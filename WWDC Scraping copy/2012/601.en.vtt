WEBVTT

00:00:10.300 --> 00:00:11.990
Hi everyone, thanks for coming out today.

00:00:12.080 --> 00:00:14.760
My name is Paul Knight,
I'm an engineer on Safari on iOS.

00:00:14.990 --> 00:00:18.760
This is Optimizing Web Content in
UIWebViews and Websites on iOS.

00:00:18.760 --> 00:00:23.720
And I want to start out by talking
about a kind of a bold assertion.

00:00:23.720 --> 00:00:27.340
The web is crucial to modern technology.

00:00:27.340 --> 00:00:31.060
I know this is like a really hard sell
to a room filled with web developers,

00:00:31.070 --> 00:00:32.310
but hear me out here.

00:00:33.420 --> 00:00:35.350
You know,
these devices that we're carrying

00:00:35.350 --> 00:00:37.480
around with us all the time,
these iPhones that we

00:00:37.480 --> 00:00:40.510
keep in our pockets,
that give us instant access to all

00:00:40.580 --> 00:00:44.870
sorts of information wherever we are,
they really change the way we work

00:00:44.950 --> 00:00:47.360
with content and work with information.

00:00:47.360 --> 00:00:51.700
And whether we're developing a
website or a standalone web app

00:00:51.700 --> 00:00:56.120
or delivering this content through
a UI WebView and a UIKit app,

00:00:56.170 --> 00:00:59.720
your users really expect
a great experience.

00:00:59.720 --> 00:01:01.800
And this is especially important on iOS.

00:01:01.800 --> 00:01:03.380
It's one of the core tenets of iOS.

00:01:03.400 --> 00:01:05.050
It's one of the core
tenets of the platform,

00:01:05.050 --> 00:01:06.500
that users want a great experience.

00:01:06.500 --> 00:01:08.800
And one of the most important
things about delivering a great

00:01:08.800 --> 00:01:10.190
experience is performance.

00:01:10.200 --> 00:01:13.290
So we're going to talk a little
bit about web content performance

00:01:13.290 --> 00:01:15.120
and optimizing your web content.

00:01:15.120 --> 00:01:18.160
We're going to start by talking
about some hidden costs and

00:01:18.170 --> 00:01:20.420
surprising slowdowns in web content.

00:01:20.420 --> 00:01:24.200
Things that look fairly obvious at first,
but when you kind of get under the

00:01:24.200 --> 00:01:27.180
hood and look at what's going on,
turn out to be really heavy

00:01:27.240 --> 00:01:28.900
in terms of implementation.

00:01:28.900 --> 00:01:33.400
We're going to look at how
WebKit takes your code.

00:01:33.400 --> 00:01:38.310
Your HTML, your CSS, your JavaScript,
and turns it into websites on the screen.

00:01:38.360 --> 00:01:41.600
We're going to actually look into
what WebKit does in a way that we've

00:01:41.600 --> 00:01:43.380
never really done before in WWDC.

00:01:43.420 --> 00:01:45.770
And we're going to talk
about some techniques for

00:01:45.770 --> 00:01:47.520
improving painting performance.

00:01:47.600 --> 00:01:49.820
And lastly,
we're saving this for the end,

00:01:49.850 --> 00:01:52.940
we've got some cool new
features in iOS 6 to talk about.

00:01:53.020 --> 00:01:56.440
Things that will improve performance in
your app and that you can use when you're

00:01:56.610 --> 00:01:58.290
working on your website and your app.

00:01:58.380 --> 00:02:02.520
So let's get started with hidden
costs and surprising slowdowns.

00:02:03.420 --> 00:02:07.230
And when I say hidden costs,
I don't mean that at Apple we're

00:02:07.230 --> 00:02:11.420
trying to hide away surprising
little performance gotchas.

00:02:11.420 --> 00:02:14.090
We're not in the hallways, "Hey Joe,
I just figured out a way to make this

00:02:14.090 --> 00:02:17.000
guy's website 50 milliseconds faster,
high five!" You know,

00:02:17.000 --> 00:02:19.420
that's not what we're talking about here.

00:02:19.420 --> 00:02:22.690
What we mean is that sometimes there
are things that when you're just

00:02:22.690 --> 00:02:26.250
staring at your HTML or your CSS,
it seems really straightforward.

00:02:26.460 --> 00:02:30.080
But in terms of what's
going on behind the scenes,

00:02:30.080 --> 00:02:31.800
there's a lot more.

00:02:31.970 --> 00:02:33.770
So there's three different
areas we're going to talk about.

00:02:33.830 --> 00:02:35.550
We're going to start with image decoding.

00:02:35.550 --> 00:02:36.880
So I have a photograph.

00:02:36.880 --> 00:02:39.130
It's 960 by 1280 pixels.

00:02:39.140 --> 00:02:40.440
It's not that large.

00:02:40.440 --> 00:02:43.380
And you know when you're
saving this photograph out from

00:02:43.380 --> 00:02:47.020
your image editing program,
there's a bunch of different options you

00:02:47.070 --> 00:02:49.280
can tweak in terms of quality and type.

00:02:49.330 --> 00:02:53.560
So we could say this is a low-quality
JPEG that might be 100 kilobytes on disk,

00:02:53.560 --> 00:02:56.080
a higher-quality JPEG,
the file's a bit larger,

00:02:56.080 --> 00:02:58.780
or we could be crazy and
save it as a lossless PNG.

00:02:58.780 --> 00:03:01.680
I hope you're not serving
this on your website.

00:03:02.000 --> 00:03:04.090
but this is an option.

00:03:05.040 --> 00:03:07.300
This is the encoded on
disk form of the image.

00:03:07.320 --> 00:03:10.190
In order to actually paint
this image onto the screen,

00:03:10.190 --> 00:03:12.310
we first have to decode it into memory.

00:03:12.310 --> 00:03:16.030
If we look at just a really small region
of this photo and blow it up a lot,

00:03:16.200 --> 00:03:18.700
all of these pixels,
every one of these pixels that

00:03:18.710 --> 00:03:22.230
make up the photograph have with
them four pieces of information.

00:03:22.450 --> 00:03:25.080
There's a red, green, blue,
and alpha component,

00:03:25.080 --> 00:03:28.060
and every one of those components
takes a byte of memory.

00:03:28.060 --> 00:03:30.750
When we take this image
and blow it up into memory,

00:03:30.750 --> 00:03:34.180
this image takes 4.7 megabytes of memory.

00:03:34.200 --> 00:03:36.610
of continuous allocated RAM.

00:03:36.640 --> 00:03:38.970
And what's really interesting is
this is true whether or not we're

00:03:39.010 --> 00:03:42.060
talking about the low quality,
100 kilobyte image on disk,

00:03:42.060 --> 00:03:46.340
or the lossless,
much larger image in the PNG format.

00:03:46.340 --> 00:03:47.920
In order to paint it,
we're going to have to

00:03:48.010 --> 00:03:50.050
decompress it into 4.7 megabytes.

00:03:50.150 --> 00:03:52.840
Width times height times 4 bytes.

00:03:52.840 --> 00:03:55.540
Now, this isn't bad, necessarily.

00:03:55.540 --> 00:03:58.640
It's simply a fact of how images work.

00:03:58.640 --> 00:04:01.060
And it's worth keeping
in the back of our minds.

00:04:01.060 --> 00:04:04.210
So, for example,
let's take a look at-- this

00:04:04.210 --> 00:04:06.740
is the iPad user guide manual.

00:04:06.740 --> 00:04:09.370
It's a web app,
and we have all these images

00:04:09.430 --> 00:04:15.100
on the left side of the screen,
the sort of chapter icons.

00:04:15.170 --> 00:04:17.900
And we could download all of
these images individually,

00:04:17.900 --> 00:04:19.930
all 20-something images.

00:04:20.190 --> 00:04:23.250
But we're trying to minimize
HTTP requests and the overhead

00:04:23.250 --> 00:04:24.930
associated with loading this page.

00:04:25.020 --> 00:04:27.620
And one really popular technique for
doing that is taking all of these

00:04:27.680 --> 00:04:32.370
individual images or sprites and
stitching them into one sprite sheet,

00:04:32.550 --> 00:04:34.450
one image that we can download.

00:04:34.540 --> 00:04:36.540
And in order to show just
a part of this image,

00:04:36.540 --> 00:04:38.400
we use a little bit of CSS trickery.

00:04:38.600 --> 00:04:41.680
We have our element set its
width and height to the size of

00:04:41.680 --> 00:04:44.520
the sprite we're trying to show,
and then use background position

00:04:44.520 --> 00:04:50.040
to slide the image around
behind the actual element.

00:04:50.100 --> 00:04:52.760
And this is a great technique
for reducing the number of

00:04:52.760 --> 00:04:56.080
individual downloads that you
need in order to load your page.

00:04:56.130 --> 00:04:59.440
But if your sprite sheet looks
like this-- and so we're not

00:04:59.690 --> 00:05:02.660
trying to point any fingers,
Ted.

00:05:03.480 --> 00:05:05.490
We're not trying to point any fingers.

00:05:05.500 --> 00:05:09.380
So what I've done is I've taken this
real sprite sheet from a popular website,

00:05:09.390 --> 00:05:12.100
probably several hundred
thousand uniques per day,

00:05:12.100 --> 00:05:14.980
and I've colored the areas
that are actually being used,

00:05:14.980 --> 00:05:17.080
the areas of this image with image data.

00:05:17.080 --> 00:05:18.280
They're colored red.

00:05:18.280 --> 00:05:21.460
And then the rest of the image has
that sort of tiny gray and white

00:05:21.460 --> 00:05:24.280
transparent checkerboard showing through.

00:05:24.280 --> 00:05:26.410
And this image is not that big on disk.

00:05:26.550 --> 00:05:30.600
The data that gets transferred over
the network is only 28 kilobytes.

00:05:30.600 --> 00:05:33.990
But when we decode this
image into RAM for painting,

00:05:33.990 --> 00:05:36.940
it requires 5.7 megabytes of RAM.

00:05:36.980 --> 00:05:38.200
That is a lot of memory.

00:05:38.200 --> 00:05:42.290
And if we were to take this image
and sort of repack it by hand,

00:05:42.290 --> 00:05:44.700
we could do it into a much smaller image.

00:05:44.800 --> 00:05:47.000
So small I'm going to actually
scale it up a little bit.

00:05:47.000 --> 00:05:51.600
Whereas this old image
was 84% unused space,

00:05:51.600 --> 00:05:54.500
this new image is only 5% unused space.

00:05:54.700 --> 00:05:56.600
And the size on disk
doesn't really change.

00:05:56.600 --> 00:05:58.510
This doesn't affect the
download speed at all.

00:05:58.650 --> 00:06:01.040
But what it changes is the
amount of RAM we need to

00:06:01.040 --> 00:06:02.600
actually draw this on the screen.

00:06:02.600 --> 00:06:06.480
And this is not just a high score thing.

00:06:06.550 --> 00:06:10.340
We're not trying to get down our RAM,
the amount of used RAM down just

00:06:10.340 --> 00:06:12.090
because it's a number we can brag about.

00:06:12.090 --> 00:06:16.900
When the system is under memory pressure,
the system behaves worse overall.

00:06:16.900 --> 00:06:19.270
The JavaScript collector is
going to have to run more often,

00:06:19.270 --> 00:06:21.100
introducing pauses in your application.

00:06:21.100 --> 00:06:23.980
Other applications are going
to be exited more often.

00:06:23.980 --> 00:06:28.100
You're going to get memory warnings
in your UI application more often.

00:06:28.100 --> 00:06:30.460
The overall user experience is worse.

00:06:30.460 --> 00:06:33.170
In the worst case,
your app might even get killed

00:06:33.240 --> 00:06:35.400
for using too much memory.

00:06:35.820 --> 00:06:38.390
Now you might be thinking to yourself,
"Hey, Paul, you know,

00:06:38.390 --> 00:06:41.310
this is just..." No,
most of you have already

00:06:41.310 --> 00:06:42.200
forgotten my name.

00:06:42.200 --> 00:06:43.180
And that's okay.

00:06:43.180 --> 00:06:46.100
So you're probably thinking to yourself,
"Hey, guy on stage,

00:06:46.100 --> 00:06:48.850
this is just like one example, right?

00:06:48.890 --> 00:06:52.040
People aren't doing this all over
the place." These are all real

00:06:52.040 --> 00:06:55.330
sprite sheets that we've collected
from real popular websites.

00:06:55.450 --> 00:06:58.980
The one on the far left
is my particular favorite,

00:06:58.980 --> 00:07:01.270
99.7% empty space.

00:07:01.320 --> 00:07:07.890
These are real savings in RAM that we
can get just by repacking these images.

00:07:08.090 --> 00:07:09.260
So, image decoding.

00:07:09.500 --> 00:07:11.130
They have a cost associated with them.

00:07:11.200 --> 00:07:13.830
There's the size of an image on disk,
but there's also the

00:07:13.830 --> 00:07:15.260
decoded size of the image.

00:07:15.260 --> 00:07:18.460
And you can get a rough estimate of that
by taking the width times the height,

00:07:18.460 --> 00:07:19.990
multiplying that by four bytes.

00:07:20.000 --> 00:07:23.120
Avoid wasted space in your sprite
sheet that's just memory that

00:07:23.180 --> 00:07:24.780
you're not going to be using.

00:07:24.780 --> 00:07:27.600
And as a more general rule,
avoid using images that

00:07:27.600 --> 00:07:29.200
are larger than you need.

00:07:29.200 --> 00:07:33.400
Don't download a 1,000 by 1,000
image if you're just going to display

00:07:33.400 --> 00:07:35.890
that at 250 by 250 pixels on screen.

00:07:36.300 --> 00:07:38.790
And likewise,
don't download high DPI content

00:07:38.790 --> 00:07:40.300
for non-retina devices.

00:07:40.300 --> 00:07:42.830
In fact,
if you want some good ways to do that,

00:07:42.830 --> 00:07:46.630
there's going to be a session later
this week on just high DPI content,

00:07:46.630 --> 00:07:50.300
and there's some really cool new
stuff that you can use for that.

00:07:50.710 --> 00:07:54.690
So that is our first area of
hidden costs image decoding.

00:07:54.720 --> 00:07:56.890
Next,
let's talk about JavaScript loading.

00:07:56.890 --> 00:07:59.800
So images are just one kind
of resource on your site.

00:07:59.800 --> 00:08:01.740
You also have a bunch
of JavaScript files.

00:08:01.750 --> 00:08:05.070
And in this particular example,
I've got four scripts up here.

00:08:05.170 --> 00:08:08.520
And when I load this page,
when I pull out my phone and

00:08:08.520 --> 00:08:12.430
I'm on a cellular network,
I tap on a link to load this page,

00:08:12.430 --> 00:08:15.800
it sure feels like it
takes a long time to load.

00:08:15.800 --> 00:08:19.310
In fact, it feels like nothing is
happening for like 14 seconds.

00:08:20.040 --> 00:08:25.510
The progress bar is filling up,
but nothing else is happening on screen.

00:08:25.830 --> 00:08:28.930
So we can use the new
Web Inspector for iOS.

00:08:29.010 --> 00:08:32.870
And if you haven't heard about this yet,
the Web Inspector works on iOS.

00:08:32.910 --> 00:08:36.930
You can take on a Mac computer,
open up a Web Inspector and

00:08:37.010 --> 00:08:39.040
attach it to an iOS device.

00:08:39.040 --> 00:08:40.280
This is really cool.

00:08:40.280 --> 00:08:47.330
There was a session about this just
a few minutes ago in this room.

00:08:47.330 --> 00:08:47.710
But if you missed that,
you can come by the labs and

00:08:47.710 --> 00:08:47.710
we'll get you up to speed.

00:08:48.270 --> 00:08:52.190
So in the instrument navigator,
it's called on the top left,

00:08:52.250 --> 00:08:56.980
it's the third navigator,
there's this network requests timeline.

00:08:56.980 --> 00:09:00.970
And in here, we get a really nice sort of
waterfall timeline view of all of the

00:09:00.970 --> 00:09:04.340
resources that we're trying to load,
when they start loading,

00:09:04.340 --> 00:09:07.630
when we get the first byte of
information back from the server,

00:09:07.670 --> 00:09:10.200
and when that resource finishes loading.

00:09:10.840 --> 00:09:13.930
And we don't get a really complete
picture of why it feels like

00:09:13.930 --> 00:09:17.660
nothing is happening when we're
loading our app just from this view.

00:09:17.660 --> 00:09:19.740
There's a couple things worth mentioning.

00:09:19.740 --> 00:09:21.340
There's this red line right at the end.

00:09:21.340 --> 00:09:24.710
This is when the onload event fires,
when all the sub-resources

00:09:24.710 --> 00:09:26.440
on the page have been loaded.

00:09:26.440 --> 00:09:28.900
And there's this one sort
of suspicious-looking

00:09:28.980 --> 00:09:30.640
JavaScript file at the bottom.

00:09:30.650 --> 00:09:33.890
It's got a 12-second latency,
12 seconds between when

00:09:33.940 --> 00:09:36.960
WebKit first asks for this resource,
and we finally get one

00:09:37.030 --> 00:09:38.680
byte back from the server.

00:09:38.680 --> 00:09:40.700
Now, this seems like a lot.

00:09:40.840 --> 00:09:41.840
This almost seems impossible.

00:09:41.840 --> 00:09:45.080
But on a cellular connection,
latency measured in the seconds

00:09:45.080 --> 00:09:46.480
is pretty much the norm.

00:09:46.500 --> 00:09:49.870
And if this is maybe another
server hosted by a third party,

00:09:49.870 --> 00:09:53.070
and it's really slow today,
they're under a lot of load,

00:09:53.100 --> 00:09:55.560
you might see really high latencies.

00:09:55.560 --> 00:09:59.790
And maybe we're getting the feeling that
this one script is actually preventing

00:09:59.790 --> 00:10:01.630
the page from rendering at all.

00:10:01.660 --> 00:10:05.160
In the layout and rendering
timeline in the Web Inspector,

00:10:05.160 --> 00:10:06.540
we get a list of events.

00:10:06.660 --> 00:10:10.660
And the interesting thing here is
that we're seeing a painting event.

00:10:10.840 --> 00:10:14.960
But they're only happening right at the
end of the load after 14 seconds or so.

00:10:15.000 --> 00:10:16.190
All right.

00:10:16.490 --> 00:10:18.740
So what's going on?

00:10:18.770 --> 00:10:22.630
It turns out that the way HTML works,
the way the HTML and

00:10:22.630 --> 00:10:27.120
JavaScript execution model works is
that JavaScript will pause parsing.

00:10:27.120 --> 00:10:30.570
So you have your HTML parser,
you have an HTML document,

00:10:30.570 --> 00:10:32.320
and the parser starts at the top.

00:10:32.340 --> 00:10:35.930
It reads the doc type, HTML tag,
head tag, title tag,

00:10:35.940 --> 00:10:38.120
and then it gets to a script tag.

00:10:38.150 --> 00:10:42.970
And the parser has to stop and wait
until all of the JavaScript in that

00:10:42.970 --> 00:10:45.920
script tag has been fully downloaded.

00:10:45.920 --> 00:10:49.780
Then the JavaScript executes immediately,
and then the parser keeps going.

00:10:49.780 --> 00:10:53.740
Meta tag, link tag, script tag,
and it stops again until all of that

00:10:53.940 --> 00:10:56.130
JavaScript has finished downloading.

00:10:56.130 --> 00:10:58.640
And this is just sort of a fact.

00:10:58.700 --> 00:11:02.150
It's the way things
are specified to work.

00:11:02.160 --> 00:11:06.960
It's how JavaScript expects
to run inside of web content.

00:11:08.670 --> 00:11:09.800
So we want to avoid this.

00:11:09.800 --> 00:11:13.940
We want to avoid this synchronous
JavaScript loading behavior.

00:11:13.940 --> 00:11:18.080
And there's two attributes we can put
on our script tags to use either an

00:11:18.080 --> 00:11:20.930
asynchronous or deferred execution model.

00:11:20.960 --> 00:11:23.620
The idea behind both of these
is the download for that

00:11:23.620 --> 00:11:26.710
JavaScript begins immediately,
and it doesn't block.

00:11:26.790 --> 00:11:30.920
So the HTML parser keeps going
down and builds the DOM tree and

00:11:31.050 --> 00:11:33.490
sets everything up on the page.

00:11:33.750 --> 00:11:36.080
If you add the async
attribute to a script,

00:11:36.080 --> 00:11:39.340
they're going to be executed
as soon as they're loaded.

00:11:39.340 --> 00:11:42.690
So the download kicks off immediately,
and whenever that JavaScript file

00:11:42.690 --> 00:11:44.890
is fully downloaded,
that's when it's run.

00:11:44.900 --> 00:11:46.410
It's run at the next good opportunity.

00:11:46.420 --> 00:11:50.760
Deferred scripts, on the other hand,
make a guarantee for the order

00:11:50.760 --> 00:11:52.200
of execution of the scripts.

00:11:52.200 --> 00:11:55.610
So deferred scripts will always
be executed in the order that

00:11:55.650 --> 00:11:59.360
they're listed in the HTML,
and they're always executed

00:11:59.400 --> 00:12:01.880
just before DOM content loaded.

00:12:01.880 --> 00:12:04.240
So that means DOM content
loaded is delayed until all

00:12:04.240 --> 00:12:07.720
of your deferred scripts run,
but sometimes you need to make

00:12:07.720 --> 00:12:09.850
guarantees about the order.

00:12:10.180 --> 00:12:14.160
So going back to my few scripts here in
my page that's taking forever to load,

00:12:14.160 --> 00:12:18.380
these first three scripts,
I need them to run in a certain order.

00:12:18.380 --> 00:12:19.720
They're dependencies of each other.

00:12:19.720 --> 00:12:21.790
They expect certain objects
to have been constructed.

00:12:21.790 --> 00:12:24.530
But this last one,
I don't care when it runs.

00:12:24.530 --> 00:12:28.060
As long as it runs sometime,
that's good enough for me.

00:12:28.080 --> 00:12:31.460
So I'll add the defer attribute
to the first three and the async

00:12:31.560 --> 00:12:33.270
attribute to the fourth one.

00:12:33.270 --> 00:12:35.810
And if we reload and
look at the timeline,

00:12:35.900 --> 00:12:38.760
the timeline looks a
little bit different.

00:12:39.230 --> 00:12:41.590
There's still the
onload event at the end,

00:12:41.590 --> 00:12:44.120
and now there's this
new blue dotted line.

00:12:44.120 --> 00:12:46.330
This is when DOM content ready fires.

00:12:46.330 --> 00:12:49.070
But more importantly,
if we look at the layout

00:12:49.190 --> 00:12:52.800
and rendering timeline,
the first paint happens just four

00:12:52.800 --> 00:12:55.030
and a half seconds into the load.

00:12:55.030 --> 00:12:57.940
That's because the parser was able to
get all the way through the document.

00:12:57.940 --> 00:13:01.990
We were able to load enough resources to
actually draw something on the screen.

00:13:02.000 --> 00:13:04.620
And even better,
there are several more painting

00:13:04.620 --> 00:13:08.340
events as more content is loaded,
as those images start to come in.

00:13:08.340 --> 00:13:11.300
And we sort of incrementally
render the page.

00:13:11.400 --> 00:13:13.490
This is a much better user experience.

00:13:13.670 --> 00:13:17.580
Even though the page doesn't load
any faster necessarily total,

00:13:17.580 --> 00:13:21.860
the first time we paint the page
happens much earlier and the user

00:13:21.860 --> 00:13:24.530
can start interacting with the page.

00:13:24.720 --> 00:13:28.100
And there's one more thing I want to
talk about with JavaScript loading.

00:13:28.100 --> 00:13:31.250
And that's,
we've seen a lot of JavaScript libraries,

00:13:31.250 --> 00:13:34.670
a sort of pattern where you
include one script at the top,

00:13:34.670 --> 00:13:38.990
and then that script will load all
of its dependencies and plugins,

00:13:39.190 --> 00:13:43.850
either by dynamically inserting script
tags or using XML HTTP requests.

00:13:44.460 --> 00:13:46.690
And if you do that,
you end up with a picture that

00:13:46.740 --> 00:13:48.200
looks something like this.

00:13:48.200 --> 00:13:51.640
You end up with this staggered
stair-step waterfall.

00:13:51.640 --> 00:13:54.670
Because we don't know that you
need any of these dependencies,

00:13:54.670 --> 00:13:57.480
any of these other resources,
until we finish loading the

00:13:57.480 --> 00:13:59.050
first top-level resource.

00:13:59.060 --> 00:14:01.640
And remember,
we're talking about cellular

00:14:01.640 --> 00:14:05.120
data connections where latencies
are measured in seconds.

00:14:05.240 --> 00:14:08.960
So every single time a resource
is chained onto another resource,

00:14:09.070 --> 00:14:12.620
that adds multiple seconds to
the total page loading time.

00:14:13.480 --> 00:14:17.450
Instead, it's much better to just list
all of the resources you need,

00:14:17.450 --> 00:14:20.930
all of the stylesheets, images,
CSS files in your HTML.

00:14:20.930 --> 00:14:24.690
And then we'll be able to start
downloading them immediately.

00:14:25.200 --> 00:17:44.800
[Transcript missing]

00:17:46.100 --> 00:17:47.950
If you need to know
when the DOM is ready,

00:17:47.960 --> 00:17:51.600
there's been a lot of confusion over
which browsers support which events.

00:17:51.620 --> 00:17:55.250
These days, DOMContentReady is a
standard DOM-specified method

00:17:55.330 --> 00:17:56.860
that's part of the spec.

00:17:56.930 --> 00:18:03.890
So you can use DOMContentReady
to know when it's safe to start

00:18:03.890 --> 00:18:03.890
attaching all of your event
listeners and manipulating the DOM.

00:18:04.360 --> 00:18:07.210
And if you're looking for
the position of an element,

00:18:07.210 --> 00:18:10.320
instead of like taking an
element's offset top and adding

00:18:10.380 --> 00:18:13.220
it to its parent's offset top,
and again, to its parent's offset top,

00:18:13.220 --> 00:18:15.850
and walking the entire chain,
there's these methods,

00:18:16.050 --> 00:18:18.710
get bounding client rect,
and that returns a rect object with

00:18:18.730 --> 00:18:20.520
all of the geometry information.

00:18:20.520 --> 00:18:22.600
It's really fast.

00:18:22.870 --> 00:18:24.700
So there's a lot of
built-in power to the DOM.

00:18:24.700 --> 00:18:27.220
This is just a sample of what
the DOM can do these days.

00:18:27.220 --> 00:18:30.550
So if we're looking to these
libraries maybe to round out what

00:18:30.550 --> 00:18:34.470
we think are missing features,
maybe they're not missing anymore.

00:18:34.480 --> 00:18:35.830
It's worth taking a look at.

00:18:35.890 --> 00:18:38.610
And in general,
the challenge I'm sort of making is,

00:18:38.610 --> 00:18:40.940
if you don't need the
JavaScript framework,

00:18:40.940 --> 00:18:42.210
try getting rid of it.

00:18:42.280 --> 00:18:43.860
They're very large resources.

00:18:43.860 --> 00:18:46.560
They cause a tremendous
amount of memory allocation.

00:18:47.760 --> 00:18:49.460
Again,
if you're using it for good reason,

00:18:49.460 --> 00:18:52.150
cross-browser compatibility
or something like that,

00:18:52.160 --> 00:18:52.990
by all means use it.

00:18:53.060 --> 00:18:53.880
They're great tools.

00:18:53.990 --> 00:18:57.940
But if you're just loading some
resources out of your application bundle,

00:18:58.070 --> 00:19:00.490
maybe it's time to reevaluate your usage.

00:19:01.330 --> 00:19:04.980
So that's the second area of hidden
costs and surprising slowdowns,

00:19:05.020 --> 00:19:06.440
JavaScript loading.

00:19:06.440 --> 00:19:10.470
And the last one I want to talk
about is layout calculation.

00:19:12.100 --> 00:19:14.060
So I have this web page.

00:19:14.060 --> 00:19:16.280
It has about 500 elements in it.

00:19:16.280 --> 00:19:18.720
And when I tap on this
button on the web page,

00:19:18.720 --> 00:19:23.020
I want to increase the height of
all of these elements by 10 pixels.

00:19:23.140 --> 00:19:27.570
So I use querySelectorAll
to get all of the things.

00:19:27.760 --> 00:19:31.320
And then for each one of the things,
I grabbed the offset height

00:19:31.320 --> 00:19:35.380
and then just set an inline
style that's 10 pixels taller.

00:19:35.440 --> 00:19:37.920
It's a little silly, but it works.

00:19:38.070 --> 00:19:39.700
Except it works really slowly.

00:19:39.770 --> 00:19:42.250
In fact,
I tried this on my iPad the other day,

00:19:42.250 --> 00:19:47.090
and it took almost 700 milliseconds
to go through these 500 elements.

00:19:47.200 --> 00:20:05.800
[Transcript missing]

00:20:05.860 --> 00:20:07.490
Well,
it turns out in this line where we ask

00:20:07.490 --> 00:20:10.650
for the offset height of the element,
we're asking for the current

00:20:10.650 --> 00:20:14.170
calculated up-to-date layout
information about the element.

00:20:14.200 --> 00:20:16.650
We're asking,
what is its height right now?

00:20:16.680 --> 00:20:20.180
And then in the very next line,
when we change the height,

00:20:20.180 --> 00:20:25.020
we invalidate all of the current
up-to-date calculated style information.

00:20:25.700 --> 00:20:28.280
And so the next time through
the loop for the second element,

00:20:28.280 --> 00:20:30.400
WebKit is going to have
to re-layout the page.

00:20:30.430 --> 00:20:33.190
It's going to have to make sure
that nothing else is moved around

00:20:33.190 --> 00:20:36.080
and that when it returns the offset
height for the second element,

00:20:36.080 --> 00:20:38.100
that is still up-to-date and accurate.

00:20:38.100 --> 00:20:39.420
And we keep doing this.

00:20:39.420 --> 00:20:42.110
We keep invalidating the
current layout information,

00:20:42.110 --> 00:20:44.310
then forcing the current
layout information,

00:20:44.310 --> 00:20:46.450
invalidating it,
and forcing the layout over

00:20:46.460 --> 00:20:47.770
and over and over again.

00:20:47.800 --> 00:20:50.550
So it's going to look a little bit silly.

00:20:51.200 --> 00:20:54.180
But instead, if we create an array,
went through all of the elements

00:20:54.180 --> 00:20:57.550
and pulled out the heights at once,
and then in another loop,

00:20:57.550 --> 00:21:02.140
updated all of the elements at once,
the code runs faster.

00:21:02.200 --> 00:21:04.900
In fact, it runs almost 100 times faster.

00:21:04.960 --> 00:21:09.490
And the best part is, in the events list,
there's just one recalculate styles,

00:21:09.490 --> 00:21:11.990
one layout, and then all the painting.

00:21:12.000 --> 00:21:14.720
That's exactly what we're looking for.

00:21:15.090 --> 00:21:18.560
So it's usually fairly obvious when we're
invalidating current layout information,

00:21:18.560 --> 00:21:22.760
adding or removing a class,
inserting a style tag,

00:21:22.760 --> 00:21:27.490
manipulating the DOM,
or inserting an inline style element.

00:21:27.520 --> 00:21:30.800
But what's often not so obvious
is what methods require up-to-date

00:21:30.800 --> 00:21:32.670
and current layout information.

00:21:32.680 --> 00:21:36.290
So if a method has either
client or offset in its name,

00:21:36.400 --> 00:21:41.860
that's a really good sign that it could
force a layout if layout is out of date.

00:21:42.780 --> 00:21:47.100
GetComputedStyle, GetPropertyCSSValue,
of course, they're explicitly asking for

00:21:47.150 --> 00:21:48.820
the up-to-date style information.

00:21:48.820 --> 00:21:52.160
But there are a couple methods
that aren't so obvious.

00:21:52.160 --> 00:21:56.000
InnerText is one of them, actually,
because InnerText is not going to

00:21:56.000 --> 00:21:59.330
include any text that is inside of
an element with display none set.

00:21:59.400 --> 00:22:02.850
So it needs current
up-to-date style information,

00:22:02.850 --> 00:22:04.910
and it could force a layout.

00:22:05.760 --> 00:22:08.460
So avoiding unnecessary layout.

00:22:08.460 --> 00:22:09.940
Use the Web Inspector timeline.

00:22:09.940 --> 00:22:11.900
It'll show you when
layouts are occurring,

00:22:11.900 --> 00:22:15.670
when we're recalculating styles,
and you can figure out if maybe there's

00:22:15.670 --> 00:22:19.700
a section of your JavaScript code
that is forcing layout unnecessarily.

00:22:19.700 --> 00:22:24.180
Operations that need current style
information will force a layout.

00:22:24.180 --> 00:22:28.380
And if you're finding that
you're forcing layout too often,

00:22:28.380 --> 00:22:31.640
try batching all of the changes
that are updating style information

00:22:31.640 --> 00:22:33.520
towards the end of your JavaScript.

00:22:33.580 --> 00:22:37.690
that will make a huge difference in
the speed of some of your methods.

00:22:38.510 --> 00:22:42.340
And that is the third area of hidden
costs and surprising slowdowns.

00:22:42.340 --> 00:22:44.960
But we are really just sort of
scratching the surface here.

00:22:44.960 --> 00:22:48.290
These are just like the first
couple of things to look at.

00:22:48.340 --> 00:22:51.800
If we want a really good understanding
of how we can improve painting

00:22:51.900 --> 00:22:55.560
performance and understanding what
WebKit is doing behind the scenes,

00:22:55.560 --> 00:22:59.780
we're going to need to peel back a few
more layers and look a little bit deeper.

00:22:59.780 --> 00:23:03.240
And to do that, I'm going to turn things
over to my colleague,

00:23:03.250 --> 00:23:06.030
Joseph Pecoraro,
who's going to talk a little bit

00:23:06.090 --> 00:23:08.400
about layers and WebKit rendering.

00:23:09.700 --> 00:26:48.200
[Transcript missing]

00:26:48.650 --> 00:26:53.880
So we can easily create this page and
with the body controls when we need them.

00:26:54.010 --> 00:26:56.290
But that's not the
whole story to painting.

00:26:56.300 --> 00:27:00.700
We don't want to paint the
entire page all the time.

00:27:00.700 --> 00:27:03.950
Take this page, for instance,
that video is going to be updating on

00:27:03.950 --> 00:27:06.140
the screen constantly if it's playing.

00:27:06.240 --> 00:27:08.540
So the best thing we can do,
and this is what WebKit does,

00:27:08.540 --> 00:27:12.050
is it cuts out a portion of the
screen and hands it to the video

00:27:12.330 --> 00:27:15.560
renderer and says paint the video here.

00:27:15.560 --> 00:27:16.560
This is great.

00:27:16.560 --> 00:27:19.430
It can update as frequently
as it wants without the page

00:27:19.430 --> 00:27:20.940
having to worry about it.

00:27:20.940 --> 00:27:23.960
WebKit does have to remember
to take the video controls,

00:27:24.170 --> 00:27:27.670
group them in their own box,
and paint them on top of the

00:27:28.030 --> 00:27:31.060
video when they need to display.

00:27:31.060 --> 00:27:33.180
And I think you can see
where I'm going with this.

00:27:33.180 --> 00:27:37.520
These are the layers that WebKit is
managing under the hood for the page.

00:27:37.520 --> 00:27:40.640
So to give you a better
visualization of that,

00:27:40.640 --> 00:27:43.220
here's the page as we as users see it.

00:27:43.240 --> 00:27:46.420
But under the hood,
WebKit has taken that video.

00:27:46.420 --> 00:27:50.120
It's going to push it into content
that's floating on top of the page.

00:27:50.120 --> 00:27:53.680
And the button controls,
when they need to be displayed,

00:27:53.680 --> 00:27:56.720
are again in another layer
that's sitting on top.

00:27:56.720 --> 00:27:57.900
And this really is a layer.

00:27:58.050 --> 00:28:03.180
It's got a width, a height, dimensions,
and painted content.

00:28:03.860 --> 00:28:06.820
So, to finish this painting story,
when we have layers,

00:28:06.820 --> 00:28:10.790
what we're going to do is we're going
to flatten them into a single image.

00:28:10.790 --> 00:28:12.230
This is called compositing.

00:28:12.230 --> 00:28:14.750
It's something that the
GPU does really well,

00:28:14.850 --> 00:28:18.360
and it's something that we'll see more,
and it's one of the reasons

00:28:18.360 --> 00:28:21.570
why using layers is efficient
for painting and animation,

00:28:21.590 --> 00:28:23.860
because we can composite so quickly.

00:28:24.060 --> 00:28:27.250
So, WebKit has a number of
different types of layers.

00:28:27.250 --> 00:28:31.600
What normally distinguishes them is
whether or not they have a backing

00:28:31.600 --> 00:28:34.300
store and the size of the backing store.

00:28:34.300 --> 00:28:37.300
So, in this example,
those video controls that were

00:28:37.300 --> 00:28:40.860
floating on top are a small
layer with a small backing store.

00:28:40.860 --> 00:28:45.280
That backing store is a memory allocation
that contains image pixel data.

00:28:45.280 --> 00:28:46.840
It's got a width and a height.

00:28:46.940 --> 00:28:51.320
It's exactly like the decoded data of
images that Paul talked about earlier.

00:28:51.320 --> 00:28:53.620
It is the painted contents.

00:28:53.970 --> 00:29:00.780
So, when we have that painted content,
we can do some really cool stuff with it.

00:29:00.820 --> 00:29:03.590
We can send that image to
the GPU as a texture and

00:29:03.590 --> 00:29:07.970
manipulate the GPU efficiently,
things like transforms, rotation,

00:29:08.080 --> 00:29:12.730
scaling, opacity to take advantage of
blending with background layers.

00:29:14.700 --> 00:29:15.310
This is great.

00:29:15.390 --> 00:29:17.400
This is called hardware acceleration.

00:29:17.400 --> 00:29:20.240
This is how we can get
animations to work so smoothly.

00:29:20.240 --> 00:29:23.130
But of course,
back-end stores have a cost,

00:29:23.230 --> 00:29:24.900
and that cost is memory.

00:29:25.310 --> 00:29:30.670
So if you have a 100x100 CSS pixel div,
about 40,000 bytes,

00:29:30.720 --> 00:29:35.440
the back-end store might actually be
a lot larger depending on your device

00:29:35.610 --> 00:29:37.800
or how the WebView is displayed.

00:29:37.800 --> 00:29:40.600
So on a retina device,
the high DPI device,

00:29:40.600 --> 00:29:44.260
there are two device pixels
for each single CSS pixel.

00:29:44.260 --> 00:29:48.750
So we've doubled the dimensions
of the back-end store to 200x200,

00:29:48.750 --> 00:29:50.500
or about four times larger.

00:29:50.860 --> 00:29:54.550
And if you zoom in on
the web page to say 2x,

00:29:54.550 --> 00:29:57.740
we've again doubled the dimensions
necessary for the back-end store.

00:29:57.740 --> 00:30:03.270
And as back-end stores get really large,
WebKit's going to potentially

00:30:03.280 --> 00:30:05.290
use up too much memory.

00:30:05.300 --> 00:30:08.780
So it's going to mitigate that
risk of using too much memory and

00:30:08.910 --> 00:30:12.710
create a different kind of layer,
which we call tile layers,

00:30:13.140 --> 00:30:14.420
for large layers.

00:30:14.440 --> 00:30:16.740
It's going to break it up
and paint it in pieces.

00:30:16.740 --> 00:30:20.740
And there's always one case
where there's a problem.

00:30:20.800 --> 00:30:22.980
It's a tile layer,
and that's the main page's content.

00:30:22.980 --> 00:30:24.490
I think you can see why.

00:30:24.500 --> 00:30:28.210
I'm sure you've all gone to a page
where if you scroll to the bottom,

00:30:28.410 --> 00:30:29.950
new content gets loaded in.

00:30:30.000 --> 00:30:32.320
And you scroll again,
new content gets loaded.

00:30:32.320 --> 00:30:34.540
You could have an infinitely large page.

00:30:34.540 --> 00:30:38.270
WebKit's not going to create
one large layer to store all of

00:30:38.270 --> 00:30:40.360
the painted contents of that.

00:30:40.380 --> 00:30:42.300
Instead, it's going to optimize.

00:30:42.300 --> 00:30:45.410
It's going to paint only the
visible portions of the layer,

00:30:45.410 --> 00:30:48.500
and it's going to paint it
in smaller back-end stores.

00:30:48.500 --> 00:30:49.940
That's what these tiles are.

00:30:51.590 --> 00:30:55.440
So we know a couple of the different
types of layers that WebKit creates.

00:30:55.460 --> 00:30:57.880
How do they get created?

00:30:57.900 --> 00:31:03.620
What's the cause in HTML and styles
that causes these layers to be made?

00:31:03.620 --> 00:31:06.310
So there's always that one
tiled layer for the main page.

00:31:06.430 --> 00:31:09.050
That's where content draws
if it draws nowhere else.

00:31:09.070 --> 00:31:11.520
But the rest is all elements and styles.

00:31:11.580 --> 00:31:15.130
So elements that paint frequently,
things like video or canvas,

00:31:15.250 --> 00:31:16.600
those will get a layer.

00:31:17.680 --> 00:31:21.250
3D transformations,
things that the GPU has been

00:31:21.250 --> 00:31:26.260
optimized for for years,
rotation, translation.

00:31:26.310 --> 00:31:29.200
It's important to note
here that these transforms,

00:31:29.280 --> 00:31:33.220
anything with the WebKit transform style,
are only affecting how the

00:31:33.220 --> 00:31:34.730
element is painted on the page.

00:31:34.800 --> 00:31:36.680
It doesn't affect how it's laid out.

00:31:36.810 --> 00:31:39.380
It doesn't move the position
of the element and cause a

00:31:39.380 --> 00:31:41.390
recalculate style and relay out.

00:31:41.630 --> 00:31:46.980
This is why it's so efficient
to do transforms for animations.

00:31:47.450 --> 00:31:57.570
Any other enhancements to content,
things like opacity, reflections,

00:31:57.570 --> 00:31:57.570
animations, transitions,
these may cause layers,

00:31:57.570 --> 00:31:57.570
and in most cases, they do.

00:31:58.370 --> 00:32:00.950
Special cases where content
moves separately from the

00:32:01.040 --> 00:32:02.420
content of the main page.

00:32:02.420 --> 00:32:06.800
So on iOS it would be position
fixed content or touch scrolling.

00:32:06.800 --> 00:32:09.490
And finally,
and this is sometimes the gotcha,

00:32:09.600 --> 00:32:12.760
is any content that overlaps
other content in a layer.

00:32:12.760 --> 00:32:15.220
So if we think back to
the original example,

00:32:15.220 --> 00:32:18.350
the video controls were
displaying on top of the video,

00:32:18.350 --> 00:32:21.190
so they needed to be pushed
into a layer in order for the

00:32:21.350 --> 00:32:23.140
page to be drawn properly.

00:32:23.640 --> 00:32:27.040
So there are a number of tools that
you can use for quickly editing

00:32:27.040 --> 00:32:29.270
your page and measuring performance.

00:32:29.270 --> 00:32:31.720
I'm going to walk through
some now and then do a demo.

00:32:31.720 --> 00:32:34.140
So the Web Inspector, really powerful.

00:32:34.140 --> 00:32:35.510
There's so much it can do.

00:32:35.680 --> 00:32:38.920
Here we're going to narrow
in on just editing styles.

00:32:38.920 --> 00:32:42.300
So you can tweak the styles
of some particular element.

00:32:42.300 --> 00:32:47.420
My favorite thing to do is open
up the style sidebar and check on

00:32:47.590 --> 00:32:53.560
or off an individual style to see
exactly how that affects the page.

00:32:53.660 --> 00:32:55.140
And then you can see the
performance on the page.

00:32:55.140 --> 00:32:58.990
You don't have to go back to Xcode,
tweak your app and run it again.

00:32:59.230 --> 00:33:02.100
You can just do it all on the fly.

00:33:02.400 --> 00:33:05.530
WebKit sits on top of the
platform graphic libraries

00:33:05.530 --> 00:33:07.770
Core Animation and Core Graphics.

00:33:07.770 --> 00:33:10.700
So the instruments,
the native debugging tools

00:33:10.700 --> 00:33:14.260
that work with those will work
just fine with web content.

00:33:14.260 --> 00:33:17.610
Core Animation has an instrument
where you can turn on certain

00:33:17.610 --> 00:33:21.040
debug options like show blended
layers or flash screen updates,

00:33:21.160 --> 00:33:25.090
and that will work just fine with
web content to measure performance.

00:33:25.140 --> 00:33:29.480
If you want to measure the memory
performance and cost of the layers,

00:33:29.480 --> 00:33:31.500
there is the VM Tracker instrument.

00:33:31.500 --> 00:33:34.110
If you use this and take
a snapshot of the page,

00:33:34.110 --> 00:33:37.520
you can see the different
malloc zones and their sizes.

00:33:37.520 --> 00:33:40.060
Make a change to the page,
take another snapshot,

00:33:40.200 --> 00:33:42.360
and you can see how it changes over time.

00:33:42.370 --> 00:33:47.570
The WebKit backing store allocations
show up under the I/O Kit malloc zone.

00:33:47.620 --> 00:33:52.090
And finally, what we'll spend the time
in the demo talking about is

00:33:52.170 --> 00:33:54.180
WebKit's own debug setting.

00:33:54.660 --> 00:33:57.900
So there's a user default,
WebKit show debug border.

00:33:57.910 --> 00:34:00.640
If you set this on your
application and relaunch it,

00:34:00.640 --> 00:34:06.110
whenever it paints web content, it will,
if there's a layer,

00:34:06.130 --> 00:34:09.280
paint a border around that layer.

00:34:09.280 --> 00:34:11.680
And there's different colors for
the different types of layers.

00:34:11.680 --> 00:34:14.520
But rather than explain them here,
I'm going to actually go

00:34:14.520 --> 00:34:15.920
into the demo and show you.

00:34:19.380 --> 00:34:20.100
Excellent.

00:34:20.190 --> 00:34:23.460
So I've got the sample application,
which you can download

00:34:23.570 --> 00:34:26.890
from developer.apple.com,
and it's got a number of pages

00:34:27.160 --> 00:34:30.180
that I'm just going to load
up and go through in order.

00:34:30.180 --> 00:34:33.200
So this first example is a
page that has a widget that's

00:34:33.200 --> 00:34:37.100
common on many pages and apps,
and it's got an issue with flashing.

00:34:37.100 --> 00:34:40.390
We're going to go through,
understand why it's flashing,

00:34:40.540 --> 00:34:42.760
and then fix this problem.

00:34:43.390 --> 00:34:45.860
So at the top, we've got a, well,
let me zoom out.

00:34:45.860 --> 00:34:49.660
At the top, we've got a scroller that's
using touch overflow scrolling.

00:34:49.660 --> 00:34:53.200
It performs great at this zoom level,
but if I zoom in or out,

00:34:53.200 --> 00:34:56.200
you can see the content
inside it flashes.

00:34:56.270 --> 00:34:57.830
Okay, you can see that.

00:34:58.660 --> 00:35:01.410
On the bottom,
we've got a similar slider,

00:35:01.410 --> 00:35:04.470
but it uses touch events
and it tracks my finger,

00:35:04.470 --> 00:35:07.970
but when I release it and it
animates to a page boundary,

00:35:07.970 --> 00:35:10.180
it flickers for just a moment.

00:35:10.500 --> 00:35:35.400
[Transcript missing]

00:35:36.170 --> 00:35:37.350
And we'll see what's going on here.

00:35:37.350 --> 00:35:40.780
So here we can already see the
tiles for main page content

00:35:40.780 --> 00:35:42.420
are drawn with their borders.

00:35:42.420 --> 00:35:44.880
But if I load up this
example and zoom in,

00:35:44.880 --> 00:35:46.820
there's a lot going on here.

00:35:46.820 --> 00:35:50.400
So around the main page,
there's this yellow border.

00:35:50.490 --> 00:35:55.140
It's difficult to see here,
but that just means a container layer.

00:35:55.140 --> 00:35:59.610
Any page that has layers will normally
have this yellow border around the body,

00:35:59.780 --> 00:36:02.050
meaning that there are layers inside it.

00:36:02.300 --> 00:36:03.960
This is kind of the
root containing layer.

00:36:04.640 --> 00:36:07.210
But the scroll on top has a couple

00:36:08.500 --> 00:36:15.450
The Orange Border Contents
of the Scroller are so large

00:36:15.450 --> 00:36:18.590
that WebKit is optimizing and
only painting what is visible.

00:36:19.080 --> 00:36:24.410
The Light Blue Cyan Border Contents
are masked or clipped content,

00:36:24.550 --> 00:36:27.500
which is certainly the case when clipping
around the edges of the scroller.

00:36:27.500 --> 00:36:31.510
The Scroller at the bottom that
follows touch events doesn't have

00:36:31.510 --> 00:36:34.480
any layers visible right now,
but when I release my

00:36:34.620 --> 00:36:37.580
finger and it animates,
it gets the same borders and the same

00:36:37.580 --> 00:36:39.500
properties as the scroller on top.

00:36:39.500 --> 00:36:42.480
There's this orange tiled layer
and the blue for clipping.

00:36:42.500 --> 00:36:47.380
So what's going on here is the
content in these layers are so large

00:36:47.380 --> 00:36:50.500
that they're being painted in tiles.

00:36:50.500 --> 00:36:53.710
And in order for WebKit to
determine what's on screen

00:36:53.710 --> 00:36:56.500
and what it needs to paint,
that's an asynchronous operation.

00:36:56.500 --> 00:37:01.380
And you get a slight flicker as it's
repainting or recreating the layer at

00:37:01.380 --> 00:37:05.290
a new zoom level or pushing content
in a layer for the first time and

00:37:05.290 --> 00:37:07.280
having to draw it for the first time.

00:37:07.500 --> 00:37:11.420
So an approach to fix this
is to make a smaller layer,

00:37:11.530 --> 00:37:15.440
to break up that large layer into smaller
pieces or eliminate it altogether.

00:37:15.510 --> 00:37:19.900
An approach that we can take here
is push each of the individual items

00:37:19.900 --> 00:37:22.500
of these sliders into its own layer.

00:37:22.500 --> 00:37:25.500
That's of course going to take a cost,
some extra memory.

00:37:25.500 --> 00:37:29.390
But we're making a smaller layer that
WebKit can manage without tiling.

00:37:29.500 --> 00:37:32.340
So I've got a button in the
corner that does just that.

00:37:32.500 --> 00:37:37.370
It just set a WebKit transform
translate Z on each of the individual

00:37:37.370 --> 00:37:39.500
items inside the scrollers.

00:37:39.500 --> 00:37:42.500
And you can see now they have
a green border around them.

00:37:42.500 --> 00:37:46.970
So now as I zoom in and out of the page,
WebKit doesn't need to paint

00:37:47.060 --> 00:37:49.500
that content in pieces.

00:37:49.500 --> 00:37:54.500
It's now in one chunk that we've kind
of hinted to WebKit is important and

00:37:54.500 --> 00:37:54.500
small enough that it can be painted.

00:37:54.560 --> 00:37:56.430
And small enough that it can keep around.

00:37:56.520 --> 00:38:00.500
The scroller on the bottom no
longer jumps into and out of tiles.

00:38:00.530 --> 00:38:04.610
It's always there,
always visible and performs much,

00:38:04.610 --> 00:38:06.000
much smoother.

00:38:06.620 --> 00:38:09.780
So, second example, while this loads.

00:38:09.790 --> 00:38:14.410
While I was doing research for this talk,
I went on the internet

00:38:14.410 --> 00:38:17.890
and I did a web search,
what information was out

00:38:17.890 --> 00:38:20.320
there on performance on iOS.

00:38:20.320 --> 00:38:23.480
And there were some great articles,
but there were also some that

00:38:23.480 --> 00:38:26.240
were recommending what may
have been useful in the past,

00:38:26.240 --> 00:38:28.340
but is definitely not useful anymore.

00:38:28.340 --> 00:38:32.580
A bad practice of adding 3D
transforms to everything on the page.

00:38:32.580 --> 00:38:36.000
One even went so far as to say this
will solve all your problems on iOS.

00:38:37.020 --> 00:38:41.360
So, I decided to give it a shot,
you know,

00:38:41.360 --> 00:38:44.410
take this blog's advice and do it
on a medium to large size page.

00:38:44.430 --> 00:38:46.910
So, I went to the New York Times and
I did just that.

00:38:46.980 --> 00:38:50.100
I injected some style that
would put layers on everything.

00:38:50.100 --> 00:38:53.140
And the results were pretty dramatic.

00:38:53.140 --> 00:38:57.120
The scrolling performance dropped
from 60 frames per second to 20.

00:38:57.120 --> 00:39:02.380
The double tap to zoom takes about
two to three times longer to recover.

00:39:02.380 --> 00:39:06.480
The memory consumption skyrocketed
from 30 megabytes to 100 megabytes.

00:39:06.500 --> 00:39:08.320
140.

00:39:08.900 --> 00:39:10.720
So I know this is a
pretty contrived example,

00:39:10.720 --> 00:39:13.860
but there's actually a lot
that we can learn from it.

00:39:14.130 --> 00:39:18.810
If you turn WebKit's debug borders
on in your own application and

00:39:18.820 --> 00:39:23.170
you see any issues like this,
it would be a great quick performance

00:39:23.170 --> 00:39:26.600
fix to improve the performance
or get a little boost to the

00:39:26.630 --> 00:39:28.850
painting performance in your app.

00:39:29.010 --> 00:39:34.520
So on the left, we've got this blue
clipping masking border.

00:39:34.850 --> 00:39:37.830
It's difficult to see here,
but it was the same as

00:39:37.830 --> 00:39:39.680
in the previous example.

00:39:39.680 --> 00:39:43.040
And that means something like overflow
hidden or overflow scroll being

00:39:43.040 --> 00:39:44.840
applied as a style to that content.

00:39:44.840 --> 00:39:47.430
If that's not necessary,
it's just extra work that

00:39:47.430 --> 00:39:50.960
WebKit's doing every time it has
to paint that portion of content.

00:39:50.960 --> 00:39:53.990
So removing that style if
it's unnecessary will get you

00:39:53.990 --> 00:39:55.710
a small performance boost.

00:39:57.790 --> 00:40:02.210
And static content like the text
that's in a yellow or a green layer

00:40:02.210 --> 00:40:04.430
is just going to be wasted memory.

00:40:04.460 --> 00:40:07.420
And removing the style that's
causing that is going to save your

00:40:07.570 --> 00:40:10.600
app and the system memory and get
you better performance overall.

00:40:10.600 --> 00:40:14.660
It may also be indicative of a problem
with CSS where a selector is more

00:40:14.660 --> 00:40:19.460
general than it needs to be as applying
styles to something you didn't expect.

00:40:19.520 --> 00:40:22.500
I'm going to wrap up
with one nice example.

00:40:22.500 --> 00:40:26.960
This is a pretty famous
example out there.

00:40:26.960 --> 00:40:27.470
I'm sure it's a good example.

00:40:27.530 --> 00:40:30.210
It's come up in a few WWDCs in the past.

00:40:30.320 --> 00:40:31.720
And it's about animations.

00:40:31.720 --> 00:40:33.770
And this page is pretty complex.

00:40:33.820 --> 00:40:36.660
It's got a lot of leaves
falling down the page.

00:40:36.680 --> 00:40:38.980
It's got this clipping
border around the edges.

00:40:38.980 --> 00:40:42.780
It's got a label with
opacity that's on top.

00:40:42.880 --> 00:40:46.130
And what I want to stress here,
and I'm going to turn off the

00:40:46.130 --> 00:40:49.480
debug border so we can see
what it looks like normally.

00:40:52.730 --> 00:40:56.190
What I want to stress here is
that in no way in this content was

00:40:56.200 --> 00:40:58.300
there any 3D transforms applied.

00:40:58.320 --> 00:41:01.420
This was just written like a normal page,
keeping in mind that we

00:41:01.420 --> 00:41:02.920
want to keep layers small.

00:41:02.920 --> 00:41:06.590
I want to say don't prematurely
optimize your page by adding

00:41:06.690 --> 00:41:10.660
something like a 3D transformer,
trying to trick WebKit into

00:41:10.770 --> 00:41:14.310
doing something it doesn't
necessarily need to do.

00:41:14.720 --> 00:41:18.300
The WebKit does a really good job,
and it's improved over

00:41:18.300 --> 00:41:21.750
the past few years,
on making sites perform as best they

00:41:21.920 --> 00:41:26.350
can just out of the box without you
having to make any extra changes.

00:41:26.420 --> 00:41:30.710
In review, WebKit layers are great when
you want smooth animations,

00:41:30.860 --> 00:41:33.050
when you want fluid interactivity.

00:41:33.240 --> 00:41:37.040
You want your content to be in
layers when you want it to animate,

00:41:37.100 --> 00:41:38.720
something like that.

00:41:38.810 --> 00:41:39.990
But there are cons.

00:41:39.990 --> 00:41:43.320
You definitely don't want
to have unnecessary layers.

00:41:43.320 --> 00:41:45.770
The memory cost does
balloon pretty quickly,

00:41:45.810 --> 00:41:49.250
and it can put pressure on your app,
maybe even get it killed.

00:41:49.260 --> 00:41:53.900
Large layers will cause
tiling and flashing.

00:41:53.900 --> 00:41:57.940
You want to avoid them when possible,
break them up into smaller layers,

00:41:57.940 --> 00:42:00.640
and hint to WebKit in
those particular cases.

00:42:00.640 --> 00:42:03.550
And something that app
developers should be aware of,

00:42:03.550 --> 00:42:06.780
anytime you're using the GPU,
you're consuming power.

00:42:06.780 --> 00:42:09.510
So a lot of GPU usage,
like a lot of layers,

00:42:09.510 --> 00:42:12.900
will cause a little bit
extra power consumption.

00:42:13.320 --> 00:42:15.310
And remember, use the debug tools.

00:42:15.320 --> 00:42:18.320
They're there to help
you find and fix issues,

00:42:18.320 --> 00:42:24.410
and it makes it really easy to find
and understand what WebKit's doing now,

00:42:24.410 --> 00:42:26.120
and then fix issues that you come across.

00:42:26.200 --> 00:42:28.610
So with that,
I'm going to hand things over

00:42:28.610 --> 00:42:31.990
back to Paul to talk about
some new iOS 6 enhancements.

00:42:32.190 --> 00:42:33.390
Thank you.

00:42:35.010 --> 00:42:36.040
Thanks, Joe.

00:42:36.130 --> 00:42:39.400
So that's a look at what WebKit is
doing underneath the hood when

00:42:39.400 --> 00:42:42.200
it's trying to take your HTML,
CSS, JavaScript,

00:42:42.200 --> 00:42:43.700
and paint it onto the page.

00:42:43.850 --> 00:42:46.800
But I want to step back a little bit.

00:42:47.090 --> 00:42:49.940
and talk about this in the
context of your application,

00:42:50.030 --> 00:42:52.360
where all of this fits in in your app.

00:42:52.360 --> 00:42:56.850
So in previous versions of iOS,
UI WebView used what's called

00:42:56.850 --> 00:42:58.520
a synchronous rendering model.

00:42:58.520 --> 00:43:01.860
And it's this idea where some work
is going on in the main thread.

00:43:02.000 --> 00:43:03.990
Your app is responding
to some touch events,

00:43:03.990 --> 00:43:06.380
maybe,
that's causing some content to update,

00:43:06.550 --> 00:43:07.800
and WebKit needs to redraw.

00:43:07.800 --> 00:43:10.680
So it's going to take over the
main thread and do its rendering

00:43:10.680 --> 00:43:11.840
there for a little while.

00:43:11.840 --> 00:43:14.180
And then when that's done,
the main thread can go back

00:43:14.180 --> 00:43:17.100
and do whatever it needs to do,
respond to UIKit events.

00:43:17.100 --> 00:43:18.620
And this can happen a few times.

00:43:18.620 --> 00:43:22.770
It happens regularly throughout
the lifecycle of your app.

00:43:22.970 --> 00:43:25.470
But the problem is this
area where rendering is

00:43:25.470 --> 00:43:27.340
happening on the main thread.

00:43:27.340 --> 00:43:30.100
This means that the main thread
can't respond to user events.

00:43:30.100 --> 00:43:33.160
You can't handle delegate callbacks
from CF Network or any of those sorts

00:43:33.160 --> 00:43:34.980
of things that we do on the main thread.

00:43:34.980 --> 00:43:38.330
The main thread is blocked,
and the application appears to freeze.

00:43:39.660 --> 00:43:41.340
So this is not great.

00:43:41.620 --> 00:43:42.800
How do we fix it?

00:43:42.820 --> 00:43:46.140
Well, we fix it like we do any sort of
long-running task on the main thread.

00:43:46.240 --> 00:43:48.120
We pull the rendering
off into a new thread,

00:43:48.240 --> 00:43:50.680
a background thread,
the rendering thread,

00:43:50.810 --> 00:43:53.710
and this leaves the main thread
free to do whatever sorts

00:43:53.780 --> 00:43:55.280
of stuff it needed to do.

00:43:56.120 --> 00:43:59.150
The idea being that WebKit rendering
happens on a background thread,

00:43:59.150 --> 00:44:02.760
it doesn't block the application,
and this is going to be automatic

00:44:02.760 --> 00:44:05.890
for all UIWebViews that are
built with the iOS 6 SDK.

00:44:05.900 --> 00:44:09.520
So the SDK that you downloaded yesterday,
if you rebuild your app with it,

00:44:09.520 --> 00:44:12.970
all UIWebViews will start using
this asynchronous rendering model.

00:44:12.970 --> 00:44:15.080
Scrolling is going to
be so much smoother.

00:44:15.100 --> 00:44:16.360
It's really fantastic.

00:44:16.360 --> 00:44:17.730
It performs great.

00:44:24.400 --> 00:44:26.400
I agree, it's totally awesome.

00:44:26.400 --> 00:44:29.840
But one word of warning,
this doesn't change the API.

00:44:29.840 --> 00:44:32.640
So still,
use UIWebView only from the main thread,

00:44:32.640 --> 00:44:34.510
just like all the UIKit classes.

00:44:34.520 --> 00:44:35.320
Okay?

00:44:37.520 --> 00:44:39.190
And one other thing I want
to talk about rendering,

00:44:39.190 --> 00:44:41.100
and we sort of touched on
this a little bit earlier,

00:44:41.100 --> 00:44:43.970
is this idea that when
you're loading a web page,

00:44:43.970 --> 00:44:46.130
it doesn't all just pop in at once.

00:44:46.130 --> 00:44:47.800
It sort of loads in chunks.

00:44:47.800 --> 00:44:50.880
So as you're loading a web page,
some text will pop in,

00:44:50.940 --> 00:44:55.930
and then as an image will load, it draws,
and then as more images load, they draw.

00:44:55.930 --> 00:44:59.050
And this incremental
rendering is fantastic.

00:44:59.150 --> 00:45:01.860
It's great,
especially for websites and web content,

00:45:01.920 --> 00:45:04.220
where,
especially on a cellular connection,

00:45:04.220 --> 00:45:07.000
it might take a while for
very large images to load.

00:45:07.000 --> 00:45:10.320
And so you want to let the
user start interacting with the

00:45:10.320 --> 00:45:12.270
page as quickly as possible.

00:45:12.490 --> 00:45:16.650
But if you have this sort of incremental
rendering with an app interface that

00:45:16.700 --> 00:45:20.540
you've implemented with a UIWebView,
it doesn't feel so great.

00:45:20.540 --> 00:45:24.190
In fact, it might even feel a little bit
broken as parts of your interface

00:45:24.200 --> 00:45:27.360
are kind of drawing and flashing
in as they're being loaded.

00:45:27.360 --> 00:45:32.040
So what we really want is we want a way
to suppress this incremental rendering.

00:45:32.040 --> 00:45:35.860
We want to avoid rendering
partially loaded content.

00:45:36.360 --> 00:45:39.790
And in iOS 6, there's a new property
on UIWebView called

00:45:39.790 --> 00:45:42.060
SuppressesIncrementalRendering.

00:45:42.170 --> 00:45:44.700
Set this to Yes,
and WebKit is going to try

00:45:44.700 --> 00:45:47.650
to avoid rendering things
until they're fully loaded.

00:45:47.660 --> 00:45:48.590
This is awesome.

00:45:48.600 --> 00:45:52.150
Use it for any case where you're
building a significant amount of

00:45:52.150 --> 00:45:54.110
your application UI with web content.

00:45:54.160 --> 00:45:56.160
But we don't want to turn
this on all the time.

00:45:56.160 --> 00:45:59.560
Again, if you're loading sort of
regular website content,

00:45:59.560 --> 00:46:01.990
incremental rendering is a good thing.

00:46:03.570 --> 00:46:06.570
So we've spent all of this
time building a great website,

00:46:06.570 --> 00:46:09.310
and then we've spent all of
this time building a great app,

00:46:09.310 --> 00:46:12.760
and we want to let all of the users who
visit our website know about this app,

00:46:12.760 --> 00:46:13.340
right?

00:46:13.340 --> 00:46:15.230
And so what happens?

00:46:15.230 --> 00:46:18.270
Well, the user visits your website,
so I have this

00:46:18.270 --> 00:46:22.690
San Francisco pocketbook guide app,
and they're reading an article about

00:46:22.690 --> 00:46:26.900
a seal rocks over by Lincoln Park,
the park named after the president,

00:46:26.900 --> 00:46:28.020
not the band.

00:46:29.520 --> 00:46:32.300
The user's kind of,
they're interested in this content,

00:46:32.300 --> 00:46:35.070
they're reading it,
and they're maybe about to start

00:46:35.070 --> 00:46:36.920
panning or tap something else.

00:46:36.920 --> 00:46:40.000
When this happens,
the user gets punched in the nose.

00:46:40.000 --> 00:46:42.840
Or at least it feels like that sometimes,
right?

00:46:42.840 --> 00:46:45.080
Big pop-up ads take over the full screen.

00:46:45.080 --> 00:46:46.800
We've seen this on all sorts of sites.

00:46:46.800 --> 00:46:49.410
And good luck hitting the
close button in the corner.

00:46:49.410 --> 00:46:50.840
I can never do that myself.

00:46:53.620 --> 00:46:56.020
So there are a bunch of
problems with this approach.

00:46:56.020 --> 00:46:57.470
They interrupt the user's browsing.

00:46:57.480 --> 00:46:59.030
The user was interested in this content.

00:46:59.080 --> 00:47:00.020
They were trying to read this.

00:47:00.020 --> 00:47:02.580
And suddenly,
there's a big ad in their face.

00:47:02.580 --> 00:47:05.220
The user may already
have the app installed.

00:47:05.330 --> 00:47:08.840
And there's really no way for web
content to determine this or detect this.

00:47:08.840 --> 00:47:10.740
And that's a privacy issue.

00:47:10.740 --> 00:47:13.130
You know, you don't want any website
knowing that-- well,

00:47:13.170 --> 00:47:15.180
I don't want any website
knowing that I've got Sallie's

00:47:15.180 --> 00:47:16.990
Spa installed on my phone.

00:47:17.140 --> 00:47:21.160
Maybe unless I can tell that website that
I've got expert scores in all 40 levels.

00:47:21.160 --> 00:47:23.960
The point is it's a privacy issue.

00:47:24.000 --> 00:47:27.130
And lastly,
say the user does have the app installed.

00:47:27.320 --> 00:47:28.740
So they go to the home screen.

00:47:28.740 --> 00:47:29.640
They find your app.

00:47:29.640 --> 00:47:30.460
They launch it.

00:47:30.460 --> 00:47:33.260
And it opens to something
completely different.

00:47:33.310 --> 00:47:36.000
It opens to whatever article
they were reading the last

00:47:36.100 --> 00:47:37.140
time they had your app open.

00:47:37.140 --> 00:47:40.700
Or it opens to the app's home screen.

00:47:40.700 --> 00:47:46.200
The user's context is lost if they
move from your website to your app.

00:47:46.270 --> 00:47:49.140
So in iOS 6,
we think we have a better solution.

00:47:49.240 --> 00:47:53.080
We're calling it the Smart App Banner,
and this is what happens.

00:47:53.210 --> 00:47:57.380
When the user visits your website,
a new banner slides in.

00:47:57.490 --> 00:48:03.720
It has your app icon,
a link to the App Store,

00:48:03.720 --> 00:48:04.560
information about the
current rating and the cost,

00:48:04.560 --> 00:48:04.560
and all this sort of great stuff.

00:48:04.730 --> 00:48:08.400
And if the app is already
installed on the user's device,

00:48:08.400 --> 00:48:11.420
that view button changes
to an open button.

00:48:11.520 --> 00:48:16.430
So tapping on the app banner links
the user directly to your application

00:48:16.470 --> 00:48:21.670
and can also pass in information to
maintain the user's current state.

00:48:21.670 --> 00:48:23.160
This is really cool.

00:48:23.160 --> 00:48:25.050
It works not just on iPhones,
it works on iPads,

00:48:25.050 --> 00:48:26.720
and it totally works in landscape, too.

00:48:26.720 --> 00:48:27.590
It's really neat.

00:48:28.280 --> 00:48:30.230
So how do you add this to your site?

00:48:30.270 --> 00:48:31.650
It's a new meta tag.

00:48:31.650 --> 00:48:34.680
It's called Apple iTunes App.

00:48:34.680 --> 00:48:36.150
And you add in your app ID.

00:48:36.150 --> 00:48:39.280
This is just a unique ID that's
associated with your app.

00:48:39.290 --> 00:48:42.730
You can get it from
itunes.apple.com slash linkmaker.

00:48:44.430 --> 00:48:47.150
And there's also this optional
app argument parameter.

00:48:47.150 --> 00:48:48.280
It's a URL.

00:48:48.280 --> 00:48:51.280
It's a real URL,
so it needs a scheme and it needs

00:48:51.280 --> 00:48:52.640
a colon and that sort of stuff.

00:48:52.670 --> 00:48:55.630
But the actual format of the
URL is totally up to you.

00:48:55.630 --> 00:48:59.230
So I'm using a private URL scheme
that includes the name of the

00:48:59.250 --> 00:49:01.460
article that the user is reading.

00:49:01.480 --> 00:49:04.200
But in your case,
this could be as simple as

00:49:04.200 --> 00:49:08.140
maybe the HTTP URL of the page
that the user is currently on.

00:49:08.150 --> 00:49:12.160
Then when your application opens,
your app will know how to translate your

00:49:12.160 --> 00:49:14.380
website URLs into view controller stacks.

00:49:14.480 --> 00:49:18.830
For example, your app doesn't need to
register for this URL scheme.

00:49:18.830 --> 00:49:21.540
Because the app is
associated with the app ID,

00:49:21.540 --> 00:49:25.100
the correct app is opened no matter
what URL schemes you've registered for.

00:49:25.100 --> 00:49:26.200
It's really cool.

00:49:26.200 --> 00:49:30.140
Inside of UI application,
the method application open URL,

00:49:30.140 --> 00:49:35.160
that URL parameter is where your app
is going to be passed this information.

00:49:35.160 --> 00:49:38.720
So that's where you would parse this URL,
set up all your view controllers

00:49:38.720 --> 00:49:40.250
to restore the user state.

00:49:40.880 --> 00:49:44.260
So the smart app banner,
it's new in iOS 6.

00:49:44.400 --> 00:49:47.780
You can invite the user to install
your app from your website.

00:49:47.810 --> 00:49:52.600
And the really cool thing is you
can maintain the user's context.

00:49:52.640 --> 00:49:56.400
So if they're reading about something,
they can continue reading about

00:49:56.400 --> 00:49:59.910
it in your app instead of losing
everything that they're doing.

00:50:01.980 --> 00:50:04.310
So we've talked about
a ton of stuff today,

00:50:04.310 --> 00:50:06.760
and let's try and wrap it all together.

00:50:06.760 --> 00:50:09.870
Web technologies are a great way
to deliver application content.

00:50:10.040 --> 00:50:14.970
I don't need to tell you guys this.

00:50:14.970 --> 00:50:17.380
You guys are the ones who
are building the really cool

00:50:17.380 --> 00:50:17.380
application content that's being
delivered to all of our users.

00:50:17.540 --> 00:50:21.190
But the way we write web
content has a direct impact on

00:50:21.230 --> 00:50:23.580
the overall user experience.

00:50:23.660 --> 00:50:26.900
It's not simply that WebKit is a black
box and every year Apple makes WebKit a

00:50:26.900 --> 00:50:30.140
little bit faster and that makes
all web content a little bit faster.

00:50:30.140 --> 00:50:33.680
As web content authors,
we can actually make changes to the way

00:50:33.680 --> 00:50:38.280
we code that have direct impact on the
overall performance of our apps today.

00:50:39.280 --> 00:50:41.080
Look at resource loading times.

00:50:41.080 --> 00:50:43.720
Make sure that you don't have any
JavaScript blocking loads or you're

00:50:43.830 --> 00:50:47.180
not chaining resource imports
unnecessarily slowing things down.

00:50:47.180 --> 00:50:49.280
Avoid unnecessary memories and layers.

00:50:49.280 --> 00:50:50.400
This is huge.

00:50:50.400 --> 00:50:53.160
Memory pressure is one of the
biggest things that can cause

00:50:53.160 --> 00:50:54.640
your app to feel slow on iOS.

00:50:54.640 --> 00:50:58.370
So make sure you don't have sprite
sheets with a ton of wasted space.

00:50:58.370 --> 00:51:01.480
Avoid images that are larger
than they need to be and don't

00:51:01.480 --> 00:51:03.470
set Transform Z on everything.

00:51:03.480 --> 00:51:06.980
And really sort of the theme
is understanding a little bit

00:51:06.980 --> 00:51:08.870
of the internals of WebKit.

00:51:09.280 --> 00:51:12.980
Just keeping some of these ideas in
the back of your mind means that it's

00:51:12.980 --> 00:51:17.160
a lot easier to build really great
web content that performs really well.

00:51:17.180 --> 00:51:21.110
Lastly, take advantage of these really
cool new features in iOS 6.

00:51:21.110 --> 00:51:23.520
You're automatically going
to get asynchronous rendering

00:51:23.600 --> 00:51:24.420
in all UI web views.

00:51:24.480 --> 00:51:25.570
It's totally awesome.

00:51:25.600 --> 00:51:30.620
And you'll also be able to take advantage
of the ability to suppress incremental

00:51:30.620 --> 00:51:35.770
rendering for app content and use the new
app banner to link people to your app.

00:51:35.950 --> 00:51:39.640
So, for more information,
you can always contact Vicky.

00:51:39.640 --> 00:51:44.790
There's great documentation for the
Web Inspector and some other general

00:51:44.790 --> 00:51:49.180
best practices for web content authoring
on the Safari Developer Center.

00:51:49.180 --> 00:51:51.500
And there's always
devforums at apple.com.

00:51:52.820 --> 00:51:52.860
So, for more information,
you can always contact Vicky.

00:51:52.860 --> 00:51:52.900
There's great documentation for the
Web Inspector and some other general

00:51:52.900 --> 00:51:52.960
best practices for web content authoring
on the Safari Developer Center.

00:51:52.960 --> 00:51:53.240
And there's always
devforums at apple.com.
WEBVTT

00:00:10.060 --> 00:00:11.800
Good morning, everyone.

00:00:11.800 --> 00:00:17.570
My name is Roger Panthos,
and welcome to the first of two sessions

00:00:17.710 --> 00:00:21.450
this week on HTTP live streaming.

00:00:22.310 --> 00:00:24.960
You know,
it's actually really remarkable when

00:00:24.960 --> 00:00:27.100
you think about the last three years.

00:00:27.130 --> 00:00:31.620
I was chatting with a few other folks
who work on streaming back at Apple.

00:00:31.820 --> 00:00:36.460
And we were talking about how
in our collective experience,

00:00:36.460 --> 00:00:40.630
no media technology that we've
ever seen has been adopted as

00:00:40.720 --> 00:00:43.660
quickly as HTTP live streaming.

00:00:43.660 --> 00:00:49.070
And certainly,
no new device has acquired so much new

00:00:49.070 --> 00:00:53.860
content as quickly as the iPad has.

00:00:53.860 --> 00:00:59.500
And so I think all of us in this room
can take a lot of credit for that.

00:00:59.710 --> 00:01:03.730
We, of course, at Apple,
built some great devices and we

00:01:03.730 --> 00:01:06.070
built a solid platform for you.

00:01:06.320 --> 00:01:10.750
And everyone who's working on
tools to produce the content and,

00:01:10.750 --> 00:01:16.150
of course, most importantly,
all you folks who work on applications,

00:01:16.490 --> 00:01:17.510
the last mile, you're going to be able to
get the content you want.

00:01:17.560 --> 00:01:17.560
Roger Pantoz, Eryk Vershen You know,
it's a great experience.

00:01:17.560 --> 00:01:17.570
And I think, I think,
it's a great experience.

00:01:17.570 --> 00:01:17.600
And I think, I think,
it's a great experience.

00:01:17.920 --> 00:01:21.120
between the network and the user,
what the user sees,

00:01:21.170 --> 00:01:24.020
that's so vitally important.

00:01:24.020 --> 00:01:27.250
And so I think we can all be very
proud of what we've accomplished.

00:01:27.340 --> 00:01:31.430
Now, having said that,
once you get over the initial enthusiasm

00:01:31.900 --> 00:01:36.190
of "I've got prime time TV on my phone,
this is awesome," once you get

00:01:36.190 --> 00:01:40.100
over that sort of initial thing,
and you start looking at the applications

00:01:40.100 --> 00:01:43.080
and you start looking at the streams
with a bit of a critical eye,

00:01:43.080 --> 00:01:46.150
you realize that, you know what,
there are actually a few things

00:01:46.150 --> 00:01:52.200
that we can do that could make
these experiences even better.

00:01:52.310 --> 00:01:56.080
And so that's what we're
going to talk about today.

00:01:56.240 --> 00:02:00.420
And so to take us through that,
we actually have an old

00:02:00.520 --> 00:02:02.640
hand with us today at this.

00:02:02.640 --> 00:02:05.520
He is our media technologies evangelist.

00:02:05.520 --> 00:02:07.850
He is our go-to guy when
you folks send us crazy,

00:02:08.040 --> 00:02:11.800
puzzling questions about
what's wrong with your apps.

00:02:11.800 --> 00:02:15.980
He's contributed to some of
the sections in the spec,

00:02:15.980 --> 00:02:16.350
the Internet Directive,
and some of the other

00:02:16.370 --> 00:02:16.440
sections in the web.

00:02:16.440 --> 00:02:18.590
And so he's been a great friend graph,
defines HTTP live streaming.

00:02:18.780 --> 00:02:21.220
And many of you have
actually already met him,

00:02:21.220 --> 00:02:26.080
either in person, or over e-mail,
or on the developer forums.

00:02:26.120 --> 00:02:28.280
And so, ladies and gentlemen,
I'd like to introduce

00:02:28.280 --> 00:02:29.540
to you Eric Verschen.

00:02:29.540 --> 00:02:31.230
ERIC VERSCHEN: Good morning.

00:02:31.230 --> 00:02:33.310
Thank you all for coming.

00:02:33.310 --> 00:02:37.050
It's a -- I hope you're
not tired already.

00:02:37.050 --> 00:02:39.980
You still got another three days

00:02:40.430 --> 00:02:43.340
So as Roger mentioned,
I'm the media technologies evangelist.

00:02:43.450 --> 00:02:46.080
I'm one of the engineers
on the evangelism team.

00:02:46.140 --> 00:02:51.100
And the talk today is
effective HTTP live streaming.

00:02:51.200 --> 00:02:55.910
So I want to start out by asking,
what makes a great streaming app?

00:02:56.300 --> 00:02:57.800
Well, high performance of course.

00:02:57.870 --> 00:03:04.900
Fast startup, fast seeking, no stalls,
and

00:03:05.220 --> 00:03:07.760
You also want great navigation.

00:03:07.870 --> 00:03:10.340
You want to be able to seek fluidly.

00:03:10.340 --> 00:03:14.370
You want to be able to
fast forward and rewind.

00:03:14.820 --> 00:03:18.800
It's also important that your
client be getting the right stream,

00:03:18.800 --> 00:03:22.180
that is the most appropriate
stream for the bit rate that

00:03:22.240 --> 00:03:25.380
they can currently stay in,
the network that they're currently on.

00:03:25.510 --> 00:03:30.370
And lastly, we believe you should have
your content localized.

00:03:31.420 --> 00:03:37.980
Now, I want to emphasize that everything
that you need is in iOS 5 already.

00:03:38.730 --> 00:03:41.930
Now, I assume you were at
the keynote yesterday,

00:03:42.050 --> 00:03:45.090
so you will have noticed
that the adoption rates for

00:03:45.180 --> 00:03:47.710
iOS 5 are pretty terrific.

00:03:47.830 --> 00:03:52.200
And even with a combination
of iOS 5 and iOS 4,

00:03:52.240 --> 00:03:55.410
you're pretty much covering
almost all of the devices.

00:03:55.620 --> 00:04:04.100
So there's not really any point to having
the backward support to older versions.

00:04:05.650 --> 00:04:09.470
So before I get started,
I want to do a little bit of a

00:04:09.470 --> 00:04:12.020
review about HTTP live streaming.

00:04:12.150 --> 00:04:16.230
Now, those of you who are familiar
with HTTP live streaming already,

00:04:16.240 --> 00:04:17.590
please bear with me.

00:04:17.660 --> 00:04:20.000
This is only going to
be a couple of minutes.

00:04:20.000 --> 00:04:23.240
Those of you who are new
to HTTP live streaming,

00:04:23.300 --> 00:04:26.810
this might be a little bit fast for you,
but I think you'll still get

00:04:26.810 --> 00:04:28.800
something out of the talk.

00:04:28.800 --> 00:04:33.570
And we have a lot of really great
material in terms of documentation

00:04:33.570 --> 00:04:38.170
and earlier years WWDC presentations.

00:04:38.720 --> 00:04:43.100
So, HTTP live streaming starts
out with a really simple idea,

00:04:43.100 --> 00:04:45.730
a really simple concept,
and that's we want to

00:04:45.730 --> 00:04:49.090
deliver video over HTTP,
and we want to do it with

00:04:49.090 --> 00:04:50.230
an ordinary web server.

00:04:50.230 --> 00:04:52.650
We don't want any magic
in the web server.

00:04:53.440 --> 00:04:56.740
And the mechanism is
pretty simple itself.

00:04:57.070 --> 00:05:00.020
You take your video,
you break it into small,

00:05:00.140 --> 00:05:05.440
roughly equal-sized chunks,
you have a list of those pieces,

00:05:05.440 --> 00:05:09.820
and in the case of live video,
you have to update

00:05:09.820 --> 00:05:11.200
that list periodically.

00:05:11.320 --> 00:05:15.560
Now, in order to have that list,
which we call a playlist,

00:05:15.660 --> 00:05:19.740
we actually have two kinds of playlists,
two types.

00:05:21.130 --> 00:05:26.420
A media playlist, which is a list of
media files or segments.

00:05:26.430 --> 00:05:31.970
And a master playlist,
which is a list of other media playlists.

00:05:33.230 --> 00:05:36.280
So let's talk about the first one,
your media playlist.

00:05:36.480 --> 00:05:41.190
So the media playlist is, at its heart,
just a list of those files,

00:05:41.190 --> 00:05:41.920
those segments.

00:05:41.920 --> 00:05:45.170
So that's file sequence A, B, C,
D that you see here.

00:05:45.500 --> 00:05:47.950
And remember that the
names aren't important.

00:05:48.030 --> 00:05:50.590
We could be calling those
Bob and Jane and Ted.

00:05:50.810 --> 00:05:53.510
What's important is the order.

00:05:53.760 --> 00:05:55.750
Now the other lines that
you see in this file,

00:05:55.760 --> 00:05:59.330
the ones that start with a hash,
are tags, and those are the way we convey

00:05:59.800 --> 00:06:01.300
more information to the client.

00:06:01.360 --> 00:06:05.300
That this is an M3U8 file,
a playlist file,

00:06:05.300 --> 00:06:09.360
what version we're using,
what the maximum duration

00:06:09.360 --> 00:06:11.790
for a segment should be,
and so on.

00:06:11.880 --> 00:06:15.450
Now this particular playlist
is a video-on-demand playlist,

00:06:15.450 --> 00:06:15.980
VOD.

00:06:15.980 --> 00:06:20.370
So it has a playlist type of VOD,
and it has an endless tag,

00:06:20.400 --> 00:06:23.320
indicating that you're at the end.

00:06:23.320 --> 00:06:27.920
Now if this was a live playlist,
we wouldn't have the playlist type,

00:06:27.970 --> 00:06:29.270
and we wouldn't have the endless tag.

00:06:29.320 --> 00:06:34.700
And instead of being a static list,
it would be a list that changes.

00:06:34.700 --> 00:06:36.320
The server would be updating it.

00:06:37.780 --> 00:06:41.390
Based on the target duration,
we'll be updating it periodically so

00:06:41.390 --> 00:06:46.590
the client could fetch it and get a
view of the newly produced content.

00:06:47.130 --> 00:06:50.540
Now the other kind of playlist
that you have is a master playlist.

00:06:50.650 --> 00:06:53.760
So master playlist is
again a list of things,

00:06:53.760 --> 00:06:55.760
but in this case it's a
list of other playlists,

00:06:55.760 --> 00:06:56.780
of media playlists.

00:06:56.780 --> 00:07:00.760
And the other important thing in
there is it's a list of bit rates.

00:07:00.850 --> 00:07:07.280
That bandwidth attribute tells the
client how many bits per second

00:07:07.400 --> 00:07:10.220
this thing is going to take.

00:07:10.740 --> 00:07:14.530
And this is essential so that the
client can make the decision about

00:07:14.530 --> 00:07:17.140
switching between different bit rates.

00:07:17.140 --> 00:07:19.780
So we have this simple mechanism.

00:07:19.780 --> 00:07:22.850
Now how do you take that mechanism
and turn it into something that

00:07:22.850 --> 00:07:24.380
gives you high performance?

00:07:26.360 --> 00:07:28.480
Well,
I want to start with asking the question,

00:07:28.480 --> 00:07:30.190
what do we mean by high performance?

00:07:30.370 --> 00:07:38.140
So fast startup, obviously, fast seeking,
and absolutely no playback stalls.

00:07:38.180 --> 00:07:44.210
And you also want to be able to
switch between streams easily.

00:07:44.950 --> 00:07:49.040
So there's a lot that goes
into Fast Startup and Seek.

00:07:49.040 --> 00:07:53.860
The first thing is you want to make
a good initial choice of variant,

00:07:54.280 --> 00:07:57.790
that is, your master playlist that first

00:07:58.290 --> 00:07:59.810
Enter the master playlist.

00:07:59.850 --> 00:08:03.150
Entry in that master playlist,
that's the one the client's

00:08:03.150 --> 00:08:04.390
going to start with.

00:08:04.390 --> 00:08:08.260
So you want the bit rate of that to
be something that most of your clients

00:08:08.260 --> 00:08:10.090
are going to be able to sustain.

00:08:10.090 --> 00:08:13.970
Now, when I'm talking about getting
the streams to the right device,

00:08:13.970 --> 00:08:17.850
I'll talk about how you can arrange
to have different master playlists

00:08:17.850 --> 00:08:22.350
delivered to different devices so
that you can tune that initial choice.

00:08:22.360 --> 00:08:24.760
Now,
the other thing you want to do is you

00:08:24.760 --> 00:08:27.260
want to serve your playlists with Gzip.

00:08:27.820 --> 00:08:33.800
Playlists can have, in the case of VOD,
hundreds of entries.

00:08:33.800 --> 00:08:36.980
And even in a live playlist,
if you're delivering a

00:08:37.100 --> 00:08:41.330
large window of content,
you can again have hundreds of entries.

00:08:41.340 --> 00:08:47.090
And Gzip reduces the size dramatically,
and it's very easy to add to your server.

00:08:47.090 --> 00:08:51.570
It's typically a one-line fix
in your server configuration.

00:08:51.600 --> 00:08:55.260
Now,
in order to have fast startup and seek,

00:08:55.260 --> 00:08:57.840
you need to have an IDR frame.

00:08:57.840 --> 00:09:02.180
Now, those of you who aren't that
familiar with H.264 might not

00:09:02.180 --> 00:09:04.080
be familiar with IDR frames.

00:09:04.080 --> 00:09:08.420
It's an instantaneous decoder refresh,
and it's a special kind of iframe.

00:09:08.470 --> 00:09:13.870
And what it indicates to the
decoder is no frame that occurs

00:09:13.870 --> 00:09:19.640
after this frame depends on
any frame that occurred before.

00:09:19.640 --> 00:09:22.960
So it means that essentially I can
reset the... I can reset the decoder.

00:09:22.980 --> 00:09:25.620
Now,
you want that IDR frame at the beginning

00:09:25.620 --> 00:09:29.470
of your segment because if we're
seeking or if this is a live stream

00:09:29.470 --> 00:09:34.240
and we're starting out partway through,
we need an IDR frame to get started.

00:09:34.470 --> 00:09:38.620
And so if you've put your
IDR frames partway into the segment,

00:09:38.620 --> 00:09:43.030
you're just wasting our time
until we get to that IDR frame.

00:09:43.300 --> 00:09:48.860
Now, in MPEG transport streams,
there's a certain amount of

00:09:48.870 --> 00:09:50.030
overhead that's in there.

00:09:50.030 --> 00:09:51.760
And there's some padding that occurs.

00:09:51.760 --> 00:09:56.300
And depending on how your transport
stream is getting created,

00:09:56.310 --> 00:09:59.950
you might have more overhead
than in other cases.

00:10:00.020 --> 00:10:03.570
Now, we've done a lot of work with our
media file segmenter and stream

00:10:03.640 --> 00:10:07.320
segmenter to try and make sure that
we don't have too much overhead.

00:10:07.320 --> 00:10:10.260
And typically,
we have less than 10%, and in fact,

00:10:10.350 --> 00:10:12.700
in most cases, less than 5% overhead.

00:10:12.700 --> 00:10:18.060
Now, in looking at streams that
come from other encoders,

00:10:18.120 --> 00:10:23.230
we've seen overhead as high as 45%. Now,
to make that a little

00:10:23.230 --> 00:10:25.970
more concrete for you,
let's say you had a stream that was

00:10:25.970 --> 00:10:28.400
nominally 100 kilobits per second.

00:10:28.400 --> 00:10:32.800
Now, if you've got 45% overhead,
then you've only got 55 kilobits of

00:10:32.810 --> 00:10:35.400
actual video data that's going through.

00:10:35.400 --> 00:10:39.650
If you've got 5% overhead,
you've got 95 kilobits.

00:10:39.650 --> 00:10:42.990
Well, obviously,
I can do a much better stream if I've

00:10:42.990 --> 00:10:46.170
got 95 kilobits for video data than 55.

00:10:46.610 --> 00:10:50.100
So you want to minimize
that overhead if you can.

00:10:50.420 --> 00:10:51.800
If you're working with
a different vendor,

00:10:51.800 --> 00:10:56.260
I suggest that what you do is
take your original content,

00:10:56.310 --> 00:10:59.260
encode it with our
media stream segmenter,

00:10:59.300 --> 00:11:02.470
and see what kind of overhead
you're getting and use that as a

00:11:02.470 --> 00:11:05.700
negotiating point with your vendor.

00:11:05.790 --> 00:11:10.530
Now, the target duration that is
the size of your segments does

00:11:10.530 --> 00:11:17.090
have some effect on startup,
but I want to emphasize over and

00:11:17.160 --> 00:11:20.810
over again that 10-second target
duration is what we recommend.

00:11:20.870 --> 00:11:22.740
It's what we recommended
at the beginning.

00:11:22.860 --> 00:11:23.960
It's what we still recommend.

00:11:23.960 --> 00:11:28.230
We believe that 10-second target
durations is the best choice.

00:11:28.290 --> 00:11:32.000
If you go with a smaller target duration,
you're increasing the likelihood

00:11:32.000 --> 00:11:33.260
that you're going to get a stall.

00:11:33.430 --> 00:11:36.320
Now, some of that's coming out
of two different reasons.

00:11:36.380 --> 00:11:38.420
If you're delivering your content,
if it's live content,

00:11:38.490 --> 00:11:42.040
and you're going through a CDN,
you're going to have propagation delays

00:11:42.170 --> 00:11:46.760
for that new content to make it all the
way out to the edge nodes on the CDN,

00:11:46.760 --> 00:11:49.010
and that's going to be variable.

00:11:49.110 --> 00:11:53.360
And also, if the client is fetching the
stuff over a cellular network,

00:11:53.420 --> 00:11:55.960
they've got higher latencies,
and both of those things can make you

00:11:55.960 --> 00:12:01.180
much more likely to encounter a stall
if you have a small target duration.

00:12:01.610 --> 00:12:06.190
Now, the other thing that you want to do
to prevent stalls is you want to make

00:12:06.190 --> 00:12:11.790
sure that you're not under-reporting
your bandwidth in your master playlist.

00:12:11.800 --> 00:12:16.670
So if I've declared a particular variant,
one of my choices as being

00:12:16.670 --> 00:12:21.470
200 kilobits per second,
then please, its maximum bit rate should

00:12:21.500 --> 00:12:23.640
be 200 kilobits per second.

00:12:23.640 --> 00:12:27.700
If you don't do that,
let's say that I'm running at

00:12:27.700 --> 00:12:31.580
something lower and I want to go up
to that 200 kilobit per second stream.

00:12:31.580 --> 00:12:34.450
If that thing actually
peaks at 300 kilobits,

00:12:34.530 --> 00:12:38.500
I might not have that much headroom,
and I may stall because you lied to

00:12:38.500 --> 00:12:40.950
me about how much bandwidth I needed.

00:12:42.440 --> 00:12:46.610
Now the other piece that comes
in here has to do with ads.

00:12:46.610 --> 00:12:49.630
And this is another thing that
we've recommended over and over

00:12:49.630 --> 00:12:51.300
and we continue to emphasize.

00:12:51.450 --> 00:12:55.900
People who are coming from some
other environment will say,

00:12:55.930 --> 00:12:57.940
"Oh, well, you know, hey,
I want to put in ad content.

00:12:58.060 --> 00:12:59.400
I'll just have a separate player.

00:12:59.600 --> 00:13:01.900
And when I need to do my ad,
I'll just click on the

00:13:01.900 --> 00:13:06.420
separate player." Well,
when you're doing things with HLS,

00:13:06.740 --> 00:13:11.520
If you've got two players,
two things that are fetching streams,

00:13:11.520 --> 00:13:16.080
the second one, when you start it up,
he doesn't have any of the knowledge

00:13:16.090 --> 00:13:19.270
that the first one has about
what bit rate he was getting.

00:13:19.280 --> 00:13:22.900
So he has to go through
the whole algorithm again.

00:13:22.900 --> 00:13:25.940
He has to start with that first bit rate,
which is typically going

00:13:25.940 --> 00:13:28.210
to be lower quality,
which means your ad,

00:13:28.210 --> 00:13:32.180
one of the things that your client
wants to have be very good quality,

00:13:32.180 --> 00:13:34.250
is not going to be good quality.

00:13:34.790 --> 00:13:37.600
So that's bad on their side,
but the other thing that's

00:13:37.680 --> 00:13:41.050
happening is that guy's
competing with the first stream.

00:13:41.050 --> 00:13:42.960
He's trying to do his
prefixes to get set,

00:13:42.970 --> 00:13:44.940
and they're competing for bandwidth.

00:13:44.940 --> 00:13:48.830
So we absolutely recommend
that you should have your

00:13:49.050 --> 00:13:52.750
ad content in the stream,
and there are a number of

00:13:52.750 --> 00:13:55.570
techniques you can use to do that.

00:13:57.000 --> 00:13:59.930
Now there's another point that I want
to bring up about preventing stalls,

00:13:59.940 --> 00:14:02.600
and this one's a little
bit complicated setup,

00:14:02.600 --> 00:14:04.140
so bear with me here.

00:14:04.140 --> 00:14:07.440
So when you're updating live playlists,
so you're delivering,

00:14:07.520 --> 00:14:11.650
imagine you're delivering this content,
you're going through a CDN, right?

00:14:14.400 --> 00:14:18.200
And in my little diagram here,
the blue bars indicate when

00:14:18.200 --> 00:14:21.990
I've got my encode done,
and that blue box is how

00:14:21.990 --> 00:14:27.180
long it takes me to get that
segment out to the edge nodes.

00:14:27.240 --> 00:14:28.600
So that's going to be variable.

00:14:28.600 --> 00:14:33.690
Remember, the segments are going to be
different sizes depending on what

00:14:33.690 --> 00:14:35.940
kind of stuff I was encoding.

00:14:35.940 --> 00:14:37.850
Like I might have been
on a fade to black,

00:14:37.850 --> 00:14:40.710
I was on a black screen for a while,
and now I'm into something

00:14:40.710 --> 00:14:44.280
and there's like smoke or fog,
so I'm ending up having to encode.

00:14:44.490 --> 00:14:50.260
And the encoding is more difficult,
I end up with a larger

00:14:50.260 --> 00:14:54.350
thing that takes me longer,
as well as just delays in the CDN.

00:14:54.400 --> 00:15:00.700
So as you remember,
when you're delivering a playlist,

00:15:01.160 --> 00:15:05.560
In the live environment,
the segments that it refers to,

00:15:05.560 --> 00:15:08.040
they have to be on the system already.

00:15:08.180 --> 00:15:09.330
They have to be available to the user.

00:15:09.330 --> 00:15:13.160
You can't deliver that
playlist for segment seven when

00:15:13.160 --> 00:15:17.690
segment seven's not available,
because then you're going

00:15:17.690 --> 00:15:19.590
to get a stall as well.

00:15:20.450 --> 00:15:24.720
So the naive view is that, well,
once I've got my segment up,

00:15:24.720 --> 00:15:26.200
I'll just ship my playlist up.

00:15:26.860 --> 00:15:30.560
But because I've got a lot
of variation in how long it

00:15:30.640 --> 00:15:36.380
takes the segments to go up,
I can end up with a very long delay in

00:15:36.380 --> 00:15:39.530
how long it takes my playlist to come up.

00:15:39.650 --> 00:15:43.050
So that playlist for segment
seven may come up really fast

00:15:43.140 --> 00:15:44.800
because it had a short segment.

00:15:44.850 --> 00:15:49.520
And that playlist for segment
eight may take a long time,

00:15:49.570 --> 00:15:53.590
at which point the time between
when I picked up the playlist for

00:15:53.590 --> 00:15:57.820
segment seven and segment eight,
I might be more than one

00:15:57.820 --> 00:15:59.970
and a half target durations.

00:16:00.210 --> 00:16:02.870
Between those times,
and I'm actually out of spec,

00:16:02.870 --> 00:16:03.700
and I could get a stall.

00:16:03.700 --> 00:16:08.940
So what you want to do is delay when
you're uploading those playlists.

00:16:09.060 --> 00:16:11.940
You want to get those playlists
to come up and be available

00:16:11.940 --> 00:16:13.460
on a pretty regular cadence.

00:16:13.460 --> 00:16:16.820
You want it like clockwork because
that's what the client needs.

00:16:16.820 --> 00:16:19.040
Now,
the other thing that you want to do is

00:16:19.100 --> 00:16:21.460
you want to have fast stream switching.

00:16:21.460 --> 00:16:27.070
So here, your IDR frames,
they're really important.

00:16:27.100 --> 00:16:29.290
That's where we can switch.

00:16:30.170 --> 00:16:31.830
If you think about it,
when you're switching

00:16:31.830 --> 00:16:35.600
between two streams,
you essentially have a discontinuity.

00:16:35.620 --> 00:16:39.510
You're potentially changing the
profile and level that you're

00:16:39.510 --> 00:16:41.320
going to or the resolution.

00:16:41.400 --> 00:16:45.290
So the decoder's having to
restart and needs that IDR frame.

00:16:45.340 --> 00:16:49.460
This is where you can also
have a difficulty because

00:16:49.610 --> 00:16:52.660
if you have longer segments,
if you say, oh,

00:16:52.660 --> 00:16:54.080
I'll just go with bigger segments.

00:16:54.140 --> 00:16:56.080
If 10 is good, let's go to 20,
let's go to 30.

00:16:56.080 --> 00:17:02.110
The problem there is when you're...
When I want to do a stream switch,

00:17:02.560 --> 00:17:06.120
I always grab the segment
before the segment where

00:17:06.130 --> 00:17:07.580
I believe I want to get into.

00:17:07.580 --> 00:17:09.760
Partially because I don't know.

00:17:09.760 --> 00:17:14.200
There's not an absolute requirement that
there be an IDR frame at the beginning.

00:17:14.200 --> 00:17:17.700
I want to have that lead in,
which means that if I'm trying to

00:17:17.700 --> 00:17:21.830
switch and I've got bigger segments,
I'm having to pull down a lot more

00:17:21.830 --> 00:17:24.280
data before I can make the transition.

00:17:24.300 --> 00:17:29.210
So you've done all this work
to increase your performance.

00:17:29.510 --> 00:17:33.240
You want to use the access logs
that you can get from the client

00:17:33.240 --> 00:17:35.680
to keep track of your performance.

00:17:35.740 --> 00:17:39.230
Now, these are great things,
but remember this is extracting

00:17:39.230 --> 00:17:42.390
data from the user that knows
something about the user,

00:17:42.390 --> 00:17:45.650
so you've got to ask the user's
permission to get this stuff.

00:17:45.700 --> 00:17:48.940
You want to look at,
especially at duration watched,

00:17:48.940 --> 00:17:53.140
observed bit rate, indicated bit rate,
so you can tell whether you're

00:17:53.140 --> 00:17:54.280
actually increasing your performance.

00:17:54.280 --> 00:18:00.200
So the three things I want you to
take away is use 10-second durations,

00:18:00.200 --> 00:18:03.380
serve your playlist during GZIPs,
it's really easy,

00:18:03.380 --> 00:18:08.410
and absolutely have at least
one IDR frame per segment.

00:18:08.950 --> 00:18:11.870
So now we've got high performance,
but we also need to

00:18:12.500 --> 00:18:14.040
have great navigation.

00:18:14.070 --> 00:18:17.900
And I want to start talking about great
navigation by also asking the question,

00:18:17.900 --> 00:18:19.270
what makes great navigation?

00:18:19.270 --> 00:18:21.890
A generous live content window.

00:18:21.900 --> 00:18:24.040
And I'll talk about that
in a little more detail.

00:18:24.040 --> 00:18:28.850
We want seeking to work well,
and you absolutely want to have fast

00:18:28.850 --> 00:18:32.250
forward and reverse playback supported.

00:18:33.170 --> 00:18:38.820
So remember when you have live content,
what you have is your playlist is

00:18:38.820 --> 00:18:42.750
a window into that content because
the content is essentially infinite.

00:18:42.850 --> 00:18:45.540
I can only show you a range of it.

00:18:45.580 --> 00:18:47.650
Now, according to the spec,
you only have to have three

00:18:47.760 --> 00:18:50.560
target durations worth of content.

00:18:51.030 --> 00:18:56.400
But the larger you make that window,
the more

00:18:56.700 --> 00:19:02.860
Flexibility you give to the user
so they can pause or seek back.

00:19:02.920 --> 00:19:05.660
And to try and illustrate that,
I've got a couple little animations here.

00:19:05.660 --> 00:19:07.230
So let's say I have a
small content window.

00:19:07.240 --> 00:19:08.630
It's three segments.

00:19:08.730 --> 00:19:11.960
I can't pause playback
because as I'm moving along,

00:19:11.980 --> 00:19:15.900
that arrow is the segment
that I'm about to play.

00:19:15.970 --> 00:19:17.540
I've got no room here.

00:19:17.540 --> 00:19:18.650
I can't pause.

00:19:18.710 --> 00:19:20.920
I'll fall off of the window.

00:19:21.020 --> 00:19:23.730
Now, if I have a bigger content window,
I've only made it slightly

00:19:23.740 --> 00:19:26.300
bigger here because I don't
have a large enough screen.

00:19:26.300 --> 00:19:33.120
In this case, as I'm moving along,
I can actually pause and the

00:19:33.120 --> 00:19:37.020
stream's moving along and
I can start up again later.

00:19:37.300 --> 00:19:39.940
Now, how big should you make this window?

00:19:40.100 --> 00:19:44.380
Well, we believe that at a minimum,
you should have a minute worth

00:19:44.430 --> 00:19:45.810
of content in this window.

00:19:45.900 --> 00:19:50.690
But what we really think you should do is
you should have a lot more than a minute.

00:19:50.790 --> 00:19:53.200
You should have half an
hour or even an hour.

00:19:53.300 --> 00:19:58.000
You should have enough content
that the -- the user can be in a

00:19:58.310 --> 00:20:03.800
situation where they get a phone call,
somebody's at the door,

00:20:03.800 --> 00:20:05.000
there's a noise in the other room.

00:20:05.000 --> 00:20:09.170
They've got something that interrupts
them and they want to pause but get

00:20:09.240 --> 00:20:11.790
back to where they were in the content.

00:20:12.620 --> 00:20:15.380
Now you also want your
seeking to work well.

00:20:15.380 --> 00:20:17.680
And the most important thing,

00:20:17.880 --> 00:20:19.860
is floating point durations.

00:20:20.040 --> 00:20:25.280
In the very first version of HLS,
you could have integer durations, but

00:20:26.250 --> 00:20:27.850
Please, use floating point duration.

00:20:27.850 --> 00:20:31.820
There's really no point being
still within integer durations.

00:20:31.870 --> 00:20:36.680
So you need this because the only
information that the client has about how

00:20:36.680 --> 00:20:43.310
long these segments take is the duration
that you specify in the media playlist.

00:20:44.240 --> 00:20:48.040
If I want to seek forward,
I haven't seen those segments.

00:20:48.040 --> 00:20:49.880
I don't know exactly how long they are.

00:20:49.880 --> 00:20:51.940
I only have that duration
that you've told me.

00:20:52.040 --> 00:20:55.100
If you give me integer durations,
I'm accumulating error.

00:20:55.100 --> 00:21:00.690
So if I attempt to seek well
into the program and start up,

00:21:00.690 --> 00:21:04.680
I've accumulated an error,
and I'm at a very different time.

00:21:04.680 --> 00:21:07.160
That current time that's going to
report in my app is going to be very

00:21:07.240 --> 00:21:09.950
different than what I would have
gotten if I'd just played forward.

00:21:12.000 --> 00:21:15.140
Now the other part about seeking is
there's actually two kinds of seek.

00:21:15.310 --> 00:21:18.200
There's fast seek or precise seek.

00:21:18.310 --> 00:21:20.900
So an AV player item,
if I use seek to time,

00:21:20.990 --> 00:21:22.900
I'm getting a fast seek.

00:21:23.030 --> 00:21:26.580
And in the case of a fast seek,
what we're doing is we're finding the

00:21:26.580 --> 00:21:30.260
segment where we believe that time is,
picking up the first IDR frame

00:21:30.350 --> 00:21:31.900
and going ahead and playing.

00:21:31.900 --> 00:21:35.740
We're just trying to get
in the general ballpark.

00:21:36.470 --> 00:21:40.160
Now that goes pretty quick,
but if I really want precise seeking,

00:21:40.160 --> 00:21:43.960
if I want to get close
to the frame that I want,

00:21:43.960 --> 00:21:47.340
I use that second method,
seek to time with tolerance

00:21:47.340 --> 00:21:49.180
before and tolerance after.

00:21:49.180 --> 00:21:53.400
Now, please remember that if you
want precise seeking with HLS,

00:21:53.400 --> 00:21:55.840
those tolerances have to be zero.

00:21:55.840 --> 00:22:00.060
If you don't have them as zero,
it won't invoke the precise seek.

00:22:00.770 --> 00:22:06.110
And what happens in this case is
we're actually going to go and pick

00:22:06.110 --> 00:22:12.120
up that segment and the one before it,
and we're going to try and get,

00:22:12.180 --> 00:22:18.150
we'll pick up the IDR frame and try
and start exactly where you want us to.

00:22:19.500 --> 00:22:21.980
Now, it does take a little bit more
time because we have to fetch that

00:22:21.980 --> 00:22:26.200
segment beforehand because we don't
have a guarantee that you have

00:22:26.200 --> 00:22:27.340
an IDR frame at the beginning.

00:22:27.340 --> 00:22:31.060
So we might actually
have to start from there,

00:22:31.070 --> 00:22:37.100
as well as the fact that there can be
some minor variations in time code.

00:22:37.100 --> 00:22:41.850
So where we want to get may
not be exactly in the segment

00:22:41.860 --> 00:22:44.480
that we're interested in.

00:22:45.950 --> 00:22:48.300
Now,
the other thing that you want to have in

00:22:48.300 --> 00:22:52.780
order to give the user a good experience
is fast forward and reverse playback.

00:22:52.870 --> 00:22:55.940
And the way you do this
is with iframe playlists.

00:22:56.650 --> 00:23:02.380
And this is really important if
you're using AirPlay and Apple TV.

00:23:02.410 --> 00:23:06.060
If I move my content over to Apple TV,
I don't have a scrub

00:23:06.060 --> 00:23:07.360
bar that I can touch.

00:23:07.360 --> 00:23:11.500
I've just got the fast forward button.

00:23:11.520 --> 00:23:13.820
And if I don't have
these iframe playlists,

00:23:13.960 --> 00:23:15.800
the user's not going to get any feedback.

00:23:15.880 --> 00:23:19.310
You're not getting any feedback
when you're doing the fast forward.

00:23:19.800 --> 00:23:24.520
Now, the higher your iframe frequency,
the better your, smoother your playback's

00:23:24.590 --> 00:23:26.700
going to be in fast forward,
right?

00:23:26.920 --> 00:23:30.810
If I've got, say,
four seconds between each iframe,

00:23:31.000 --> 00:23:33.810
then when I'm going at 4x,
I've got one frame to show

00:23:33.810 --> 00:23:35.860
to the user per second.

00:23:35.990 --> 00:23:40.590
If it was two,
if the separation's two seconds,

00:23:40.920 --> 00:23:43.040
then I'd have two frames to show.

00:23:43.220 --> 00:23:46.960
So the higher we get this,
the smoother the playback's going to be.

00:23:47.430 --> 00:23:52.480
Now your iframe playlists can
reuse your existing media files.

00:23:52.580 --> 00:23:55.840
So if you've already got content,

00:23:56.780 --> 00:24:02.540
The iframe playlist is pulling
out references to those iframes.

00:24:02.540 --> 00:24:05.400
So it can point at exactly the
same media files that you had

00:24:05.760 --> 00:24:08.980
for your normal playback content.

00:24:09.570 --> 00:24:14.300
and the playlist uses our byte
range syntax to indicate a

00:24:14.300 --> 00:24:19.500
particular offset and length where
the iframe will be in that segment.

00:24:19.550 --> 00:24:25.490
You want to have multiple iframe
playlists in your master playlist.

00:24:25.860 --> 00:24:33.500
Beginning I've got my four variants here
and then I've got some iframe playlists.

00:24:33.500 --> 00:24:41.970
What you can't see in this is that
that low iframe M3U8 is pointing

00:24:41.970 --> 00:24:46.330
to the same media that the low
audio/video M3U8 is pointing to.

00:24:46.520 --> 00:24:48.500
It's just pointing to pieces of it.

00:24:48.500 --> 00:24:53.400
Now, even though we're using the same

00:24:53.690 --> 00:24:54.680
Media.

00:24:55.040 --> 00:25:01.360
The decision about which bitrate to
choose is made independently if I'm in

00:25:01.600 --> 00:25:04.490
fast forward than from normal playback.

00:25:04.580 --> 00:25:10.260
So if in normal playback I'm playing
my medium level bitstream there,

00:25:10.260 --> 00:25:14.510
when I go into fast forward,
I'm not required to pick

00:25:14.510 --> 00:25:16.810
the medium range iframe.

00:25:16.910 --> 00:25:21.500
I'll pick whichever one has
the most appropriate bitrate.

00:25:23.370 --> 00:25:26.960
So those are the essentials
for having great navigation.

00:25:27.260 --> 00:25:31.160
Having that nice,
generous live content window,

00:25:31.320 --> 00:25:34.490
floating point durations,
and iframe playlists.

00:25:35.000 --> 00:25:38.810
So we've got good performance,
got great navigation.

00:25:38.940 --> 00:25:42.640
So the next thing is getting the
right stream to the right device.

00:25:45.320 --> 00:25:48.320
Now,
the tagline I want you to remember is

00:25:48.640 --> 00:25:51.890
the right stream to the right device.

00:25:53.200 --> 00:25:56.930
You want to choose your
bit rates carefully.

00:25:57.040 --> 00:25:59.470
You want to know something
about your client.

00:25:59.580 --> 00:26:02.780
What's the capabilities
of this particular device?

00:26:02.890 --> 00:26:05.720
And there are some special
considerations for cellular.

00:26:05.910 --> 00:26:12.850
So we have this great tech note, 2224,
on bit rates.

00:26:12.960 --> 00:26:17.570
And rather than bore you by going
through all of the detail in there,

00:26:17.640 --> 00:26:21.410
I thought I'd try and distill
it down to some high points.

00:26:21.970 --> 00:26:26.930
So the first thing is that adjacent
bit rates should be a factor of

00:26:26.930 --> 00:26:29.540
about one and a half to two apart.

00:26:29.590 --> 00:26:33.060
The reason you want to keep them
at a particular range is you don't

00:26:33.060 --> 00:26:35.070
want them too close together.

00:26:35.240 --> 00:26:40.750
If you put them too close together,
you're essentially wasting bandwidth.

00:26:40.930 --> 00:26:42.350
You're just going to pick one.

00:26:42.500 --> 00:26:48.260
It's not really going to make much
difference if I've got 150 and 180.

00:26:48.260 --> 00:26:50.790
It's like, what's the point?

00:26:50.830 --> 00:26:53.580
But you don't want them too far apart,
because if they're too far apart,

00:26:53.590 --> 00:26:56.330
you may get in a situation
where a client could actually

00:26:56.790 --> 00:27:00.190
have gotten a better stream,
but you don't have one available

00:27:00.190 --> 00:27:05.490
because you're going from
100 kilobits to 300 kilobits.

00:27:05.580 --> 00:27:07.650
It's too big of a jump.

00:27:08.060 --> 00:27:14.610
Now, keyframes, IDR frames, we,
in all of our recommendations,

00:27:14.610 --> 00:27:16.640
they're no more than three seconds apart.

00:27:16.640 --> 00:27:18.640
In fact, in some cases, they're less.

00:27:20.780 --> 00:27:24.660
And the first bit rate that you have
in your playlist should be the one

00:27:24.660 --> 00:27:26.500
that most of the clients can sustain.

00:27:26.500 --> 00:27:30.760
Now, choosing bit rates,
you do have some considerations.

00:27:30.820 --> 00:27:34.150
And the problem here is that I can't tell
you the absolute right answer because

00:27:34.220 --> 00:27:36.000
there is no absolute right answer.

00:27:36.000 --> 00:27:38.970
You have to figure it out for yourself.

00:27:39.090 --> 00:27:40.880
You have constraints on yourself.

00:27:40.920 --> 00:27:43.950
You're using some particular
encoding hardware.

00:27:43.980 --> 00:27:46.880
You may have a limitation
on the number of various bit

00:27:46.880 --> 00:27:48.600
rates that you can produce.

00:27:49.370 --> 00:27:51.320
It may be that with your
particular set of hardware,

00:27:51.320 --> 00:27:52.880
it's like, oh, well,
you can only produce five.

00:27:52.920 --> 00:27:53.760
You can't produce six.

00:27:53.760 --> 00:27:55.760
So you've got to pick
five that work for you.

00:27:57.090 --> 00:28:01.830
Also in the case of live,
if you're delivering through a CDN,

00:28:01.840 --> 00:28:04.910
you've got to worry about
how much time does it take,

00:28:04.960 --> 00:28:08.950
how much bandwidth do I need
into my CDN to get all of these

00:28:08.950 --> 00:28:11.080
streams up at the same time.

00:28:11.170 --> 00:28:14.840
Because I'm not going through the big
fat pipe where I've got a whole bunch

00:28:14.840 --> 00:28:16.840
of different edge nodes to talk to.

00:28:16.840 --> 00:28:19.340
I'm trying to get this
in from the back end.

00:28:19.340 --> 00:28:20.420
I may have a budget.

00:28:20.420 --> 00:28:23.810
In fact, I may even have financial
constraints on that side.

00:28:24.600 --> 00:28:27.240
And then lastly,
you want to think about the

00:28:27.240 --> 00:28:29.260
things I talked about before.

00:28:29.260 --> 00:28:31.280
You know, what's my ability to switch?

00:28:31.280 --> 00:28:34.070
What's the distance between
these various bit rates?

00:28:34.120 --> 00:28:38.700
Once you've picked your bit rates,
once you've deployed all this stuff,

00:28:38.840 --> 00:28:40.620
you want to verify your assumptions.

00:28:40.620 --> 00:28:43.460
So just like when you were
measuring your performance,

00:28:43.470 --> 00:28:45.190
you want to measure this stuff.

00:28:45.320 --> 00:28:47.660
You want to track the client
performance in the field.

00:28:47.660 --> 00:28:50.110
You've got access logs and error logs.

00:28:50.140 --> 00:28:52.470
And once again,
don't forget to get the user's

00:28:52.480 --> 00:28:54.060
permission to grab this data.

00:28:54.600 --> 00:28:58.040
Now we've got a lot of
fields in the access log.

00:28:58.040 --> 00:29:01.150
So you want to look at, you know,
what streams am I actually getting?

00:29:01.160 --> 00:29:03.200
How long are they playing for?

00:29:03.200 --> 00:29:05.490
Where am I stream switching?

00:29:05.500 --> 00:29:07.200
Am I getting stalls?

00:29:07.200 --> 00:29:10.300
You want to also know about your clients.

00:29:10.460 --> 00:29:12.140
Devices have different capabilities.

00:29:12.140 --> 00:29:13.780
They have different screen resolutions.

00:29:13.820 --> 00:29:17.790
They have different versions
of H.264 that they can handle,

00:29:17.790 --> 00:29:19.830
different profiles and levels.

00:29:21.550 --> 00:29:23.330
And you might in some cases
want to provide a different

00:29:23.460 --> 00:29:27.200
playlist to different models,
like a particular playlist

00:29:27.200 --> 00:29:29.710
to iPads versus iPhones.

00:29:30.460 --> 00:29:35.200
and you want to use the capabilities
you have on the client side to

00:29:35.200 --> 00:29:38.940
find out about your network.

00:29:41.070 --> 00:29:46.910
So the first thing you can do is you can
add things into the playlist that allows

00:29:47.070 --> 00:29:49.540
the client to select based on resolution.

00:29:49.540 --> 00:29:53.920
So different devices have different
resolutions that they can handle.

00:29:53.920 --> 00:29:56.550
Let's imagine that we
have a playlist like this.

00:29:56.560 --> 00:30:00.890
I've got a 640x360, a 720p, and a 1080p.

00:30:00.900 --> 00:30:09.390
So if I'm delivering to an old device,
a 3GS, the 3GS can't play 720p or 1080p.

00:30:09.400 --> 00:30:11.460
So it's going to pick that 640x360.

00:30:11.480 --> 00:30:16.160
Whereas the new iPad will pick the
1080p if it can handle the bitrate.

00:30:17.900 --> 00:30:21.280
But you should remember that
if you've got an app and you

00:30:21.280 --> 00:30:24.710
actually have a smaller window,
you're not delivering your

00:30:24.710 --> 00:30:25.760
video to the whole screen.

00:30:25.760 --> 00:30:32.210
So let's say I had on my iPad and
I had a window that was 640 by 360.

00:30:32.210 --> 00:30:37.050
Then we'd pull the 640 by 360 stream
because there's no point getting

00:30:37.050 --> 00:30:39.580
the 1080p and downshifting it.

00:30:39.720 --> 00:30:41.390
If you're only showing that
stuff in a small window,

00:30:41.400 --> 00:30:42.860
why would we waste the user's bandwidth?

00:30:42.860 --> 00:30:46.810
But if you then go to full screen,
we're going to switch up

00:30:46.810 --> 00:30:49.280
to the 1080p if we can.

00:30:50.400 --> 00:30:53.840
Now, you can also add things into your
playlist that allows the client

00:30:53.840 --> 00:30:59.870
to filter based on the codec,
the particular profile and

00:30:59.870 --> 00:31:01.300
level that you're encoding.

00:31:01.390 --> 00:31:05.820
Now,
these codecs tags are somewhat obscure,

00:31:05.820 --> 00:31:09.150
I'll admit,
and we have some documentation

00:31:09.580 --> 00:31:13.290
available that will help you
navigate to the correct one.

00:31:13.450 --> 00:31:16.280
That's why I've added the comment,
and by the way, that's not a comment,

00:31:16.310 --> 00:31:20.670
you can't put comments in your playlist,
so don't try and use that slash slash,

00:31:20.670 --> 00:31:22.000
it won't work.

00:31:22.360 --> 00:31:25.790
So the first one's baseline,
second one's main, the third one's high.

00:31:25.920 --> 00:31:28.610
So once again,
if I'm going to something like the 3GS,

00:31:28.610 --> 00:31:31.430
it doesn't handle main or high,
so it's going to take

00:31:31.430 --> 00:31:34.090
that baseline profile,
it's going to ignore

00:31:34.090 --> 00:31:35.800
the other two variants.

00:31:35.800 --> 00:31:41.740
Whereas, say the iPhone 4 would
take the main profile.

00:31:42.910 --> 00:31:45.260
Now,
you can also select based on your device

00:31:45.260 --> 00:31:47.260
model by sniffing the user agent string.

00:31:47.260 --> 00:31:51.640
So this is something you do on the
server side rather than the client side.

00:31:51.740 --> 00:31:54.450
You can sniff the user
agent string and decide,

00:31:54.580 --> 00:31:58.980
you know, oh, iPhone versus iPad,
I'll deliver you a different playlist.

00:31:59.750 --> 00:32:05.760
The first two here are if
you're coming over Safari.

00:32:05.760 --> 00:32:08.420
The last two are if you're in an app.

00:32:08.480 --> 00:32:12.960
And if you'd like to go
to the Stumpy Experts,

00:32:12.960 --> 00:32:16.880
what modern phone can that
third one not be from?

00:32:16.880 --> 00:32:19.470
It's a fairly obscure question.

00:32:19.480 --> 00:32:23.340
So you also want to
know about your network,

00:32:23.340 --> 00:32:24.340
right?

00:32:24.540 --> 00:32:30.090
You've got the reachability
API available to you,

00:32:30.220 --> 00:32:31.330
SC Network Reachability.

00:32:31.340 --> 00:32:37.470
And this allows you to find out
whether you're on cellular or Wi-Fi.

00:32:37.480 --> 00:32:43.340
And so doing this,
you can either go to a different URL or

00:32:43.340 --> 00:32:50.570
add this as extra information in your
request so that the server can tell you,

00:32:50.640 --> 00:32:51.740
and you can get a different playlist.

00:32:51.820 --> 00:32:54.520
This is particularly important so
that you can have that first-order.

00:32:54.540 --> 00:32:58.280
That first item in the
playlist be appropriate for

00:32:58.380 --> 00:32:59.500
the network that you're on.

00:33:02.550 --> 00:33:05.040
Now, there's some special
considerations for cellular.

00:33:05.060 --> 00:33:08.440
And this is something that we've
repeated over and over again,

00:33:08.440 --> 00:33:09.960
but it bears repeating again.

00:33:09.960 --> 00:33:14.270
And that's if you're delivering this
content over a cellular network,

00:33:14.270 --> 00:33:18.240
you absolutely have to provide
a stream that is no more

00:33:18.240 --> 00:33:22.780
than 64 kilobits per second,
or you will be rejected.

00:33:22.790 --> 00:33:27.760
And as I was reminded
by someone this morning,

00:33:27.770 --> 00:33:31.830
when you're doing that,
when you submit to the App Store,

00:33:32.110 --> 00:33:41.050
Tell us a URL to your cellular stream,
the cellular playlist,

00:33:41.050 --> 00:33:42.210
so that we can test it.

00:33:42.470 --> 00:33:45.140
Because otherwise what we have
to do is try and sniff the

00:33:45.240 --> 00:33:46.780
network to find out what it is.

00:33:46.780 --> 00:33:50.660
And if we can't find what it is,
we'll reject your app and you'll

00:33:50.660 --> 00:33:53.000
have to go through another cycle.

00:33:53.000 --> 00:33:57.270
The other thing that you
need to remember is...

00:33:57.650 --> 00:34:02.600
Some people have been grabbing
media in some other format,

00:34:02.600 --> 00:34:07.960
bringing it into their app and having a
local web server to serve that as HLS.

00:34:08.110 --> 00:34:09.250
You can't do that on cellular.

00:34:09.420 --> 00:34:11.120
Don't do that.

00:34:12.430 --> 00:34:16.050
So delivering the right stream
to the right device is about

00:34:16.050 --> 00:34:19.870
choosing your bit rates carefully,
using the access logs to

00:34:19.900 --> 00:34:24.210
verify your assumptions,
and customizing your master playlist.

00:34:24.340 --> 00:34:27.870
So we've talked about great performance,
great navigation,

00:34:27.980 --> 00:34:30.080
getting the right stream.

00:34:30.580 --> 00:34:34.260
So there's one other piece,
which is localizing your content.

00:34:34.330 --> 00:34:36.980
You're probably delivering
your app to the world,

00:34:36.980 --> 00:34:41.360
but you might even be delivering
it just to a particular country.

00:34:41.420 --> 00:34:43.850
And even in that case,
many countries have

00:34:43.850 --> 00:34:46.520
significant minorities that
speak some other language.

00:34:46.520 --> 00:34:50.410
So you probably want to get your
audio into multiple languages.

00:34:50.520 --> 00:34:54.300
And the way you do this is
with alternate audio playlists.

00:34:55.040 --> 00:34:58.420
So here's a conceptual
diagram of a master playlist.

00:34:58.580 --> 00:35:01.440
It's got a bunch of variants,
one audio only,

00:35:01.440 --> 00:35:06.610
and then three audio/video
variants at different bit rates.

00:35:07.130 --> 00:35:10.820
So when I add an audio alternates,
what I'm doing is I'm

00:35:10.820 --> 00:35:15.040
adding some more playlists,
one that has English language audio,

00:35:15.040 --> 00:35:17.020
one with German, one with French.

00:35:17.120 --> 00:35:21.440
And I'm grouping those audios
together and then associating that

00:35:21.440 --> 00:35:23.440
group with each of the variants.

00:35:23.630 --> 00:35:29.200
So let me walk through what
the master playlist looks like.

00:35:29.230 --> 00:35:33.480
So to get one of those audio variants,
you use the media tag,

00:35:33.480 --> 00:35:37.870
which is something we added in 5.0,
but it's backward compatible.

00:35:38.090 --> 00:35:43.680
So what the important things in here,
there's the URI that tells

00:35:43.680 --> 00:35:47.390
us where the playlist is.

00:35:47.640 --> 00:35:50.840
The language that it's in and
a name that we're going to show

00:35:50.840 --> 00:35:52.900
to the user for this alternate.

00:35:53.050 --> 00:35:57.980
So when I add the
German and French in here,

00:35:57.980 --> 00:35:59.680
again I've got

00:35:59.800 --> 00:36:28.400
[Transcript missing]

00:36:28.580 --> 00:36:32.770
So when I add this into a playlist,
you can see the rest of this

00:36:32.930 --> 00:36:37.220
playlist is a typical variant,
typical master playlist

00:36:37.300 --> 00:36:39.890
with a bunch of variants.

00:36:40.120 --> 00:36:41.830
And the connection is
still that group ID.

00:36:41.970 --> 00:36:46.800
That group ID is just an arbitrary
name that you can come up with.

00:36:46.920 --> 00:36:52.980
The audio attribute on the stream
info tags says that this particular

00:36:52.980 --> 00:36:58.060
variant can have its audio substituted
by any of the audios in this group.

00:36:58.120 --> 00:37:00.600
Those alternates that you have,
they're constrained by

00:37:00.600 --> 00:37:01.880
the streams that use them.

00:37:02.050 --> 00:37:07.450
That is, if my variant says I'm
using a particular codec,

00:37:07.500 --> 00:37:12.710
a particular sample rate and bit rate,
then the alternate should have

00:37:12.720 --> 00:37:14.770
the same sample rate and bit rate.

00:37:14.890 --> 00:37:17.300
And in fact, the playlist,
if my variant has a

00:37:17.420 --> 00:37:20.990
particular target duration,
the alternate should have the

00:37:20.990 --> 00:37:23.130
same target duration as well.

00:37:23.500 --> 00:37:26.970
And if I have discontinuities
or I have add insertions,

00:37:27.060 --> 00:37:28.820
the same things apply.

00:37:28.820 --> 00:37:34.270
These alternates have to be
substitutable for the variants.

00:37:34.970 --> 00:37:40.870
And that media tag is
backward compatible.

00:37:40.920 --> 00:37:44.070
So I can take that playlist and
I can provide that to a client

00:37:44.080 --> 00:37:46.660
who's not on 5.0 and they'll still
be able to play the variants.

00:37:46.700 --> 00:37:51.530
They just won't be able
to detect the alternates.

00:37:52.410 --> 00:37:53.900
So I'd like to try and wrap up.

00:37:53.950 --> 00:37:57.620
I want to mention a bunch
more things that you can do.

00:37:57.660 --> 00:38:01.510
Along with audio alternates,
you can have video alternates.

00:38:02.300 --> 00:38:06.060
So I can have an event that
has multiple cameras on it,

00:38:06.060 --> 00:38:10.780
and I can provide the feeds of
both of those cameras to my users.

00:38:10.860 --> 00:38:13.980
I can add timed metadata,
which allows me to add

00:38:14.310 --> 00:38:18.940
metadata that's associated with
particular instance in my movie.

00:38:19.360 --> 00:38:23.120
I can add American style
closed captioning.

00:38:23.120 --> 00:38:30.930
I can add real world times and dates
associated with points in my stream.

00:38:31.030 --> 00:38:33.940
I can also consolidate segments together.

00:38:33.940 --> 00:38:38.110
So that same byte range
syntax that we use to identify

00:38:38.230 --> 00:38:42.130
iframes in your media files,
you can actually consolidate your

00:38:42.130 --> 00:38:49.720
media files into a single media file
and reference the individual segments.

00:38:49.830 --> 00:38:53.720
This allows you to have
fewer files on your server.

00:38:53.720 --> 00:38:55.630
And of course, streams can be encrypted.

00:38:55.630 --> 00:38:58.810
Now,
we have a lot of resources available if

00:38:58.810 --> 00:39:01.440
you're interested in HTTP live streaming.

00:39:01.440 --> 00:39:05.800
Remember this URL,
developer.apple.com slash resources

00:39:05.800 --> 00:39:07.550
slash HTTP dash streaming.

00:39:07.560 --> 00:39:19.260
So we have pointers to
our documentation there,

00:39:19.260 --> 00:39:19.260
including the internet draft spec.

00:39:19.260 --> 00:39:19.260
We also have pointers to all
the tech notes that we've done.

00:39:19.260 --> 00:39:21.260
We have pointers to the tools.

00:39:21.710 --> 00:39:28.670
And to the to some example streams
that we've recently put up.

00:39:28.950 --> 00:39:31.570
So these example streams
are really great.

00:39:31.580 --> 00:39:35.530
They show-- they're using all of the
things that I've talked about today.

00:39:35.540 --> 00:39:38.410
They're using floating point
durations and alternate audio and

00:39:38.410 --> 00:39:42.440
iframe playlists and more stuff,
time metadata and closed captions.

00:39:42.570 --> 00:39:45.500
So these are a great
way to test your player.

00:39:45.500 --> 00:39:48.740
If you're running a player,
this gives you some content that you can

00:39:48.740 --> 00:39:53.000
play where you can make sure that you're
picking up time metadata correctly,

00:39:53.000 --> 00:39:57.070
that you're dealing with closed captions,
that you're able to switch

00:39:57.130 --> 00:39:58.830
between alternate audio.

00:39:58.880 --> 00:40:04.860
So I encourage you to take
advantage of these example streams.

00:40:06.070 --> 00:40:10.410
So, that's almost it.

00:40:10.590 --> 00:40:11.500
I'm Eryk Vershen.

00:40:11.500 --> 00:40:15.240
You can email me.

00:40:15.290 --> 00:40:18.240
The documentation, of course,
the tools are available where all

00:40:18.240 --> 00:40:23.860
of our special downloads are in
developer.apple.com/downloads.

00:40:23.940 --> 00:40:28.020
Just go there and search for
HTTP and you'll find the tools.

00:40:28.340 --> 00:40:32.390
I also want to recommend that if
you have questions about HTTP live

00:40:32.570 --> 00:40:36.000
streaming that you don't get
a chance to get answered here.

00:40:36.000 --> 00:40:38.000
That you go to the dev forums.

00:40:38.000 --> 00:40:43.690
Engineers from the HLS team are on
the dev forums answering questions.

00:40:44.350 --> 00:40:46.920
So another pitch for our talk tomorrow.

00:40:47.100 --> 00:40:52.400
Please do come back tomorrow and find
out all the cool new stuff we've done.

00:40:52.440 --> 00:40:54.150
Thank you very much.
WEBVTT

00:00:14.000 --> 00:00:20.440
Welcome to this session on
internationalization tips and tricks.

00:00:20.510 --> 00:00:21.820
My name is Dave DeLoong.

00:00:21.840 --> 00:00:23.880
I am an engineer on the UI kit framework.

00:00:23.960 --> 00:00:27.290
And today we're going to talk
about ways that you can improve

00:00:27.290 --> 00:00:29.980
internationalizing your applications.

00:00:30.560 --> 00:00:34.990
Now you're here because on Monday you
heard some really impressive things.

00:00:34.990 --> 00:00:40.730
Things such as we have sold
over 365 million iOS devices.

00:00:40.760 --> 00:00:44.300
Or that by the end of the year,
the app store will be

00:00:44.510 --> 00:00:47.270
available to 155 countries.

00:00:47.270 --> 00:00:51.540
Chances are most of your users
may not speak your language.

00:00:51.540 --> 00:00:54.850
So we're going to talk about
things that you can do to

00:00:54.980 --> 00:00:56.850
make your app work for them.

00:00:56.900 --> 00:00:59.940
Now there is something to understand.

00:01:00.540 --> 00:01:05.340
Is that for all of these users,
you should be creating one application.

00:01:05.340 --> 00:01:11.240
The iOS app store in 155 countries does
not mean that you should be creating

00:01:11.240 --> 00:01:14.560
155 versions of your application.

00:01:14.560 --> 00:01:17.100
You should be creating one version.

00:01:17.100 --> 00:01:20.850
That same version should work
for everyone regardless of

00:01:20.850 --> 00:01:22.910
where they are in the world.

00:01:22.920 --> 00:01:26.410
You do this by
internationalizing your app.

00:01:26.500 --> 00:01:27.740
What does that mean?

00:01:27.740 --> 00:01:30.200
Internationalization.

00:01:30.650 --> 00:01:35.380
Is the process that we as developers
do to prepare our applications

00:01:35.380 --> 00:01:37.800
to receive translated content.

00:01:37.800 --> 00:01:42.700
This includes things like properly
formatting dates or numbers,

00:01:42.780 --> 00:01:46.890
pulling out translated strings
from our strings table,

00:01:46.890 --> 00:01:47.840
and so on.

00:01:49.190 --> 00:01:54.180
This is in contrast to localization,
which is the process of actually

00:01:54.180 --> 00:01:59.140
integrating that translated
content into our application.

00:01:59.200 --> 00:02:04.720
Let's look at what a simple example
might be of localizing a resource.

00:02:04.780 --> 00:02:09.040
On the left here,
we have selected a strings resource file.

00:02:09.210 --> 00:02:12.820
In this case,
it's the resource for our Info.plist.

00:02:12.940 --> 00:02:16.950
And we can see that it's currently
available in a single language.

00:02:17.040 --> 00:02:21.120
If we want this resource to be
available in another language,

00:02:21.220 --> 00:02:25.410
we'll simply click that plus
button there underneath English and

00:02:25.440 --> 00:02:30.020
choose to add a new language,
such as Spanish, or we can see others

00:02:30.020 --> 00:02:32.490
like Japanese or French.

00:02:32.920 --> 00:02:35.200
That's all we have to do.

00:02:35.280 --> 00:02:38.720
After we've done this,
we'll see that our resource is now

00:02:38.730 --> 00:02:41.390
available in both English and Spanish.

00:02:41.510 --> 00:02:44.360
And there are now two
versions of this file,

00:02:44.360 --> 00:02:47.000
one for English and one for Spanish.

00:02:47.000 --> 00:02:51.340
We have doubled the amount of
content that you need to localize,

00:02:51.380 --> 00:02:54.930
but as is to be expected,
you need different content

00:02:55.030 --> 00:02:56.960
for English and Spanish.

00:02:57.320 --> 00:03:01.950
What happens when you do this is
that in your application directory,

00:03:01.950 --> 00:03:06.970
we will create a new folder called a
Language Specific Project Directory,

00:03:06.970 --> 00:03:07.790
or LPROJ.

00:03:09.440 --> 00:03:13.260
Since we have two versions of our
resource in English and Spanish,

00:03:13.310 --> 00:03:17.510
we have two lproj folders,
one for English, one for Spanish.

00:03:17.510 --> 00:03:21.830
And any localized resource
in English will be located

00:03:21.830 --> 00:03:27.320
within the en lproj folder,
and any Spanish localized resource will

00:03:27.590 --> 00:03:30.460
be inside the Spanish lproj folder.

00:03:31.420 --> 00:03:34.170
Dave DeLoong Localizing
resources is done this way,

00:03:34.280 --> 00:03:39.860
no matter what kind of resource it is,
whether it's an interface builder file,

00:03:39.860 --> 00:03:45.450
a strings table, an image, a plist,
you can all localize them the same way.

00:03:45.500 --> 00:03:49.690
Dave DeLoong One key concept to
understand when dealing with translated

00:03:49.810 --> 00:03:53.810
content is that there is a difference
between the language of your app

00:03:53.810 --> 00:03:56.150
and the region in which it's running.

00:03:56.160 --> 00:03:59.650
Dave DeLoong Here on the left,
we can see the list of languages

00:03:59.650 --> 00:04:01.160
that are available to us.

00:04:01.310 --> 00:04:05.020
Dave DeLoong Here on the right,
we can see the same

00:04:05.020 --> 00:04:07.620
screen running on iOS.

00:04:07.620 --> 00:04:12.070
Dave DeLoong Since the language
can be different from your locale,

00:04:12.070 --> 00:04:16.450
here we can see English as our language,
but Thailand as our locale,

00:04:16.520 --> 00:04:19.800
this can cause some
interesting situations.

00:04:19.800 --> 00:04:23.060
Dave DeLoong For example,
the text of your application

00:04:23.060 --> 00:04:25.960
might be in English,
but when you're formatting

00:04:25.960 --> 00:04:29.060
dates or numbers,
they will be formatted according

00:04:29.060 --> 00:04:31.380
to the title of your application.

00:04:31.380 --> 00:04:34.800
Thailand locale region formats.

00:04:34.900 --> 00:04:39.650
So the names of your months,
the decimal separators used in numbers,

00:04:39.650 --> 00:04:46.180
etc., will all be formatted
according to the locale of Thailand.

00:04:46.180 --> 00:04:51.660
However, your strings are translated
according to the language.

00:04:52.480 --> 00:04:57.960
The main class that we use to determine
this information is called NSLocale.

00:04:57.960 --> 00:05:02.330
NSLocale contains all of the linguistic,
technological,

00:05:02.330 --> 00:05:07.910
and even cultural conventions and
standards for that particular region.

00:05:07.920 --> 00:05:13.040
The way that we access the locale is
using the class method currentLocale.

00:05:13.300 --> 00:05:16.700
This returns a static
object that does not change.

00:05:16.700 --> 00:05:20.340
However,
since the user can change the locale

00:05:20.340 --> 00:05:25.710
of their device... ...at any time,
you may also want to consider using

00:05:25.710 --> 00:05:27.910
the auto-updating currentLocale.

00:05:27.910 --> 00:05:32.660
This is a locale that will correctly
pick up any changes the user may

00:05:32.660 --> 00:05:36.690
make to their date format settings,
to whether or not they want

00:05:36.760 --> 00:05:40.970
time to show as in 12-hour
format versus 24-hour format,

00:05:40.970 --> 00:05:41.820
and so on.

00:05:42.130 --> 00:05:44.700
Regardless of which locale
object you're using,

00:05:44.900 --> 00:05:49.240
you should be listening to the
NSCurrentLocaleDidChange notification.

00:05:49.240 --> 00:05:52.180
This is a notification
posted by the system.

00:05:52.510 --> 00:05:54.280
The system will then send a
notification to the system about

00:05:54.280 --> 00:05:55.280
when these settings change.

00:05:55.340 --> 00:05:59.580
When you receive this notification,
you should update your UI to

00:05:59.600 --> 00:06:02.010
reflect the new locale settings.

00:06:02.140 --> 00:06:05.040
So,
what are we going to talk about today?

00:06:05.240 --> 00:06:10.380
We're going to talk about the four
main areas of localizing your content.

00:06:10.570 --> 00:06:15.010
There are text, dates, numbers,
and images.

00:06:15.180 --> 00:06:17.820
You'll notice that what we
are not going to talk about

00:06:18.230 --> 00:06:21.630
is internationalizing your UI.

00:06:21.860 --> 00:06:24.870
For that,
we recommend that you use AutoLayout,

00:06:24.870 --> 00:06:28.880
which is available in
OSÂ X Lion and now also in iOS 6.

00:06:28.880 --> 00:06:33.010
We've already had two sessions on
AutoLayout on Tuesday and on Thursday,

00:06:33.010 --> 00:06:36.440
so I encourage you to go check
out the videos for those sessions

00:06:36.460 --> 00:06:38.480
when they become available.

00:06:38.840 --> 00:06:41.970
So, let's start off with text.

00:06:42.020 --> 00:06:45.410
Internationalizing your text
will be the bulk of your work

00:06:45.410 --> 00:06:49.280
because text is also likely going
to be the bulk of your content.

00:06:49.280 --> 00:06:53.520
The way that you access your
translated text is with some built-in

00:06:53.520 --> 00:06:55.980
macros called NSLocalizeString.

00:06:55.980 --> 00:07:00.390
There are a couple variants that
give you a little bit of flexibility

00:07:00.390 --> 00:07:04.250
in where you want your translated
text to come from if you're

00:07:04.250 --> 00:07:06.820
providing a default value and so on.

00:07:07.770 --> 00:07:08.820
All of these macros are going
to be available in your app.

00:07:08.830 --> 00:07:14.190
All of these macros are simply
wrappers around an NSBundle method

00:07:14.190 --> 00:07:18.200
called LocalizeStringForKeyValueTable.

00:07:18.870 --> 00:07:22.220
We'll see in a little bit
how that can be useful.

00:07:22.450 --> 00:07:25.780
So where does our text come from?

00:07:25.960 --> 00:07:29.550
It comes from something
called a string table.

00:07:29.750 --> 00:07:33.680
A string table is a file that
lives inside your language

00:07:33.680 --> 00:07:41.090
project directory and by default
it's called localizable.strings.

00:07:41.650 --> 00:07:47.690
Localizable.string simply stores your
translated content in key value pairs,

00:07:47.850 --> 00:07:50.120
very much like an NSDictionary.

00:07:50.300 --> 00:07:54.890
So when you ask for a translated string,
it's simply going to

00:07:55.050 --> 00:07:58.060
look through the file,
find the key that matches

00:07:58.060 --> 00:08:02.420
the one you're looking for,
and return the corresponding value.

00:08:02.710 --> 00:08:05.250
So where do these tables come from?

00:08:05.390 --> 00:08:08.710
Well, if you want,
you can add them to your project yourself

00:08:09.110 --> 00:08:15.010
simply by choosing to add a new file
and then adding a strings file resource.

00:08:15.250 --> 00:08:17.890
However,
there is another way you can do it,

00:08:17.890 --> 00:08:21.400
and that is using the
GenStrings command line utility.

00:08:23.550 --> 00:08:27.900
As the name suggests,
GenStrings is a utility to

00:08:27.900 --> 00:08:30.590
generate strings tables.

00:08:30.710 --> 00:08:35.760
It is built into MacÂ OSÂ X,
so you have it on all of your computers.

00:08:35.970 --> 00:08:39.750
And because it's a command line utility,
it is easily integrated

00:08:39.750 --> 00:08:41.400
into build scripts.

00:08:41.580 --> 00:08:44.800
It is customizable,
so if you're using a custom macro,

00:08:44.960 --> 00:08:46.320
it can handle that.

00:08:46.370 --> 00:08:48.240
It can handle skipping various tables.

00:08:48.300 --> 00:08:53.910
It can handle where you want to output
these generated tables to and so on.

00:08:53.910 --> 00:08:56.350
For a complete list of
all the things it can do,

00:08:56.350 --> 00:08:57.740
check out its man page.

00:08:59.510 --> 00:09:02.720
So what does GenStrings do?

00:09:03.210 --> 00:09:07.390
One way we might invoke
GenStrings is like this.

00:09:07.500 --> 00:09:11.120
This is going to find in the
current directory any files whose

00:09:11.270 --> 00:09:13.540
names end with the .m suffix.

00:09:13.540 --> 00:09:15.140
So we found some.

00:09:15.170 --> 00:09:18.420
It is then going to pass
those files off to GenStrings.

00:09:18.420 --> 00:09:22.630
GenStrings will look through
those files for any uses of

00:09:22.630 --> 00:09:27.160
the NSLocalizeString macro,
build up the strings table,

00:09:27.160 --> 00:09:31.240
and then output it into
your English lproj folder.

00:09:31.270 --> 00:09:36.430
When it comes across a localized
string macro inside your source code,

00:09:36.430 --> 00:09:39.750
GenStrings is going to parse
the arguments and begin to

00:09:39.750 --> 00:09:41.790
build an entry in the table.

00:09:41.890 --> 00:09:43.480
The first argument is the key.

00:09:43.480 --> 00:09:47.480
So GenStrings will simply take that and
copy it down and use that as the key.

00:09:47.480 --> 00:09:51.520
Since this version of the
NSLocalizeString macro does

00:09:51.520 --> 00:09:55.910
not provide a default value,
the same key will be reused as the value.

00:09:55.910 --> 00:10:00.240
The second argument is a comment
to give some context to how

00:10:00.240 --> 00:10:04.580
this string is being used,
and that is simply added to

00:10:04.580 --> 00:10:06.920
the table as the comment.

00:10:06.980 --> 00:10:10.390
Once GenStrings has generated this table,
we can then hand it

00:10:10.390 --> 00:10:13.740
off to our translators,
and they can put in the

00:10:13.800 --> 00:10:15.200
correct value for us.

00:10:15.200 --> 00:10:20.520
So let's talk about some things
to be careful of when dealing

00:10:20.520 --> 00:10:22.310
with internationalizing text.

00:10:22.310 --> 00:10:26.100
First off,
you want to be very careful about using

00:10:26.100 --> 00:10:28.920
an NSLocalizeString macro more than once.

00:10:28.920 --> 00:10:34.240
Let's say your app puts up two alerts,
one asking if you want to run

00:10:34.240 --> 00:10:37.720
a script and the other one
asking how you're feeling.

00:10:37.950 --> 00:10:42.950
If you use the same
NSLocalizeString macro to provide

00:10:42.980 --> 00:10:44.670
a title for the OK button,

00:10:44.970 --> 00:10:47.460
You'll have something like this.

00:10:47.530 --> 00:10:51.450
But then after reading these alerts,
you realize that the response

00:10:51.450 --> 00:10:55.840
of OK is not quite what you
want for running a script.

00:10:56.070 --> 00:10:57.470
You want it to say run.

00:10:57.710 --> 00:11:01.790
And so you change your macro to use run.

00:11:02.400 --> 00:11:06.060
After you do this,
you then rerun your app and notice

00:11:06.220 --> 00:11:10.080
that it asks you how you are
feeling and gives you a response,

00:11:10.190 --> 00:11:11.340
an option of run.

00:11:11.480 --> 00:11:14.190
This is obviously not what we want.

00:11:14.270 --> 00:11:17.430
So what we should be doing instead

00:11:17.740 --> 00:11:23.760
is using two different macros,
one for the first alert

00:11:24.090 --> 00:11:26.030
and one for the second.

00:11:26.300 --> 00:11:30.900
This allows us to easily change
the text without affecting

00:11:30.900 --> 00:11:33.260
any other parts of our UI.

00:11:33.450 --> 00:11:38.500
You'll notice that we also updated
the comments to more accurately

00:11:38.500 --> 00:11:43.640
reflect how these localized
string macros were being used.

00:11:43.880 --> 00:11:48.290
This is because having little
to no context in our localized

00:11:48.470 --> 00:11:51.910
string macros makes things very
difficult for our translators.

00:11:51.910 --> 00:11:54.210
The comments are there for a reason.

00:11:54.270 --> 00:11:55.360
Please use them.

00:11:55.610 --> 00:11:58.600
When your translators
get your strings table,

00:11:58.670 --> 00:12:01.280
this is what they do not want to see.

00:12:01.710 --> 00:12:05.860
They don't want to see no
comment provided by the engineer.

00:12:05.860 --> 00:12:11.900
And show really gives them no information
on what or how this string is being used.

00:12:12.100 --> 00:12:15.630
Is show a verb, as in you want to show
something to the user?

00:12:15.800 --> 00:12:19.380
Or is it a noun,
asking if they want to go see a show?

00:12:19.410 --> 00:12:21.500
There's no way to know.

00:12:21.730 --> 00:12:25.510
So please provide comments and
also use descriptive key names.

00:12:25.510 --> 00:12:29.340
That makes things a lot
easier for your translators.

00:12:30.360 --> 00:12:34.180
As engineers,
we are trained to decompose problems

00:12:34.180 --> 00:12:36.820
into their most fundamental parts.

00:12:36.870 --> 00:12:39.550
And this is a habit of which
we need to break ourselves when

00:12:39.550 --> 00:12:42.090
dealing with internationalized text.

00:12:42.160 --> 00:12:45.900
Composing strings can
be very problematic.

00:12:45.990 --> 00:12:50.410
So remember that the unit of
translation is not the phrase,

00:12:50.550 --> 00:12:52.010
but is the sentence.

00:12:52.320 --> 00:12:58.360
This is because in many languages,
they have concepts of number and gender.

00:12:58.650 --> 00:13:01.380
Some words may be masculine,
some may be feminine.

00:13:01.540 --> 00:13:06.410
Some words may even need to be conjugated
to match the rest of the sentence.

00:13:06.480 --> 00:13:09.480
As an example,
let's say that your text or your

00:13:09.840 --> 00:13:12.100
application has two buttons.

00:13:12.170 --> 00:13:15.900
One says go to next page and the
other says go to next chapter.

00:13:15.900 --> 00:13:21.900
And so you decompose the problem
and you have go to next something.

00:13:21.900 --> 00:13:27.070
And then you will substitute in
at runtime either page or chapter.

00:13:27.430 --> 00:13:31.000
On the surface,
this may not seem like a bad idea.

00:13:31.050 --> 00:13:34.850
However, when your translator
tries to translate this,

00:13:34.970 --> 00:13:38.080
he's going to start with,
go to next page.

00:13:38.160 --> 00:13:42.500
Well, page in many languages
is a feminine noun.

00:13:42.530 --> 00:13:48.150
That means that the adjective next must
also match in both number and gender.

00:13:48.330 --> 00:13:52.480
Some languages may even require the
definite article the to be in there,

00:13:52.520 --> 00:13:55.990
which also must match
in number and gender.

00:13:56.140 --> 00:14:00.620
So here we have a sentence with
three feminine singular words.

00:14:00.890 --> 00:14:04.320
However,
when he goes to translate chapter,

00:14:04.970 --> 00:14:06.780
He runs into problems.

00:14:06.830 --> 00:14:10.550
That is because chapter in many
languages is a masculine noun,

00:14:10.710 --> 00:14:14.700
which means that both the and next
must also match in number and gender.

00:14:14.700 --> 00:14:18.620
They are different words,
and the result is that he cannot

00:14:18.620 --> 00:14:20.760
translate this accurately.

00:14:20.760 --> 00:14:25.240
Any attempt to translate this would
result in something that is incorrect.

00:14:25.600 --> 00:14:27.730
Dave DeLoong He runs into problems.

00:14:27.730 --> 00:14:31.290
That is because chapter in many
languages is a masculine noun,

00:14:31.290 --> 00:14:35.500
which means that both the and next
must also match in number and gender.

00:14:35.600 --> 00:14:39.970
Any attempt to translate this would
result in something that is incorrect.

00:14:39.970 --> 00:14:39.970
Any attempt to translate this would
result in something that is incorrect.

00:14:40.360 --> 00:14:44.410
There are times that we need to
display a list of strings to our users.

00:14:44.630 --> 00:14:49.890
Perhaps we're ordering a list of users,
like an address book.

00:14:50.890 --> 00:14:53.320
In these cases,
we should not be using the

00:14:53.400 --> 00:14:58.350
compare method on NSString to
order this list of strings.

00:14:58.450 --> 00:15:02.010
Instead,
we should be using the NSString method

00:15:02.230 --> 00:15:04.490
localized standard compare.

00:15:04.660 --> 00:15:09.510
This is a comparison that will take
into account the user's locale and

00:15:09.510 --> 00:15:15.410
it will do a case sensitive and
diacritic sensitive comparison.

00:15:16.890 --> 00:15:20.250
As such, you should avoid using case
and diacritic insensitivity.

00:15:20.510 --> 00:15:23.540
Let's see why.

00:15:23.910 --> 00:15:27.930
Our example is that we have
these eight strings in Swedish.

00:15:29.660 --> 00:15:34.600
And we want to see how they get sorted
using these three NSString methods:

00:15:34.620 --> 00:15:37.510
compare,
localized case-insensitive compare,

00:15:37.700 --> 00:15:40.440
and localized standard compare.

00:15:40.570 --> 00:15:43.200
If we sort them according
to the compare method,

00:15:43.260 --> 00:15:45.150
we'll get this.

00:15:45.960 --> 00:15:50.900
For users in your Swedish locale,
this is incorrect.

00:15:51.170 --> 00:15:54.990
In Swedish,
A with the umlaut comes lexically after

00:15:55.460 --> 00:15:57.510
all the other characters in the alphabet.

00:15:57.630 --> 00:16:00.800
It is similar to-- it
comes after the letter Z.

00:16:01.020 --> 00:16:03.340
Additionally,
the lowercase letters should

00:16:03.430 --> 00:16:05.670
precede the uppercase letters.

00:16:05.800 --> 00:16:09.920
So compare is the wrong thing
to use in this situation.

00:16:09.960 --> 00:16:12.340
If we tried to do a
case-insensitive compare,

00:16:12.550 --> 00:16:14.370
we'll get this.

00:16:15.240 --> 00:16:19.100
The A with the umlaut is correctly
placed at the end of the list,

00:16:19.290 --> 00:16:21.620
but because we want
everything to be consistent,

00:16:21.730 --> 00:16:22.640
this is still wrong.

00:16:22.860 --> 00:16:27.020
In some cases, uppercase letters come
before lowercase letters,

00:16:27.020 --> 00:16:30.800
and so we should not use
case-insensitive searching either,

00:16:30.800 --> 00:16:31.930
or sorting.

00:16:32.640 --> 00:16:36.420
If we use localized standard compare,
we get the correct result.

00:16:36.480 --> 00:16:40.950
Lowercase letters come first,
and the A with the umlaut

00:16:41.040 --> 00:16:42.990
is at the end of the list.

00:16:44.670 --> 00:16:49.320
Similar to sorting is
searching through strings.

00:16:49.670 --> 00:16:55.790
Here you may use casein
diacritic insensitivity.

00:16:55.790 --> 00:16:55.790
However,

00:16:56.290 --> 00:16:59.800
You should avoid using range of string.

00:16:59.910 --> 00:17:05.380
This is because range of string does
not take into account the user's locale.

00:17:05.500 --> 00:17:08.560
It uses the system locale.

00:17:08.730 --> 00:17:12.100
The system locale is the
ultimate fallback locale.

00:17:12.320 --> 00:17:15.090
It is the locale to which all
other locales run if they can't

00:17:15.220 --> 00:17:16.990
provide an answer themselves.

00:17:17.000 --> 00:17:23.060
So when searching through strings,
please remember to specify the

00:17:23.110 --> 00:17:29.490
locale yourself using the range of
strings options range locale method

00:17:29.490 --> 00:17:34.960
passing in the current locale or
the auto updating current locale.

00:17:34.960 --> 00:17:39.770
Some of our users may be running
their device in Hebrew or Arabic,

00:17:39.770 --> 00:17:42.500
which are right to left languages.

00:17:42.500 --> 00:17:46.390
However, for some of them,
and in some situations,

00:17:46.390 --> 00:17:46.950
they can't find the correct location.

00:17:47.020 --> 00:17:49.860
So they can actually have
mixed directionality.

00:17:49.860 --> 00:17:56.060
So their right to left text can
contain left to right substrings.

00:17:56.120 --> 00:17:58.960
For example,
if we have this string in Arabic,

00:17:58.960 --> 00:18:03.350
it contains parts that are right to left,
a portion that is left to right,

00:18:03.350 --> 00:18:05.910
and another part that is right to left.

00:18:06.250 --> 00:18:10.360
However,
when this string is stored in memory,

00:18:10.360 --> 00:18:13.890
it is stored in a single logical order.

00:18:16.090 --> 00:18:19.150
And so if you are doing any
manipulations on this string,

00:18:19.440 --> 00:18:23.290
such as needing to search
through this string character

00:18:23.290 --> 00:18:26.580
by character or word by word,
you need to remember

00:18:26.580 --> 00:18:28.280
about directionality.

00:18:28.360 --> 00:18:32.870
On the subject of parsing,
the key thing to remember is that not

00:18:32.870 --> 00:18:36.780
every character fits inside a unichar.

00:18:36.870 --> 00:18:38.710
What does this mean?

00:18:39.980 --> 00:18:43.410
Let's say we have the string
capital E with a cute accent and

00:18:43.410 --> 00:18:44.760
we want to know how long it is.

00:18:44.960 --> 00:18:47.830
Well, we use the length method, right?

00:18:47.980 --> 00:18:51.680
So if we use the length method on
this string to see how long it is,

00:18:51.900 --> 00:18:53.560
we'll get one.

00:18:53.630 --> 00:18:58.180
Let's say that we've got the string
capital E with a cute accent and

00:18:58.190 --> 00:19:00.490
we want to know how long it is.

00:19:00.630 --> 00:19:03.330
So we use the length method
and ask it how long it is.

00:19:03.590 --> 00:19:04.720
What do we get?

00:19:04.790 --> 00:19:07.480
Two, of course.

00:19:07.690 --> 00:19:09.150
What's going on?

00:19:09.270 --> 00:19:12.780
Well, in the first situation,
capital E with a cute accent is

00:19:12.780 --> 00:19:15.790
being stored as a single character.

00:19:16.330 --> 00:19:21.200
The second example, however,
capital E with acute accent is actually

00:19:21.200 --> 00:19:25.410
being stored as two characters,
the first being the capital

00:19:25.500 --> 00:19:30.510
letter E and the second being
the combining acute accent mark,

00:19:30.790 --> 00:19:35.970
which means to place an acute
accent over the previous character.

00:19:36.950 --> 00:19:40.270
Extending this a little further,
let's say we want to know

00:19:40.300 --> 00:19:41.860
how long Hamburger is.

00:19:41.860 --> 00:19:46.050
And so we ask, and of course the length
of Hamburger is two.

00:19:46.790 --> 00:19:50.540
Or we want to know how long
the US flag is and we ask,

00:19:50.650 --> 00:19:53.100
and it is four characters long.

00:19:53.230 --> 00:19:56.870
So if we were to try and iterate
through these strings using

00:19:57.080 --> 00:20:00.960
length and character at index,
there are times where we

00:20:00.990 --> 00:20:04.620
might get a whole character,
such as the first example,

00:20:04.620 --> 00:20:09.110
or there are times where we might
only get one fourth of the character,

00:20:09.110 --> 00:20:10.890
such as with the US flag.

00:20:11.860 --> 00:20:15.900
So, you should avoid,
when dealing with user visible strings,

00:20:15.900 --> 00:20:20.060
you should avoid using methods
such as character at index,

00:20:20.060 --> 00:20:24.470
length, and also precompose string
with canonical mapping.

00:20:26.030 --> 00:20:28.880
Dave DeLoong: They will often lead
you to the wrong result.

00:20:28.990 --> 00:20:33.080
What you should use instead
is the NSString method,

00:20:33.150 --> 00:20:37.530
enumerate substrings in
range options using block.

00:20:37.760 --> 00:20:40.900
This is a method that allows
you to iterate over a string,

00:20:40.900 --> 00:20:45.740
perhaps character by character,
and that will correctly take

00:20:45.740 --> 00:20:52.660
into account combining accent
marks or emoji or et cetera.

00:20:52.840 --> 00:20:55.630
Or you can iterate through
a string word by word.

00:20:55.660 --> 00:20:59.260
Or sentence by sentence
or paragraph by paragraph.

00:20:59.260 --> 00:21:02.220
And using this method,
you can count up how many

00:21:02.220 --> 00:21:07.170
characters are in a string,
what's the 42nd word, et cetera.

00:21:08.360 --> 00:21:13.340
So let's talk about some tips to make
dealing with text a little bit easier.

00:21:13.490 --> 00:21:15.810
First off, you can use multiple tables.

00:21:15.960 --> 00:21:19.940
You're not limited to just
localizable dot strings.

00:21:20.060 --> 00:21:23.450
So going back to our original
example that we saw in the beginning,

00:21:23.590 --> 00:21:27.900
we can add strings tables
for perhaps our app delegate,

00:21:28.010 --> 00:21:32.170
the root view controller,
our data view controller.

00:21:32.550 --> 00:21:38.510
Providing multiple strings tables adds
even more context to our translators.

00:21:38.630 --> 00:21:42.620
They know that anything inside
the app delegate dot strings table

00:21:42.620 --> 00:21:46.560
contains text that will only be
used by the application delegate.

00:21:46.560 --> 00:21:51.050
Or text inside the root view controller
dot strings table will only be

00:21:51.050 --> 00:21:53.460
used by the root view controller.

00:21:53.460 --> 00:21:55.870
And so if they know what
is on those screens,

00:21:55.960 --> 00:21:58.580
they get even more
contextual information.

00:21:58.580 --> 00:22:01.940
This is also good for
encapsulation principles.

00:22:02.400 --> 00:22:07.790
While you're building your application,
you should pseudo-localize it to help

00:22:07.880 --> 00:22:13.300
you easily find places where you have
forgotten to use NSLocalizeString.

00:22:13.300 --> 00:22:15.560
What is pseudo-localization?

00:22:15.560 --> 00:22:19.690
It simply means to take your existing
strings and manipulate them in

00:22:19.690 --> 00:22:23.750
such a way so that you can tell
if they've been translated or not.

00:22:23.800 --> 00:22:27.190
So if we were to
pseudo-localize this screen,

00:22:27.190 --> 00:22:31.390
perhaps we get something like this,
where we've inserted

00:22:31.410 --> 00:22:32.380
hyphens between the strings.

00:22:32.400 --> 00:22:34.920
between the word back.

00:22:35.600 --> 00:22:52.000
[Transcript missing]

00:22:52.270 --> 00:22:53.650
Now what about this thing down here?

00:22:53.840 --> 00:22:58.110
Well, as it turns out,
that is the name January in Thai.

00:22:58.420 --> 00:23:00.900
Why does this not have hyphens?

00:23:00.990 --> 00:23:05.960
This doesn't have hyphens because it's
being provided by an NSDate formatter.

00:23:06.090 --> 00:23:09.720
For things such as dates and numbers,
you do not need to

00:23:09.900 --> 00:23:12.200
translate them yourselves.

00:23:12.350 --> 00:23:16.880
They can be translated for you
by using the NSDate formatter

00:23:16.880 --> 00:23:19.780
and NSNumber formatter classes.

00:23:20.190 --> 00:23:23.860
On the subject of pseudo-localization,
you can also use custom macros,

00:23:23.860 --> 00:23:26.110
as I mentioned earlier.

00:23:26.320 --> 00:23:30.130
So normally,
you might use NSLocalizeString to

00:23:30.140 --> 00:23:32.350
get the title of a back button.

00:23:32.660 --> 00:23:35.090
What you can also do

00:23:35.680 --> 00:23:38.470
is to find your own function,
in this case,

00:23:38.500 --> 00:23:41.420
ICT root view controller string.

00:23:42.120 --> 00:23:46.480
You can then define your own function,
ITT root view controller string

00:23:46.530 --> 00:23:50.380
that takes a key and a comment,
just like NSLocalizeString.

00:23:51.070 --> 00:23:54.890
And remember how NSLocalizeString
simply passes on to NSBundle to

00:23:55.070 --> 00:23:56.760
find the correct string?

00:23:56.760 --> 00:23:59.400
Well, we can do the same thing ourselves.

00:23:59.440 --> 00:24:02.550
And then perhaps if we're
running in debug mode,

00:24:02.620 --> 00:24:04.930
we can pseudo-localize it.

00:24:05.080 --> 00:24:09.890
So we can encapsulate all of our
pseudo-localization logic in one

00:24:09.890 --> 00:24:15.570
place without actually having to
generate entirely new strings files.

00:24:16.420 --> 00:24:19.660
This also works with
the GenStrings utility.

00:24:19.800 --> 00:24:22.400
With GenStrings,
you can tell it to instead of

00:24:22.440 --> 00:24:27.730
looking for NSLocalizeString,
to look for ITTRootViewControllerString.

00:24:27.730 --> 00:24:33.120
And then it will also look for
ITTRootViewControllerString in table,

00:24:33.180 --> 00:24:36.760
ITTRootViewControllerString
with default value,

00:24:36.760 --> 00:24:37.650
and so on.

00:24:37.950 --> 00:24:40.160
Let's talk about dates.

00:24:40.240 --> 00:24:45.800
We have observed many people doing
some pretty bad things with dates.

00:24:46.580 --> 00:24:51.640
So let's talk about what a date is.

00:24:51.640 --> 00:24:57.640
An NSDate object is simply a
wrapper around an NSTimeInterval.

00:24:57.680 --> 00:24:59.160
That's it.

00:24:59.250 --> 00:25:00.490
It is nothing more than that.

00:25:00.670 --> 00:25:02.500
It is nothing less.

00:25:02.630 --> 00:25:09.630
It is specifically a time interval
relative to a well-defined point in time.

00:25:09.730 --> 00:25:13.980
It does not have any
calendar associated with it.

00:25:13.980 --> 00:25:16.860
It does not have any time
zone associated with it.

00:25:16.880 --> 00:25:20.890
It is simply a point in time.

00:25:22.020 --> 00:25:24.280
So for example, here is now.

00:25:24.410 --> 00:25:26.660
And of course, as we know,
time extends into the past and

00:25:26.850 --> 00:25:28.260
goes forward into the future.

00:25:28.420 --> 00:25:29.660
That's all an NSDate is.

00:25:29.660 --> 00:25:32.130
It's just a point in time.

00:25:33.540 --> 00:25:41.750
We can format a date for visual
consumption using an NSDate formatter.

00:25:42.870 --> 00:25:48.910
An NSDate formatter converts a date
to and from human readable form.

00:25:49.200 --> 00:25:54.190
It is created automatically with
the current system settings.

00:25:55.320 --> 00:25:59.060
It is locale sensitive,
as we saw earlier how the name

00:25:59.130 --> 00:26:03.640
of the month was automatically
translated for us into Thai.

00:26:04.360 --> 00:26:08.510
And by far the easiest way to
convert a date into a string

00:26:08.790 --> 00:26:13.820
is to use the class method,
localizeStringFromDate, dateStyle,

00:26:13.820 --> 00:26:14.660
timeStyle.

00:26:14.970 --> 00:26:18.600
The dateStyle and timeStyle
parameters allow you to tell the

00:26:18.600 --> 00:26:24.220
date formatter whether you want
no date and simply want the time,

00:26:24.250 --> 00:26:28.270
whether you want a long style,
so for example,

00:26:28.270 --> 00:26:32.450
the full spelled out name of the
month and day with the year and so on.

00:26:32.950 --> 00:26:38.140
That's really going to cover
about 90% of your use cases.

00:26:39.910 --> 00:26:46.190
However, there are times where you may
need to specify a format string.

00:26:46.190 --> 00:26:46.190
Well,

00:26:46.670 --> 00:26:49.900
You think you do,
but you should really avoid

00:26:49.900 --> 00:26:52.420
doing that as much as possible.

00:26:52.420 --> 00:26:54.920
Let's see this example,
where we want to format

00:26:54.920 --> 00:26:57.380
a date with the month,
the day, and the year.

00:26:57.660 --> 00:27:03.360
So we put in the format string m/dd/yyyy.

00:27:04.130 --> 00:27:09.220
When we localize a date
using this date formatter,

00:27:09.250 --> 00:27:11.260
we'll get this.

00:27:11.340 --> 00:27:15.030
For our users in the United States,
that may be the correct format.

00:27:15.110 --> 00:27:21.060
However, for your users in China,
that is not how they display dates.

00:27:21.220 --> 00:27:22.740
And that is wrong.

00:27:22.940 --> 00:27:27.470
So what you should instead do is
use the appropriate date style,

00:27:27.570 --> 00:27:30.010
in this case a short date style.

00:27:30.720 --> 00:27:34.450
And now your dates will be
correctly localized according to

00:27:34.450 --> 00:27:37.060
the user's settings and preferences.

00:27:37.110 --> 00:27:40.700
So for your users in China,
they will see dates according

00:27:40.780 --> 00:27:41.700
to their preference.

00:27:41.730 --> 00:27:46.850
And for your users in the United States,
they will see dates formatted according

00:27:46.860 --> 00:27:49.890
to their preferences and format settings.

00:27:50.810 --> 00:27:54.230
But what about for situations
where the date and time

00:27:54.230 --> 00:27:56.170
styles don't meet your needs?

00:27:56.520 --> 00:28:00.930
The date styles generally
show the full year-month day.

00:28:01.070 --> 00:28:05.030
But what if you just want to
show the month in the day?

00:28:05.540 --> 00:28:09.960
Well for that,
you might try doing something like this,

00:28:10.090 --> 00:28:13.710
just using the month and
the day format string.

00:28:14.610 --> 00:28:17.790
Well, for your users in France,
they'll get the name of the month

00:28:18.020 --> 00:28:19.660
followed by the day of the month.

00:28:19.800 --> 00:28:22.510
And for your users in China,
they will get the month

00:28:22.730 --> 00:28:26.610
with the appropriate month
symbol followed by the day.

00:28:26.830 --> 00:28:28.260
These are both wrong.

00:28:28.440 --> 00:28:31.290
So what should you be doing instead?

00:28:33.190 --> 00:28:35.990
There is a class method
on NSDateFormatter called

00:28:36.140 --> 00:28:39.560
DateFormatFromTemplateOptionsLocale.

00:28:39.680 --> 00:28:43.590
This is a method that allows you
to pass that same format string

00:28:43.590 --> 00:28:48.090
you would have used and get a
localized version of that string

00:28:48.090 --> 00:28:51.080
according to the locale you pass in.

00:28:51.220 --> 00:28:53.940
So we'll take that same
date format string,

00:28:54.080 --> 00:28:58.180
asking for the month and the day,
and passing in our current locale,

00:28:58.320 --> 00:29:00.160
and it will return a format string.

00:29:00.250 --> 00:29:03.750
Doesn't matter what the string is,
we just take it and set it

00:29:03.830 --> 00:29:05.510
into our date formatter.

00:29:06.150 --> 00:29:11.070
Now when we localize our date,
we can see that the date format string

00:29:11.070 --> 00:29:14.830
for our users in France returns the
day before the name of the month.

00:29:14.830 --> 00:29:18.550
And for your users in China,
you will get the month followed

00:29:18.730 --> 00:29:23.280
by the day with the appropriate
symbols after each component.

00:29:23.400 --> 00:29:27.490
Occasionally, we may ask our users to
type in a date for us,

00:29:27.510 --> 00:29:32.150
or we may receive a date over a
network connection and we'll need

00:29:32.150 --> 00:29:34.790
to parse it into an NSDate object.

00:29:35.120 --> 00:29:39.180
We need to remember in these
situations to explicitly configure

00:29:39.180 --> 00:29:41.190
the date formatter object.

00:29:41.550 --> 00:29:47.040
So let's say we are given the
string 06-15-2012 and we want

00:29:47.040 --> 00:29:49.120
to turn it into an NSDate.

00:29:49.170 --> 00:29:54.120
If we simply do this,
then perhaps in many situations

00:29:54.180 --> 00:29:56.560
we'll get the correct NSDate.

00:29:56.970 --> 00:30:02.890
But if our users are, say,
using the Japanese imperial calendar,

00:30:03.040 --> 00:30:10.280
where the current year is the year 24,
then 6/15/2012 represents a date that

00:30:10.280 --> 00:30:13.240
is nearly 2,000 years in the future.

00:30:13.900 --> 00:30:17.390
Or if your users are
using the Hebrew calendar,

00:30:17.390 --> 00:30:25.820
the date 6/15/2012 represents a date
that is 3,500 years in the past.

00:30:26.030 --> 00:30:28.490
So how do we fix this?

00:30:29.620 --> 00:30:34.900
We need to tell the date formatter
what calendaring system we're using.

00:30:35.040 --> 00:30:39.170
And so we instantiate the
appropriate NSCalendar object,

00:30:39.270 --> 00:30:42.740
and then we tell the date formatter,
use this calendar for

00:30:42.770 --> 00:30:44.500
interpreting this date.

00:30:44.500 --> 00:30:48.360
What is NSCalendar?

00:30:50.280 --> 00:30:53.160
Optionally,
there are times where you will

00:30:53.160 --> 00:30:55.380
receive an unlocalized date.

00:30:55.380 --> 00:30:59.410
Perhaps it's a timestamp
given to you by a server.

00:30:59.890 --> 00:31:07.350
In this case, you can use the C function,
strptime_l, to parse that string into a

00:31:07.370 --> 00:31:11.780
time interval from which you can
then construct an NSDate object.

00:31:11.870 --> 00:31:15.800
So,
this is all being driven by NSCalendar.

00:31:15.940 --> 00:31:19.770
NSCalendar is an object that
represents a calendaring system.

00:31:19.920 --> 00:31:22.130
We have support for
the Gregorian calendar,

00:31:22.130 --> 00:31:27.730
of course, Japanese, Imperial, Persian,
Islamic, Hebrew, Buddhist,

00:31:27.850 --> 00:31:28.790
many different calendars.

00:31:28.800 --> 00:31:34.770
And this calendar object contains all
of the calculations and transformations

00:31:34.770 --> 00:31:40.070
and algorithms necessary to
properly convert between strings

00:31:40.450 --> 00:31:44.530
and dates in that calendaring system.

00:31:44.530 --> 00:31:46.070
It can also do things like

00:31:46.400 --> 00:31:47.740
Adding intervals to dates.

00:31:47.900 --> 00:31:49.900
Say you want to add one week to a date.

00:31:49.900 --> 00:31:52.440
It can handle that as well.

00:31:54.120 --> 00:32:01.350
So if we have time again,
today is June 15, 2012.

00:32:01.580 --> 00:32:05.190
So we have an NSDate object
representing today.

00:32:05.600 --> 00:32:10.500
This is that NSDate formatted
according to the Gregorian calendar.

00:32:10.650 --> 00:32:14.040
However,
that same NSDate can be formatted

00:32:14.050 --> 00:32:20.030
in many different ways depending on
what calendar object we are using.

00:32:20.150 --> 00:32:24.900
Remember that an NSDate is simply
a wrapper around a time interval.

00:32:25.040 --> 00:32:29.190
Since it contains no inherent
calendaring information,

00:32:29.230 --> 00:32:34.400
we need to use a calendar to turn
that into a human readable date.

00:32:34.700 --> 00:32:40.200
So these seven examples are
all the same NSDate object,

00:32:40.210 --> 00:32:44.600
just formatted using different calendars.

00:32:44.870 --> 00:32:49.460
Another problem that we run into
sometimes when trying to parse a string

00:32:49.460 --> 00:32:52.540
into a date is forgetting the time zone.

00:32:53.180 --> 00:32:55.360
So when we are parsing a
date and storing a date,

00:32:55.480 --> 00:32:59.250
we need to remember what
time zone we are in.

00:32:59.370 --> 00:33:02.470
So for example, let's say we have this
string representing a little

00:33:02.490 --> 00:33:06.750
bit earlier this morning,
and we want to turn it into an NSDate.

00:33:06.800 --> 00:33:11.400
Well, if we simply just construct a
date formatter and set the format,

00:33:11.400 --> 00:33:15.380
then for our users in San Francisco,
being seven hours behind

00:33:15.380 --> 00:33:18.410
Greenwich Mean Time,
they will get an NSDate for

00:33:18.760 --> 00:33:20.730
9.42 that morning.

00:33:22.000 --> 00:33:25.600
However, your users in Beijing,
being eight hours ahead

00:33:25.620 --> 00:33:29.740
of Greenwich Mean Time,
will also get an NSDate representing

00:33:29.800 --> 00:33:32.380
their 9.42 in the morning.

00:33:32.380 --> 00:33:36.220
This is incorrect.

00:33:37.190 --> 00:33:40.450
What we instead need to do
is tell the date formatter,

00:33:40.720 --> 00:33:45.920
this string is actually in
Greenwich Mean Time already.

00:33:46.220 --> 00:33:50.310
Then when we try to parse it,
for users in San Francisco,

00:33:50.320 --> 00:33:55.070
they will get 2:42 in the morning,
being seven hours behind GMT.

00:33:55.260 --> 00:33:59.370
And for your users in Beijing,
they will get 5:42 in the evening,

00:33:59.370 --> 00:34:01.100
being eight hours ahead.

00:34:01.150 --> 00:34:06.250
You do not need to worry about adding
time intervals to the date yourself.

00:34:06.450 --> 00:34:12.560
Simply use the correct time zone
when configuring your date formatter.

00:34:12.710 --> 00:34:14.020
So NSTimeZone.

00:34:14.280 --> 00:34:18.220
All it is is simply another
wrapper around a time offset.

00:34:18.270 --> 00:34:20.450
Except this one,
instead of being relative

00:34:20.570 --> 00:34:25.240
to a specific point in time,
is relative to coordinated

00:34:25.240 --> 00:34:27.080
universal time.

00:34:27.660 --> 00:34:32.600
So, if we have time again,
with a date representing now,

00:34:32.600 --> 00:34:38.070
then we can format that same
NSDate object in many different

00:34:38.090 --> 00:34:43.850
ways simply by changing the
time zone of the date formatter.

00:34:45.160 --> 00:34:54.890
So 4:42 PM is the same date as 9:42
AM in Pacific Daylight Time and is

00:34:54.910 --> 00:35:00.390
the same NSDate as 1:42 AM in Japan.

00:35:01.880 --> 00:35:04.720
So,
some tips on dealing with dates properly.

00:35:04.720 --> 00:35:08.710
How many of you have seen this before?

00:35:08.930 --> 00:35:13.890
86,400, or 24 times 60 times 60.

00:35:14.710 --> 00:35:18.510
99% of the time,
this is the wrong thing to use.

00:35:18.680 --> 00:35:23.630
One date is not 86,400 seconds.

00:35:23.740 --> 00:35:27.190
One day is not 24 hours.

00:35:27.520 --> 00:35:30.480
Let's say we have a date
corresponding to March 10th,

00:35:30.480 --> 00:35:32.690
2012 at 11:50 p.m.

00:35:32.920 --> 00:35:35.530
and we want to add 24 hours to it.

00:35:35.740 --> 00:35:42.210
So we add 86,400,
expecting March 11th at 11:50

00:35:42.210 --> 00:35:48.380
p.m., but we're surprised to find
that we actually get March 12th.

00:35:48.470 --> 00:35:50.370
What's going on?

00:35:50.820 --> 00:35:55.380
Well, in many places around the world,
March 11th is when the daylight

00:35:55.460 --> 00:35:57.580
savings time transition happened.

00:35:57.730 --> 00:36:01.730
And so there were only
23 hours on that day.

00:36:01.890 --> 00:36:08.700
So by explicitly adding 24 hours,
we have ended up with the wrong result.

00:36:08.840 --> 00:36:11.490
What should we do to fix this?

00:36:12.010 --> 00:36:17.210
Well, we can simply construct an
NSDateComponents object.

00:36:18.010 --> 00:36:23.180
And we tell it to represent one
day and then ask our calendar to

00:36:23.180 --> 00:36:26.080
add one day to that date for us.

00:36:26.200 --> 00:36:29.390
And NS Calendar is smart enough
to know about things like

00:36:29.390 --> 00:36:32.610
daylight savings time transitions.

00:36:32.990 --> 00:36:37.050
It will correctly handle
days that are 23 hours long,

00:36:37.050 --> 00:36:39.370
24 and 25 hours long.

00:36:39.430 --> 00:36:43.830
And so when we add one day
to March 10th at 11:50 PM,

00:36:43.840 --> 00:36:47.860
we correctly get March 11th at 11:50 PM.

00:36:48.030 --> 00:36:52.290
This is done, as I mentioned,
using the date components class.

00:36:53.440 --> 00:36:58.640
NSDate components represent
portions of a calendrical date.

00:36:58.710 --> 00:37:01.740
NSDate, as we remember,
is a point in time.

00:37:01.960 --> 00:37:10.640
NSDate components are the various parts
of a formatted human readable date.

00:37:10.660 --> 00:37:14.960
And as we saw,
it can be a relative difference.

00:37:15.750 --> 00:37:19.840
So, for example,
if we have this NSDate components object,

00:37:19.930 --> 00:37:25.190
we can set the month to 13,
the date to 3, and the year to 2000.

00:37:25.520 --> 00:37:29.050
Now this can be perhaps
an interval of 13 months,

00:37:29.340 --> 00:37:31.910
three days, and 2,000 years.

00:37:32.240 --> 00:37:38.630
Or if we were to use a calendar to
convert this back into an NSDate,

00:37:38.800 --> 00:37:42.450
then in some calendaring
systems which have 13 months,

00:37:42.450 --> 00:37:48.000
that might be the third day of
the 13th month of the 2000th year.

00:37:48.000 --> 00:37:51.830
If we use a calendar like
the Gregorian calendar,

00:37:51.870 --> 00:37:58.000
for example, we could actually get
January 3rd of the year 2001.

00:37:58.000 --> 00:38:03.990
NS calendar will handle
unit rollovers for us.

00:38:06.630 --> 00:38:09.720
There are times where we may
need to know how long a unit is.

00:38:09.820 --> 00:38:13.310
Say we're building a calendaring
app and we want to know how

00:38:13.390 --> 00:38:15.300
many months should we draw.

00:38:15.460 --> 00:38:21.220
Well, we should not assume there are 12,
because many calendars have 13.

00:38:21.890 --> 00:38:26.520
So we can ask our calendar,
how long are months?

00:38:26.520 --> 00:38:27.840
How many months in a year do you have?

00:38:28.060 --> 00:38:34.020
And we'll get back 13 in many situations,
perhaps 12 in others.

00:38:35.350 --> 00:38:38.970
We can also ask how long is
this unit for a specific date?

00:38:39.070 --> 00:38:44.360
So given a date of June 15th,
we can ask how many days are

00:38:44.370 --> 00:38:49.420
in that month and we will get
back an NS range of 1 to 30.

00:38:49.610 --> 00:38:52.980
That means that the first day
of the month is the first and

00:38:52.980 --> 00:38:55.390
there are 30 days in that month.

00:38:56.250 --> 00:39:00.290
Should not try to hard code in
a leap year algorithm yourself.

00:39:00.470 --> 00:39:03.990
Simply use NSCalendar to
ask how many days are in,

00:39:03.990 --> 00:39:05.750
for example, February.

00:39:06.110 --> 00:39:11.710
And it will tell you either 28 or 29,
depending on the year.

00:39:14.700 --> 00:39:18.960
We talked a little bit earlier about
date templates and localizing format

00:39:19.050 --> 00:39:24.550
strings when the built-in options
don't allow for what we want to do.

00:39:24.920 --> 00:39:28.900
There is a special case to this,
and that is with time.

00:39:30.600 --> 00:39:35.400
How should we know whether to use
AM or PM when displaying a time?

00:39:35.780 --> 00:39:42.740
Do we know whether the user prefers 1
through 12 with an AM or PM or perhaps 0

00:39:42.740 --> 00:39:47.910
through 23 or perhaps even 1 through 24?

00:39:48.040 --> 00:39:51.970
We can use a special template called J.

00:39:53.110 --> 00:39:59.310
When you run j through the date format
from template method on NSDateFormatter,

00:39:59.430 --> 00:40:05.890
it will return a time format
string specific to that locale.

00:40:06.400 --> 00:40:11.040
So in the United States,
which uses an AM and PM,

00:40:11.310 --> 00:40:15.140
you will get back 1 through
12 and an AM and PM.

00:40:15.330 --> 00:40:21.140
Or for your users in France,
you will get 00 through 23.

00:40:21.390 --> 00:40:25.750
And it will also correctly
handle whether or not the AM and

00:40:25.750 --> 00:40:30.490
PM should come before the hour,
such as in China or Korea.

00:40:30.780 --> 00:40:37.410
So you can use J for formatting an
hour according to your user's settings.

00:40:39.710 --> 00:40:43.490
The final thing to remember
when dealing with dates is that

00:40:43.490 --> 00:40:45.970
1+1 does not always equal 2.

00:40:46.580 --> 00:40:50.650
Let's say we have these three months,
January, February, and March.

00:40:50.920 --> 00:40:53.920
And we want to add two months.

00:40:54.350 --> 00:40:57.090
to January 31st.

00:40:57.090 --> 00:41:01.400
So we add one month and get
the last day of February,

00:41:01.400 --> 00:41:02.940
the 28th.

00:41:02.950 --> 00:41:06.950
And we add one month again
and end up with March 28th.

00:41:07.140 --> 00:41:12.470
Well, March 28th isn't really two
months after January 31st.

00:41:12.940 --> 00:41:19.900
So when doing date additions like this,
you should always be doing your

00:41:19.900 --> 00:41:25.830
additions relative to your starting
date and not to any intermediate dates.

00:41:25.830 --> 00:41:31.520
If we start with January 31st and
simply add two months directly to it,

00:41:31.560 --> 00:41:35.350
we will end up with
the correct March 31st.

00:41:35.350 --> 00:41:39.600
So don't use intermediate
dates for date calculations.

00:41:40.460 --> 00:41:43.170
Let's talk about numbers.

00:41:43.340 --> 00:41:45.460
Numbers are fairly simple.

00:41:45.460 --> 00:41:48.520
Like NSDateFormatter,
we have a built-in class

00:41:48.550 --> 00:41:51.810
called NSNumberFormatter,
and it is similar to

00:41:51.810 --> 00:41:53.670
DateFormatter in many respects.

00:41:53.820 --> 00:41:56.570
It is initialized with your
current system settings and

00:41:56.570 --> 00:41:58.550
as such is locale sensitive.

00:41:58.810 --> 00:42:03.230
And by far the easiest way to
format a number for human readable

00:42:03.230 --> 00:42:08.140
display is using a class method,
localized string from number with

00:42:08.140 --> 00:42:10.690
a corresponding number style.

00:42:11.200 --> 00:42:14.300
The number styles that we provide
cover a variety of options.

00:42:14.390 --> 00:42:15.820
There's general.

00:42:16.010 --> 00:42:19.640
You can format for currency,
format as a percentage,

00:42:19.760 --> 00:42:25.170
format in scientific notation,
and also format the number spelled out.

00:42:25.700 --> 00:42:30.200
One thing to point out here is that when
you format a number as a percentage,

00:42:30.320 --> 00:42:33.320
it is actually multiplied by 100.

00:42:33.500 --> 00:42:40.950
So if you want to format a number as
50%, you should be passing in 0.5.

00:42:41.180 --> 00:42:46.720
If you were to pass in 50 to be localized
as-- or to be formatted as a percentage,

00:42:46.720 --> 00:42:52.250
you would end up with 5,000%.
NSNumberFormatter is also

00:42:52.250 --> 00:42:54.650
sensitive to the user's locale.

00:42:54.850 --> 00:42:59.090
It will use the correct
character set for the digits.

00:42:59.200 --> 00:43:02.040
It will use the correct
decimal and grouping separator.

00:43:02.110 --> 00:43:07.690
Many places in Europe, for example,
use the comma as the decimal separator.

00:43:08.040 --> 00:43:11.230
It will also use the correct
currency symbol of your user's

00:43:11.230 --> 00:43:15.400
locale and will even handle
symbols like the percentage sign.

00:43:15.520 --> 00:43:19.540
There are some things to be aware of,
though.

00:43:19.950 --> 00:43:25.000
When you're parsing a number
or a string as a number,

00:43:25.050 --> 00:43:28.250
you should avoid using
methods such as int value on

00:43:28.250 --> 00:43:31.480
NSString or functions like scanf.

00:43:32.530 --> 00:43:36.670
The simple example is trying
to parse the string ASDF.

00:43:36.880 --> 00:43:39.550
If we were to ask that
string for its int value,

00:43:39.560 --> 00:43:43.980
we would get back zero because
there is no number in that string.

00:43:44.130 --> 00:43:48.150
However, if we have the string zero
and ask for its int value,

00:43:48.150 --> 00:43:50.080
we also get back zero.

00:43:50.080 --> 00:43:54.830
And so there is no way to disambiguate
whether or not the source string

00:43:54.830 --> 00:43:57.230
was actually a number or not.

00:43:57.460 --> 00:44:01.540
So, of course,
we should use an NSNumber formatter.

00:44:01.590 --> 00:44:04.420
And in our case,
we want it to be parsing numbers

00:44:04.420 --> 00:44:06.610
according to the decimal style.

00:44:07.060 --> 00:44:11.720
And now when we parse those strings,
we will get back nil for an invalid

00:44:11.720 --> 00:44:19.000
number and we will get back an actual
NSNumber instance for the string zero.

00:44:19.130 --> 00:44:22.990
Related to parsing is that of printing.

00:44:23.740 --> 00:44:27.750
If we were to use methods such as
string with format or printf in order

00:44:27.760 --> 00:44:33.680
to try and format a number for display,
we may try doing something like this.

00:44:34.060 --> 00:44:37.190
Well, for users in the United States,
that might be correct.

00:44:37.330 --> 00:44:41.550
However, for your users in Egypt,
that's incorrect.

00:44:41.780 --> 00:44:46.460
First off, that's not the character set
they use for their digits.

00:44:46.640 --> 00:44:50.490
So again, we should be using the
decimal style here.

00:44:50.650 --> 00:44:56.890
And since NSNumber is locale sensitive,
it will use the correct character set

00:44:56.890 --> 00:45:00.360
and the correct decimal separator.

00:45:00.900 --> 00:45:05.550
In Mountain Lion and
iOS 6 is this method,

00:45:05.610 --> 00:45:08.350
localize string with format.

00:45:09.170 --> 00:45:12.660
I should clarify,
this method has been around for a while.

00:45:12.810 --> 00:45:15.350
However,
prior to Mountain Lion and iOS 6,

00:45:15.350 --> 00:45:19.250
when you tried to use this method,
it would only change the decimal

00:45:19.370 --> 00:45:21.720
separator according to the locale.

00:45:21.720 --> 00:45:25.280
This method has been updated
for Mountain Lion and iOS 6

00:45:25.280 --> 00:45:27.040
to now do the correct thing.

00:45:27.040 --> 00:45:33.480
And so the previous example works just as
well using localized string with format.

00:45:33.480 --> 00:45:37.650
However, for compatibility reasons,
it will only have this

00:45:37.670 --> 00:45:39.080
behavior for a while.

00:45:39.100 --> 00:45:44.620
Dave DeLoong

00:45:48.750 --> 00:45:53.380
With NSDateFormatter,
we can set a specific date format to use.

00:45:53.710 --> 00:45:56.880
We can do the same thing
with an NSNumber formatter.

00:45:56.930 --> 00:46:01.400
However, when we do so,
we are overriding any information

00:46:01.400 --> 00:46:03.700
the locale might provide.

00:46:03.700 --> 00:46:07.700
So if we wanted to format
a number like this,

00:46:08.630 --> 00:46:12.250
With a currency symbol,
perhaps some thousands,

00:46:12.320 --> 00:46:16.340
we have a thousands separator
and two decimal places.

00:46:16.530 --> 00:46:20.500
Then for your users in the United States,
you might be getting the correct result.

00:46:20.760 --> 00:46:25.180
However, for your users in China,
they don't use the dollar sign

00:46:25.180 --> 00:46:27.030
for their currency symbol.

00:46:27.150 --> 00:46:31.440
So instead,
I should be setting the number style to

00:46:31.440 --> 00:46:35.120
ask it to format our number as currency.

00:46:35.470 --> 00:46:40.360
And now we will get the correct
currency symbol being used.

00:46:40.440 --> 00:46:43.270
Some tips for dealing with numbers.

00:46:43.460 --> 00:46:50.810
The previous example showed
241.23 yuan as correct for China.

00:46:50.960 --> 00:46:52.850
Well, yes and no.

00:46:53.000 --> 00:46:57.260
It may be using the correct symbol,
but it might not be the correct number.

00:46:57.260 --> 00:46:59.950
So don't forget to do unit conversion.

00:47:00.570 --> 00:47:04.070
Just because you're using, you know,

00:47:04.200 --> 00:47:10.700
[Transcript missing]

00:47:11.680 --> 00:47:15.250
3 miles is not the same
thing as 3 kilometers,

00:47:15.480 --> 00:47:17.660
so please convert your units.

00:47:17.870 --> 00:47:20.150
Now, we don't provide any
unit conversion for you.

00:47:20.330 --> 00:47:24.930
However, you can ask the NSLocale object
what you should be doing.

00:47:24.930 --> 00:47:28.050
The Locale object will tell
you whether you should be

00:47:28.050 --> 00:47:30.100
using the metric system or not.

00:47:30.150 --> 00:47:33.190
It will also tell you what
currency code you should be using.

00:47:33.190 --> 00:47:38.680
And using that information,
you can then perhaps call a web service

00:47:38.680 --> 00:47:41.510
to convert the currency for you.

00:47:41.600 --> 00:47:46.220
or simply do some unit
conversion for distance yourself.

00:47:47.120 --> 00:47:51.340
Also, as we saw with dates,
using the strptime function,

00:47:51.340 --> 00:47:58.000
we can do the same thing with unlocalized
numbers using the str2 whatever function.

00:47:58.000 --> 00:48:03.190
So str2d for integers, str2f for floats,
and so on.

00:48:03.840 --> 00:48:06.680
But really,
you want to use the predefined

00:48:06.700 --> 00:48:10.510
formats as much as possible,
since they are the formats that

00:48:10.610 --> 00:48:14.380
will take care of all of the
special edge cases for you.

00:48:16.080 --> 00:48:18.300
Finally, let's talk about images.

00:48:18.620 --> 00:48:21.860
There is a single overriding
rule to be aware of when dealing

00:48:22.270 --> 00:48:24.940
with localizing your images.

00:48:25.000 --> 00:48:28.920
And that is beware.

00:48:30.130 --> 00:48:33.920
Localizing images is fraught with peril.

00:48:34.060 --> 00:48:37.090
Let's say, for example,
that you're writing a children's

00:48:37.220 --> 00:48:41.440
application and you have centered
your application around this wordplay,

00:48:41.440 --> 00:48:43.680
be clever.

00:48:47.700 --> 00:48:51.460
I think you're starting to understand
how this might be problematic.

00:48:51.460 --> 00:48:56.330
You should really try to avoid any sort
of linguistic puns or word play when

00:48:56.330 --> 00:48:59.700
dealing with images in your application.

00:48:59.970 --> 00:49:06.710
For example, if we were to translate "be
clever" literally into Spanish,

00:49:06.930 --> 00:49:12.590
we might end up with something
like "abeja inteligente," which

00:49:12.590 --> 00:49:12.590
literally means "smart honeybee."

00:49:13.380 --> 00:49:17.110
It's not what we're going for,
so please avoid doing any

00:49:17.170 --> 00:49:19.240
sort of jokes with images.

00:49:19.240 --> 00:49:22.540
The rare circumstances where
you will need to localize your

00:49:22.540 --> 00:49:26.440
images are when you're dealing
with culture-specific content.

00:49:26.450 --> 00:49:30.330
For example, let's say your children's
application has a stop sign in it,

00:49:30.330 --> 00:49:33.780
and so you, being the internationally
savvy person you are,

00:49:33.780 --> 00:49:38.370
have decided to just
ship the red octagon.

00:49:38.930 --> 00:49:41.450
And then at runtime,
you're going to superimpose

00:49:41.450 --> 00:49:45.240
the correct text,
whether it's in Arabic, French,

00:49:45.240 --> 00:49:47.470
Portuguese, or Korean.

00:49:48.760 --> 00:49:52.280
Well, then you start getting reports back
from your users in Japan saying

00:49:52.360 --> 00:49:54.140
that their stop signs look funny.

00:49:54.270 --> 00:49:55.130
Why is that?

00:49:55.270 --> 00:49:59.200
Well, in Japan,
stop signs are actually triangles.

00:49:59.300 --> 00:50:02.800
And so this is a situation where,
due to the culture,

00:50:02.800 --> 00:50:08.690
you will need to localize your image
to account for that specific culture.

00:50:08.890 --> 00:50:11.300
But again,
you would simply just ship the red

00:50:11.380 --> 00:50:15.500
triangle image and then superimpose
the correct text at runtime.

00:50:15.500 --> 00:50:18.780
This allows you to be
as flexible as possible.

00:50:20.380 --> 00:50:24.400
However, there's nothing else you need to
really change because you can still

00:50:24.400 --> 00:50:28.440
use the same image named methods
to retrieve the appropriate image.

00:50:28.440 --> 00:50:32.850
Image named will go through
NSBundle to find the correct image,

00:50:32.850 --> 00:50:36.780
and NSBundle takes your language
into account when finding

00:50:36.780 --> 00:50:39.230
the correct resource to use.

00:50:39.240 --> 00:50:43.820
There are also situations
where you have text in images.

00:50:43.820 --> 00:50:47.560
This is usually a bad idea simply
because it really increases the

00:50:47.590 --> 00:50:49.660
number of assets you have to ship.

00:50:50.020 --> 00:50:53.950
But in case you do,
let's say you have a question

00:50:54.000 --> 00:50:59.290
mark in an icon somewhere,
you may need to ship another version

00:50:59.290 --> 00:51:02.640
that has the question mark inverted.

00:51:02.640 --> 00:51:05.440
So what have we talked about today?

00:51:05.440 --> 00:51:08.600
First off,
we've learned that standards vary.

00:51:08.600 --> 00:51:12.780
Whether it's currency symbols
or how we spell months or

00:51:12.780 --> 00:51:18.080
what images we should use,
standards vary from region to region.

00:51:18.080 --> 00:51:20.000
And so we should be considerate
of how we spell months.

00:51:20.020 --> 00:51:26.170
And so we should be considerate
of how we spell months.

00:51:26.640 --> 00:51:29.500
We've also learned that cultures vary.

00:51:29.530 --> 00:51:33.010
Images that might make sense
to us in our locale might be

00:51:33.010 --> 00:51:35.030
meaningless to other users.

00:51:35.120 --> 00:51:39.320
Jokes that are funny to us may be
nonsensical to them or at worst

00:51:39.470 --> 00:51:41.720
even horrendously offensive.

00:51:41.860 --> 00:51:46.240
So please remember that not
everybody shares your culture.

00:51:46.770 --> 00:51:50.620
As you're building your applications,
do not forget to test them,

00:51:50.620 --> 00:51:53.750
both in your own language
and in other languages.

00:51:54.010 --> 00:51:57.830
Pseudolocalization can help,
but it is not a panacea.

00:51:58.010 --> 00:52:02.640
So please ask your beta testers to run
the application in other languages.

00:52:02.750 --> 00:52:09.860
Ideally, they may even speak that
native language themselves.

00:52:10.920 --> 00:52:14.670
And they can be the ones to let you know,
hey, your stop signs actually

00:52:14.670 --> 00:52:20.520
need to be a triangle or hey,
that image is actually really crude.

00:52:20.740 --> 00:52:23.940
And finally, please use the built-in
APIs as much as possible.

00:52:24.170 --> 00:52:27.540
These are APIs that have been
over 20 years in development,

00:52:28.070 --> 00:52:30.430
and nothing you can
do will approach that.

00:52:30.610 --> 00:52:33.590
So please take advantage
of our hard work.

00:52:34.250 --> 00:52:39.670
If you have more information,
you can contact our evangelist,

00:52:39.670 --> 00:52:41.100
Paul Marcos.

00:52:41.120 --> 00:52:47.270
There's also a really great
guide in the documentation called

00:52:47.270 --> 00:52:53.810
"Introduction to Internationalization
Programming Topics." And of course,

00:52:53.810 --> 00:52:53.810
you can go on to the dev forums
to ask for specific help.

00:52:54.180 --> 00:52:55.380
There are some related sessions.

00:52:55.580 --> 00:52:59.490
We've already talked about Auto Layout,
but please don't forget

00:52:59.490 --> 00:53:01.140
about accessibility.

00:53:01.280 --> 00:53:05.170
You have correctly
internationalized your UI.

00:53:05.610 --> 00:53:09.760
But not all of your users can see
or not all of your users can hear.

00:53:10.170 --> 00:53:13.860
Please remember to also
remember accessibility when

00:53:13.860 --> 00:53:16.380
internationalizing your application.

00:53:16.450 --> 00:53:18.290
Thank you for coming.
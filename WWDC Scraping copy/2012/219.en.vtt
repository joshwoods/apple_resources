WEBVTT

00:00:10.440 --> 00:00:16.300
Welcome to Advanced Collection Views
and Building Custom Layouts.

00:00:16.300 --> 00:00:17.300
I'm Luke Hiesterman.

00:00:17.300 --> 00:00:19.600
I'm an engineer on the
iOS Frameworks team.

00:00:19.600 --> 00:00:23.520
And let me tell you,
in less than 24 hours since we

00:00:23.520 --> 00:00:28.400
introduced Collection View yesterday,
the feedback has just been overwhelming.

00:00:28.400 --> 00:00:32.380
And I can't tell you how
excited that makes all of us

00:00:33.060 --> 00:00:36.760
to share with you the keys,
the more advanced keys to

00:00:36.780 --> 00:00:40.340
Collection Views so we can send
all of you on your way to being

00:00:40.340 --> 00:00:45.200
Collection View experts and
creating just astounding UIs.

00:00:45.310 --> 00:00:47.830
So that's what this talk
is going to be about,

00:00:48.070 --> 00:00:50.740
the deeper keys.

00:00:50.930 --> 00:00:54.690
To get us through that,
we're going to start by talking

00:00:54.690 --> 00:00:58.600
about some architectural
things in UI Collection View.

00:00:58.600 --> 00:01:02.470
That's going to be kind
of the meat of this talk,

00:01:02.470 --> 00:01:04.030
the drier part.

00:01:04.090 --> 00:01:08.320
But get us all on the same page in
terms of how UI Collection View works,

00:01:08.400 --> 00:01:12.600
its terminology, and the workings of
things under the hood,

00:01:12.600 --> 00:01:14.040
so that we can go forward.

00:01:14.080 --> 00:01:17.080
And from there,
we'll talk about how we can really

00:01:17.100 --> 00:01:21.050
push the UI Collection View flow
layout in great directions.

00:01:21.160 --> 00:01:25.890
We got a taste of this yesterday,
but we'll see really the kind of

00:01:25.890 --> 00:01:28.300
things that we can do with it.

00:01:28.460 --> 00:01:33.030
And for those of you who went back
to your hotels or your homes last

00:01:33.030 --> 00:01:37.390
night and pulled out a sketch pad
and started writing your mockup

00:01:37.560 --> 00:01:41.640
of the next great American layout,
we're going to talk to you

00:01:41.750 --> 00:01:45.590
about the API that makes it
easy to write custom layouts.

00:01:45.800 --> 00:01:46.400
There we go.

00:01:46.400 --> 00:01:47.960
Build your own layout.

00:01:47.980 --> 00:01:51.880
So to begin,
let's talk about architecture.

00:01:52.880 --> 00:01:56.740
Part of this is going to be review from
what you learned yesterday if you went

00:01:56.740 --> 00:01:59.400
to the intro to collection views talk.

00:01:59.400 --> 00:02:02.010
But we want to make sure we're
on the same page for dealing

00:02:02.010 --> 00:02:03.500
with the advanced concept.

00:02:03.660 --> 00:02:07.600
So let's talk about the views
that are in a collection view.

00:02:07.720 --> 00:02:08.560
There are three of them.

00:02:08.560 --> 00:02:10.200
Most of you hopefully remember them.

00:02:10.200 --> 00:02:11.300
They are cells.

00:02:11.400 --> 00:02:13.000
They are supplementary views.

00:02:13.170 --> 00:02:16.600
And they are decoration views.

00:02:16.680 --> 00:02:20.400
And let's take a minute to make
sure that we're really familiar

00:02:20.400 --> 00:02:24.000
with these sort of two new terms,
supplementary view and decoration view.

00:02:24.000 --> 00:02:27.500
Because that's not something we've
dealt with before in the kit.

00:02:27.500 --> 00:02:29.510
And we want to make sure we
understand what they are and how

00:02:29.550 --> 00:02:30.970
they're distinct from each other.

00:02:31.020 --> 00:02:34.960
So this is a UI that you've probably
seen before from the previous talk.

00:02:34.990 --> 00:02:40.710
And it has supplementary views as
denoted by the Paris and Telluride

00:02:40.710 --> 00:02:43.000
markers that are metadata.

00:02:43.000 --> 00:02:45.590
about these sections.

00:02:46.310 --> 00:02:49.490
Now, that's sort of what's interesting
about supplementary views.

00:02:49.500 --> 00:02:56.240
They have metadata about your content,
but they're not the content itself.

00:02:56.360 --> 00:02:59.940
But what's important about them is
they do take data from the data source,

00:03:00.040 --> 00:03:03.540
and in that sense, they are data-driven.

00:03:05.350 --> 00:03:09.780
Conversely, if you look at the
background of this thing,

00:03:09.780 --> 00:03:14.590
that little shelf UI,
we consider that a decoration view.

00:03:14.640 --> 00:03:21.210
And the decoration view is fully owned
and defined by the layout object.

00:03:21.530 --> 00:03:25.200
It does not interact with the data source
of your collection view in any way.

00:03:25.200 --> 00:03:28.860
The data source will not be
asked to provide any data.

00:03:29.110 --> 00:03:32.840
And the layout defines this
completely within its own world.

00:03:32.990 --> 00:03:36.130
So in that way,
decoration views are layout

00:03:36.130 --> 00:03:40.080
driven as opposed to supplementary
views which are data driven.

00:03:40.160 --> 00:03:44.680
The layout defines support
for a supplementary view,

00:03:44.700 --> 00:03:48.620
but the heart of the view is
going to be the data that is

00:03:48.630 --> 00:03:50.090
provided by the data source.

00:03:50.210 --> 00:03:53.920
So we have this thing,
this other class that was

00:03:53.920 --> 00:03:58.710
alluded to in our previous talk,
which is UI Collection View Layout

00:03:58.710 --> 00:03:59.640
Attributes.

00:03:59.700 --> 00:04:01.440
And this is the thing
we want to understand.

00:04:01.440 --> 00:04:02.860
Because it's a very complex thing.

00:04:02.890 --> 00:04:07.150
If you're customizing layouts,
this is the object that carries

00:04:07.150 --> 00:04:11.660
information from a layout to a collection
view and ultimately gets applied

00:04:11.950 --> 00:04:13.960
to all the views in the collection view.

00:04:14.070 --> 00:04:18.360
So let's talk about that relationship.

00:04:18.760 --> 00:04:22.820
We have the basic class diagram
that you're already familiar with.

00:04:22.920 --> 00:04:28.100
And the layout attributes is this
little tool that the layout is going

00:04:28.500 --> 00:04:31.260
to use to define itself as a layout.

00:04:31.540 --> 00:04:32.250
Each of the views that any
game is going to use is going

00:04:32.250 --> 00:04:32.820
to be defined as a layout.

00:04:32.820 --> 00:04:35.980
And if any given layout wants to layout,
it will define the layout

00:04:35.980 --> 00:04:40.320
information in terms of instances of
UI Collection View Layout Attributes.

00:04:40.320 --> 00:04:43.090
One instance per view.

00:04:43.550 --> 00:04:46.860
And those are going to go from
the layout handed over each

00:04:46.860 --> 00:04:48.800
instance to the collection view.

00:04:48.800 --> 00:04:51.900
And the collection view is going
to use those instances which

00:04:51.940 --> 00:04:55.810
define how to layout a view to
literally go layout those views.

00:04:55.870 --> 00:04:59.230
It will apply the layout
attributes in a given layout

00:04:59.230 --> 00:05:01.360
attribute instance to a view.

00:05:01.510 --> 00:05:05.420
So what are the attributes that
are contained in this object?

00:05:05.740 --> 00:05:08.380
First and foremost and very simply,
we have center and size.

00:05:08.580 --> 00:05:13.240
You can define where this thing
is on screen and how big it is.

00:05:13.350 --> 00:05:16.920
We also have a convenience accessor
that defines both of these,

00:05:16.920 --> 00:05:17.970
which is frame.

00:05:18.100 --> 00:05:21.960
You can define it in terms of frame
if you're used to that in UIView.

00:05:22.060 --> 00:05:23.180
We also have alpha.

00:05:23.460 --> 00:05:27.600
If you want to control
the opacity of your views,

00:05:27.600 --> 00:05:31.240
you can put that in a layout attribute
and it will be applied to the views.

00:05:31.340 --> 00:05:33.200
We can apply a transform.

00:05:33.200 --> 00:05:37.080
This is actually a 3D
transform to any of the views.

00:05:37.220 --> 00:05:39.760
And that will get applied as well.

00:05:39.830 --> 00:05:41.560
Now,
one thing you might notice is now that

00:05:41.560 --> 00:05:45.780
we have a transform on these views,
they overlap each other.

00:05:45.880 --> 00:05:50.840
And you might say, well,
they overlap sort of top to bottom now,

00:05:51.080 --> 00:05:52.600
but I might want the opposite.

00:05:52.700 --> 00:05:56.700
I might want the views on top to
overlap the things on bottom as

00:05:56.700 --> 00:05:59.110
though it was laid out bottom up.

00:05:59.230 --> 00:06:02.720
And we have a way for you to specify
how things are stacked if they,

00:06:02.840 --> 00:06:04.040
in fact, overlap.

00:06:04.250 --> 00:06:07.680
And we do that via zindex
property on the layout attributes.

00:06:07.810 --> 00:06:14.720
The way that works is any zindex,
any view, with its zindex is guaranteed

00:06:14.720 --> 00:06:18.780
to be layout above a view whose
zindex is lower than it and

00:06:18.990 --> 00:06:20.130
below one that's greater than it.

00:06:20.230 --> 00:06:24.690
So by default,
layout attribute zindex is zero.

00:06:25.080 --> 00:06:29.340
But if you specify one to be, say,
zindex of one,

00:06:29.340 --> 00:06:34.330
then it is guaranteed to be above all
of the views whose zindex is zero.

00:06:34.680 --> 00:06:37.580
But if there was another
view that was two,

00:06:37.580 --> 00:06:40.280
the one would be
guaranteed to be below two.

00:06:40.280 --> 00:06:43.400
And in cases where they're equal,
their relationship,

00:06:43.400 --> 00:06:45.080
their stacking relationship is undefined.

00:06:45.290 --> 00:06:47.930
So in many cases, if you just don't have
views that overlap,

00:06:47.960 --> 00:06:49.570
you leave the zindex
to everything as zero.

00:06:49.580 --> 00:06:51.790
It doesn't matter because
they don't overlap.

00:06:52.250 --> 00:06:58.800
Let's talk about how the layout
gets information from the delegate.

00:06:58.800 --> 00:07:02.180
We talked about the idea that
the layout gets information from

00:07:02.180 --> 00:07:04.110
the delegate in yesterday's talk.

00:07:04.210 --> 00:07:07.370
We talked about all these things
that you can specify dynamically in

00:07:07.530 --> 00:07:11.860
the layout -- or in your delegate
that the flow layout will use.

00:07:11.860 --> 00:07:17.050
And so the way that works is
if this is our set of classes,

00:07:17.050 --> 00:07:22.180
we want effectively the layout to
be able to draw this line and go,

00:07:22.180 --> 00:07:25.820
"Oh, directly to the collection
view." And that makes it so

00:07:25.860 --> 00:07:29.930
that we can have a delegate,
which is the collection view delegate,

00:07:29.930 --> 00:07:33.780
but then reuse that delegate for
the purposes of whatever delegation

00:07:33.780 --> 00:07:36.950
needs that a given layout has,
like the flow layout uses

00:07:36.950 --> 00:07:41.740
this to get dynamic sizing and
other properties for itself.

00:07:41.740 --> 00:07:47.400
So how this works is a pattern
that we are putting forth called

00:07:47.400 --> 00:07:50.540
basically the extensible delegate.

00:07:50.540 --> 00:07:52.690
And it is, in fact,
true that this is a method that

00:07:52.690 --> 00:07:54.160
we use in the collection view.

00:07:54.160 --> 00:07:55.950
And this is not your
granddaddy's protocol.

00:07:55.960 --> 00:07:59.660
And that happens by taking a
concept that we already have,

00:07:59.660 --> 00:08:02.600
which is, say,
the UI collection view delegate

00:08:02.940 --> 00:08:04.770
extends UI scroll view delegate.

00:08:04.840 --> 00:08:06.600
This isn't really a new idea.

00:08:06.620 --> 00:08:11.260
UI table view delegate extends UI scroll
view delegate in this way also.

00:08:11.280 --> 00:08:13.840
And that way,
your delegate for the collection

00:08:13.840 --> 00:08:17.350
view can implement any of the methods
defined in UI scroll view delegate.

00:08:18.790 --> 00:08:24.310
So we take this a step further by saying
that UI Collection View Flow Layout

00:08:24.310 --> 00:08:30.620
defines its own delegate protocol called
UI Collection View Delegate Flow Layout,

00:08:30.970 --> 00:08:35.250
and that protocol extends
UI Collection View Delegate.

00:08:35.330 --> 00:08:39.330
So now you can set a delegate
on the Collection View,

00:08:39.330 --> 00:08:44.460
which actually implements
UI Collection View Delegate Flow Layout.

00:08:44.500 --> 00:08:47.310
And not only can it handle all of
the Collection View delegation,

00:08:47.420 --> 00:08:51.680
but it can also handle the
requisite methods for dealing

00:08:51.800 --> 00:08:55.170
with dynamism in the Flow Layout.

00:08:55.400 --> 00:08:57.900
Now,
since you're all here at the advanced

00:08:58.260 --> 00:09:03.230
talk and you're thinking about doing
interesting things with layouts,

00:09:03.370 --> 00:09:08.060
you might write layouts that also want
to get information from a delegate.

00:09:08.170 --> 00:09:10.460
And we want you to
follow this same pattern.

00:09:10.610 --> 00:09:15.810
So you might have your own delegate
protocol and you would extend one of

00:09:15.810 --> 00:09:17.860
our delegate protocols with yours.

00:09:17.980 --> 00:09:21.020
So if you subclassed
UI Collection View Flow Layout and you

00:09:21.450 --> 00:09:26.500
wanted additional information from the
delegate besides what is already there,

00:09:26.600 --> 00:09:29.470
you would make a delegate
protocol that extends

00:09:29.480 --> 00:09:32.310
UI Collection View Delegate Flow Layout.

00:09:32.430 --> 00:09:35.530
Alternatively, if you were writing a
completely custom layout but

00:09:35.530 --> 00:09:38.890
you wanted delegate information,
you could define a protocol that

00:09:38.890 --> 00:09:42.030
extends UI Collection View Delegate,
and that would be the

00:09:42.030 --> 00:09:43.870
protocol that you would use.

00:09:44.140 --> 00:09:46.240
So that's the delegation pattern.

00:09:46.240 --> 00:09:50.180
Let's look at now how we
change things in a layout.

00:09:50.180 --> 00:09:53.510
Some of the demos that
were shown yesterday,

00:09:53.510 --> 00:09:57.190
like Cover Flow,
deal with actually changing how

00:09:57.250 --> 00:10:02.500
things are laid out after the
collection view is already on screen.

00:10:02.640 --> 00:10:05.440
And we have a mechanism for this.

00:10:05.770 --> 00:10:10.630
Changing how things are laid out,
which really is changing any of the

00:10:10.630 --> 00:10:14.570
layout attributes after your layout has
provided a set of layout attributes,

00:10:14.570 --> 00:10:17.660
it might want to say, well,
I changed my mind about some

00:10:17.660 --> 00:10:19.490
of those or all of them.

00:10:19.500 --> 00:10:21.500
We consider that invalidation.

00:10:21.560 --> 00:10:25.500
That's what we call that whole
idea is invalidating the layout.

00:10:25.560 --> 00:10:28.300
When you invalidate a layout,
that means start over,

00:10:28.300 --> 00:10:31.230
provide new layout attributes,
new layout information for

00:10:31.230 --> 00:10:32.500
the collection view to use.

00:10:33.770 --> 00:10:40.090
The way to this is a method defined on
the Layout class called invalidateLayout.

00:10:40.250 --> 00:10:46.440
Now, we can get to the point where we're
calling this a variety of different ways.

00:10:46.440 --> 00:10:49.270
One, if you're the delegate, say,
you're the controller and you

00:10:49.270 --> 00:10:52.270
implement the delegate protocol,
and maybe you have some dynamic

00:10:52.270 --> 00:10:55.100
sizes that you provide and
size for item and index path,

00:10:55.340 --> 00:10:57.950
and you decide you
change your data model,

00:10:58.070 --> 00:11:02.140
you want to change those sizes, well,
you can just call invalidate

00:11:02.140 --> 00:11:05.690
layout on the layout after you've
changed your internal model,

00:11:05.720 --> 00:11:08.380
and that will cause the
layout to rebuild itself,

00:11:08.380 --> 00:11:14.880
including accessing your delegate again
so that your new sizes can be applied.

00:11:15.310 --> 00:11:23.270
and David You can also do this
if you want to animate by putting

00:11:23.280 --> 00:11:27.130
that in a perform batch updates.

00:11:27.230 --> 00:11:31.280
Let's say you change your data
model so that your sizes are

00:11:31.280 --> 00:11:33.440
going to be different now.

00:11:33.440 --> 00:11:35.520
But you don't want to just
snap to those new sizes.

00:11:35.520 --> 00:11:37.800
You want the collection
view to animate that.

00:11:37.800 --> 00:11:41.820
Well, perform batch updates is a
block-based analog to begin updates

00:11:41.820 --> 00:11:44.580
and end updates from UI table view.

00:11:44.580 --> 00:11:49.060
And if you call this method,
it will implicitly invalidate the layout.

00:11:49.060 --> 00:11:53.920
And whatever changes that you have put
into your model will then get animated.

00:11:53.920 --> 00:11:57.520
You could also do this by, like,
in there, in that block,

00:11:57.640 --> 00:12:02.270
you could then set a property like
item size on the layout if it's

00:12:02.420 --> 00:12:05.320
UI collection view flow layout.

00:12:05.320 --> 00:12:09.900
The layout can also call invalidate
layout on itself if it wants to.

00:12:09.900 --> 00:12:15.740
Like if you just set the property of item
size on UI collection view flow layout,

00:12:15.740 --> 00:12:18.940
well, that means that things should
look different since you

00:12:18.940 --> 00:12:20.260
just changed the item size.

00:12:20.280 --> 00:12:23.540
And the flow layout will call
self invalidate layout because it

00:12:23.540 --> 00:12:27.760
knows that it is now invalidated
and needs to invalidate itself.

00:12:27.760 --> 00:12:32.210
We provide one other mechanism which
is a convenience for layouts that want

00:12:32.290 --> 00:12:37.330
to define times for themselves when
they need to relay out because of the

00:12:37.330 --> 00:12:39.700
bounds of the collection view changing.

00:12:39.720 --> 00:12:43.230
Now, there are two main instances
where this applies,

00:12:43.230 --> 00:12:45.620
which is one when you're scrolling.

00:12:45.620 --> 00:12:50.240
As you scroll up and down or left, right,
whatever it is, that changes the bounds

00:12:50.240 --> 00:12:52.120
of your collection view.

00:12:52.120 --> 00:12:55.060
And if you're something
like a cover flow,

00:12:55.060 --> 00:12:58.240
as you scroll, we want to change those
transforms on the views,

00:12:58.240 --> 00:13:00.470
so that's changing the layout attributes.

00:13:00.470 --> 00:13:05.380
And we do that by responding to a
method which is should invalidate

00:13:05.420 --> 00:13:07.350
layout for bounds change.

00:13:07.420 --> 00:13:11.140
If you have a layout like the cover flow,
that every time the bounds

00:13:11.140 --> 00:13:13.880
changes for a scroll,
it wants to relay out,

00:13:13.880 --> 00:13:20.130
it can return yes to this method and that
gives it an opportunity to relay out.

00:13:20.170 --> 00:13:22.550
If you have something
like the flow layout,

00:13:22.550 --> 00:13:26.060
the flow layout actually needs
to reflow when the aspect ratio

00:13:26.060 --> 00:13:29.590
of the collection view changes,
like when you rotate from

00:13:29.590 --> 00:13:31.180
portrait to landscape.

00:13:31.180 --> 00:13:32.150
It needs to reflow.

00:13:32.240 --> 00:13:34.350
There can be, say,
more columns if you have a

00:13:34.350 --> 00:13:36.750
vertically scrolling flow layout.

00:13:36.840 --> 00:13:41.630
So flow layout implements this method to
check to see if the width has changed,

00:13:41.630 --> 00:13:44.600
say, if you have a vertically
scrolling layout,

00:13:44.600 --> 00:13:47.380
and if the width of
the bounds has changed,

00:13:47.380 --> 00:13:51.470
it says, yes, I need to invalidate,
and it relays itself

00:13:51.470 --> 00:13:53.070
out in response to that.

00:13:53.100 --> 00:13:57.870
So that's the underpinnings
of how collection view works.

00:13:57.990 --> 00:14:01.660
And now that we're -- we kind
of got that in our stomach,

00:14:01.820 --> 00:14:04.480
we can talk about stuff
we can do with it.

00:14:04.480 --> 00:14:09.180
And this section on advanced flow
layout is a little bit more complex.

00:14:09.180 --> 00:14:13.710
It is pushing you towards the
direction of when you go and

00:14:13.710 --> 00:14:18.630
start writing your custom stuff,
I know that you have brilliant ideas,

00:14:18.700 --> 00:14:21.560
and I want to direct you
towards first thinking,

00:14:21.640 --> 00:14:28.720
does my brilliant idea apply towards
building based off of the flow layout?

00:14:28.720 --> 00:14:33.360
And the answer to that question is, well,
it stems from the definition

00:14:33.360 --> 00:14:34.880
of the flow layout.

00:14:35.000 --> 00:14:37.750
The flow layout is a
line breaking layout.

00:14:37.870 --> 00:14:39.000
And if you have any very
specific flow layout,

00:14:39.000 --> 00:14:42.100
any variation on a layout that
lays things out on a line and

00:14:42.100 --> 00:14:45.670
breaks when it gets to the end,
then that's something you

00:14:45.740 --> 00:14:48.200
should start with flow layout.

00:14:48.200 --> 00:14:52.040
We showed you yesterday how to tweak
the properties and the delegate

00:14:52.480 --> 00:14:56.030
methods on the flow layout delegate
to be able to do cool things.

00:14:56.040 --> 00:14:58.740
Today we're going to dive
into a more advanced way of

00:14:58.740 --> 00:15:02.290
customizing the flow layout,
which is subclassing,

00:15:02.420 --> 00:15:04.420
and we can do even more than that.

00:15:04.420 --> 00:15:06.940
And the goal is to get you to
realize just how much you can do

00:15:06.940 --> 00:15:10.540
by leveraging the work that we have
already done for you in defining

00:15:10.540 --> 00:15:12.820
your collection view flow layout.

00:15:12.860 --> 00:15:15.640
And then we'll talk a little
bit later about sort of going

00:15:15.640 --> 00:15:17.050
off into the other world.

00:15:17.230 --> 00:15:21.290
So what are things you might
subclass the flow layout to do?

00:15:21.400 --> 00:15:25.500
Well, you can add new kinds of views.

00:15:25.580 --> 00:15:29.340
We saw the decoration view
that was added to this view.

00:15:29.340 --> 00:15:31.760
This can really be thought
of as a flow layout.

00:15:31.760 --> 00:15:35.360
We have this sort of grid-ish thing,
a flow of lines.

00:15:35.760 --> 00:15:38.710
And it's got that shelving
behind it to make it look

00:15:38.790 --> 00:15:40.860
like a bookshelf application.

00:15:40.990 --> 00:15:44.470
And that's just something you can
do in a subclass of the flow layout.

00:15:44.470 --> 00:15:47.100
You use the subclass to
add additional views.

00:15:48.760 --> 00:15:51.740
You can also use it to
tweak the layout attributes.

00:15:51.810 --> 00:15:54.480
If you want to take the layout
attributes that flow layout provides

00:15:54.480 --> 00:15:57.220
by default and change them a bit,
you can do that.

00:15:57.220 --> 00:15:59.220
That gets you something like this.

00:15:59.250 --> 00:16:00.910
Or whatever it is that
you want to define.

00:16:00.910 --> 00:16:02.920
Here we've tweaked the
transform attribute.

00:16:02.920 --> 00:16:05.210
You can tweak any of
the attributes you want,

00:16:05.210 --> 00:16:08.680
like alpha or whatever it is that
makes sense for your application to

00:16:08.860 --> 00:16:10.910
be able to get something super easily.

00:16:10.930 --> 00:16:14.410
This is only a couple of lines
of code to modify the transform,

00:16:14.410 --> 00:16:18.420
and I've leveraged everything that was
already provided by the flow layout.

00:16:18.420 --> 00:16:21.940
Additionally,
you can provide new layout attributes.

00:16:21.940 --> 00:16:26.830
One of the features of having this
sort of layout attributes class is

00:16:26.840 --> 00:16:32.590
that you can subclass that class,
UI collection view layout attributes,

00:16:32.590 --> 00:16:38.240
into some new thing that adds
additional layout attributes themselves.

00:16:38.240 --> 00:16:40.420
And you can use that.

00:16:40.420 --> 00:16:44.520
We actually shuffle the layout
attribute instances over to cells and

00:16:44.520 --> 00:16:46.140
views themselves and then call them.

00:16:46.140 --> 00:16:46.160
And then we can actually shuffle the
layout attributes instances over to cells

00:16:46.160 --> 00:16:46.240
and views themselves and then call them.

00:16:46.270 --> 00:16:47.350
And then we can actually
call a method on them that is

00:16:47.500 --> 00:16:49.860
called apply layout attributes.

00:16:49.860 --> 00:16:53.230
And that allows you to use the
layout attributes instances as a

00:16:53.230 --> 00:16:57.300
means of vectoring data from your
layout all the way to the views

00:16:57.310 --> 00:16:59.800
and do special things with that.

00:16:59.800 --> 00:17:03.550
So if we look at this view,
this is an extremely basic flow

00:17:04.000 --> 00:17:06.040
layout with a couple of columns.

00:17:06.070 --> 00:17:10.750
And we see there are little labels
in each of these views that just

00:17:10.760 --> 00:17:13.340
tells me what index path they are.

00:17:13.340 --> 00:17:18.010
Now, I can subclass the layout attributes
into the layout attributes class,

00:17:18.190 --> 00:17:23.290
provide a new instance that provides
some additional attributes that my cells

00:17:23.290 --> 00:17:26.800
are programmed to know how to deal with.

00:17:26.800 --> 00:17:31.650
And then I can do something like this,
where I have actually moved

00:17:31.730 --> 00:17:37.110
the justification of the
text based on which column --

00:17:37.350 --> 00:17:43.070
and the layout class was able to know
what column it was laying things out

00:17:43.070 --> 00:17:48.350
in and then put an additional layout
attribute into those instances that

00:17:48.350 --> 00:17:50.230
the cells could then read and say,
"Oh, okay,

00:17:50.310 --> 00:17:53.670
I'm on the left or I'm on the right."
In addition to justification here,

00:17:53.710 --> 00:17:55.060
I actually rounded the corners.

00:17:55.060 --> 00:17:57.230
So the views on the left
have rounded corners in the

00:17:57.230 --> 00:17:58.560
top left and the top right.

00:17:58.560 --> 00:17:59.560
Maybe a little hard to see.

00:17:59.560 --> 00:18:00.990
I don't know.

00:18:01.400 --> 00:18:05.600
And likewise, the views on the right have
rounded corners on the top

00:18:05.600 --> 00:18:07.200
right and the bottom right.

00:18:07.320 --> 00:18:10.650
So that just gives you a taste
of whatever information you might

00:18:10.650 --> 00:18:14.900
want to shuttle from your layout to
your views can be done by putting

00:18:14.900 --> 00:18:20.370
that information in a subclass of
UI Collection View Layout Attributes.

00:18:21.110 --> 00:18:25.060
So you can also add gesture
support by subclassing.

00:18:25.120 --> 00:18:29.060
You can just take a stock
UI Collection View flow layout

00:18:29.460 --> 00:18:34.570
and add to it a subclass that
knows how to deal with a gesture.

00:18:34.900 --> 00:18:40.310
You saw in the introductory talk,
Olivier had a layout that you

00:18:40.310 --> 00:18:43.340
could pinch and move cells around.

00:18:43.400 --> 00:18:46.340
Well, you know,
you could have a gesture support directly

00:18:46.340 --> 00:18:51.040
in the flow layout without having
to write a completely custom layout.

00:18:51.040 --> 00:18:53.410
And you could do something like this,
where you pinch on one,

00:18:53.590 --> 00:18:58.130
and then you are able to pinch out and
just change the layout attributes of that

00:18:58.140 --> 00:19:04.960
one cell while still using all the other
information from the flow layout class.

00:19:05.830 --> 00:19:11.340
So you can also do this to add
custom insert and delete animations.

00:19:11.340 --> 00:19:15.360
We saw this yesterday,
which is a layout that, if you recall,

00:19:15.360 --> 00:19:18.940
is able to insert by taking
photos in from the center.

00:19:18.940 --> 00:19:24.170
This shot is a mid-animation shot of
the center of the photo being inserted

00:19:24.170 --> 00:19:26.590
by animating in from the center.

00:19:26.750 --> 00:19:31.110
And this layout also would explode
pictures as they animated out.

00:19:31.210 --> 00:19:36.340
This isn't a flow layout,
but you can implement the same genre

00:19:36.340 --> 00:19:41.570
of strategy simply by subclassing the
flow layout and overriding appropriate

00:19:41.570 --> 00:19:47.330
hooks to get custom insert and delete
animations into your application and

00:19:47.330 --> 00:19:49.400
just add that bit to the flow layout.

00:19:49.540 --> 00:19:53.540
So these are all piecemeal things,
and they can, of course,

00:19:53.620 --> 00:19:57.950
be combined together that are
the type of thing you can do

00:19:57.950 --> 00:20:00.580
by subclassing the flow layout.

00:20:00.620 --> 00:20:05.600
And really, what makes this category of
customization nice is all of these are

00:20:05.600 --> 00:20:08.220
just really a couple of lines of code.

00:20:08.220 --> 00:20:12.140
You're leveraging all of the work
that UI Collection View Flow Layout

00:20:12.140 --> 00:20:16.210
does for you and just adding the
thing that makes your app awesome.

00:20:16.340 --> 00:20:20.940
So that's really cool,
and I'd like to invite Mathieu

00:20:21.260 --> 00:20:26.590
Martin up at this point to show
us a demo of the code for a pinch

00:20:26.600 --> 00:20:29.980
resizing gesture on Flow Layout.

00:20:32.100 --> 00:20:33.520
Hello.

00:20:34.300 --> 00:20:36.600
There's pretty cool stuff
we can do with FlowLayout,

00:20:36.600 --> 00:20:40.940
and I'm going to show you just
how to subclass FlowLayout to add

00:20:40.940 --> 00:20:47.100
a small gesture recognizer to it
and have a nice user interaction.

00:20:47.230 --> 00:20:48.020
All right.

00:20:48.020 --> 00:20:52.080
So here we have a very simple
FlowLayout set up as a grid.

00:20:52.200 --> 00:20:55.900
And what Luke was talking about
is we want maybe to add like a

00:20:55.900 --> 00:21:01.020
small pin-shaped gesture recognizer
to do something like that.

00:21:01.170 --> 00:21:04.000
And it follows my fingers.

00:21:04.080 --> 00:21:07.460
You could add also like a
rotation angle if you wanted to,

00:21:07.530 --> 00:21:12.230
but here we just had an
offset and a zoom scale on it.

00:21:12.310 --> 00:21:14.090
It goes back.

00:21:15.200 --> 00:21:37.100
[Transcript missing]

00:21:37.470 --> 00:21:40.140
The only very interesting
thing we're going to add to the

00:21:40.300 --> 00:21:46.100
layout are those two properties:
pinch cell class and pinch cell center.

00:21:51.270 --> 00:21:56.140
So when you override
UI Collection View flow layout

00:21:56.140 --> 00:22:00.470
or any layout for that matter,
there's two methods to

00:22:00.650 --> 00:22:02.000
implement to override.

00:22:02.000 --> 00:22:04.740
The main one is layout attributes
for item at index pass.

00:22:04.860 --> 00:22:09.520
That's the main function we're going
to call and that return all the layout

00:22:09.520 --> 00:22:12.200
attributes visible in a certain rect.

00:22:12.220 --> 00:22:15.350
So basically your visible bounds.

00:22:15.360 --> 00:22:17.500
So there was this one, of course.

00:22:17.500 --> 00:22:18.500
All right.

00:22:18.500 --> 00:22:22.110
So you can see that's the only code
we had to write to subclass and to

00:22:22.200 --> 00:22:24.500
extend UI Collection View flow layout.

00:22:24.650 --> 00:22:28.060
First thing you want to do is to
grab what the super class is doing.

00:22:28.060 --> 00:22:32.960
So you just call super
with the same method.

00:22:32.960 --> 00:22:37.670
And then with the information
you have given the flow layout

00:22:37.670 --> 00:22:42.400
subclass from your pinch recognizer,
we're going to apply

00:22:42.400 --> 00:22:46.800
those values to the cells,
to the cells attribute.

00:22:46.800 --> 00:22:51.800
And basically what we are doing
is if you are applying the --

00:22:51.840 --> 00:22:56.440
dealing with the pinch cell,
we just apply a transform and

00:22:56.530 --> 00:22:58.570
we offset the center here.

00:23:00.280 --> 00:23:04.700
So there's a little bit, as I said,
there was two methods

00:23:04.800 --> 00:23:06.200
you want to override.

00:23:06.250 --> 00:23:10.630
And so the main one is really the
layout attributes for elements in Rect.

00:23:10.680 --> 00:23:13.340
But the second one is quite important,
too.

00:23:13.510 --> 00:23:18.660
At any given time,
the Collection View can call back

00:23:18.660 --> 00:23:18.660
your flow layout or your layout

00:23:19.050 --> 00:23:27.020
was asking for information
about a very specific cell,

00:23:27.020 --> 00:23:27.020
and we're going to ask you
that for an index pass.

00:23:27.020 --> 00:23:27.020
And here...

00:23:27.240 --> 00:23:33.770
You need to do the same thing and
apply the same transform in the

00:23:33.770 --> 00:23:38.100
same center offset to the cell.

00:23:40.150 --> 00:23:43.310
So really,
when you want to add a bit of user

00:23:43.920 --> 00:23:48.470
interaction to the flow layout,
for example, you have only a couple of

00:23:48.530 --> 00:23:49.770
lines of code to write.

00:23:49.980 --> 00:23:54.790
Here, if you see,
the layout subclass is three functions,

00:23:55.000 --> 00:23:57.890
three methods,
plus some glue code here at the bottom.

00:23:58.000 --> 00:24:03.890
But it's really about 50 lines of
code to add just a pinched organizer.

00:24:03.890 --> 00:24:07.700
And of course,
some bit of glue code in the controller.

00:24:07.790 --> 00:24:11.390
But nothing you have to hack.

00:24:11.400 --> 00:24:15.680
You can really do that
in a very simple fashion.

00:24:16.800 --> 00:24:22.390
Maybe we can look a
bit more at the thing.

00:24:22.800 --> 00:24:26.960
Any gesture, any cell can be pinched.

00:24:27.070 --> 00:24:31.880
And when we fail,
when the gesture recognizer

00:24:32.860 --> 00:24:37.800
So when I lift my finger, in this case,
I go back to the regular layout.

00:24:37.800 --> 00:24:43.040
But in your delegate code,
you could handle that the way you want.

00:24:43.040 --> 00:24:46.020
For example, trigger another action,
maybe changing layout.

00:24:46.140 --> 00:24:48.850
Or even with the same
example of flow layout,

00:24:48.850 --> 00:24:52.620
saying that this cell should be
the entire width of your view,

00:24:52.620 --> 00:24:53.660
for example.

00:24:53.660 --> 00:24:55.660
There's a lot of things
you can do with that.

00:24:55.660 --> 00:25:01.040
And as Luke said,
before writing your own custom layout,

00:25:01.150 --> 00:25:04.560
and if your design fits in
something that's either on the

00:25:04.560 --> 00:25:10.270
line or kind of grid-driven,
you should consider subclassing

00:25:10.270 --> 00:25:12.020
your collection view flow layout.

00:25:12.020 --> 00:25:18.810
Is that it?

00:25:22.400 --> 00:25:24.240
All right, thank you so much, Mathieu.

00:25:24.310 --> 00:25:25.310
It's really that easy.

00:25:25.430 --> 00:25:27.850
I love it.

00:25:27.990 --> 00:25:31.820
So we're going to move on to talking
about maybe what some of you have

00:25:31.820 --> 00:25:35.660
been dreaming of for the last,
I don't know, 16 hours.

00:25:35.660 --> 00:25:37.800
Yeah.

00:25:37.800 --> 00:25:42.040
And that's writing
something totally brand new,

00:25:42.040 --> 00:25:47.140
amazing us all with your brilliant
idea for the layout that is

00:25:47.180 --> 00:25:51.070
going to change the way we
think of user interfaces on iOS.

00:25:51.760 --> 00:25:56.440
And the value proposition that we're
bringing here with UI Collection View is

00:25:56.440 --> 00:26:01.400
that we've taken all of the performance
lessons that we've learned from

00:26:01.400 --> 00:26:05.440
things like building UI Table View,
and we've brought it to

00:26:05.440 --> 00:26:10.380
UI Collection View and abstracted
out this idea of defining how

00:26:10.380 --> 00:26:12.840
things are laid out in that world.

00:26:13.090 --> 00:26:18.220
So when you go write some great layout,

00:26:18.960 --> 00:26:21.910
And then you go apply it to code or even,
you know,

00:26:22.010 --> 00:26:26.310
hand it off to another engineer,
another team of engineers to say, hey,

00:26:26.310 --> 00:26:30.810
take this great layout that I wrote
and apply your data set to it.

00:26:30.970 --> 00:26:34.090
And they can go do that
instantly and see the results.

00:26:34.180 --> 00:26:39.080
You don't have to spend your time
implementing all of the performance

00:26:39.080 --> 00:26:44.200
features and things like cell selection
that you would have to do otherwise

00:26:44.270 --> 00:26:48.700
if you started from scratch writing
something like a grid view on iOS 5.

00:26:48.810 --> 00:26:50.280
That's five.

00:26:50.460 --> 00:26:52.980
I've gotten, you know,
just in the last two days,

00:26:52.980 --> 00:26:59.420
I've talked to a lot of developers who
have written grid-type applications,

00:26:59.420 --> 00:27:05.370
and they come to me and they say, "Man,
this thing is slow." Well...

00:27:06.120 --> 00:27:09.120
There's a good chance, you know,
if you've dealt in Grid worlds,

00:27:09.120 --> 00:27:10.760
you're in one of two situations.

00:27:10.960 --> 00:27:15.450
Either it's slow, in which case,
introduce UI Collection View.

00:27:15.670 --> 00:27:17.580
It's fast.

00:27:17.890 --> 00:27:22.620
Or you actually have really
spent a lot of time on your grid

00:27:22.620 --> 00:27:25.600
view and your grid view is fast.

00:27:25.710 --> 00:27:29.400
Introduce UI Collection View,
now you manage less code.

00:27:29.580 --> 00:27:32.470
So either way,
this is the thing for you if

00:27:32.470 --> 00:27:35.070
you're writing fantastic layouts.

00:27:35.920 --> 00:27:42.060
So the first decision is, okay,
we've talked a lot about FlowLayout.

00:27:42.060 --> 00:27:46.370
We've really pushed the advantages
of subclassing FlowLayout in

00:27:46.370 --> 00:27:50.180
that by going down that route,
you don't have to write a lot of code.

00:27:50.430 --> 00:27:52.740
You get a lot of things for free.

00:27:52.860 --> 00:27:56.790
But your layout idea is just
so cool that it completely

00:27:57.180 --> 00:27:59.700
jumps the bounds of FlowLayout.

00:27:59.700 --> 00:28:05.400
It was not something that mere
mortals like me were able to imagine

00:28:05.400 --> 00:28:10.580
when we designed Collection View.

00:28:10.580 --> 00:28:10.580
So you're --

00:28:10.810 --> 00:28:13.740
Thinking, geez, should I just write a
completely custom layout?

00:28:13.930 --> 00:28:17.200
And the decision for
that is really based on,

00:28:17.200 --> 00:28:20.240
like,
are you changing all the cell positions

00:28:20.240 --> 00:28:23.740
to the point where the flow layout
doesn't make any sense for you anymore?

00:28:24.020 --> 00:28:27.140
You're just not buying anything from it?

00:28:27.250 --> 00:28:30.900
And you have something that just
doesn't look anything like a grid.

00:28:30.900 --> 00:28:33.140
Maybe you have something
that looks like this.

00:28:33.240 --> 00:28:33.520
You know?

00:28:33.700 --> 00:28:36.380
That bears no resemblance to flow layout.

00:28:36.510 --> 00:28:38.940
And so if you're doing that, okay.

00:28:38.990 --> 00:28:41.600
It's time for you to write
a fully custom layout.

00:28:41.640 --> 00:28:46.620
And the good news is,
even though you're sort of declaring

00:28:46.710 --> 00:28:50.890
yourself God and writing everything,

00:28:51.140 --> 00:28:53.140
The API is quite simple.

00:28:53.260 --> 00:28:58.470
And that's the other advantage of
UI CollectionView is we've defined

00:28:58.470 --> 00:29:03.890
a very succinct set of methods and a
framework for thinking about defining

00:29:03.890 --> 00:29:08.460
layout information in addition to
handling the work of performance and

00:29:08.690 --> 00:29:13.410
enabling cell selection capability and
things like that so that you can focus

00:29:13.470 --> 00:29:18.740
your creative energies on building
the best definition of a layout.

00:29:18.850 --> 00:29:21.730
And we have the framework for
you to define that layout.

00:29:21.900 --> 00:29:26.540
So if you're in this world,
you are going to subclass an

00:29:26.540 --> 00:29:31.020
abstract class that we are shipping
called UI CollectionView layout.

00:29:31.130 --> 00:29:34.140
This is a superclass of
UI CollectionView flow layout.

00:29:34.260 --> 00:29:36.790
And as an abstract class,
there are a handful of

00:29:36.790 --> 00:29:39.230
methods that you're required
to override when you do this.

00:29:39.230 --> 00:29:41.030
So we'll talk about those now.

00:29:41.160 --> 00:29:44.330
Number one,
UI CollectionView content size

00:29:44.330 --> 00:29:46.360
or CollectionView content size.

00:29:46.370 --> 00:29:50.150
This is where you tell us
what is the user scrollable

00:29:50.150 --> 00:29:53.880
area in the CollectionView,
the area in which you are going to

00:29:53.880 --> 00:29:58.950
layout content so we know how to set
the content size and where you might

00:29:59.020 --> 00:30:02.420
put content within this CollectionView.

00:30:02.750 --> 00:30:06.520
Number two,
you need to give us layout attributes

00:30:06.520 --> 00:30:09.440
for elements in a given rectangle.

00:30:09.440 --> 00:30:11.170
This is going to be the meet method.

00:30:11.440 --> 00:30:14.650
This is, I dare say,
the single most important method

00:30:14.650 --> 00:30:16.440
on UI Collection View layout.

00:30:16.700 --> 00:30:20.760
It is the thing that we're
going to call when we bootstrap

00:30:20.760 --> 00:30:24.700
up the Collection View to
ask how to lay things out.

00:30:24.700 --> 00:30:26.860
And here you're going to
provide us an NSArray of

00:30:26.920 --> 00:30:29.700
UI Collection View layout attributes.

00:30:29.700 --> 00:30:33.050
We will take those attributes,
which define how to lay things out,

00:30:33.160 --> 00:30:34.700
and go apply them to views.

00:30:35.270 --> 00:30:37.770
Additionally,
as Mathieu mentioned before,

00:30:37.770 --> 00:30:41.610
we will from time to time require
direct access to the layout

00:30:41.610 --> 00:30:43.630
attributes for a given item.

00:30:43.810 --> 00:30:49.290
So you're required to implement layout
attributes for item at index path.

00:30:50.250 --> 00:30:54.110
This is sort of the, you know,
quick way instead of going through

00:30:54.110 --> 00:30:57.060
layout attributes for elements in Rect.

00:30:57.180 --> 00:31:01.440
Additionally, we have direct accessors
for supplementary views

00:31:01.550 --> 00:31:03.300
and for decoration views.

00:31:03.420 --> 00:31:07.010
So if you support supplementary views
or you support decoration views,

00:31:07.320 --> 00:31:12.810
you're also required to implement
these direct accessors as appropriate.

00:31:15.760 --> 00:31:19.540
Let's talk about the order of operations
in which UI Collection View will

00:31:19.540 --> 00:31:21.520
call these things.

00:31:22.440 --> 00:31:25.690
We're going to start by
calling prepareLayout.

00:31:25.800 --> 00:31:26.860
This is an optional method.

00:31:26.860 --> 00:31:28.960
It's not one of the required ones.

00:31:28.990 --> 00:31:32.450
But this is the opportunity
for your layout to do upfront

00:31:32.560 --> 00:31:37.100
calculations regarding however
you're going to lay things out.

00:31:37.200 --> 00:31:41.500
And, for example,
the circle layout that we saw

00:31:41.630 --> 00:31:44.950
in the previous session's demo

00:31:46.130 --> 00:31:50.100
Prepare a layout that might
figure out how many cells,

00:31:50.100 --> 00:31:54.990
how many elements are in that circle
and determine based on that what

00:31:55.130 --> 00:31:59.490
the radius offset it's going to
use for each item and it can use

00:31:59.490 --> 00:32:04.780
that radius offset in computing
individual item attributes later.

00:32:04.870 --> 00:32:07.360
Or a layout might compute
everything about itself.

00:32:07.360 --> 00:32:13.940
It might store off layout attributes
in a dictionary or an array somewhere.

00:32:14.120 --> 00:32:18.320
So this can be whatever you want,
as much upfront calculation as you want.

00:32:18.600 --> 00:32:20.180
Or it can be as lazy as you want.

00:32:20.180 --> 00:32:24.090
You can choose to ignore this method
and do all of your calculations

00:32:24.180 --> 00:32:29.100
later when we ask you for layout
attributes for elements in Rect.

00:32:29.190 --> 00:32:32.400
Next thing we're going to call
is Collection View Content Size.

00:32:32.400 --> 00:32:35.340
We need to -- after you're prepared,
we need you to tell us, hey,

00:32:35.340 --> 00:32:37.200
what's the area in which
you're going to lay stuff out?

00:32:38.670 --> 00:32:41.050
After we have that area,
we set the content size

00:32:41.120 --> 00:32:43.470
of the collection view,
and we will call that

00:32:43.470 --> 00:32:47.430
most important of methods,
layout attributes for elements in Rect.

00:32:47.500 --> 00:32:50.260
This is when, okay, it's time,
we're going to display

00:32:50.260 --> 00:32:53.910
stuff on the screen,
we need to know where to put it.

00:32:54.010 --> 00:32:56.330
And, in fact, what stuff is on screen.

00:32:56.460 --> 00:33:02.440
So we're going to pass you a Rect that
will at least cover the current screen.

00:33:02.510 --> 00:33:07.370
And you need to tell us what's in
that Rect and how to lay it out.

00:33:07.470 --> 00:33:09.440
Pass this layout attribute instances.

00:33:09.610 --> 00:33:13.340
At this point, from this point,
our layout is considered

00:33:13.340 --> 00:33:15.450
effectively live,
if you will.

00:33:15.840 --> 00:33:19.120
And we can call any of the other
methods that are defined on

00:33:19.120 --> 00:33:23.200
UI Collection View attributes,
depending on what happens in the

00:33:23.200 --> 00:33:28.640
flow of interaction and what is
necessary for the given time.

00:33:29.730 --> 00:33:35.560
Until we hit at some point,
the layout gets invalidated.

00:33:35.690 --> 00:33:38.080
This happens for any of the
reasons we talked about before.

00:33:38.240 --> 00:33:40.540
The controller calls invalidateLayout,
the layout calls

00:33:40.540 --> 00:33:41.690
invalidateLayout on itself.

00:33:42.090 --> 00:33:45.500
Whatever reason it gets invalidated,
we call invalidateLayout.

00:33:45.620 --> 00:33:47.190
And that means start over.

00:33:47.340 --> 00:33:50.240
So after that point,
we go back to the beginning.

00:33:50.310 --> 00:33:52.250
We'll call prepareLayout
on your layout again.

00:33:52.540 --> 00:33:56.250
It'll give you a chance to redo any of
those calculations that you threw out in

00:33:56.250 --> 00:34:00.360
invalidateLayout because you won't need
anything again after invalidateLayout.

00:34:00.450 --> 00:34:02.590
And the cycle continues.

00:34:02.650 --> 00:34:03.240
We start over.

00:34:03.240 --> 00:34:04.790
We do that same thing again.

00:34:04.940 --> 00:34:07.230
Just a few methods.

00:34:07.330 --> 00:34:12.220
And it's really just within
this very simple framework.

00:34:12.380 --> 00:34:17.880
that you can provide to us layout
attributes for whatever you might need,

00:34:17.880 --> 00:34:21.300
defined in whatever way
makes sense for you,

00:34:21.300 --> 00:34:25.870
provides a nice simple way of
separating definition of a layout

00:34:26.160 --> 00:34:31.850
from all the other great features
that are supplied by Collection View.

00:34:31.950 --> 00:34:37.420
And also makes it so that you
can define a layout and ship it

00:34:37.420 --> 00:34:41.330
to somebody else who is creating
content and creating a controller

00:34:41.330 --> 00:34:43.730
and a delegate and all that such.

00:34:43.870 --> 00:34:46.130
So that's just how simple it is.

00:34:46.280 --> 00:34:50.370
At this point, I would like to invite Dr.

00:34:50.480 --> 00:34:56.260
Olivier Gutknecht on stage to show
us a demo of how all this works.

00:35:03.460 --> 00:35:06.000
Only two layouts.

00:35:06.090 --> 00:35:12.030
Yeah, yesterday I maybe did 42
layouts in five minutes.

00:35:12.080 --> 00:35:14.720
I'm going to be nice and quiet.

00:35:20.930 --> 00:35:25.030
You know these iOS apps showing
some kind of document browser?

00:35:25.150 --> 00:35:31.890
So you have this line of documents and
the thing at the center is a small zoom,

00:35:31.890 --> 00:35:33.340
scaled up?

00:35:33.450 --> 00:35:35.060
We need to do that.

00:35:35.190 --> 00:35:37.330
So it's a Collection View Flow layout.

00:35:37.450 --> 00:35:45.990
And what I did here is just set up
an in-time size in my subclass and

00:35:46.150 --> 00:35:54.070
change my scroll direction so that's
actually a horizontal scrolling layout.

00:35:54.530 --> 00:36:00.260
And in that case,
it's just a very simple flow layout.

00:36:00.370 --> 00:36:05.330
Next thing I'm going to do is to
adjust parameters on that flow layout

00:36:05.970 --> 00:36:10.040
so I'm going to get only one line.

00:36:10.140 --> 00:36:14.150
So that should be, yes, much better.

00:36:14.350 --> 00:36:19.800
So now, I need this scaling effect.

00:36:19.940 --> 00:36:28.140
How do I do that?

00:36:28.180 --> 00:36:28.190
I'm going to use the exact same
technique and actually reuse

00:36:29.070 --> 00:36:32.600
Well, the flow layout is going to define.

00:36:32.670 --> 00:36:38.150
And for that layout, what I want to do is

00:36:38.640 --> 00:36:44.920
Just grab the cell at the center of the
screen and just tweak its attributes.

00:36:45.050 --> 00:36:50.970
So what I'm doing here
is I check the actual

00:36:51.610 --> 00:36:56.650
Collection view bound size
and its content offset.

00:36:56.650 --> 00:37:02.720
And I have this very boring mathematical
stuff which just tries to find what

00:37:02.720 --> 00:37:08.140
is in this current attribute which
is the thing closest to the center.

00:37:08.230 --> 00:37:15.870
And then the only thing I need to do is
to apply a zoom based on the distance for

00:37:15.870 --> 00:37:20.440
that cell which is closest to the center.

00:37:20.520 --> 00:37:22.020
So.

00:37:23.600 --> 00:37:25.730
Let's try that.

00:37:25.740 --> 00:37:28.230
Oh, that was better.

00:37:28.240 --> 00:37:29.870
Actually, no.

00:37:32.550 --> 00:37:37.780
The thing I need to do now
is when I scroll my layout,

00:37:37.940 --> 00:37:44.660
when I scroll my collection view,
I actually need to update the attributes

00:37:44.660 --> 00:37:48.060
for the cell each time I scroll,
right?

00:37:48.260 --> 00:37:55.630
So one thing I could do is to
call invalidateLayout a lot or

00:37:58.050 --> 00:38:03.820
I can use this "Should invalidate
layout" for bounds change.

00:38:05.790 --> 00:38:11.240
And in that case,
Collection View is going

00:38:11.240 --> 00:38:13.700
to invalidate that for me.

00:38:13.850 --> 00:38:17.850
So I basically have what I need here.

00:38:19.380 --> 00:38:25.690
Okay, maybe the one thing missing,
if you want to nitpick, is...

00:38:26.230 --> 00:38:30.420
You remember my
CoverFlow-like demo yesterday?

00:38:30.750 --> 00:38:34.800
I had this nice snapping
behavior for the cell,

00:38:34.950 --> 00:38:38.660
so it would be perfectly centered.

00:38:38.810 --> 00:38:42.030
So I'm going to add that.

00:38:52.000 --> 00:39:01.300
[Transcript missing]

00:39:02.060 --> 00:39:07.750
So that method is a way to
scroll a view that is our

00:39:07.750 --> 00:39:12.630
superclass in Collection View,
is going to communicate with the layout.

00:39:12.800 --> 00:39:16.060
So we actually ask,
the Collection View asks

00:39:16.120 --> 00:39:19.390
the layout to compute that

00:39:19.930 --> 00:39:22.760
Target offset when we scroll.

00:39:22.760 --> 00:39:25.110
And the way we do that is...

00:39:26.000 --> 00:39:34.500
[Transcript missing]

00:39:34.800 --> 00:39:40.200
We're going to iterate in the
destination rack for the scroll.

00:39:40.630 --> 00:39:44.830
We're going to find what cell,
actually what layout attributes is

00:39:45.290 --> 00:39:49.770
the actual closest one to the center.

00:39:49.770 --> 00:39:54.380
And in that case, we just slightly tweak

00:39:55.680 --> 00:39:58.720
The offset for that cell.

00:39:58.830 --> 00:40:04.920
And that value is going to be used
by the scroll view to actually

00:40:04.920 --> 00:40:08.300
adapt to target content offsets.

00:40:08.450 --> 00:40:10.560
So, okay, what do we have here?

00:40:10.660 --> 00:40:12.140
One method.

00:40:12.280 --> 00:40:13.900
Two methods.

00:40:14.070 --> 00:40:16.270
Three, four in it.

00:40:17.540 --> 00:40:22.120
So with that amount of code,
you can implement this very popular

00:40:22.830 --> 00:40:26.800
scaling effect in your line layout.

00:40:31.720 --> 00:40:35.100
That was a technique which is
not tied to Flow Layout at all.

00:40:35.100 --> 00:40:38.600
You can use that for any
of your custom layouts.

00:40:38.720 --> 00:40:45.740
So, let's check a custom layout now.

00:40:51.850 --> 00:40:56.800
You might remember this one.

00:40:56.970 --> 00:41:01.800
So that is definitely
not a line-based layout.

00:41:01.950 --> 00:41:07.390
So we set up in this one the
layout attributes all self,

00:41:07.550 --> 00:41:13.780
and I also added -- couldn't
resist -- a small animation for

00:41:13.790 --> 00:41:17.120
appearing and disappearing cells.

00:41:17.310 --> 00:41:20.210
So how do you do that?

00:41:20.300 --> 00:41:24.740
Let me just show you the actual
view controller because we

00:41:24.740 --> 00:41:27.390
don't really have magic here.

00:41:27.460 --> 00:41:29.040
I just want to prove that.

00:41:29.210 --> 00:41:34.080
So I set up a gesture recognizer
on my collection view.

00:41:34.620 --> 00:41:38.750
I registered the CEL class,
as we learned yesterday,

00:41:38.750 --> 00:41:42.000
and I set up a nice background color.

00:41:42.110 --> 00:41:47.460
And I think I have the most stupid
data source implementation ever.

00:41:48.920 --> 00:41:51.570
I just need a cell count.

00:41:51.780 --> 00:41:53.560
So I need 60 items.

00:41:53.620 --> 00:41:54.560
Okay.

00:41:54.700 --> 00:41:58.860
And my cell,
because I don't have any content in that,

00:41:59.010 --> 00:42:04.730
I just dequeue and return my cell.

00:42:04.730 --> 00:42:04.730
Then,

00:42:06.600 --> 00:42:10.640
This tapping gesture,
I'm using here a few things that

00:42:11.280 --> 00:42:15.350
Collection View can do for you.

00:42:15.850 --> 00:42:20.000
One thing is you can
ask the Collection View

00:42:20.890 --> 00:42:25.840
What index path is at
a point in the view?

00:42:26.040 --> 00:42:31.100
So I just get the index
path for the cell I tapped.

00:42:31.740 --> 00:42:36.500
And if I tap that cell,
I want that cell to go away.

00:42:36.580 --> 00:42:41.080
So my extremely stupid implementation
of a data source is just going

00:42:41.080 --> 00:42:43.500
to decrement that cell count.

00:42:43.630 --> 00:42:50.850
And I'm going to remove in my collection
view an item for that index pass.

00:42:51.060 --> 00:42:54.800
So if you used table view before,
it's basically the same thing.

00:42:54.800 --> 00:42:58.400
It's block-based,
but the exact same mechanism

00:42:58.600 --> 00:43:01.230
we were using with table views.

00:43:02.570 --> 00:43:05.650
And because I'm doing that
with this block-based method,

00:43:05.650 --> 00:43:08.000
it's just going to animate things.

00:43:08.000 --> 00:43:12.590
And if I didn't tap on a cell, well,
in that case,

00:43:12.660 --> 00:43:16.460
that index pass returned by the
collection view is going to be nil.

00:43:16.460 --> 00:43:20.870
So I just decided that when
I tap in the background,

00:43:20.870 --> 00:43:22.980
I just want to add a new cell.

00:43:23.050 --> 00:43:25.600
So that's my logic.

00:43:25.620 --> 00:43:27.560
That was quite simple.

00:43:27.560 --> 00:43:30.740
Now, what about the layout itself?

00:43:30.770 --> 00:43:34.690
So that's a
UI Collection View Layout subclass.

00:43:35.180 --> 00:43:37.100
I just need a few things.

00:43:37.210 --> 00:43:43.100
The radius for my circle,
where that thing is on screen.

00:43:43.380 --> 00:43:49.100
And I'm going to track a
cell count in this layout.

00:43:49.170 --> 00:43:51.090
And you'll see why.

00:43:53.010 --> 00:44:00.340
So, my two really important methods here,
the one that we call when

00:44:00.420 --> 00:44:02.260
we set up a custom layout.

00:44:02.520 --> 00:44:08.230
First, prepare layout.

00:44:08.230 --> 00:44:08.230
This is where we are...

00:44:08.440 --> 00:44:12.440
If you want to set up some
initial attributes or compute

00:44:12.940 --> 00:44:19.300
a few things ahead of time,
PreparLayout is the place to do that.

00:44:19.430 --> 00:44:23.370
And because that is a
really simple layout,

00:44:23.370 --> 00:44:29.410
and because I'm lazy,
that layout only supports one section.

00:44:29.900 --> 00:44:33.580
And I'm implementing that by
asking the Collection View how

00:44:33.580 --> 00:44:36.300
many items do we want to layout.

00:44:36.420 --> 00:44:42.400
So that line is basically my
configuration for my layout

00:44:42.600 --> 00:44:44.710
at a given point of time.

00:44:44.960 --> 00:44:50.970
Then, my two other parameters is where
should I display that circle and

00:44:50.970 --> 00:44:54.040
radius for that circle layout.

00:44:54.170 --> 00:44:59.860
And again, that's a very simple layout,
and I don't want to scroll or anything,

00:44:59.860 --> 00:45:05.690
so the Collection View Content Size I'm
using actually is going to be just

00:45:05.690 --> 00:45:09.700
a frame of my Collection View,
so that's really full screen,

00:45:09.700 --> 00:45:11.350
no scrolling layout.

00:45:11.830 --> 00:45:19.700
And I'm using that to set up my
center for that layout and the radius.

00:45:19.940 --> 00:45:24.690
And I'm ready to actually
generate layout attributes now.

00:45:25.600 --> 00:45:30.060
So that's our next method.

00:45:30.230 --> 00:45:34.220
So Luke said that when you're
implementing a custom layout,

00:45:34.220 --> 00:45:37.540
you have two methods that
you really need to implement.

00:45:37.540 --> 00:45:42.710
Layout for index pass and layout
attributes for item at index pass

00:45:42.870 --> 00:45:45.660
and layout attributes for rect.

00:45:45.780 --> 00:45:51.030
And that layout attributes
for item at index pass

00:45:51.370 --> 00:45:55.800
It's usually where you actually
instantiate a layout attribute.

00:45:55.890 --> 00:46:05.120
So that line is just us constructing
a layout of UI Collection View layout

00:46:05.120 --> 00:46:08.290
attributes for an index pass.

00:46:08.390 --> 00:46:10.170
So you have this method,
layout attributes for

00:46:10.230 --> 00:46:11.300
cells with index pass.

00:46:11.300 --> 00:46:15.290
We have the same thing for supplemental
reviews and decoration views.

00:46:15.400 --> 00:46:18.610
And the next step is just to
decide what you want to do

00:46:18.610 --> 00:46:20.800
with that layout attributes.

00:46:20.980 --> 00:46:25.980
So we just want to set up
the size for that cell.

00:46:26.610 --> 00:46:32.240
And the center part,
where should we actually position that?

00:46:32.410 --> 00:46:34.700
So mathematics again.

00:46:34.830 --> 00:46:39.910
And we're just using our cell count
we prepared in the PreparLayout

00:46:39.960 --> 00:46:48.640
phase to actually decide where each
of these cells should be based on,

00:46:48.640 --> 00:46:48.640
basically.

00:46:49.000 --> 00:46:54.300
[Transcript missing]

00:46:54.510 --> 00:46:55.900
What's happening here?

00:46:56.060 --> 00:47:00.080
Collection view needs layout
for a given index pass.

00:47:00.110 --> 00:47:02.290
Scrolling the layout
with that index pass,

00:47:02.400 --> 00:47:07.590
we compute the exact position
for anything that should

00:47:07.590 --> 00:47:08.920
be at that index pass.

00:47:09.100 --> 00:47:13.850
And these index pass are basically
what are in your data source.

00:47:13.990 --> 00:47:16.600
And then we return the attributes.

00:47:17.040 --> 00:47:22.340
So for my circle layout,
that was quite a simple implementation.

00:47:22.440 --> 00:47:25.940
We have a perfectly mathematical layout.

00:47:25.940 --> 00:47:31.090
For things more complicated
like my map example yesterday,

00:47:31.190 --> 00:47:36.050
you could generate that before in
prepareLayout and just return a given

00:47:36.050 --> 00:47:38.430
layout attribute in this method.

00:47:38.590 --> 00:47:42.340
We have a lot of
different strategies here.

00:47:42.880 --> 00:47:46.740
And the next method I actually
need to implement is layout

00:47:46.740 --> 00:47:49.050
attributes for elements in React.

00:47:49.160 --> 00:47:55.200
And again, that is a very simple layout,
because I want to display

00:47:55.430 --> 00:47:57.400
every single cell here.

00:47:57.620 --> 00:48:03.470
So that implementation is just iterating

00:48:04.760 --> 00:48:10.350
On the cell count,
we are building an index

00:48:10.350 --> 00:48:12.790
pass for that item.

00:48:13.260 --> 00:48:16.800
And then we need to generate
for each of these index paths

00:48:17.880 --> 00:48:20.120
UI Collection View Layout attributes.

00:48:20.150 --> 00:48:22.280
And the good thing is

00:48:22.980 --> 00:48:24.760
We did that already.

00:48:24.920 --> 00:48:28.570
So I'm just reusing this layout
attributes for item at index

00:48:28.640 --> 00:48:33.240
pass above to create that
UI Collection View layout attributes.

00:48:33.340 --> 00:48:36.130
That implementation is very simple.

00:48:36.410 --> 00:48:40.500
So, UI Collection View is not magic.

00:48:40.590 --> 00:48:41.970
Not completely.

00:48:42.090 --> 00:48:46.150
So,
when you want to build your own layout,

00:48:46.560 --> 00:48:51.210
You won't -- probably you
won't be in that situation.

00:48:51.210 --> 00:48:57.640
You won't want to actually display
every single item in your data set.

00:48:57.770 --> 00:49:01.630
That is going to be quite
high performance cost.

00:49:01.760 --> 00:49:06.990
So when you have things like a stack
layout that Luke had on the slide

00:49:07.100 --> 00:49:12.440
before or in my demo yesterday,
you want to optimize that.

00:49:12.550 --> 00:49:16.730
You want to display a few cells,
and after that,

00:49:16.810 --> 00:49:20.530
just cheat and not generate
layout attributes for every

00:49:20.530 --> 00:49:23.450
single item in your data set.

00:49:23.570 --> 00:49:27.700
But with this form method,

00:49:28.480 --> 00:49:32.220
We have a perfectly fine custom layout.

00:49:32.220 --> 00:49:39.210
And now we can add some fancy stuff like
these custom animations for inserting

00:49:39.210 --> 00:49:42.600
and deleting items in my data set.

00:49:43.330 --> 00:49:47.310
And that's quite easy, actually.

00:49:47.620 --> 00:49:50.970
So you just have to override one method,
which is

00:49:51.360 --> 00:49:55.390
initial layout attributes for
inserted item at index pass.

00:49:55.490 --> 00:49:59.680
We absolutely love
extremely long method names.

00:50:00.440 --> 00:50:04.540
And how do I do that?

00:50:04.650 --> 00:50:10.880
Well, initial layout attributes is going
to be the starting point for a cell

00:50:10.980 --> 00:50:15.160
that I want to insert in my layout.

00:50:15.200 --> 00:50:19.110
So if we get back to this

00:50:20.320 --> 00:50:22.700
Animation.

00:50:22.800 --> 00:50:24.640
What's happening here?

00:50:24.790 --> 00:50:28.500
So layout itself is going
to reconfigure itself.

00:50:28.500 --> 00:50:32.680
And that is just calling -- that
is just a collection view calling

00:50:32.680 --> 00:50:35.200
layout attributes for items in React.

00:50:35.510 --> 00:50:40.530
And for this cell animation,
what we actually do

00:50:40.530 --> 00:50:43.130
here is really simple.

00:50:43.130 --> 00:50:48.420
We just want that cell to start
at the center and with alpha 0.

00:50:48.420 --> 00:50:48.420
So

00:50:49.040 --> 00:50:53.650
I just reuse again my layout
attributes for item at index

00:50:54.050 --> 00:50:56.070
path method and I just tweak.

00:50:56.110 --> 00:50:59.150
It's a bit technical like what we
did with subclassing for layout,

00:50:59.320 --> 00:51:02.510
just reusing layout
attributes and tweaking that.

00:51:02.640 --> 00:51:05.930
And I just change the
opacity and the center.

00:51:06.030 --> 00:51:10.350
And what Collection View is going to do,
it's going to compute its final

00:51:10.370 --> 00:51:17.240
official position in the circle and then
compute that initial layout attribute.

00:51:17.300 --> 00:51:24.000
And we're going to animate from that
initial state to that official state.

00:51:24.770 --> 00:51:31.730
And building this animation for the
disappearing cell is actually quite easy,

00:51:31.730 --> 00:51:32.340
too.

00:51:32.540 --> 00:51:40.120
And in this case, if you remember,
is when I actually tap a cell here.

00:51:41.060 --> 00:51:44.400
What I'm doing is, again,
reusing the same technique of

00:51:44.400 --> 00:51:50.150
grabbing the existing layout
attributes for that index pass and

00:51:50.590 --> 00:51:53.270
I'm switching the opacity to zero.

00:51:53.460 --> 00:51:59.100
I'm again changing the
position to be at the center.

00:51:59.100 --> 00:52:04.080
So I'm setting the center of the
cell to be the center of my layout.

00:52:04.080 --> 00:52:09.480
And the only additional tweak
is this shrinking effect,

00:52:09.480 --> 00:52:12.820
which is just a small
CA transform 3D scale.

00:52:12.820 --> 00:52:15.880
So it's just a scaling transform.

00:52:16.040 --> 00:52:19.270
So with these two methods,
just a few lines of code,

00:52:19.360 --> 00:52:24.220
I have custom animation for
ourselves going in and going out.

00:52:24.220 --> 00:52:31.520
And then to wrap this up,
I'd like to bring back Luke on stage.

00:52:31.520 --> 00:52:31.520
Thank you.

00:52:41.080 --> 00:52:46.490
I really hope you guys are as excited as
we are about the possibilities that are

00:52:46.660 --> 00:52:52.580
being enabled by UI Collection View and
really by your creativity,

00:52:52.580 --> 00:52:58.650
which is now going to be unleashed
by how much easier it is to define

00:52:58.650 --> 00:53:03.940
a user interface that is highly
performant and has built-in features

00:53:03.940 --> 00:53:07.630
like selection and such on the cells.

00:53:07.800 --> 00:53:13.400
So to review the ideas that we
really want to take away from this,

00:53:13.540 --> 00:53:18.670
remember just how powerful
UI Collection View flow layout is.

00:53:18.790 --> 00:53:22.040
When you go out and start
thinking about cool new things,

00:53:22.140 --> 00:53:23.890
remember that it's powerful.

00:53:23.990 --> 00:53:26.310
It's got a lot of bells and
whistles that you can tweak in

00:53:26.310 --> 00:53:29.430
the delegate and its properties
that we talked about yesterday.

00:53:29.570 --> 00:53:36.300
But it's also a subclassable entity
that you can add your own ideas onto

00:53:36.300 --> 00:53:37.600
based on the framework that we have.

00:53:37.600 --> 00:53:39.810
have already built for you.

00:53:40.110 --> 00:53:44.240
And then, moreover,
the fact that UI Collection View enables

00:53:44.240 --> 00:53:48.390
you to build completely custom
layouts and define that layout

00:53:48.400 --> 00:53:53.560
code separate from all the performance
optimizations and features that

00:53:53.560 --> 00:53:56.200
we have built into Collection View.

00:53:56.420 --> 00:54:02.930
So, taking that framework,
taking the work that we have done for

00:54:03.000 --> 00:54:09.800
you into building great user interfaces
is something that I hope you'll enjoy.

00:54:09.800 --> 00:54:14.400
And I know I am incredibly looking
forward to coming back a year

00:54:14.400 --> 00:54:18.210
from now and seeing what all
the just spectacular interfaces

00:54:18.290 --> 00:54:20.080
you guys have come out with are.

00:54:20.300 --> 00:54:25.180
So, thank you very much for coming and
learning about Collection View.

00:54:25.900 --> 00:54:29.090
If you have more questions,
direct them to Jake Behrens.

00:54:29.170 --> 00:54:31.420
He's our UI Frameworks Evangelist.

00:54:31.420 --> 00:54:33.420
We have another intro session tomorrow.
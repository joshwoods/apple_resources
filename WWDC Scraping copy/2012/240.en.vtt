WEBVTT

00:00:11.100 --> 00:00:12.450
Good afternoon, everybody.

00:00:12.630 --> 00:00:15.960
Thanks for coming to check out
the Polishing Your Interface

00:00:15.960 --> 00:00:19.490
Rotation Animations talk,
even if you didn't necessarily

00:00:19.490 --> 00:00:22.180
know what it was that meant
when you read the title.

00:00:22.470 --> 00:00:25.910
So we're going to talk a little bit
today about interface rotations,

00:00:26.070 --> 00:00:29.950
and by that I mean the thing that happens
when you take your device and turn it

00:00:30.070 --> 00:00:34.270
from portrait to landscape or vice versa,
and you get a nice smooth rotation

00:00:34.280 --> 00:00:38.580
transition as it rotates and
animates from one to the other.

00:00:38.650 --> 00:00:42.480
So we're going to start by talking about,
well, what exactly that means, and,

00:00:42.520 --> 00:00:45.390
you know, gave you a little idea there,
but we've got a little

00:00:45.550 --> 00:00:48.560
more depth to go into,
and why you want to do this.

00:00:48.670 --> 00:00:52.140
And really the reason here is
because this is one of those things,

00:00:52.140 --> 00:00:56.510
one of those little pieces of polish that
just makes your app that much better.

00:00:56.600 --> 00:01:01.200
A key component of iOS landscape and
portrait operation is the fact that the

00:01:01.200 --> 00:01:04.600
transition between the two is super,
super smooth,

00:01:04.600 --> 00:01:06.600
and like a really nice smooth
transition rotation keeps your users

00:01:06.600 --> 00:01:06.600
in the context of the rotation.

00:01:06.600 --> 00:01:06.600
So we're going to start by talking
about what exactly that means,

00:01:06.600 --> 00:01:06.600
and, you know,
gave you a little idea there,

00:01:06.600 --> 00:01:06.600
but we've got a little
more depth to go into,

00:01:06.600 --> 00:01:06.600
and why you want to do this.

00:01:06.600 --> 00:01:06.970
And really the reason here is
because this is one of those things,

00:01:06.970 --> 00:01:07.600
one of those little pieces of polish that
just makes your app that much better.

00:01:07.660 --> 00:01:10.350
your users in the context of
what they're seeing and make

00:01:10.390 --> 00:01:12.650
sure that there's no jarring,
you know,

00:01:12.650 --> 00:01:16.660
fades or jumps when the device goes
from one orientation to the other.

00:01:16.660 --> 00:01:19.530
So it's really important that
this be smooth and that the users

00:01:19.540 --> 00:01:21.120
have a good experience here.

00:01:21.350 --> 00:01:24.150
After we're done talking about that,
then we're going to talk a little

00:01:24.160 --> 00:01:28.060
bit about the iOS view hierarchy,
the way that animations work and how

00:01:28.060 --> 00:01:31.300
they get rendered onto the screen,
so that we can talk a little bit

00:01:31.300 --> 00:01:34.160
about how that impacts the way
that you're going to design and

00:01:34.160 --> 00:01:36.000
update your rotation animations.

00:01:36.120 --> 00:01:37.670
And then after we've
talked about those things,

00:01:37.770 --> 00:01:40.610
we're going to get into some more
advanced topics about some performance

00:01:40.610 --> 00:01:44.000
issues that you may run into and
ways that you can resolve them.

00:01:44.000 --> 00:01:47.210
If you just go ahead and start out
by doing the really simple thing and

00:01:47.210 --> 00:01:50.900
basically doing nothing and hoping
that your rotations will look smooth,

00:01:50.970 --> 00:01:53.490
sometimes you may find that's
not the case without some work.

00:01:53.600 --> 00:01:56.480
So we'll look at what you might
change in order to make them smoother.

00:01:56.570 --> 00:01:58.710
And then if you find that
even just optimizing your

00:01:58.710 --> 00:02:01.700
performance isn't sufficient to
get a really great experience,

00:02:01.840 --> 00:02:05.290
we'll talk about some
visual sleight of hand,

00:02:05.300 --> 00:02:08.700
various different ways that you
can trick your users into thinking

00:02:08.700 --> 00:02:11.120
that they're seeing you doing
something awesome on the screen

00:02:11.340 --> 00:02:13.890
that you're really not doing at all.

00:02:13.970 --> 00:02:15.500
So, yeah, basically trick your users.

00:02:15.500 --> 00:02:18.100
It's a good plan.

00:02:18.150 --> 00:02:18.340
All right.

00:02:18.410 --> 00:02:20.600
So first, what is interface rotation?

00:02:20.610 --> 00:02:24.180
Well, let's take, for example,
a really common thing that you'll

00:02:24.180 --> 00:02:27.510
obviously see in most apps on iOS,
but starting with this one,

00:02:27.510 --> 00:02:28.440
the Notes app.

00:02:28.640 --> 00:02:32.430
So when your user rotates their
device from portrait to landscape,

00:02:32.500 --> 00:02:36.120
they're going to see a nice transition,
an animation that's going

00:02:36.190 --> 00:02:38.100
to happen when this happens.

00:02:38.100 --> 00:02:39.340
There it is.

00:02:39.420 --> 00:02:41.270
And then, of course,
when they rotate back from

00:02:41.270 --> 00:02:43.160
landscape back to portrait,
you're going to get

00:02:43.180 --> 00:02:43.800
another nice animation.

00:02:43.800 --> 00:02:45.790
That smoothly brings you back.

00:02:45.800 --> 00:02:47.800
Now, that all happens pretty fast.

00:02:47.800 --> 00:02:49.340
So you may be thinking, well, it was,
you know,

00:02:49.340 --> 00:02:50.800
three-tenths of a second or something.

00:02:50.800 --> 00:02:51.790
Whatever.

00:02:51.800 --> 00:02:53.800
But it really is important.

00:02:53.800 --> 00:02:55.520
You know,
it keeps your users with the context

00:02:55.570 --> 00:02:56.800
of what they were working on.

00:02:56.800 --> 00:03:00.760
It makes sure that they know exactly what
from one orientation is still relevant in

00:03:00.760 --> 00:03:04.800
the next orientation so that they don't
lose track of what they were working on.

00:03:04.800 --> 00:03:08.200
It's just that nice, you know,
part of what makes using

00:03:08.200 --> 00:03:09.800
an iOS device so nice.

00:03:09.800 --> 00:03:11.540
So I want to slow this rotation
animation down a little bit so

00:03:11.540 --> 00:03:13.700
that you can see some of the things
that I'm going to be talking about.

00:03:13.700 --> 00:03:15.690
So let's see some of the
things that are happening here.

00:03:15.720 --> 00:03:18.640
Because at first it may just look like
we're actually redrawing all those

00:03:18.790 --> 00:03:21.690
intermediate frames and doing exactly
the kind of thing that you would expect

00:03:21.700 --> 00:03:26.700
if you really drew every frame at the way
that it should look during this rotation.

00:03:26.700 --> 00:03:29.210
But when I run it really slow,
you're going to see that in some

00:03:29.210 --> 00:03:30.700
cases that's not actually true.

00:03:30.700 --> 00:03:33.700
So let's take another look with it
running just a little bit slower.

00:03:33.700 --> 00:03:36.850
So partway through the rotation,
if you watch the keyboard,

00:03:36.910 --> 00:03:40.170
you're going to see that there's
actually some ghosting of the keys

00:03:40.300 --> 00:03:43.600
where one key seems to be sort
of overlapping part of itself.

00:03:43.600 --> 00:03:46.560
And the reason that this looks
like this is because the keyboard

00:03:46.560 --> 00:03:49.590
actually only knows how to draw
itself in two different ways,

00:03:49.640 --> 00:03:50.440
landscape and portrait.

00:03:50.620 --> 00:03:52.490
And that's it.

00:03:52.500 --> 00:03:55.160
For all the intermediate
frames of this rotation,

00:03:55.220 --> 00:03:58.490
we're actually overlaying and
stretching the two images,

00:03:58.490 --> 00:04:01.590
the snapshots of the
landscape and portrait views,

00:04:01.590 --> 00:04:04.300
and then stretching them out at the
same time and cross baiting them.

00:04:04.500 --> 00:04:08.660
The effect about halfway through is
that you do see some of that ghosting,

00:04:08.660 --> 00:04:11.500
but it happens so fast
that to the user at speed,

00:04:11.500 --> 00:04:13.490
it really just looks like
it's a really smooth rotation.

00:04:13.500 --> 00:04:15.400
It's a flowing transition.

00:04:15.400 --> 00:04:17.870
And I just sometimes stand
here and watch this for like

00:04:17.870 --> 00:04:19.400
an hour and then fall asleep.

00:04:19.400 --> 00:04:21.290
But I think it's kind of fun.

00:04:21.400 --> 00:04:25.840
Now, there is a little bit more obvious
effect going on in the title bar there,

00:04:25.840 --> 00:04:27.270
in the navigation bar.

00:04:27.600 --> 00:04:30.600
You do sort of notice a little
bit more of the ghosting in the

00:04:30.600 --> 00:04:32.400
title of the navigation bar.

00:04:32.400 --> 00:04:36.400
But even at speed, users generally don't
really even notice that.

00:04:36.400 --> 00:04:38.940
In fact,
I would probably bet that most of you

00:04:38.940 --> 00:04:43.400
just watching this now had never even
imagined some of the stuff going on here.

00:04:43.400 --> 00:04:46.310
I really never even noticed.

00:04:49.800 --> 00:10:01.600
[Transcript missing]

00:10:01.740 --> 00:10:06.840
So let's take a look at how that
impacts values that would be set -- or,

00:10:06.840 --> 00:10:08.920
sorry,
how setting values on your layers and

00:10:08.920 --> 00:10:11.460
your views impacts these various trees.

00:10:11.570 --> 00:10:14.540
So let's look first at what happens
when you just call set frame on

00:10:14.550 --> 00:10:16.290
a view with no animation block.

00:10:16.460 --> 00:10:21.030
So let's assume that we've got some
views that start out with just a size.

00:10:21.380 --> 00:10:25.720
Let's say it started out with 25,
25 is the size of our view.

00:10:26.030 --> 00:10:30.740
And we call set frame on that view and
try to change its frame size to 50 by 50.

00:10:30.800 --> 00:10:34.130
Now, immediately when you call set frame,
the model value will be updated.

00:10:34.230 --> 00:10:38.480
So if we query back the value from
our view by calling view frame,

00:10:38.540 --> 00:10:41.880
we will find that it thinks
its size is 50 by 50.

00:10:41.950 --> 00:10:43.850
The render tree and
the presentation tree,

00:10:43.850 --> 00:10:45.640
though, have not been updated yet.

00:10:45.680 --> 00:10:48.680
Now, let's assume that we've done this
in response to some user action,

00:10:48.680 --> 00:10:51.000
like a button press or a tap.

00:10:51.050 --> 00:10:54.900
Once you finish processing that event,
UI kit and core animation will commit

00:10:54.900 --> 00:10:57.430
that change to the render server,
and then it will actually

00:10:57.440 --> 00:10:58.430
be able to be displayed.

00:10:58.440 --> 00:10:59.760
So everything you change as a result
of one user action will be displayed.

00:10:59.810 --> 00:11:06.020
So at the end of that event,
once it's processed,

00:11:06.430 --> 00:11:09.550
then the two other trees will be
updated to reflect the current state,

00:11:09.670 --> 00:11:11.580
because that will then
be displayed to the user.

00:11:11.700 --> 00:11:16.470
So that's sort of the progression when
you're dealing with a non-animated case.

00:11:16.590 --> 00:11:19.170
So let's look at what happens
in the case of animation.

00:11:19.280 --> 00:11:22.030
With the exact same thing,
we're going to assume that our view

00:11:22.030 --> 00:11:25.500
starts with a size of 25 by 25,
and we're going to call set frame to

00:11:25.500 --> 00:11:29.290
change it to have a size of 50/50,
but this time within an animation block.

00:11:29.430 --> 00:11:33.080
For example,
calling UIView animate with duration.

00:11:33.160 --> 00:11:35.670
And we'll assume that we're going
to do a two-second animation,

00:11:35.710 --> 00:11:38.270
just so that we have something
that we can talk through.

00:11:38.580 --> 00:11:42.360
So let's call animate with duration
and then call set frame in there.

00:11:42.510 --> 00:11:44.520
Again,
the model will update immediately because

00:11:44.520 --> 00:11:46.890
we're setting the value on our UI view.

00:11:47.010 --> 00:11:49.680
And when I'm talking about model here,
I mean, I know that's a little

00:11:49.750 --> 00:11:52.400
confusing because we have MVC,
the model view controller.

00:11:52.500 --> 00:11:54.390
That's not the kind of model
I'm talking about here.

00:11:54.400 --> 00:11:56.400
Here I mean a model layer.

00:11:56.400 --> 00:11:58.310
It's your UI view.

00:11:58.500 --> 00:12:01.400
So, yeah, we've called set frame on this.

00:12:01.400 --> 00:12:04.380
And so our size is now
50/50 in the model,

00:12:04.540 --> 00:12:08.400
but our presentation and render
trees are still 25 by 25.

00:12:08.490 --> 00:12:10.650
Now, at the end, again,
we're assuming we're doing

00:12:10.780 --> 00:12:12.400
this based on some user action.

00:12:12.400 --> 00:12:14.380
So the user action now finishes.

00:12:14.420 --> 00:12:15.390
We return to the run loop.

00:12:15.410 --> 00:12:17.810
At that point,
unlike in the previous case,

00:12:18.020 --> 00:12:21.400
our presentation and render
trees are still 25/25.

00:12:21.400 --> 00:12:24.400
We've committed the change,
but now this is an animated change.

00:12:24.400 --> 00:12:26.400
So we're right at the
beginning of the animation,

00:12:26.400 --> 00:12:29.400
and the user is still seeing
the old size of 25/25.

00:12:29.430 --> 00:12:32.400
And that's reflected in the
presentation and render trees.

00:12:32.400 --> 00:12:35.400
Now, let's say one second
later we check again.

00:12:35.400 --> 00:12:37.400
At that point,
our presentation tree will be reflecting

00:12:37.400 --> 00:12:38.400
what's currently being rendered.

00:12:38.400 --> 00:12:40.430
And if we display to
the user one second in,

00:12:40.430 --> 00:12:44.570
halfway through,
it will be about 37.5 by 37.5.

00:12:44.900 --> 00:12:46.790
And the same for the render tree.

00:12:46.880 --> 00:12:49.170
And then two seconds later,
once the animation has finished,

00:12:49.300 --> 00:12:52.260
since we had a two-second duration,
everything will be back in sync,

00:12:52.330 --> 00:12:56.290
and the sizes on all of these
different trees will be back to 50/50.

00:12:56.380 --> 00:13:01.210
So that's sort of a basic understanding,
hopefully, of how rendering on iOS works.

00:13:01.330 --> 00:13:05.130
And the reason that this is interesting
is because the first way that you will

00:13:05.130 --> 00:13:08.940
start building your rotation animations
is just by making changes inside

00:13:08.940 --> 00:13:12.240
of animation blocks and having them
animate from the beginning to the end.

00:13:12.350 --> 00:13:15.480
And so if you're trying to query
the state of these animations,

00:13:15.620 --> 00:13:18.870
you can do that by looking at the
presentation tree during your rotations.

00:13:18.990 --> 00:13:21.890
So now to get an idea of how we might
do some of this and some ways that

00:13:22.000 --> 00:13:25.340
we can improve performance during
some of these animated transitions,

00:13:25.460 --> 00:13:28.510
Andy's going to come up and
talk about rasterization.

00:13:31.000 --> 00:13:35.590
Thank you, Josh.

00:13:36.470 --> 00:13:39.470
You have animations happening,
and whenever you have

00:13:39.490 --> 00:13:43.000
complex animations happening,
complex graphics,

00:13:43.140 --> 00:13:46.610
the sad truth of the matter is that
you have to worry about performance.

00:13:46.710 --> 00:13:49.160
So this section of the talk is
going to be concerned a little

00:13:49.160 --> 00:13:53.330
bit more with making your
rotation animations performant,

00:13:53.330 --> 00:13:55.620
assuming that you already
have them performing the

00:13:55.690 --> 00:13:57.300
visual effect that you'd like.

00:13:57.680 --> 00:14:00.500
Say that you have a user interface
that looks a little bit like this.

00:14:00.610 --> 00:14:01.820
You got these three blocks.

00:14:01.910 --> 00:14:06.140
They're nested inside of each
other as a view hierarchy.

00:14:06.200 --> 00:14:08.410
When we go to render this,

00:14:08.720 --> 00:14:11.340
We're going to copy each of
these sequentially from the

00:14:11.360 --> 00:14:12.920
bottom up onto the screen.

00:14:13.060 --> 00:14:16.660
Orange, then green, then red.

00:14:17.540 --> 00:14:22.570
The tricky thing about this
situation is that this orange view

00:14:22.770 --> 00:14:24.900
is mostly covered by the green view.

00:14:24.960 --> 00:14:28.820
And so by copying the orange view
onto the screen and then immediately

00:14:28.820 --> 00:14:34.290
covering it mostly with the green view,
we're actually wasting a lot of time.

00:14:34.790 --> 00:14:38.340
Now, it's important that
we do this in general,

00:14:38.630 --> 00:14:42.130
copy each of them individually,
because they might be moving

00:14:42.130 --> 00:14:45.530
with respect to one another,
because sometimes the green

00:14:45.530 --> 00:14:49.600
view might be really small with
respect to the orange view.

00:14:49.700 --> 00:14:52.790
But you, the developer,
know a piece of information that

00:14:52.790 --> 00:14:55.170
the system can't necessarily know.

00:14:55.320 --> 00:15:00.380
Namely, you might know these are
going to stay fixed relative

00:15:00.380 --> 00:15:02.600
to one another for a while.

00:15:03.220 --> 00:15:05.900
And that's why we're talking about
this now with respect to rotation.

00:15:05.970 --> 00:15:09.090
It's that often during
rotation animations,

00:15:09.090 --> 00:15:12.190
you're able to say,
"Pieces of my interface,

00:15:12.220 --> 00:15:16.440
I can keep these static
while they rotate,

00:15:16.580 --> 00:15:20.410
or I can keep really tight control
over pieces of my interface

00:15:20.660 --> 00:15:23.660
while it's rotating because
I know that the user isn't able

00:15:23.660 --> 00:15:25.420
to interact with this application.

00:15:25.560 --> 00:15:28.440
I control the whole appearance."

00:15:28.630 --> 00:15:34.340
So there's this method you can call on
CAA layers called setShouldRasterize.

00:15:34.410 --> 00:15:38.300
And that causes Core Animation to
make what's called a rasterization.

00:15:38.450 --> 00:15:43.300
When it goes to render this thing,
it takes a snapshot of the entire

00:15:43.350 --> 00:15:49.290
view hierarchy under the layer
where you setShouldRasterize to yes.

00:15:49.580 --> 00:15:53.900
It keeps that copy around so
that when it goes to render,

00:15:53.950 --> 00:15:57.300
it can just copy that
whole thing back on screen.

00:15:57.730 --> 00:16:00.740
It doesn't have to do orange, then green,
then red.

00:16:00.770 --> 00:16:04.900
And for the next frame,
it can reuse that rasterization,

00:16:04.950 --> 00:16:06.970
which saves even more time.

00:16:07.630 --> 00:16:13.570
Now, if you have these views animating
with respect to each other like this,

00:16:14.230 --> 00:16:16.100
Then you get a somewhat different effect.

00:16:16.220 --> 00:16:19.940
Remember I was telling you that this
is useful because you know something.

00:16:19.940 --> 00:16:23.750
You know that these views are
static with respect to each other,

00:16:23.750 --> 00:16:27.210
and that allowed you to take
advantage of this rasterization

00:16:27.210 --> 00:16:28.860
technique where you can say,
"Hey,

00:16:28.990 --> 00:16:31.330
just treat this whole thing as one block.

00:16:31.490 --> 00:16:35.000
Take a snapshot of it effectively
and use that instead of dealing

00:16:35.000 --> 00:16:39.770
with the layers individually." Well,
so if you have an animation like

00:16:39.770 --> 00:16:44.360
this and you try to set should
rasterize yes on the orange view,

00:16:44.480 --> 00:16:48.590
then Core Animation will
make that rasterization,

00:16:48.730 --> 00:16:52.200
copy it on screen, but then for the next
frame of the animation,

00:16:52.200 --> 00:16:54.540
because that red block has
moved down a little bit,

00:16:54.790 --> 00:16:59.070
Core Animation will say, "Oh,
that rasterization that I have,

00:16:59.110 --> 00:17:00.600
it's not valid anymore.

00:17:00.630 --> 00:17:04.780
It's not an accurate representation of
the layer tree." So it'll throw it out.

00:17:04.920 --> 00:17:06.540
And then it'll make another one.

00:17:06.600 --> 00:17:08.700
And it'll copy that one on screen.

00:17:08.740 --> 00:17:12.260
And then for the next frame,
it'll have to throw that one out too.

00:17:12.260 --> 00:17:14.320
Every frame, creating one,
throwing it out,

00:17:14.380 --> 00:17:18.140
doing even more work than it was
doing before you tried to set

00:17:18.140 --> 00:17:21.140
should_rasterize onto the orange layer.

00:17:21.140 --> 00:17:23.450
So be careful where you set it.

00:17:25.930 --> 00:17:28.850
I told you that you might want to
set it during your rotations when

00:17:28.850 --> 00:17:32.720
you know that you have some part of
the view hierarchy that's fixed and

00:17:32.790 --> 00:17:34.900
you can use this optimization for.

00:17:34.900 --> 00:17:37.420
So you might say, okay,
in will animate rotation

00:17:37.420 --> 00:17:41.390
to interface orientation,
I'm going to set should rasterize yes

00:17:41.660 --> 00:17:44.450
on this particular view hierarchy.

00:17:45.560 --> 00:17:51.030
I encourage you to be very careful doing
this because you will want to disable

00:17:51.250 --> 00:17:57.350
rasterization after the rotation finishes
so that once your user is able to once

00:17:57.440 --> 00:18:02.160
again interact with your interface,
thus presumably changing

00:18:02.160 --> 00:18:06.130
around the way that it looks,
you don't want to inadvertently

00:18:06.420 --> 00:18:09.890
have that problem I was just showing
you where core animation has to

00:18:09.900 --> 00:18:14.160
repeatedly create these rasterizations
and then just throw them out.

00:18:14.270 --> 00:18:17.890
So turn it on and then at the
end of the rotation animation,

00:18:17.950 --> 00:18:19.410
turn it off again.

00:18:20.950 --> 00:18:24.120
If you have a rotation
that looks like this,

00:18:24.120 --> 00:18:27.800
unfortunately what that means is that
rasterization is of no use to you.

00:18:27.850 --> 00:18:30.190
But hopefully we'll be able to
talk about some other things in

00:18:30.190 --> 00:18:33.310
this presentation that will be.

00:18:34.220 --> 00:18:36.880
There's one other interesting
issue with rasterization

00:18:36.900 --> 00:18:39.700
that you need to be aware of,
and that's if we're taking a snapshot

00:18:39.700 --> 00:18:43.600
or something like a snapshot,
at what scale,

00:18:43.600 --> 00:18:46.640
at what resolution should we take it?

00:18:47.240 --> 00:18:49.500
It's really kind of usage dependent.

00:18:49.500 --> 00:18:52.210
So if we have a label like this one,

00:18:52.730 --> 00:18:55.030
And say it's 75 points high.

00:18:55.100 --> 00:18:59.960
Well, if you're an LLDB and you ask
this label how high it is,

00:18:59.960 --> 00:19:01.660
it doesn't say, oh, I'm 75 points high.

00:19:01.660 --> 00:19:03.540
It says, I'm 75 high.

00:19:03.540 --> 00:19:05.980
It's kind of not that clever.

00:19:05.980 --> 00:19:07.490
It doesn't know the unit.

00:19:07.550 --> 00:19:11.490
And so when you ask this layer
to create a rasterization,

00:19:11.490 --> 00:19:14.700
it creates a 75-pixel rasterization.

00:19:14.750 --> 00:19:19.120
And critically,
it does so even on a retina device.

00:19:19.980 --> 00:19:22.400
What that means is that
on a retina device,

00:19:22.400 --> 00:19:25.310
when you blow it up,
it's going to have jaggies.

00:19:25.340 --> 00:19:27.180
We don't like jaggies.

00:19:29.220 --> 00:19:34.680
There's a method you can call called
setRasterizationScale that specifies to

00:19:34.680 --> 00:19:40.290
CoreAnimation at what resolution would
you like this rasterization to be made.

00:19:40.520 --> 00:19:44.450
Generally for UIKit applications,
it makes sense to use the main screen

00:19:44.450 --> 00:19:49.030
scale or the views windows screens scale.

00:19:49.250 --> 00:19:52.870
So if you do that,
then it'll actually create 150

00:19:52.870 --> 00:19:57.440
pixel tall rasterization rather
than a 75 pixel tall rasterization.

00:19:57.610 --> 00:20:01.700
And then the jaggy situation
is substantially improved.

00:20:03.550 --> 00:20:06.880
there are some memory
implications as well.

00:20:06.920 --> 00:20:10.260
We're talking about making
a cache effectively,

00:20:10.340 --> 00:20:14.740
and as with all caches,
they have memory implications.

00:20:14.840 --> 00:20:18.380
So if you have a user interface
that looks a little bit like this,

00:20:18.920 --> 00:20:23.440
where you have an image view and
then a sub view that's a label,

00:20:23.440 --> 00:20:26.670
you certainly need to have
space to store that image.

00:20:26.670 --> 00:20:28.720
It's a UI image of the Coliseum.

00:20:28.720 --> 00:20:32.480
Maybe you loaded it from disk,
maybe you downloaded it.

00:20:32.650 --> 00:20:36.460
However, it's stored in memory.

00:20:36.460 --> 00:20:40.330
But if you set should rasterize
on the parent of the UI image

00:20:40.330 --> 00:20:43.340
view and the UI label,
then you should be aware

00:20:43.740 --> 00:20:47.460
that you also have the memory
cost of that rasterization,

00:20:47.470 --> 00:20:54.310
which in some cases may be
as large as the image itself.

00:20:56.450 --> 00:21:02.280
Now that we've talked about using this
snapshot-like tool for performance,

00:21:02.400 --> 00:21:05.400
Let me talk about using
snapshots for snapshots' sake,

00:21:05.400 --> 00:21:08.390
because they're actually really cool,
and they're generally useful

00:21:08.780 --> 00:21:11.650
in rotation animations,
especially for the kind of

00:21:11.650 --> 00:21:14.900
slate of hand tricks we're
going to be showing you later.

00:21:15.010 --> 00:21:22.070
If you have an interface like this,
when it rotates, watch the red square.

00:21:24.180 --> 00:21:29.100
Do you see how it actually appears
on screen in two places at once?

00:21:29.220 --> 00:21:34.400
In order to do that, we basically need to
have one view duplicated.

00:21:34.530 --> 00:21:38.400
But unfortunately,
UIView doesn't conform to NSCopying.

00:21:38.520 --> 00:21:41.100
And even if it did,
that might not be a very effective

00:21:41.100 --> 00:21:45.360
way to achieve this result,
because maybe your views point

00:21:45.360 --> 00:21:49.100
to a particular data source
that would be very confused if

00:21:49.100 --> 00:21:50.360
it got queried twice as often.

00:21:50.430 --> 00:21:52.700
It's not prepared for that.

00:21:52.800 --> 00:21:55.040
Or maybe it's just very complex.

00:21:55.170 --> 00:21:58.720
So I propose that in many cases,
it's more convenient to simply

00:21:58.720 --> 00:22:02.880
take a snapshot of the red
view to achieve this result.

00:22:03.170 --> 00:22:05.200
And you can do this with a piece of API.

00:22:05.270 --> 00:22:11.240
If you have a layer like this red view,
you can send it render in context

00:22:11.350 --> 00:22:15.740
to have it draw into a CG context.

00:22:15.850 --> 00:22:19.050
You can create a CG context
into which it might draw using

00:22:19.050 --> 00:22:21.030
these UI graphics functions.

00:22:21.140 --> 00:22:25.300
UI graphics begin image
context with options.

00:22:25.780 --> 00:22:29.820
Note that here the scale
is yet again relevant.

00:22:30.060 --> 00:22:34.640
Here we're using zero for the third
argument to begin image context,

00:22:34.790 --> 00:22:39.770
and that indicates to the system
that the image created should be

00:22:39.770 --> 00:22:42.720
at the scale of the main screen.

00:22:42.730 --> 00:22:44.610
In this case,
on a high-resolution device,

00:22:44.710 --> 00:22:48.760
that would be 2x, and that's what we want
to avoid those jaggies.

00:22:48.800 --> 00:22:53.050
So now we have an image,
and we can manipulate it as such.

00:22:54.090 --> 00:22:56.790
There is the question, however,
of what exactly are

00:22:56.790 --> 00:23:01.020
we taking an image of,
particularly when we have an animation?

00:23:01.130 --> 00:23:04.240
So if we take a snapshot
while that red box is moving,

00:23:04.320 --> 00:23:08.940
what happens will depend upon whether
we're taking the snapshot of the model

00:23:08.940 --> 00:23:12.460
tree or of the presentation tree.

00:23:12.520 --> 00:23:16.140
As Josh mentioned earlier, the model tree

00:23:16.280 --> 00:23:21.300
Always contains the final values,
and the model tree is the one that

00:23:21.300 --> 00:23:25.960
your layers actually refer to,
your UIViews layers.

00:23:26.120 --> 00:23:31.680
So if you just send rendering
context to the orange layer directly,

00:23:31.680 --> 00:23:37.040
then what you'll get is a snapshot
of it at the end of its animation,

00:23:37.130 --> 00:23:41.090
no matter where in the course of
its animation you take the snapshot.

00:23:41.760 --> 00:23:45.330
That may be what you want,
but it may be more expedient for

00:23:45.410 --> 00:23:49.440
you to send rendering context
to the presentation layer,

00:23:49.440 --> 00:23:53.420
and that way you'll get
a snapshot mid-flight,

00:23:53.420 --> 00:24:01.530
because the presentation tree always
contains at least an approximation

00:24:01.530 --> 00:24:01.530
of what the user is seeing on screen.

00:24:02.410 --> 00:24:05.180
There are some performance
characteristics that

00:24:05.180 --> 00:24:06.650
you should be aware of.

00:24:06.810 --> 00:24:10.500
Although rasterizations and snapshots
sound like mostly the same thing,

00:24:10.500 --> 00:24:14.030
they're both snapshotty,
the way that they work,

00:24:14.030 --> 00:24:17.330
technically speaking,
are somewhat distinct.

00:24:18.030 --> 00:24:22.220
Critically, rasterizations are performed
by the render server.

00:24:22.330 --> 00:24:24.810
You say, "Hey,
I want this layer to be rasterized.

00:24:24.890 --> 00:24:27.720
I want you to effectively take
a snapshot of it and use that

00:24:28.010 --> 00:24:31.660
instead of dealing with the layers
individually." The render server,

00:24:31.660 --> 00:24:33.700
when it renders, does that.

00:24:33.850 --> 00:24:35.750
So that's not happening in your process.

00:24:36.040 --> 00:24:39.600
It's not blocking the flow
of application events.

00:24:39.740 --> 00:24:42.310
Sometimes that can be useful,
but it could also mean that you're

00:24:42.310 --> 00:24:43.690
now blocking the render server.

00:24:43.800 --> 00:24:46.600
So it's an interesting
thing to be aware of.

00:24:46.700 --> 00:24:49.350
The render server, though,
knows how to use the GPU.

00:24:49.460 --> 00:24:51.380
That's valuable.

00:24:51.500 --> 00:24:54.890
When you do it within
your own application,

00:24:55.250 --> 00:24:58.890
when you take a snapshot,
you're going to be using the CPU.

00:24:59.000 --> 00:25:03.150
So you say, "Layer Rendering
Context," and that thread,

00:25:03.150 --> 00:25:06.370
the one where you say "Rendering
Context," which incidentally,

00:25:06.370 --> 00:25:08.770
if you're sending that
message to a UI views layer,

00:25:08.770 --> 00:25:12.250
had better be the main thread,
is going to be blocked until

00:25:12.250 --> 00:25:16.460
that rendering is complete,
which could be quite a while,

00:25:16.710 --> 00:25:18.500
especially on a new iPad.

00:25:18.620 --> 00:25:22.740
On a new iPad, snapshots of the entire
screen are 10 megabytes,

00:25:22.890 --> 00:25:26.610
so consider even the cost of just
copying 10 megabytes of data around,

00:25:26.800 --> 00:25:30.020
let alone the fact that those
10 megabytes of data come from

00:25:30.100 --> 00:25:32.410
a detailed rendering process.

00:25:32.510 --> 00:25:35.730
There are costs associated
with these snapshots.

00:25:35.950 --> 00:25:37.690
But if you're aware of
these characteristics,

00:25:37.830 --> 00:25:41.110
between your knowledge and
your usage of instruments,

00:25:41.110 --> 00:25:43.730
you should be able to figure
out the best thing to do.

00:25:44.140 --> 00:25:47.700
Now that you know how to take snapshots
and how to make your rotations a little

00:25:47.820 --> 00:25:51.150
faster with snapshotty-like techniques,
Josh is going to show you how

00:25:51.150 --> 00:25:53.100
to make them look even better.

00:25:53.370 --> 00:25:57.280
Thanks.

00:26:00.000 --> 00:29:36.800
[Transcript missing]

00:29:37.360 --> 00:29:41.440
And in fact, that's exactly what the
mail application does.

00:29:41.440 --> 00:29:44.480
So if we take a look again,
I've slowed this down so that you can

00:29:44.480 --> 00:29:46.840
fall asleep here in the next few minutes.

00:29:46.840 --> 00:29:49.330
If you watch the right-hand
side that we had marked in red,

00:29:49.510 --> 00:29:53.040
you're going to see that that part
where the labels are actually stretch

00:29:53.040 --> 00:29:56.340
and fade out a little bit during the
rotation from landscape to portrait,

00:29:56.470 --> 00:29:57.440
and the opposite happens.

00:29:57.440 --> 00:30:00.800
It fades in on the rotation
from portrait to landscape.

00:30:00.940 --> 00:30:04.090
The parts on the left are cross-fading,
but the only part on the left that we

00:30:04.170 --> 00:30:07.800
can even notice that there's a cross-fade
at all is the second line of text,

00:30:07.830 --> 00:30:09.240
because everything
else remains identical.

00:30:09.240 --> 00:30:11.300
Nothing's changing there.

00:30:11.300 --> 00:30:15.630
You do kind of notice a little bit
at the bottom on where the text crops

00:30:15.740 --> 00:30:18.090
a little bit right at the beginning,
but again,

00:30:18.090 --> 00:30:22.330
this is happening so fast that users
mostly just never even notice this.

00:30:22.590 --> 00:30:24.650
Hopefully, this is something new to you.

00:30:24.810 --> 00:30:26.310
If you've noticed it,
then maybe it's not worked

00:30:26.390 --> 00:30:31.930
as well as I was hoping,
but... Anyway, so we've avoided basically

00:30:32.220 --> 00:30:34.890
having to redraw a lot of stuff,
and we've fixed a problem that

00:30:34.900 --> 00:30:37.900
wouldn't even be possible to
fix without snapshotting in any

00:30:37.900 --> 00:30:41.210
really high-performance way,
because we can't draw every

00:30:41.570 --> 00:30:43.180
frame of the text rewrapping.

00:30:43.540 --> 00:30:45.760
That would be really expensive,
to rewrap the text at every

00:30:45.770 --> 00:30:48.140
frame of that animation.

00:30:48.140 --> 00:30:52.260
So, yeah, this entire animation really in
the middle is just two snapshots

00:30:52.430 --> 00:30:56.140
cross-fading and stretching that
part that we had highlighted in red.

00:30:56.280 --> 00:30:59.820
So what we're going to do next is
write a little sample application

00:30:59.820 --> 00:31:02.280
that does basically exactly that.

00:31:02.280 --> 00:31:04.420
And it's going to look a little
bit like this with slightly

00:31:04.460 --> 00:31:05.950
less interesting content.

00:31:06.020 --> 00:31:08.960
So we've got, again, just two views,
our landscape and portrait,

00:31:09.060 --> 00:31:11.170
and it's basically the same
layout as the Mail app.

00:31:11.290 --> 00:31:14.070
We've got a bunch of rows of text,
and we've got, you know,

00:31:14.200 --> 00:31:16.590
navigation bar and tool bar.

00:31:17.230 --> 00:31:19.940
We're going to do that same thing
because we've got the area on the

00:31:19.940 --> 00:31:21.800
left that will remain the same,
the area on the right

00:31:21.860 --> 00:31:24.940
that will remain the same,
and the area that we're going to stretch.

00:31:25.030 --> 00:31:27.500
We actually, as I mentioned,
are going to take two snapshots.

00:31:27.500 --> 00:31:30.060
So we're going to also take a
snapshot of the portrait view,

00:31:30.100 --> 00:31:32.330
and we're going to stretch
that in much the same way.

00:31:32.500 --> 00:31:34.550
But because that's actually
the full width of the thing

00:31:34.550 --> 00:31:36.980
we're trying to stretch to,
we need to find some part

00:31:36.980 --> 00:31:38.300
of it that we can stretch.

00:31:38.380 --> 00:31:42.440
And I'm not sure how visible it is there,
but there's a red line just to the

00:31:42.610 --> 00:31:46.950
right of that portrait snapshot,
just to the left of the chevrons.

00:31:47.050 --> 00:31:50.380
Which is really -- basically we
can find one pixel there that's

00:31:50.440 --> 00:31:54.560
pretty much all white except for the
separator rows that we could stretch

00:31:54.840 --> 00:31:57.520
out as we expand this horizontally.

00:31:57.620 --> 00:31:59.940
And the user would never really
notice that because it's all white,

00:31:59.940 --> 00:32:01.700
so it's just going to
fill some empty space.

00:32:01.810 --> 00:32:06.210
And we'll be cross-fading it with the
landscape one simultaneously anyway.

00:32:06.320 --> 00:32:08.370
So let's take a look and
just focus on that because,

00:32:08.370 --> 00:32:11.620
again, as in the other case,
we don't have to worry about the toolbar

00:32:11.620 --> 00:32:14.100
or the tab bar or the navigation bar.

00:32:14.100 --> 00:32:16.070
So we're really just focusing
on this part of the content,

00:32:16.130 --> 00:32:16.760
the table view.

00:32:16.890 --> 00:32:20.260
And, again, if we did nothing,
we would end up with something like

00:32:20.260 --> 00:32:24.000
what we saw would have happened in Mail,
where at the beginning of that animation,

00:32:24.000 --> 00:32:25.820
it would just snap to its new appearance.

00:32:25.820 --> 00:32:27.890
And that's definitely not
what we want because we'd see

00:32:27.890 --> 00:32:29.050
that big open white space.

00:32:29.080 --> 00:32:31.720
And then, again,
if we hadn't done something,

00:32:31.810 --> 00:32:34.990
we would see it animate towards
the portrait view in somewhat

00:32:35.200 --> 00:32:36.790
of a way kind of like this.

00:32:37.140 --> 00:32:39.810
Just doesn't look very good.

00:32:39.820 --> 00:32:41.950
And then on the way back,
it would actually be slightly worse.

00:32:41.990 --> 00:32:44.870
It would redraw itself and then be
clipping off on the right as it sort

00:32:44.870 --> 00:32:46.680
of comes out from under the chevrons.

00:32:46.820 --> 00:32:50.570
It's a very strange effect and
definitely not the best we could do.

00:32:50.680 --> 00:32:53.250
So instead, we'll do those two snapshots,
and we're going to crossfade

00:32:53.250 --> 00:32:55.660
and rotate them -- or,
sorry, crossfade and stretch them.

00:32:55.790 --> 00:32:58.790
And it will look instead
something like this.

00:33:01.860 --> 00:33:04.720
So the right side with the
chevrons is just sort of sliding

00:33:04.750 --> 00:33:08.400
in towards the other side,
and the left side is minimally changing.

00:33:08.400 --> 00:33:11.150
We just got crossfade of
the bottom lines of text,

00:33:11.150 --> 00:33:14.170
and there's a little bit of stretching
happening there on the right side.

00:33:14.360 --> 00:33:17.810
But for the most part,
most of the content is remaining

00:33:17.820 --> 00:33:19.900
pretty much still in place.

00:33:20.470 --> 00:33:22.750
And when we do this at speed,
users pretty much won't have any

00:33:22.750 --> 00:33:25.170
ability to tell that there's anything
happening here other than what

00:33:25.170 --> 00:33:28.030
they may actually have convinced
themselves is really supposed to

00:33:28.120 --> 00:33:30.000
be the correct rotation animation.

00:33:30.080 --> 00:33:32.650
So let's build that.

00:33:33.500 --> 00:36:50.700
[Transcript missing]

00:36:50.740 --> 00:36:53.650
Now, before we actually get into
implementing the rotation itself,

00:36:53.650 --> 00:36:57.620
let's create a helper method,
actually a helper static function,

00:36:57.620 --> 00:37:01.150
that will take a snapshot of an
arbitrary view for us using the technique

00:37:01.220 --> 00:37:03.020
that Andy showed us a minute ago.

00:37:03.080 --> 00:37:04.860
So I'll call it captureSnapshotOfView.

00:37:04.880 --> 00:37:07.030
It's going to take a UIView
of which we'd like a snapshot

00:37:07.140 --> 00:37:10.460
and return a UIImageView that
represents the content of that view.

00:37:10.500 --> 00:37:12.260
Now, we'll do exactly what
Andy showed us in the slides.

00:37:12.360 --> 00:37:15.210
And we're going to call
UIGraphicsBeginImageContextWithOptions

00:37:15.550 --> 00:37:18.520
and pass in the bound size
of the view we want to snapshot.

00:37:18.590 --> 00:37:21.800
We'll pass yes for the opaque because
our table view is fully opaque,

00:37:21.800 --> 00:37:24.920
so we don't need an alpha layer here.

00:37:25.300 --> 00:37:27.680
And finally,
we're going to pass zero for our scale

00:37:27.740 --> 00:37:31.100
so that we'll get a high-resolution
rendering when we're on a retina device.

00:37:31.160 --> 00:37:34.280
And then we're just going
to tell the target view,

00:37:34.440 --> 00:37:38.230
tell its layer to render in
context into the current graphics

00:37:38.240 --> 00:37:39.830
context that we just started.

00:37:39.950 --> 00:37:42.590
Just like Andy showed,
we'll get an image out of it using

00:37:42.590 --> 00:37:46.320
UIGraphicsGetImageFromCurrentContext
and then end that context.

00:37:46.380 --> 00:37:48.560
Then we'll create our
UIImageView to represent this.

00:37:48.560 --> 00:37:51.020
So we're going to allocate
a new UIImageView with

00:37:51.020 --> 00:37:52.540
that image we just created.

00:37:52.660 --> 00:37:55.200
We're going to set its frame to
match the frame of the target view

00:37:55.210 --> 00:37:56.560
that we're trying to snapshot.

00:37:56.650 --> 00:37:59.300
And then we can return
it from this function.

00:37:59.370 --> 00:38:01.060
All right,
so that's going to be used so that we

00:38:01.060 --> 00:38:02.590
can get our before and after snapshots.

00:38:02.810 --> 00:38:05.560
It was helpful to factor it out
since we're going to call it twice.

00:38:05.630 --> 00:38:07.540
So now we can actually begin
implementing the snapshotting.

00:38:07.660 --> 00:38:11.900
So in willRotateToInterfaceOrientation
is where we want to capture

00:38:12.020 --> 00:38:13.530
our before snapshot.

00:38:13.760 --> 00:38:17.760
And we want to do this here because
in willRotateToInterfaceOrientation,

00:38:17.840 --> 00:38:21.600
we're called before any of the changes
for the rotation have been applied.

00:38:21.770 --> 00:38:24.870
So all the views are still in their
state for the previous orientation,

00:38:24.870 --> 00:38:26.560
and nothing has been resized yet.

00:38:26.670 --> 00:38:29.760
So that means that we can capture
our table view's original frame,

00:38:29.760 --> 00:38:32.360
the frame before rotation,
by just getting it here.

00:38:32.490 --> 00:38:35.580
We can capture the initial
snapshot by calling our function

00:38:35.580 --> 00:38:37.200
captureSnapshotOfView here.

00:38:37.550 --> 00:38:41.020
That will give us the
snapshot and frame before.

00:38:41.230 --> 00:38:43.850
And then we just need to add that
snapshot into our view hierarchy

00:38:44.020 --> 00:38:45.460
to get ready for this rotation.

00:38:45.590 --> 00:38:46.960
So we're going to insert
it above the table view.

00:38:46.960 --> 00:38:48.960
Because we want it to be on top.

00:38:48.960 --> 00:38:51.080
So snapshot before rotation
that we just created,

00:38:51.080 --> 00:38:53.870
insert into the view hierarchy
above the table view.

00:38:53.960 --> 00:38:56.960
Now that we've got that,
we can actually go ahead

00:38:56.960 --> 00:39:00.960
and start implementing the
frames after the rotation.

00:39:00.960 --> 00:39:04.960
So in
willAnimateRotationToInterfaceOrientation

00:39:04.960 --> 00:39:06.340
,
all of the views in your

00:39:06.340 --> 00:39:09.960
hierarchy have already been
resized for the new orientation.

00:39:09.960 --> 00:39:11.960
And the status bar orientation
has already been updated.

00:39:11.960 --> 00:39:16.150
So everything is now in its final
state as far as the model is concerned.

00:39:16.160 --> 00:39:20.970
So we can go ahead and capture
our table view's frame after

00:39:20.970 --> 00:39:25.900
the rotation by looking at
willAnimateRotationToInterfaceOrientation

00:39:26.160 --> 00:39:26.160
.

00:39:26.180 --> 00:39:29.210
So we'll get the table view's
frame here and save that into

00:39:29.270 --> 00:39:31.160
our frame after rotation Ivar.

00:39:31.160 --> 00:39:34.110
Now we're going to do some setup here
that we don't want to have animated.

00:39:34.300 --> 00:39:37.470
But willAnimateRotationToInterfaceOrient
ation is called from

00:39:37.530 --> 00:39:39.130
within an animation block.

00:39:39.210 --> 00:39:43.060
The one that UIKit set up to actually
resize all our views during rotation.

00:39:43.250 --> 00:39:45.360
So we just want to temporarily
disable animations.

00:39:45.360 --> 00:39:47.480
By setting animations enabled to no.

00:39:47.560 --> 00:39:50.560
Once we've done that,
we can actually take our snapshot.

00:39:50.610 --> 00:39:53.460
Again, calling the same capture snapshot
a view method on our table view.

00:39:53.630 --> 00:39:55.560
And that's our after snapshot.

00:39:55.560 --> 00:39:57.560
Now we're not going to insert it
into the view hierarchy just yet.

00:39:57.560 --> 00:39:59.560
We'll get to that in a minute.

00:39:59.560 --> 00:40:02.070
But what we do want to do is
resize it horizontally so that

00:40:02.070 --> 00:40:06.550
it has the same width as the
initial view did at the beginning.

00:40:06.730 --> 00:40:09.430
And I've actually written
a helper method for that.

00:40:09.560 --> 00:40:12.350
So we're going to call
setFramePreservingHeight.

00:40:12.560 --> 00:40:14.550
Passing in the frame before rotation.

00:40:14.560 --> 00:40:16.760
Now this is basically
identical to setFrame.

00:40:16.760 --> 00:40:20.760
With the only exception being that it
doesn't change the height of our view.

00:40:20.760 --> 00:40:22.760
We don't want to stretch
these snapshots vertically.

00:40:22.760 --> 00:40:24.760
So we want to make sure not
to resize them vertically.

00:40:24.760 --> 00:40:27.760
So this will set the origin
and will set the width.

00:40:27.980 --> 00:40:29.960
But will not set the height.

00:40:30.200 --> 00:40:31.940
So we've got our snapshot now.

00:40:31.940 --> 00:40:33.620
It's our right size.

00:40:33.640 --> 00:40:36.330
It's the after snapshot,
but stretched horizontally

00:40:36.380 --> 00:40:39.020
down to land on top of the
size of the initial snapshot.

00:40:39.020 --> 00:40:42.880
So they're now layered on top of each
other on the left side of our view.

00:40:42.880 --> 00:40:46.540
So next we need to figure out which
parts of our snapshots we want

00:40:46.600 --> 00:40:48.660
to stretch during this rotation.

00:40:48.700 --> 00:40:51.560
And if you recall,
we wanted to do something like this.

00:40:51.560 --> 00:40:55.690
We want the right side here to
not stretch and the left side in

00:40:55.800 --> 00:40:58.130
green over here to not stretch.

00:40:58.260 --> 00:40:59.580
And the same thing in our portrait.

00:40:59.580 --> 00:41:01.920
The right side over here should
not stretch and the left side

00:41:01.920 --> 00:41:03.060
there should not stretch.

00:41:03.060 --> 00:41:05.830
We will allow stretching in
this red part here and on the

00:41:05.830 --> 00:41:07.610
single point width thing here.

00:41:09.050 --> 00:41:13.020
So I've actually written
a little helper method to

00:41:13.020 --> 00:41:14.930
calculate those two side things.

00:41:15.010 --> 00:41:17.830
It's just a little bit of math,
and it's not especially interesting

00:41:17.920 --> 00:41:21.020
here only because the way that you'll
decide which parts of your content can

00:41:21.020 --> 00:41:24.180
be stretched and which ones can't will
vary based on what kind of content you're

00:41:24.180 --> 00:41:25.920
talking about in your own applications.

00:41:26.340 --> 00:41:29.150
So for the purposes of the demo,
I have a quick thing that will

00:41:29.150 --> 00:41:30.820
calculate edge insets for us.

00:41:30.950 --> 00:41:35.260
So UI edge insets represents top, left,
bottom, and right inset.

00:41:35.260 --> 00:41:38.630
And so I've got a method here that
just calculates those green insets,

00:41:38.710 --> 00:41:40.100
the left and right ones.

00:41:40.150 --> 00:41:44.700
Now, the interesting part is that it
will basically always be in sum

00:41:44.700 --> 00:41:47.080
the image with the smaller width.

00:41:47.340 --> 00:41:48.420
So we have two images.

00:41:48.420 --> 00:41:52.160
We have the final and the start
with landscape and portrait.

00:41:52.210 --> 00:41:56.590
Whichever one is smaller is the one that
we're basically going to have be the

00:41:56.590 --> 00:41:58.900
total sum of our left and right insets.

00:41:58.900 --> 00:42:00.320
Because, you know,
the green here basically

00:42:00.320 --> 00:42:00.850
adds up to the full image.

00:42:00.940 --> 00:42:02.860
So we're going to have the
full width of portrait.

00:42:02.860 --> 00:42:05.820
So anyway, we've now got our UI edge
insets representing the areas

00:42:05.820 --> 00:42:07.360
that we don't want to stretch.

00:42:07.360 --> 00:42:09.360
So now that we know what
we don't want to stretch,

00:42:09.360 --> 00:42:11.720
we want to modify the
UI images that we captured,

00:42:11.760 --> 00:42:14.860
the snapshots, to indicate which parts
should be stretchable.

00:42:14.860 --> 00:42:18.700
So we're going to get our images out
of those two UI image views by calling

00:42:18.710 --> 00:42:20.860
image on the UI image views that we have.

00:42:20.860 --> 00:42:23.950
And we're going to create
stretchable images out of those

00:42:23.960 --> 00:42:25.760
two UI images that we have here.

00:42:25.860 --> 00:42:28.410
Now,
I'm using a new method being introduced

00:42:28.420 --> 00:42:30.860
in iOS 6 here to do this called resizing.

00:42:30.860 --> 00:42:34.800
So we're going to create a resizable
image with cap insets resizing mode.

00:42:34.920 --> 00:42:39.860
The only catch right now is that
this is not in seed 1 that you have.

00:42:39.870 --> 00:42:43.570
So I've used it here because it's
actually quite a bit easier to

00:42:43.570 --> 00:42:45.850
do stretching using this method.

00:42:45.870 --> 00:42:48.220
There are other ways that you
could do this stretching on

00:42:48.220 --> 00:42:49.800
your own using other mechanisms.

00:42:49.940 --> 00:42:52.780
But for simplicity's sake here,
we're going to use this.

00:42:52.920 --> 00:42:54.850
And you will have it at some point.

00:42:55.050 --> 00:42:57.640
But in the meantime, yes,
we've created a resizable

00:42:57.700 --> 00:42:59.860
image with cap insets with that
unstretched area that we calculated.

00:43:00.880 --> 00:43:03.860
With the resizing mode being
UI resizing mode stretch.

00:43:04.040 --> 00:43:06.860
Now, that's the new part in this
API is the resizing mode.

00:43:06.890 --> 00:43:10.100
The default, if you didn't pass that or
if you used the existing

00:43:10.100 --> 00:43:12.860
resizable image with cap insets,
is to tile, not to stretch.

00:43:12.860 --> 00:43:16.750
So we wouldn't end up getting
it stretched the way we'd like.

00:43:16.970 --> 00:43:18.430
And anyway,
now that we've got our images created

00:43:18.430 --> 00:43:21.320
with the correct stretchable regions,
we can just set them back

00:43:21.320 --> 00:43:22.860
on that UI image view.

00:43:22.860 --> 00:43:24.860
We've got our snapshot before and after.

00:43:24.860 --> 00:43:26.980
Set the image back on there.

00:43:27.310 --> 00:43:30.540
So next we have two things
left that we want to do.

00:43:30.540 --> 00:43:33.580
We've got things set up so that we
have the images created and they're

00:43:33.580 --> 00:43:36.150
set to stretch in the right ways,
but now we need to actually

00:43:36.240 --> 00:43:37.200
set up the animations.

00:43:37.350 --> 00:43:42.160
We want to crossfade the two views and
we want to stretch them horizontally.

00:43:42.250 --> 00:43:44.010
So for crossfading,
we always want to fade

00:43:44.010 --> 00:43:45.200
the one that is shorter.

00:43:45.200 --> 00:43:47.760
The reason that we want to fade
the shorter one is because if

00:43:47.760 --> 00:43:50.940
we were to fade the taller one,
you'd end up seeing at the bottom an

00:43:50.940 --> 00:43:54.200
area where it became translucent and you
could see through to what's behind it.

00:43:54.200 --> 00:43:57.790
If we always fade the shorter of the two,
you'll only ever see the

00:43:57.790 --> 00:43:59.200
taller one behind it.

00:43:59.200 --> 00:44:04.380
So it preserves the illusion that
we're actually rotating real stuff.

00:44:04.600 --> 00:44:06.990
So in order to do that,
we have to pick the shorter image.

00:44:07.010 --> 00:44:09.700
So we've got our two images,
image after and image before.

00:44:09.870 --> 00:44:12.740
We'll check their sizes and
figure out which one's shorter.

00:44:12.740 --> 00:44:15.230
Assuming that the image
after rotation is shorter,

00:44:15.390 --> 00:44:20.010
we want to put the image after rotation
-- this is what we're rotating to -- on

00:44:20.010 --> 00:44:22.940
top of the image before and fade it in.

00:44:23.060 --> 00:44:25.600
So we're going to have the
image before as what's visible,

00:44:25.600 --> 00:44:27.360
we're going to have
the image after on top,

00:44:27.480 --> 00:44:29.640
and we'll fade it in
on top while we rotate.

00:44:29.740 --> 00:44:31.640
So to do that,
we have to start with it faded out,

00:44:31.640 --> 00:44:33.900
so we're going to set its alpha to zero.

00:44:34.020 --> 00:44:36.240
Then we're going to insert it
on top of the image before,

00:44:36.350 --> 00:44:39.900
so insert subview image after,
above subview image before,

00:44:39.900 --> 00:44:42.530
so we've got the after
one we're going to on top.

00:44:42.650 --> 00:44:45.700
And then we want to fade it in,
so we'll set its alpha to one.

00:44:45.810 --> 00:44:50.160
Now, if the image before rotation,
our initial image, were the shorter one,

00:44:50.280 --> 00:44:53.100
what we'd actually want
to do then is fade it out.

00:44:53.200 --> 00:44:55.690
We want it to start visible
and then start disappearing.

00:44:55.850 --> 00:44:58.800
So for that to work,
we have to put the final snapshot,

00:44:58.800 --> 00:45:00.660
our image after, underneath it.

00:45:00.750 --> 00:45:02.620
So we're going to insert
it into our view hierarchy,

00:45:02.860 --> 00:45:06.140
insert snapshot after,
below subview snapshot before.

00:45:06.190 --> 00:45:08.760
This is why we didn't insert this
when we first created the snapshot,

00:45:08.820 --> 00:45:11.810
because depending on which one's shorter,
we want one on top of

00:45:11.810 --> 00:45:13.460
the other or vice versa.

00:45:13.720 --> 00:45:16.000
Now, of course,
we want to fade out the image before,

00:45:16.000 --> 00:45:18.800
because it's on top right now,
so we'll set its alpha to zero,

00:45:18.850 --> 00:45:22.370
which will fade it out and cause
us to see the final version about

00:45:22.370 --> 00:45:23.870
halfway through our rotation.

00:45:23.980 --> 00:45:24.840
So that's it for fading.

00:45:24.980 --> 00:45:27.640
The last thing we have to do
is stretch them horizontally.

00:45:27.680 --> 00:45:29.390
Right now,
they're both positioned right on top of

00:45:29.390 --> 00:45:31.300
each other on the left side of our view.

00:45:31.330 --> 00:45:35.430
We want to stretch them horizontally
throughout this animation.

00:45:35.680 --> 00:45:39.900
The animation for this for the
snapshot after is really easy,

00:45:39.900 --> 00:45:42.220
because we already have
the frame for that.

00:45:42.320 --> 00:45:45.270
So we'll call the snapshot after frame,
set its frame to the

00:45:45.270 --> 00:45:46.640
frame after rotation.

00:45:46.710 --> 00:45:49.400
This basically sets the final
snapshot's frame to match

00:45:49.400 --> 00:45:50.970
the final table view's frame.

00:45:51.070 --> 00:45:52.800
So that'll stretch it out horizontally.

00:45:52.830 --> 00:45:55.080
Now, we want to do the same thing
for the initial snapshot,

00:45:55.210 --> 00:45:58.060
the snapshot before,
but like we did before,

00:45:58.060 --> 00:45:59.650
we only want to stretch it horizontally.

00:45:59.660 --> 00:46:02.100
We don't want to stretch it vertically,
because if we stretched it vertically,

00:46:02.100 --> 00:46:03.800
you'd see the text
stretched out vertically,

00:46:03.800 --> 00:46:05.440
and that would look pretty bad.

00:46:05.570 --> 00:46:07.940
So we're going to use that same
convenience method I created before,

00:46:07.940 --> 00:46:10.580
set frame preserving height,
and we'll pass in the

00:46:10.580 --> 00:46:12.790
same frame after rotation,
because we do want it

00:46:12.790 --> 00:46:18.380
to have the same width,
but we'll keep its original height.

00:46:18.510 --> 00:46:20.900
All right, now there is one last
thing we're going to do.

00:46:20.920 --> 00:46:23.060
Oops,
I have failed miserably in that I've

00:46:23.060 --> 00:46:27.340
put this above our animations enabled
so they would not actually animate.

00:46:27.500 --> 00:46:28.640
Wow, I've done this for everything.

00:46:28.640 --> 00:46:31.350
Let's go ahead and move
all this down here.

00:46:34.080 --> 00:46:37.320
That would have been surprising
when I went to run our demo.

00:46:37.380 --> 00:46:41.040
Then the last thing we've got
here is that we actually have

00:46:41.270 --> 00:46:44.600
our table view still in the view
hierarchy and still visible.

00:46:44.680 --> 00:46:47.490
Now, our snapshots are on top of it,
but they're fully covering it.

00:46:47.600 --> 00:46:51.240
So it's a little silly to have the table
view in the hierarchy at this point,

00:46:51.340 --> 00:46:54.540
only because Core Animation will
have to figure out that it

00:46:54.540 --> 00:46:55.800
shouldn't be rendering it.

00:46:55.800 --> 00:46:56.930
We could tell it that.

00:46:57.050 --> 00:46:58.910
So we'll tell it that by
just setting it into yes,

00:46:58.910 --> 00:47:01.600
make sure that our performance
is as high as possible.

00:47:01.670 --> 00:47:04.440
The last thing we want to do is
clean up after ourselves and did

00:47:04.440 --> 00:47:06.160
rotate from interface orientation.

00:47:06.250 --> 00:47:09.970
So we remove our two snapshot views from
the view hierarchy and nil them out.

00:47:10.250 --> 00:47:12.510
I'm using arc here just so
you don't think I'm leaking

00:47:12.510 --> 00:47:13.700
views all over the place.

00:47:13.890 --> 00:47:16.260
I didn't call release because
arc's cleaning up for us

00:47:16.480 --> 00:47:19.310
when we set our IVARs to nil.

00:47:19.780 --> 00:47:21.800
And then we're going to unhide
our table view so that we

00:47:21.800 --> 00:47:24.050
actually see it again in the end.

00:47:24.160 --> 00:47:28.350
And after all of that typing and
frantic reorganizing of code,

00:47:28.420 --> 00:47:30.730
we should now be in a
case where when we rotate,

00:47:30.820 --> 00:47:34.250
we see the -- the whole thing -- Oh,
right, sorry.

00:47:34.440 --> 00:47:36.680
I did this right before the demo,
so I now know what's wrong.

00:47:36.860 --> 00:47:41.560
I have commented out my code so that
it wouldn't be throwing errors before.

00:47:41.640 --> 00:47:45.070
That was the method that's
returning us the edge insets.

00:47:45.160 --> 00:47:47.680
I had written it before
but left it commented out.

00:47:47.830 --> 00:47:50.420
Let's uncomment it so it works.

00:47:50.580 --> 00:47:52.060
Now when we rotate,
if we watch over here,

00:47:52.060 --> 00:47:55.100
we'll see things stretch just in
that area that was marked red.

00:47:55.170 --> 00:47:57.900
And everything else will
just crossfade nicely.

00:47:57.980 --> 00:48:00.600
The chevrons will kind of slide
in towards the views on the left,

00:48:00.810 --> 00:48:03.320
the areas on the left,
will slide towards the chevrons.

00:48:03.340 --> 00:48:06.710
And there's kind of a minimal amount
now of stretching and crossfading.

00:48:06.720 --> 00:48:10.950
It's about as close as we can get to what
it really should look like without having

00:48:10.950 --> 00:48:13.360
to really draw every intermediate frame.

00:48:13.360 --> 00:48:14.760
Now there is one last thing.

00:48:14.790 --> 00:48:20.210
So we can scroll around now and
rotate and everything looks -- Uh-oh.

00:48:20.890 --> 00:48:22.920
So we've got some black areas up there.

00:48:22.920 --> 00:48:24.380
That doesn't look too good.

00:48:24.380 --> 00:48:29.320
What happened there is that when
we called render in context,

00:48:29.330 --> 00:48:32.280
it actually was the case that
-- Since we're in a scroll

00:48:32.280 --> 00:48:34.240
view and the thing we're trying
to render is a scroll view,

00:48:34.240 --> 00:48:35.880
we had scrolled our content up.

00:48:35.880 --> 00:48:38.880
We captured the origin of the
content in the table view,

00:48:38.880 --> 00:48:39.770
00.

00:48:39.780 --> 00:48:42.220
But that's scrolled way up off
screen now and there's no cells there

00:48:42.220 --> 00:48:43.880
anymore because it's off screen.

00:48:43.880 --> 00:48:46.920
So we ended up seeing a big black
area where there would have been cells

00:48:46.920 --> 00:48:50.140
at the top of our table view if it
were actually scrolled all the way in.

00:48:50.160 --> 00:48:52.680
So we need to make sure that
when we render this table view,

00:48:52.680 --> 00:48:54.820
we capture just the
part of it that we want.

00:48:54.830 --> 00:48:58.940
So before we call render in context,
we can just shift our graphics context

00:48:58.940 --> 00:49:02.440
by the amount that we scrolled to make
sure that we -- So when we capture it,

00:49:02.440 --> 00:49:07.000
we render the right part at the origin of
our image that we're trying to snapshot.

00:49:07.040 --> 00:49:11.000
So we can do that by translating
the context transformation matrix.

00:49:11.040 --> 00:49:17.200
So we'll call CG context translate CTM,
translate the current transform matrix,

00:49:17.260 --> 00:49:19.400
on the current graphics context.

00:49:19.440 --> 00:49:21.620
And the amount that we want to
translate it by is the exact

00:49:21.720 --> 00:49:23.380
same amount that we scrolled by.

00:49:23.410 --> 00:49:25.040
And the amount that we
scrolled by is just the bounds

00:49:25.080 --> 00:49:27.940
origin of our target view,
which is the table view.

00:49:27.950 --> 00:49:31.040
So we'll translate by the negative
of the bounds origin dot x and the

00:49:31.040 --> 00:49:34.200
negative of the bounds origin dot y to
make sure that we're capturing the right

00:49:34.300 --> 00:49:37.740
part of the table view and not getting
black areas where there's no content.

00:49:38.010 --> 00:49:40.440
So if we do that and then scroll
down a little bit and rotate,

00:49:40.490 --> 00:49:42.140
now we're actually
capturing the right part,

00:49:42.160 --> 00:49:46.060
and we can still get a correct snapshot,
and everything looks good.

00:49:52.660 --> 00:49:57.460
So we say all this stuff not to say that,
like, these are the techniques

00:49:57.460 --> 00:49:58.660
in order to do rotation.

00:49:58.660 --> 00:50:00.620
We're not trying to say
that snapshotting is,

00:50:00.620 --> 00:50:01.740
like, the way to do it.

00:50:01.840 --> 00:50:04.540
This is more trying to give you
an idea of the kinds of tools that

00:50:04.580 --> 00:50:07.060
are in the toolbox that you can
use when thinking of how you should

00:50:07.150 --> 00:50:09.000
build your own rotation animations.

00:50:09.140 --> 00:50:10.990
Some of these techniques
may be useful in your apps,

00:50:10.990 --> 00:50:13.680
but if they're not, then, you know,
move on and try something else.

00:50:13.960 --> 00:50:17.890
Not all of them are, you know,
the right answer for every situation.

00:50:18.050 --> 00:50:24.160
So to get back into some of the,
you know, more honest rotation animations

00:50:24.160 --> 00:50:26.340
that are really doing the real
things as opposed to the ways that

00:50:26.340 --> 00:50:29.040
we're tricking our users here,
Andy's going to come back and talk

00:50:29.040 --> 00:50:31.760
a little more about performance
characteristics and tricks.

00:50:34.370 --> 00:50:38.000
Josh has lied to you.

00:50:38.000 --> 00:50:41.330
What I'm about to show you
is a series of hideous hacks.

00:50:45.800 --> 00:50:49.760
Masks are slow.

00:50:49.850 --> 00:50:51.040
This is why they're slow.

00:50:51.130 --> 00:50:53.310
When we go to draw them,
say that we have a view like this

00:50:53.410 --> 00:50:58.880
that's masked in a star shape,
we render the entire view,

00:50:58.990 --> 00:51:02.700
the unmasked version,
into an off-screen buffer,

00:51:02.780 --> 00:51:07.260
and then in each frame,
copy the bits of that buffer on screen,

00:51:07.330 --> 00:51:10.840
evaluating the mask to make sure
we only copy the right bits on,

00:51:10.910 --> 00:51:13.190
and then we throw the buffer away.

00:51:13.760 --> 00:51:15.460
We do that every frame.

00:51:15.510 --> 00:51:18.550
Make the buffer, copy,
throw the buffer away.

00:51:18.820 --> 00:51:20.480
No good.

00:51:20.720 --> 00:51:24.800
But rotation,
like the rasterization thing

00:51:24.800 --> 00:51:26.960
we were talking about before,
is a place where you might be

00:51:26.960 --> 00:51:31.020
able to control the situation
you're trying to mask.

00:51:31.130 --> 00:51:33.550
So you might be able to
use setShouldRasterize,

00:51:33.550 --> 00:51:36.360
like I showed you before,
in order to say, "Hey,

00:51:36.520 --> 00:51:38.710
this thing that I'm masking,

00:51:38.840 --> 00:51:41.750
Nothing inside of it is going to change
during the course of the animation,

00:51:41.750 --> 00:51:45.220
so at least don't throw
that off-screen buffer away,

00:51:45.220 --> 00:51:45.990
please.

00:51:47.020 --> 00:51:52.730
If you can't guarantee that things inside
of the masked hierarchy are not moving,

00:51:52.820 --> 00:51:55.040
then you might be able to
take a screenshot of it,

00:51:55.180 --> 00:51:59.090
perhaps sans a view,
and then move the screenshot

00:51:59.090 --> 00:52:02.500
around and move one of the
views around on top of it.

00:52:02.630 --> 00:52:05.690
But the aforementioned hideous
hack is actually this one.

00:52:05.790 --> 00:52:10.940
Maybe you can draw what's underneath the
masked view hierarchy back on top of it.

00:52:11.090 --> 00:52:14.000
In this case, that would look like this.

00:52:14.130 --> 00:52:16.780
So you actually don't mask anything.

00:52:16.790 --> 00:52:22.200
You create another view that has
the background and has a hole in it,

00:52:22.360 --> 00:52:23.920
and then you draw that on top.

00:52:24.080 --> 00:52:27.100
You probably can't get away with
doing that in general because usually

00:52:27.100 --> 00:52:28.800
the background is going to change.

00:52:28.940 --> 00:52:32.720
But during a rotation animation,
you might have enough control,

00:52:32.720 --> 00:52:35.900
you might be able to arrange
things so that you can.

00:52:36.050 --> 00:52:37.770
That would be pretty cool.

00:52:38.760 --> 00:52:40.220
I have a piece of news for you.

00:52:40.530 --> 00:52:42.700
This particular kind of masking,
which you get by calling

00:52:42.700 --> 00:52:49.830
setCornerRadius on caLayer,
is now much, much faster on iOS 6.

00:52:54.740 --> 00:52:55.940
It's still kind of slow.

00:52:55.940 --> 00:52:59.810
It has to be.

00:53:01.100 --> 00:53:04.200
I have more hideous hacks for you.

00:53:04.240 --> 00:53:06.980
Maybe you don't have to do
all of the complex animations

00:53:06.980 --> 00:53:09.030
that you think you have to do.

00:53:09.820 --> 00:53:13.740
During a rotation, part of your interface
is going off screen.

00:53:13.810 --> 00:53:15.940
The corner is going to be cut.

00:53:16.010 --> 00:53:18.500
Maybe the corner doesn't matter.

00:53:18.570 --> 00:53:20.200
I'd like to show you a demo.

00:53:20.570 --> 00:53:22.750
The fun part about this demo is

00:53:23.460 --> 00:53:26.400
is that I'm not actually
going to write any code.

00:53:26.500 --> 00:53:30.480
So I'm going to make a new project
that's just the default master

00:53:30.550 --> 00:53:32.550
detail application template.

00:53:36.370 --> 00:53:37.500
Build and run.

00:53:37.560 --> 00:53:38.800
No code changes.

00:53:38.840 --> 00:53:41.490
I'm going to show you what
split views on our system do.

00:53:41.960 --> 00:53:43.300
It's kind of heinous.

00:53:43.300 --> 00:53:47.540
So I rotate.

00:53:47.540 --> 00:53:51.780
Split view looks good, right?

00:53:51.780 --> 00:53:51.780
I think it looks pretty good.

00:53:53.130 --> 00:53:58.460
Now watch over here as
this navigation bar slides.

00:53:58.680 --> 00:54:03.280
Yes, that's right,
slides into place and out of place.

00:54:03.420 --> 00:54:06.180
We were able to get away with doing that

00:54:06.350 --> 00:54:11.320
Because this region of the screen mostly
goes off-screen during the rotation.

00:54:11.460 --> 00:54:16.280
So there's really no need to
do anything more than take a

00:54:16.440 --> 00:54:22.960
snapshot of the 768 pixel high
master view and move that around,

00:54:23.090 --> 00:54:26.150
which is extremely cheap because at
that point core animation is just

00:54:26.190 --> 00:54:27.920
sliding a quad around the screen.

00:54:27.920 --> 00:54:30.700
It's not doing anything fancy at all.

00:54:30.760 --> 00:54:33.330
And you probably never noticed this.

00:54:34.170 --> 00:54:40.240
I encourage you to use such techniques
within your own applications.

00:54:40.200 --> 00:54:42.960
I encourage you also to
bother Jake Behrens with any

00:54:42.960 --> 00:54:46.200
questions you might have,
because he is here to help you.

00:54:46.390 --> 00:54:49.540
Furthermore, you should bother each other
on the developer forums.

00:54:50.530 --> 00:54:54.560
And I'd like to review a few points
that we've talked about today.

00:54:54.640 --> 00:55:00.000
First one, most importantly,
let UIKit do things for you.

00:55:00.040 --> 00:55:03.850
Much of this is hard,
and we've done much of it for you.

00:55:03.920 --> 00:55:05.580
So there's the rotating
header view thing.

00:55:05.580 --> 00:55:07.630
There's the rotating footer view thing.

00:55:07.760 --> 00:55:09.140
Status bars rotate for you.

00:55:09.140 --> 00:55:11.000
The keyboard rotates for you.

00:55:11.050 --> 00:55:12.940
Let us do that.

00:55:13.250 --> 00:55:16.730
When you have to do your own rotations,

00:55:16.960 --> 00:55:20.490
Maybe you can tell the system
that a certain part of your screen

00:55:21.190 --> 00:55:24.740
can be considered as a unit for
the course of your rotation.

00:55:24.840 --> 00:55:27.330
That was the rasterization bit.

00:55:28.160 --> 00:55:32.210
And then maybe you can use some of the
same techniques to fake things or to make

00:55:32.280 --> 00:55:36.590
better animations by taking snapshots,
which may be slow,

00:55:36.790 --> 00:55:39.520
especially on new iPads,
so make sure you evaluate the

00:55:39.610 --> 00:55:41.410
performance characteristics.

00:55:41.600 --> 00:55:44.470
You can get some really cool
animations by stretching

00:55:44.470 --> 00:55:46.340
only part of those snapshots.

00:55:46.480 --> 00:55:48.340
That's a technique we really like.

00:55:48.480 --> 00:55:52.740
There's some new API in iOS 6,
not in this beta, but soon,

00:55:52.870 --> 00:55:54.930
that you'll be able to use for that.

00:55:55.590 --> 00:55:57.770
And finally, simplify.

00:55:58.100 --> 00:56:02.500
The theme of this whole talk has been,
this is pretty fast.

00:56:02.540 --> 00:56:09.000
Maybe you can get away with doing
something a little less faithful.

00:56:09.440 --> 00:56:13.040
I hope this has been helpful.

00:56:13.580 --> 00:56:15.900
I hope you'll create even
more amazing applications.

00:56:15.900 --> 00:56:19.400
I hope you'll wow us with your
interface orientation transitions.

00:56:19.400 --> 00:56:21.370
And I hope you have a great
time with the rest of your week.
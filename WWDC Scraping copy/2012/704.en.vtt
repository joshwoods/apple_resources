WEBVTT

00:00:10.340 --> 00:00:11.440
Good afternoon, everyone.

00:00:11.440 --> 00:00:13.090
My name is Dallas De Atley.

00:00:13.090 --> 00:00:15.380
And for the next hour,
we're going to be talking about the

00:00:15.420 --> 00:00:19.600
Security Framework on iOS and OS X.

00:00:21.030 --> 00:00:24.050
So some of the things we're going
to be talking about over the next

00:00:24.220 --> 00:00:29.700
hour include the basic building
blocks of the Security Framework,

00:00:31.000 --> 00:00:34.170
How the operating systems
use the Security Framework

00:00:34.170 --> 00:00:38.990
to store the user's secrets,
like a password using the Keychain.

00:00:40.450 --> 00:00:44.400
How the operating system relies on
the security framework to protect data

00:00:44.400 --> 00:00:49.550
as it travels over a network between
devices or a device and a web server.

00:00:50.900 --> 00:00:55.510
and how the operating systems rely on
the Security Framework to evaluate the

00:00:55.510 --> 00:00:58.790
trust of a digitally signed object.

00:01:00.500 --> 00:01:04.050
So the Security Framework on
OS X actually is in a number of

00:01:04.050 --> 00:01:05.540
different places in the system.

00:01:05.760 --> 00:01:10.120
At the lowest level,
we have our crypto implementation.

00:01:10.120 --> 00:01:13.700
And the Security Framework is
primarily implemented as a CF API.

00:01:13.700 --> 00:01:18.740
But we also expose interfaces for
developers at the Objective-C level

00:01:18.740 --> 00:01:21.320
and as a part of the AppKit level.

00:01:21.320 --> 00:01:26.930
But for the purposes of today's talk,
we're just going to focus on those

00:01:26.930 --> 00:01:31.850
bottom two components that are
the same on both OS X and iOS.

00:01:32.290 --> 00:01:35.800
Now, if we were to just focus on
the entire Security Framework,

00:01:35.930 --> 00:01:38.420
it actually has a lot
of technology in it,

00:01:38.520 --> 00:01:41.430
and we're not going to be able to
cover all of this in today's session.

00:01:41.500 --> 00:01:44.170
So again,
we're going to narrow it down a little

00:01:44.170 --> 00:01:47.780
bit and just talk about a couple of
core concepts that we want you to

00:01:47.780 --> 00:01:49.920
take away from the session today.

00:01:52.820 --> 00:01:57.400
So the technologies that we want to
talk about include the crypto itself.

00:01:57.400 --> 00:02:01.690
So the actual encryption and
signing operations that we

00:02:01.720 --> 00:02:03.610
support on the platforms.

00:02:04.760 --> 00:02:06.910
We're also going to
talk about the Keychain,

00:02:06.940 --> 00:02:12.120
which is the database that we use for
securely protecting the user's passwords.

00:02:12.610 --> 00:02:14.600
We're going to talk
about Secure Transport,

00:02:14.720 --> 00:02:20.500
which is that technology that we
use for providing SSL on the device.

00:02:20.610 --> 00:02:23.130
And we're going to talk
about how the system takes

00:02:23.130 --> 00:02:24.910
advantage of trust evaluation.

00:02:26.220 --> 00:02:29.700
So let's start with crypto.

00:02:29.700 --> 00:02:34.620
So we support our cryptography in
a library called Common Crypto.

00:02:34.620 --> 00:02:40.480
And Common Crypto was designed in
particular to be very performant.

00:02:40.670 --> 00:02:47.570
And so our goal with this library
is to keep it small and fast.

00:02:47.570 --> 00:02:47.570
But not only that,

00:02:47.990 --> 00:02:52.760
The crypto library is at the lowest level
of the system because we use cryptography

00:02:53.120 --> 00:02:55.910
on both platforms all over the place.

00:02:55.920 --> 00:03:00.460
And so we are very sensitive to it
being as performant as possible,

00:03:00.460 --> 00:03:03.770
not only because in general,
crypto algorithms are

00:03:03.880 --> 00:03:07.270
computationally very complex,
but we also want it to be as

00:03:07.270 --> 00:03:09.100
power efficient as possible.

00:03:10.020 --> 00:03:12.810
One of the reasons we call it
common crypto is we want to put all

00:03:12.810 --> 00:03:16.240
of the common algorithms that the
system depends on in one location.

00:03:16.240 --> 00:03:19.800
So for example,
before we developed this library,

00:03:19.960 --> 00:03:23.810
most of the engineering teams would
copy and paste the specific code they

00:03:23.810 --> 00:03:25.940
needed into their own components.

00:03:25.940 --> 00:03:31.010
And this led to, for example,
us having 17 different copies of the MD5

00:03:31.010 --> 00:03:33.920
algorithm floating around the system.

00:03:33.920 --> 00:03:37.840
So now we've got all of that
centralized in one place.

00:03:37.840 --> 00:03:42.110
The other benefit of common crypto
is that for our clients in the OS,

00:03:42.140 --> 00:03:45.650
we have a stable interface
that everyone can use.

00:03:45.660 --> 00:03:50.460
But the crypto library itself
will actually take advantage of

00:03:50.460 --> 00:03:52.620
processor-specific optimizations.

00:03:52.690 --> 00:03:56.950
So if there's an instruction set
on a particular processor that

00:03:56.950 --> 00:04:00.720
we can use to make AES go faster,
then common crypto is going to

00:04:00.720 --> 00:04:05.210
take advantage of that without
our clients having to know.

00:04:05.610 --> 00:04:09.300
In the same vein,
if we actually have hardware acceleration

00:04:09.300 --> 00:04:12.800
available on a particular platform,
we'll take that path.

00:04:12.870 --> 00:04:14.840
But again,
none of our clients really need

00:04:14.860 --> 00:04:18.480
to know that all of this is going
on under the hood because they're

00:04:18.480 --> 00:04:20.600
using a common set of interfaces.

00:04:21.450 --> 00:04:23.870
In particular,
we support state-of-the-art

00:04:23.950 --> 00:04:26.400
crypto algorithms on the device.

00:04:26.420 --> 00:04:27.790
So what does that actually mean?

00:04:27.830 --> 00:04:33.920
Well, we support the majority of the
FIPS 140-2 standard as defined by NIST.

00:04:33.920 --> 00:04:37.610
For those of you who don't
recognize that alphabet soup,

00:04:37.610 --> 00:04:42.420
NIST is a federal group that works to
define a lot of technology standards,

00:04:42.420 --> 00:04:47.080
and FIPS in particular is their
information protection standard.

00:04:47.080 --> 00:04:52.470
So what they do is they publish on a
regular basis the latest and greatest

00:04:52.530 --> 00:04:58.520
crypto algorithms and the best way to
take advantage of them in your software.

00:04:58.540 --> 00:05:01.710
And so in particular,

00:05:01.830 --> 00:05:06.330
Our library,
we aim to keep up with the latest

00:05:06.660 --> 00:05:09.130
standard as it's published.

00:05:09.850 --> 00:05:12.140
So what I'd like to do is talk
a little bit about the types of

00:05:12.150 --> 00:05:13.710
crypto that we actually support.

00:05:13.710 --> 00:05:17.090
So for those of you who
have a bit more experience,

00:05:17.090 --> 00:05:20.310
this might seem a little redundant,
but we also want to go through some

00:05:20.310 --> 00:05:23.540
of the concepts that we use and the
terms that we use when we talk about

00:05:23.610 --> 00:05:26.530
crypto for those of you who might
not be cryptographers yourself.

00:05:26.600 --> 00:05:31.600
So what I have here is an example of
what we call symmetric encryption.

00:05:31.600 --> 00:05:35.110
And the basic idea behind symmetric
encryption is that you want

00:05:35.110 --> 00:05:38.280
to take a piece of plain text,
like a file or a message,

00:05:38.280 --> 00:05:42.460
and you want to encrypt it and obscure
it so that an attacker can't actually

00:05:42.460 --> 00:05:44.100
see what your original message was.

00:05:44.100 --> 00:05:48.230
And the key behind symmetric encryption
is that you have a single key,

00:05:48.230 --> 00:05:50.120
but the operation is two ways.

00:05:50.120 --> 00:05:53.950
You can encrypt with the key and
then decrypt with the same key.

00:05:53.960 --> 00:05:58.680
So in this example,
you're going to feed that symmetric key

00:05:58.680 --> 00:06:00.840
and the plain text into an AES engine.

00:06:00.840 --> 00:06:04.260
And what you're going to get out the
other side is what we call ciphertext.

00:06:04.260 --> 00:06:11.040
And that is the obscured text that
should now be encrypted by that key.

00:06:11.040 --> 00:06:14.880
And as I mentioned,
AES is what we call a two-way function.

00:06:14.880 --> 00:06:19.220
So you can then take that ciphertext
and use the exact same key,

00:06:19.220 --> 00:06:24.060
feed it back through the same engine,
and get the original plain text.

00:06:24.060 --> 00:06:28.090
And so this is the kind of...
standard thing that people think

00:06:28.090 --> 00:06:30.600
about when they think about
encryption and crypto in general.

00:06:31.350 --> 00:06:35.350
And it's what most crypto systems
have been doing for a long time.

00:06:35.360 --> 00:06:41.010
The main issue about all of this, though,
is if you want to encrypt a file

00:06:41.030 --> 00:06:45.040
and then give that file to someone
else so that they can decrypt it,

00:06:45.080 --> 00:06:48.760
you also have to get them the
key without an attacker being

00:06:48.760 --> 00:06:50.040
able to intercept it on the way.

00:06:50.040 --> 00:06:53.000
So there's another
algorithm that we support,

00:06:53.040 --> 00:06:55.140
which is called a message digest.

00:06:55.140 --> 00:06:56.440
And a message digest is a
way to decrypt a message.

00:06:56.600 --> 00:07:02.280
And it's different from encryption in
that we call it a one-way function.

00:07:02.280 --> 00:07:06.290
So the idea is that you're going to
have an arbitrary amount of data,

00:07:06.300 --> 00:07:09.800
a file, or a large message,
that you're then going to run

00:07:09.800 --> 00:07:13.500
through a message digest algorithm,
in this case like SHA.

00:07:13.500 --> 00:07:17.940
And what you're going to get is
what we call a message digest.

00:07:17.940 --> 00:07:21.740
Now,
a message digest is a much smaller value,

00:07:21.740 --> 00:07:26.580
and it uniquely identifies
the data that you're sending.

00:07:26.600 --> 00:07:32.460
And the idea behind a secure hashing
algorithm is that the odds of two

00:07:32.460 --> 00:07:38.720
different sets of data hashing down
to the same message digest are very,

00:07:38.870 --> 00:07:39.910
very low.

00:07:39.950 --> 00:07:44.800
And so in most cases,
you can rely upon an algorithm like SHA-1

00:07:44.800 --> 00:07:48.100
as a way to uniquely identify a message.

00:07:48.100 --> 00:07:51.900
Now, as I mentioned,
we call this a one-way function.

00:07:51.900 --> 00:07:54.990
So if someone just has the message digest
and they don't have the original data,

00:07:54.990 --> 00:07:56.580
they can't have the message digest.

00:07:56.600 --> 00:07:59.520
original data that you actually hashed.

00:08:00.000 --> 00:10:56.500
[Transcript missing]

00:10:56.680 --> 00:11:00.940
So that you can get the same behavior
for every crypto operation that

00:11:00.950 --> 00:11:02.350
you feed through the AES engine.

00:11:02.350 --> 00:11:05.560
And of course,
you also want to take advantage

00:11:05.560 --> 00:11:08.300
of something that's called
an initialization vector.

00:11:08.410 --> 00:11:12.850
Because what modern cryptanalysis
is trying to do is manipulate the

00:11:12.850 --> 00:11:16.900
ciphertext and feed it back through
AES in such a way that people

00:11:16.900 --> 00:11:19.150
can discover what your key was.

00:11:19.190 --> 00:11:24.100
And so one technique is to use
an initialization vector to kind

00:11:24.100 --> 00:11:26.300
of prime the pump for the engine.

00:11:28.640 --> 00:11:33.500
But you can also run an AES engine
in a number of different modes.

00:11:33.540 --> 00:11:35.610
So in this case,
we have what's called the

00:11:35.610 --> 00:11:38.100
electronic codebook mode.

00:11:38.100 --> 00:11:39.860
And it doesn't actually work with an IV.

00:11:39.860 --> 00:11:44.110
So if you were to call the common
crypto operation and put it into

00:11:44.110 --> 00:11:47.860
that mode and feed it an IV,
it's going to ignore it.

00:11:48.590 --> 00:11:51.740
There's a different mode where
you're actually chaining all

00:11:51.740 --> 00:11:53.440
the cipher blocks together.

00:11:53.480 --> 00:11:58.060
And what's going on there is that each
cipher block that comes out is being

00:11:58.060 --> 00:12:03.790
fed back into the engine to provide a
kind of feedback loop into the system.

00:12:05.060 --> 00:12:09.700
And so, if the one thing you
take away from this talk,

00:12:09.780 --> 00:12:13.060
if you're not familiar with
developing your own crypto

00:12:13.060 --> 00:12:17.640
systems and using crypto directly,
we generally recommend that you use the

00:12:17.640 --> 00:12:20.140
higher level services of the system.

00:12:20.190 --> 00:12:24.570
So let me give you an example
of how this can go wrong.

00:12:24.830 --> 00:12:28.740
So here we have a piece of artwork
that we chose completely at random.

00:12:29.300 --> 00:12:34.090
And we wrote a little command line
tool based on our own crypto algorithms

00:12:34.090 --> 00:12:38.190
that was designed to encrypt the file
so that if someone got a hold of it,

00:12:38.200 --> 00:12:40.760
they wouldn't be able to
tell what the plain text was.

00:12:40.760 --> 00:12:44.780
And we used that electronic code
book mode to feed it through AES,

00:12:44.780 --> 00:12:47.640
which is an industry standard algorithm.

00:12:47.640 --> 00:12:49.770
And this was the result.

00:12:49.780 --> 00:12:53.920
So you can tell that an attacker
can probably guess what our

00:12:53.920 --> 00:12:55.910
original plain text was.

00:12:55.910 --> 00:12:59.280
So again, the devil is in the details
when it comes to this.

00:12:59.300 --> 00:13:02.550
comes to doing crypto
operations on your own.

00:13:03.550 --> 00:13:05.040
So some things to keep in mind.

00:13:05.040 --> 00:13:10.090
Avoid using those crypto primitives.

00:13:10.540 --> 00:13:12.150
Use the higher level services.

00:13:12.310 --> 00:13:16.880
For example,
on the operating system itself,

00:13:16.920 --> 00:13:16.920
we provide

00:13:17.650 --> 00:13:21.670
is an API that the Mail application
uses called Cryptographic

00:13:21.670 --> 00:13:23.380
Message Syntax or CMS.

00:13:23.380 --> 00:13:28.640
And this is how Mail encrypts and
signs messages for the S/MIME protocol.

00:13:28.770 --> 00:13:33.150
And so we've provided a higher
level API that the Mail team can

00:13:33.150 --> 00:13:36.630
use so that they don't have to
figure out how to encrypt and sign

00:13:36.630 --> 00:13:38.970
everything manually themselves.

00:13:39.900 --> 00:13:44.700
Now we provide a higher level API for
folks who want to do encryption and

00:13:44.700 --> 00:13:49.970
decryption and signing and verify
operations as a part of the set key APIs.

00:13:49.970 --> 00:13:54.190
And those APIs are
available on OS X and iOS.

00:13:55.020 --> 00:13:59.400
Last year we also introduced a
new API we call SecTransform.

00:13:59.450 --> 00:14:02.380
And I'd like to talk about
SecTransform a little bit.

00:14:02.660 --> 00:14:07.970
So SecTransform is
only available on OS X.

00:14:08.620 --> 00:14:12.330
And the ideas that we've
provided in interface,

00:14:12.330 --> 00:14:17.030
which at the core foundation
layer allows you to drive data

00:14:17.160 --> 00:14:22.390
through a GCD engine for doing
encryption and data transcoding.

00:14:22.550 --> 00:14:25.390
Now again, it's only available on OS X.

00:14:25.790 --> 00:14:42.010
But you can do all of the standard
crypto routines that you would expect.

00:14:42.010 --> 00:14:42.010
And you can do data encoding.

00:14:42.010 --> 00:14:42.010
So for example, if you would like to
transfer a file into base 64,

00:14:42.010 --> 00:14:42.010
so you can then send
it out over a network,

00:14:42.010 --> 00:14:42.010
SecTransform will support that.

00:14:42.010 --> 00:14:42.010
But

00:14:42.260 --> 00:14:46.740
One of the great things about
SecTransform is it's a lot simpler

00:14:46.740 --> 00:14:51.840
to use than the existing APIs we
had in the Security Framework.

00:14:51.880 --> 00:14:55.640
So here's a code example of how you
can use SecTransform to actually

00:14:55.950 --> 00:14:58.750
encode something into Base64.

00:14:58.790 --> 00:15:02.330
So you're only going to be
providing two inputs fundamentally,

00:15:02.470 --> 00:15:05.480
which is a CFData that
represents the actual data you

00:15:05.480 --> 00:15:09.810
want to translate into Base64,
and then the error code you

00:15:09.810 --> 00:15:11.380
want to get back from the call.

00:15:11.680 --> 00:15:16.130
And what you're going to do is
first create that SecTransform.

00:15:16.190 --> 00:15:18.500
And when you create the transform,
you're going to tell it,

00:15:18.560 --> 00:15:22.510
"I'm going to use this transform
for doing Base64 encoding."

00:15:23.180 --> 00:15:25.540
And you're going to set an
attribute on that transform.

00:15:25.540 --> 00:15:27.540
And in this case,
the attribute is simply,

00:15:27.590 --> 00:15:30.530
here's the input data I want you to use.

00:15:30.610 --> 00:15:34.380
Once you've got that set up,
you call SecTransform execute,

00:15:34.460 --> 00:15:37.500
and it's going to do all of
that work on your behalf.

00:15:37.500 --> 00:15:40.140
It's going to return
the output data to you,

00:15:40.200 --> 00:15:43.220
and then you can check for
errors with that error variable.

00:15:43.440 --> 00:15:46.860
What's really cool about
SecTransform is under the hood,

00:15:46.910 --> 00:15:50.620
it's taking advantage of
GCD on the platform for you.

00:15:50.680 --> 00:15:53.770
So if you want to do a
whole bunch of operations,

00:15:53.860 --> 00:15:57.560
either you want to chain them together
or you want them to run all in parallel,

00:15:57.720 --> 00:16:01.830
SecTransform is going to use the
existing dispatch APIs to do all

00:16:01.930 --> 00:16:03.860
of that scheduling on your behalf.

00:16:03.860 --> 00:16:06.250
So your application,
you don't have to worry

00:16:06.250 --> 00:16:08.130
about those level of details.

00:16:08.210 --> 00:16:10.550
So let me give you an example
of what that looks like.

00:16:10.640 --> 00:16:16.620
So in this code,
what we're doing is we want to first

00:16:16.720 --> 00:16:20.610
encrypt the data and then encode
it for sending over the network.

00:16:22.200 --> 00:16:24.740
So one additional piece of data
that you're going to have as

00:16:24.740 --> 00:16:28.690
an input is the actual key that
you want to use for encryption.

00:16:29.050 --> 00:16:33.480
And then the input data that you
want to encrypt and then encode.

00:16:33.520 --> 00:16:36.620
And again, you're just going to create
an encryption transform,

00:16:36.620 --> 00:16:38.640
set it up and give it the
original key that it needs

00:16:38.640 --> 00:16:41.640
to use to do that encryption.

00:16:41.700 --> 00:16:45.440
And then you're going to create
a separate encoding transform.

00:16:46.350 --> 00:16:49.140
And the way that you actually
chain these together is by using

00:16:49.140 --> 00:16:51.750
what we call a SecTransform group.

00:16:51.790 --> 00:16:54.680
So you're going to create
that group transform.

00:16:54.820 --> 00:16:57.920
And then you're going to connect
those two transforms together.

00:16:57.920 --> 00:17:01.120
So you're telling the group that
I want this transform to run first,

00:17:01.140 --> 00:17:05.290
and I want its data to feed into
this transform that runs after it.

00:17:06.080 --> 00:17:07.720
At that point,
you just need to set the original

00:17:07.720 --> 00:17:09.510
attribute on that encryption transform.

00:17:09.510 --> 00:17:11.750
So here's your input data.

00:17:12.430 --> 00:17:15.520
You can then execute those
transforms asynchronously.

00:17:15.560 --> 00:17:19.670
And again, GCD will take care of all
of the details of scheduling

00:17:19.670 --> 00:17:21.800
all that work on your behalf.

00:17:21.950 --> 00:17:23.900
And that's really all there is to it.

00:17:24.110 --> 00:17:28.990
And if you're familiar with using
the APIs that we've had previously,

00:17:29.150 --> 00:17:30.330
this is far simpler.

00:17:30.400 --> 00:17:35.400
So now I'd like to switch gears and
talk a little bit about the Keychain.

00:17:35.710 --> 00:17:39.640
So the Keychain is fundamentally
intended to protect the user's secrets.

00:17:39.640 --> 00:17:42.930
So when the user enters in his
passwords to log on to a website

00:17:43.090 --> 00:17:45.680
or even to log on to the device,

00:17:46.290 --> 00:17:49.140
You want to be storing
them in the Keychain.

00:17:49.140 --> 00:17:52.280
It's also the right place for
other types of crypto material like

00:17:52.280 --> 00:17:55.860
certificates and signing identities,
things like that.

00:17:56.600 --> 00:18:00.440
One of the things the keychain
does is it enforces access control.

00:18:00.440 --> 00:18:05.040
So the keychain is responsible for
deciding if a calling application is

00:18:05.470 --> 00:18:07.810
allowed to get access to a keychain item.

00:18:07.820 --> 00:18:13.120
And this can be expressed through
what we call access control lists,

00:18:13.120 --> 00:18:17.530
or ACLs,
so that the original client that put

00:18:17.580 --> 00:18:21.640
something into the keychain can specify,
here are the set of other clients

00:18:21.690 --> 00:18:23.960
that are allowed to get direct
access to this keychain item.

00:18:24.640 --> 00:18:26.990
And on OS X,
the keychain is also responsible

00:18:27.000 --> 00:18:31.040
for putting up the UI that
will actually ask the user,

00:18:31.040 --> 00:18:34.400
this application in particular
would like access to this item,

00:18:34.400 --> 00:18:36.060
and the user can make that choice.

00:18:36.060 --> 00:18:40.670
The keychain is cryptographically secure,
so that when you put an

00:18:40.800 --> 00:18:43.570
item into the keychain,
we are encrypting it

00:18:43.620 --> 00:18:48.020
and storing it locally,
and it's bound to the user's password.

00:18:48.020 --> 00:18:53.980
So when I log into my Mac,
we're unlocking the default keychain.

00:18:53.980 --> 00:18:54.020
Okay.

00:18:54.600 --> 00:18:58.020
And on iOS, when I enter in my passcode
to unlock the device,

00:18:58.020 --> 00:19:01.320
the keychain items are then
accessible to clients as well.

00:19:03.760 --> 00:19:07.540
One chief difference between the
two platforms is that OS X supports

00:19:07.540 --> 00:19:11.800
the concept of multiple Keychains,
so the user can take a set of

00:19:11.800 --> 00:19:15.040
Keychain items and put them in
a separate physical Keychain.

00:19:15.040 --> 00:19:18.700
You can put it on a USB thumb drive,
for example.

00:19:19.750 --> 00:19:24.700
So I'd like to walk you through an
actual code example for how your app

00:19:24.700 --> 00:19:28.580
can use the Keychain APIs on iOS.

00:19:28.580 --> 00:19:34.200
So in this case,
we have a standard UI alert view.

00:19:34.230 --> 00:19:38.020
And the UI alert views provide two
different styles for your applications

00:19:38.020 --> 00:19:39.810
to ask the user for a password.

00:19:39.910 --> 00:19:42.640
In this case,
we have the secure text input style.

00:19:42.780 --> 00:19:44.380
And so when the user
types in his password,

00:19:44.380 --> 00:19:48.170
it's displayed as those
black dots in the text field.

00:19:48.790 --> 00:19:55.370
There's also a UI Alert View style
that allows you to ask for credentials,

00:19:55.370 --> 00:19:57.690
so the username and the
password at the same time.

00:19:57.720 --> 00:20:01.250
But fundamentally,
what your application gets access to is

00:20:01.250 --> 00:20:03.660
the string that represents that password.

00:20:03.660 --> 00:20:05.730
So when your application
has the password,

00:20:05.730 --> 00:20:08.130
what it wants to do is go
put it into the Keychain.

00:20:08.130 --> 00:20:12.170
And the way that you do that is you don't
just put the password into the Keychain,

00:20:12.170 --> 00:20:15.740
you put the password and a set of
attributes that describe how that item

00:20:15.740 --> 00:20:17.680
is going to be used in the future.

00:20:18.240 --> 00:20:21.460
So the first thing your
application is going to do is

00:20:21.500 --> 00:20:23.700
create an attributes dictionary.

00:20:24.020 --> 00:20:26.940
And then set a couple of
standard attributes that

00:20:26.940 --> 00:20:29.270
describe what that item is.

00:20:29.280 --> 00:20:33.850
So in this example,
it's going to be just a generic password,

00:20:33.890 --> 00:20:37.800
and we're setting an attribute that
associates it with a particular account.

00:20:37.900 --> 00:20:41.960
So that when your application wants
to access that account in the future,

00:20:41.960 --> 00:20:43.900
it knows which one to go ask for.

00:20:43.900 --> 00:20:49.840
The last attribute that you set in the
dictionary is the password item itself.

00:20:49.900 --> 00:20:52.790
And at that point,
once you have your dictionary,

00:20:52.790 --> 00:20:55.600
you simply call sec item add,
and it's going to put

00:20:55.600 --> 00:20:57.680
it into the Keychain.

00:20:57.900 --> 00:21:02.900
And the system is going to
securely store that Keychain in the

00:21:02.900 --> 00:21:03.900
Keychain database on your behalf.

00:21:03.900 --> 00:21:08.710
So your application doesn't have to
worry about any of the other details

00:21:08.720 --> 00:21:11.570
about protecting that Keychain item.

00:21:11.800 --> 00:21:15.690
and SecItem is an API that
we provide on both platforms.

00:21:15.780 --> 00:21:20.860
Now if your application
on OS X needs to use,

00:21:20.860 --> 00:21:25.330
needs to run on older versions of OS X,
then there are pre-existing

00:21:25.330 --> 00:21:26.670
APIs that you can use as well.

00:21:26.700 --> 00:21:29.810
Now once the item is in the password,
the next time your application runs,

00:21:29.810 --> 00:21:32.700
you don't want to have to ask the
user to enter in his password again,

00:21:32.700 --> 00:21:35.700
you just want to go retrieve it
on his behalf from the Keychain.

00:21:35.700 --> 00:21:37.720
And so what you do,
it's a very similar operation,

00:21:37.720 --> 00:21:39.700
you're going to create
another dictionary,

00:21:39.700 --> 00:21:44.040
and in this case you're going to set the
attributes to describe the item that you

00:21:44.260 --> 00:21:46.610
want the Keychain to find on your behalf.

00:21:46.700 --> 00:21:50.050
So again, you're going to say I'm
looking for a generic password

00:21:50.050 --> 00:21:53.520
associated with my account,
and then you're going to

00:21:53.520 --> 00:21:56.960
call SecItemCopyMatching,
and the Keychain is going to

00:21:56.970 --> 00:22:01.690
return the item that best matches
the attributes that you provided.

00:22:01.880 --> 00:22:05.700
One thing to keep in mind is that
in the case of calling CopyMatching,

00:22:05.700 --> 00:22:08.860
you need to set an attribute
that says go ahead and actually

00:22:08.950 --> 00:22:12.690
return the data once you've found
an item that matches properly.

00:22:12.700 --> 00:22:16.610
When you call CopyMatching,
it's going to return a standard CFTypeRef

00:22:16.700 --> 00:22:21.700
that's the password that you can then
use to go log into another service.

00:22:21.700 --> 00:22:23.700
So that's the Keychain.

00:22:23.700 --> 00:22:26.700
I'd now like to talk a little
bit about SecureTransport.

00:22:26.700 --> 00:22:30.200
SecureTransport is a technology
that the OS uses for protecting

00:22:30.360 --> 00:22:32.680
data as it travels over the network.

00:22:32.700 --> 00:22:35.700
So for example, if you're a web browser,
and you're talking about a data transfer,

00:22:35.700 --> 00:22:39.780
and you're talking to an HTTPS server,
underneath the hood,

00:22:39.780 --> 00:22:44.170
you're taking advantage of
SecureTransport to do that work.

00:22:44.460 --> 00:22:49.500
It does this by negotiating what we call
a secure channel between the device and

00:22:49.500 --> 00:22:53.190
the server via a protocol called TLS,
which stands for

00:22:53.190 --> 00:22:54.320
Transport Layer Security.

00:22:54.320 --> 00:22:59.630
You've probably also heard of this,
heard of people refer to this as SSL.

00:23:00.320 --> 00:23:03.860
In particular,
Mountain Lion and iOS 5 support the

00:23:03.860 --> 00:23:07.700
latest TLS protocol 1.2 by default.

00:23:07.870 --> 00:23:11.540
And if your application is doing
networking on either platform,

00:23:11.540 --> 00:23:14.710
most likely you're using the
higher level CF network APIs for

00:23:14.740 --> 00:23:16.540
doing that network activity.

00:23:16.680 --> 00:23:21.360
And CF network and the NSURL APIs support
Secure Transport natively.

00:23:21.360 --> 00:23:26.850
So if you're talking to an HTTPS server,
CF network is going to use

00:23:26.850 --> 00:23:29.570
Secure Transport on your behalf.

00:23:29.900 --> 00:23:34.510
But if your application is talking
directly to the BSD level APIs,

00:23:34.550 --> 00:23:38.450
you can then use Secure Transport to
manually perform the handshake

00:23:38.540 --> 00:23:42.590
and then to actually send the
data over the socket yourself.

00:23:43.000 --> 00:23:48.190
One thing to keep in mind is that there
are older web servers that only know

00:23:48.260 --> 00:23:51.140
how to talk older dialects of TLS.

00:23:51.220 --> 00:23:55.190
And if you're using the default
settings for Secure Transport on

00:23:55.190 --> 00:23:59.150
Mountain Lion and iOS 5,
you might not be able to communicate

00:23:59.150 --> 00:24:01.520
with those older servers directly.

00:24:01.610 --> 00:24:04.850
We have a great tech note online
that goes into details about

00:24:04.850 --> 00:24:06.420
how you can adapt to that.

00:24:06.420 --> 00:24:09.570
So as I mentioned,
Secure Transport is heavily

00:24:09.570 --> 00:24:11.200
used by a web browser.

00:24:11.290 --> 00:24:17.580
So I'd kind of like to give you an idea
of how that stacks up in the system.

00:24:17.580 --> 00:24:17.580
So in this case, we have Safari.

00:24:17.820 --> 00:24:22.800
which is fundamentally relying upon the
CF network APIs for doing all of the

00:24:22.800 --> 00:24:26.140
networking and the HTTP on its behalf.

00:24:26.220 --> 00:24:31.750
In the case where you're actually
visiting an HTTPS server,

00:24:31.870 --> 00:24:35.950
CF Network is automatically going to
create an SSL context and perform all

00:24:35.950 --> 00:24:39.520
of the work to handshake with that
server on behalf of the application.

00:24:39.610 --> 00:24:43.390
And once it has that context in hand,
all of the actual data that's

00:24:43.390 --> 00:24:47.980
written over the network is
done using the SSL calls that we

00:24:47.980 --> 00:24:49.970
provide in the Security Framework.

00:24:50.640 --> 00:24:54.160
So I'd like to talk a little
bit about what that protocol

00:24:54.180 --> 00:24:56.290
behind TLS is actually doing.

00:24:56.320 --> 00:25:00.160
So in this case, we have an iPhone that's
talking to a web server.

00:25:00.160 --> 00:25:04.700
And the first thing the iPhone is
going to do is send a hello message.

00:25:04.700 --> 00:25:08.860
And the idea of the hello message is
that the client is telling the server,

00:25:08.890 --> 00:25:12.080
hey, I want to negotiate a
secure channel with you.

00:25:12.080 --> 00:25:15.640
And it's going to specify a handful of
things that the server needs to know,

00:25:15.900 --> 00:25:19.260
particularly the supported versions
of TLS that the client can speak.

00:25:19.340 --> 00:25:20.600
So it'll send a list of things
that the client needs to know.

00:25:20.620 --> 00:25:24.220
So it'll send a list of I speak
all of these different dialects.

00:25:24.220 --> 00:25:28.480
It's also going to tell the server,
here's the crypto that I know how to use,

00:25:28.480 --> 00:25:31.430
so a specific encryption protocol,
for example.

00:25:31.430 --> 00:25:34.970
Secure Transport also supports
the idea of encrypting data and

00:25:34.990 --> 00:25:37.400
compressing it for network efficiency.

00:25:37.410 --> 00:25:39.760
And so the client can
also tell the server,

00:25:39.830 --> 00:25:41.620
I know how to compress.

00:25:42.120 --> 00:25:46.420
At that point, the server is going to be
the person who decides,

00:25:46.420 --> 00:25:50.510
"Here is the actual version of TLS,
and here is the actual cipher

00:25:50.660 --> 00:25:53.940
that we're going to use for this
session." So it's going to respond

00:25:53.960 --> 00:25:57.930
with its own hello message with all
that information for the client.

00:25:58.880 --> 00:26:01.800
Something else the server is going
to include is the certificate.

00:26:01.860 --> 00:26:05.510
And the certificate is how
the server tells the client,

00:26:05.640 --> 00:26:09.290
here's who I am and here's
how you can trust me.

00:26:09.300 --> 00:26:12.690
Now, if you're doing something that we
call client-side authentication,

00:26:12.790 --> 00:26:16.230
the client is then going to
respond with its own certificate.

00:26:16.230 --> 00:26:18.940
And at that point,
both sides can use public key

00:26:18.940 --> 00:26:22.680
cryptography to then exchange a
symmetric key so that all of the

00:26:22.710 --> 00:26:26.210
data that travels between them
from that point on is encrypted.

00:26:27.180 --> 00:26:31.750
So, I'd now like to talk a little bit
about certificates and how those play

00:26:31.800 --> 00:26:36.450
into trust evaluation on the system
because it's heavily used by both Secure

00:26:37.090 --> 00:26:41.770
Transport and a lot of the technologies
that we use for signing applications.

00:26:42.080 --> 00:26:46.390
In particular,
a certificate contains the public key,

00:26:46.420 --> 00:26:49.870
and it also contains a set of
attributes that describe that public

00:26:49.870 --> 00:26:51.950
key and how it should be used.

00:26:52.000 --> 00:26:54.750
So, for example,
there are some public keys or key

00:26:54.870 --> 00:26:58.380
pairs that should only be used for SSL,
they should only be

00:26:58.380 --> 00:27:00.200
used for signing SMIME.

00:27:00.260 --> 00:27:03.500
All of that information is
included in the certificate,

00:27:03.530 --> 00:27:08.470
also including things like the
certificate should expire after one year.

00:27:09.310 --> 00:27:11.820
At that point, you have all of that
data in your certificate.

00:27:11.950 --> 00:27:18.890
It's then signed by the certificate that
issued what we call a leaf certificate.

00:27:18.900 --> 00:27:22.640
So, for example, you'll have a leaf
certificate like this one,

00:27:22.800 --> 00:27:25.700
and it's issued by a root certificate.

00:27:25.700 --> 00:27:28.620
The root certificate is associated
with its own private key,

00:27:28.930 --> 00:27:33.000
and that's what signed all of
the attributes in that leaf.

00:27:33.180 --> 00:27:37.100
And in fact, there are a number of root
certificates in the world.

00:27:37.500 --> 00:27:41.270
and on iOS and OS X,
the system ships with a set of

00:27:41.280 --> 00:27:45.080
default root certificates that
the system will trust by default

00:27:45.720 --> 00:27:48.420
that we call root anchors.

00:27:48.490 --> 00:27:51.400
So in particular,
the trust evaluation system that we've

00:27:51.400 --> 00:27:56.320
built into the Security Framework is
built on top of X.509 certificates.

00:27:56.320 --> 00:28:01.190
So this is an industry standard for,
it's the data format that the

00:28:01.190 --> 00:28:03.310
certificates are in and it's a

00:28:03.490 --> 00:28:04.700
Very extensive format.

00:28:04.700 --> 00:28:06.900
It has a lot of options.

00:28:06.910 --> 00:28:10.000
But in particular,
both iOS and OS X ship with a standard

00:28:10.000 --> 00:28:15.500
set of root anchors that the trust
evaluation engine will use by default.

00:28:15.570 --> 00:28:18.350
And of course,
our clients can specify a different

00:28:18.420 --> 00:28:20.160
set of root anchors to use.

00:28:20.910 --> 00:28:23.240
And fundamentally,
what trust evaluation is

00:28:23.240 --> 00:28:26.020
doing is evaluating what we
call a certificate chain.

00:28:26.100 --> 00:28:29.530
So when you sign something,
you're going to sign an object,

00:28:29.530 --> 00:28:32.930
and trust evaluation wants to
verify that signature matches

00:28:32.930 --> 00:28:36.240
the public key in your cert,
but it also is going to want

00:28:36.240 --> 00:28:40.210
to verify that that certificate
was issued ultimately by a root

00:28:40.210 --> 00:28:42.470
anchor that it was told to trust.

00:28:42.800 --> 00:28:46.730
And trust evaluation also supports
the concept of revocation.

00:28:46.730 --> 00:28:48.000
So keys can be lost.

00:28:48.000 --> 00:28:51.840
And in the case of a lost key,
at the point you're evaluating it,

00:28:51.840 --> 00:28:56.030
you want to find out, hey,
should I not trust this guy anymore?

00:28:56.030 --> 00:28:58.420
Because the data may have
been posted on the internet

00:28:58.420 --> 00:29:00.200
or otherwise been compromised.

00:29:00.200 --> 00:29:04.180
And we support two different
models of revocation.

00:29:04.180 --> 00:29:07.850
The first is called a
certificate revocation list.

00:29:07.870 --> 00:29:10.840
And this is usually a URL that's
included as one of those

00:29:10.840 --> 00:29:12.650
attributes in a certificate.

00:29:12.710 --> 00:29:16.580
So when the security framework
is evaluating a certificate,

00:29:16.580 --> 00:29:20.680
if a URL, if a CRL is specified,
the system is actually going to go

00:29:20.680 --> 00:29:25.400
out to that server that's hosting the
CRL and download it to the device.

00:29:25.400 --> 00:29:28.630
And what trust evaluation is
going to do at that point is take

00:29:28.630 --> 00:29:32.130
each of the certificates in the
chain and determine if any of them

00:29:32.130 --> 00:29:35.970
appear on that revocation list,
because then it will know that, oh,

00:29:35.970 --> 00:29:38.050
this guy's been revoked by its owner.

00:29:38.090 --> 00:29:39.950
We should no longer trust it.

00:29:41.500 --> 00:29:46.400
One of the issues with CRLs is that
they can grow unbounded over time.

00:29:46.500 --> 00:29:47.720
And so they can get pretty big.

00:29:47.720 --> 00:29:51.200
And the effort of manually walking
each certificate you want to check

00:29:51.200 --> 00:29:53.160
against that list can be expensive.

00:29:53.160 --> 00:29:59.230
So there's an alternate protocol
that we also support called OCSP.

00:29:59.240 --> 00:30:02.960
This stands for Online Certificate
Status Protocol.

00:30:03.600 --> 00:30:07.070
And the idea is that at the point in time
where you've got a set of certificates

00:30:07.070 --> 00:30:10.600
in a chain that you want to evaluate,
you're going to take those certs and talk

00:30:10.600 --> 00:30:13.360
directly to an OCSP responder and ask,
hey, are any of these

00:30:13.360 --> 00:30:14.760
certificates been revoked?

00:30:14.810 --> 00:30:16.180
Are they all still good?

00:30:19.090 --> 00:30:22.330
So I'd like to walk through a very
simplified example of what trust

00:30:22.330 --> 00:30:24.410
evaluation might actually look like.

00:30:24.550 --> 00:30:28.430
So when you buy an app on an iOS device
and you download it to your device,

00:30:28.500 --> 00:30:31.140
it's going to come
along with a signature.

00:30:31.140 --> 00:30:32.850
And it's also going
to have a certificate.

00:30:32.910 --> 00:30:36.650
So at the point that the
installer on iOS goes to evaluate,

00:30:36.650 --> 00:30:40.960
is this an application that it can trust,
it's first going to take a

00:30:40.960 --> 00:30:43.600
measurement of that application.

00:30:43.600 --> 00:30:48.560
And that is going to get it a message
digest that represents the actual

00:30:48.590 --> 00:30:48.980
data that it's going to be using.

00:30:49.000 --> 00:30:53.970
And then it's going to use the public
key in the certificate to perform an

00:30:53.970 --> 00:30:56.710
RSA verification on that signature.

00:30:56.710 --> 00:31:00.030
And fundamentally,
it's using that public key

00:31:00.030 --> 00:31:05.280
to decrypt the signature,
and then the message digest should match.

00:31:05.280 --> 00:31:07.240
But it's not done yet.

00:31:07.240 --> 00:31:09.480
At that point,
it now has a certificate that it

00:31:09.810 --> 00:31:13.290
then wants to evaluate against the
root certificate coming from Apple,

00:31:13.290 --> 00:31:17.260
so that you know that this came from
the App Store and not somewhere else.

00:31:17.260 --> 00:31:20.680
And of course, at any point,
along that chain,

00:31:20.680 --> 00:31:23.600
it might have to reach out to
a server to find out if any of

00:31:23.610 --> 00:31:25.280
these elements had been revoked.

00:31:25.350 --> 00:31:29.420
Now, if you'd like to take advantage of
trust evaluation in your application,

00:31:29.460 --> 00:31:32.560
the API that you want to learn
about is the SecTrust API.

00:31:32.560 --> 00:31:35.480
And we have a great reference
online that goes into a lot of

00:31:35.480 --> 00:31:38.980
good detail about how to take
advantage of it on both platforms.

00:31:38.980 --> 00:31:41.980
We also have an upcoming
session this Friday.

00:31:41.980 --> 00:31:46.630
It's going to go into a lot of really
good detail about how secure transport

00:31:46.630 --> 00:31:48.960
takes advantage of trust evaluation.

00:31:48.960 --> 00:31:52.200
and some practical examples
for what that looks like.

00:31:53.630 --> 00:31:56.830
So one of the things I want to
talk about is the cross-platform

00:31:57.000 --> 00:31:59.500
nature of the Security Framework.

00:31:59.700 --> 00:32:01.360
So we have a shared source space.

00:32:01.360 --> 00:32:05.400
So the same code that we use
for OS X is what we use on iOS.

00:32:05.400 --> 00:32:09.030
And in particular,
the crypto library is exactly the same.

00:32:09.140 --> 00:32:12.800
So what we submit for the
OS X train is the same for iOS,

00:32:12.800 --> 00:32:15.780
as well as our Secure Transport engine.

00:32:15.810 --> 00:32:21.760
So Secure Transport is the exact
same code on both platforms.

00:32:21.760 --> 00:32:23.580
And so in the cases of
these two technologies,

00:32:23.580 --> 00:32:23.580
we have a shared source space.

00:32:23.600 --> 00:32:24.220
So we have a shared source space.

00:32:24.220 --> 00:32:25.050
And so in the cases of
these two technologies,

00:32:25.050 --> 00:32:26.330
we're bug-for-bug compatible
between the two platforms.

00:32:26.350 --> 00:32:30.630
One thing to keep in mind, though,
is that the Security Framework

00:32:30.650 --> 00:32:35.100
on iOS is a subset of the overall
API that we make available on OS X.

00:32:37.070 --> 00:32:40.360
One specific difference that
I mentioned earlier is that iOS

00:32:40.360 --> 00:32:42.610
only supports a single Keychain.

00:32:42.670 --> 00:32:48.500
So it's the same physical Keychain
that the Security Framework is using

00:32:48.500 --> 00:32:52.260
to store all of the Keychain items
on behalf of those applications.

00:32:52.280 --> 00:32:56.180
And it's the Security Framework that's
enforcing all of the access control

00:32:56.180 --> 00:32:58.320
on behalf of all of the applications.

00:32:58.440 --> 00:33:03.170
And that includes both system
apps and third-party apps.

00:33:03.970 --> 00:33:09.190
Now, the API for interacting with the
Keychain on iOS is only the SecItem APIs.

00:33:09.380 --> 00:33:13.340
So the other APIs that are on
OS X for searching for other

00:33:13.740 --> 00:33:16.940
Keychains and then opening those,
because we only have a

00:33:16.950 --> 00:33:20.060
single Keychain on iOS,
those APIs aren't necessary.

00:33:20.060 --> 00:33:23.480
We do have a feature that is
only available on iOS that is not

00:33:23.480 --> 00:33:26.480
on OS X called Data Protection,
and I'd like to talk

00:33:26.570 --> 00:33:27.910
a little bit about it.

00:33:28.880 --> 00:33:32.170
So the idea of Data Protection is
to protect the user's data

00:33:32.170 --> 00:33:33.840
on a compromised device.

00:33:33.840 --> 00:33:37.350
So if a device has been attacked
and the security model has

00:33:37.360 --> 00:33:41.390
otherwise been exploited,
we still want to protect the user's data.

00:33:41.400 --> 00:33:46.100
And the way we do that is that every
single file that is created on an

00:33:46.110 --> 00:33:51.190
iOS device is given its own AES key,
its own randomly generated AES key

00:33:51.190 --> 00:33:53.760
at the time the file is created.

00:33:53.760 --> 00:33:57.040
And this is the same for
every Keychain item as well.

00:33:57.060 --> 00:33:58.860
So when a file is released,
it's not a keychain.

00:33:58.860 --> 00:33:59.630
It's written to disk.

00:33:59.700 --> 00:34:03.720
It's written and stored on
disk using that AES key.

00:34:03.740 --> 00:34:08.280
So the only thing that's actually
stored in Flash is the ciphertext.

00:34:08.280 --> 00:34:11.610
And this is the same for every
single Keychain item as well.

00:34:11.620 --> 00:34:15.390
And the way that we protect the
data in the event of a compromised

00:34:15.390 --> 00:34:19.600
device is those keys are then
protected with the user's passcode.

00:34:19.600 --> 00:34:22.190
So when you enable a
passcode on an iOS device,

00:34:22.190 --> 00:34:25.500
what we're fundamentally doing
under the hood is taking all

00:34:25.520 --> 00:34:28.840
of those keys associated with
all the files and Keychain,

00:34:28.840 --> 00:34:31.910
and wrapping them with your passcode.

00:34:31.960 --> 00:34:35.380
The benefit of this approach is
that when the user does enable

00:34:35.380 --> 00:34:38.570
that feature on an iOS device,
we don't have to go back and

00:34:38.570 --> 00:34:41.870
re-encrypt any of the files or
Keychain items because all of

00:34:41.870 --> 00:34:44.130
that's already been done by default.

00:34:44.280 --> 00:34:47.570
We just have to re-wrap
some of those keys.

00:34:47.780 --> 00:34:50.730
Now we do support different
classes of protection.

00:34:50.750 --> 00:34:54.700
And this is because on an iOS device,
there are certain files that the

00:34:54.700 --> 00:34:58.850
operating system needs access to in order
to boot up and bring up that lock screen.

00:34:58.850 --> 00:35:02.140
A good example might be the
actual wallpaper that you chose.

00:35:02.140 --> 00:35:04.300
We want to be able to display
that even if the user hasn't

00:35:04.300 --> 00:35:05.460
unlocked the device yet.

00:35:06.370 --> 00:35:09.150
So we have a particular
class of protection,

00:35:09.150 --> 00:35:13.250
which is for the subset of files
so that when the device boots up,

00:35:13.250 --> 00:35:16.960
those keys are made available
to the system directly.

00:35:16.960 --> 00:35:21.840
We also have a set of keys that are
available after the first unlocks.

00:35:21.840 --> 00:35:24.020
When you unlock your
device for the first time,

00:35:24.050 --> 00:35:27.680
those keys are going to be available
even if the user later locks his device.

00:35:27.680 --> 00:35:30.780
And this is useful for
system applications that are

00:35:30.840 --> 00:35:33.300
running in the background,
like mail,

00:35:33.300 --> 00:35:35.980
which is able to go and download files.

00:35:35.980 --> 00:35:37.820
So you can download files or
download your email even if

00:35:37.820 --> 00:35:38.860
the device has been locked.

00:35:38.860 --> 00:35:42.350
The best level of protection
that we offer is a mode where

00:35:42.350 --> 00:35:45.990
when the device is locked,
all of the keys associated with

00:35:45.990 --> 00:35:50.710
those items are erased from memory
after a 10-second grace period.

00:35:50.720 --> 00:35:54.240
Now there are a couple of
features that we do not support

00:35:54.240 --> 00:35:56.220
in the Security Framework.

00:35:56.250 --> 00:35:57.580
The first is DRM.

00:35:57.600 --> 00:36:01.720
So we don't have any APIs for
performing any type of digital

00:36:01.720 --> 00:36:04.300
rights management on iOS or OS X.

00:36:05.680 --> 00:36:09.680
The second is the we don't support
the concept of jailbreak detection.

00:36:09.680 --> 00:36:14.120
And the issue here is that if
there were an interface that your

00:36:14.120 --> 00:36:15.680
application could call to say,
"Hey, am I on a jailbroken iPhone?"

00:36:15.680 --> 00:36:21.500
it would be very easy for a
compromised device to simply lie.

00:36:21.500 --> 00:36:24.500
And so either way, we can't support that.

00:36:24.500 --> 00:36:28.490
So in summary,

00:36:29.100 --> 00:36:33.590
We talked a lot about the actual
crypto that we support on the device

00:36:33.650 --> 00:36:39.530
and how all of that has been collected
into a unified common crypto library

00:36:39.740 --> 00:36:43.200
that is primary focus is to be as
fast and efficient as possible.

00:36:43.200 --> 00:36:46.100
And of course,
if you need to use the cryptography,

00:36:46.100 --> 00:36:49.070
we highly recommend that you
focus on the higher level

00:36:49.080 --> 00:36:51.040
SecKey and SecTransform APIs.

00:36:51.040 --> 00:36:55.290
We talked about the Keychain and how
that is used by applications to protect

00:36:55.330 --> 00:36:57.870
the user's passcodes and other secrets.

00:36:59.780 --> 00:37:03.590
We talked about Secure Transport and
how clients of the Security Framework

00:37:03.610 --> 00:37:09.290
can use that to protect data as it
travels over the network between devices.

00:37:09.580 --> 00:37:14.500
We talked about trust evaluation
and how technologies like Secure

00:37:14.500 --> 00:37:18.720
Transport and application signing
rely upon it to know that it can

00:37:18.720 --> 00:37:21.720
trust digitally signed objects.

00:37:22.120 --> 00:37:24.850
And we talked about the data
protection feature in iOS and how it

00:37:24.920 --> 00:37:29.670
can help to protect the customer's
data on a compromised device.

00:37:30.270 --> 00:37:33.690
So we have a lot of really good
references online if you'd like to learn

00:37:33.690 --> 00:37:38.070
more about all of the technologies that
are available in the Security Framework.

00:37:38.260 --> 00:37:42.400
In particular, we have two really good
introductions to the API set,

00:37:42.480 --> 00:37:46.540
as well as a secure coding guide so
that you can make your own application

00:37:46.540 --> 00:37:49.030
as resistant to attack as possible.

00:37:49.130 --> 00:37:52.370
And last month,
we also introduced a document

00:37:52.380 --> 00:37:56.690
that goes into greater detail
on the iOS Security model.

00:37:58.400 --> 00:38:01.440
If you have more information,
I highly recommend that you take

00:38:01.500 --> 00:38:04.240
advantage of our Apple Developer Forums.

00:38:04.240 --> 00:38:06.950
So if you have specific questions
about how things behave,

00:38:06.950 --> 00:38:10.530
other developers and
Apple engineers are on those forums.

00:38:10.630 --> 00:38:13.740
We also have our evangelist,
Paul Danbold.

00:38:13.930 --> 00:38:18.110
So if you have other specific questions,
please feel free to contact him.

00:38:18.590 --> 00:38:22.180
There are a number of really great
sessions that are going into some greater

00:38:22.180 --> 00:38:26.970
detail on these technologies and others
that we make available on both platforms.

00:38:27.120 --> 00:38:31.780
So if you missed any of these talks,
we highly recommend that

00:38:31.780 --> 00:38:33.460
you can catch them online.

00:38:33.550 --> 00:38:38.150
The app sandbox talk in particular
will be repeated this Friday.

00:38:38.220 --> 00:38:41.070
We also have a very good talk
about privacy support on both

00:38:41.090 --> 00:38:44.770
platforms and how your applications
can take advantage of that.

00:38:44.930 --> 00:38:48.840
And then this Friday we have another
talk called Protecting the User's Data,

00:38:48.870 --> 00:38:51.500
which is going to give very
practical examples of how secure

00:38:51.500 --> 00:38:56.660
transport and data protection
can be used by your applications.

00:38:56.710 --> 00:38:58.860
And thank you very much.
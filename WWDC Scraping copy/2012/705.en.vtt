WEBVTT

00:00:10.730 --> 00:00:12.340
Good afternoon and welcome.

00:00:12.360 --> 00:00:14.450
My name is Joakiim Linde and
I'm here to talk to you about

00:00:14.450 --> 00:00:16.970
the Core Bluetooth framework.

00:00:18.050 --> 00:00:22.150
In iOS 5, we introduced the
Core Bluetooth framework with

00:00:22.150 --> 00:00:24.460
support for Bluetooth Low Energy.

00:00:24.610 --> 00:00:28.220
We got a tremendous response from you,
so thank you,

00:00:28.250 --> 00:00:32.780
especially from the sports and fitness
industry and the mobile health industry.

00:00:32.940 --> 00:00:38.380
In iOS 6, we're introducing some new and
exciting functionality targeted towards

00:00:38.380 --> 00:00:41.020
social media and proximity sensing.

00:00:41.130 --> 00:00:45.250
At the end of this presentation,
you will see a demonstration showing

00:00:45.250 --> 00:00:51.500
two iPhones exchanging data wirelessly,
triggered by proximity sensing.

00:00:51.610 --> 00:00:55.260
We think this is very exciting,
and we're sure this will

00:00:55.260 --> 00:00:58.240
help your application and the
relationship that you're trying

00:00:58.410 --> 00:01:00.220
to build with app developers.

00:01:00.340 --> 00:01:03.680
But before we show the demo,
I'd like to introduce to you

00:01:03.940 --> 00:01:06.020
the Core Bluetooth framework.

00:01:07.430 --> 00:01:10.670
We'll start with covering
the object model.

00:01:11.040 --> 00:01:14.580
Brian talked a little bit about
this in the morning session.

00:01:14.710 --> 00:01:17.680
Then we're going to talk
about the two roles:

00:01:17.820 --> 00:01:22.110
the central role, that's also the client,
and the peripheral role,

00:01:22.150 --> 00:01:23.700
that's the server.

00:01:23.820 --> 00:01:26.800
After that,
we're going to dive in and talk a little

00:01:26.800 --> 00:01:29.600
bit about tips and tricks and reminders.

00:01:29.720 --> 00:01:33.850
We got a lot of feedback from you
guys over the past year about this.

00:01:34.160 --> 00:01:37.460
We're going to move on and
talk about iOS backgrounding,

00:01:37.600 --> 00:01:42.900
how to discover devices efficiently,
and this concept called pairing.

00:01:43.100 --> 00:01:45.500
Then we're going to wrap up with a demo.

00:01:46.480 --> 00:01:49.140
So let's dive right in.

00:01:49.260 --> 00:01:56.440
The Core Bluetooth implements support for
the Bluetooth low energy protocol stack.

00:01:57.090 --> 00:01:58.950
We're not going to bore you
with all the details of the

00:01:59.020 --> 00:02:02.990
Bluetooth low energy stack.

00:02:03.100 --> 00:02:06.620
We've taken care of all of
that so you can focus on just

00:02:06.890 --> 00:02:08.880
using it in your application.

00:02:08.900 --> 00:02:14.210
And the Core Bluetooth framework
provides a fairly complete API so

00:02:14.210 --> 00:02:20.340
your application can make use of
the Bluetooth low energy technology.

00:02:20.730 --> 00:02:24.270
The key thing with the
Core Bluetooth framework is it gives you,

00:02:24.410 --> 00:02:27.600
the app developer,
control over almost everything.

00:02:27.600 --> 00:02:33.350
It puts the application in total
control so it can make use of the

00:02:33.350 --> 00:02:36.590
Bluetooth Low Energy as best as possible.

00:02:39.200 --> 00:02:41.740
So let's dive in and take a
look at some key concepts.

00:02:41.760 --> 00:02:47.800
We have the central role and
then we have the peripheral role.

00:02:48.000 --> 00:02:54.340
The central role is normally implemented
on a Mac or on an iPhone or an iPad.

00:02:54.400 --> 00:02:58.930
And the peripheral role is, for instance,
a heart rate monitor or some other

00:02:59.140 --> 00:03:02.060
accessibility or some other accessory.

00:03:02.110 --> 00:03:07.500
New in iOS 6 is that we now
support for the peripheral

00:03:07.930 --> 00:03:10.840
role built into iOS as well.

00:03:11.060 --> 00:03:14.270
So the peripheral is
the one serving up data.

00:03:14.270 --> 00:03:17.400
So it acts as the server.

00:03:17.440 --> 00:03:20.290
And the central is the
one consuming the data.

00:03:21.300 --> 00:03:22.630
And this acts as the client.

00:03:22.630 --> 00:03:26.600
This is a similar relationship
as we have with web browsing,

00:03:26.820 --> 00:03:30.800
where the web server serves the data
and we as the client gets the data.

00:03:30.980 --> 00:03:34.970
How do we implement this on the
Core Bluetooth object framework?

00:03:35.110 --> 00:03:39.480
The central side is represented
by a CB central manager object.

00:03:39.720 --> 00:03:42.430
This is the object where you
control your local central.

00:03:42.440 --> 00:03:48.810
The remote side, the peripheral,
is represented by a CB peripheral object.

00:03:48.810 --> 00:03:54.920
The same way on the peripheral side
we have a CB peripheral manager that

00:03:54.920 --> 00:03:57.360
implements the local peripheral.

00:03:57.360 --> 00:03:59.520
And this is the object that
you interact with when you try

00:03:59.600 --> 00:04:00.960
to interact with your client.

00:04:00.980 --> 00:04:04.270
You interact with this
peripheral on your local device.

00:04:04.270 --> 00:04:07.980
And the remote side,
the CB central in this case,

00:04:07.980 --> 00:04:10.180
is represented by the CB central object.

00:04:10.420 --> 00:04:16.490
So that was the main objects of
the Core Bluetooth object model.

00:04:17.780 --> 00:04:20.050
As Brian mentioned in the earlier talk,
we have a couple of

00:04:20.060 --> 00:04:21.300
other objects as well.

00:04:21.400 --> 00:04:23.300
Data objects.

00:04:23.380 --> 00:04:28.510
And this is where we have to introduce
the concept of a characteristic

00:04:29.010 --> 00:04:30.380
and the service.

00:04:30.400 --> 00:04:34.090
A characteristic is basically
a fancy name for a variable.

00:04:34.090 --> 00:04:36.500
And the variable has a value.

00:04:36.620 --> 00:04:42.030
You can take these characteristics and
group them together into a service.

00:04:42.030 --> 00:04:46.240
And we use the CB service
object to represent that group.

00:04:46.380 --> 00:04:51.270
We also have immutable versions of
these and mutable versions of them.

00:04:52.100 --> 00:04:54.140
and we're going to take a look
at the mutable versions when we

00:04:54.360 --> 00:04:56.000
dive into the peripheral side.

00:04:56.000 --> 00:05:00.000
We also have a couple of helper objects.

00:05:00.610 --> 00:05:05.000
Everything is represented
by UUIDs in Core Bluetooth.

00:05:05.100 --> 00:05:09.000
So we have a dedicated object for that,
the CBUUID object.

00:05:09.110 --> 00:05:13.500
And then we have a request object that
you get when you do read and write.

00:05:13.510 --> 00:05:14.990
So we're going to get to those in a sec.

00:05:15.000 --> 00:05:17.990
So let's dive in and look at the central.

00:05:18.160 --> 00:05:20.500
There's three easy steps.

00:05:20.800 --> 00:05:24.120
First one is, you have to discover

00:05:24.200 --> 00:05:45.400
[Transcript missing]

00:05:45.790 --> 00:05:50.420
running iOS 6,
or even a thermostat that's

00:05:50.530 --> 00:05:52.200
sitting on the wall in this room.

00:05:52.340 --> 00:05:55.740
All of these devices can be peripherals.

00:05:55.830 --> 00:05:59.770
They all send out advertising packets.

00:06:00.820 --> 00:06:02.550
So we can find them.

00:06:02.550 --> 00:06:03.570
And they sit there.

00:06:03.640 --> 00:06:06.700
The heart rate monitor sends
out an advertising packet.

00:06:06.700 --> 00:06:10.700
The iOS 6 device sends out advertising
packets if it's in peripheral mode.

00:06:10.700 --> 00:06:14.300
Or the thermostat on the wall sends
out these advertising packets.

00:06:14.410 --> 00:06:16.700
That's how we find these devices.

00:06:16.700 --> 00:06:19.980
And we as a central in this case,
just sit back,

00:06:20.030 --> 00:06:24.010
open up a receiver and start
listening for these devices,

00:06:24.130 --> 00:06:26.290
these advertising packets.

00:06:26.930 --> 00:06:31.540
So how would we implement the central
role in the Core Bluetooth framework?

00:06:31.650 --> 00:06:35.600
Well,
it's a fully asynchronous interface.

00:06:35.740 --> 00:06:39.290
So we have our CB central manager object,
and it has a delegate

00:06:39.450 --> 00:06:41.540
where we get the callback.

00:06:41.650 --> 00:06:43.820
And we start by saying,

00:06:44.140 --> 00:06:52.480
calling the method scan for peripherals
with services on the CB Central Manager.

00:06:54.150 --> 00:06:56.660
When we call this,
we can say we can scan for every single

00:06:56.660 --> 00:07:00.100
devices that are out there and we get
to receive all advertising packets,

00:07:00.250 --> 00:07:02.020
or we can be a little bit
smart about it and say,

00:07:02.190 --> 00:07:06.420
I'm only interested in devices
that has a certain service,

00:07:06.420 --> 00:07:08.600
and that service is
represented by a UUID.

00:07:08.740 --> 00:07:13.350
So for instance, if I'm only looking for
heart rate monitor belts,

00:07:13.350 --> 00:07:17.480
I just specify the UUID for
heart rate monitor service.

00:07:17.670 --> 00:07:20.800
The radio will go off and start
listening for these devices

00:07:20.850 --> 00:07:23.610
and do the filtering for you.

00:07:24.120 --> 00:07:27.010
and you're going to get
a number of callbacks,

00:07:27.010 --> 00:07:30.120
one for each advertising
packet that we receive.

00:07:30.200 --> 00:07:31.760
Did discover peripheral.

00:07:31.860 --> 00:07:34.330
With that callback,
we also get a CB peripheral

00:07:34.410 --> 00:07:40.310
object that you can use if you
want to connect to this device.

00:07:40.880 --> 00:07:44.730
Once you've found a device
that you're interested in,

00:07:44.850 --> 00:07:46.810
you stop scanning.

00:07:47.120 --> 00:07:51.280
So we don't have to spend any
power opening up our radio anymore,

00:07:51.280 --> 00:07:53.400
listening for devices.

00:07:53.460 --> 00:07:56.680
And call Connect Peripheral,
supplying the CP peripheral

00:07:56.680 --> 00:08:01.710
that you just got with the
Did Discover Peripheral callback.

00:08:01.860 --> 00:08:05.550
Since we just recently saw this device,
we now know that it's fairly close

00:08:05.670 --> 00:08:09.400
by and setting up a connection to
it is going to be fairly quick.

00:08:09.510 --> 00:08:12.160
And once a connection is set up,
you get a callback,

00:08:12.160 --> 00:08:16.030
"Did connect peripheral?"
We've discovered the device,

00:08:16.030 --> 00:08:20.030
we've set up a connection to it,
and we're now ready to

00:08:20.600 --> 00:08:23.300
start exploring this device.

00:08:23.480 --> 00:08:27.750
So, as Brian talked about in the morning,
this peripheral contains a tree structure

00:08:27.890 --> 00:08:30.500
of services and characteristics.

00:08:30.570 --> 00:08:33.790
And what we're going to do is
try to replicate that or copy

00:08:33.790 --> 00:08:37.100
that tree structure to our local
device so we can start interacting.

00:08:37.150 --> 00:08:41.380
We're going to use these objects
so we can read and write to them.

00:08:42.020 --> 00:08:45.990
As an example of that is, for instance,
in a heart rate monitor,

00:08:45.990 --> 00:08:49.440
you can have a service,
the heart rate monitor service.

00:08:49.440 --> 00:08:52.900
It can have two
characteristics or variables,

00:08:52.980 --> 00:08:57.040
one of them being the heart
rate and the second one being

00:08:57.040 --> 00:08:59.320
the body sensor location.

00:08:59.320 --> 00:09:03.520
This is where on your body this
heart rate monitor is located.

00:09:03.520 --> 00:09:07.400
It could be over the chest, on your arm,
on your finger, on your hand,

00:09:07.460 --> 00:09:08.440
earlobe or foot.

00:09:08.520 --> 00:09:11.720
Let's see how we do
this in Core Bluetooth.

00:09:11.720 --> 00:09:14.560
Now we're going to start
interacting with the CB peripheral

00:09:15.050 --> 00:09:18.170
object that we got earlier.

00:09:18.840 --> 00:09:22.700
and we call the method Discover Services.

00:09:22.720 --> 00:09:27.640
We can of course ask for all services,
but we can be smart about it.

00:09:27.710 --> 00:09:30.830
If we're just interested in
the heart rate monitor service,

00:09:30.830 --> 00:09:33.070
we just ask for that specific service.

00:09:33.390 --> 00:09:36.840
Core Bluetooth now goes over
the air and gets the data

00:09:36.840 --> 00:09:41.400
back and you get a call back,
"Did discover services?" Now you

00:09:41.400 --> 00:09:45.720
can call "Discover characteristics
for service" and asking the system

00:09:45.760 --> 00:09:48.560
to fetch all the characteristics,
or in the heart rate monitor case,

00:09:48.630 --> 00:09:50.340
the two characteristics.

00:09:50.430 --> 00:09:54.520
Ask the system to fetch those
and once those are available,

00:09:54.520 --> 00:09:57.930
you get "Did discover characteristics?"

00:09:58.610 --> 00:10:03.420
Next, we're going to take a look at
how to interact with a device.

00:10:03.620 --> 00:10:07.600
So now we have set up a connection to it,
we discover the services,

00:10:07.710 --> 00:10:12.180
and now we take one of these
characteristics that's under a service,

00:10:12.310 --> 00:10:16.410
and we can start reading
and writing that variable.

00:10:17.590 --> 00:10:21.400
So for instance,
if I want to read where on my body

00:10:21.400 --> 00:10:25.330
this body sensor location is located,
I can call read value

00:10:25.450 --> 00:10:26.760
for characteristics.

00:10:26.980 --> 00:10:30.750
The read request goes out to the device,
fetches the value for that

00:10:30.750 --> 00:10:34.270
variable or characteristic,
and you get a callback,

00:10:34.270 --> 00:10:37.130
did update value for characteristic.

00:10:37.200 --> 00:10:40.580
And that works fine if you're
just going to read it once.

00:10:40.730 --> 00:10:44.990
But in the case of my heart rate,
I don't really want to

00:10:45.120 --> 00:10:47.060
read it every single time.

00:10:47.890 --> 00:10:52.360
Instead, I'd like the heart rate monitor
to send me an updated value

00:10:52.360 --> 00:10:54.300
whenever there is an updated value.

00:10:54.480 --> 00:10:59.630
Normally, heart rate monitors measure the
heart rate about once a second.

00:11:00.000 --> 00:11:04.120
So I want to tell the heart rate monitor
that I'm interested in this value,

00:11:04.120 --> 00:11:07.890
so please notify me when it changes.

00:11:08.990 --> 00:11:13.240
So I do that by calling the method
setNotifyValue for characteristic.

00:11:13.270 --> 00:11:16.790
Now the heart rate monitor knows
that whenever the heart rate

00:11:16.850 --> 00:11:20.610
monitor changes or whenever I have
a new measurement for this value,

00:11:21.070 --> 00:11:26.640
You get a callback, "Did update value for
characteristic?" This is kind of cool.

00:11:26.640 --> 00:11:28.760
Your application just sits
back and relaxes and waits

00:11:28.760 --> 00:11:30.000
for these values to come in.

00:11:30.000 --> 00:11:34.000
You don't have to worry about, "Oh,
should I pull it again?" and all this.

00:11:34.000 --> 00:11:36.000
So instead, sit back, relax.

00:11:36.000 --> 00:11:38.830
When there's a new value coming in,
you can update the UI,

00:11:39.300 --> 00:11:41.980
you can log this value,
do what you want with it.

00:11:42.000 --> 00:11:49.000
So far we talked about how to discover,
explore, and interact with a device.

00:11:49.000 --> 00:11:52.990
Now we're going to talk about
how to reconnect to a device.

00:11:53.030 --> 00:11:55.300
So there's three ways.

00:11:56.300 --> 00:11:57.210
to reconnect to a device.

00:11:57.410 --> 00:12:00.320
The first one is scan and connect.

00:12:00.360 --> 00:12:01.830
And this is what we just did.

00:12:01.920 --> 00:12:06.840
We scanned for the device to see if
it's around and then connected to it.

00:12:06.970 --> 00:12:10.760
The second is you can reconnect
to this device using a UUID.

00:12:10.950 --> 00:12:14.810
And you go UUID again.

00:12:14.810 --> 00:12:18.180
Would it be better to use a
Bluetooth address here and refer to it?

00:12:18.290 --> 00:12:23.700
Well, Bluetooth addressing is kind of
complicated in Bluetooth Low Energy.

00:12:23.830 --> 00:12:27.260
The address changes over time and
we do that to obfuscate things.

00:12:27.400 --> 00:12:32.240
So instead we've abstracted all of
this away for you and all you need

00:12:32.240 --> 00:12:34.940
is a UUID to represent that device.

00:12:35.010 --> 00:12:38.660
You can take this UUID,
store it somewhere,

00:12:38.780 --> 00:12:41.600
and then a couple of days
later come back and say I want

00:12:41.600 --> 00:12:43.440
to reconnect to this device.

00:12:43.510 --> 00:12:48.200
And the third way is another
app running on the phone.

00:12:48.290 --> 00:12:51.550
And the phone might already have set
up a connection to that peripheral.

00:12:51.690 --> 00:12:54.600
So you can go and ask what
other connections exist and

00:12:54.600 --> 00:12:55.990
maybe I should use one of those.

00:12:56.120 --> 00:12:57.810
So let's dive in and take
a look at number two,

00:12:57.940 --> 00:13:01.880
how we would do that in the
Khrob Bluetooth framework.

00:13:02.000 --> 00:13:07.560
Option three, I let you guys do that
as an exercise at home.

00:13:07.670 --> 00:13:12.790
So we have this UUID representing the
peripheral that we want to connect to.

00:13:12.920 --> 00:13:16.770
Now I need to take that
UUID and go to a factory.

00:13:17.050 --> 00:13:22.020
So they can produce a CB peripheral
object for me that I can use

00:13:22.090 --> 00:13:24.000
to call connect peripheral.

00:13:24.070 --> 00:13:27.460
And the way I do that is
I call retrieve peripherals,

00:13:27.480 --> 00:13:31.600
supplying the UUID of the
device that I'm interested in.

00:13:31.760 --> 00:13:35.680
And I get a call back,
did retrieve peripherals.

00:13:36.090 --> 00:13:42.600
with a CB peripheral object that I now
can take and call Connect Peripheral.

00:13:42.710 --> 00:13:47.000
Since we didn't see the
peripheral through advertising,

00:13:47.070 --> 00:13:49.400
we don't know if that
peripheral is around.

00:13:49.500 --> 00:13:52.380
So when you call Connect Peripheral,
that could take a while.

00:13:52.510 --> 00:13:57.200
It could take an hour, a day,
or even a week.

00:13:57.270 --> 00:14:02.900
The cool thing with this is next time
iOS sees this device somewhere around,

00:14:03.010 --> 00:14:05.050
we will call

00:14:05.280 --> 00:14:08.430
So your application gets to know that
the peripheral is now available and

00:14:08.460 --> 00:14:11.150
you can start doing data with it.

00:14:11.930 --> 00:14:15.990
So far, we've been very much
focused on the central side.

00:14:16.040 --> 00:14:17.960
The central could be a Mac or an iPhone.

00:14:18.150 --> 00:14:20.670
What we're going to do now is move
on and take a look at the peripheral

00:14:20.670 --> 00:14:27.280
side and how we can implement the
peripheral side on an iOS 6 device.

00:14:29.170 --> 00:14:33.900
So implementing a peripheral device
allows a Mac to talk to an iPhone.

00:14:33.920 --> 00:14:37.560
It also allows an iPhone
to talk to another iPhone.

00:14:37.680 --> 00:14:41.490
And the cool thing is,
this is while your app

00:14:41.500 --> 00:14:43.180
is in the background.

00:14:43.390 --> 00:14:45.320
We're going to talk a little
bit later about more about

00:14:45.320 --> 00:14:48.090
backgrounding and how that is done.

00:14:48.180 --> 00:14:50.400
Let's start with taking a
look at how we're going to

00:14:50.400 --> 00:14:52.060
implement the peripheral side.

00:14:52.250 --> 00:14:54.100
So there's three easy steps.

00:14:54.210 --> 00:14:58.100
The first one is we have to build our
tree with services and characteristics.

00:14:58.160 --> 00:15:00.880
The second one is we have to
take that tree and publish

00:15:00.960 --> 00:15:04.100
it and start advertising,
sending out these advertising packets.

00:15:04.100 --> 00:15:08.910
And the third thing is sit back and wait
for the read request or write request

00:15:09.010 --> 00:15:14.210
to come in for these variables and
characteristics that we just published.

00:15:15.000 --> 00:15:17.040
So the first thing is we
have to build the tree.

00:15:17.040 --> 00:15:20.530
And this is where the new
CBMutable services and CBMutable

00:15:20.530 --> 00:15:22.890
characteristics comes in place.

00:15:23.100 --> 00:15:26.220
So we start by instantiating
a CBMutable service,

00:15:26.260 --> 00:15:29.710
and then we instantiate one CBMutable
characteristic for each of the

00:15:29.710 --> 00:15:32.590
variables that we would like to publish.

00:15:33.300 --> 00:15:35.880
So these variables,
we can have static data

00:15:35.880 --> 00:15:39.000
in those variables,
and we can have dynamic

00:15:39.010 --> 00:15:41.600
data in those variables.

00:15:41.720 --> 00:15:44.550
If it's static data,
we can supply it with the

00:15:44.550 --> 00:15:45.710
tree when we build it.

00:15:45.910 --> 00:15:47.070
It's not going to change.

00:15:47.140 --> 00:15:49.980
We can just attach it up
at that point in time.

00:15:50.100 --> 00:15:53.700
That means that CoreOS,
if there's a read request coming in,

00:15:53.700 --> 00:15:56.320
Core Bluetooth will take
care of that read request and

00:15:56.410 --> 00:15:59.800
respond to that automatically.

00:15:59.900 --> 00:16:02.190
If you have dynamic data,

00:16:02.720 --> 00:16:05.300
You can't really supply it at this point.

00:16:05.330 --> 00:16:08.390
So for instance,
in the heart rate monitor case,

00:16:08.390 --> 00:16:11.960
you just supply nil and the
Core Bluetooth framework will

00:16:12.310 --> 00:16:15.960
give you a callback when that data
is being asked for and you can

00:16:15.960 --> 00:16:17.840
supply it at that point in time.

00:16:18.010 --> 00:16:21.730
So next is we have to start
advertising to the world,

00:16:21.960 --> 00:16:26.730
tell the world we put this nice tree
together and start advertising it,

00:16:26.730 --> 00:16:29.280
sending out these advertising packets.

00:16:29.460 --> 00:16:31.200
How do we do that in Core Bluetooth?

00:16:31.330 --> 00:16:32.800
Well,
now we're going to start interacting

00:16:32.800 --> 00:16:35.470
with the CB Peripheral Manager.

00:16:36.060 --> 00:16:38.180
We're going to call add service.

00:16:38.320 --> 00:16:41.960
We're going to supply the tree
that we just bid with the service

00:16:41.960 --> 00:16:43.280
and the number of characteristics.

00:16:43.280 --> 00:16:46.300
Core Bluetooth then goes off and
does some checking on it and makes

00:16:46.410 --> 00:16:49.650
sure that everything is fine and
you get a callback saying "did add

00:16:49.650 --> 00:16:52.030
service". Now the tree is installed.

00:16:52.080 --> 00:16:55.640
Now we need to start sending
out these advertising packets.

00:16:55.640 --> 00:16:59.000
We do that by calling start advertising.

00:16:59.000 --> 00:17:02.060
You also supply the content
of the advertising packets

00:17:02.060 --> 00:17:03.640
that are going to be sent out.

00:17:03.690 --> 00:17:05.720
We're going to talk about that
in a couple of slides later.

00:17:06.100 --> 00:17:06.580
But for now...

00:17:08.070 --> 00:17:11.040
Here's how you start sending
out the advertising packets.

00:17:11.080 --> 00:17:13.100
You get a notification
coming back saying,

00:17:13.100 --> 00:17:15.820
"Did start advertising,"
and you're all set.

00:17:15.870 --> 00:17:17.980
You publish your tree.

00:17:18.300 --> 00:17:20.960
You started advertising,
now you're ready to just sit back

00:17:20.960 --> 00:17:22.800
and wait for requests coming in.

00:17:22.960 --> 00:17:27.420
So we have this peripheral,
it's an iOS 6 device,

00:17:27.420 --> 00:17:34.130
sending out advertising
packets to another iPhone.

00:17:34.390 --> 00:17:38.500
That other iPhone says, "Oh,
this looks like an interesting device.

00:17:38.500 --> 00:17:42.020
I'll set up a connection to
it and start exploring it,

00:17:42.020 --> 00:17:45.560
see what services and
characteristics is available there."

00:17:46.540 --> 00:17:49.940
Until it hits a characteristic
that has dynamic data in it,

00:17:49.950 --> 00:17:52.220
and in that case it has to start
asking your application for

00:17:52.300 --> 00:17:54.900
what the value of that data is.

00:17:54.990 --> 00:18:01.110
Your application starts with getting
a notification on the delegate saying

00:18:01.210 --> 00:18:06.300
"Central did connect". And then when it's
a read to one of these dynamic variables,

00:18:06.300 --> 00:18:09.980
you get a "Did receive read request".
This is the time when you take

00:18:09.980 --> 00:18:13.730
the request and you respond to it,
respond to request,

00:18:13.730 --> 00:18:15.550
and you supply the value.

00:18:15.730 --> 00:18:20.230
This loop can continue
now for a number of times.

00:18:20.330 --> 00:18:23.660
It can read one characteristic or
read a number of characteristics

00:18:24.050 --> 00:18:26.510
until the central says,
I've got the information

00:18:26.510 --> 00:18:29.300
that I was looking for,
and it disconnects.

00:18:29.300 --> 00:18:31.170
And you get a notification
about that as well.

00:18:31.220 --> 00:18:32.380
Central did disconnect.

00:18:33.220 --> 00:18:36.160
We talked about earlier that there
is another way of doing this,

00:18:36.160 --> 00:18:39.440
that you can actually subscribe
to these notifications instead.

00:18:39.440 --> 00:18:42.260
So the way that is done in
Core Bluetooth is that you see

00:18:42.400 --> 00:18:47.400
that the central connected,
you get a call, central did connect.

00:18:47.940 --> 00:18:51.450
And then a center can say,
I want to know whenever this

00:18:51.590 --> 00:18:54.610
characteristic or this variable changes.

00:18:54.820 --> 00:18:57.570
You get to know,
because a delegate will be called,

00:18:57.570 --> 00:19:00.710
the did subscribe to characteristic
delegate will be called.

00:19:01.030 --> 00:19:05.110
That's a cue to your app to
start supplying updates to this

00:19:05.190 --> 00:19:08.340
variable on a regular basis to
the central on the other device.

00:19:08.420 --> 00:19:10.800
And you do that by calling update value.

00:19:10.800 --> 00:19:15.290
You can do that a number of
times until the central says,

00:19:15.330 --> 00:19:17.990
it's time for me to
disconnect and go away.

00:19:18.060 --> 00:19:20.960
So you get a notification saying
the central did disconnect.

00:19:22.180 --> 00:19:24.270
And at that point,
there's no one interested

00:19:24.270 --> 00:19:27.260
in this value anymore,
so you stop calling update value.

00:19:27.260 --> 00:19:30.470
So all of this,
we can have an iPhone talking to another

00:19:30.520 --> 00:19:32.840
iPhone while the app is background.

00:19:32.840 --> 00:19:35.850
And we think this is pretty cool,
and we're sure this will tickle

00:19:35.920 --> 00:19:38.610
some imagination of yours,
and you will come up with really,

00:19:38.610 --> 00:19:40.080
really cool applications for this.

00:19:40.080 --> 00:19:43.350
So let's dive in and talk a
little bit about what we've

00:19:43.360 --> 00:19:45.320
learned over the past year.

00:19:45.320 --> 00:19:48.960
We've got tremendous
feedback from you guys.

00:19:49.020 --> 00:19:51.980
And we're going to start by
looking at iOS background.

00:19:52.100 --> 00:19:56.520
We allow application to do

00:19:56.950 --> 00:19:59.800
Almost anything in Core Bluetooth while
they're backgrounded.

00:19:59.810 --> 00:20:04.000
They can scan for devices,
they can advertise in the background,

00:20:04.170 --> 00:20:07.640
they can even connect to other devices
while the app is in the background.

00:20:07.640 --> 00:20:12.670
And it can interact with other devices
while the app is in the background.

00:20:12.680 --> 00:20:15.660
Of course,
this consumes power on the device,

00:20:15.770 --> 00:20:19.960
so we want to make sure that the
user is aware that this is going on.

00:20:20.720 --> 00:20:25.500
This is why we ask of you to have
a start and stop concept in the UI.

00:20:25.820 --> 00:20:28.470
The user can say, "Yes,
I want to start it, and yes,

00:20:28.470 --> 00:20:30.140
I want to stop it."

00:20:30.560 --> 00:20:34.920
You also have to put some magic
words in the Info.plist so we

00:20:35.140 --> 00:20:38.200
can grant you this privilege.

00:20:38.290 --> 00:20:42.360
But we ask of you to be very,
please be mindful.

00:20:42.630 --> 00:20:43.940
We're giving you a lot of power.

00:20:44.030 --> 00:20:46.260
Your application is allowed
to run in the background.

00:20:46.390 --> 00:20:48.920
You can go off and do
all this cool stuff.

00:20:49.030 --> 00:20:52.140
But please,
we ask of you not to access the internet

00:20:52.140 --> 00:20:58.810
more than every 15 to 30 minutes to
preserve battery of the iOS device.

00:20:58.910 --> 00:21:01.980
We give you a lot of power,
so please be mindful.

00:21:02.090 --> 00:21:06.600
So we have this foregrounded apps,
and we have backgrounded apps.

00:21:07.280 --> 00:21:09.440
And when an app is in the
foreground and it's trying to

00:21:09.440 --> 00:21:12.320
discover devices around it,
we go off and do a high

00:21:12.320 --> 00:21:13.600
intensity scanning.

00:21:13.690 --> 00:21:16.290
And it's basically, we know the user is
looking at the screen,

00:21:16.290 --> 00:21:19.240
the screen is on,
and it's expecting results.

00:21:19.380 --> 00:21:21.850
So we turn on the radio.

00:21:22.510 --> 00:21:26.100
and really scan with a high intensity.

00:21:26.190 --> 00:21:30.440
When the app goes in the background,
or when the screen is off,

00:21:30.530 --> 00:21:33.980
we use low intensity
scanning to save power.

00:21:36.490 --> 00:21:40.730
We want you to be aware that when
your app is in the background,

00:21:40.750 --> 00:21:43.500
that it takes longer to discover devices.

00:21:43.580 --> 00:21:47.150
It takes longer to connect
and see what's around you.

00:21:47.900 --> 00:21:50.520
One thing,
if you're an accessory manufacturer,

00:21:50.650 --> 00:21:52.910
one thing that you can do

00:21:53.310 --> 00:21:57.920
To help is to really advertise
with a short advertising interval.

00:21:57.960 --> 00:22:00.600
Sending these advertising
packets out very,

00:22:00.600 --> 00:22:03.310
very often will help

00:22:03.670 --> 00:22:07.300
The application finds you even
when it's in the background.

00:22:07.430 --> 00:22:11.300
So imagine I have this
heart rate monitor.

00:22:11.380 --> 00:22:13.300
And I put it on, it starts advertising.

00:22:13.350 --> 00:22:16.780
And I have my phone.

00:22:17.090 --> 00:22:21.190
and I would like the application
sitting in the background on the

00:22:21.200 --> 00:22:25.240
phone to pick up my heart rate
monitor as quick as possible.

00:22:25.330 --> 00:22:28.110
For it to pick it up,
we suggest that you advertise

00:22:28.110 --> 00:22:32.360
about every 20 milliseconds
with a really high intensity.

00:22:32.440 --> 00:22:37.000
You don't have to do it for forever,
but maybe for a couple of minutes.

00:22:37.060 --> 00:22:41.890
And then go back to low
intensity advertising.

00:22:41.890 --> 00:22:41.890
So if you are

00:22:42.390 --> 00:22:45.930
Accessory Developer,
please advertise often when you

00:22:45.930 --> 00:22:48.310
want us to discover your device.

00:22:48.800 --> 00:23:00.400
[Transcript missing]

00:23:00.740 --> 00:23:04.310
Name of my heart rate monitor,
saying this is Joakiim's

00:23:04.310 --> 00:23:04.570
heart rate monitor.

00:23:04.570 --> 00:23:08.600
Or if it's a thermostat on the wall,
it could contain the name of the room.

00:23:08.600 --> 00:23:13.380
The advertising packet also contains
the transmit power at which this

00:23:13.890 --> 00:23:15.600
advertising packet was sent.

00:23:15.600 --> 00:23:19.710
This is kind of convenient
because in the Core Bluetooth API,

00:23:19.710 --> 00:23:23.710
every single advertising
packet we let you know about,

00:23:23.820 --> 00:23:28.140
we also supply you the RSSI value,
the read signal strength,

00:23:28.140 --> 00:23:31.510
the received signal strength
at which it was received.

00:23:31.600 --> 00:23:37.600
You can use these values to figure out
the approximate distance to the device.

00:23:37.600 --> 00:23:40.400
You can see if it's very,
very close or far, far away.

00:23:40.600 --> 00:23:45.640
We think this is pretty cool and you
will see this in the demo that Khrob is

00:23:45.720 --> 00:23:48.570
going to do in a couple of minutes here.

00:23:48.710 --> 00:23:53.140
It would be sad if we had to connect
to every single device to figure

00:23:53.140 --> 00:23:55.520
out what services it provides.

00:23:55.600 --> 00:23:58.760
It could be kind of a bad experience,
have to connect to it and

00:23:58.890 --> 00:24:00.600
then connect to the next one.

00:24:00.600 --> 00:24:03.580
So instead,
you can put the most important service,

00:24:03.580 --> 00:24:06.740
this one service that you
want everybody to know about,

00:24:06.870 --> 00:24:08.600
in the advertising packet.

00:24:08.600 --> 00:24:10.560
Of course,
it's the UUID that you put in there.

00:24:10.710 --> 00:24:15.600
You can also put some key data
associated with this service.

00:24:15.600 --> 00:24:18.790
For instance,
if you have a thermostat on the wall,

00:24:18.790 --> 00:24:21.600
you could put the
temperature of the room.

00:24:21.600 --> 00:24:24.960
So it's constantly advertising saying,
"I am a thermostat." Here's

00:24:24.960 --> 00:24:26.600
the temperature of this room.

00:24:26.600 --> 00:24:28.590
Here's the name of the room.

00:24:28.610 --> 00:24:33.510
If you want to know more or maybe
change the setting of this thermostat,

00:24:33.510 --> 00:24:35.530
you'll then have to connect to it.

00:24:35.620 --> 00:24:37.600
But at least you know,
"I'm interested in this device.

00:24:37.600 --> 00:24:40.600
Let me connect to it and
start interacting with it."

00:24:41.060 --> 00:24:44.170
Remember I said in the beginning
that Bluetooth Low Energy is

00:24:44.170 --> 00:24:45.590
all about low energy.

00:24:45.740 --> 00:24:48.600
So the advertising packet
has some limitations.

00:24:48.600 --> 00:24:49.600
It's very short.

00:24:49.600 --> 00:24:50.600
It's only 31 bytes.

00:24:50.600 --> 00:24:53.600
So you have to be careful when you put
the data in here that it all has to fit.

00:24:53.600 --> 00:24:56.420
We have to live within these limits.

00:24:56.420 --> 00:24:57.600
So only 31 bytes.

00:24:57.600 --> 00:24:59.600
So these UUIDs.

00:24:59.600 --> 00:25:00.600
We've talked a lot about UUIDs.

00:25:00.600 --> 00:25:02.600
There's two types of UUIDs.

00:25:02.600 --> 00:25:06.430
There's 16-bit UUIDs and
there's 128-bit UUIDs.

00:25:06.600 --> 00:25:11.600
16-bit UUIDs is basically reserved for
the Bluetooth SIG and they assign them.

00:25:11.600 --> 00:25:14.600
They normally assign them in
specifications that they produce.

00:25:14.600 --> 00:25:18.600
If you want to know more about
the 16-bit UUIDs that exist,

00:25:18.600 --> 00:25:21.600
you can go to developer.bluetooth.org.

00:25:21.620 --> 00:25:22.600
And they have a nice table there for you.

00:25:22.600 --> 00:25:24.910
They have a nice table there for you.

00:25:25.420 --> 00:25:30.900
There's also the 128-bit UUIDs,
and those are actually assigned by you.

00:25:31.030 --> 00:25:32.700
Now you go, "Oh, great,
then I can come up with

00:25:32.700 --> 00:25:36.000
this cool UUID that's 1,
2, 3, 4, 5, 6,

00:25:36.000 --> 00:25:40.060
7." The guy next to you probably
has the same brilliant idea.

00:25:40.200 --> 00:25:43.860
So instead,
we recommend that you open up a terminal

00:25:43.860 --> 00:25:47.840
window on MacÂ OS and type UUID gen.

00:25:47.980 --> 00:25:53.900
And it will generate a
truly random 128-bit UUID

00:25:54.530 --> 00:25:57.360
and the probability of someone
else using that UID is very,

00:25:57.360 --> 00:25:59.210
very, very close to zero.

00:25:59.250 --> 00:26:04.020
So we talked a lot about advertising
and how to discover devices.

00:26:04.030 --> 00:26:08.120
Now we're going to dive in to see what
happens when you connect the device.

00:26:08.130 --> 00:26:13.180
As Brian mentioned in his talk,
when you connect to a device,

00:26:13.590 --> 00:26:19.640
You set up a timetable when these
devices are going to interact.

00:26:20.360 --> 00:26:23.930
and initially, Core Bluetooth,
when it connects to a peripheral,

00:26:24.010 --> 00:26:26.540
sets up a very short connection interval.

00:26:26.560 --> 00:26:31.040
The reason for that is we want to make
sure that the data that we're fetching,

00:26:31.040 --> 00:26:36.870
the services and the characteristics,
we get them very fast.

00:26:37.190 --> 00:26:40.390
The peripheral might say, "Whoa,
that's a little bit too short for me.

00:26:40.460 --> 00:26:47.080
I'm going to consume a lot of power."
Maintain this connection interval so it

00:26:47.080 --> 00:26:53.220
can actually request a longer connection
interval and that way saving power.

00:26:53.610 --> 00:26:57.300
Of course,
this leads to latency involved with it,

00:26:57.300 --> 00:27:00.340
so this is a design decision
that you have to make.

00:27:00.360 --> 00:27:05.080
We have guidelines for what
connection parameters we support.

00:27:05.300 --> 00:27:09.370
Those are documented in the
Bluetooth design guidelines.

00:27:09.460 --> 00:27:11.250
We suggest that you take a look at that.

00:27:11.300 --> 00:27:14.340
Setting up these connections,
the first time you set it up,

00:27:14.340 --> 00:27:17.300
you go and look for the services
and you look for the characteristics

00:27:17.300 --> 00:27:18.300
and it takes a while to get those.

00:27:18.300 --> 00:27:21.220
Second time,
you go and look for the services

00:27:21.220 --> 00:27:23.300
and characteristics again.

00:27:23.300 --> 00:27:25.300
We found out a better way to do that.

00:27:25.300 --> 00:27:28.300
In iOS 6, we actually introduced caching.

00:27:28.540 --> 00:27:31.990
That means that the discovered services
and the discovered characteristics

00:27:32.350 --> 00:27:35.300
are cached locally on your device.

00:27:35.430 --> 00:27:37.260
We only cache the data structure.

00:27:37.260 --> 00:27:39.270
We don't cache the actual values.

00:27:39.470 --> 00:27:45.300
When you do a read or a write,
those are still live variables.

00:27:45.300 --> 00:27:49.460
Since this takes up a little
bit of space on our device,

00:27:49.610 --> 00:27:52.260
we only do it for paired devices.

00:27:52.400 --> 00:27:56.500
The cool thing with this is,
this is fully transparent to the app.

00:27:56.590 --> 00:27:58.990
So your app thinks the second
time it connects to the device,

00:27:59.030 --> 00:28:03.200
I'm going to go and read the services
and read the characteristics.

00:28:03.320 --> 00:28:05.800
In reality,
we have this small stash on the side

00:28:05.800 --> 00:28:08.100
and we go and get the values from there.

00:28:08.100 --> 00:28:09.990
I mentioned these paired devices.

00:28:10.110 --> 00:28:12.000
So let's talk a little bit about pairing.

00:28:12.090 --> 00:28:15.760
Pairing is always triggered
by the peripheral.

00:28:15.860 --> 00:28:19.800
The central tries to do a
read or write to a peripheral.

00:28:19.920 --> 00:28:25.100
And the peripheral has the ability
to reject that read or write.

00:28:25.230 --> 00:28:29.600
They go through the pairing process
and you end up with an encrypted link.

00:28:29.600 --> 00:28:34.790
It's only paired devices that you
can have an encrypted link with.

00:28:35.830 --> 00:28:38.280
So let's take a look at how this works.

00:28:38.390 --> 00:28:44.110
Your app issues a read or write
to a characteristic that gets sent

00:28:44.850 --> 00:28:46.700
over the air to the peripheral.

00:28:46.700 --> 00:28:50.790
The peripheral says,
"I don't know who you are," and rejects

00:28:50.910 --> 00:28:53.810
this with insufficient authentication.

00:28:54.430 --> 00:28:58.310
Core Bluetooth then goes off and
tries to pair with this device.

00:28:58.360 --> 00:29:00.280
But before we do that,
we have to go and ask the user.

00:29:00.300 --> 00:29:03.050
So we pop up a notification
to the user saying,

00:29:03.070 --> 00:29:04.340
do you really want to
pair with this device?

00:29:04.340 --> 00:29:06.700
We're going to create a bond with this.

00:29:06.750 --> 00:29:08.540
Do you really want to do that?

00:29:08.540 --> 00:29:09.780
And the user says yes.

00:29:09.780 --> 00:29:11.190
Then we move forward.

00:29:11.350 --> 00:29:15.580
request pairing for the peripheral
and part of the pairing process,

00:29:15.580 --> 00:29:19.400
encryption keys are
generated on both sides.

00:29:19.450 --> 00:29:22.290
We're going to use these
encryption keys on the link that

00:29:22.290 --> 00:29:23.840
we later on are going to set up.

00:29:24.560 --> 00:29:27.960
Core Bluetooth then automatically
goes and retries without your

00:29:27.960 --> 00:29:29.760
application having to worry about it.

00:29:29.870 --> 00:29:32.000
Retries the read or write.

00:29:32.120 --> 00:29:36.100
And now we have a paired relationship
and it's done over an encrypted link.

00:29:36.210 --> 00:29:39.790
And the peripheral now responds to it
because he knows who it comes from.

00:29:40.070 --> 00:29:42.150
Last, I'd like to talk a
little bit about state.

00:29:42.430 --> 00:29:47.850
One thing that's important is not
all iOS devices or Macs support

00:29:48.000 --> 00:29:49.700
Bluetooth Low Energy in the hardware.

00:29:49.850 --> 00:29:52.990
And before you start in calling
the Core Bluetooth framework,

00:29:53.100 --> 00:29:58.080
we want to make sure that
you're actually on a device that

00:29:58.080 --> 00:30:00.000
supports Bluetooth Low Energy.

00:30:00.140 --> 00:30:02.490
You can check that in the
CB Central Manager or in

00:30:02.530 --> 00:30:04.200
the CB Peripheral Manager.

00:30:04.300 --> 00:30:06.000
There's a variable called state.

00:30:06.150 --> 00:30:09.400
And this property can
have a number of states.

00:30:09.400 --> 00:30:10.430
It can be unknown.

00:30:10.620 --> 00:30:13.400
When it's first instantiated,
it's unknown.

00:30:13.590 --> 00:30:15.590
It can be resetting.

00:30:16.000 --> 00:30:18.780
This is normally when we
start booting up the system.

00:30:18.850 --> 00:30:23.860
And then, if Bluetooth Low Energy is not
supported on this hardware,

00:30:23.940 --> 00:30:25.860
the state is unsupported.

00:30:25.990 --> 00:30:27.940
Or it could be powered off.

00:30:28.180 --> 00:30:32.060
In that case, your application will have
to go and tell the user,

00:30:32.080 --> 00:30:34.290
"Bluetooth is turned off on this device.

00:30:34.380 --> 00:30:37.510
You might want to go into Settings and
turn Bluetooth on so I can use

00:30:37.510 --> 00:30:42.580
Bluetooth." Key thing you want to look
for eventually is that it's powered on,

00:30:42.670 --> 00:30:45.740
Bluetooth Low Energy is supported on
the device that your app is running,

00:30:45.820 --> 00:30:50.340
and now your application is all
ready to start using Core Bluetooth.

00:30:50.410 --> 00:30:54.130
With that, I'd like to invite Khrob up
to the stage for the demo.

00:30:54.190 --> 00:30:55.770
Thank you, Joaki.

00:30:59.990 --> 00:31:00.850
G'day all.

00:31:01.090 --> 00:31:05.140
Now, if you're all like me,
a lot of your Bluetooth experience

00:31:05.280 --> 00:31:09.220
will be sticking on some really cool
noise-canceling Bluetooth headphones

00:31:09.220 --> 00:31:13.050
and tunneling down so you just,
you know, you focus and you're blocking

00:31:13.050 --> 00:31:14.290
out the outside world.

00:31:14.300 --> 00:31:17.140
But hypothetically speaking,
what if you were to find

00:31:17.140 --> 00:31:21.030
yourself in a large conference
center with 4,999 other really,

00:31:21.030 --> 00:31:24.920
really cool people that you actually
get along with really well and share,

00:31:24.920 --> 00:31:27.260
let's say, quite a few common interests?

00:31:28.190 --> 00:31:31.680
Well, you might meet some of them and you
want to exchange your contact details.

00:31:31.790 --> 00:31:34.500
Now,
that might involve going to contacts,

00:31:34.680 --> 00:31:37.640
typing in their number,
sending them a message with your details,

00:31:37.640 --> 00:31:40.210
step by step by step by step.

00:31:40.300 --> 00:31:43.570
You know, wouldn't it be much nicer if
you could just do the equivalent

00:31:43.570 --> 00:31:47.030
of pulling out a business card,
handing it over, they take it from you,

00:31:47.030 --> 00:31:48.100
and you're done?

00:31:48.120 --> 00:31:50.350
But, you know,
eco-friendly and everything,

00:31:50.350 --> 00:31:53.090
we want to save trees,
so let's just do it electronically,

00:31:53.090 --> 00:31:54.000
phone to phone.

00:31:54.000 --> 00:31:56.210
So in this demo,
I'll show you how to set up your phone.

00:31:56.870 --> 00:32:00.470
your phone into a peripheral mode

00:32:00.920 --> 00:32:04.280
So essentially you're turning this
into a peripheral like the heart

00:32:04.280 --> 00:32:07.710
rate monitor or the thermostat on
the wall that is your business card.

00:32:07.800 --> 00:32:10.800
So let's have a look
at what we need to do.

00:32:10.800 --> 00:32:11.800
So it's quite simple.

00:32:11.800 --> 00:32:14.800
First up we need to start
our CV peripheral manager.

00:32:14.800 --> 00:32:17.550
Once we've done that we
need to create the tree,

00:32:17.650 --> 00:32:21.320
publish our service,
so Core Bluetooth knows what information

00:32:21.430 --> 00:32:23.800
we want to put out in the world.

00:32:24.120 --> 00:32:28.920
Then we need to advertise the service
and then we basically sit back and relax

00:32:28.920 --> 00:32:34.000
until a central comes along and says,
"Hey, you're advertising this UID that

00:32:34.000 --> 00:32:37.800
I'm interested in plus your RSSI,
the power,

00:32:37.800 --> 00:32:41.860
tells me that you're actually really,
really close." And when it does that

00:32:41.860 --> 00:32:43.740
it connects and we start talking.

00:32:43.800 --> 00:32:48.490
So just quickly the class itself, very,
very simple.

00:32:48.800 --> 00:32:52.780
We have the CV peripheral manager,
we just called that one manager.

00:32:52.800 --> 00:32:58.060
We implement the CV peripheral manager
delegate so we get all the right

00:32:58.060 --> 00:33:00.800
callbacks from the asynchronous services.

00:33:00.960 --> 00:33:04.950
We have a mutable service which
I've called vCardService and

00:33:04.950 --> 00:33:07.800
a mutable characteristic which
I've called vCardCharacteristic.

00:33:07.980 --> 00:33:10.500
Note that because we're on the
peripheral side we want to be using

00:33:10.500 --> 00:33:13.800
the mutable versions of these because
we set the information in them,

00:33:13.800 --> 00:33:15.590
not Core Bluetooth.

00:33:15.800 --> 00:33:19.570
So turning on Core Bluetooth, very,
very simple,

00:33:19.570 --> 00:33:21.800
stock standard in it function.

00:33:21.800 --> 00:33:27.800
And we call CV peripheral manager
alloc and in it with delegate.

00:33:27.800 --> 00:33:30.780
Of course we're going to set
it to ourself because that's,

00:33:30.780 --> 00:33:32.800
you know, we implement the protocol.

00:33:32.800 --> 00:33:34.800
And we set the queue that
it's going to run on.

00:33:34.840 --> 00:33:38.490
In this case we're just setting
nil which will choose the

00:33:38.570 --> 00:33:41.800
most appropriate queue to,
you know,

00:33:41.800 --> 00:33:43.800
do all the callbacks and everything on.

00:33:43.800 --> 00:33:48.120
If you need to do something a little
bit more clever then feel free to

00:33:48.120 --> 00:33:50.800
set whatever queue you like for that.

00:33:50.800 --> 00:33:55.210
Now the second part of turning
on the peripheral manager as

00:33:55.210 --> 00:33:57.590
Joachim was just talking about.

00:33:57.730 --> 00:34:01.100
was checking that state,
which is very simply done.

00:34:01.110 --> 00:34:05.300
We get the callback,
peripheral manager did update state,

00:34:05.420 --> 00:34:07.590
and it even says the peripheral.

00:34:07.840 --> 00:34:09.420
So we do a switch on the state.

00:34:09.450 --> 00:34:14.270
If it's CB peripheral manager state
powered off or resetting or unknown,

00:34:14.270 --> 00:34:17.580
we know that something's not
quite right with the setup.

00:34:17.650 --> 00:34:21.140
Maybe it's an older phone
or an older MacBook Air,

00:34:21.140 --> 00:34:24.200
doesn't have the low energy Bluetooth.

00:34:24.200 --> 00:34:26.570
So we deal with that here.

00:34:26.940 --> 00:34:31.040
But if we do have the magic one,
CB peripheral manager state powered on,

00:34:31.040 --> 00:34:33.620
then we can go ahead
and set up our service.

00:34:33.620 --> 00:34:36.790
Now, the service will have
several characteristics.

00:34:36.800 --> 00:34:39.510
Well,
it could have several characteristics.

00:34:39.510 --> 00:34:42.110
A service is a collection
of characteristics,

00:34:42.110 --> 00:34:43.400
as we've just seen.

00:34:43.400 --> 00:34:46.280
So you could have a service
that has a UID that expresses

00:34:46.280 --> 00:34:47.830
that it's the vCard service.

00:34:48.010 --> 00:34:51.480
And you could have a characteristic
that says this is my first name,

00:34:51.480 --> 00:34:54.030
this is my second name,
this is my phone number,

00:34:54.030 --> 00:34:55.370
this is my address.

00:34:56.280 --> 00:34:59.230
And that's absolutely perfectly
valid use case and way to

00:34:59.230 --> 00:35:00.750
do it with core Bluetooth.

00:35:00.870 --> 00:35:03.290
Each of those things is a
very small piece of data.

00:35:03.610 --> 00:35:05.830
And as we're low energy,
we want to send small pieces of

00:35:05.890 --> 00:35:08.120
data because we can do that very,
very quickly.

00:35:08.120 --> 00:35:11.480
We're going to do something
slightly different today.

00:35:11.660 --> 00:35:15.900
Instead of a readable characteristic
for each of those different things,

00:35:15.900 --> 00:35:19.120
we're going to set up a
notifiable characteristic that

00:35:19.200 --> 00:35:22.340
when the central connects,
it can subscribe to.

00:35:22.340 --> 00:35:25.620
Now, remember, when you subscribe to a
notifiable characteristic,

00:35:25.620 --> 00:35:25.620
you're going to get a notification.

00:35:25.620 --> 00:35:26.540
So if you have a
notifiable characteristic,

00:35:26.620 --> 00:35:31.870
any time that characteristic changes,
the connected central will

00:35:31.870 --> 00:35:35.810
get a callback saying,
hey, this value changed,

00:35:36.080 --> 00:35:37.960
and here's the new data.

00:35:37.960 --> 00:35:41.590
So let's go ahead and set up that tree,
which represents that.

00:35:42.160 --> 00:35:49.310
So, as just said,
everything is identified by UUIDs,

00:35:49.310 --> 00:35:51.910
or CBUIDs that is.

00:35:52.040 --> 00:35:54.760
So we're setting up a
string for each of the two,

00:35:54.760 --> 00:35:57.830
one for the service,
one for the characteristic.

00:35:58.010 --> 00:36:02.320
And then we can use the CBUID helper
function UUID with string,

00:36:02.320 --> 00:36:10.410
pass in the strings from up here,
and there we get service and pipe UUIDs.

00:36:10.500 --> 00:38:18.600
[Transcript missing]

00:38:21.770 --> 00:38:23.300
This is exactly the same as above.

00:38:23.420 --> 00:38:27.540
We've just made the, you know,
I've just repeated it for clarity.

00:38:27.600 --> 00:38:30.860
UUID with string, passing the string,
we have our new UUID.

00:38:31.240 --> 00:38:33.880
Make an array of the services.

00:38:34.020 --> 00:38:38.080
Make a dictionary, pass in that array.

00:38:38.760 --> 00:38:40.200
and make sure we use the right key.

00:38:40.200 --> 00:38:43.900
There's one for each of them,
clearly defined in the header docs.

00:38:44.020 --> 00:38:48.300
CB advertisement data,
service UIDs key and then

00:38:48.300 --> 00:38:51.290
starting to advertise,
simple as telling the manager to

00:38:51.410 --> 00:38:53.900
start advertising this information.

00:38:54.020 --> 00:38:58.210
Hell of a lot nicer than packing bytes.

00:38:58.820 --> 00:38:59.990
So now we're advertising.

00:39:00.190 --> 00:39:02.920
What's going to happen then is
we're walking around the conference.

00:39:03.160 --> 00:39:05.520
I meet someone and say,
you look pretty cool.

00:39:05.520 --> 00:39:07.220
You're working on really
interesting stuff.

00:39:07.500 --> 00:39:08.840
Here's my card, essentially.

00:39:08.840 --> 00:39:11.680
And when they get close,
his app is in central

00:39:11.680 --> 00:39:15.910
mode and it's going to go,
hey, wow, someone's broadcasting this

00:39:16.040 --> 00:39:18.250
data and the RSSI is very small.

00:39:18.250 --> 00:39:20.560
So obviously it's very close.

00:39:20.560 --> 00:39:22.400
So it'll connect to us.

00:39:22.540 --> 00:39:24.900
And as the peripheral manager,
we'll get a callback

00:39:24.900 --> 00:39:26.480
saying central did connect.

00:39:27.810 --> 00:39:30.620
Now, many apps are going to use
that for their own ends.

00:39:30.620 --> 00:39:33.590
There might be something very
important they need to do.

00:39:33.760 --> 00:39:35.250
We're not particularly
worried about that.

00:39:35.400 --> 00:39:36.610
It's like, hey, connect away.

00:39:36.620 --> 00:39:37.740
We're all good with that.

00:39:39.320 --> 00:39:41.800
But then it's going to explore
us and it's going to hit the

00:39:41.800 --> 00:39:45.740
characteristic that we want and say,
oh, there you go,

00:39:45.740 --> 00:39:47.040
there's your pipe characteristic.

00:39:47.040 --> 00:39:49.910
I know that if I connect to you,
if I subscribe to that,

00:39:49.910 --> 00:39:53.690
you're going to send me a whole lot
of data that represents a vCard.

00:39:54.700 --> 00:39:59.120
So they're going to call subscribe
to characteristic and on our side,

00:39:59.230 --> 00:40:01.240
we're going to get a callback.

00:40:01.360 --> 00:40:02.950
What callback is that, you ask?

00:40:02.990 --> 00:40:06.400
Peripheral manager central did
subscribe to characteristic.

00:40:06.400 --> 00:40:08.120
Very, very simple.

00:40:08.120 --> 00:40:09.800
That comes in without us
having to do anything.

00:40:09.800 --> 00:40:12.900
And once it happens,
we know that we can loop through

00:40:12.900 --> 00:40:16.050
the data that represents our
vCard one chunk at a time,

00:40:16.150 --> 00:40:20.580
send each chunk over to the central,
and then send an end of message.

00:40:20.600 --> 00:40:22.500
Now,
I just want to reiterate again here that

00:40:22.500 --> 00:40:26.180
when you're sending characteristics...
When you're sending chunks,

00:40:26.180 --> 00:40:27.310
this is low energy.

00:40:27.310 --> 00:40:28.730
We can't send video files.

00:40:28.840 --> 00:40:31.030
We can't send massive, massive stuff.

00:40:31.030 --> 00:40:32.100
Keep it small.

00:40:32.100 --> 00:40:36.110
The chunks in this case,
they're 20 bytes a pop.

00:40:36.110 --> 00:40:41.160
So I've got a little helper function
that just goes to my Anastata that

00:40:41.160 --> 00:40:44.540
contains the vCard and pulls out...

00:40:44.960 --> 00:40:49.520
The next chunk, the next 20-byte chunk,
and keeps on doing that until

00:40:49.520 --> 00:40:50.920
the vCard's already sent.

00:40:51.140 --> 00:40:53.810
But once we have each chunk,
we need to actually update the

00:40:53.810 --> 00:40:54.930
value of our characteristic.

00:40:54.990 --> 00:40:58.980
So, again,
back to our CV peripheral manager.

00:40:59.320 --> 00:41:03.980
Update value, pass in the NSData for
the characteristic,

00:41:04.000 --> 00:41:10.160
the vCard characteristic, and like magic,
it'll go over to the central.

00:41:10.160 --> 00:41:15.060
The central will get their response,
their callback, saying, "Hey,

00:41:15.060 --> 00:41:18.920
this characteristic updated
the value." They'll pull it in,

00:41:18.920 --> 00:41:23.960
they'll pull it in, they'll pull it in,
and the app here streams them all

00:41:24.000 --> 00:41:24.960
together until it gets updated.

00:41:25.030 --> 00:41:28.960
And that's the end of message one, which,
again, very, very simple.

00:41:29.040 --> 00:41:32.860
Just getting an NSString,
turn it into some NSData,

00:41:32.860 --> 00:41:36.980
and using exactly the
same call as before,

00:41:37.130 --> 00:41:39.980
we update the value
for the characteristic.

00:41:39.980 --> 00:41:44.750
And when the central gets that, it goes,
"Okay, that's the end of message.

00:41:44.750 --> 00:41:46.590
I have all the data I need.

00:41:46.590 --> 00:41:49.980
I will disconnect to you
-- or disconnect from you,

00:41:49.980 --> 00:41:54.280
and you're free to go and share your
card with someone else." And really,

00:41:54.280 --> 00:41:54.980
it's a very simple thing.

00:41:56.680 --> 00:41:57.600
That's it.

00:41:57.600 --> 00:42:01.150
Now, I know I've been a bit long-winded
in explaining how it goes,

00:42:01.150 --> 00:42:06.540
so let's have a look at just how
quickly this all happens in real life.

00:42:06.660 --> 00:42:10.850
Okay,
so that's a phone set into central mode,

00:42:10.850 --> 00:42:16.650
so it's scanning, looking out for people
in peripheral mode.

00:42:16.660 --> 00:42:19.330
And so I've got this
chap in peripheral mode.

00:42:19.370 --> 00:42:24.000
I'm going to very simply
select the card that I want.

00:42:24.020 --> 00:42:25.400
He's up there.

00:42:26.410 --> 00:42:31.000
Now, when I bring it close,
hand the card over, flash, flash, flash,

00:42:31.000 --> 00:42:32.320
and you're done.

00:42:40.210 --> 00:42:43.200
and just because it's really,
really quick, let's see it again.

00:42:43.900 --> 00:42:48.200
âª âª There we have it.

00:42:48.500 --> 00:42:50.690
Back to you, Joaki.

00:42:54.380 --> 00:42:55.840
Thank you, Khrob.

00:42:55.890 --> 00:42:58.460
Wasn't that an amazing demo?

00:42:58.660 --> 00:43:01.260
I'm just trying to imagine all
the applications that you guys

00:43:01.300 --> 00:43:02.230
are going to build using this.

00:43:02.540 --> 00:43:03.640
Wow.

00:43:03.770 --> 00:43:06.520
So many use cases for this.

00:43:06.990 --> 00:43:10.500
So if you want to know more,
we have Steven Schick

00:43:10.590 --> 00:43:12.310
and Craig Keithley here.

00:43:12.310 --> 00:43:14.000
They are our evangelists.

00:43:14.000 --> 00:43:15.400
They'd be happy to answer
all your questions.

00:43:15.400 --> 00:43:19.650
We also have a Bluetooth mailing
list where I try to answer as

00:43:19.650 --> 00:43:21.960
many questions as possible.

00:43:21.960 --> 00:43:24.820
So please post questions there as well.

00:43:24.820 --> 00:43:27.920
We also have the Apple Developers Forum.

00:43:28.010 --> 00:43:31.620
Under Core OS,
there is a Core Bluetooth Forum.

00:43:31.620 --> 00:43:35.240
We try to answer your
questions there as well.

00:43:36.240 --> 00:43:38.630
Previously today,
you heard Brian speak about the

00:43:38.680 --> 00:43:40.380
introduction to Core Bluetooth.

00:43:40.380 --> 00:43:41.470
Thank you.
WEBVTT

00:00:10.970 --> 00:00:11.950
Good afternoon.

00:00:12.140 --> 00:00:15.700
This is session 222,
Introduction to Attributed

00:00:15.700 --> 00:00:17.340
Strings for iOS.

00:00:17.470 --> 00:00:21.070
I'm Aki Inoue from the Cocoa Group.

00:00:23.450 --> 00:00:27.170
For the last couple of years,
we've been getting numerous

00:00:27.170 --> 00:00:33.700
feedbacks requesting multi-style
string drawing in iOS,

00:00:33.700 --> 00:00:33.700
much like

00:00:34.100 --> 00:00:39.370
Attributed String Integration on OS X.

00:00:40.260 --> 00:00:44.600
As Chris announced yesterday,
spectacularly,

00:00:44.680 --> 00:00:50.500
in his What's New in Cocoa Touch session,
the wait is over.

00:00:55.700 --> 00:01:01.970
We are introducing UIKit and
SFS string integration in iOS 6.

00:01:03.600 --> 00:01:06.350
These are the items we're covering today.

00:01:06.350 --> 00:01:12.100
First, I'm going to start with
Attribute Essentials.

00:01:12.100 --> 00:01:19.400
How to create, how to modify,
and how to work with them

00:01:19.400 --> 00:01:19.400
effortlessly and efficiently.

00:01:19.920 --> 00:01:24.660
So with this material,
you should be able to bootstrap and work

00:01:24.660 --> 00:01:28.330
with the attributed string right away.

00:01:28.330 --> 00:01:33.060
And I believe the materials present
here should be valuable even for

00:01:33.060 --> 00:01:39.510
those of you who are already familiar
with attributed string via core text.

00:01:39.880 --> 00:01:45.100
Then we're going to see some of the
drawing attributes UIKit provides.

00:01:45.180 --> 00:01:51.120
Later on, you'll see how these new
capabilities are integrated

00:01:51.120 --> 00:01:55.020
into the UIKit control classes.

00:01:55.100 --> 00:01:57.010
Let's get started.

00:02:00.600 --> 00:02:04.190
When you go to iOS 6,
when you wanted to render

00:02:04.190 --> 00:02:07.360
a string like this,
you'd use ULLabel or

00:02:07.360 --> 00:02:10.190
your string drawing API.

00:02:10.400 --> 00:02:15.930
The data model for this
functionality is based on NSString.

00:02:16.680 --> 00:02:21.440
When you want to render text,
you specify a font, you specify a string,

00:02:21.440 --> 00:02:24.540
along with other required information.

00:02:24.690 --> 00:02:29.970
For example,
you specify a string and a font.

00:02:30.800 --> 00:02:36.460
and the bold form, string, font, color.

00:02:36.530 --> 00:02:41.800
And there was no object
bindings attributes together.

00:02:42.440 --> 00:02:44.100
and the attribute string.

00:02:44.190 --> 00:02:49.880
The object associates these
attributes to the characters.

00:02:51.700 --> 00:02:56.520
So you can attach font
to your string object.

00:02:56.830 --> 00:03:03.390
You can specify a color to a range,
or even specify various

00:03:03.640 --> 00:03:06.570
fonts to different ranges.

00:03:07.090 --> 00:03:12.790
So what can you exactly do with
these attributed string objects?

00:03:12.950 --> 00:03:18.130
The first advantage is, of course,
you can create multi-style

00:03:18.130 --> 00:03:19.400
attributed string.

00:03:19.550 --> 00:03:25.840
You can render and measure text,
multi-style text as a single unit.

00:03:26.000 --> 00:03:29.330
This is from Stock's application.

00:03:29.630 --> 00:03:35.900
As you see in the news section,
it shows both headline and summary.

00:03:36.040 --> 00:03:38.840
The both string is the headline.

00:03:39.010 --> 00:03:43.740
When it requires more than one line,
it wraps to the second line.

00:03:43.850 --> 00:03:49.940
Then the summary string in regular
typeface is concatenated right after it.

00:03:50.000 --> 00:03:54.900
It's very easy.

00:03:54.900 --> 00:03:54.900
Another advantage

00:03:55.080 --> 00:04:01.330
is coming from the ability to attach
an arbitrary number of attributes.

00:04:01.880 --> 00:04:07.960
and That way we can extend the
capability without complicating the

00:04:07.960 --> 00:04:14.150
API much so that we provide much
more expressive options in terms of

00:04:14.250 --> 00:04:18.120
text formatting via attracing API.

00:04:18.280 --> 00:04:22.150
This is an example from Reminders.

00:04:22.520 --> 00:04:27.960
In order to reserve the
space for priority icon,

00:04:28.080 --> 00:04:31.420
we are shifting the first line.

00:04:31.980 --> 00:04:35.360
You know, like this,
you still require you to manually

00:04:35.360 --> 00:04:39.100
measure lines and render them separately.

00:04:39.180 --> 00:04:44.760
Now it's as easy as creating an attribute
string with indent option and render.

00:04:45.850 --> 00:04:51.520
Also, we're now more expressive in
terms of graphics representation.

00:04:51.600 --> 00:04:57.190
Shadow, outline, underline,
so on and so forth.

00:04:57.430 --> 00:05:02.700
This is rendered entirely
using UIKit attributes.

00:05:02.840 --> 00:05:05.550
You don't have to go down to

00:05:05.790 --> 00:05:07.400
and Koi Graphics and more.

00:05:07.450 --> 00:05:16.320
You can have this kind of text effects
right from the comfort from your

00:05:16.320 --> 00:05:16.320
UIKit object-oriented programming.

00:05:17.180 --> 00:05:20.040
What's an Assertive Stream?

00:05:20.190 --> 00:05:24.740
An Assertive Stream is not new, actually.

00:05:24.850 --> 00:05:32.010
In fact, it's been available in the
foundation framework since iOS 3.2.

00:05:33.310 --> 00:05:37.440
It's not just been used
by UIKit up until now.

00:05:37.570 --> 00:05:43.960
And these two base methods represent
the model object for the-- the data

00:05:43.960 --> 00:05:46.890
model for the attribution object.

00:05:47.490 --> 00:05:53.860
It has an string and a dictionary
of attributes per character.

00:05:54.470 --> 00:05:57.830
And this is the designate
initializer for the object.

00:05:57.950 --> 00:06:04.280
In it with string attributes,
it takes a string and attributes.

00:06:04.360 --> 00:06:08.600
The attributes are specified
to the entire string this way.

00:06:12.100 --> 00:06:15.760
So let's create an attribute string.

00:06:15.860 --> 00:06:21.220
We're using NSFontAttributeName,
an attribute key for specifying

00:06:21.220 --> 00:06:24.760
UI font to your string here.

00:06:24.860 --> 00:06:27.240
It's new for iOS 6.

00:06:27.380 --> 00:06:33.390
And using the initWithString attributes,
we are creating a string with the

00:06:33.390 --> 00:06:37.470
system font at 12-point size here.

00:06:37.530 --> 00:06:39.390
Very easy.

00:06:44.050 --> 00:06:47.630
One thing to note here is that
AttributeString associates

00:06:48.140 --> 00:06:49.740
attributes to characters.

00:06:49.890 --> 00:06:54.740
So for an empty string,
there's no attributes associated with it.

00:06:54.880 --> 00:06:57.740
This is an important
characteristic of AttributeString,

00:06:57.740 --> 00:07:03.350
so I'm going to revisit the
fact later in this talk again.

00:07:04.640 --> 00:07:09.390
So now you created an attribute string,
let's modify it.

00:07:09.550 --> 00:07:15.790
Just like other foundation-date objects,
this attribute string has

00:07:15.790 --> 00:07:21.140
clear separation between
mutable and immutable classes.

00:07:21.280 --> 00:07:21.390
In this mutable attribute string,

00:07:21.860 --> 00:07:26.290
Mutable subclass of NSFH string
has these two groups of mutable

00:07:26.470 --> 00:07:32.500
methods for changing attributes
and changing string contents.

00:07:32.630 --> 00:07:35.170
Let's change the attributes first.

00:07:36.230 --> 00:07:40.140
This is the best method
for changing attributes.

00:07:40.190 --> 00:07:41.740
Set attributes range.

00:07:42.000 --> 00:07:47.140
It replaces the attributes at the
range with the specified attributes.

00:07:47.360 --> 00:07:49.060
Straightforward.

00:07:49.750 --> 00:07:54.850
However, you typically work with these
convenient methods for adding

00:07:54.850 --> 00:07:57.040
and removing attributes.

00:07:57.040 --> 00:07:59.990
This way,
you can focus to a particular attribute.

00:08:00.220 --> 00:08:07.090
For example, if you have font picker UI,
the object can focus to

00:08:07.090 --> 00:08:09.810
NSFont attribute name.

00:08:10.310 --> 00:08:13.970
And similarly,
if you have color picker UI,

00:08:13.970 --> 00:08:17.760
you can focus to the
text color attributes,

00:08:17.760 --> 00:08:18.520
so on and so forth.

00:08:19.930 --> 00:08:23.560
So these methods are useful for
modifying existing attributes,

00:08:23.630 --> 00:08:29.740
of course, but it's also useful for you
creating the multi-style attributes.

00:08:29.740 --> 00:08:35.790
You might think when creating
multi-style attribute string,

00:08:36.560 --> 00:08:40.530
You might consider instantiating
an attribute string,

00:08:40.680 --> 00:08:44.740
plus I run and concatenate
together at the end.

00:08:44.860 --> 00:08:50.200
However, it's much more efficient to
instantiate the entire string up from

00:08:50.780 --> 00:08:54.160
the modified attributes as necessary.

00:08:54.800 --> 00:08:59.700
Let's create multi-style
attribute string efficiently.

00:08:59.890 --> 00:09:10.500
Here we're using another attribute
new to iOS 6 and it's program

00:09:10.500 --> 00:09:10.500
color attribute name for specifying
text color using UAColor.

00:09:11.390 --> 00:09:15.740
and we're instantiating attribute
string using attribute string attributes

00:09:16.250 --> 00:09:25.180
but in this case we are instantiating
NSMutable attribute string so that later

00:09:25.180 --> 00:09:25.180
you can modify the contents freely.

00:09:26.020 --> 00:09:31.390
And here,
we're using add attribute value range to

00:09:31.390 --> 00:09:35.900
specify the red color to the time string.

00:09:35.900 --> 00:09:41.150
Here, now you have multi-saggible string.

00:09:41.320 --> 00:09:43.880
Now, change the string contents.

00:09:46.670 --> 00:09:49.950
This is, again,
the best method for changing the

00:09:49.950 --> 00:09:55.600
string contents for attributed string,
replace characters in range with string.

00:09:55.710 --> 00:10:01.410
Just like there,
just like its attribute counterpart,

00:10:01.620 --> 00:10:07.190
we have a convenient method for adding,
replacing,

00:10:07.190 --> 00:10:10.670
and inserting attributed string.

00:10:10.870 --> 00:10:15.750
But I recommend to stick with
the base replace characters

00:10:15.750 --> 00:10:20.400
in range with string method,
because this way you can avoid

00:10:20.400 --> 00:10:25.890
instantiate temporary attribute string
just for modifying your string contents.

00:10:26.750 --> 00:10:32.770
So let's work with the reproductive
range with string here.

00:10:34.930 --> 00:10:37.800
Here's an example.

00:10:37.800 --> 00:10:42.790
We have the same new robot you were
seeing from the previous example.

00:10:43.170 --> 00:10:49.690
We want to move the dentist
appointment one earlier at 8:15.

00:10:50.010 --> 00:10:52.850
Using replaced characters
in range with string method.

00:10:52.980 --> 00:10:55.330
We accomplished that.

00:10:56.610 --> 00:11:01.830
Notice that we just
specify a string here,

00:11:01.830 --> 00:11:06.340
yet the attribute is still there.

00:11:06.450 --> 00:11:08.140
Why is that?

00:11:09.590 --> 00:11:13.140
Because the attributes are
preserved while you are working

00:11:13.140 --> 00:11:15.410
with the string contents.

00:11:15.410 --> 00:11:19.330
That way... Thank you.

00:11:20.960 --> 00:11:26.280
That way, you are still-- when you are
working with string contents,

00:11:26.280 --> 00:11:30.800
you can focus to the string contents
and forget about attributes.

00:11:30.930 --> 00:11:36.180
In order to do so,
you can just remember three simple rules.

00:11:37.330 --> 00:11:40.970
First,
when you're replacing a range of text,

00:11:41.250 --> 00:11:47.970
the attributes for the new
string is coming from the first

00:11:48.010 --> 00:11:48.010
character of the old range.

00:11:49.730 --> 00:11:53.420
When you're inserting,
the attributes coming from

00:11:53.420 --> 00:11:56.560
the previous character,
and when you're inserting

00:11:56.730 --> 00:12:00.440
at the beginning,
you don't have the previous character,

00:12:00.440 --> 00:12:04.510
so you have the attribute
from index zero.

00:12:06.120 --> 00:12:11.690
Now, remember, I mentioned no character,
no attribute rule.

00:12:12.730 --> 00:12:17.600
Because the attributes are
associated with characters,

00:12:17.920 --> 00:12:21.270
when there's no attributes,
there's no attributes to be

00:12:21.340 --> 00:12:24.300
inherited to a new string inserted.

00:12:24.470 --> 00:12:30.650
So with this characteristic,
you might get surprised sometimes.

00:12:30.750 --> 00:12:33.590
You might want to be careful about this.

00:12:34.750 --> 00:12:39.940
In this example, we are inserting a
string at rotation three.

00:12:40.840 --> 00:12:43.940
Using the rule 2,
the attributes coming from

00:12:43.940 --> 00:12:48.220
the previous character,
the lowercase c,

00:12:48.810 --> 00:12:52.360
And with this example,
inserting at the beginning,

00:12:52.360 --> 00:12:57.400
we're getting attribute index 0,
the lowercase a,

00:12:59.640 --> 00:13:03.500
And also, when you are replacing
a range of characters,

00:13:03.500 --> 00:13:07.060
you're getting the attribute from the
first character from the old range,

00:13:07.280 --> 00:13:11.720
so lower Tc gives the
attributes a new string.

00:13:14.010 --> 00:13:17.460
Finally,
when you erase the entire string,

00:13:17.490 --> 00:13:19.600
there's no attribute anymore.

00:13:19.740 --> 00:13:24.800
So when you insert a new string,
there's still no attributes.

00:13:24.930 --> 00:13:27.530
So you want to remember this fact.

00:13:30.200 --> 00:13:39.200
[Transcript missing]

00:13:39.800 --> 00:13:43.940
Let's work with attributes
inside AttributeString.

00:13:44.120 --> 00:13:45.610
Internet attributes

00:13:46.990 --> 00:13:50.330
Using attributes at index
effective range method,

00:13:50.330 --> 00:13:55.660
it returns an NSDictionary of
attributes at specified location.

00:13:57.660 --> 00:14:02.040
Notice that the method
takes another argument,

00:14:02.120 --> 00:14:05.040
a pointer to an NSRange.

00:14:05.110 --> 00:14:11.330
Upon returning from this method,
it's filled with the concept of a range

00:14:11.550 --> 00:14:14.870
for the style run at the location.

00:14:15.230 --> 00:14:20.340
So it's useful when you want to identify
the style run you are working with.

00:14:21.020 --> 00:14:25.030
But one thing to note here
is that it doesn't return

00:14:25.200 --> 00:14:27.900
the maximum range possible.

00:14:27.900 --> 00:14:32.000
Because the way API is
designed to be effective,

00:14:32.000 --> 00:14:37.470
it can return the date
range readily available.

00:14:40.100 --> 00:14:50.200
[Transcript missing]

00:14:51.610 --> 00:14:58.410
The range argument could be
filled at index 3 and length 3.

00:14:59.310 --> 00:15:03.080
However,
it's possible to get shorter range,

00:15:03.080 --> 00:15:06.060
or even just the character itself.

00:15:06.190 --> 00:15:10.810
So if you want to work with
the attributes sequentially,

00:15:11.310 --> 00:15:19.320
and Qualus, the operation on style rams,
you can use these convenience method.

00:15:19.680 --> 00:15:29.390
Attributes at index longest effective
range and range and attributes at index

00:15:29.390 --> 00:15:29.390
longest effective range and range.

00:15:31.130 --> 00:15:36.550
This method takes extra effort to
ensure the range you get is the maximum

00:15:36.550 --> 00:15:40.210
continuous range for the start run.

00:15:41.790 --> 00:15:46.120
So when you access string like this,
with attributes that index from

00:15:46.150 --> 00:15:53.660
this effective range in range,
you get the full style runs as expected.

00:15:57.000 --> 00:16:09.180
Similarly, if you use attribute at index,
longest effective range in

00:16:09.180 --> 00:16:09.180
range with NS1 attribute name,
you get two ranges.

00:16:12.190 --> 00:16:17.540
Similarly,
if you use NSProgramColorAttributeName,

00:16:17.680 --> 00:16:21.220
as you expected, three ranges.

00:16:21.260 --> 00:16:22.970
Very simple.

00:16:23.570 --> 00:16:28.570
So if you want to work with
attributes sequentially,

00:16:28.570 --> 00:16:33.980
process, style run one by one,
you can use this attribute

00:16:34.310 --> 00:16:36.300
animation method.

00:16:36.300 --> 00:16:42.180
It takes a block and the block
is invoked per style run.

00:16:45.340 --> 00:16:48.570
So it's useful when you want
to change the attributes

00:16:48.570 --> 00:16:50.790
based on existing attributes.

00:16:50.920 --> 00:16:53.360
For example,
if you want to change the font

00:16:53.490 --> 00:16:57.680
attribute from the regular
typeface to bold typeface,

00:16:57.780 --> 00:16:59.360
it's very useful.

00:16:59.550 --> 00:17:02.370
Similarly,
it's useful for when you want to

00:17:02.370 --> 00:17:06.760
change the string contents while
preserving the multi-style configuration.

00:17:10.200 --> 00:17:13.920
How do you do that?

00:17:14.040 --> 00:17:17.590
In this example,
we are advertising the entire

00:17:17.590 --> 00:17:22.330
string that has multiple styles,
and you want to preserve

00:17:22.330 --> 00:17:24.520
the styles there.

00:17:24.620 --> 00:17:27.940
To do so, first,
we're going to get the current locale

00:17:27.940 --> 00:17:33.200
because the appartage operation
is locale sensitive operation.

00:17:33.440 --> 00:17:38.730
Then we're going to call animate
attributes and range options using block.

00:17:39.200 --> 00:17:44.450
Instead of block,
we create a substring using the specified

00:17:44.450 --> 00:17:47.440
range and replace the characters.

00:17:47.570 --> 00:17:50.490
And here, using the upper case,

00:17:51.220 --> 00:17:55.020
AppletasteString with locale,
specifying the locale to do the

00:17:55.020 --> 00:17:57.400
proper locale-sensitive operation.

00:17:57.560 --> 00:18:06.710
And the result is AppletasteString,
while the attributes are still preserved.

00:18:08.650 --> 00:18:12.740
Now you're familiar with
the attributes string.

00:18:12.900 --> 00:18:18.090
Let's take a look at some of the drawing
attributes we introduce in iOS 6.

00:18:20.540 --> 00:18:23.800
This is an example string
from the previous section.

00:18:23.960 --> 00:18:26.720
Once you have an attributed
string like this,

00:18:26.860 --> 00:18:29.020
rendering is very easy.

00:18:29.450 --> 00:18:32.790
Just send the message, draw a point.

00:18:33.100 --> 00:18:34.730
That's it.

00:18:36.100 --> 00:18:42.390
In iOS 6, we're introducing
NSStringDrawing API from UIKit.

00:18:43.320 --> 00:18:49.340
It's much like the NSRT string
categories found in OS X.

00:18:50.270 --> 00:18:57.300
The method has two major groups,
one simple, one extended.

00:18:57.750 --> 00:19:03.160
In the simple drawing method,
we have drawing rect, draw point, size,

00:19:03.280 --> 00:19:05.800
very simple interface.

00:19:05.870 --> 00:19:10.010
Yet, because of the abilities we are
providing through attributes,

00:19:10.030 --> 00:19:14.210
they can perform pretty
sophisticated tasks here.

00:19:15.800 --> 00:19:21.600
Drawing reg renders itself
inside a specified reg.

00:19:21.730 --> 00:19:30.220
And depending on the setting
inside that string itself,

00:19:30.220 --> 00:19:30.220
it can wrap or truncate itself properly.

00:19:30.730 --> 00:19:35.440
and DrawAtPoint can render
itself at a specified point.

00:19:35.560 --> 00:19:39.700
And since there's no
constraint size specified here,

00:19:39.770 --> 00:19:43.590
it just renders as a single line mode.

00:19:44.150 --> 00:19:47.060
Similarly,
the size method does the single

00:19:47.150 --> 00:19:50.330
line measurement of the receiver.

00:19:51.330 --> 00:19:56.150
and these are pretty much a
giver and their counterpart

00:19:56.150 --> 00:19:58.340
in US String Drawing API.

00:19:58.400 --> 00:20:04.200
DrawingRef is very similar
to DrawingRef with font,

00:20:04.200 --> 00:20:08.580
line break mode, alignment.

00:20:08.800 --> 00:20:15.320
And DrawedPoint,
similar to DrawedPoint with font,

00:20:15.320 --> 00:20:15.320
size method with size with font.

00:20:17.340 --> 00:20:23.520
and we are introducing a slew of
attributes you can use in iOS 6.

00:20:23.870 --> 00:20:33.730
You have many bells and whistles
for configuring the appearance

00:20:34.890 --> 00:20:34.890
of layout of your attribute
strings inside the applications.

00:20:36.000 --> 00:20:41.270
Here, I'm focusing to three of the basic
attributes you're going to be

00:20:41.290 --> 00:20:45.240
commonly using again and again.

00:20:46.590 --> 00:20:50.990
You've already seen the first
two NSFont attribute name and

00:20:51.070 --> 00:20:54.040
NSForegroundColor attribute name.

00:20:54.330 --> 00:20:58.250
and the third one is an NSParagraph
attribute name that controls

00:20:58.250 --> 00:21:00.400
the text formatting options.

00:21:00.450 --> 00:21:09.230
Each of these attributes uses UI font,
UI color and NSParagraph

00:21:09.230 --> 00:21:09.230
style object as its value.

00:21:11.700 --> 00:21:19.800
[Transcript missing]

00:21:21.800 --> 00:21:27.490
An attribute missing from
attribute dictionary means that's

00:21:27.650 --> 00:21:33.700
implying the default value,
not just unspecified.

00:21:33.740 --> 00:21:35.680
What does that mean?

00:21:38.960 --> 00:21:42.940
Instead of just leaving
the attribute unspecified,

00:21:43.100 --> 00:21:47.700
we use the default value for each
attribute if they are missing

00:21:47.700 --> 00:21:49.490
from the attribute dictionary.

00:21:49.610 --> 00:21:55.870
For example, for the font attributes,
we use the system font of system font

00:21:56.100 --> 00:22:01.920
size and the black color for text color,
and similarly default paragraph style

00:22:02.190 --> 00:22:04.690
for the paragraph style attribute.

00:22:09.300 --> 00:22:14.600
Here is an example illustrating
the default value usage.

00:22:14.670 --> 00:22:21.200
Because since there is no unspecified
attributes in AttributeString,

00:22:21.330 --> 00:22:28.190
the attribute string can always
produce an expected result for you.

00:22:28.710 --> 00:22:32.070
For example,
you have an attribute string here,

00:22:32.070 --> 00:22:35.120
this time using initWithString method.

00:22:35.550 --> 00:22:39.390
It's a convenience cover
for the initializer.

00:22:39.390 --> 00:22:42.260
And this method does take any attribute.

00:22:42.360 --> 00:22:47.910
So the attribute is essentially
empty for this attribute string.

00:22:48.270 --> 00:22:55.240
Now, we are rendering, we are filling the
background with red color.

00:22:55.380 --> 00:22:59.450
What this means is the
CG content color property is

00:22:59.700 --> 00:23:02.270
left with a red color setting.

00:23:03.080 --> 00:23:08.550
Now, we render with the empty attributes.

00:23:08.680 --> 00:23:13.240
The end result is instead of
using the CGColorColor property,

00:23:13.360 --> 00:23:18.290
we are using the default value,
black color, to render here.

00:23:22.820 --> 00:23:27.000
Now let's take a look at the final
attribute in this session in the

00:23:27.120 --> 00:23:29.160
form of style attribute name.

00:23:31.750 --> 00:23:36.250
And this part of the style
encapsulates various paragraphs-wide

00:23:36.410 --> 00:23:39.440
text formatting options for you.

00:23:40.690 --> 00:23:46.460
Line Break Mode, Alignment, Line Spacing,
so on and so forth.

00:23:46.580 --> 00:23:52.310
They give you powerful text formatting
capability to your applications.

00:23:53.370 --> 00:23:57.480
And because of that,
you can have rich word processor-like

00:23:57.660 --> 00:24:01.000
text formatting in your application.

00:24:10.400 --> 00:24:15.300
And notice that the single
paragraph style object is

00:24:15.300 --> 00:24:18.290
shared for an entire paragraph.

00:24:18.500 --> 00:24:23.420
Because the way attributed string works,
you can apply and assign multiple

00:24:23.420 --> 00:24:29.660
paragraph style objects to a string,
but only the first attribute,

00:24:29.860 --> 00:24:34.490
the first one associated with the
first character in the paragraph is

00:24:34.640 --> 00:24:37.270
used for the entire paragraph style.

00:24:39.460 --> 00:24:45.400
and this is an example we showed
early in this session from reminders.

00:24:45.510 --> 00:24:49.250
It's using the indenting option
using Power Star to reserve the

00:24:49.320 --> 00:24:53.920
space for the priority icon.

00:24:56.850 --> 00:25:02.020
We have this setting in Paragraph style,
line break mode, alignment,

00:25:02.120 --> 00:25:07.290
spacing for lines,
between lines and between paragraphs.

00:25:07.560 --> 00:25:08.900
indentation.

00:25:08.970 --> 00:25:15.550
You can control margin from left to right
and for the first line specifically.

00:25:15.700 --> 00:25:20.230
And you can have final
control over line height.

00:25:20.530 --> 00:25:23.840
and finally,
you can control hyphenation and right to

00:25:23.840 --> 00:25:27.500
left settings using the power of style.

00:25:29.370 --> 00:25:34.350
We're going to see two of the commonly
used Firehose style settings here.

00:25:38.910 --> 00:25:41.710
First, line break mode.

00:25:41.760 --> 00:25:47.790
It's very similar to UI line
break mode you are familiar with.

00:25:47.790 --> 00:25:47.790
First, you

00:25:47.880 --> 00:25:53.070
We are creating mutable paragraph
style just like other objects.

00:25:53.410 --> 00:25:58.430
The NSParagraphStyle has separation
of mutable and immutable classes.

00:25:58.680 --> 00:26:01.670
Here we're using NSMutableParagraphStyle.

00:26:01.800 --> 00:26:06.050
The init method returns the
paragraph instance configure

00:26:06.810 --> 00:26:08.760
for the system default.

00:26:08.900 --> 00:26:14.800
So that all you have to do is just change
the setting you want to customize here.

00:26:15.070 --> 00:26:18.640
Here, you are changing line break
mode to tail-translation.

00:26:18.730 --> 00:26:26.030
And using this paragraph style,
the end result is tail-translated text.

00:26:28.180 --> 00:26:29.860
Alignment.

00:26:30.170 --> 00:26:36.570
Very similar to UI text alignment,
you can specify left, center,

00:26:36.920 --> 00:26:39.380
right alignment as expected.

00:26:39.500 --> 00:26:44.730
In addition to that,
we are providing full justification.

00:26:51.850 --> 00:26:55.260
And finally,
you can specify a natural alignment.

00:26:55.260 --> 00:26:58.770
What does this mean is that

00:27:00.280 --> 00:27:04.770
When you specify this setting,
for majority of all languages,

00:27:04.860 --> 00:27:09.990
the text is left online,
but if you are working with

00:27:10.190 --> 00:27:13.830
write to left language
such as Arabic or Hebrew.

00:27:13.830 --> 00:27:18.800
It's going to be
automatically write a line.

00:27:24.750 --> 00:27:28.600
usually have an appetite
for more rendering power.

00:27:28.740 --> 00:27:32.120
We have advanced
attributed string sessions.

00:27:32.130 --> 00:27:36.430
We're going to show more bell
and whistle for treating your

00:27:36.430 --> 00:27:38.990
application's attributed string.

00:27:39.800 --> 00:27:45.840
So it's good to come back for this
session if you want to do these tricks.

00:27:47.150 --> 00:27:51.880
Now I'd like to switch over to
my colleague from UIKit group,

00:27:52.010 --> 00:27:56.010
Ian Baird, who's going to show how
these new capabilities are

00:27:56.010 --> 00:27:58.600
integrated into UIKit controls.

00:27:58.870 --> 00:28:00.430
Ian.

00:28:09.960 --> 00:28:10.810
Thank you, Akki.

00:28:11.000 --> 00:28:12.210
Hi, I'm Ian Baird.

00:28:12.470 --> 00:28:18.550
I'm a label engineer for UIKit,
and I'm happy to talk to you about

00:28:18.550 --> 00:28:19.810
UIKit's adoption of attributed strings.

00:28:21.240 --> 00:28:24.850
or how do I get this
stuff into my labels?

00:28:24.980 --> 00:28:30.100
The first thing to remember is that
UILabel is really your nexus of power.

00:28:30.220 --> 00:28:37.160
If you understand how to use
attributed text with UILabel,

00:28:37.170 --> 00:28:40.490
you essentially understand
how to use attributed strings

00:28:40.490 --> 00:28:40.490
with the rest of UIKit.

00:28:41.500 --> 00:28:44.210
This is a UI label with a title.

00:28:44.210 --> 00:28:48.060
It says, hi, I'm a UI label with a title.

00:28:48.060 --> 00:28:49.900
And you can see it's unadorned.

00:28:50.000 --> 00:28:54.990
We've used thousands if not
millions of these in our apps.

00:28:55.080 --> 00:29:01.230
I'd like to introduce to you today
UI label with an attributed title.

00:29:08.020 --> 00:29:12.330
There are a few existing properties on
UILabel that you've probably used before.

00:29:12.480 --> 00:29:14.900
The first one is the text property.

00:29:15.000 --> 00:29:20.060
This takes an NSString instance
and it tells the label what

00:29:20.060 --> 00:29:22.550
you want it to represent.

00:29:23.170 --> 00:29:26.000
The next property is the font property.

00:29:26.150 --> 00:29:29.270
As you see,
we've changed from the system to font,

00:29:29.270 --> 00:29:34.390
in this case, Helvetica Noia,
to one of my favorites, Heuveler Text.

00:29:35.320 --> 00:29:39.430
Next, you can change the text color
by supplying a UI color instance

00:29:39.800 --> 00:29:42.270
to the text color attribute.

00:29:43.090 --> 00:29:53.550
You can even change the text
alignment as we have done here,

00:29:53.550 --> 00:29:53.550
changing the text alignment from
center aligned to left aligned

00:29:53.550 --> 00:29:53.550
using the text alignment property

00:29:55.490 --> 00:29:59.840
You can set up word wrapping
using line break mode.

00:29:59.930 --> 00:30:03.400
You can add a shadow with shadow color.

00:30:03.530 --> 00:30:06.790
And you can change the shadow offset.

00:30:08.110 --> 00:30:13.240
We've added a new property to this,
attributed text.

00:30:13.380 --> 00:30:16.840
As you can see,
now you can supply an NS attributed

00:30:16.840 --> 00:30:20.830
string to UILabel and it will
represent your attributed

00:30:20.830 --> 00:30:23.090
string as we have done here.

00:30:24.130 --> 00:30:28.890
We've also added a new property,
minimum scale factor.

00:30:29.030 --> 00:30:35.680
This tells Label exactly how small it
can shrink all of your fonts before we'll

00:30:35.730 --> 00:30:40.510
begin to truncate the text to try to
fit it within the bounds of the label.

00:30:41.350 --> 00:30:45.930
We also added a new Boolean property,
adjust letter spacing to fit width.

00:30:46.220 --> 00:30:51.370
This tells us exactly how much
-- it tells us exactly -- sorry.

00:30:51.680 --> 00:31:00.590
It tells us we can adjust the tracking
between your characters to try to fit

00:31:00.590 --> 00:31:00.590
all of the text in the UI label's bounds.

00:31:05.540 --> 00:31:09.500
We've deprecated a property.

00:31:09.530 --> 00:31:11.540
Minimum font size.

00:31:11.540 --> 00:31:14.710
In a new world where you
can have multiple fonts and

00:31:14.710 --> 00:31:18.540
multiple font point sizes,
it no longer makes sense to

00:31:18.540 --> 00:31:21.060
specify a minimum font size.

00:31:21.120 --> 00:31:27.510
We would prefer that you instead use
the new minimum scale factor property.

00:31:32.260 --> 00:31:37.500
There are a few things to remember when
using labels and attributed strings.

00:31:37.570 --> 00:31:40.260
And this is one of the most important.

00:31:40.500 --> 00:31:43.960
When you're using any of the
existing style properties,

00:31:44.110 --> 00:31:49.090
the properties are going to apply
the style to the entire string.

00:31:49.360 --> 00:31:59.750
So for example,
if I set the font with the font property,

00:31:59.750 --> 00:31:59.750
NS font attribute name is going to be set
to Helvetica Noi for the entire string.

00:32:00.260 --> 00:32:09.790
Next, if I change the text color
using the text color property,

00:32:09.790 --> 00:32:09.790
you're going to change the text color
for the entire attributed string.

00:32:10.500 --> 00:32:12.940
and that's Label.

00:32:13.070 --> 00:32:15.440
Next today,
I'd like to tell you about what

00:32:15.460 --> 00:32:19.940
we've done with Button by building
on the methods you already know.

00:32:20.110 --> 00:32:30.380
First, the setTitleForControlState
method allows you to supply,

00:32:30.380 --> 00:32:30.490
again, an NSString for a certain
control state for the button.

00:32:30.660 --> 00:32:35.650
This will render the NSString on
the face of the button.

00:32:37.150 --> 00:32:47.080
knew in iOS 6,
set attributed title for control state

00:32:47.080 --> 00:32:47.080
allows you to supply an NS attributed
string for a UI control state.

00:32:48.110 --> 00:32:52.560
And an important point to remember
is that this new attributed title

00:32:52.560 --> 00:32:54.630
is going to take precedence.

00:32:54.690 --> 00:32:58.690
If you set title for UI control
state normal and set attributed

00:32:58.710 --> 00:33:02.680
title for UI control state normal,
the button is going to

00:33:02.790 --> 00:33:04.950
show the attributed title.

00:33:08.040 --> 00:33:14.590
We've even changed Pickerview
to Pickerview Caliente.

00:33:19.290 --> 00:33:27.770
To achieve this effect,
just implement PickerView attributed

00:33:27.770 --> 00:33:27.770
title for row for component in
your UI PickerView data source.

00:33:28.950 --> 00:33:32.400
We've added some
properties to UI TextView.

00:33:32.440 --> 00:33:35.550
The first one is attributed text.

00:33:35.670 --> 00:33:42.700
You can supply an attributed string
to UI TextView and it's going to

00:33:42.700 --> 00:33:42.700
render the string as its content.

00:33:43.970 --> 00:33:49.970
Next, we've added a Boolean property
allows editing text attributes.

00:33:57.400 --> 00:33:59.740
We're excited about it, too.

00:33:59.740 --> 00:34:05.350
It allows your users to interact with
and change any of the style properties in

00:34:05.450 --> 00:34:08.640
the text view on the attributed string.

00:34:08.640 --> 00:34:13.070
You can then fetch this attributed
string back out via the property.

00:34:15.180 --> 00:34:20.860
Any new update to the API of UIKit,
any talk about new updates

00:34:20.860 --> 00:34:24.920
to UIKit is really incomplete
without a discussion of TableView.

00:34:25.010 --> 00:34:29.330
TableView, as Chris said,
is really the workhorse of UIKit.

00:34:29.430 --> 00:34:35.640
And today I'm happy to tell you there
are no new properties or methods.

00:34:37.710 --> 00:34:43.100
just set attributed text on the
cell or header views text label.

00:34:44.920 --> 00:34:49.920
has prepared a demo and he's
going to show you all this cool

00:34:49.920 --> 00:34:52.600
new functionality in UIKit.

00:34:59.100 --> 00:35:00.240
Thanks, Ian.

00:35:00.280 --> 00:35:02.360
Hi, I'm Johannes Fortmann
from the UIKit team,

00:35:02.460 --> 00:35:07.380
and I've prepared a little
application that shows you how to

00:35:07.380 --> 00:35:13.900
use these attributed strings in
your app to render beautiful text.

00:35:13.900 --> 00:35:17.600
My application is basically very simple.

00:35:17.600 --> 00:35:24.130
I have a few pages from speeches
from famous plays and I render them.

00:35:24.130 --> 00:35:29.060
You might use that on the bus to
learn your text if you're an actor,

00:35:29.150 --> 00:35:33.820
for example, or just to look at the
beautiful typography.

00:35:33.820 --> 00:35:36.760
Let me show you how that looks right now.

00:35:36.760 --> 00:35:38.720
I'm switching to demo here.

00:35:38.750 --> 00:35:43.860
I'm going to run this for you
so you can see how it looks.

00:35:43.860 --> 00:35:45.380
And here we go.

00:35:45.420 --> 00:35:48.060
As you can see,
we have a beautiful collection view,

00:35:48.060 --> 00:35:52.580
our new class here,
and we are showing several pages from

00:35:52.580 --> 00:35:57.880
speeches like Midsummer Night's Dream.

00:35:57.880 --> 00:35:59.100
And when you tap one of these,
you can see a nice,

00:35:59.410 --> 00:36:04.910
though unstyled rendering of these.

00:36:04.910 --> 00:36:04.910
And you can see the text here.

00:36:04.910 --> 00:36:04.910
And you can

00:36:05.280 --> 00:36:09.660
So what I want to do first
here is transform my app,

00:36:09.830 --> 00:36:13.470
which has been written against
the old version of the OS,

00:36:13.470 --> 00:36:18.340
apparently,
to use the new amazing features we have.

00:36:18.410 --> 00:36:22.820
I've already put in a method
to compare and contrast these.

00:36:22.820 --> 00:36:27.290
So if I slide here, we see nothing,
because I didn't actually

00:36:27.460 --> 00:36:29.520
implement the rendering.

00:36:29.520 --> 00:36:36.020
It should be -- it should switch
between these two rendering modes.

00:36:36.020 --> 00:36:39.180
So let's look at the
implementation of this.

00:36:39.820 --> 00:36:45.110
Looking at the implementation here,
we have a page view and this page view

00:36:45.170 --> 00:36:49.160
renders pages paragraph by paragraph.

00:36:50.360 --> 00:36:57.020
So what we're doing here is basically
our data model has these pages laid

00:36:57.020 --> 00:37:00.560
out and separated in paragraphs.

00:37:00.560 --> 00:37:07.390
We are going, walking through the page
one paragraph at a time,

00:37:07.390 --> 00:37:10.650
drawing it, and sizing it up.

00:37:11.060 --> 00:37:14.060
We also have a case distinction here.

00:37:14.330 --> 00:37:20.230
If we're using unstyled drawing,
we are just using the old rendering

00:37:20.230 --> 00:37:25.490
path and the style drawing,
well, it's implemented with a copy here.

00:37:25.590 --> 00:37:28.000
That's obviously no good.

00:37:28.010 --> 00:37:30.390
So I'm going to delete this.

00:37:31.420 --> 00:37:34.460
So first, if we want to render
an attributed string,

00:37:34.470 --> 00:37:36.780
we need to get an attributed string.

00:37:36.820 --> 00:37:42.030
I've already implemented a method on my
data model to actually format the string.

00:37:42.030 --> 00:37:45.910
And I'm going to call
it to get my string,

00:37:45.910 --> 00:37:49.180
which I will then later render.

00:37:49.180 --> 00:37:55.030
Then because we have to advance
our page cursor down our page,

00:37:55.030 --> 00:37:57.750
we have to size up our string.

00:37:58.100 --> 00:37:59.980
I'm going to do that.

00:38:00.250 --> 00:38:04.320
And then finally we have
to actually draw it.

00:38:05.080 --> 00:38:05.960
That's it.

00:38:06.070 --> 00:38:07.860
That's how easy this is.

00:38:07.990 --> 00:38:10.180
Let's have a look at this.

00:38:13.480 --> 00:38:14.890
All right.

00:38:14.900 --> 00:38:20.180
So, this is our new rendering,
and I'm zooming in here so you can

00:38:20.260 --> 00:38:23.580
actually see that we are rendering
with attributes because this is

00:38:23.580 --> 00:38:26.010
kind of tiny on the big screen.

00:38:26.010 --> 00:38:31.320
You see how we are beautifully
rendering in two different fonts.

00:38:31.320 --> 00:38:36.000
And if I use my switch gesture,
please pay attention to the will

00:38:36.000 --> 00:38:38.180
here because that's going to change.

00:38:38.180 --> 00:38:41.320
I'm switching back to
the simple rendering now.

00:38:41.320 --> 00:38:45.510
And as you can see, the simple rendering,
unlike the new attributed rendering,

00:38:45.530 --> 00:38:50.240
doesn't support attributes
like the kerning attribute.

00:38:50.240 --> 00:38:53.360
So, we don't actually kern
in the simple rendering,

00:38:53.360 --> 00:38:57.820
whereas we do proper kerning with
the attributed rendering system,

00:38:57.820 --> 00:39:02.670
which allows us to render
this much more beautifully.

00:39:10.010 --> 00:39:10.770
All right.

00:39:10.770 --> 00:39:13.360
Let's switch back to this overview here.

00:39:13.360 --> 00:39:18.530
And as you can see here,
our title of our page

00:39:19.030 --> 00:39:21.700
is using a UI label.

00:39:21.700 --> 00:39:25.720
And right now we are basically
using the standard UI label,

00:39:25.720 --> 00:39:29.910
we are setting the title,
and we are setting the text color.

00:39:29.920 --> 00:39:33.350
But we're not making use
of the new attributes here.

00:39:33.500 --> 00:39:38.380
So let's change that by bringing
this label into the new exciting

00:39:38.380 --> 00:39:40.570
world of attributed strings.

00:39:40.760 --> 00:39:43.870
I'm going to pull up
my page preview cell.

00:39:43.980 --> 00:39:48.030
As you know,
the collection view uses cells to render

00:39:48.030 --> 00:39:51.070
each of these objects we see here.

00:39:51.070 --> 00:39:54.090
And this is the cell we are using.

00:39:54.890 --> 00:39:57.800
Basically what we're doing
right now is what I just said.

00:39:57.800 --> 00:40:02.960
We have a text label,
set its text to the title of our page,

00:40:03.060 --> 00:40:05.240
and then we're setting the color.

00:40:05.300 --> 00:40:09.390
Now we won't need this anymore,
so I can delete it.

00:40:10.170 --> 00:40:14.070
And what we actually need
to do now here is we want to

00:40:14.270 --> 00:40:16.630
create an attributed string.

00:40:16.740 --> 00:40:21.870
What we have to do is first we have to
create a style dictionary which defines

00:40:22.000 --> 00:40:24.810
the style of our attributed string.

00:40:25.310 --> 00:40:27.300
I'm going to do that.

00:40:27.350 --> 00:40:31.320
I'm choosing to leave the
font name empty so we use the

00:40:31.320 --> 00:40:33.540
default font as we did before.

00:40:33.540 --> 00:40:36.040
We didn't set a font on the label.

00:40:36.160 --> 00:40:42.730
I'm only setting the foreground
color to be a red color.

00:40:42.730 --> 00:40:42.730
Just like before.

00:40:42.720 --> 00:40:43.010
Okay.

00:40:43.320 --> 00:40:46.690
Then we have to create the
attributed string here.

00:40:46.780 --> 00:40:49.480
That's a simple call to the method.

00:40:49.480 --> 00:40:55.160
We have to init with the old string,
page title, and use the attributes

00:40:55.610 --> 00:40:57.640
to set on this string.

00:40:57.750 --> 00:41:01.820
And finally,
I have to assign it to my label.

00:41:01.920 --> 00:41:04.970
That's it.

00:41:04.970 --> 00:41:04.970
Let's look at this.

00:41:07.650 --> 00:41:08.960
Well, that was boring.

00:41:09.170 --> 00:41:10.200
We didn't change anything.

00:41:10.200 --> 00:41:11.970
It looks exactly the same.

00:41:12.230 --> 00:41:16.970
But we can see here that at least we've
verified that our attributed string

00:41:16.970 --> 00:41:21.730
rendering works exactly like it did
before with the non-attributed rendering.

00:41:21.830 --> 00:41:24.690
Let's go back and spice this up a little.

00:41:24.830 --> 00:41:29.540
You can see we've -- in our labels,
we have basically always the

00:41:29.540 --> 00:41:34.240
name of the play and then the
name of a scene within this play.

00:41:34.400 --> 00:41:38.710
What I want to do now is kind of
emphasize the name of the scene here.

00:41:38.810 --> 00:41:42.950
So I want to set a different font,
a bold font.

00:41:43.090 --> 00:41:44.910
Let's do that.

00:41:45.360 --> 00:41:48.750
I've already created a mutable
attributed string so I can now change

00:41:48.750 --> 00:41:51.480
the attributes on our attributed string.

00:41:51.480 --> 00:41:56.020
And to change the attributes
on part of the string,

00:41:56.020 --> 00:42:01.340
what I have to do is first actually find
the separator that divides our name of

00:42:01.730 --> 00:42:04.240
the play from the name of the scene.

00:42:04.300 --> 00:42:06.520
That's a hyphen in this case.

00:42:06.680 --> 00:42:09.280
So I'm going to find this hyphen.

00:42:09.530 --> 00:42:15.050
Oh, first I'm going to, of course,
create the font I want to later set.

00:42:15.710 --> 00:42:18.690
Then I'm going to find my hyphen.

00:42:18.690 --> 00:42:22.120
That's just a call to range of string.

00:42:22.390 --> 00:42:25.950
Now I have to move my range that
I just created to just after

00:42:25.950 --> 00:42:30.280
the hyphen because we don't want
the hyphen to actually be bold.

00:42:30.440 --> 00:42:34.640
And finally,
I have to extend the range to

00:42:34.730 --> 00:42:38.290
the full extent of my scene name.

00:42:38.500 --> 00:42:40.680
So let me do that.

00:42:41.240 --> 00:42:46.660
The last thing I have to do is actually
set my new bold font on this range,

00:42:46.720 --> 00:42:49.100
this range only, of course.

00:42:49.220 --> 00:42:52.330
So I'm doing that.

00:42:52.430 --> 00:42:56.970
Let's have another look at the
current appearance of this.

00:42:58.530 --> 00:42:59.420
All right.

00:42:59.420 --> 00:43:04.920
I'm going to zoom in here so we
can actually see that this is bold.

00:43:04.920 --> 00:43:07.450
And it's a very nice bold.

00:43:07.450 --> 00:43:12.920
It's understated and tasteful,
yet kind of beautiful.

00:43:14.540 --> 00:43:15.440
All right.

00:43:15.560 --> 00:43:18.500
Let's have a look at the page view again.

00:43:18.500 --> 00:43:23.090
Now, you see here we have
these stage directions.

00:43:23.100 --> 00:43:25.600
I'm going to show you
with the mouse here.

00:43:25.630 --> 00:43:28.690
It's the Oberon leading the
fairy sing and dance here,

00:43:28.690 --> 00:43:29.740
for example.

00:43:29.740 --> 00:43:32.070
And these are kind of indented.

00:43:32.270 --> 00:43:34.890
I did that with a few spaces.

00:43:34.890 --> 00:43:36.810
It's not as good as it could be.

00:43:36.990 --> 00:43:43.560
And, well, it's also black like
the rest of the text.

00:43:43.580 --> 00:43:48.040
So, people might actually
accidentally read this.

00:43:48.050 --> 00:43:54.750
So, what I want to do now is change these
stage directions to be first making

00:43:54.750 --> 00:44:02.610
use of the NS paragraph style attribute
centered and second to have a slightly

00:44:02.610 --> 00:44:05.790
different color and better font.

00:44:05.790 --> 00:44:07.740
So, let's do that.

00:44:07.740 --> 00:44:12.020
And here I'm going to show you
how I'm formatting these strings.

00:44:12.030 --> 00:44:14.860
I do that in my data model in the
attributed string for paragraph

00:44:14.860 --> 00:44:17.880
method which I'm pulling up now.

00:44:17.880 --> 00:44:19.740
And this is really very simple.

00:44:19.870 --> 00:44:25.250
What we're doing here is we get the
speaker for the current paragraph,

00:44:25.340 --> 00:44:29.230
we get the text,
and then we create an attributed

00:44:29.310 --> 00:44:34.040
string for the speaker and an
attributed string for the text.

00:44:34.330 --> 00:44:36.660
Finally, we append those.

00:44:36.660 --> 00:44:41.440
So, and then we return the
value for current paragraph.

00:44:41.440 --> 00:44:41.740
Now, you can see here that the string is
not the same as the previous string.

00:44:41.930 --> 00:44:46.560
You can see here the attributes
we are using are attributes that

00:44:46.560 --> 00:44:51.950
are apparently instance variables
here which are already predefined.

00:44:52.210 --> 00:44:56.520
That's a good idea because we don't
want to create a new dictionary every

00:44:56.520 --> 00:44:59.590
time we format a simple paragraph.

00:44:59.710 --> 00:45:01.800
So, let's look at where we define that.

00:45:01.870 --> 00:45:07.250
And I'm doing that in my
designated initializer here.

00:45:07.270 --> 00:45:09.080
In the knit with title method.

00:45:09.130 --> 00:45:10.820
That's my pages initializer.

00:45:10.820 --> 00:45:12.060
together.

00:45:13.510 --> 00:45:20.280
You can see here I'm creating the speaker
attributes with my speaker color and

00:45:20.280 --> 00:45:26.610
bold font and I'm creating the text
attributes with the text color and,

00:45:26.730 --> 00:45:29.590
well, the regular font here.

00:45:29.830 --> 00:45:33.740
and now I want to create my
stage direction attributes.

00:45:33.740 --> 00:45:37.100
Now, as I said,
I want these to be centered.

00:45:37.100 --> 00:45:40.150
So I have to create a NS paragraph style.

00:45:40.450 --> 00:45:41.850
In fact, an NSMutable paragraph style.

00:45:41.860 --> 00:45:45.820
I'm going to create that one.

00:45:46.180 --> 00:45:47.360
That's my centered style.

00:45:47.360 --> 00:45:50.750
It's the default style,
only it's mutable.

00:45:50.900 --> 00:45:57.610
And now I have to actually set its
alignment to be actually centered.

00:45:57.850 --> 00:46:02.910
That's this line where
I just set the alignment.

00:46:02.930 --> 00:46:10.250
I also have to create a font that's
for this paragraph style I chose to use

00:46:10.250 --> 00:46:14.310
an italic font that's a bit lighter.

00:46:14.310 --> 00:46:14.310
That's the

00:46:14.650 --> 00:46:17.410
and Helvetica Light Oblique font.

00:46:17.540 --> 00:46:22.420
Now, having created that,
all that remains for me to do

00:46:22.420 --> 00:46:28.870
for this is to actually create
the style dictionary and stow it

00:46:28.870 --> 00:46:28.870
away into my instance variable.

00:46:29.280 --> 00:46:30.440
All right.

00:46:30.470 --> 00:46:36.870
Now that we have initialized
our style dictionary,

00:46:36.870 --> 00:46:36.870
I'm going back to the
attributed string method.

00:46:37.280 --> 00:46:40.770
And now I can format my paragraph.

00:46:41.050 --> 00:46:44.430
Of course, I only want to format it if
it's actually stage direction.

00:46:44.540 --> 00:46:46.900
Otherwise,
the current formatting is fine.

00:46:47.120 --> 00:46:50.690
So I'm distinguishing the two cases.

00:46:51.140 --> 00:46:55.000
This one here is if the
paragraph is a stage direction.

00:46:55.140 --> 00:46:58.140
And the other one is my old one,
old case.

00:46:58.390 --> 00:47:00.840
Let me reformat that quickly.

00:47:00.940 --> 00:47:06.190
That's the case where we format as usual.

00:47:06.850 --> 00:47:10.410
Okay, in the stage direction case,
all that remains for me to do

00:47:10.410 --> 00:47:18.340
is actually format the text
with my new paragraph style and,

00:47:18.340 --> 00:47:23.600
well, append it to my return value.

00:47:23.650 --> 00:47:25.990
Let me run that for you.

00:47:28.510 --> 00:47:30.120
and here we go.

00:47:30.320 --> 00:47:33.180
Let me zoom in.

00:47:33.180 --> 00:47:37.030
And now my paragraph is
actually centered and the font

00:47:37.050 --> 00:47:38.550
is changed and the color too.

00:47:38.620 --> 00:47:40.730
All right.

00:47:40.730 --> 00:47:45.710
Let me switch back to slides.

00:47:56.440 --> 00:48:00.690
So to sum this up,
you've seen how to actually draw text

00:48:00.780 --> 00:48:04.100
using the attributed string methods.

00:48:04.120 --> 00:48:09.460
You've seen how easy it is
to enhance an existing label.

00:48:09.460 --> 00:48:15.450
So you have a label which
is pretty common case.

00:48:15.490 --> 00:48:20.620
And you want to spruce it up just a
little by adding extended attributes.

00:48:20.700 --> 00:48:25.390
And finally, you have seen how to
use paragraph styles.

00:48:25.430 --> 00:48:28.550
And with that, I give back to Ian.

00:48:34.450 --> 00:48:35.250
Thank you, Johannes.

00:48:35.300 --> 00:48:41.720
So you've seen a lot of things today.

00:48:44.030 --> 00:48:49.510
You've seen the basics of using,
creating, modifying,

00:48:49.510 --> 00:48:53.030
and querying attributed strings.

00:48:53.240 --> 00:48:54.090
You've seen how to do this.

00:48:54.210 --> 00:48:58.230
Akki took you on a
whirlwind tour of the API.

00:48:58.720 --> 00:49:05.060
Next, you saw how to draw them and
use them with paragraph styles.

00:49:05.060 --> 00:49:09.380
And finally, we showed you how they
were adopted by UIKit.

00:49:10.360 --> 00:49:14.390
If you'd like to know more,
I'd recommend contacting our

00:49:14.390 --> 00:49:17.060
UI Frameworks evangelist,
Jake Behrens.

00:49:17.110 --> 00:49:20.260
He'll be happy to help guide
you in your quest for more

00:49:20.260 --> 00:49:24.900
information about attributed
strings and their use with UIKit.

00:49:25.270 --> 00:49:30.260
Next, you can also visit the
UIKit documentation online.

00:49:30.450 --> 00:49:34.390
And finally, if you haven't visited the
Apple Developer Forums,

00:49:34.480 --> 00:49:35.640
I would urge you to.

00:49:35.910 --> 00:49:41.400
It's a great place to go to give
and receive peer-to-peer support and

00:49:41.400 --> 00:49:46.710
interact with employees like Akki,
Johannes, and myself.

00:49:47.620 --> 00:49:50.110
Next, we have a few related sessions.

00:49:50.320 --> 00:49:53.540
As Akki talked about earlier,
we have our advanced attributed

00:49:53.540 --> 00:49:55.160
strings for iOS talk.

00:49:55.370 --> 00:49:57.500
You're going to learn
about shadow attribute,

00:49:57.630 --> 00:50:03.620
stroke attribute,
and a host of other attributes

00:50:04.710 --> 00:50:04.710
that we talked about today
but didn't go into depth for.

00:50:04.990 --> 00:50:09.890
Next, you should catch the video
for keyboard input in iOS.

00:50:10.050 --> 00:50:12.920
They're going to talk
more about UI Text Field,

00:50:13.000 --> 00:50:16.650
UI Text View,
and their adoption of attributed string.

00:50:16.890 --> 00:50:22.070
Finally, there's going to be a session
on core text and fonts.

00:50:22.170 --> 00:50:26.370
Core text is the awesome,
awesome framework which underlies

00:50:26.370 --> 00:50:28.450
all of this new technology.

00:50:28.630 --> 00:50:32.610
So I would urge you to
go and see this session.
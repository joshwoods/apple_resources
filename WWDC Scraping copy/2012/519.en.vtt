WEBVTT

00:00:10.070 --> 00:00:12.560
Good morning, everyone,
and welcome to Multiplayer

00:00:12.560 --> 00:00:14.330
Gaming with Game Center.

00:00:14.390 --> 00:00:18.570
I'm Christy Warren,
and I hope you're having a great WWDC.

00:00:18.720 --> 00:00:19.530
I love it here.

00:00:19.730 --> 00:00:23.180
New toys, new APIs, new fun.

00:00:23.180 --> 00:00:27.850
So I'm here to tell you about how to
add multiplayer gaming to your game.

00:00:28.270 --> 00:00:30.700
I'm going to talk about
our matchmaking UI,

00:00:30.700 --> 00:00:35.380
which makes it easy and quick for
you to have players connect with

00:00:35.500 --> 00:00:37.440
other players to play your game.

00:00:37.500 --> 00:00:40.240
I'm going to talk about
programmatic matchmaking,

00:00:40.310 --> 00:00:43.680
which will allow you to create
a more custom user experience.

00:00:43.920 --> 00:00:46.630
I'm going to talk about how to

00:00:46.800 --> 00:00:51.180
Share data between instances of your
game via peer-to-peer communications.

00:00:51.180 --> 00:00:54.800
And I'm going to then take you on a tour
through the world of turn-based gaming,

00:00:54.800 --> 00:01:00.570
which is a great new feature we
added in iOS 5 that allows for more

00:01:00.570 --> 00:01:04.260
freeform and asynchronous gameplay.

00:01:04.810 --> 00:01:09.600
But first let's talk about why
add multiplayer to your game.

00:01:09.670 --> 00:01:12.190
Now I know that you're at a
multiplayer gaming session,

00:01:12.200 --> 00:01:14.560
so you probably already want to do this.

00:01:14.770 --> 00:01:16.940
But let's talk about the benefits.

00:01:17.050 --> 00:01:20.260
How many of you out there,
raise your hands if you have a

00:01:20.260 --> 00:01:22.300
game on the App Store already?

00:01:22.420 --> 00:01:24.410
Or are planning on it?

00:01:25.260 --> 00:01:28.300
Well, one of your biggest challenges,
at least from what I hear

00:01:28.300 --> 00:01:31.930
and what I understand,
is discoverability.

00:01:32.050 --> 00:01:36.650
You've worked long and hard and
you've made your game awesome.

00:01:36.880 --> 00:01:42.500
But it is just one game out of
650,000 apps on the App Store.

00:01:42.660 --> 00:01:46.200
And there are players like me who
love games and want to play your game,

00:01:46.280 --> 00:01:48.570
but how do I discover them?

00:01:49.060 --> 00:01:51.840
Well,
let's suppose I own a copy of your game

00:01:51.900 --> 00:01:54.560
and my friend Nate over here doesn't.

00:01:54.640 --> 00:01:57.230
If it's single player,
I could just wait until

00:01:57.230 --> 00:01:58.000
I see him next time.

00:01:58.000 --> 00:02:02.520
I go into the office or whatever and say,
"Hey, you know, this game is awesome.

00:02:02.600 --> 00:02:06.120
Why don't you download and
buy it?" If your game supports

00:02:06.120 --> 00:02:10.380
multiplayer and I own it,
I can invite him to play,

00:02:10.450 --> 00:02:12.380
and he'll see this on his screen.

00:02:12.440 --> 00:02:14.790
And when he taps on this,

00:02:15.030 --> 00:02:18.660
It'll take him right to a buy
button and he can buy your game.

00:02:18.820 --> 00:02:21.900
This is free and easy viral
marketing that you get by

00:02:21.950 --> 00:02:24.490
just supporting multiplayer.

00:02:25.070 --> 00:02:28.760
Furthermore,
multiplayer makes your game stand out.

00:02:28.800 --> 00:02:31.980
If I just play a single player game,
I'm playing against AI.

00:02:31.980 --> 00:02:34.760
I'm going to go off in
the corner and play.

00:02:34.790 --> 00:02:35.670
I might earn an achievement.

00:02:35.670 --> 00:02:36.840
I killed 30 robots.

00:02:38.700 --> 00:02:40.810
Okay, whatever, move on.

00:02:40.810 --> 00:02:45.300
There's another 599,000
games on the App Store,

00:02:45.300 --> 00:02:46.530
or apps on the App Store.

00:02:46.550 --> 00:02:49.990
But if it's multiplayer
and I'm playing a game,

00:02:49.990 --> 00:02:54.700
say I'm playing a tennis game with
Nate and he aces me five times and

00:02:54.780 --> 00:02:58.600
he gets the five aces achievement,
I'm going to see that on his

00:02:58.710 --> 00:03:01.600
office door and I'm going to hear
about it for the next two weeks.

00:03:02.430 --> 00:03:06.510
Suddenly, your game moves from being just
a personal experience to being

00:03:06.870 --> 00:03:11.270
woven into my social milieu,
increases engagement and competition,

00:03:11.270 --> 00:03:15.670
and it makes those leaderboards
and achievements really matter.

00:03:15.680 --> 00:03:19.280
Because suddenly, I've got to play them,
I've got to beat them,

00:03:19.280 --> 00:03:21.470
I've got to make up for that mistake.

00:03:23.340 --> 00:03:28.590
And finally, the top games in the
App Store support multiplayer.

00:03:28.590 --> 00:03:33.150
If you look back over the history of
gaming in the last 10 or 20 years,

00:03:33.170 --> 00:03:37.030
think about the names that stand out,
that have large and

00:03:37.030 --> 00:03:39.200
long-lasting communities.

00:03:39.600 --> 00:03:42.160
Websites dedicate them,
or even conventions.

00:03:43.420 --> 00:03:45.120
These games support multiplayer.

00:03:45.180 --> 00:03:49.200
Wouldn't you like a chance for
your game to gain immortality?

00:03:49.200 --> 00:03:52.200
So what's new in iOS 6?

00:03:52.450 --> 00:03:57.200
Well, we give you a new and streamlined
matchmaking UI that lets your

00:03:57.200 --> 00:03:59.200
players get into your game quickly.

00:03:59.200 --> 00:04:04.160
We also give you the ability to
discover players on nearby devices.

00:04:04.180 --> 00:04:06.680
So even if they're not your friends,
you know,

00:04:06.820 --> 00:04:10.200
if he's running a game and she's
running a game right here in this room,

00:04:10.200 --> 00:04:12.200
I can find them, connect with them,
and play with them.

00:04:13.200 --> 00:04:14.840
with him.

00:04:15.230 --> 00:04:18.420
We also support,
in addition to programmatic auto-match,

00:04:18.650 --> 00:04:20.750
we support programmatic invites.

00:04:20.990 --> 00:04:25.390
So now the full functionality
of our standard UI is available

00:04:25.390 --> 00:04:28.390
to you programmatically,
so you can make it blend better

00:04:28.390 --> 00:04:32.770
with your application or your game.

00:04:32.860 --> 00:04:34.610
Also...

00:04:37.870 --> 00:04:40.760
Also, when your game is over,
on the Game Over screen,

00:04:40.760 --> 00:04:44.290
you can add a re-match button
and get your players back

00:04:44.370 --> 00:04:46.370
into the action right away.

00:04:47.050 --> 00:04:50.340
And also we support the
ability to do host selection.

00:04:50.340 --> 00:04:54.010
What this means is if
we have four devices,

00:04:54.290 --> 00:04:58.300
it's often a good idea to pick
one device to act as the master.

00:04:58.450 --> 00:05:01.340
And now we make that really easy to do.

00:05:01.450 --> 00:05:05.630
And for turn-based gaming,
we support better handling of missed

00:05:05.630 --> 00:05:10.510
turns and the ability to save your
match data in the middle of a turn.

00:05:11.950 --> 00:05:16.900
But perhaps the biggest feature
new in iOS 6 is the ability to face

00:05:16.900 --> 00:05:19.300
off with your friends on the Mac.

00:05:19.430 --> 00:05:21.040
And this is awesome.

00:05:21.180 --> 00:05:24.850
There have been success stories where
developers have ported their iOS

00:05:24.850 --> 00:05:28.480
game to the Mac in just a few days,
at least get it up and running.

00:05:28.630 --> 00:05:31.920
So the relatively small
amount of engineering work,

00:05:32.000 --> 00:05:34.660
you can open up this additional platform.

00:05:34.740 --> 00:05:40.560
New customers, newer App Store, you know,
great opportunity to expand

00:05:40.560 --> 00:05:43.220
your base and get visibility.

00:05:45.190 --> 00:05:47.060
So let's talk about the
styles of multiplayer.

00:05:47.280 --> 00:05:54.690
We support three styles: peer-to-peer,
turn-based, and server-based.

00:05:57.250 --> 00:06:01.530
Peer-to-peer supports 2-4 players.

00:06:01.710 --> 00:06:04.700
Turn-based supports 2-16.

00:06:04.790 --> 00:06:07.750
And server-based is also 2-16.

00:06:08.160 --> 00:06:10.900
The gameplay in peer-to-peer
is simultaneous.

00:06:10.950 --> 00:06:16.100
This means I get my device,
three of my friends get their devices,

00:06:16.170 --> 00:06:17.970
we connect up and we play together.

00:06:17.970 --> 00:06:21.100
It's kind of the classic
way we do multiplayer.

00:06:21.480 --> 00:06:24.100
Turn-based is a different breed.

00:06:24.100 --> 00:06:26.760
In turn-based, I can create a match.

00:06:26.780 --> 00:06:29.040
I can pass the turn to another.

00:06:29.040 --> 00:06:32.020
And when I'm not playing,
I don't even have to be at the table.

00:06:32.150 --> 00:06:36.100
I can walk away, I can tweet,
I can do whatever I want.

00:06:36.100 --> 00:06:39.100
And only when it becomes my turn again
do I have to return to that game.

00:06:39.100 --> 00:06:43.530
So it actually supports a
mobile lifestyle even more

00:06:43.530 --> 00:06:46.100
nicely than peer-to-peer.

00:06:46.620 --> 00:06:48.010
and server base.

00:06:48.050 --> 00:06:51.740
So the sequence is a sequential play.

00:06:51.850 --> 00:06:53.520
Server base is usually simultaneous.

00:06:53.520 --> 00:06:55.490
I mean, yes,
there are chess servers out there where

00:06:55.500 --> 00:06:58.490
you can play turn-based games online,
but this is typically to

00:06:58.490 --> 00:07:02.510
implement your MMORPG or similar
massively online service.

00:07:04.410 --> 00:07:09.540
The hosting on peer-to-peer is either
a particular device or distributed.

00:07:09.540 --> 00:07:12.520
Turn-based is fully distributed.

00:07:12.520 --> 00:07:15.300
Server-based is your server.

00:07:15.740 --> 00:07:20.330
The communication in peer-to-peer
is point-to-point or broadcast.

00:07:20.400 --> 00:07:22.660
Turn-based is just point-to-point.

00:07:22.710 --> 00:07:25.900
And server-based is developer-defined.

00:07:26.310 --> 00:07:29.750
We provide the APIs to do data
transmission for turn-based

00:07:29.860 --> 00:07:31.660
and peer-to-peer and in-server.

00:07:31.890 --> 00:07:32.650
You're on your own.

00:07:32.880 --> 00:07:34.370
Sorry.

00:07:35.690 --> 00:07:37.600
Let's talk about
peer-to-peer multiplayer.

00:07:37.600 --> 00:07:42.160
A few concepts for those of you
who may not be familiar with this.

00:07:42.230 --> 00:07:47.600
We're going to illustrate this with
an example of a four-player game.

00:07:47.830 --> 00:07:50.500
Dungeon, death, cage match.

00:07:50.680 --> 00:07:56.910
The idea is you get together
with four other players,

00:07:56.910 --> 00:07:58.120
you pick a hero or a monster,
and you get in and you rumble with them.

00:07:58.560 --> 00:08:01.560
So to set this game up,
the first thing you do is you

00:08:01.560 --> 00:08:03.640
begin the matchmaking process.

00:08:03.710 --> 00:08:06.440
This creates the game table,
and the game table represents

00:08:06.550 --> 00:08:08.200
your communication channel.

00:08:08.320 --> 00:08:11.130
This is how all the data
moves back and forth,

00:08:11.130 --> 00:08:14.160
the state changes and
notifications occur,

00:08:14.270 --> 00:08:16.930
and even handles the invite process.

00:08:17.040 --> 00:08:20.410
So the first thing we do
is we invite my friends,

00:08:20.410 --> 00:08:22.160
in this case Sue and Bob.

00:08:22.560 --> 00:08:26.300
The fourth player is one of those
famous players to be named later.

00:08:26.890 --> 00:08:30.750
So Sue and Bob accept,
and now they're in the channel.

00:08:31.000 --> 00:08:35.060
Depending on how you implement this,
you could even at this

00:08:35.230 --> 00:08:37.840
point set up a voice chat,
which you can read about

00:08:37.880 --> 00:08:38.960
in the documentation.

00:08:39.020 --> 00:08:42.000
Or you could start some
initial game activity.

00:08:42.120 --> 00:08:45.160
But in this case,
let's say we're gonna move on

00:08:45.160 --> 00:08:46.900
and find this fourth player.

00:08:46.950 --> 00:08:49.350
In this case, Meg joins in.

00:08:49.460 --> 00:08:53.420
And now that everyone's present,
we're good to go.

00:08:53.420 --> 00:08:55.340
We can play.

00:08:56.280 --> 00:08:59.740
So to build this,
these are the tasks you have to do.

00:08:59.750 --> 00:09:04.180
You have to implement the process
of picking the players via invite

00:09:04.290 --> 00:09:07.070
or nearby players or via auto-match.

00:09:07.340 --> 00:09:10.200
And by nearby players,
I mean other people running

00:09:10.200 --> 00:09:11.820
the devices in the same room.

00:09:12.110 --> 00:09:15.860
Then once we're invited,
we wait for the players to connect

00:09:16.280 --> 00:09:18.890
and observe their state changes.

00:09:18.890 --> 00:09:23.900
And then once we're ready to go,
we play and we send and receive data.

00:09:24.710 --> 00:09:28.760
So on the left here,
there's entry points.

00:09:28.850 --> 00:09:30.820
And let's talk about that for a moment.

00:09:30.820 --> 00:09:34.900
You know, there's three entry
points that a user will --

00:09:35.070 --> 00:09:39.030
: The first is kind of obvious.

00:09:39.240 --> 00:09:41.760
You'll have a button in your game,
play multiplayer.

00:09:41.770 --> 00:09:46.510
When they press it,
the UI comes up and they can immediately

00:09:46.510 --> 00:09:48.990
press play to go into the game.

00:09:48.990 --> 00:09:50.390
And this is our new UI.

00:09:50.450 --> 00:09:51.900
It's really awesome.

00:09:51.920 --> 00:09:56.690
If you tap the close box,
it will make that slot go away.

00:09:56.690 --> 00:09:58.940
It has two to four players.

00:09:58.970 --> 00:10:02.130
And when they hit the close box,
it will go to three players.

00:10:02.130 --> 00:10:03.890
Hit it again, it will go to two.

00:10:04.200 --> 00:10:05.860
And you have the ability
to add them back in.

00:10:07.200 --> 00:10:13.580
If you hit invite friends,
it'll bring up a friend picker and

00:10:13.580 --> 00:10:15.780
let you choose some friends to play.

00:10:15.780 --> 00:10:17.720
And once you choose them,

00:10:17.890 --> 00:10:21.900
You'll go right into the game adding
any auto-match players if necessary.

00:10:21.960 --> 00:10:24.210
So just set up and go.

00:10:24.580 --> 00:10:27.720
No more complicated interactions.

00:10:27.860 --> 00:10:28.800
That's awesome.

00:10:28.800 --> 00:10:32.200
The second and third entry
points are kind of related.

00:10:32.260 --> 00:10:37.020
The second one is if Nate invites me and
I get one of those notification banners

00:10:37.050 --> 00:10:42.690
and I tap it and I accept the invite,
we will launch your game.

00:10:43.360 --> 00:10:48.090
And once we launch the game,
you need to put up this UI and

00:10:48.090 --> 00:10:49.790
show the matchmaking in progress.

00:10:49.800 --> 00:10:53.140
And once it connects, you're good to go.

00:10:53.200 --> 00:10:56.580
And kind of similar to that,
if I hit -- if I go into Game Center and

00:10:56.580 --> 00:10:58.780
I find a game that Nate is playing,

00:10:59.970 --> 00:11:04.410
I can tap play right there and
that will launch the app and start

00:11:04.480 --> 00:11:07.460
the -- it will also invite Nate,
but it will start the matchmaking

00:11:07.460 --> 00:11:11.280
process and you need to go through a
similar thing where you put up the UI.

00:11:11.280 --> 00:11:13.000
So let's talk about this UI.

00:11:13.010 --> 00:11:14.550
What do we need to put it up?

00:11:14.550 --> 00:11:17.000
We make a match request.

00:11:17.020 --> 00:11:19.700
Match request contains sort
of your preferences about

00:11:19.700 --> 00:11:21.960
what you want from the match,
like the number of players.

00:11:21.960 --> 00:11:23.840
Is it two or is it four?

00:11:23.940 --> 00:11:28.500
We then pass that to the
matchmaker view controller.

00:11:28.950 --> 00:11:32.010
And that will interact with a
singleton matchmaker under the

00:11:32.060 --> 00:11:34.240
covers and produce the GK match.

00:11:34.400 --> 00:11:37.400
GK match is this game table.

00:11:37.400 --> 00:11:39.400
It's your channel for communications.

00:11:39.480 --> 00:11:41.570
So to set up,
we make the match request and

00:11:41.650 --> 00:11:44.270
specify the number of players,
min and max.

00:11:44.400 --> 00:11:47.340
There's some other options
which I'll talk about later.

00:11:47.520 --> 00:11:49.900
Once we have the match request,
we show the view controller.

00:11:49.900 --> 00:11:53.900
You construct the view controller,
pass in the master request.

00:11:54.110 --> 00:11:55.400
And this is important.

00:11:55.400 --> 00:11:56.400
You need to set the delegate.

00:11:56.400 --> 00:11:59.780
And as with many of our APIs,
or most of our APIs,

00:11:59.900 --> 00:12:03.820
if you don't set the delegate,
things will just mysteriously not work.

00:12:04.080 --> 00:12:05.900
So make sure you do that.

00:12:05.900 --> 00:12:07.900
And then you present it as usual.

00:12:07.980 --> 00:12:09.660
Now...

00:12:09.900 --> 00:12:13.560
Once the user hits play or takes
some other action in the UI,

00:12:13.560 --> 00:12:15.400
you need to respond to those actions.

00:12:15.400 --> 00:12:17.240
So we do that with the delegate.

00:12:17.320 --> 00:12:19.370
In this case,
we're going to show what happens

00:12:19.370 --> 00:12:21.140
when we successfully find a match.

00:12:21.200 --> 00:12:23.600
You have a new match,
so you set the delegate.

00:12:23.670 --> 00:12:25.550
Now it's your code and
you're ready to go.

00:12:25.710 --> 00:12:27.670
You know, just set up your match and go.

00:12:27.760 --> 00:12:30.030
Now, that's one of the delegate
methods we implement,

00:12:30.040 --> 00:12:33.200
which is when the user hits
play or they invite friends.

00:12:33.290 --> 00:12:36.290
The user hits cancel on the upper left.

00:12:37.180 --> 00:12:41.890
If the match fails,
like I've invited Jeff or Nate and

00:12:41.890 --> 00:12:45.690
they're on a bus going through a tunnel,
they've accepted,

00:12:45.720 --> 00:12:48.940
then the bus goes in the tunnel,
they lose connection,

00:12:49.060 --> 00:12:52.500
they'll get did fail with error and
you need to take appropriate action.

00:12:52.560 --> 00:12:57.100
Now, on the handling invitation side,
you implement an invite handler block.

00:12:57.150 --> 00:13:01.570
And this block implements the
second two entry points for when

00:13:01.570 --> 00:13:05.860
you accept an invite or when
you launch from Game Center.

00:13:05.940 --> 00:13:07.420
And this is important.

00:13:07.500 --> 00:13:09.840
You want to give your
users good experience,

00:13:09.900 --> 00:13:10.660
don't you?

00:13:10.780 --> 00:13:14.920
So when you accept an invite,
you'll launch the app.

00:13:15.660 --> 00:13:18.870
I don't want to go through a
bunch of set-up screens or menus.

00:13:19.210 --> 00:13:24.740
I want to go right into the matchmaking
process and get into the game.

00:13:24.760 --> 00:13:27.200
So install that invite
handler as early as possible.

00:13:27.200 --> 00:13:30.340
And we recommend you actually
authenticate an application

00:13:30.420 --> 00:13:32.320
that did finish launching.

00:13:32.320 --> 00:13:34.900
And then install your event handler
if you successfully authenticate.

00:13:34.970 --> 00:13:37.280
That will get called automatically.

00:13:37.370 --> 00:13:40.600
And you'll be able to
go right on from there.

00:13:40.600 --> 00:13:42.600
So how do we implement this?

00:13:42.600 --> 00:13:48.030
Well, you have one invite handler
for both kinds of -- you know,

00:13:48.060 --> 00:13:49.590
both these invite entry points.

00:13:49.590 --> 00:13:51.590
And it takes two arguments.

00:13:51.600 --> 00:13:55.530
It takes a GK invite
and a list of players.

00:13:55.720 --> 00:14:00.870
Only one of these will be non-nil,
depending on whether it was the accept

00:14:00.870 --> 00:14:03.590
invite or the Game Center launch.

00:14:03.600 --> 00:14:07.420
So if there's an invite,
we construct a matchmaker view controller

00:14:07.420 --> 00:14:09.560
and set the day we'll get a present.

00:14:09.690 --> 00:14:11.600
And we set the matchmaker view
controller to the same pattern as before.

00:14:11.600 --> 00:14:14.940
If there are players,
we use a different initializer,

00:14:14.940 --> 00:14:17.590
a match request, and players to invite.

00:14:17.600 --> 00:14:20.600
And we set the delegate and we present.

00:14:20.600 --> 00:14:22.600
And that's all there is to it.

00:14:22.630 --> 00:14:25.580
So in summary,
we create the match request.

00:14:25.660 --> 00:14:27.450
We present the standard UI.

00:14:27.450 --> 00:14:29.570
We handle the invites.

00:14:29.600 --> 00:14:32.140
And this same UI, by the way,
works if you want to

00:14:32.140 --> 00:14:33.600
host the game yourself.

00:14:33.600 --> 00:14:36.940
The only difference is you go
through a little different API that

00:14:37.030 --> 00:14:38.600
doesn't return a GK match data.

00:14:38.600 --> 00:14:40.600
Or GK match.

00:14:40.600 --> 00:14:44.740
It returns a -- it just gives
you the information required to

00:14:44.930 --> 00:14:46.600
let you go on with your server.

00:14:46.600 --> 00:14:49.290
And you can read about
that in the documentation.

00:14:50.260 --> 00:14:53.410
So now let's say you want to
provide your own custom look.

00:14:53.570 --> 00:14:55.600
You want to do the UI yourself.

00:14:55.630 --> 00:15:00.180
We now give you all the features
to do programmatic matchmaking.

00:15:00.770 --> 00:15:04.440
So to do this,
you make your match request,

00:15:04.440 --> 00:15:08.570
and this time you call the
Singleton matchmaker directly,

00:15:08.570 --> 00:15:10.900
and it will return your match.

00:15:11.750 --> 00:15:13.660
So do this.

00:15:13.720 --> 00:15:16.080
This is all the code you need.

00:15:16.110 --> 00:15:17.590
Just this little bit.

00:15:17.600 --> 00:15:19.560
You get the shared matchmaker.

00:15:19.560 --> 00:15:21.900
You call find match for request.

00:15:21.900 --> 00:15:23.990
Handle any errors if you need to.

00:15:23.990 --> 00:15:25.480
In other words, you're good to go.

00:15:25.680 --> 00:15:27.800
So if you want to get your -- if
you have a single-player game and

00:15:27.800 --> 00:15:31.800
you want to try out multiplayer,
this is the only code you have to

00:15:32.060 --> 00:15:34.600
write other than handling the data.

00:15:34.600 --> 00:15:36.510
You can get connected.

00:15:36.590 --> 00:15:39.460
You can start trying out your game.

00:15:39.460 --> 00:15:40.600
And you're good to go.

00:15:40.600 --> 00:15:42.380
It's that easy.

00:15:43.250 --> 00:15:47.800
And if you want to find nearby
players running your game,

00:15:47.910 --> 00:15:49.640
it's also pretty easy.

00:15:49.710 --> 00:15:51.760
You get the shared matchmaker.

00:15:51.820 --> 00:15:55.330
You call this new API,
start browsing for nearby

00:15:55.340 --> 00:15:57.430
players with reachable.

00:15:57.750 --> 00:16:02.110
And if you find one,
someone using a device in the same room,

00:16:02.300 --> 00:16:03.230
add them to the array.

00:16:03.470 --> 00:16:06.490
Probably a good idea to check
if they're reachable or not.

00:16:07.110 --> 00:16:10.840
And when you're done looking,
you call stop browsing.

00:16:10.870 --> 00:16:16.080
Now, new for iOS 6, we can send invites.

00:16:16.960 --> 00:16:18.060
You know, programmatically.

00:16:18.240 --> 00:16:22.080
So what you do is you get
your shared matchmaker.

00:16:22.490 --> 00:16:25.740
In the match request, there's a field,
Players Who Invite, and you give it the

00:16:25.750 --> 00:16:27.090
players you wish to invite.

00:16:27.100 --> 00:16:31.190
These may be players that you've
played with previously or players you

00:16:31.190 --> 00:16:35.200
just discovered through that local
multiplayer browsing that we just did.

00:16:35.480 --> 00:16:40.400
And once you have them,
you call find match requests.

00:16:40.660 --> 00:16:43.450
You get your match and you're good to go.

00:16:45.640 --> 00:16:49.570
Now one thing you need to do
is when you invite someone,

00:16:49.570 --> 00:16:55.730
you may wish to give feedback
for when the players responded.

00:16:56.030 --> 00:16:59.730
You may want to go from
inviting to connecting,

00:16:59.730 --> 00:17:03.180
or you may wish to show that
they're actually ready to go.

00:17:03.430 --> 00:17:06.900
So we allow you to implement
a response handler.

00:17:07.020 --> 00:17:08.540
And this gets called.

00:17:08.760 --> 00:17:11.460
And at this point,
you can mark your players

00:17:11.460 --> 00:17:12.940
accepted in your UI.

00:17:13.080 --> 00:17:16.360
And then there's also a good
trigger for starting your game.

00:17:16.570 --> 00:17:19.130
You can ask yourself,
do I have enough players yet?

00:17:19.280 --> 00:17:21.200
And if you are,
you can tell the matchmaker,

00:17:21.200 --> 00:17:25.590
finish matchmaking, and we're good to go.

00:17:27.190 --> 00:17:32.000
Now let me step back and talk about some
other features on the match request.

00:17:32.150 --> 00:17:34.210
You know,
player groups is a way to allow players

00:17:34.430 --> 00:17:38.300
of like minds to play the part of
the game that they love the most.

00:17:38.420 --> 00:17:40.700
So let's illustrate
this with a racing game.

00:17:40.790 --> 00:17:42.320
So let's say there's
four kinds of tracks:

00:17:42.460 --> 00:17:48.600
oval, figure eight, curvy,
and the wave with that long straightaway.

00:17:48.750 --> 00:17:50.740
And my favorite track
is the figure eight.

00:17:50.740 --> 00:17:53.050
And let me tell you a secret,
it's because it's the

00:17:53.050 --> 00:17:54.300
only one I'm any good at.

00:17:56.310 --> 00:18:00.580
So I want to play with other players
who love the figure-eight track.

00:18:00.650 --> 00:18:02.880
So I can just set that by setting
the player group on the match

00:18:02.890 --> 00:18:04.510
request of the figure-eight track.

00:18:04.550 --> 00:18:07.190
This is a constant that you define.

00:18:07.190 --> 00:18:08.830
It's a 32-bit int.

00:18:08.910 --> 00:18:11.040
You can define as many
or as few as you wish.

00:18:11.040 --> 00:18:13.270
And we'll just match them in.

00:18:13.280 --> 00:18:17.250
So other ideas for this is easy, normal,
or hard.

00:18:17.370 --> 00:18:18.070
Or game type.

00:18:18.080 --> 00:18:22.120
You might want to play Deathmatch or
Capture the Flag or Team Fortress.

00:18:22.120 --> 00:18:28.290
But there's one subtlety here, which is,
let's say I love to play the oval track,

00:18:28.290 --> 00:18:32.100
but the rest of you like the other three.

00:18:32.100 --> 00:18:32.100
And I'm trying to match
at three in the morning.

00:18:33.420 --> 00:18:35.720
Well, there may not be anybody else on,
so I might be waiting a

00:18:35.720 --> 00:18:36.870
long time to get a match.

00:18:37.020 --> 00:18:39.560
That's not a good user experience.

00:18:39.920 --> 00:18:41.800
So what can we do?

00:18:42.050 --> 00:18:46.480
Well, we have an API to check for the
activity on that player group.

00:18:46.480 --> 00:18:50.800
So you can check that,
and if it's low or zero, you can say,

00:18:50.800 --> 00:18:53.800
"Hey, Christy, nobody else is playing
that track right now.

00:18:53.800 --> 00:18:58.420
Do you want to go into the general pool,
or do you wish to pick another track?"

00:18:58.680 --> 00:19:02.350
So that's a good feature if
you wish to use player groups.

00:19:02.350 --> 00:19:11.020
Now kind of a dual to that in a moment,
yay, is player attributes.

00:19:11.070 --> 00:19:14.280
This allows you to specify the role
that you wish to play in the game.

00:19:14.580 --> 00:19:17.560
This is a 32-bit unsigned integer.

00:19:17.560 --> 00:19:20.480
And what we do is I get a value,
Nate gets a value.

00:19:20.480 --> 00:19:22.840
Each player who wishes
to play chooses a value.

00:19:22.840 --> 00:19:24.640
And they'll be orred together.

00:19:24.640 --> 00:19:27.440
And a match will be made if
all the numbers are orred

00:19:27.440 --> 00:19:28.410
together to form a match.

00:19:28.600 --> 00:19:31.500
A pattern of all ones in the bits.

00:19:31.560 --> 00:19:33.420
So let's walk through
this with an example.

00:19:33.440 --> 00:19:37.300
In chess, maybe I prefer to play black.

00:19:37.300 --> 00:19:39.810
So I'll give it the pattern FFF000.

00:19:39.840 --> 00:19:47.870
If Megan likes to play white,
she gets 000FFF.

00:19:48.730 --> 00:19:51.000
Let's say Nate is happy
to play either color.

00:19:51.000 --> 00:19:52.470
So he'll just give me all Fs.

00:19:52.480 --> 00:19:57.220
And when we matchmake,
we'll pick players that will

00:19:57.220 --> 00:19:59.540
match together to all Fs.

00:19:59.750 --> 00:20:03.770
Now Nate, even though he's got all Fs,
will not just match with himself

00:20:03.860 --> 00:20:07.500
because we also have to meet the other
requirements like minimum players.

00:20:07.610 --> 00:20:10.740
So it'll pick any other player.

00:20:10.920 --> 00:20:17.630
So other examples of this,
a role-playing game like

00:20:17.630 --> 00:20:20.750
our Dungeon Cage Match.

00:20:20.920 --> 00:20:23.630
You could pick fighter, cleric, mage,
or thief.

00:20:23.760 --> 00:20:26.550
Or in a soccer game, goalie, forward,
or defense.

00:20:28.970 --> 00:20:33.280
So in summary,
you create the match request,

00:20:33.300 --> 00:20:35.700
use player groups or
attributes as desired,

00:20:35.700 --> 00:20:37.390
you request the match,
you wait for them to connect,

00:20:37.480 --> 00:20:39.390
and then you play.

00:20:40.940 --> 00:20:44.040
So now let's talk about
once you've made a match,

00:20:44.140 --> 00:20:47.870
how do you do the communications
between the peers?

00:20:48.960 --> 00:20:53.860
So we're first talking about
networking strategy and host selection.

00:20:53.940 --> 00:20:56.450
How to send and receive data.

00:20:57.190 --> 00:21:00.860
How to observe state changes.

00:21:00.860 --> 00:21:04.860
So on the right here,
I'm showing our GK match and

00:21:04.860 --> 00:21:07.460
you implement a match delegate.

00:21:07.920 --> 00:21:11.030
And these four things you implement
are all you have to do to handle

00:21:11.310 --> 00:21:13.200
peer-to-peer communications.

00:21:13.240 --> 00:21:14.840
Let's go into this.

00:21:14.890 --> 00:21:17.310
But first, networking strategy.

00:21:17.420 --> 00:21:21.440
If I have four devices that are playing
your game and they're sharing data,

00:21:21.520 --> 00:21:25.740
one way I might do this is
every time I make a move,

00:21:25.790 --> 00:21:28.440
I broadcast my changes to
the other four players.

00:21:28.460 --> 00:21:31.070
And if Nate makes a move,
he broadcasts to all four

00:21:31.070 --> 00:21:33.340
players and so forth.

00:21:33.390 --> 00:21:36.210
Now, this is not a good idea.

00:21:36.780 --> 00:21:41.120
It consumes unnecessary bandwidth
because it's sending redundant data.

00:21:41.160 --> 00:21:45.100
And furthermore, if I'm making changes,
Nate's making changes,

00:21:45.170 --> 00:21:48.030
Dan's making changes,
you're going to have to implement some

00:21:48.030 --> 00:21:51.040
kind of conflict resolution coherency.

00:21:51.120 --> 00:21:53.190
And that's a lot of
complexity for your code.

00:21:53.490 --> 00:21:55.800
There's a better way.

00:21:56.050 --> 00:21:59.800
Choose one of your devices as the host.

00:22:00.520 --> 00:22:03.160
It'll be the holder of
the truth of your app,

00:22:03.340 --> 00:22:04.800
of your game.

00:22:04.840 --> 00:22:08.040
The other devices can
communicate their updates.

00:22:08.120 --> 00:22:11.640
My device can reconcile those changes
and then broadcast it to the others.

00:22:11.640 --> 00:22:15.150
This uses less bandwidth
and makes your code simpler.

00:22:15.270 --> 00:22:16.460
So that's a win all around.

00:22:16.480 --> 00:22:19.330
Now, in the past,
we've told you to do this.

00:22:19.330 --> 00:22:22.500
But it turns out, I mean,
if you ever try to get, you know,

00:22:22.610 --> 00:22:26.140
yourself and three of your friends to,
you know, when they're not in the same

00:22:26.220 --> 00:22:28.870
room to agree on anything,
coordinate on anything,

00:22:29.060 --> 00:22:30.960
that's a difficult problem.

00:22:30.970 --> 00:22:34.920
And we kind of had you guys
solving that in the past.

00:22:34.920 --> 00:22:40.910
But new in iOS 6, we give you a simple
API to pick your host.

00:22:41.410 --> 00:22:46.140
All four devices call choose best
host player with completion handler.

00:22:46.400 --> 00:22:49.990
And it will pick one of the player
IDs based on the device they're using,

00:22:50.000 --> 00:22:52.540
the network they're using, and so forth.

00:22:52.670 --> 00:22:54.690
And it will be consistent
across all four devices.

00:22:54.700 --> 00:22:57.030
Once you call this,
you've got your host picked.

00:22:57.040 --> 00:22:59.150
It is that easy.

00:23:01.800 --> 00:23:03.840
So now let's talk about sending data.

00:23:03.870 --> 00:23:06.960
There are three choices
that you need to make here.

00:23:07.130 --> 00:23:10.270
The first one is data size and frequency.

00:23:10.920 --> 00:23:14.890
And what this is about is,
let's say I have my space shooter game.

00:23:14.890 --> 00:23:16.920
And I'm flying my spaceship.

00:23:16.920 --> 00:23:20.330
And I want the peer to see every
movement I make as I jitter

00:23:20.330 --> 00:23:22.240
my finger across the screen.

00:23:22.240 --> 00:23:24.620
I want to make the ship move.

00:23:24.620 --> 00:23:28.750
I could do this by sending the update 60
times a second and I send all the data

00:23:28.750 --> 00:23:30.960
on the game as my ship's moving across.

00:23:31.020 --> 00:23:33.080
Well, that's obviously a bad idea.

00:23:33.170 --> 00:23:34.350
It's inefficient.

00:23:34.350 --> 00:23:36.020
It sends unnecessary data.

00:23:36.020 --> 00:23:37.820
And it sends it too often.

00:23:38.000 --> 00:23:42.700
So you should use some techniques
like dead reckoning where you not

00:23:42.700 --> 00:23:46.360
only send over the new positions,
you send their velocities,

00:23:46.360 --> 00:23:47.020
their acceleration.

00:23:47.020 --> 00:23:52.930
You could even analyze the movement
of my finger and generate a standard

00:23:53.320 --> 00:23:55.980
deviation and send that across.

00:23:55.980 --> 00:23:55.980
Then the peer...

00:23:56.360 --> 00:24:13.340
can just model that and interpolate.

00:24:13.340 --> 00:24:13.340
Now you can send the
information less often.

00:24:13.340 --> 00:24:13.340
Rather than 60 times a second,
you send it five times a second.

00:24:13.340 --> 00:24:13.340
And this improves your latency
and your user experience.

00:24:13.340 --> 00:24:13.450
So make good choices here.

00:24:13.670 --> 00:24:16.120
Now you can also choose
communication styles,

00:24:16.160 --> 00:24:19.240
you know,
between reliable and unreliable.

00:24:19.330 --> 00:24:23.940
You know, unreliable,
you just send the packet and forget it.

00:24:24.010 --> 00:24:27.870
And this is good for clocked
updates like my ship movement.

00:24:28.090 --> 00:24:29.540
You know,
because I've already implemented

00:24:29.540 --> 00:24:33.260
this interpolation logic,
it's okay if one of my

00:24:33.260 --> 00:24:35.340
clocked updates is missed.

00:24:35.390 --> 00:24:38.190
You know,
the peer can predict the movement

00:24:38.190 --> 00:24:41.660
and fill in the missing parts.

00:24:41.710 --> 00:24:45.210
Now, for something like, you know,
my ship blows up,

00:24:45.210 --> 00:24:49.900
and so now I have two ships left,
that's an event, and it's important the

00:24:49.900 --> 00:24:50.930
other side knows that.

00:24:51.130 --> 00:24:53.240
I'm not going to send it again.

00:24:53.360 --> 00:24:57.500
So I use reliable communications,
and it sends the packet.

00:24:57.820 --> 00:25:01.800
If the packet doesn't make it to
Nate or whoever is receiving it,

00:25:01.800 --> 00:25:03.270
Game Center will send it again.

00:25:03.300 --> 00:25:05.680
It will retry it until it
gets an acknowledgement.

00:25:05.890 --> 00:25:08.740
So it's good for events,
but it's not good for sort

00:25:08.740 --> 00:25:11.040
of ongoing game activity.

00:25:11.510 --> 00:25:16.700
Now the final choice is whether you send
to individual players or to all players.

00:25:16.700 --> 00:25:20.770
And this code here shows how
to send data to all players.

00:25:21.200 --> 00:25:26.490
You just make an NSData with your data,
send data to all players with data mode,

00:25:26.510 --> 00:25:29.330
and there's an out parameter
of an error that gets called,

00:25:29.340 --> 00:25:31.600
and you need to handle that error.

00:25:31.680 --> 00:25:34.690
The code for sending to specific
players is just as easy.

00:25:34.900 --> 00:25:36.900
You make an array.

00:25:37.020 --> 00:25:39.680
If you're hosted,
it'll probably be one player,

00:25:39.680 --> 00:25:42.700
but you could send it to two or three,
your choice.

00:25:42.820 --> 00:25:44.000
And it's the same kind of thing.

00:25:44.000 --> 00:25:47.490
Send data to players
with data mode and error.

00:25:49.040 --> 00:25:52.640
Now receiving data is even easier.

00:25:52.680 --> 00:25:55.800
You get a callback on your delegate,
did receive data,

00:25:55.800 --> 00:25:58.590
and will tell you what player sent it.

00:26:00.720 --> 00:26:04.490
Now, the last thing you need to do
is to check for state changes.

00:26:04.490 --> 00:26:07.130
When a player connects,
you want to show some

00:26:07.170 --> 00:26:09.100
feedback they're connecting.

00:26:09.100 --> 00:26:12.180
You maybe put their photo
on the screen or something.

00:26:12.470 --> 00:26:16.230
We checked for that state and did change
state and if the player is connected,

00:26:16.300 --> 00:26:18.240
give that feedback.

00:26:18.310 --> 00:26:20.520
If they've disconnected,

00:26:21.200 --> 00:26:24.130
You know, take appropriate action.

00:26:24.130 --> 00:26:28.100
And this is also a good time
to call expected players.

00:26:28.150 --> 00:26:30.500
If your game hasn't started,

00:26:30.900 --> 00:26:33.900
The expected players will tell you
how many players are still connecting.

00:26:33.910 --> 00:26:38.240
If you have no expected players,
you're ready to start your game.

00:26:38.340 --> 00:26:43.310
Now, if you lose connection and it's a
one-on-one game that's invite-only,

00:26:43.420 --> 00:26:45.960
You can implement should we
invite player in your delegate.

00:26:45.960 --> 00:26:49.160
If you make this true,
then if I invite someone,

00:26:49.160 --> 00:26:51.740
let's say Megan,
and she's on a bus going through a

00:26:51.740 --> 00:26:55.620
tunnel and she loses her connection,
all is not lost.

00:26:55.970 --> 00:26:59.860
Game Center on your behalf will
send her a new invite and when

00:26:59.860 --> 00:27:03.530
she comes out of that tunnel,
she'll get that invite and she accepts.

00:27:03.630 --> 00:27:08.280
She's back in the action playing
with me as if nothing had happened.

00:27:08.440 --> 00:27:10.940
I can also add other players
to the existing game,

00:27:10.940 --> 00:27:14.730
and this follows the
similar pattern closely.

00:27:14.990 --> 00:27:17.790
Get your match request.

00:27:17.940 --> 00:27:20.410
Update the parameters as you desire.

00:27:20.640 --> 00:27:22.620
Create the view controller.

00:27:22.680 --> 00:27:25.670
And then call this API,
add players to match,

00:27:25.670 --> 00:27:27.910
giving it your current match.

00:27:28.220 --> 00:27:31.780
So in summary,
we've talked about the matchmaking

00:27:31.780 --> 00:27:35.680
UI and how it can quickly
get players into your game.

00:27:35.840 --> 00:27:39.130
We've talked about handling invites
and programmatic matchmaking if

00:27:39.190 --> 00:27:41.440
you wish to roll your own UI.

00:27:41.590 --> 00:27:43.320
And we've talked about
peer-to-peer communication and

00:27:43.330 --> 00:27:44.460
some of the best practices.

00:27:46.760 --> 00:27:49.120
And now let's move on to turn-based.

00:27:49.200 --> 00:27:52.070
So in contrast to peer-to-peer,

00:27:52.630 --> 00:27:55.740
Not everyone has to be at
the table at the same time.

00:27:55.820 --> 00:28:00.000
There's no need to manage
connection and disconnection.

00:28:00.140 --> 00:28:01.660
Instead, you're playing a game.

00:28:01.740 --> 00:28:04.470
In this example,
we have four players or four

00:28:04.470 --> 00:28:09.690
friends in a six-player game and
you and a player to be named later.

00:28:10.260 --> 00:28:12.700
So right now it's my turn.

00:28:12.840 --> 00:28:15.960
So I have to be at the table,
but the others may not be there yet.

00:28:16.000 --> 00:28:17.460
In fact, this may be a new match.

00:28:17.460 --> 00:28:19.600
They've not even been invited.

00:28:19.600 --> 00:28:23.950
And when I take my turn
and I pass it to Sue,

00:28:24.460 --> 00:28:26.580
she gets an invite.

00:28:26.670 --> 00:28:30.600
When she accepts, she's now at the table.

00:28:30.600 --> 00:28:32.610
Same for Bob.

00:28:32.720 --> 00:28:36.700
Now even the player to be named later,
when we pass the turn to them,

00:28:36.700 --> 00:28:40.660
they get matched in at that point.

00:28:40.890 --> 00:28:44.670
So far the match has proceeded
in sort of a natural order,

00:28:44.670 --> 00:28:46.260
but it's not restricted to that.

00:28:46.280 --> 00:28:49.020
Meg could choose to pass the turn to Sam.

00:28:49.020 --> 00:28:53.460
Now Sam, being really grateful,
could pass it back to Meg.

00:28:55.320 --> 00:28:57.200
and Meg may choose then
to pass it back to you.

00:28:57.200 --> 00:29:00.290
The order is completely up to you.

00:29:00.430 --> 00:29:03.800
Now let's go into a little more
detail of how the turn flow goes.

00:29:04.000 --> 00:29:05.650
So it's my turn.

00:29:05.760 --> 00:29:07.130
I've updated my game data.

00:29:07.310 --> 00:29:09.410
I pass it to the server.

00:29:09.760 --> 00:29:12.470
Sue gets a push notification.

00:29:13.060 --> 00:29:15.760
If Sue wishes to take this
turn or accept this invite,

00:29:15.870 --> 00:29:18.320
she gets the game data it's her turn.

00:29:18.510 --> 00:29:21.120
She now passes it to Bob.

00:29:21.490 --> 00:29:26.010
Now let's say Bob is going
on a trip around the world.

00:29:26.010 --> 00:29:28.020
And he's one of these
people who likes to,

00:29:28.140 --> 00:29:30.280
when he's on vacation,
he's really on vacation,

00:29:30.280 --> 00:29:31.400
so he's off the grid.

00:29:31.560 --> 00:29:33.470
He's left his phone at home.

00:29:33.540 --> 00:29:37.810
I know that's hard for a lot of us, but,
you know, it's a good thing to do.

00:29:38.010 --> 00:29:40.320
So Bob misses his turn.

00:29:40.450 --> 00:29:45.060
Now this is a problem in iOS 5,
because now this match is stuck.

00:29:45.180 --> 00:29:47.440
Bob never comes back to it.

00:29:47.580 --> 00:29:49.430
The game's dead.

00:29:49.730 --> 00:29:54.490
But thankfully in iOS 6 we have a new
API called Fallbacks and Timeouts.

00:29:54.490 --> 00:29:59.090
And with Fallbacks and Timeouts,
Sue could choose not just Bob,

00:29:59.090 --> 00:30:02.250
but Meg and the others.

00:30:02.370 --> 00:30:04.100
As many players as they want.

00:30:04.270 --> 00:30:08.410
They can even repeat players or make
it the player who has the current turn.

00:30:08.410 --> 00:30:12.380
The game will time out
and pass it to Meg.

00:30:13.530 --> 00:30:15.800
and she gets the data
and we're good to go.

00:30:15.860 --> 00:30:18.000
We can also support multiple matches.

00:30:18.050 --> 00:30:20.020
I'm not very good at chess,
but there may be some of you

00:30:20.020 --> 00:30:23.640
out there that can play 30
games of chess at a time.

00:30:23.730 --> 00:30:26.480
And that's possible
with turn-based gaming.

00:30:26.570 --> 00:30:32.910
We support up to 30 simultaneous matches.

00:30:32.910 --> 00:30:32.910
We support 16 players per match.

00:30:33.390 --> 00:30:36.300
This gameplay is fully asynchronous.

00:30:36.360 --> 00:30:41.290
The game data we pass
around is up to 64K bytes.

00:30:42.070 --> 00:30:46.240
The seats are filled via
invitation or auto-match.

00:30:46.440 --> 00:30:49.480
The turn order is developer defined.

00:30:50.260 --> 00:30:54.440
And missed turns are handled
through a callback list.

00:30:54.440 --> 00:30:57.420
And the turn timeout which you
pass in will give you a constant

00:30:57.420 --> 00:30:59.200
which defaults to two weeks.

00:30:59.230 --> 00:31:01.000
But you can also choose
a different timeout.

00:31:01.000 --> 00:31:04.680
Although we recommend you don't
make it like five minutes or

00:31:04.730 --> 00:31:08.900
an hour because that would make
your game less fun for the users.

00:31:08.970 --> 00:31:12.180
Now the expectations of a turn-based
game is that you need to be able to

00:31:12.180 --> 00:31:15.400
handle multiple simultaneous matches.

00:31:15.510 --> 00:31:19.100
Each one will have its own state,
its own player, its own outcome.

00:31:19.190 --> 00:31:23.320
And you'll need to let the player
choose among the matches which one

00:31:23.650 --> 00:31:25.710
they want to view or take a turn on.

00:31:26.190 --> 00:31:27.690
Also, one player at a time.

00:31:27.690 --> 00:31:31.200
Other players will observe,
but the player who has

00:31:31.330 --> 00:31:34.060
the turn can make changes.

00:31:35.040 --> 00:31:37.760
Now, your app is not always running.

00:31:37.990 --> 00:31:43.920
A typical use pattern here is,
I'm off tweeting or updating my Facebook.

00:31:44.400 --> 00:31:45.420
You know, a turn comes in.

00:31:45.420 --> 00:31:47.430
I go, okay, I'll take that turn.

00:31:47.430 --> 00:31:50.020
We'll launch your app,
I'll take the turn,

00:31:50.020 --> 00:31:51.490
and then I'll exit and
go back to tweeting.

00:31:51.500 --> 00:31:54.130
Now I want to write that
great American tweet,

00:31:54.130 --> 00:31:55.890
so that's got to come first.

00:31:58.540 --> 00:32:01.200
Now,
I may be anywhere in your app as well.

00:32:01.300 --> 00:32:04.150
I may be taking a turn from Nate.

00:32:04.910 --> 00:32:08.580
and Megan finishes her
turn and passes it to me.

00:32:08.640 --> 00:32:11.040
You should handle this
notification and say,

00:32:11.040 --> 00:32:14.320
hey, Christy,
Megan wants to play with you.

00:32:14.400 --> 00:32:18.650
Do you want to exit your current
match or leave that current

00:32:18.660 --> 00:32:24.750
match and go to Megan's game
and come back to Nate's later?

00:32:25.090 --> 00:32:28.540
You just need to give a
good user experience here.

00:32:29.940 --> 00:32:34.420
So the classes involved
with turn-based gaming.

00:32:34.420 --> 00:32:35.870
We have a GK turn-based match.

00:32:35.940 --> 00:32:40.320
This is the counterpart to
GK match for turn-based.

00:32:40.620 --> 00:32:43.490
It represents a single instance
of the game as the list of

00:32:43.490 --> 00:32:45.340
the participants involved.

00:32:45.400 --> 00:32:48.450
It contains the current game state.

00:32:48.530 --> 00:32:51.680
It also indicates whose turn it is.

00:32:52.600 --> 00:32:53.910
Now what are these participants?

00:32:53.990 --> 00:32:57.710
I've talked about players a lot,
but now I've brought up this new term,

00:32:57.710 --> 00:32:58.720
participant.

00:32:58.900 --> 00:33:02.470
And why do we have two things
that are sort of alike?

00:33:02.830 --> 00:33:07.790
And the reason is the participant
is the slot at the table.

00:33:07.900 --> 00:33:11.830
You know, it's an open position,
and until that player accepts

00:33:12.030 --> 00:33:15.640
the invite or joins the game,
it doesn't have a player yet.

00:33:15.880 --> 00:33:19.140
So turn-based gaming thinks
in terms of participants.

00:33:19.230 --> 00:33:22.960
When that participant gets filled,
it gets a player ID set.

00:33:23.420 --> 00:33:27.730
It has a status which is invited or
matching and then becomes active when

00:33:27.830 --> 00:33:29.870
it's playing and then it becomes done.

00:33:29.880 --> 00:33:33.600
The outcome of the game gets
filled in when the game is

00:33:33.600 --> 00:33:35.420
over or the player quits.

00:33:35.420 --> 00:33:39.870
And there are various outcomes like won,
lost, tied, and so forth.

00:33:41.950 --> 00:33:44.300
We have a GK turn-based event handler.

00:33:44.300 --> 00:33:47.580
This is a singleton for handling
all your turn-based events.

00:33:47.670 --> 00:33:51.490
So this gets called when you
get invited or you join a match.

00:33:51.700 --> 00:33:54.180
Or when an invite is initiated
from the Game Center app.

00:33:54.200 --> 00:33:59.590
So those are the second two entry
points we talked about before.

00:33:59.690 --> 00:34:01.700
It also gets called when
someone has taken their turn

00:34:01.700 --> 00:34:03.440
or when the match has ended.

00:34:03.500 --> 00:34:06.600
And finally, we have the GK Turn-Based
Matchmaker View Controller.

00:34:06.600 --> 00:34:09.400
This is the focal point for
the actions in your game.

00:34:09.570 --> 00:34:13.800
Now remember I told you that you have
to manage up to 30 simultaneous matches?

00:34:13.950 --> 00:34:17.320
Well, it turns out that we can do
most of the work for you.

00:34:17.570 --> 00:34:23.240
We provide a UI here that contains
a list of all your active matches.

00:34:23.240 --> 00:34:27.150
Your current turn, matches that have the
other player's turn.

00:34:27.260 --> 00:34:30.110
If there's an invite pending,
it'll show it at the top there.

00:34:30.120 --> 00:34:31.730
It'll also show matches
that you've already won.

00:34:31.730 --> 00:34:37.970
The user can select these and you'll get
a callback that lets your game show them.

00:34:37.980 --> 00:34:40.010
So this could act as your
complete match manager.

00:34:40.010 --> 00:34:42.980
If I swipe it,
I can delete it and that'll

00:34:42.980 --> 00:34:44.750
quit from the match.

00:34:45.540 --> 00:34:49.680
If I hit the plus on the upper right,
it'll take me to the matchmaking

00:34:49.680 --> 00:34:53.400
UI and let me invite players or
just hit play now to auto match.

00:34:54.770 --> 00:34:57.140
So it's a complete solution.

00:34:57.320 --> 00:34:59.500
So how do we pose this?

00:34:59.560 --> 00:35:01.700
We make a match request.

00:35:01.720 --> 00:35:07.140
We construct the view controller,
just like with peer-to-peer.

00:35:07.220 --> 00:35:09.730
Here's a difference, however.

00:35:10.120 --> 00:35:12.350
There's a field on the
View Control called

00:35:12.460 --> 00:35:14.000
Show Existing Matches.

00:35:14.030 --> 00:35:18.980
If you want that match manager UI,
you set this to Yes.

00:35:19.110 --> 00:35:21.840
If you prefer to roll your
own that's more integrated

00:35:21.840 --> 00:35:24.750
with your look or whatever,
set that to No,

00:35:24.760 --> 00:35:30.300
and you'll just get the matchmaking
piece but not the match manager piece.

00:35:30.440 --> 00:35:33.030
And once you're ready, you present.

00:35:35.320 --> 00:35:39.080
Now there's some delegate actions on
the ViewController that get called.

00:35:39.160 --> 00:35:43.390
So when a user creates a new match,
they call didFindMatch.

00:35:43.920 --> 00:35:50.190
When a user selects a match in the UI,
you also get called Turn-Based

00:35:50.190 --> 00:35:50.190
Matchmaker ViewControllerDidFindMatch.

00:35:51.410 --> 00:35:55.900
If you accept an invite,
you get called did find match.

00:35:55.900 --> 00:35:59.900
If the user hits cancel
on the upper left,

00:35:59.900 --> 00:36:03.620
you get turn-based matchmaker
view controller was canceled.

00:36:04.140 --> 00:36:06.260
The match failed?

00:36:06.270 --> 00:36:09.280
He had called with did fail with error.

00:36:10.970 --> 00:36:15.980
If a user swipes to remove a match,
you get player quit for match.

00:36:17.730 --> 00:36:21.600
Now let's implement did find
match for when a user selects one.

00:36:21.600 --> 00:36:25.580
So the first thing we need to do,
and this is true of all of these events,

00:36:25.680 --> 00:36:27.470
is you need to dismiss
the view controller.

00:36:27.680 --> 00:36:31.220
We don't know when to take it down,
so you need to tell us.

00:36:32.310 --> 00:36:36.600
Secondly,
now an improvement we've made in iOS

00:36:36.600 --> 00:36:40.820
since iOS 5 is that we do our best
to make sure the match data is up

00:36:40.820 --> 00:36:42.920
to date whenever you get the match.

00:36:42.920 --> 00:36:46.770
So if you just get it off the match,
it'll have a current value.

00:36:46.780 --> 00:36:50.380
But even so, it's still good to load
the latest match data.

00:36:50.400 --> 00:36:55.460
Someone may have quit in the short
time between we last got it and now.

00:36:55.460 --> 00:36:56.860
So I would load it.

00:36:56.900 --> 00:37:00.330
Now display that match to your user.

00:37:00.860 --> 00:37:02.160
And if it's your turn,

00:37:03.680 --> 00:37:06.010
Allow them to take actions in the game.

00:37:06.010 --> 00:37:09.990
Now the match data contains
the current state of the match.

00:37:10.360 --> 00:37:11.900
The contents are developer defined.

00:37:11.900 --> 00:37:12.660
It's completely up to you.

00:37:12.660 --> 00:37:14.420
It's an arbitrary NSData.

00:37:14.710 --> 00:37:18.740
It's stored online, so you must have the
current turn to update it.

00:37:18.830 --> 00:37:20.840
But others can read it.

00:37:20.920 --> 00:37:25.220
It's of a limited size of 64K,
so pack your data wisely.

00:37:25.350 --> 00:37:29.020
And you can get a lot of stuff in here,
but if you need more room,

00:37:29.110 --> 00:37:31.460
you can point to server-stored data.

00:37:31.540 --> 00:37:34.100
Now let's talk about taking a turn.

00:37:34.510 --> 00:37:37.430
So to take a turn,
you make a move in your game.

00:37:37.440 --> 00:37:38.540
This is just up to you.

00:37:38.540 --> 00:37:40.600
It's based on the rules of your game.

00:37:40.660 --> 00:37:43.610
A player may make a move,
they may resign or pass or so forth,

00:37:43.700 --> 00:37:46.200
depending on what you desire.

00:37:46.270 --> 00:37:51.350
You choose the next players and you
call our API to submit the turn.

00:37:51.570 --> 00:37:55.720
So to do this,
here's your update of your state.

00:37:56.120 --> 00:37:59.160
Now you choose the next participants,
and I'll give you an example

00:37:59.240 --> 00:38:00.700
of how to do that soon.

00:38:01.200 --> 00:38:03.640
Then you set a message to be
shown to the other participants.

00:38:03.790 --> 00:38:06.400
So in this case,
I made the Kessel run in 12 parsecs.

00:38:06.600 --> 00:38:08.260
Hooray!

00:38:08.660 --> 00:38:13.630
And now we send the new game
state to the Game Center and pass

00:38:13.630 --> 00:38:15.240
the turn to the next participant.

00:38:15.240 --> 00:38:16.990
And here's where you supply the timeout.

00:38:17.100 --> 00:38:18.520
So how do we choose next participants?

00:38:18.600 --> 00:38:19.280
Well, that's up to you.

00:38:19.280 --> 00:38:22.960
You can go clockwise, counterclockwise.

00:38:23.020 --> 00:38:25.090
You can skip every other player.

00:38:25.300 --> 00:38:26.720
You can even let the player decide.

00:38:26.720 --> 00:38:30.670
But you must choose active players.

00:38:30.930 --> 00:38:34.200
If you choose a player who's
done with the game or quit,

00:38:34.360 --> 00:38:36.300
it's an error.

00:38:36.300 --> 00:38:38.300
And you should also guard
against missed turns.

00:38:38.520 --> 00:38:41.220
And you do this by providing
a list of multiple next

00:38:41.220 --> 00:38:43.500
participants rather than just one.

00:38:43.560 --> 00:38:47.500
And this will automatically
enable the use of timeouts.

00:38:47.790 --> 00:38:51.200
And the last participant on the list,
though, they will not get a timeout

00:38:51.200 --> 00:38:54.250
because we don't know who to
give the turn to afterwards.

00:38:54.640 --> 00:38:58.460
So I strongly recommend you add
yourself as the last participant.

00:38:58.600 --> 00:39:03.050
Because if I just took a turn
and nobody else takes a turn,

00:39:03.300 --> 00:39:06.540
Then I'm probably the most likely
person to take the next turn.

00:39:06.570 --> 00:39:09.090
And you can do something
like mark the player as one.

00:39:09.090 --> 00:39:10.530
So how do we do that?

00:39:12.180 --> 00:39:14.330
Let's implement a simple
clockwise rotation.

00:39:14.440 --> 00:39:18.900
So we're going to ask the match
for its participants and get the

00:39:18.900 --> 00:39:21.690
index of the current participant.

00:39:22.250 --> 00:39:46.710
Now, let's loop through the participants,
starting with the next one,

00:39:46.710 --> 00:39:46.710
and add them if they are still active.

00:39:46.710 --> 00:39:46.710
We add them to the array and we're
going to keep looping around.

00:39:46.710 --> 00:39:46.710
Notice that my loop is post-decrement,
so that'll catch me,

00:39:46.710 --> 00:39:46.710
the current participant,
as the last entry.

00:39:47.090 --> 00:39:51.300
If there are participants remaining,
return that list.

00:39:51.410 --> 00:39:52.640
Otherwise, return nil.

00:39:52.640 --> 00:39:54.720
The game's over at this point.

00:39:54.720 --> 00:39:55.780
There are no active participants.

00:39:55.800 --> 00:39:57.080
You should handle that accordingly.

00:39:59.880 --> 00:40:04.760
Now, this is a new feature in iOS 6,
which is saving match data.

00:40:04.950 --> 00:40:08.880
So, some games, rather than having a
turn take a single step,

00:40:08.880 --> 00:40:12.020
it might consist of
multiple discrete steps.

00:40:12.580 --> 00:40:17.950
For example, in a trivia game,
let's say the MC is firing questions.

00:40:17.950 --> 00:40:19.380
Let's say Nate is playing.

00:40:19.380 --> 00:40:22.660
So the MC is going to fire
questions one after another to Nate.

00:40:22.660 --> 00:40:28.170
As long as he keeps answering correctly,
his turn continues.

00:40:28.900 --> 00:40:30.430
You know,
he doubles his money or whatnot.

00:40:30.450 --> 00:40:33.130
If he answers incorrectly, his turn ends.

00:40:34.590 --> 00:40:36.260
Now there's a few things about this.

00:40:36.300 --> 00:40:38.180
Now let's say I'm playing
this game and I answer two

00:40:38.180 --> 00:40:40.410
questions correctly on my iPad.

00:40:40.480 --> 00:40:42.370
I switch to my iPhone.

00:40:43.220 --> 00:40:47.560
Well, in iOS 5,
I would start that turnover.

00:40:47.700 --> 00:40:52.100
You know, with this saved match data now,
I can continue with the third question.

00:40:52.210 --> 00:40:55.510
Also, you know,
Megan and Dan are watching me play.

00:40:55.740 --> 00:40:58.680
You know, they're running the game and
they're watching my updates.

00:40:58.890 --> 00:41:01.720
My game can send updates to them.

00:41:01.930 --> 00:41:04.400
And this is also good to
avoid cheating situations.

00:41:04.400 --> 00:41:08.000
Like let's say I'm playing
a game and I roll some dice.

00:41:08.020 --> 00:41:09.900
I don't lie, I get snake eyes.

00:41:09.900 --> 00:41:13.390
Well, now I can -- I mean,
before I can go over to my

00:41:13.390 --> 00:41:16.770
iPhone and I get a do-over
because I just launched the game,

00:41:16.770 --> 00:41:17.880
start my turn.

00:41:17.910 --> 00:41:21.850
But with saving match data,
when I launch that phone,

00:41:21.860 --> 00:41:24.740
I'm going to have my die rolls there.

00:41:24.740 --> 00:41:27.840
So it makes your game much more robust.

00:41:27.920 --> 00:41:29.760
So to do this,
let's walk through that trivia example.

00:41:29.790 --> 00:41:32.400
So we're going to have a while loop.

00:41:32.420 --> 00:41:34.440
You ask trivia question.

00:41:34.470 --> 00:41:35.510
Update game state.

00:41:35.540 --> 00:41:37.340
Number correct plus one.

00:41:37.340 --> 00:41:41.250
And we save the current
turn with match data.

00:41:41.710 --> 00:41:46.490
And to illustrate this,
here I am and here's Megan and Dan.

00:41:46.570 --> 00:41:48.670
They're running your game.

00:41:50.110 --> 00:41:53.100
When I update,
I send the data to the server.

00:41:53.280 --> 00:41:54.280
I keep my own copy.

00:41:54.280 --> 00:41:56.400
I can continue with my turn.

00:41:56.550 --> 00:41:59.000
Since they have running
instances of your game,

00:41:59.160 --> 00:42:03.240
they will get an event handler
callback and they'll receive

00:42:03.290 --> 00:42:05.100
a new copy of the data.

00:42:05.180 --> 00:42:08.150
The other three players who
are doing something else,

00:42:08.150 --> 00:42:10.360
they do not get push notifications.

00:42:10.480 --> 00:42:16.320
But if they launch the game,
they'll get the same data and

00:42:16.320 --> 00:42:16.490
they'll be able to follow along.

00:42:16.830 --> 00:42:21.100
And this leads us into the kinds
of turn notifications we get.

00:42:21.230 --> 00:42:24.540
If you receive an invite,
you'll get a push notification

00:42:24.540 --> 00:42:28.530
and we'll call the delegate
method handleTurnEventForMatch.

00:42:28.820 --> 00:42:31.730
If it becomes your turn, the same thing.

00:42:31.740 --> 00:42:34.370
You get a push notification,
you get a handle turn event for match.

00:42:36.160 --> 00:42:39.760
If the turn is passed to
someone else besides you,

00:42:39.780 --> 00:42:43.320
only the running instances of the
game get handle turn event for match.

00:42:43.440 --> 00:42:46.220
There's no push notification
sent in that case.

00:42:46.510 --> 00:42:49.340
And likewise for saving the data.

00:42:49.900 --> 00:42:54.510
If the match ends,
you get a push notification and

00:42:54.780 --> 00:42:57.240
handleMatchEnded gets called.

00:42:57.320 --> 00:43:01.700
Now let's talk about implementing
handleTurnEventForMatch.

00:43:01.740 --> 00:43:03.500
There's a couple things
you should do here.

00:43:03.530 --> 00:43:07.260
If it's now my turn, inform the user.

00:43:08.170 --> 00:43:11.500
In this example, we're just using the
show banner with title,

00:43:11.530 --> 00:43:15.500
but you can show whatever UI you want
and take whatever action you wish.

00:43:15.850 --> 00:43:19.910
And similarly, handle that case of if
I'm playing the game,

00:43:19.910 --> 00:43:25.790
if I'm taking a turn for another match,
or I'm just observing a match

00:43:26.580 --> 00:43:33.230
and somebody makes a change,
we can check that and update our UI.

00:43:34.860 --> 00:43:38.070
Now, things to remember when taking
a turn is only the current

00:43:38.070 --> 00:43:41.240
participant may update the data,
and they're also the only

00:43:41.240 --> 00:43:43.010
ones that can pass the turn.

00:43:43.840 --> 00:43:48.020
Other players may quit during this time,
so you need to handle that.

00:43:48.100 --> 00:43:51.950
And finally, handle your turn events.

00:43:53.500 --> 00:43:57.260
Now for quitting a match,
this is when a player resigns

00:43:57.460 --> 00:43:59.220
or they just decide to quit.

00:43:59.350 --> 00:44:01.000
There's two cases here.

00:44:01.000 --> 00:44:02.980
One is when it's my turn.

00:44:03.230 --> 00:44:07.240
Quitting while I'm in turn
is just like taking a turn,

00:44:07.250 --> 00:44:10.640
except I set an outcome
on that participant.

00:44:10.780 --> 00:44:13.000
So you'll update your game state.

00:44:13.050 --> 00:44:18.490
You'll set my outcome to quit,
and then you'll pass the turn by sending,

00:44:18.490 --> 00:44:23.030
you know, player quit in turn
with completion handler.

00:44:23.330 --> 00:44:29.200
And you can supply a participant list
with fallbacks and use the timeouts.

00:44:29.260 --> 00:44:33.300
If it's not your turn,
you just inform Game Center by calling

00:44:33.390 --> 00:44:35.310
an API player quit out of turn.

00:44:35.520 --> 00:44:37.800
At that point,
it will just mark you as quit.

00:44:37.940 --> 00:44:40.620
Now, if the game is over
and you have the turn,

00:44:40.710 --> 00:44:42.200
you can end the match.

00:44:42.320 --> 00:44:45.080
At this point,
you need to set the outcomes

00:44:45.080 --> 00:44:46.800
for all participants.

00:44:46.930 --> 00:44:51.120
And we provide a number of constants,
including one loss, tied,

00:44:51.220 --> 00:44:55.300
various positions,
a player ran out of time, and so forth.

00:44:55.430 --> 00:44:59.770
We can also set a -- we also provide
a custom field here so you can

00:44:59.790 --> 00:45:02.380
show custom outcomes in your UI.

00:45:02.540 --> 00:45:04.700
Provide an optional message.

00:45:04.840 --> 00:45:08.600
And then inform Game Centers and
the notification goes out.

00:45:08.730 --> 00:45:10.810
Now, how do we do this?

00:45:11.540 --> 00:45:13.080
Well, we set the outcome.

00:45:13.080 --> 00:45:15.900
In this case,
we're kind of lucky no one lost,

00:45:15.900 --> 00:45:18.030
but we're not that lucky
because no one won either.

00:45:20.270 --> 00:45:23.990
We set the final game state and
we set the optional message.

00:45:24.000 --> 00:45:27.490
Yes, I really did win the
Kessel Run this time.

00:45:28.130 --> 00:45:33.240
We end the match just by
calling our API and that's it.

00:45:34.830 --> 00:45:38.870
Now that the game is over,
I want to play again.

00:45:38.870 --> 00:45:40.140
And this is really easy.

00:45:40.140 --> 00:45:43.700
You just put a button on your game over
screen and then you call on the match.

00:45:43.870 --> 00:45:46.530
Re-match with completion handler.

00:45:46.810 --> 00:45:50.100
And when this returns,
you can start your game.

00:45:50.100 --> 00:45:54.340
In turn-based gaming,
this means I take the first turn,

00:45:54.470 --> 00:45:56.490
and then when I'm done,
I can pass it to one of the

00:45:56.500 --> 00:46:00.450
other participants who will
be invited back to play.

00:46:00.800 --> 00:46:06.660
Now if Nate also does this on his device,
he'll get a match where

00:46:06.660 --> 00:46:07.940
he can take a turn.

00:46:07.940 --> 00:46:11.460
So there'll actually be two
instances of the matches created.

00:46:11.590 --> 00:46:16.260
That's just the characteristic of
turn-based because the invites don't

00:46:16.530 --> 00:46:19.000
happen until it becomes their turn.

00:46:19.660 --> 00:46:23.940
Now in contrast to that,
we also support this on GK Match.

00:46:24.030 --> 00:46:26.570
In the case of GK Match,

00:46:27.430 --> 00:46:32.170
All the players who were in that
match who hit replay will get

00:46:32.180 --> 00:46:34.080
auto-matched into a new match.

00:46:34.080 --> 00:46:37.600
So the players who don't choose
to do this will get left out,

00:46:37.600 --> 00:46:40.550
but the other ones will all get
matched into a single match.

00:46:42.660 --> 00:46:44.300
But other than that,
it's really easy and we recommend

00:46:44.310 --> 00:46:48.990
you add that because it adds more
replayability to these games.

00:46:50.410 --> 00:46:54.490
So with that, I've given you a quick
walkthrough of multiplayer.

00:46:54.580 --> 00:46:56.900
This is a really popular feature.

00:46:57.570 --> 00:47:01.620
It adds a lot of longevity to your
app and engagement for your players.

00:47:01.650 --> 00:47:03.840
I've talked about the different
styles of multiplayer we support.

00:47:03.840 --> 00:47:06.880
I've gone into detail on
peer-to-peer and turn-based.

00:47:06.880 --> 00:47:11.000
I've pointed you to documentation
for how to do server-based.

00:47:11.030 --> 00:47:15.000
I've talked about the Matchmaker
UI and how it can make it really easy

00:47:15.050 --> 00:47:19.640
for you to connect with your friends
and play or even with other people

00:47:19.640 --> 00:47:22.140
on the Internet or in the same room.

00:47:22.140 --> 00:47:25.220
I've talked about
programmatic matchmaking.

00:47:25.220 --> 00:47:27.520
I've talked about peer-to-peer
communication and the

00:47:27.520 --> 00:47:29.760
best practices thereof.

00:47:29.760 --> 00:47:31.510
And then finally,
I've given you a nickel tour

00:47:31.610 --> 00:47:33.260
through turn-based gaming.

00:47:33.260 --> 00:47:36.830
For more information, you can contact the
incomparable Alan Schafer,

00:47:36.900 --> 00:47:38.860
our wonderful evangelist.

00:47:38.860 --> 00:47:40.290
Or you can read the documentation.

00:47:40.290 --> 00:47:43.950
There's a multiplayer section in
the GameKit programming guide.

00:47:43.960 --> 00:47:46.280
Or you can, you know, go to our forums.

00:47:46.340 --> 00:47:48.180
We post and reply to your messages.

00:47:50.410 --> 00:47:52.720
There are a number of related
sessions I hope you're able to make,

00:47:52.720 --> 00:47:55.900
like what's new in Game Center,
integrating your games with Game Center,

00:47:55.900 --> 00:47:57.590
or what's new in iTunes Connect.

00:47:57.600 --> 00:48:01.600
And after me,
Gabe is going to show you hands-on

00:48:01.600 --> 00:48:05.890
how to port your app to OS X and
broaden that customer base.

00:48:05.900 --> 00:48:07.500
So please attend that.

00:48:07.500 --> 00:48:08.050
That's awesome.

00:48:08.060 --> 00:48:09.590
And thank you very much.
WEBVTT

00:00:10.090 --> 00:00:13.040
Good morning, my name is Bob Wilson,
and together with a few of my colleagues,

00:00:13.040 --> 00:00:15.410
I'm going to talk with you
today about some great new

00:00:15.410 --> 00:00:18.200
features in the LLVM compiler.

00:00:18.310 --> 00:00:20.920
So,
a better compiler is really significant

00:00:20.920 --> 00:00:25.720
because we believe that a better compiler
can help you guys to make better apps.

00:00:25.880 --> 00:00:30.540
And there's three ways we can do that:
performance, productivity, and quality.

00:00:30.600 --> 00:00:34.180
Performance is really important
because you want your apps to

00:00:34.180 --> 00:00:36.090
run quickly and be responsive.

00:00:36.190 --> 00:00:40.460
The compiler can help you by
optimizing your code to run quickly.

00:00:41.600 --> 00:00:45.800
compiler can help your productivity by
making sure that it itself runs quickly,

00:00:45.880 --> 00:00:47.830
so that you don't have to
spend a lot of time sitting

00:00:47.830 --> 00:00:49.700
around waiting for your builds.

00:00:49.780 --> 00:00:53.660
And we can also help your productivity by
having the compiler support new language

00:00:53.660 --> 00:00:59.090
features that make it easier for you
to write correct and efficient code.

00:01:00.090 --> 00:01:01.680
And finally, quality is essential.

00:01:01.800 --> 00:01:03.980
Nobody wants to use a buggy app.

00:01:04.230 --> 00:01:06.640
Every time that you build
your project in Xcode,

00:01:06.640 --> 00:01:09.570
the compiler is going to
look for suspicious things,

00:01:09.800 --> 00:01:13.460
and it will warn you before
you even hit those problems.

00:01:13.540 --> 00:01:16.120
You can also periodically
run the Static Analyser,

00:01:16.120 --> 00:01:18.700
which is based on the compiler,
to find more subtle

00:01:18.700 --> 00:01:19.850
problems in your code.

00:01:20.130 --> 00:01:23.800
So these are three areas where
the compiler can help you.

00:01:23.840 --> 00:01:27.180
Xcode 4.4 has a new version
of the Apple LLVM compiler,

00:01:27.460 --> 00:01:30.320
version 4.0,
and we're going to talk about some

00:01:30.320 --> 00:01:32.340
of those new features here today.

00:01:32.400 --> 00:01:35.490
Before we do that,
I want to say a few things about LLVM.

00:01:35.490 --> 00:01:38.940
LLVM is represented by
the Dragon logo here,

00:01:38.940 --> 00:01:42.080
it's an open source project
to develop compilers and other

00:01:42.080 --> 00:01:44.220
low-level development tools.

00:01:44.270 --> 00:01:48.470
One of the distinctive things about
LLVM is its modular architecture,

00:01:48.640 --> 00:01:52.700
where it's built upon a set of
reusable components that can be

00:01:52.780 --> 00:01:55.010
combined together in interesting ways.

00:01:55.050 --> 00:01:57.050
So some of these components
are the Clang parser,

00:01:57.200 --> 00:02:00.620
which is a unified C, C++,
and Objective-C parser.

00:02:00.620 --> 00:02:03.280
Runs really fast,
and it has great informative

00:02:03.280 --> 00:02:06.810
diagnostics to help you understand
the problems that the compiler finds.

00:02:06.810 --> 00:02:10.830
We have a sophisticated optimizer
to make your code run fast,

00:02:10.830 --> 00:02:15.200
and we have code generators, assemblers,
and disassemblers for both

00:02:15.300 --> 00:02:17.100
Intel and ARM processors.

00:02:17.580 --> 00:02:21.100
So together with those components,
we also have some runtime libraries.

00:02:21.160 --> 00:02:24.580
libc++, which we're going to talk
about in a few minutes,

00:02:24.630 --> 00:02:26.600
is our C++ runtime library.

00:02:26.940 --> 00:02:30.810
And we also have a lower level
compiler support runtime.

00:02:31.750 --> 00:02:36.180
We can then combine all of those
different components and runtime

00:02:36.180 --> 00:02:38.740
libraries to create stand-alone tools.

00:02:38.740 --> 00:02:42.680
So starting with the LLVM compilers
is the most obvious one.

00:02:42.680 --> 00:02:46.480
The LLVM compiler builds upon all
of those things shown below it,

00:02:46.480 --> 00:02:49.810
and you'll see this whenever
you build your project in Xcode.

00:02:49.810 --> 00:02:52.070
And of course,
you can also run the compiler

00:02:52.070 --> 00:02:54.160
directly from the command line.

00:02:54.220 --> 00:02:58.820
The Xcode Static Analyser is
built on top of the Clang parser,

00:02:59.150 --> 00:03:02.040
combined with sophisticated
analysis to understand what

00:03:02.110 --> 00:03:04.460
your code is really doing.

00:03:04.930 --> 00:03:08.630
And this is also integrated into
Xcode when you run the analyze step,

00:03:08.630 --> 00:03:11.260
in a nice way to actually
be able to visualize and see

00:03:11.260 --> 00:03:14.050
the results of that analysis.

00:03:14.510 --> 00:03:16.940
and finally we have the LDB debugger.

00:03:17.070 --> 00:03:20.380
The debugger uses the Clang parser,
the code generator and the

00:03:20.380 --> 00:03:24.590
disassembler and forms the
basis of the Xcode debugger.

00:03:24.710 --> 00:03:28.440
The Clang parser itself is
integrated directly into Xcode to

00:03:28.440 --> 00:03:31.390
support features like indexing,
code completion,

00:03:31.400 --> 00:03:33.200
live warnings and fixits.

00:03:33.350 --> 00:03:37.790
So I hope this gives you a feeling for
how the architecture of LLVM really

00:03:37.790 --> 00:03:39.300
lets us do some powerful things.

00:03:39.300 --> 00:03:43.200
We can reuse these components,
we get consistency across the tools

00:03:43.370 --> 00:03:48.190
and we get this really powerful
integration into the Xcode IDE.

00:03:48.280 --> 00:03:52.090
Now, if you're familiar with our tools,
you may notice one thing that's

00:03:52.090 --> 00:03:56.120
missing from this list here,
and that's LLVM GCC.

00:03:56.200 --> 00:03:59.270
LLVM GCC is a hybrid.

00:03:59.270 --> 00:04:04.300
It's a combination of the old GCC 4.2
parser with an older version of the

00:04:04.300 --> 00:04:06.980
LLVM Optimizer and Code Generator.

00:04:06.980 --> 00:04:11.440
This was a stopgap solution
that we created to ease the

00:04:11.440 --> 00:04:14.400
transition from GCC over to LLVM.

00:04:15.410 --> 00:04:20.530
We finished that transition now,
and we've no longer been adding any new

00:04:20.530 --> 00:04:23.200
features or even fixing bugs in LLVM GCC.

00:04:23.230 --> 00:04:26.010
So it's really time for
everyone to stop using that.

00:04:26.040 --> 00:04:28.080
And in fact,
we're going to be removing that

00:04:28.080 --> 00:04:29.660
from Xcode in the near future.

00:04:29.660 --> 00:04:32.040
So please move to the LLVM compiler.

00:04:34.910 --> 00:04:36.730
So with that context,
I'd like to go on and

00:04:36.730 --> 00:04:39.450
talk about performance,
which is the first of the focus

00:04:39.550 --> 00:04:41.780
areas we're going to cover today.

00:04:41.780 --> 00:04:44.920
As a compiler team, performance is near
and dear to our hearts.

00:04:45.090 --> 00:04:48.460
Some of us stay up at night thinking
about how we can squeeze a few more

00:04:48.460 --> 00:04:50.200
cycles out of some important code.

00:04:50.240 --> 00:04:53.120
And we also work really,
really hard to make sure that

00:04:53.120 --> 00:04:55.170
the compiler itself runs quickly.

00:04:55.170 --> 00:04:57.860
There's no way I can talk
about all the performance

00:04:58.320 --> 00:05:00.820
enhancements we've added recently,
so I've just picked three

00:05:00.960 --> 00:05:02.130
of them to highlight today.

00:05:02.380 --> 00:05:05.880
So let's start by talking
about the Arc Optimizer.

00:05:05.950 --> 00:05:09.640
Arc, or automated reference counting,
is this great feature we introduced

00:05:09.800 --> 00:05:11.960
last year to make you more productive.

00:05:12.080 --> 00:05:14.560
If you use Arc,
you no longer have to manually

00:05:14.680 --> 00:05:18.440
insert retains and releases
into your Objective-C code.

00:05:18.660 --> 00:05:19.930
Let's look at how this works.

00:05:20.100 --> 00:05:24.700
So I've put up a simple example
here of a debug logging method.

00:05:24.700 --> 00:05:28.350
It takes a string as an argument
and just writes it out with NSLog.

00:05:28.360 --> 00:05:31.980
From the perspective of Arc,
the important thing here is that

00:05:32.060 --> 00:05:36.030
from the time you enter the method
to the point where you call NSLog,

00:05:36.180 --> 00:05:38.320
we have to make sure that
nothing is going to release

00:05:38.320 --> 00:05:39.740
the string out from under us.

00:05:39.800 --> 00:05:43.820
So the compiler will just automatically
insert a retain for that string

00:05:43.820 --> 00:05:47.450
S at the beginning of the method
and then release it at the end.

00:05:48.270 --> 00:05:52.220
And in fact, if you build an unoptimized
debug version of this code,

00:05:52.240 --> 00:05:54.560
that's basically what you'll get.

00:05:55.090 --> 00:05:58.010
Now, as an experienced programmer,
you may look at this and say,

00:05:58.010 --> 00:05:58.950
that's kind of silly.

00:05:58.950 --> 00:06:02.960
There's really no way that the
string could be released out

00:06:02.960 --> 00:06:06.340
from under you because nothing
happens before you call NSLog.

00:06:06.380 --> 00:06:09.520
If you run an optimized
build of this code,

00:06:09.520 --> 00:06:13.980
the compiler will automatically
run the Arc Optimizer.

00:06:13.980 --> 00:06:16.880
It analyzes it and
realizes this is silly,

00:06:16.950 --> 00:06:20.560
and it optimizes the way
that retain and release.

00:06:21.430 --> 00:06:24.970
This kind of optimization has been
in LLVM from day one with Arc.

00:06:25.040 --> 00:06:27.450
So let's talk about
something new this year.

00:06:27.460 --> 00:06:31.080
We have a lot of improvements
to this Arc Optimizer,

00:06:31.080 --> 00:06:34.360
and I can't unfortunately
cover all of them.

00:06:34.460 --> 00:06:38.260
So again, I've just picked one example,
and that's the case of nested retains.

00:06:38.260 --> 00:06:42.370
And to illustrate that,
let's look at a more complicated

00:06:42.370 --> 00:06:45.260
version of that debug logging method.

00:06:45.360 --> 00:06:49.080
Again, it takes a string,
and so Arc will insert a

00:06:49.080 --> 00:06:51.000
retain for the string S.

00:06:51.120 --> 00:06:55.960
Now, unlike the previous version,
there's a copy from S to a new string T,

00:06:55.960 --> 00:06:58.430
so a reference to the same string.

00:06:58.440 --> 00:07:02.720
And Arc will also insert a retain for T.

00:07:04.470 --> 00:07:08.400
Now at this point, well I should say this
is a contrived example.

00:07:08.400 --> 00:07:10.310
I'm sure you wouldn't
actually write this code.

00:07:10.500 --> 00:07:13.950
But in a more complicated method,
there may be reasons where you

00:07:13.950 --> 00:07:15.900
would insert a copy like that.

00:07:15.950 --> 00:07:19.460
And it can also happen when
the compiler inlines functions.

00:07:19.580 --> 00:07:22.930
So the Arc Optimizer can
look at this and realize,

00:07:23.020 --> 00:07:25.660
I've retained the same string twice.

00:07:25.890 --> 00:07:28.360
As long as the string is
retained at least once,

00:07:28.430 --> 00:07:30.450
there's no way it can be released.

00:07:30.600 --> 00:07:33.600
So that second retain is
completely unnecessary.

00:07:33.600 --> 00:07:36.420
And the Arc Optimizer,
now in version 4 of the compiler,

00:07:36.420 --> 00:07:39.590
will optimize that away.

00:07:40.540 --> 00:07:41.640
What about the other retainer?

00:07:41.640 --> 00:07:43.700
Can we get rid of that as well?

00:07:43.780 --> 00:07:45.370
In this case, unfortunately, you can't.

00:07:45.440 --> 00:07:48.700
If you look inside the method,
it's now a little more complicated.

00:07:48.700 --> 00:07:51.200
It's checking a logging-enabled flag.

00:07:51.380 --> 00:07:54.660
And then, before it calls NSLog,
it's sending an increment

00:07:54.660 --> 00:07:56.390
log count message.

00:07:56.820 --> 00:08:00.750
It's highly unlikely that increment log
count is going to release the string.

00:08:00.930 --> 00:08:02.760
But the compiler can't know that.

00:08:02.990 --> 00:08:06.350
It's hypothetically possible
that the string that was passed

00:08:06.350 --> 00:08:08.180
in is in a global variable.

00:08:08.330 --> 00:08:12.070
Somebody could make an increment
log count implementation that

00:08:12.070 --> 00:08:13.500
would actually release that string.

00:08:13.500 --> 00:08:15.090
And the compiler has to be correct.

00:08:15.180 --> 00:08:16.160
It has to be safe.

00:08:16.220 --> 00:08:18.900
So we can't get rid of
the retain in this case.

00:08:18.900 --> 00:08:21.030
But that doesn't mean
we can't optimize it.

00:08:22.280 --> 00:08:25.870
The compiler isn't smart enough to
realize it can move the retain and

00:08:25.870 --> 00:08:29.090
release inside that conditional,
so that if logging is disabled,

00:08:29.100 --> 00:08:31.890
you don't pay the cost of the retain.

00:08:32.600 --> 00:08:35.950
So that's just one example of a
lot of nice improvements to the

00:08:36.040 --> 00:08:39.320
Arc Optimizer that should make
your code run faster than with

00:08:39.460 --> 00:08:42.030
previous versions of the compiler.

00:08:42.190 --> 00:08:44.220
Let's go on and talk about
another performance area,

00:08:44.220 --> 00:08:46.170
which is support for Intel's AVX.

00:08:46.170 --> 00:08:50.100
AVX is a vector processing extension.

00:08:50.100 --> 00:08:52.660
It's available in recent
versions of Intel processors,

00:08:52.660 --> 00:08:54.460
the Sandy Bridge and
Ivy Bridge processors.

00:08:54.570 --> 00:08:56.990
So basically,
most of the new Macs from the

00:08:57.250 --> 00:08:59.210
last year or so will support AVX.

00:08:59.300 --> 00:09:01.100
And it's really powerful.

00:09:01.100 --> 00:09:05.500
Compared to the older SSE,
the AVX vectors are twice as wide,

00:09:05.500 --> 00:09:08.500
256 bits instead of 128.

00:09:09.450 --> 00:09:11.290
So it's very powerful.

00:09:11.290 --> 00:09:14.200
It's not going to help every application,
though.

00:09:14.320 --> 00:09:18.520
It's an entirely
floating-point optimization.

00:09:18.560 --> 00:09:23.520
So it's a good fit for applications
that are floating-point intensive and

00:09:23.650 --> 00:09:28.340
typically works best where there's a high
ratio of computation to memory bandwidth,

00:09:28.460 --> 00:09:31.340
where you're actually
doing a lot of computation.

00:09:31.480 --> 00:09:34.880
So if you think that your
application may fit that profile,

00:09:34.880 --> 00:09:38.930
it might be worth taking a
look at optimizing for AVX.

00:09:39.130 --> 00:09:41.610
And let's look at an example
to show how you can do that.

00:09:41.680 --> 00:09:46.000
This is just a simple matrix addition,
and the code up here is going to

00:09:46.000 --> 00:09:48.430
step through two input matrices.

00:09:48.530 --> 00:09:52.530
It's going to load eight elements
at a time into two vectors,

00:09:52.530 --> 00:09:53.010
A and B.

00:09:53.280 --> 00:09:55.220
It's going to add them to a new vector,
C,

00:09:55.240 --> 00:09:57.930
and then store it back out to the result.

00:09:58.380 --> 00:10:01.060
You can see it's using some
intrinsic function calls here.

00:10:01.060 --> 00:10:04.900
Intel's defined a standard
set of intrinsics,

00:10:04.900 --> 00:10:09.300
and LLVM 4.0 supports the full
set of those standard intrinsics,

00:10:09.300 --> 00:10:10.980
which is really great.

00:10:11.000 --> 00:10:15.020
It's powerful because it lets you
have full access to the functionality

00:10:15.020 --> 00:10:16.720
of AVX and a lot of control.

00:10:16.720 --> 00:10:20.250
It can be a little bit hard to read,
especially if you're not familiar

00:10:20.360 --> 00:10:22.040
with all those intrinsics.

00:10:22.210 --> 00:10:27.180
So a nice option is to use
the OpenCL vector syntax.

00:10:28.420 --> 00:10:32.820
So you can directly dereference pointers
to those vectors and just load them up.

00:10:32.900 --> 00:10:37.280
We can now do the add as just A plus B,
and it's much easier for you

00:10:37.280 --> 00:10:38.940
to understand what's going on.

00:10:38.940 --> 00:10:43.920
You can mix and match the syntax
with the intrinsic calls as well.

00:10:43.920 --> 00:10:48.680
So for the simple operations like adds,
you can use the OpenCL syntax.

00:10:48.760 --> 00:10:51.540
For more complicated things
that you can't directly

00:10:51.540 --> 00:10:54.760
represent with C operators,
you can use the intrinsics.

00:10:57.050 --> 00:10:59.440
How much performance does this buy you?

00:10:59.440 --> 00:11:02.620
So I took that same example,
I implemented an SSE version

00:11:02.620 --> 00:11:06.560
and a scalar version that just
adds one element at a time.

00:11:06.560 --> 00:11:10.940
So this graph is showing a speedup
relative to the scalar version.

00:11:10.940 --> 00:11:14.050
The SSE implementation speeds
up more than three times,

00:11:14.220 --> 00:11:15.190
so that's good.

00:11:15.190 --> 00:11:18.560
And AVX version running on
the same machine speeds up by

00:11:18.560 --> 00:11:20.530
about four and a half times.

00:11:20.610 --> 00:11:22.800
So it's a significant step up.

00:11:22.800 --> 00:11:24.970
This is kind of a small example.

00:11:24.970 --> 00:11:27.130
In your own code,
you may see either larger

00:11:27.130 --> 00:11:29.770
or smaller speedups,
but I think it's good enough

00:11:29.910 --> 00:11:32.610
to illustrate the point
that there's potentially a

00:11:32.630 --> 00:11:34.500
really significant win here.

00:11:35.570 --> 00:11:37.810
If you want to use AVX,
there's one complication,

00:11:37.810 --> 00:11:41.560
and that's you will want your
code to run on older Macs as well.

00:11:41.560 --> 00:11:45.110
And what that means is you
need to implement not only

00:11:45.110 --> 00:11:48.820
the AVX optimized version,
but an SSE version.

00:11:48.820 --> 00:11:53.500
And then check at runtime whether the
hardware you're running on supports AVX,

00:11:53.640 --> 00:11:56.530
and if not,
fall back and use the SSE version.

00:11:56.540 --> 00:12:00.640
So to do that, put the AVX code into
separate source files,

00:12:00.640 --> 00:12:04.320
compile just those source
files with AVX enabled,

00:12:05.110 --> 00:12:06.480
and then insert a runtime check.

00:12:06.580 --> 00:12:10.120
You can use the syscontrol interface
to check if AVX is supported,

00:12:10.120 --> 00:12:12.730
and then switch between
those two implementations.

00:12:14.160 --> 00:12:17.790
But in the cases where it works,
it's really a significant win for

00:12:17.790 --> 00:12:21.010
floating-point intensive applications.

00:12:21.530 --> 00:12:25.260
One last performance area,
and that's the integrated ARM assembler.

00:12:25.330 --> 00:12:30.490
Previous versions of the LLVM compiler
for ARM would write out an assembly file,

00:12:30.530 --> 00:12:34.840
and then invoke the system assembler
to read that file in and parse it,

00:12:34.840 --> 00:12:37.720
translate it to machine code,
and write out an object file.

00:12:37.720 --> 00:12:39.610
There's a lot of overhead
involved in that.

00:12:39.610 --> 00:12:43.080
We want to cut out that overhead
so the compiler runs faster.

00:12:43.080 --> 00:12:46.070
And now in version 4,
the compiler can just generate

00:12:46.390 --> 00:12:49.440
that object file directly,
so it runs faster.

00:12:49.440 --> 00:12:52.040
This is a feature we've had
on Intel for a while now,

00:12:52.040 --> 00:12:56.270
and I'm really pleased to say
it's supported for ARM as well.

00:12:56.660 --> 00:12:59.790
Besides the build time improvements,
a nice feature of this is

00:12:59.790 --> 00:13:02.600
you get better error checking
if you have inline assembly.

00:13:02.730 --> 00:13:06.600
The compiler will look at that and
understand it and report errors to you.

00:13:06.740 --> 00:13:09.410
And the only thing you really
have to watch out for is if you've

00:13:09.410 --> 00:13:13.760
got some really old ARM assembly,
this integrated assembler only

00:13:13.760 --> 00:13:16.590
supports ARM's modern unified syntax.

00:13:16.720 --> 00:13:20.510
So if you've got some really old stuff,
you may need to either update

00:13:20.510 --> 00:13:23.580
the syntax or build with the
integrated assembler disabled.

00:13:23.760 --> 00:13:26.600
But those are rare cases.

00:13:26.600 --> 00:13:29.900
For almost all of you,
the result of this will just be that

00:13:29.900 --> 00:13:32.560
your builds run faster than they used to.

00:13:32.820 --> 00:13:35.600
So those are three performance
improvements that I wanted

00:13:35.680 --> 00:13:36.700
to highlight for you today.

00:13:36.790 --> 00:13:39.810
And now I'd like to invite
Doug Gregor to come up and talk

00:13:39.880 --> 00:13:41.700
about some new language features.

00:13:41.700 --> 00:13:43.560
So, new language features.

00:13:43.710 --> 00:13:45.980
There's a bunch of new language
features available in the

00:13:45.980 --> 00:13:47.520
Apple LLVM compiler version 4.

00:13:47.700 --> 00:13:51.780
So we've talked a bit this week about
the new Objective-C language features,

00:13:51.780 --> 00:13:54.700
like numeric literals, array literals,
dictionary literals, and so on.

00:13:54.700 --> 00:13:59.700
These are all available in the
Apple LLVM compiler version 4.

00:13:59.700 --> 00:14:02.700
But we've talked a lot about Objective-C.

00:14:02.700 --> 00:14:03.690
I don't want to talk
about Objective-C anymore.

00:14:03.700 --> 00:14:06.490
I want to talk about C++.

00:14:07.500 --> 00:14:10.480
Thank you.

00:14:10.580 --> 00:14:12.500
There's always a sum of
people in the room like that.

00:14:12.500 --> 00:14:16.500
So there's a new C++ standard,
the C++11 standard.

00:14:16.500 --> 00:14:19.500
It was ratified late last
year by the committee.

00:14:19.500 --> 00:14:25.320
And it's been 13 years since
the original 1998 C++ standard.

00:14:25.500 --> 00:14:28.500
And since then,
there's been a lot of improvements

00:14:28.500 --> 00:14:32.500
in the C++ language and the
standard library that comes with it.

00:14:32.500 --> 00:14:35.500
Now, there are lots of improvements,
but we can sort of pigeonhole them

00:14:35.500 --> 00:14:36.500
into a couple different places.

00:14:36.500 --> 00:14:41.500
So many of the improvements are
targeted at simplifying common idioms.

00:14:41.500 --> 00:14:45.500
So the things that C++
programmers do day in and day out,

00:14:45.500 --> 00:14:49.500
C++11 tries to make them easier,
more concise, more safe.

00:14:49.500 --> 00:14:54.670
C++11 is also about performance,
so it introduces new features to

00:14:54.760 --> 00:14:57.500
help you make your code run faster.

00:14:57.500 --> 00:15:02.220
And finally, one of the areas C++ has
traditionally been very good

00:15:02.670 --> 00:15:05.500
is in describing expressive,
efficient software lines

00:15:05.500 --> 00:15:08.490
and in describing the
application software libraries.

00:15:08.560 --> 00:15:11.110
And so there's new features in
the C++11 language to make it

00:15:11.110 --> 00:15:13.430
easier to build those libraries.

00:15:13.510 --> 00:15:18.340
Now, all of this is done with a very
strong focus on backward compatibility

00:15:18.500 --> 00:15:22.730
so that your apps that build as
C++98 apps today will compile and

00:15:22.730 --> 00:15:25.450
run the same way as C++11 apps.

00:15:25.590 --> 00:15:27.480
Now, last year,
we actually started introducing

00:15:27.560 --> 00:15:31.500
C++11 support with version 3
of the Apple LLVM compiler.

00:15:31.510 --> 00:15:34.670
And since then, we've been hard at work
implementing more and more of

00:15:34.670 --> 00:15:37.380
this very large C++11 standard.

00:15:37.500 --> 00:15:40.500
With version 4 of the
Apple LLVM compiler,

00:15:40.500 --> 00:15:43.500
we've introduced many of the
highly requested features,

00:15:43.500 --> 00:15:47.650
such as generalized initializer lists,
generalized constant expressions,

00:15:47.650 --> 00:15:50.360
or constexpr, and lambda expressions.

00:15:50.510 --> 00:15:53.500
Now, we're going to talk about
a couple of these features,

00:15:53.500 --> 00:15:56.500
skewing toward the ones that
can improve productivity.

00:15:56.610 --> 00:15:58.500
That's what we find is
most important for people.

00:15:58.500 --> 00:16:01.490
But before we dig into the
language side of the equation,

00:16:01.500 --> 00:16:03.500
we're going to talk
about the C++11 standard,

00:16:03.570 --> 00:16:06.590
the C++11 standard library.

00:16:07.080 --> 00:16:11.930
Now you can't have a great C++11
solution unless you have both a C++11

00:16:12.090 --> 00:16:15.920
compiler to support the languages
and a C++11 standard library to

00:16:15.970 --> 00:16:18.100
provide all the library facilities.

00:16:18.180 --> 00:16:20.190
There's two general reasons for this.

00:16:20.360 --> 00:16:24.900
First reason is that the language and the
library in C++ are somewhat intertwined.

00:16:24.990 --> 00:16:27.140
So some of the features we
think of as language features,

00:16:27.190 --> 00:16:30.900
like initializer lists,
they're really only truly useful

00:16:30.900 --> 00:16:35.060
when you also have the C++11
standard library backing them up.

00:16:35.200 --> 00:16:39.570
Things like move semantics,
you can use them without a C++11 library,

00:16:39.580 --> 00:16:41.850
but you're not going to see the
benefits unless your library has

00:16:41.910 --> 00:16:45.190
been optimized for move semantics.

00:16:45.520 --> 00:16:49.160
But the C++11 library isn't
just a language support library.

00:16:49.160 --> 00:16:53.220
There's actually a lot of
new great features in C++11,

00:16:53.220 --> 00:16:54.890
like smart pointers.

00:16:55.000 --> 00:16:58.900
So the smart pointers help automate your
memory management for your C++ objects,

00:16:59.040 --> 00:17:01.800
kind of like Arc does it for
your Objective-C objects,

00:17:01.960 --> 00:17:04.800
through use of-- by
describing your ownership.

00:17:05.100 --> 00:17:07.450
So you have a unique pointer
to describe unique ownership,

00:17:07.560 --> 00:17:10.180
shared pointer for shared ownership,
weak pointer to weakly

00:17:10.180 --> 00:17:11.770
point at a shared object.

00:17:11.850 --> 00:17:14.270
And these can help you eliminate
the trouble of matching up

00:17:14.270 --> 00:17:16.000
all of your news and deletes.

00:17:16.150 --> 00:17:17.490
There's also regular expressions.

00:17:17.570 --> 00:17:20.300
There's concurrency support
through threading and atomics,

00:17:20.460 --> 00:17:26.480
and a lot of other features to help
you build good C++ apps in C++11.

00:17:27.010 --> 00:17:28.380
Now, here at Apple,
we've been working on a

00:17:28.380 --> 00:17:31.600
new implementation of the
C++11 standard library.

00:17:31.600 --> 00:17:35.400
It's part of the LLVM project,
and it's called libc++.

00:17:35.520 --> 00:17:39.230
So this is a ground-up
implementation intended for complete

00:17:39.230 --> 00:17:42.000
C++11 standards conformance.

00:17:42.540 --> 00:17:46.990
Now, it also gracefully
degrades for C++ 98 and 03.

00:17:47.000 --> 00:17:53.800
So you can migrate to the libc++ standard
library with your C++ 98 app first,

00:17:53.930 --> 00:17:59.990
and then change into compiling for C++
11 to get a complete C++ 11 solution.

00:18:00.240 --> 00:18:02.190
Now, libc++, it's a new library.

00:18:02.200 --> 00:18:03.600
We've been working on
it for several years,

00:18:03.600 --> 00:18:08.640
and it's a ground-up implementation
where we got to focus on performance.

00:18:08.990 --> 00:18:12.640
And in focusing on performance,
we've created better data structures

00:18:12.710 --> 00:18:16.900
that require less memory and are faster,
and highly tuned algorithms,

00:18:17.010 --> 00:18:19.510
so that your uses of the
standard library will be more

00:18:19.510 --> 00:18:21.300
efficient and take less memory.

00:18:21.360 --> 00:18:24.880
libc++ is a replacement for the
current C++ standard library

00:18:24.880 --> 00:18:26.980
that you're probably all using.

00:18:27.120 --> 00:18:29.200
That old standard library is from GCC.

00:18:29.200 --> 00:18:31.250
It hasn't been touched in years.

00:18:31.380 --> 00:18:36.300
And so we want you to migrate
forward to the new libc++ library.

00:18:36.420 --> 00:18:39.230
The good news is that
migrating to libc++ is very,

00:18:39.230 --> 00:18:43.560
very easy, because libc++ as a standard
library implementation and

00:18:43.630 --> 00:18:47.600
C++11 as a new standard are both
largely backward compatible.

00:18:47.820 --> 00:18:50.920
So for most applications,
you just switch to libc++ and

00:18:50.920 --> 00:18:53.450
switch to C++11 at the same time.

00:18:53.590 --> 00:18:56.300
Your code will just compile and build.

00:18:56.400 --> 00:19:00.300
So the only thing that we've seen
trip up migration moving to libc++

00:19:00.410 --> 00:19:02.990
is due to the library tr1 components.

00:19:03.110 --> 00:19:05.210
So these were some
transitional components that

00:19:05.300 --> 00:19:07.810
the committee had worked on,
and these features have

00:19:07.860 --> 00:19:09.500
actually moved into C++11.

00:19:09.770 --> 00:19:12.560
So if you're using them from
the old GCC standard library,

00:19:12.740 --> 00:19:16.460
you just need to update your includes
to remove the tr1 slash and update

00:19:16.540 --> 00:19:20.210
your namespace references to eliminate
the tr1 there and use the new

00:19:20.290 --> 00:19:23.100
C++11 versions of these components.

00:19:23.200 --> 00:19:25.600
So that's the new libc++
C++ standard library.

00:19:25.600 --> 00:19:29.190
Let's talk about some language features
and how they can actually help you be

00:19:29.240 --> 00:19:32.230
more productive when working in C++.

00:19:32.610 --> 00:19:37.750
So, one of the major problems
that C++ has is verbosity.

00:19:37.890 --> 00:19:40.540
So this is one of my
least favorite loops,

00:19:40.630 --> 00:19:44.820
because all I want to do is walk
over the views in this vector.

00:19:45.230 --> 00:19:48.720
Simple operation,
and yet I have these two lines of

00:19:48.860 --> 00:19:51.160
for loop header just to do that.

00:19:51.220 --> 00:19:54.220
One of the big problems there is
I have to write this iterator type.

00:19:54.260 --> 00:19:58.160
I write hundreds of these
iterator types during the day,

00:19:58.190 --> 00:20:01.440
and they're all almost identical.

00:20:01.580 --> 00:20:06.330
So C++11 introduces this
wonderful new feature of auto.

00:20:06.820 --> 00:20:11.090
What auto does is it tells the compiler,
"Please fill in the type for me.

00:20:11.140 --> 00:20:14.160
I don't want to write it."
And this is not magic.

00:20:14.420 --> 00:20:17.200
It's just a placeholder
that the compiler will use.

00:20:17.280 --> 00:20:19.700
And when the compiler sees it,
it will go look at the initializer.

00:20:19.790 --> 00:20:22.000
So look at the initializer
v is v stop again,

00:20:22.070 --> 00:20:23.640
compute the type,
which it had to do anyway,

00:20:24.010 --> 00:20:26.200
and then fill it in for you.

00:20:26.300 --> 00:20:27.250
Great feature.

00:20:27.250 --> 00:20:28.700
Saves a ton of typing.

00:20:28.700 --> 00:20:30.700
Now, by default,
when you use an auto variable,

00:20:30.700 --> 00:20:33.700
you're going to get a copy of
whatever you're initializing with.

00:20:33.710 --> 00:20:35.700
Almost always, that's the right answer.

00:20:35.700 --> 00:20:38.090
It's certainly the right answer here,
because that's what we're iterating over.

00:20:38.420 --> 00:20:41.700
But if you actually want to
reference instead of a copy,

00:20:41.700 --> 00:20:42.150
that's perfectly fine.

00:20:42.230 --> 00:20:43.670
Just use auto reference.

00:20:45.440 --> 00:20:46.500
Our loop is better.

00:20:46.510 --> 00:20:47.940
Our loop is not perfect.

00:20:47.970 --> 00:20:51.040
C++ 11 also has the for range loop.

00:20:51.110 --> 00:20:53.960
For range loop should look very
familiar to anyone who's used

00:20:54.020 --> 00:20:57.940
Objective-C because it's almost
identical to a fast enumeration loop.

00:20:57.970 --> 00:21:01.340
We're using the colon rather than in,
but otherwise the syntax is the same.

00:21:01.370 --> 00:21:04.660
We just say for every view
in the container views,

00:21:04.720 --> 00:21:05.960
do something.

00:21:05.960 --> 00:21:09.460
Notice--

00:21:10.740 --> 00:21:13.390
and notice that we're using
auto here as well because,

00:21:13.500 --> 00:21:15.840
hey,
why bother to write NSView star again?

00:21:15.840 --> 00:21:17.420
We know that when we're
walking over views,

00:21:17.550 --> 00:21:19.040
we've got a view.

00:21:19.090 --> 00:21:22.440
Now, the for range loop works with any
of the standard library containers,

00:21:22.490 --> 00:21:25.460
and it also works with anything
else that has begin and end

00:21:25.460 --> 00:21:26.890
functions that return iterators.

00:21:27.020 --> 00:21:29.440
So if you have containers that
have been following conventions

00:21:29.440 --> 00:21:32.080
of the standard library,
the for range loop just

00:21:32.090 --> 00:21:33.610
works with those too.

00:21:34.580 --> 00:21:36.370
Now, we love using auto.

00:21:36.550 --> 00:21:40.090
However, in Objective C++,
we have to be a little

00:21:40.090 --> 00:21:44.030
bit careful with auto,
because sometimes using auto without

00:21:44.030 --> 00:21:46.900
care can change the meaning of
your program in surprising ways.

00:21:46.930 --> 00:21:48.400
So here's a really simple method.

00:21:48.400 --> 00:21:53.400
All we're gonna do is grab a
view out of an NSArray of views.

00:21:54.260 --> 00:21:56.900
Well, this typing NSVU is far
too much typing for me.

00:21:56.900 --> 00:21:59.500
I want to use auto instead.

00:22:00.820 --> 00:22:02.490
This program is still correct.

00:22:02.610 --> 00:22:04.160
It'll probably still compile,
but we've actually

00:22:04.230 --> 00:22:06.100
changed the meaning here.

00:22:06.230 --> 00:22:11.590
And the reason is, ObjectAtIndex doesn't
actually return an NSView.

00:22:11.700 --> 00:22:14.400
What it returns is ID.

00:22:14.510 --> 00:22:17.100
So when the compiler sees an
ID on the right-hand side,

00:22:17.100 --> 00:22:20.280
it decides that View must
have the type of ID.

00:22:20.380 --> 00:22:21.660
This is correct behavior.

00:22:21.770 --> 00:22:24.800
Your program will probably
still do exactly the same thing.

00:22:24.980 --> 00:22:28.780
But what you've actually done here
is you've lost a little bit of the

00:22:29.000 --> 00:22:32.800
static types of information that
you used to have in your program.

00:22:32.860 --> 00:22:37.050
Because uses of View used to
know that it was an NSView.

00:22:37.430 --> 00:22:39.760
And therefore,
you get warnings if you accidentally

00:22:39.920 --> 00:22:42.300
convert that NSView over to an NSString.

00:22:42.370 --> 00:22:45.260
Or if you try to send a message
that isn't available on NSViews,

00:22:45.310 --> 00:22:47.100
you would get a warning.

00:22:47.130 --> 00:22:50.030
You no longer get those warnings,
because you can do anything with an ID.

00:22:50.240 --> 00:22:52.380
You'll also notice other features,
like code completion won't

00:22:52.380 --> 00:22:54.240
be as precise anymore,
because that static type

00:22:54.310 --> 00:22:56.440
information is gone.

00:22:56.610 --> 00:23:00.540
So the moral here is that Auto is
really great for C++ types.

00:23:00.540 --> 00:23:02.480
It can save you a lot of typing.

00:23:02.620 --> 00:23:05.990
But when you're using
Auto in Objective C++ code,

00:23:05.990 --> 00:23:10.480
and you're working with methods that
may return ID or you're not sure,

00:23:10.680 --> 00:23:14.210
don't use Auto, just use the typing that
you've used before so you keep

00:23:14.250 --> 00:23:16.500
that static type information.

00:23:16.550 --> 00:23:19.530
So let's talk about some new features.

00:23:19.950 --> 00:23:24.710
Initializing containers in C++,
and formerly in Objective-C,

00:23:24.790 --> 00:23:26.990
is actually really, really painful.

00:23:27.120 --> 00:23:30.000
So here we have to declare the vector,
and then we call the

00:23:30.140 --> 00:23:34.040
pushback over and over again,
copying these pushback calls.

00:23:34.320 --> 00:23:35.460
It's really, really tedious.

00:23:35.530 --> 00:23:37.100
There must be a better way.

00:23:37.270 --> 00:23:41.440
In C++ 11, there is a better way,
and that's to use the generalized

00:23:41.470 --> 00:23:43.510
initializer list syntax.

00:23:47.650 --> 00:23:52.500
So obviously this is far cleaner than
calling pushback a hundred times.

00:23:52.500 --> 00:23:56.370
It's also nice because it generalizes
existing facilities of language.

00:23:56.550 --> 00:23:58.300
Initializer lists have always been there.

00:23:58.410 --> 00:24:01.500
If we were initializing an array,
we could have used an initializer list.

00:24:01.570 --> 00:24:03.710
Now we can do it for
arbitrary containers as well.

00:24:03.890 --> 00:24:07.150
Of course,
this works for any of the containers

00:24:07.150 --> 00:24:09.410
in the C++ standard library.

00:24:09.410 --> 00:24:12.720
So you can initialize a map with
key value pairs very easily with

00:24:12.720 --> 00:24:14.400
these nested initializer lists.

00:24:14.540 --> 00:24:17.910
The caveat here, of course,
is that you need a C++ 11

00:24:18.050 --> 00:24:20.170
standard library for this to work.

00:24:20.230 --> 00:24:22.890
So if you want to use
generalized initializer lists,

00:24:22.980 --> 00:24:26.220
you're going to need to use libc++,
which provides the library

00:24:26.220 --> 00:24:29.490
facilities to make the initializer
list feature work nicely.

00:24:29.500 --> 00:24:33.700
Now it turns out you can use
initializer lists in other places.

00:24:33.720 --> 00:24:36.820
This is then just after the equal
sign when initializing a variable.

00:24:36.820 --> 00:24:40.460
For example, you can use them in an
insert call into a map,

00:24:40.460 --> 00:24:43.050
where usually you'd
have to write this big,

00:24:43.180 --> 00:24:46.780
long std make pair call to put
the key and the value into a pair.

00:24:46.780 --> 00:24:50.260
You can just pass it almost
like a tuple of a key and value

00:24:50.260 --> 00:24:52.180
using an initializer list.

00:24:52.280 --> 00:24:55.580
So hold that thought of the tuple,
because it turns out that with

00:24:55.590 --> 00:24:58.790
generalized initializer lists,
and with the new features of

00:24:58.790 --> 00:25:01.840
the C++ 11 standard library,
we've made it very,

00:25:01.840 --> 00:25:03.700
very easy to do something cool.

00:25:03.720 --> 00:25:06.350
Which is multiple return
values with a very nice,

00:25:06.350 --> 00:25:07.330
clean syntax.

00:25:07.340 --> 00:25:10.990
So here our min-max function
wants to return two values.

00:25:11.040 --> 00:25:12.070
How do you do that in C++?

00:25:12.180 --> 00:25:13.050
Well, you don't.

00:25:13.050 --> 00:25:14.610
You have one pass-by reference.

00:25:14.680 --> 00:25:18.280
But in C++ 11,
you can say return a tuple.

00:25:18.280 --> 00:25:20.870
And it can be a tuple of
any number of elements.

00:25:20.920 --> 00:25:22.920
They can have any type,
whatever you specify.

00:25:22.920 --> 00:25:25.030
And when you actually
initialize that tuple,

00:25:25.090 --> 00:25:26.750
you just use an initializer list.

00:25:26.800 --> 00:25:31.440
Very clean, very natural syntax for
returning multiple values.

00:25:31.500 --> 00:25:33.200
Well, what about using that?

00:25:33.360 --> 00:25:36.070
Because our user probably doesn't
actually want to get a tuple back.

00:25:36.150 --> 00:25:39.640
Well, there's also really nice
syntax for this as well.

00:25:39.640 --> 00:25:42.180
And that's through the
tie library facility.

00:25:42.180 --> 00:25:47.520
You can tie up a couple local variables
and assign to the result of that tie

00:25:47.670 --> 00:25:51.800
from the min-max to say get the minimum,
get the maximum, add separate variables,

00:25:51.800 --> 00:25:52.940
and continue on with our code.

00:25:52.960 --> 00:25:55.600
Very, very nice,
natural way to do multiple

00:25:55.710 --> 00:25:57.610
return values in C++ 11.

00:25:57.620 --> 00:25:59.070
Let's talk about lambdas.

00:25:59.140 --> 00:26:02.360
This is a very, very,
very highly requested feature.

00:26:03.780 --> 00:26:09.410
And so lambdas are a nice
way of packaging up code,

00:26:09.410 --> 00:26:12.350
in this case a comparison operation,
and passing them off

00:26:12.350 --> 00:26:13.900
to another operation.

00:26:13.970 --> 00:26:17.740
The syntax should look very familiar
to you if you've used Objective-C,

00:26:17.800 --> 00:26:20.290
because it's very,
very similar to blocks.

00:26:20.410 --> 00:26:23.030
Lambdas and blocks are two
different features that try

00:26:23.070 --> 00:26:24.700
to address the same problem.

00:26:24.830 --> 00:26:28.620
Both of them are essentially creating
anonymous functions or closures,

00:26:28.620 --> 00:26:31.690
we can pass off to another
routine to do some operation.

00:26:31.780 --> 00:26:33.700
Now you see some syntactic
differences here.

00:26:33.730 --> 00:26:37.700
We're using the open and closed
square brackets rather than the caret.

00:26:37.700 --> 00:26:40.700
And the return type for a
lambda is in a different place.

00:26:40.740 --> 00:26:42.700
It's this optional arrow type at the end.

00:26:42.960 --> 00:26:46.700
Other than that, the syntax and the
usages are very similar.

00:26:47.200 --> 00:26:50.130
However, the semantics,
the behavior of blocks

00:26:50.180 --> 00:26:53.660
and lambda expressions are
different in some subtle ways.

00:26:53.700 --> 00:26:56.910
So to understand those,
we're going to go a little

00:26:57.220 --> 00:26:59.550
bit into how blocks work,
and then we can contrast

00:26:59.670 --> 00:27:02.030
those with how lambdas work,
so you can make an educated decision

00:27:02.090 --> 00:27:05.520
about what is best for your code.

00:27:06.480 --> 00:27:08.800
So let's take our sorting example
and let's make the assumption

00:27:08.950 --> 00:27:12.120
that this strings array that
we were sorting is really,

00:27:12.120 --> 00:27:13.590
really, really big.

00:27:13.630 --> 00:27:16.170
It's so big that we really want
to sort it on a different thread,

00:27:16.170 --> 00:27:20.780
and then later on we'll join up with our
thread to actually look at the results.

00:27:20.780 --> 00:27:23.200
So we'll do that with
Grand Central Dispatch.

00:27:23.260 --> 00:27:28.060
Call the dispatch async, pass it a block,
and inside that block you can

00:27:28.060 --> 00:27:30.200
do the sorting of strings.

00:27:31.250 --> 00:27:33.510
This code looks good,
but this code actually

00:27:33.580 --> 00:27:34.910
has an error in it.

00:27:35.050 --> 00:27:41.200
And the reason for the error is that this
block is referring to the vector strings.

00:27:41.320 --> 00:27:42.190
Now, what does that mean?

00:27:42.200 --> 00:27:45.650
Well, when you refer to something
that's outside of the block,

00:27:45.790 --> 00:27:48.100
from inside the block,
so refer to a variable,

00:27:48.190 --> 00:27:50.780
that variable has to be captured,
meaning it has to be

00:27:50.780 --> 00:27:52.630
pulled into the block.

00:27:52.840 --> 00:27:56.350
By default,
a block is going to capture by value,

00:27:56.360 --> 00:28:00.880
which means that we make a copy of
the data structure of that variable

00:28:01.390 --> 00:28:04.150
and put that copy inside the block.

00:28:04.320 --> 00:28:06.260
Now, immediately,
this sounds like both a performance

00:28:06.260 --> 00:28:07.310
and a correctness problem.

00:28:07.440 --> 00:28:09.570
First,
we're making this copy of something

00:28:09.590 --> 00:28:11.300
that we already said was large.

00:28:11.420 --> 00:28:15.420
But second, if we sort the copy,
we're never going to see

00:28:15.420 --> 00:28:17.300
the results anywhere.

00:28:17.580 --> 00:28:19.250
So that's not the reason
for the compiler error.

00:28:19.250 --> 00:28:22.370
The reason for the compiler error is
that because this is so dangerous to be

00:28:22.540 --> 00:28:26.390
working modifying a copy of something,
by default,

00:28:26.470 --> 00:28:28.410
by-value captures are captured as const.

00:28:28.450 --> 00:28:29.970
You can't modify them.

00:28:29.980 --> 00:28:33.400
So the compiler error you're actually
getting here is that you can't

00:28:33.400 --> 00:28:35.230
sort a constant vector of strings.

00:28:35.330 --> 00:28:38.770
Now,
by-value captures within Objective C++

00:28:38.900 --> 00:28:43.300
for blocks also have this nice other
behavior that when you capture something

00:28:43.360 --> 00:28:46.960
that's actually an Objective C object,
it's going to retain that

00:28:46.960 --> 00:28:49.770
object automatically for you,
so you know it doesn't go away.

00:28:51.390 --> 00:28:53.450
What we really want here is
we want to fix this problem.

00:28:53.460 --> 00:28:56.800
We want to make this code correct
and eliminate the compiler error.

00:28:56.880 --> 00:29:00.400
And the way we do that is
with double_block variables.

00:29:00.520 --> 00:29:04.000
So if we mark the strings
variable as double_block,

00:29:04.060 --> 00:29:06.890
what it does is it tells any
blocks that refer to that variable

00:29:06.900 --> 00:29:11.720
to capture it by reference,
so that all of those blocks and the

00:29:11.850 --> 00:29:17.790
main thread of control all see the
same version of this strings vector.

00:29:18.240 --> 00:29:21.370
Now, one thing you may not know
is that by reference captured

00:29:21.400 --> 00:29:23.700
variables actually do get copied.

00:29:23.810 --> 00:29:27.420
They get copied once at the
time when you pass off-- when

00:29:27.420 --> 00:29:32.470
Grand Central Dispatch takes in your
block and does a block copy on it.

00:29:32.590 --> 00:29:34.680
Now,
the reason for that copy is that when

00:29:34.680 --> 00:29:39.200
we first come into this function here,
strings is allocated on the stack.

00:29:39.330 --> 00:29:42.100
When we pass a block off
to Grand Central Dispatch,

00:29:42.230 --> 00:29:44.900
we have no assurances that
that stack is still gonna be

00:29:44.900 --> 00:29:46.890
there when we call the block.

00:29:47.010 --> 00:29:51.220
And so what the compiler does for
safety reasons is it makes one copy of

00:29:51.230 --> 00:29:54.880
that strings variable out on the heap,
and then everyone that refers

00:29:54.880 --> 00:29:57.900
to that strings variable
now points at the heap copy,

00:29:58.020 --> 00:30:00.300
which can live longer
than the stack frame.

00:30:00.430 --> 00:30:02.800
Altogether,
this means that our application now

00:30:02.800 --> 00:30:07.090
actually does work because we're all
referring to the same strings variable,

00:30:07.100 --> 00:30:08.900
we're allowed to sort
it because it's mutable,

00:30:08.900 --> 00:30:13.600
and we will see the results later
on once we sync up with GCD.

00:30:14.380 --> 00:30:15.460
That's how blocks work.

00:30:15.460 --> 00:30:18.130
Let's look at the same
issues for lambdas.

00:30:18.340 --> 00:30:22.660
So we're gonna change our block, caret,
to open/close square brackets

00:30:22.730 --> 00:30:24.780
to introduce a lambda.

00:30:25.850 --> 00:30:29.000
First thing we're going to
see is a compiler error.

00:30:29.020 --> 00:30:31.690
This is for a different reason than
our first compiler error with blocks,

00:30:31.690 --> 00:30:32.180
though.

00:30:32.340 --> 00:30:35.640
See, the open and close brackets
introduces a lambda,

00:30:35.690 --> 00:30:40.580
but what's really stating is,
is this an empty lambda capture list?

00:30:41.700 --> 00:30:45.830
And because it's an empty capture list,
it means this lambda is not allowed

00:30:45.840 --> 00:30:48.910
to refer to any variables from the
outside scope that have to capture.

00:30:49.060 --> 00:30:52.460
So when it tries to refer to strings,
the error the compiler's

00:30:52.560 --> 00:30:53.580
going to tell you is,
"Well,

00:30:53.600 --> 00:30:57.530
I can't capture strings because I'm
not allowed to capture anything."

00:30:58.150 --> 00:31:00.800
So let's tell it, capture strings.

00:31:00.950 --> 00:31:03.610
Well, we can do that by putting the name
of the variable we want to capture

00:31:04.190 --> 00:31:06.800
in between those square brackets.

00:31:06.940 --> 00:31:09.580
So now we're capturing
the variable strings,

00:31:09.580 --> 00:31:11.700
and we're going to get another error.

00:31:12.030 --> 00:31:14.110
Now this is similar to
the first blocks error,

00:31:14.370 --> 00:31:19.700
because when you just name the variable
strings here in the open square brackets,

00:31:19.700 --> 00:31:21.600
it's going to capture by copy.

00:31:21.780 --> 00:31:23.900
Same semantics as blocks
for the most part.

00:31:23.900 --> 00:31:26.060
We're going to copy the
variable into the lambda.

00:31:26.140 --> 00:31:29.230
It's going to be const,
so we can't modify it.

00:31:29.360 --> 00:31:31.000
Again, that's our compiler error.

00:31:31.000 --> 00:31:33.260
We can't sort something that's const.

00:31:33.440 --> 00:31:37.800
And the one difference in the by-value
captures of lambdas versus in blocks

00:31:38.410 --> 00:31:41.860
is that for Objective-C objects
that are captured by value,

00:31:41.910 --> 00:31:45.950
we do not retain them
when creating the lambda.

00:31:46.080 --> 00:31:49.260
So they're retained by blocks,
not by lambdas.

00:31:49.470 --> 00:31:51.000
Again, let's fix this example.

00:31:51.000 --> 00:31:54.400
Let's actually make it work with lambdas,
and we're going to do that

00:31:54.400 --> 00:31:56.020
with a by-reference capture.

00:31:56.350 --> 00:32:02.030
Same solution as we saw with the blocks,
except different syntax and

00:32:02.120 --> 00:32:03.430
slightly different semantics.

00:32:03.550 --> 00:32:06.620
So the by-reference capture,
you put an ampersand before the variable

00:32:06.620 --> 00:32:10.640
name within the capture list to say,
"I want to capture this by reference."

00:32:10.710 --> 00:32:13.900
Variables captured by reference
in a lambda are never copied.

00:32:14.020 --> 00:32:16.380
You're actually getting
a direct reference to the

00:32:16.380 --> 00:32:19.790
element that is on the stack.

00:32:20.100 --> 00:34:05.400
[Transcript missing]

00:34:06.350 --> 00:34:10.380
Now,
this is only available in Objective-C++.

00:34:10.380 --> 00:34:13.100
And the reason for that is
that when we do this conversion

00:34:13.100 --> 00:34:16.300
from a lambda to a block,
we create a new block.

00:34:16.300 --> 00:34:18.300
And that block needs to be managed.

00:34:18.300 --> 00:34:19.300
Its memory needs to be managed.

00:34:19.300 --> 00:34:22.410
And so we return it as
retain-auto-released,

00:34:22.410 --> 00:34:25.510
using the Objective-C memory subsystem
to give you back a block that's

00:34:25.510 --> 00:34:28.640
going to live long enough and,
of course, can be block-copied if

00:34:28.640 --> 00:34:30.290
it needs to live longer.

00:34:30.580 --> 00:34:33.690
Of course, the Arc Optimizer will kick
in here to eliminate this

00:34:33.780 --> 00:34:36.700
retain-auto-release pair in many,
many, many cases,

00:34:36.770 --> 00:34:39.900
but it still can be there
in certain rare cases.

00:34:39.980 --> 00:34:44.700
So, let's step back and look at blocks
and lambdas at a high level.

00:34:44.720 --> 00:34:47.880
They're intending to provide
essentially the same feature of these

00:34:47.920 --> 00:34:50.100
anonymous functions or closures.

00:34:50.120 --> 00:34:53.960
They both allow capture by copy,
they both allow capture by reference.

00:34:54.100 --> 00:34:57.800
Blocks skew toward safety,
so they'll make sure that they

00:34:57.800 --> 00:35:00.670
retain Objective-C objects
when you do a by-value capture,

00:35:00.780 --> 00:35:02.560
so those things don't go away.

00:35:02.860 --> 00:35:08.400
They make sure to copy your
by-reference captures out to the heap,

00:35:08.560 --> 00:35:12.800
so that you can't have dangling
references within your blocks.

00:35:13.100 --> 00:35:15.840
However, beyond that,
when using our APIs,

00:35:15.840 --> 00:35:18.840
you have flexibility to use
whatever is right for your problem,

00:35:18.970 --> 00:35:21.530
because both Blocks and
Lambdas work with all of the

00:35:21.530 --> 00:35:24.510
Blocks-based APIs on our system.

00:35:24.690 --> 00:35:26.600
So what should you use?

00:35:26.630 --> 00:35:28.600
Should you use blocks,
should you use lambdas?

00:35:28.730 --> 00:35:31.600
So our recommendation is
generally for Objective C++ code,

00:35:31.690 --> 00:35:33.600
you should use blocks.

00:35:33.600 --> 00:35:35.850
The reason, they're succinct,
they're well understood by

00:35:35.850 --> 00:35:40.600
the Objective C community,
and they skew towards safety,

00:35:40.640 --> 00:35:44.690
so you're more likely to have a correct
application if you just use the blocks,

00:35:44.690 --> 00:35:47.600
because it's going to make sure
that your objects are retained,

00:35:47.600 --> 00:35:48.600
your references don't dangle.

00:35:48.600 --> 00:35:51.590
Now, there are good reasons
to use lambdas as well.

00:35:51.670 --> 00:35:55.570
You might be in a portable C++11
code base that already has lambdas.

00:35:55.650 --> 00:35:58.600
In that case,
just continue using lambdas.

00:35:58.600 --> 00:36:01.590
You may want to have really precise
control over how captures work.

00:36:01.600 --> 00:36:03.810
You want to write out that
explicit capture list and

00:36:03.920 --> 00:36:05.600
say how each thing works.

00:36:05.600 --> 00:36:07.600
Lambdas are really good
for that sort of thing.

00:36:07.820 --> 00:36:10.530
And finally,
if you're working with C++ and templates,

00:36:10.600 --> 00:36:14.540
the compiler can do a lot more
optimization when you're passing

00:36:14.590 --> 00:36:18.600
a lambda expression to a C++
template than it can with a block

00:36:18.600 --> 00:36:21.600
passed to that same template,
even though both will work.

00:36:21.700 --> 00:36:24.340
So with that, let's talk about the
deployment story for C++11.

00:36:24.610 --> 00:36:27.600
So of course, C++11, it's available now.

00:36:27.760 --> 00:36:30.600
The language features work anywhere.

00:36:30.600 --> 00:36:34.600
For the libc++ library to get
the full C++11 experience,

00:36:34.600 --> 00:36:40.820
you can build your apps and deploy
them back to iOS 5 and MacOSX Lion.

00:36:41.410 --> 00:36:46.690
So we think C++ 11 is a really great
revision of the C++ language and library.

00:36:46.700 --> 00:36:50.940
So we're moving the C++
defaults towards C++ 11.

00:36:50.990 --> 00:36:53.150
In Xcode 4.4,
you'll see that any new projects

00:36:53.560 --> 00:36:55.140
start with C++ 11 as a language.

00:36:55.140 --> 00:36:59.340
In Xcode 4.5, we're going to move
the default to libc++,

00:36:59.450 --> 00:37:02.450
so that by default,
new projects going forward will

00:37:02.450 --> 00:37:05.070
use the full C++ 11 language.

00:37:05.220 --> 00:37:08.490
Of course, there's absolutely no reason
to wait until you start your

00:37:08.490 --> 00:37:10.300
next projects to do C++ 11.

00:37:10.640 --> 00:37:13.820
You can just go in and change
your build settings so that

00:37:13.820 --> 00:37:17.060
you're using the GNU++ 11,
which is the most compatible

00:37:17.150 --> 00:37:22.130
C++ 11 setting for the language,
and use the libc++ C++ 11

00:37:22.130 --> 00:37:26.410
library to give you complete,
very useful C++ 11

00:37:26.550 --> 00:37:28.060
solution for your apps.

00:37:28.190 --> 00:37:31.170
If you're a command line kind of person,
flags are up here to

00:37:31.170 --> 00:37:35.410
use GNU++ 11 and libc++.

00:37:35.520 --> 00:37:38.740
And with that, I'm going to turn it
over to Ted Kremenek,

00:37:38.820 --> 00:37:44.220
who's going to talk about finding bugs
using Clang Compiler and Static Analyzer.

00:37:44.300 --> 00:37:46.420
So just to recap,
we've been talking about different

00:37:46.420 --> 00:37:49.480
ways that the compiler can improve
the quality of your applications.

00:37:49.570 --> 00:37:51.540
We talked about performance
enhancements to the compiler

00:37:51.540 --> 00:37:55.180
that we continue to do with every
release to make your app run faster,

00:37:55.370 --> 00:37:59.260
so we encourage you to go
and re-compile your app.

00:37:59.320 --> 00:38:01.610
And then throughout the week,
we've been talking about various

00:38:01.660 --> 00:38:03.770
language improvements we've been making.

00:38:03.780 --> 00:38:06.260
You know, we've talked extensively
about Objective-C.

00:38:06.320 --> 00:38:08.240
Doug just talked about C++.

00:38:08.330 --> 00:38:10.040
And this is a trajectory
that will continue,

00:38:10.160 --> 00:38:11.540
you know, going forward.

00:38:11.640 --> 00:38:14.840
So in this last part of the talk,
let's talk about ways that the compiler

00:38:14.930 --> 00:38:19.960
can proactively find-- compiler-related
tools can proactively find issues

00:38:20.110 --> 00:38:22.400
that are latent in your code.

00:38:22.490 --> 00:38:25.130
The motivation is very simple.

00:38:25.140 --> 00:38:28.820
We have this very large
ecosystem of applications,

00:38:28.890 --> 00:38:30.440
and users notice quality, right?

00:38:30.610 --> 00:38:32.770
Quality really matters.

00:38:32.840 --> 00:38:35.780
And they can be very vocal
about what they think,

00:38:35.780 --> 00:38:37.640
you know, about your application.

00:38:37.740 --> 00:38:41.200
And quality can mean the difference
between them buying your app

00:38:41.350 --> 00:38:44.260
and just steering clear of it,
you know, forever.

00:38:44.420 --> 00:38:48.250
So it leaves a very lasting
impression in the App Store.

00:38:48.330 --> 00:38:51.450
And we want to help with this by
making the compiler-related tools

00:38:51.460 --> 00:38:55.060
be able to be more proactive at
finding issues before they ship.

00:38:55.160 --> 00:38:58.440
And this is something we care
very much about and will continue

00:38:58.450 --> 00:39:00.370
to improve going forward.

00:39:00.950 --> 00:39:02.790
So how can we do this?

00:39:03.120 --> 00:39:05.640
One very obvious way that we've
been doing for a long time is

00:39:05.760 --> 00:39:08.340
finding issues using warnings,
right?

00:39:08.460 --> 00:39:09.540
Warnings are awesome, right?

00:39:09.540 --> 00:39:13.290
I mean, as you're coding,
they find bugs early, right?

00:39:13.400 --> 00:39:17.450
And when we engineered the
Apple LLVM compiler from the ground up,

00:39:17.670 --> 00:39:22.000
we cared very much about building a
system that could give you very clear,

00:39:22.080 --> 00:39:26.100
explanatory diagnostics that could
work in the presence of macros,

00:39:26.100 --> 00:39:30.160
templates, just all the natural stuff
that you use in your code.

00:39:30.240 --> 00:39:32.660
And of course,
we provide fixes in many cases

00:39:32.660 --> 00:39:36.160
when the compiler has fairly good
intelligence about discovering,

00:39:36.160 --> 00:39:37.820
well, maybe this is what you meant.

00:39:37.820 --> 00:39:39.500
This is the likely fix.

00:39:39.500 --> 00:39:42.900
We've continued this trend in Xcode 4.4.

00:39:42.920 --> 00:39:48.380
We've added much deeper static analysis,
which is the corollary of the compiler.

00:39:48.440 --> 00:39:51.980
And we've added various compiler
warnings and static analyzer checks

00:39:52.070 --> 00:39:56.620
that focus a lot on memory safety,
security, just general correctness.

00:39:56.620 --> 00:39:59.800
And we've also improved the ways in
which you can control warnings and you

00:39:59.840 --> 00:40:03.130
can tailor them more to your individual
workflow because some warnings make more

00:40:03.130 --> 00:40:05.400
sense for other codebases versus others.

00:40:05.570 --> 00:40:08.120
So we're gonna touch on all these topics.

00:40:08.830 --> 00:40:11.940
So for those of you not familiar
with the differences between the

00:40:11.940 --> 00:40:15.000
compiler and the Static Analyzers,
let's just step back and take a

00:40:15.000 --> 00:40:18.230
look at what they're intended to do.

00:40:18.260 --> 00:40:20.750
On one end of the spectrum,
if you think about trading

00:40:20.750 --> 00:40:24.070
CPU time for finding issues,
we can think of the compiler

00:40:24.070 --> 00:40:27.360
as being on one end,
where it's fast, it's always available,

00:40:27.360 --> 00:40:30.000
and it's so fast,
we use it for code completion,

00:40:30.050 --> 00:40:32.420
we provide live issues within Xcode.

00:40:32.420 --> 00:40:33.760
And so it's really great.

00:40:33.760 --> 00:40:34.940
It gives you instant feedback.

00:40:34.940 --> 00:40:38.860
But because it has to be so fast,
it inherently does a more

00:40:38.910 --> 00:40:41.350
shallow analysis of your code.

00:40:41.540 --> 00:40:45.190
And so we kind of look at it as,
it can find some really important bugs,

00:40:45.190 --> 00:40:47.450
but they're the ones
that are just harder,

00:40:47.450 --> 00:40:50.070
I mean, easier to see,
kind of with the naked eye.

00:40:50.080 --> 00:40:54.340
On the other end of the spectrum,
we have the Static Source Code Analyzer.

00:40:54.340 --> 00:41:00.140
It's basically compiler analysis,
like on steroids, we trade CPU time for

00:41:00.140 --> 00:41:04.980
finding more issues,
doing a deeper analysis of your code.

00:41:04.980 --> 00:41:07.460
And so we look at it as, like,
kind of finding those

00:41:07.570 --> 00:41:09.920
bugs that are more subtle,
harder to see.

00:41:10.620 --> 00:41:13.590
You won't necessarily want to
run this analysis all the time,

00:41:13.590 --> 00:41:17.230
but you're encouraged, obviously,
to proactively do so often.

00:41:17.240 --> 00:41:22.010
Moreover, we can engineer intelligence
into the Static Analyzer that we

00:41:22.010 --> 00:41:24.320
just can't do with the compiler.

00:41:24.320 --> 00:41:27.380
We can teach it about common APIs,
like Grand Central Disk Ratch,

00:41:27.520 --> 00:41:30.110
Core Foundation, and so forth,
things we just can't really

00:41:30.220 --> 00:41:31.820
do very well in the compiler.

00:41:34.490 --> 00:41:36.420
So to kind of understand the
differences between these

00:41:36.570 --> 00:41:39.200
tools on a more concrete level,
let's look at one kind of

00:41:39.200 --> 00:41:41.800
bug that they both can find.

00:41:41.870 --> 00:41:45.740
And this is just a standard, you know,
using an uninitialized variable.

00:41:45.810 --> 00:41:47.980
So if you run this code
example through the compiler,

00:41:48.160 --> 00:41:51.040
this is the exact output
you'll see on the command line.

00:41:51.040 --> 00:41:52.800
You'll get, you know,
a diagnostic saying that

00:41:52.800 --> 00:41:56.060
you're using this variable
uninitialized when you return it.

00:41:56.060 --> 00:41:58.180
It actually points to the line of code.

00:41:58.330 --> 00:42:02.340
We show the warning flag on the
right side of the diagnostic.

00:42:02.400 --> 00:42:04.640
And we even have a suggested fix-it here,
you know,

00:42:04.640 --> 00:42:08.400
that you can silence the problem
by initializing the variable.

00:42:08.450 --> 00:42:11.420
Now,
if we make this code just slightly more,

00:42:11.440 --> 00:42:14.290
you know, complicated, right,
and this is a little bit contrived.

00:42:14.350 --> 00:42:17.080
We're initializing a variable, you know,
by reference.

00:42:17.220 --> 00:42:21.390
But we've all seen or written code
that looks something like this,

00:42:21.390 --> 00:42:22.100
right?

00:42:22.130 --> 00:42:26.380
The compiler actually can't find a
problem in this code because it just

00:42:26.380 --> 00:42:28.920
takes a little bit deeper analysis.

00:42:29.720 --> 00:42:33.020
We run the compiler over it,
and you're going to get no issues at all.

00:42:33.280 --> 00:42:36.600
You run the Static Analyser
over it in Xcode 4.4,

00:42:36.630 --> 00:42:42.600
we get this very rich diagnostic saying,
like, hey, you used this variable

00:42:42.670 --> 00:42:48.100
uninitialized when you took this
particular path through your code,

00:42:48.100 --> 00:42:52.350
where you took the false branch and bar,
you called foo, and then skipped over

00:42:52.350 --> 00:42:52.350
initializing the object.

00:42:52.350 --> 00:42:52.350
So very clear, very explanatory.

00:42:54.060 --> 00:42:57.760
So let's look at the improvements
in the Static Analyzr.

00:42:57.760 --> 00:43:02.000
In Xcode 4.3, which is our current
shipping version of Xcode,

00:43:02.000 --> 00:43:05.890
the Analyzr works by essentially
analyzing each file one at a time.

00:43:05.980 --> 00:43:08.000
And if we think of these as
the functions in the file,

00:43:08.000 --> 00:43:11.650
it just iterates over those functions
and does a deep code analysis.

00:43:11.920 --> 00:43:13.810
And here we have these functions,
foo and bar,

00:43:13.910 --> 00:43:16.930
and in previous versions of the Analyzr,
they're just analyzed

00:43:16.950 --> 00:43:18.330
completely separately.

00:43:18.450 --> 00:43:20.960
So if we looked at the body of foo,
we just see that, you know,

00:43:21.070 --> 00:43:24.080
this value is being written
to some memory location.

00:43:24.150 --> 00:43:26.550
But if we don't really know
anything about that memory location,

00:43:26.710 --> 00:43:29.770
there's no reason to assume
there's anything wrong.

00:43:29.930 --> 00:43:33.720
Similarly, if we analyze bar without
any understanding of what

00:43:33.750 --> 00:43:35.840
the function foo does,
there doesn't look like

00:43:35.840 --> 00:43:36.830
there's anything wrong here.

00:43:36.930 --> 00:43:40.880
So if you just imagine that
the body of foo wasn't here,

00:43:41.050 --> 00:43:44.230
you yourself wouldn't really guess
that you were doing anything wrong,

00:43:44.230 --> 00:43:44.670
right?

00:43:44.830 --> 00:43:46.490
So, like,
there's obviously a problem here.

00:43:46.610 --> 00:43:49.700
But this is essentially, you know,
the limited reasoning, you know,

00:43:49.760 --> 00:43:53.830
boundary that was in previous
versions of the Analyzr.

00:43:54.230 --> 00:43:57.190
In Xcode 4.4,
we've enhanced it for the analyzer

00:43:57.190 --> 00:44:02.850
to look much more deeply into these
cross-functional dependencies.

00:44:02.970 --> 00:44:05.500
So in this case,
we start by analyzing the function bar,

00:44:05.500 --> 00:44:08.700
because we can see on a call
graph that it lies at the top.

00:44:08.780 --> 00:44:11.390
And then when we contextually
see it calling foo,

00:44:11.690 --> 00:44:13.530
it will flag a null to reference.

00:44:13.620 --> 00:44:18.190
This one change greatly amplifies
the power of the Static Analyzers to

00:44:18.280 --> 00:44:20.360
find a lot more issues in your code.

00:44:20.460 --> 00:44:24.620
And we think that you're absolutely
going to love this enhancement.

00:44:24.900 --> 00:47:19.900
[Transcript missing]

00:47:21.510 --> 00:47:25.740
Let's look at a cussed of memcopy,
and that's memset.

00:47:25.750 --> 00:47:27.260
Basically the same thing.

00:47:27.260 --> 00:47:30.600
Instead of copying, you know,
some bytes from some other location,

00:47:30.600 --> 00:47:34.580
you're just setting a range
of bytes to be the same value.

00:47:35.020 --> 00:47:36.730
Here it looks like we're
doing everything right.

00:47:36.740 --> 00:47:40.400
We're computing the size of the
destination object correctly.

00:47:40.450 --> 00:47:44.460
But if this is C++ code,
this also might be subtly incorrect.

00:47:44.660 --> 00:47:48.810
What if Y is some object that has,
you know, virtual methods, right?

00:47:48.870 --> 00:47:52.750
That means there's a
V pointer in that object.

00:47:52.810 --> 00:47:55.420
And so when you're memsetting here,
you're not just, like,

00:47:55.420 --> 00:47:56.200
zero-initializing it.

00:47:56.200 --> 00:47:58.960
You're just nuking that V table pointer.

00:47:59.090 --> 00:48:02.000
And the compiler will
actually warn about this now,

00:48:02.000 --> 00:48:02.440
too.

00:48:02.500 --> 00:48:05.480
And we've heard from a very
credible game developer that

00:48:05.480 --> 00:48:08.680
when they turn this warning on,
they found a large number

00:48:08.690 --> 00:48:10.780
of bugs in their code base.

00:48:10.880 --> 00:48:16.330
So it might seem a little contrived,
but this stuff happens all the time.

00:48:16.580 --> 00:48:18.590
Let's talk about some
Static Analyser issues.

00:48:18.650 --> 00:48:22.150
I had mentioned before how the
Static Analyser has a deep knowledge

00:48:22.170 --> 00:48:25.750
of many of our framework APIs.

00:48:26.000 --> 00:48:30.190
CF is something that's obviously
used extensively on OSX and iOS.

00:48:30.460 --> 00:48:35.690
We have containers like CFArray,
CFDictionary, and so on.

00:48:36.120 --> 00:48:39.840
One issue we've seen is with
portability between OSX and iOS.

00:48:39.840 --> 00:48:43.090
We can have the difference
between 32-bit and 64-bit.

00:48:43.100 --> 00:48:46.910
And there's cases where people
want to use their containers to

00:48:46.910 --> 00:48:49.150
store things other than objects.

00:48:49.260 --> 00:48:53.090
And they'll do clever things like,
here we have an array of ints.

00:48:53.120 --> 00:48:56.800
Ints on a 32-bit architecture have
the same size as a pointer value,

00:48:56.800 --> 00:49:00.150
so let's just do some tricks
here so that we can stuff an

00:49:00.150 --> 00:49:02.640
array of ints into a CF set.

00:49:03.260 --> 00:49:05.860
It turns out if you put
this on a 64-bit machine,

00:49:05.860 --> 00:49:07.040
this is complete nonsense.

00:49:07.040 --> 00:49:07.900
This is garbage.

00:49:07.900 --> 00:49:11.910
And you're going to get
completely unpredictable results.

00:49:11.980 --> 00:49:16.180
We strongly discourage
writing this kind of code.

00:49:16.200 --> 00:49:17.520
It's a portability issue.

00:49:17.520 --> 00:49:18.800
It's just very brittle.

00:49:18.800 --> 00:49:20.940
That's not really how
the APIs were intended.

00:49:20.940 --> 00:49:24.730
And on a 64-bit architecture,
this would be a security

00:49:24.740 --> 00:49:26.520
or a correctness issue.

00:49:26.520 --> 00:49:27.900
Thank you.

00:49:30.190 --> 00:49:33.440
So let's talk about the last
bit about memory safety.

00:49:33.440 --> 00:49:35.240
And these are, again,
just the highlights of some of the

00:49:35.240 --> 00:49:39.400
things that we have added to both
the compiler and the Static Analyser.

00:49:39.470 --> 00:49:41.440
And that's mallocan-free.

00:49:41.440 --> 00:49:45.820
Mallocan-free are these low-level
memory management APIs that

00:49:45.910 --> 00:49:47.600
we still use very frequently.

00:49:47.860 --> 00:49:51.460
Arc does a great job of managing
your Objective-C objects,

00:49:51.570 --> 00:49:53.330
but for mallocan-free,
you still need to manage

00:49:53.370 --> 00:49:56.010
that memory yourself.

00:49:56.170 --> 00:49:58.920
Now, we have great tools like
instruments and leaks to help

00:49:58.950 --> 00:50:02.090
you try and find these issues,
but those tools are

00:50:02.090 --> 00:50:03.900
limited in various ways.

00:50:03.900 --> 00:50:06.490
First, you're going to only be able
to find leaks on code paths

00:50:06.590 --> 00:50:08.400
that you yourself test,
right?

00:50:08.410 --> 00:50:12.800
And memory leaks can often happen
on corner cases that maybe it's,

00:50:12.800 --> 00:50:17.380
you know, just some case that you haven't
tested but your users encounter.

00:50:17.580 --> 00:50:20.720
And also, it would be great if you
could just find these issues

00:50:20.720 --> 00:50:23.040
proactively without having to do,
you know,

00:50:23.090 --> 00:50:26.440
the extensive dynamic analysis later.

00:50:26.510 --> 00:50:28.660
Oftentimes,
we can find these memory leaks

00:50:28.800 --> 00:50:30.860
using static source code analysis.

00:50:31.020 --> 00:50:32.200
It's not perfect.

00:50:32.200 --> 00:50:34.770
You still should use tools
like instruments and so forth,

00:50:34.860 --> 00:50:36.900
but we think this is going to
greatly enhance your ability

00:50:36.900 --> 00:50:38.430
to find those problems early.

00:50:38.670 --> 00:50:40.340
So here's a real example.

00:50:40.340 --> 00:50:45.290
It's been slightly simplified to fit,
you know, well on this slide.

00:50:45.520 --> 00:50:47.420
But essentially,
it's a case where we're calling

00:50:47.420 --> 00:50:50.140
malloc and then we're returning early.

00:50:50.200 --> 00:50:52.860
You run it through the
Static Analyser in Xcode 4.4.

00:50:52.880 --> 00:50:55.640
You're going to get a
diagnostics like this,

00:50:55.660 --> 00:50:58.530
and where we gave an explanation where,
you know, how the memory was allocated.

00:50:58.540 --> 00:51:01.560
We even see that the pointer
was checked for validity.

00:51:01.650 --> 00:51:04.750
And then on an early return path,
we said that the memory was leaked,

00:51:04.750 --> 00:51:05.220
right?

00:51:05.290 --> 00:51:07.770
This is a very localized, you know,
problem, right?

00:51:07.800 --> 00:51:10.890
And you wouldn't have been able to
find it with the dynamic analysis

00:51:10.890 --> 00:51:14.570
tool unless you were able to test
the case where set of data failed,

00:51:14.670 --> 00:51:15.440
right?

00:51:15.570 --> 00:51:17.960
So very subtle,
but you can find these issues

00:51:17.970 --> 00:51:20.380
proactively using the Static Analyser.

00:51:20.620 --> 00:51:22.720
So let's look at a real bug.

00:51:23.490 --> 00:51:26.660
This is something
slightly more complicated.

00:51:26.660 --> 00:51:30.310
And it's essentially the same bug
that I just showed you before.

00:51:30.450 --> 00:51:33.730
We're returning early,
and we're failing to

00:51:33.760 --> 00:51:35.920
deallocate something.

00:51:36.810 --> 00:51:38.860
The details of this code
doesn't really matter.

00:51:38.870 --> 00:51:44.050
The thing to keep in mind is the very top
we're calling this function parsePgArray,

00:51:44.050 --> 00:51:49.050
where we were turning
allocated memory by reference.

00:51:49.400 --> 00:51:51.460
So if you looked at
this like in isolation,

00:51:51.540 --> 00:51:54.540
you wouldn't necessarily
know that that was the case,

00:51:54.540 --> 00:51:55.130
right?

00:51:55.380 --> 00:51:57.700
But because we have this new
cross-functional analysis,

00:51:57.700 --> 00:52:01.580
the analyzer looks into the
implementation of this function.

00:52:01.790 --> 00:52:04.950
And if you go to the navigation
bar that shows up in the editor,

00:52:04.950 --> 00:52:08.670
you'll get a complete
abstract call stack.

00:52:09.270 --> 00:52:12.200
and you can dive in and
see what's going on.

00:52:12.410 --> 00:52:15.580
If I click on that,
I go into the body of parsePgArray.

00:52:15.640 --> 00:52:19.330
I see the allocation from malloc,
and at the bottom we see that

00:52:19.350 --> 00:52:22.650
memory getting assigned by
reference to the return value.

00:52:22.740 --> 00:52:25.380
So this allows you to dive in,
write into the code to

00:52:25.380 --> 00:52:26.700
see what's going on.

00:52:26.700 --> 00:52:28.900
It's really, really powerful.

00:52:30.590 --> 00:52:32.000
So we just highlighted a few things.

00:52:32.000 --> 00:52:34.100
We've added enhancements
for finding issues with,

00:52:34.130 --> 00:52:37.040
you know, Cocoa Touch APIs,
Grand Central Dispatch,

00:52:37.040 --> 00:52:40.840
portability issues, and a whole bunch of
the low-level Unix APIs.

00:52:40.840 --> 00:52:44.640
And we'll continue to improve the
Static Analyzers and the compiler in

00:52:44.640 --> 00:52:47.040
these areas and others going forward.

00:52:47.160 --> 00:52:51.600
So with all this new awesomeness, right,
how do you go and tailor

00:52:51.600 --> 00:52:53.400
it to your workflow?

00:52:55.290 --> 00:52:59.790
We talked about in the kickoff about how
controlling warnings is really important.

00:52:59.840 --> 00:53:03.400
I'd like to divide that for the
compiler into two different approaches.

00:53:03.570 --> 00:53:07.630
The standard approach you have right now
is the additive approach to warnings.

00:53:07.660 --> 00:53:11.900
If you imagine that this gray bar is the
set of all possible compiler warnings,

00:53:11.950 --> 00:53:15.100
there's some set of warnings
that are enabled by default.

00:53:15.190 --> 00:53:17.500
These are the ones that we,
in our divine wisdom,

00:53:17.500 --> 00:53:22.510
have decided that you should always see,
or at least see by default.

00:53:23.490 --> 00:53:27.640
Then there's all these, like,
magical flags that exist to turn

00:53:27.640 --> 00:53:29.430
on additional compiler warnings.

00:53:29.470 --> 00:53:32.840
We have the misnamed WALL,
which doesn't actually turn

00:53:32.920 --> 00:53:34.440
on all compiler warnings.

00:53:34.620 --> 00:53:37.900
This really just came about
from historical expectations.

00:53:37.960 --> 00:53:39.910
You know,
people started building their code

00:53:40.000 --> 00:53:43.940
with WALL and pairing it with WAR,
which turns all warnings to errors.

00:53:43.940 --> 00:53:46.600
And then whenever compiler
authors added new warnings to

00:53:46.600 --> 00:53:48.940
WALL that they didn't like,
that those people didn't like,

00:53:48.940 --> 00:53:51.940
those authors got yelled at.

00:53:52.230 --> 00:53:56.590
So we have to add things,
new warnings to WL with a lot of care.

00:53:56.690 --> 00:54:03.150
And then there's other
esoteric flags like -pandantic,

00:54:03.150 --> 00:54:07.010
and then just a whole smorgasbord
of other compiler flags that you can

00:54:07.010 --> 00:54:07.010
pass to turn on additional warnings.

00:54:07.190 --> 00:54:11.400
So the problem is,
how do you know what all these flags are?

00:54:11.590 --> 00:54:15.030
I mean,
it's a real discoverability issue.

00:54:15.100 --> 00:54:19.030
We have to document these, of course,
but let's say you just want to

00:54:19.030 --> 00:54:22.000
use all the warnings that are
available that make sense for you.

00:54:22.000 --> 00:54:24.100
Should you go and look
at the release notes?

00:54:24.100 --> 00:54:26.680
And I mean,
there's hundreds of compiler warnings.

00:54:26.790 --> 00:54:31.450
So there's an inverse approach,
where you start with all warnings,

00:54:31.450 --> 00:54:34.090
and you turn off the ones you don't want.

00:54:34.470 --> 00:54:37.620
With the new -weverything flag,
or weverything,

00:54:37.690 --> 00:54:42.510
you can truly turn on all the
warnings that are in the compiler.

00:54:42.780 --> 00:54:45.470
Now, the one caveat is-- well,
there's two caveats.

00:54:45.570 --> 00:54:48.200
One, if you upgrade compilers,
you should just basically expect

00:54:48.200 --> 00:54:52.320
your code not to compile anymore
if you're passing w-error.

00:54:52.530 --> 00:54:55.050
This is really the intended workflow,
right?

00:54:55.060 --> 00:54:59.400
And the idea is that you immediately
are drawing attention to the new issues,

00:54:59.480 --> 00:55:03.920
and you can decide either to fix
them or disable those warnings.

00:55:04.720 --> 00:55:07.810
and you could do so
simply by passing the -w,

00:55:07.950 --> 00:55:11.040
no, and the warning name
flag to the compiler.

00:55:11.130 --> 00:55:13.200
So it's a very powerful workflow.

00:55:13.280 --> 00:55:17.030
And as we saw earlier in the diagnostics,
the compiler will tell you what the

00:55:17.030 --> 00:55:20.350
warning flag is when you see the warning,
right?

00:55:20.460 --> 00:55:22.120
So there's no discoverability problem.

00:55:22.240 --> 00:55:25.180
You know exactly how to
turn the warnings off.

00:55:25.290 --> 00:55:27.700
Now,
the other caveat about this approach,

00:55:27.810 --> 00:55:31.360
besides, you know, the w-air issue,
is that there are many warnings.

00:55:31.360 --> 00:55:34.860
Some warnings are more like
coding-style conventions.

00:55:34.860 --> 00:55:39.240
For example, we have the new default
synthesis feature in Xcode 4.4.

00:55:39.420 --> 00:55:41.790
There is a warning for
transitioning from,

00:55:41.790 --> 00:55:43.310
you know,
older code that's using explicit

00:55:43.370 --> 00:55:45.360
synthesis to default synthesis.

00:55:45.480 --> 00:55:48.530
And some people would like to
still be warned about explicitly,

00:55:48.630 --> 00:55:51.960
you know, not explicitly synthesizing
your properties.

00:55:52.110 --> 00:55:53.760
That is a coding-style warning.

00:55:53.760 --> 00:55:56.360
If you don't want to see it,
which shouldn't apply to most of you,

00:55:56.360 --> 00:55:59.060
just turn the warning off.

00:55:59.060 --> 00:56:02.360
So that's the one caveat, is, like,
there's a lot of different warnings here.

00:56:02.360 --> 00:56:05.360
Just cherry-pick the ones
that make sense for you.

00:56:05.360 --> 00:56:08.550
Beyond just the command line,
you continue to have the power to control

00:56:08.580 --> 00:56:11.860
compiler warnings within a source file.

00:56:12.040 --> 00:56:16.360
Many of you may not be aware,
but we have these preprocessor pragmas,

00:56:16.370 --> 00:56:20.120
which allow you to conditionally--
to suppress a warning within a

00:56:20.130 --> 00:56:24.350
scope of text or even promote a
particular warning to an error.

00:56:24.390 --> 00:56:28.360
And so this is documented on
the LLVM open source web page,

00:56:28.360 --> 00:56:31.750
but the syntax is pretty simple,
as you can see right here.

00:56:31.870 --> 00:56:33.860
You just say,
"Map this warning to an error,"

00:56:33.860 --> 00:56:35.360
and just give the warning name.

00:56:35.630 --> 00:56:39.360
Finally, we have improved the ability
to control analyzer issues.

00:56:39.360 --> 00:56:42.720
We've expanded the Xcode build settings
to allow you to turn off and turn

00:56:42.750 --> 00:56:44.360
on and turn off various checkers.

00:56:44.360 --> 00:56:46.860
You can do this on a
per-project and target level,

00:56:46.900 --> 00:56:49.210
and we will continue to enhance
this workflow going forward.

00:56:49.560 --> 00:56:52.070
So to summarize,
we're very passionate that a better

00:56:52.090 --> 00:56:54.350
compiler means better applications.

00:56:54.360 --> 00:56:57.260
We care very much about the
quality of what you are producing

00:56:57.360 --> 00:56:59.360
and putting on the App Store.

00:56:59.570 --> 00:57:02.290
And your users obviously do too.

00:57:02.800 --> 00:57:05.760
So in the LLVM compiler 4.0,
we've improved the performance of the

00:57:05.860 --> 00:57:07.690
compiler for you to write better code.

00:57:07.690 --> 00:57:08.240
It's faster.

00:57:08.240 --> 00:57:10.440
The compiler itself is faster.

00:57:10.620 --> 00:57:11.850
Great language improvements.

00:57:11.850 --> 00:57:13.650
It reduces boilerplate.

00:57:13.720 --> 00:57:16.840
It lets you let more elegant
code that's less error-prone.

00:57:16.910 --> 00:57:20.460
And we've improved its ability
to find more issues early with

00:57:20.460 --> 00:57:25.300
improved compiler warnings and
vastly improved static analysis.

00:57:25.360 --> 00:57:27.820
There's a lot of places you
can look for more information.

00:57:27.960 --> 00:57:31.390
Michael Jurowicz,
our developer tools evangelist.

00:57:31.510 --> 00:57:34.540
The open source web pages have a
lot of information that you go to.

00:57:34.540 --> 00:57:36.330
There's tips on using
the Static Analyser,

00:57:36.390 --> 00:57:38.540
the Static Analyser open source page.

00:57:38.620 --> 00:57:41.400
And we are directly available
on the developer forums.

00:57:41.550 --> 00:57:44.050
So we're happy to meet
with you at the labs.

00:57:44.290 --> 00:57:46.840
But we post on the developer
forums all the time.

00:57:46.840 --> 00:57:51.770
So if you have questions or concerns,
you can reach many of us directly there.

00:57:51.880 --> 00:57:54.360
And with that, we hope you enjoy the
rest of the conference.

00:57:54.380 --> 00:57:54.900
Thank you.
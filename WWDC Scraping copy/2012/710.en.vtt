WEBVTT

00:00:10.400 --> 00:06:19.800
[Transcript missing]

00:06:20.090 --> 00:06:22.400
In terms of its behavior, well,
it's backed up.

00:06:22.400 --> 00:06:24.280
We're going to maintain
that in the backup set.

00:06:24.310 --> 00:06:26.340
If it gets restored back
onto that same device,

00:06:26.500 --> 00:06:29.000
that whole table basically
will come back down.

00:06:29.110 --> 00:06:31.720
So it persists across as
it restores from backup.

00:06:32.260 --> 00:06:36.380
However, we won't restore that identifier
onto a different device.

00:06:36.570 --> 00:06:39.320
So if someone backs up an
iPhone and then purchases,

00:06:39.320 --> 00:06:41.590
say,
a new iPhone and restores that backup

00:06:41.730 --> 00:06:45.320
set onto that new different device,
then these identifiers won't

00:06:45.320 --> 00:06:46.620
come along for the ride.

00:06:46.930 --> 00:06:50.540
This is a long way of saying they
behave just like the UDID does today in

00:06:50.540 --> 00:06:52.980
that the UDID changed across devices.

00:06:53.470 --> 00:06:57.410
Similarly, the vendor identifier for your
apps will change across devices.

00:06:57.410 --> 00:07:00.000
So it's the behavior that
you've had with the UDID.

00:07:00.000 --> 00:07:01.490
So now we have two replacements.

00:07:01.490 --> 00:07:04.400
We have that one that can be used
for your individual application,

00:07:04.400 --> 00:07:06.480
random number,
the application identifier,

00:07:06.480 --> 00:07:09.340
and a second one which is
shared across your applications.

00:07:09.340 --> 00:07:12.900
But this still doesn't cover
all of the key uses of the UDID.

00:07:12.900 --> 00:07:16.400
So we have one more new API,
and we call that the advertiser.

00:07:16.690 --> 00:07:17.590
So we have one more new API,
and we call that the advertiser.

00:07:17.660 --> 00:07:18.660
This is the UDID.

00:07:18.660 --> 00:07:19.660
And it's a new UDID identifier.

00:07:19.660 --> 00:07:20.660
This, again, is new API.

00:07:20.660 --> 00:07:22.300
It also hangs out on
UIDevice's current device.

00:07:22.300 --> 00:07:25.750
And you can call it with
identifier for advertising.

00:07:25.820 --> 00:07:28.360
This identifier is unique to the device.

00:07:28.360 --> 00:07:32.400
And it's the same across all
applications on the device.

00:07:32.500 --> 00:07:33.420
It's used for advertising.

00:07:33.490 --> 00:07:36.640
And, in fact, we know it works well for
advertising because iAd,

00:07:36.640 --> 00:07:40.780
that's Apple's ad network,
has already converted over to using it.

00:07:40.780 --> 00:07:45.040
For every device running iOS 6 or later,
iAd now uses the advertising

00:07:45.040 --> 00:07:48.750
identifier exclusively,
and no longer uses the UDID as it

00:07:48.750 --> 00:07:51.500
once did for advertising purposes.

00:07:51.500 --> 00:07:54.470
If you're familiar with ads,
things like frequency capping,

00:07:54.500 --> 00:07:59.280
conversion tracking,
this identifier works for those purposes.

00:07:59.280 --> 00:08:02.610
Because it's not a hardware identifier,
it's something managed by software,

00:08:02.840 --> 00:08:06.240
that means the user can reset it by
tapping erase all content and settings,

00:08:06.240 --> 00:08:11.240
and that will create a new advertising
identifier on that same device.

00:08:11.240 --> 00:08:13.430
And then lastly, again,
to compare it to the other ones,

00:08:13.460 --> 00:08:14.720
this identifier is backed up.

00:08:14.760 --> 00:08:16.580
It's restored back onto the same device.

00:08:16.580 --> 00:08:18.190
It will persist that way.

00:08:18.250 --> 00:08:20.710
But if you restore that
back up onto a new device,

00:08:20.770 --> 00:08:22.980
it will be a new advertising identifier.

00:08:22.980 --> 00:08:27.340
So this one, like the vendor ID,
behaves like the UDID in terms

00:08:27.340 --> 00:08:29.900
of its behavior across devices.

00:08:29.900 --> 00:08:32.920
So for the replacements for UDID,
we have these three new APIs,

00:08:33.010 --> 00:08:35.380
the application identifier
for single apps,

00:08:35.380 --> 00:08:37.960
the vendor identifier across
all of your applications,

00:08:38.070 --> 00:08:41.680
and the advertising
identifier for advertising.

00:08:41.680 --> 00:08:42.880
And they have these behaviors.

00:08:42.920 --> 00:08:44.310
This is exactly what I said before.

00:08:44.420 --> 00:08:46.480
It's maybe so you can
go back in the video.

00:08:46.540 --> 00:08:49.040
The scope, lifetime,
the fact that all of them are backed up,

00:08:49.040 --> 00:08:51.580
and the fact that only the
advertising identifier will

00:08:51.580 --> 00:08:52.980
be restored across devices.

00:08:53.040 --> 00:08:57.460
So you've heard me say replacements a
few times over the past ten minutes,

00:08:57.460 --> 00:09:01.450
and so this slide shouldn't
be too much of a surprise,

00:09:01.520 --> 00:09:04.260
that the future of UDID is no UDID.

00:09:04.260 --> 00:09:06.820
There are these new replacement
APIs available in iOS 6,

00:09:06.820 --> 00:09:09.620
and I encourage you to
begin your transition now.

00:09:09.620 --> 00:09:12.550
For any new application you create,
you should build it on

00:09:12.630 --> 00:09:13.880
top of these new APIs.

00:09:13.880 --> 00:09:16.010
And as you update your
existing applications,

00:09:16.120 --> 00:09:16.500
move them up.

00:09:16.500 --> 00:09:17.400
And you can see that the new UDID is
now on top of the existing ones.

00:09:17.690 --> 00:09:24.190
And that's because the new UDID and
similar identifiers will be

00:09:24.250 --> 00:09:27.590
disallowed for use in the future.

00:09:27.640 --> 00:09:29.880
And when we do that,
it's not going to change anything

00:09:29.900 --> 00:09:33.960
about the legacy behavior of existing
applications on users' devices.

00:09:33.960 --> 00:09:35.790
They'll still be able to call,
for instance,

00:09:35.790 --> 00:09:38.510
the UDID and get back that same number,
so it won't be disruptive.

00:09:38.900 --> 00:09:40.970
However,
for those new applications and updates,

00:09:41.100 --> 00:09:44.340
use of the UDID and similar
identifiers won't be allowed.

00:09:44.340 --> 00:09:45.340
So it's motivating.

00:09:45.340 --> 00:09:46.340
And start your new UDID.

00:09:46.340 --> 00:09:46.420
Bye.

00:09:46.500 --> 00:09:47.420
Bye.

00:09:47.500 --> 00:09:47.500
Bye.

00:09:52.420 --> 00:09:54.970
Let me talk next about data isolation.

00:09:54.970 --> 00:09:57.300
And I'll actually start
by defining the term.

00:09:57.380 --> 00:10:00.210
Data isolation is just when the
OS is going to get between your

00:10:00.210 --> 00:10:02.280
application and sensitive user data.

00:10:02.300 --> 00:10:06.120
It does this in a way which is largely
transparent to your application.

00:10:06.300 --> 00:10:09.780
It's just that you call existing API,
and that will trigger a user

00:10:09.780 --> 00:10:11.300
consent dialogue or alert.

00:10:11.300 --> 00:10:14.300
And you guys have seen these, actually,
for location services.

00:10:14.300 --> 00:10:15.210
I have two examples up there.

00:10:15.310 --> 00:10:17.980
On the left,
we have one from iOS where camera

00:10:17.980 --> 00:10:20.300
is requesting access to location.

00:10:20.300 --> 00:10:25.000
On the right, you can see Safari and
OS X Lion doing the same thing.

00:10:25.180 --> 00:10:27.140
So when these alerts,
you also saw that the user could

00:10:27.140 --> 00:10:28.860
make a yes or no choice there.

00:10:28.860 --> 00:10:32.440
And so if the user says don't allow,
then the application doesn't get

00:10:32.440 --> 00:10:35.560
access to whatever data is covered
by that permissions dialogue.

00:10:35.610 --> 00:10:38.480
On the other hand, the user can say yes,
it works.

00:10:38.600 --> 00:10:42.280
And regardless of whether the user says
yes or no to that permissions dialogue,

00:10:42.370 --> 00:10:45.300
the OSs offer a choice for the
user to review and to change

00:10:45.300 --> 00:10:48.620
his or her decision afterward,
a no to a yes, a yes to a no,

00:10:49.020 --> 00:10:54.340
either by going into iOS settings or
inside of OS X system preferences.

00:10:55.000 --> 00:13:33.900
[Transcript missing]

00:13:34.130 --> 00:13:37.480
So let's start with the really dead
simple way of how it works today.

00:13:37.530 --> 00:13:39.420
This is just to be
grounding for the next one,

00:13:39.490 --> 00:13:39.760
right?

00:13:39.760 --> 00:13:42.320
If you want data today in
a non-data isolation world,

00:13:42.440 --> 00:13:45.440
you call createX,
you get back the thing with data, right?

00:13:45.480 --> 00:13:46.560
It's just as simple as that.

00:13:46.560 --> 00:13:47.900
You do it every day.

00:13:48.030 --> 00:13:52.490
So let's talk about how Contacts works on
OS X Mountain Lion with data isolation.

00:13:52.620 --> 00:13:56.270
Where it starts off again,
you call some address book API, say,

00:13:56.400 --> 00:13:59.930
and then what happens is that
OS X will go and ask permission.

00:14:00.100 --> 00:14:03.020
That dialog box will come up
requesting the user's permission.

00:14:03.170 --> 00:14:05.590
Let's say the user says,
"Okay," so you get permission.

00:14:05.770 --> 00:14:11.310
Then the API that you called will return
to you the object with all of that data.

00:14:12.000 --> 00:14:14.310
So this covers the API that you can call.

00:14:14.500 --> 00:14:17.500
It's the purpose-specific API,
which is a whole host of APIs inside

00:14:17.500 --> 00:14:18.880
the address book framework.

00:14:19.070 --> 00:14:21.630
Two examples might be the
shared address book or if you

00:14:21.630 --> 00:14:23.500
init AB person or AB group.

00:14:23.500 --> 00:14:26.800
These are the kinds of API that
will trigger that permission check.

00:14:26.820 --> 00:14:31.490
And as you saw in that last slide,
the call does block while the user gives

00:14:31.520 --> 00:14:33.890
or makes that choice about permission.

00:14:33.950 --> 00:14:35.290
And so this is a user action, right?

00:14:35.300 --> 00:14:38.380
It will take a relatively long
time compared to running code.

00:14:38.410 --> 00:14:42.660
And so if your application is in a state
where it needs to remain responsive,

00:14:42.720 --> 00:14:46.760
you should wrap the call to these
APIs inside of a dispatch block.

00:14:47.010 --> 00:14:50.190
But when it comes back,
if you've been granted access,

00:14:50.210 --> 00:14:53.060
if the user said yes,
it's just like the was before

00:14:53.110 --> 00:14:55.730
data isolation that you'll
get back a populated object.

00:14:55.840 --> 00:14:57.390
It has all the data.

00:14:57.450 --> 00:15:01.200
If the user denies access to contacts,
then you'll get back a nil object.

00:15:01.210 --> 00:15:03.600
So this is something you're
going to want to check for,

00:15:03.700 --> 00:15:06.450
whereas it would have been unlikely
in the past that you would have gotten

00:15:06.450 --> 00:15:08.300
back a nil object in the same way.

00:15:08.300 --> 00:15:11.550
And then in addition to the
purpose-specific API for

00:15:11.560 --> 00:15:14.220
the address book framework,
any other APIs which

00:15:14.220 --> 00:15:18.590
specifically use contacts data,
so sync services, spotlight if you're

00:15:18.640 --> 00:15:20.900
searching for a contact,
Apple script,

00:15:21.000 --> 00:15:24.250
these will also trigger those
same permission dialogs.

00:15:24.360 --> 00:15:27.510
So it's both the purpose-specific
APIs and other system services that

00:15:27.620 --> 00:15:29.700
explicitly access contacts data.

00:15:30.000 --> 00:15:32.180
So let's talk about
sandboxing and how it relates.

00:15:32.360 --> 00:15:33.780
And they're really separate things.

00:15:33.800 --> 00:15:35.850
The sandbox check still applies.

00:15:35.960 --> 00:15:38.140
So for those of you that are
submitting to the app store,

00:15:38.200 --> 00:15:41.600
sandboxed your application,
you know that the address book

00:15:41.650 --> 00:15:44.700
is already -- it's by default,
it's outside of the sandbox.

00:15:44.700 --> 00:15:47.900
And to bring it into the sandbox,
you have to request an entitlement.

00:15:47.900 --> 00:15:49.900
And you should only use the
entitlements that you need.

00:15:49.900 --> 00:15:54.130
And so in this case for contacts,
that entitlement is com.apple.security

00:15:54.520 --> 00:15:56.400
personal information address book.

00:15:56.430 --> 00:15:57.610
Descriptive long string.

00:15:57.740 --> 00:16:00.300
It's actually easier just to
check inside the Xcode UI.

00:16:00.300 --> 00:16:02.940
There's a box which says allow
address book data access.

00:16:03.050 --> 00:16:05.260
You check that,
the exact same thing happens

00:16:05.360 --> 00:16:06.980
in your entitlements file.

00:16:07.040 --> 00:16:10.100
So if you have -- if you
have that entitlement,

00:16:10.100 --> 00:16:13.780
then the sandbox check will pass,
and you'll get to that permission

00:16:13.780 --> 00:16:15.100
check that I just went through.

00:16:15.100 --> 00:16:17.050
But the sandbox check occurs first.

00:16:17.110 --> 00:16:21.060
If your application is sandboxed
and does not have the entitlement

00:16:21.180 --> 00:16:24.160
for address book data access,
then the sandbox will fail that

00:16:24.290 --> 00:16:27.100
request even before the user
is prompted for permission.

00:16:27.100 --> 00:16:28.600
So the two work together.

00:16:28.600 --> 00:16:31.600
You sandbox your application
with the necessary entitlements,

00:16:31.600 --> 00:16:33.600
and then the user gives you
permission whether or not

00:16:33.600 --> 00:16:36.100
to access the contacts data.

00:16:36.210 --> 00:16:38.000
And that's how it works
in OS X Mountain Lion.

00:16:38.000 --> 00:16:39.030
Amen.

00:16:39.610 --> 00:16:43.470
So this is the same slide,
but now let's take it from

00:16:43.470 --> 00:16:46.600
here and talk about iOS.

00:16:46.790 --> 00:16:50.190
And in iOS,
you have the call to create the object,

00:16:50.190 --> 00:16:53.390
and then you get back actually
immediately an empty object.

00:16:53.500 --> 00:16:57.630
And that's because if you think about it,
a lot of this data request happens at

00:16:57.630 --> 00:16:58.960
launch in some of your applications.

00:16:59.060 --> 00:17:01.620
Maybe it doesn't need to,
and we'll talk about that more later.

00:17:01.700 --> 00:17:05.230
But your application has a
limited amount of time to launch

00:17:05.240 --> 00:17:06.500
and needs to remain responsive.

00:17:06.500 --> 00:17:10.400
And so that permission check is
actually done separately by the OS.

00:17:10.490 --> 00:17:13.630
And then if you receive
access to the data,

00:17:13.720 --> 00:17:16.330
then you'll receive a change
notification stating that

00:17:16.330 --> 00:17:18.400
there's now data in this object.

00:17:18.590 --> 00:17:22.150
So that initial access,
it's synchronous in the sense

00:17:22.150 --> 00:17:24.280
that you call and it comes back.

00:17:24.310 --> 00:17:26.780
But the permission check is
occurring outside of that.

00:17:26.870 --> 00:17:28.610
That initial object may be empty.

00:17:28.760 --> 00:17:30.950
So it's very important that for
the classes that support it,

00:17:31.010 --> 00:17:32.940
you handle change notifications.

00:17:32.990 --> 00:17:36.270
And though I'm bringing it up here
in the context of data isolation,

00:17:36.430 --> 00:17:39.940
the change notification is something
you already should have been handling,

00:17:39.940 --> 00:17:39.940
right?

00:17:39.990 --> 00:17:43.210
Because in a world with
iCloud and data changing from

00:17:43.210 --> 00:17:45.920
underneath your application,
these change notifications were

00:17:45.920 --> 00:17:47.370
how you kept in sync already.

00:17:47.480 --> 00:17:49.710
But in this case,
a change notification will be

00:17:49.710 --> 00:17:52.270
more commonly occurring for
all of your applications that

00:17:52.360 --> 00:17:53.780
are accessing contacts data.

00:17:53.860 --> 00:17:57.730
And so it's important that you
really pay attention to it now.

00:17:58.140 --> 00:18:01.560
Because that story that I just told,
we're finding that it might be a little

00:18:01.560 --> 00:18:05.040
bit confusing or difficult to handle
that permission check out of band,

00:18:05.040 --> 00:18:07.590
we actually have a new
API we'll be adding to iOS 6.

00:18:07.760 --> 00:18:09.780
That said,
it's not in the seed that you have now,

00:18:09.790 --> 00:18:11.090
so don't go looking for it.

00:18:11.240 --> 00:18:13.600
And I'm now going to describe
something that we're working on.

00:18:13.600 --> 00:18:15.940
And so if when you read it in
the release notes of a later seed

00:18:15.940 --> 00:18:18.640
and it doesn't look like this,
well, you know, don't blame me.

00:18:18.640 --> 00:18:20.600
I'm trying to give you
the early idea of it.

00:18:20.600 --> 00:18:21.050
But who knows?

00:18:21.160 --> 00:18:22.800
We may still tweak it.

00:18:22.930 --> 00:18:26.320
But the point of this API is that you
can call it for each data class and

00:18:26.320 --> 00:18:28.550
get your individual application status.

00:18:28.730 --> 00:18:31.100
So you could say, okay,
does my application

00:18:31.100 --> 00:18:32.700
have access to contacts?

00:18:32.790 --> 00:18:34.350
And you might think that's
a yes or no question,

00:18:34.360 --> 00:18:36.830
but as we're designing it,
this API will probably have

00:18:36.830 --> 00:18:38.490
four different return values.

00:18:38.600 --> 00:18:40.260
The first one is not determined.

00:18:40.410 --> 00:18:43.770
That means your application has
never requested access to contacts,

00:18:43.940 --> 00:18:46.360
so we literally have no
idea what the state is.

00:18:46.400 --> 00:18:48.160
It's simply indeterminate.

00:18:48.270 --> 00:18:50.300
The next two, more straightforward.

00:18:50.370 --> 00:18:52.260
If you've requested
permission and been given it,

00:18:52.360 --> 00:18:56.400
then you've got granted -- you've been
granted permission to the data class,

00:18:56.400 --> 00:18:57.400
and we'll return that.

00:18:57.560 --> 00:19:00.500
Or if you requested permission
and the user said don't allow,

00:19:00.500 --> 00:19:02.770
then we'll say, no, you've been denied.

00:19:02.850 --> 00:19:05.190
But then that last one, restricted.

00:19:05.300 --> 00:19:08.690
So we've also enhanced restrictions,
kind of the parental controls

00:19:08.700 --> 00:19:12.100
or things that enterprises
can do with managed devices,

00:19:12.170 --> 00:19:15.520
to also include each of these
data classes and whether or

00:19:15.520 --> 00:19:19.970
not the user is allowed to even
answer that permission question.

00:19:20.150 --> 00:19:24.030
So in the case where, say,
access to contacts has actually

00:19:24.030 --> 00:19:26.440
been disallowed from you and
that's done by restrictions,

00:19:26.500 --> 00:19:31.200
this means that your user may not even
be able to make that choice to allow

00:19:31.200 --> 00:19:33.290
your application access to contacts.

00:19:33.350 --> 00:19:36.800
And so we're proposing this fourth
return value to allow you to tailor

00:19:36.800 --> 00:19:40.300
your user experience to the cases
where your user may not have control

00:19:40.300 --> 00:19:43.900
and therefore not be able to give
your application access to the data.

00:19:43.970 --> 00:19:48.920
So four return values: don't know,
yes/no, and then no, but the user may not

00:19:48.920 --> 00:19:50.120
be able to change it.

00:19:50.320 --> 00:19:52.750
From your application's perspective,
denied and restricted will

00:19:52.750 --> 00:19:57.200
look the same in that you don't
have access to that data class.

00:19:57.980 --> 00:19:59.900
So I talked about the classes
that we're adding to iOS.

00:19:59.900 --> 00:20:02.600
It's contacts, calendars, reminders,
and photos.

00:20:02.600 --> 00:20:07.070
Let me go through each of those now,
starting on the iOS side with contacts.

00:20:07.270 --> 00:20:11.190
So in iOS, it's access to the A/B address
book ref that's managed.

00:20:11.200 --> 00:20:13.260
That's where the permission
check will happen.

00:20:13.380 --> 00:20:15.380
So you know this method,
A/B address book create.

00:20:15.590 --> 00:20:18.900
Well, we've actually deprecated in iOS 6,
and so we have a new method,

00:20:18.900 --> 00:20:21.170
A/B address book create with options.

00:20:21.280 --> 00:20:23.960
The options parameter is
reserved for future use,

00:20:24.000 --> 00:20:26.980
and that pointer to the CFError is
something that can tell you

00:20:27.240 --> 00:20:28.800
if you've been denied access.

00:20:28.890 --> 00:20:31.960
So that'll actually be set to
a value if your application

00:20:32.070 --> 00:20:34.240
is denied access to contacts.

00:20:34.420 --> 00:20:36.900
Now, of course, deprecated APIs,
you should move off of them,

00:20:36.900 --> 00:20:40.000
and so you should move on to the new one,
but I do want to be really clear that

00:20:40.000 --> 00:20:43.000
even if you call the deprecated API,
the permission check

00:20:43.000 --> 00:20:44.360
occurs there as well.

00:20:44.460 --> 00:20:47.400
So permission happens no matter
which one of these you call,

00:20:47.490 --> 00:20:50.300
but that second one gives you a little
bit of additional information in the

00:20:50.300 --> 00:20:53.060
case where you've been denied access.

00:20:53.920 --> 00:20:57.400
Initially, first time your app runs,
it will be in that not determined state.

00:20:57.400 --> 00:21:00.980
And what this means concretely is that
AB Address Book Create With Options will

00:21:00.980 --> 00:21:02.550
hand back to you,
kind of in that immediate

00:21:02.550 --> 00:21:04.580
synchronous way,
it will give you back an

00:21:04.690 --> 00:21:06.300
empty read-only object.

00:21:06.390 --> 00:21:10.140
What you should then do is register
that address book instance you got with

00:21:10.220 --> 00:21:14.480
a callback method by calling AB Address
Book Register External Change Callback.

00:21:14.830 --> 00:21:16.790
You pass in your callback function.

00:21:16.860 --> 00:21:20.640
And then when your callback gets called,
you should call AB Address Book Revert.

00:21:20.960 --> 00:21:23.340
And what that does is it takes
the AB Address Book Ref that

00:21:23.370 --> 00:21:26.030
you got initially and makes
sure that it's in sync,

00:21:26.170 --> 00:21:28.740
which in the case of a permissions
check means that you go from an

00:21:28.840 --> 00:21:32.370
empty read-only object to one with,
you know, 500 contacts suddenly in it,

00:21:32.370 --> 00:21:34.600
because it's as though the
entire address book was just

00:21:34.600 --> 00:21:37.000
synced into your copy of it.

00:21:37.080 --> 00:21:40.430
And so you'll want to definitely
sync up the address book

00:21:40.430 --> 00:21:43.910
reference that you got initially,
because that's how you'll

00:21:43.910 --> 00:21:46.730
really get access to the data
after the user has said yes.

00:21:46.900 --> 00:21:50.310
otherwise you're just holding
on to a stale instance.

00:21:50.800 --> 00:29:00.100
[Transcript missing]

00:29:00.480 --> 00:29:03.940
If you change the checkbox to
say whether or not you want the

00:29:03.940 --> 00:29:07.410
application to have access to it,
then you can choose -- then the

00:29:07.440 --> 00:29:10.830
user gets to choose whether to
quit the application or not.

00:29:12.140 --> 00:29:16.360
: On iOS,
inside settings at the top level,

00:29:16.360 --> 00:29:17.620
we have a new top-level
privacy item there.

00:29:17.630 --> 00:29:19.600
You can see it with the hand icon.

00:29:19.620 --> 00:29:21.850
And if you tap into that,
there are the five different data

00:29:21.850 --> 00:29:23.600
classes that I've been talking about.

00:29:23.600 --> 00:29:25.600
And then I show you
photos there on the right.

00:29:25.600 --> 00:29:28.600
And note that text at the top
that's shown to users inside

00:29:28.600 --> 00:29:31.210
the photos privacy area,
that photos stored on your phone

00:29:31.210 --> 00:29:33.420
may contain other information,
such as when and where

00:29:33.710 --> 00:29:34.760
the photo was taken.

00:29:34.880 --> 00:29:37.010
And that's present there
to remind the users,

00:29:37.080 --> 00:29:40.000
just as I reminded you, that photos,
along with their metadata,

00:29:40.000 --> 00:29:43.500
are given to applications to which the
user's given their permission here.

00:29:43.560 --> 00:29:46.000
So we also -- I talked about how
restrictions have been updated.

00:29:46.000 --> 00:29:48.930
So if you go into restrictions
inside of settings on iOS,

00:29:48.930 --> 00:29:52.500
then there's a new privacy section
where those same data classes are shown.

00:29:52.500 --> 00:29:55.680
And if you tap into one of them,
you see at the top "allow changes" and

00:29:55.680 --> 00:29:59.650
"don't allow changes." And this is where,
through parental controls or through

00:29:59.650 --> 00:30:03.440
device management in an enterprise,
someone can choose both whether or not

00:30:03.440 --> 00:30:07.070
the individual applications should have
access and then also whether or not

00:30:07.070 --> 00:30:11.160
the user of that device is allowed to
change or respond to new access requests

00:30:11.160 --> 00:30:13.260
from new applications on the device.

00:30:13.500 --> 00:30:16.940
So this is how restrictions
plays into the data isolation.

00:30:17.010 --> 00:30:20.970
So let me now just broaden it and
talk not about particular changes

00:30:21.020 --> 00:30:24.030
we've made to our platforms,
but instead go through some comments on

00:30:24.030 --> 00:30:28.220
best practices that you can apply when
you're doing data collection or doing

00:30:28.240 --> 00:30:30.280
things that may impact users' privacy.

00:30:30.600 --> 00:30:33.000
And most of you are probably
client-side developers,

00:30:33.000 --> 00:30:36.600
but a lot of what I'm saying also
applies as part of business decisions

00:30:36.600 --> 00:30:38.360
and to server programmers as well.

00:30:38.450 --> 00:30:40.600
I think you'll see as
I go through the examples.

00:30:40.600 --> 00:30:41.830
I'm going to cover three areas.

00:30:42.090 --> 00:30:44.900
First is transparency and
talk about user control,

00:30:44.930 --> 00:30:49.100
and then data collection techniques that
you can use to best respect privacy.

00:30:49.100 --> 00:30:52.700
So starting with transparency,
privacy policy or statement.

00:30:52.700 --> 00:30:53.890
These things are really good.

00:30:53.920 --> 00:30:55.900
It's important for your
company to have one,

00:30:56.050 --> 00:30:59.930
and in fact, there's a new feature now in
iTunes Connect that you can submit

00:30:59.990 --> 00:31:03.700
a link to your privacy policy or
your privacy statement to Apple.

00:31:03.860 --> 00:31:07.600
And in a future release,
an upcoming release of the App Store,

00:31:07.600 --> 00:31:11.020
the page for your application
will display that link so that a

00:31:11.020 --> 00:31:14.590
user is able to view your privacy
policy before ever even downloading

00:31:14.590 --> 00:31:16.400
or purchasing your application.

00:31:16.510 --> 00:31:18.400
So this is a feature
coming to the App Store,

00:31:18.470 --> 00:31:22.300
but you can start submitting your privacy
statements now through iTunes Connect,

00:31:22.400 --> 00:31:25.800
and then they will become visible
to users in that App Store update.

00:31:25.830 --> 00:31:27.600
So this is a very good thing to do.

00:31:27.650 --> 00:31:31.100
But even after explaining to the user up
front how you're going to collect data,

00:31:31.100 --> 00:31:33.600
how you're going to use data,
if possible,

00:31:33.600 --> 00:31:36.980
it's important to give the user
opportunities to inspect precisely what

00:31:37.110 --> 00:31:39.800
your application is providing about them.

00:31:39.800 --> 00:31:42.490
So if you can provide UI inside
your application or a method on the

00:31:42.530 --> 00:31:44.760
website for the user to inspect that,
again,

00:31:44.760 --> 00:31:47.800
it just goes to open yourselves up,
show more transparency,

00:31:47.830 --> 00:31:51.800
and have the users be better
informed about the data collection.

00:31:51.860 --> 00:31:54.270
Now,
you can be as transparent as you want,

00:31:54.460 --> 00:31:56.630
but it's also important
that you give users control.

00:31:56.800 --> 00:31:59.540
And so part of that is asking permission,
and really asking

00:31:59.560 --> 00:32:00.790
permission with context.

00:32:00.800 --> 00:32:04.800
So I went through the purpose strings for
the iOS and the OS X permissions dialogs.

00:32:04.800 --> 00:32:06.000
Those are part of it.

00:32:06.000 --> 00:32:08.980
It's also important,
and this is more under your control,

00:32:09.170 --> 00:32:11.880
to ask when you need access to the data.

00:32:12.080 --> 00:32:15.860
So it's a bad situation in many ways
to just ask for everything up front

00:32:16.030 --> 00:32:17.500
when your application launches.

00:32:17.500 --> 00:32:19.500
Number one,
it's not a great user experience.

00:32:19.500 --> 00:32:23.000
User just bought your application,
launches it, gets a bunch of alerts.

00:32:23.140 --> 00:32:25.840
But from a performance perspective,
if you're not needing access

00:32:25.840 --> 00:32:27.500
to the data right then,
remember,

00:32:27.510 --> 00:32:30.850
we're only requesting permission
when you're instantiating one of

00:32:30.850 --> 00:32:32.880
these objects to access the data.

00:32:33.000 --> 00:32:36.230
So if you don't need access to the data,
that actually means you're instantiating

00:32:36.280 --> 00:32:39.150
objects you don't need to use right then,
and that's slowing down

00:32:39.150 --> 00:32:40.200
your application launch.

00:32:40.290 --> 00:32:42.230
So it has a performance impact.

00:32:42.510 --> 00:32:44.690
It's better if you ask
just before you need it.

00:32:44.730 --> 00:32:47.280
Maybe the user taps a button that says,
"Oh, I want to upload a photo or

00:32:47.300 --> 00:32:48.900
something," and then you say,
"Oh, well,

00:32:48.900 --> 00:32:52.040
let me go get access to the photos
database." A user's more likely

00:32:52.040 --> 00:32:55.710
to understand why your application
needs access to that data,

00:32:55.710 --> 00:32:58.640
not only if there's a purpose
string in the permissions dialog,

00:32:58.800 --> 00:33:02.940
but also if they have an idea that
the action that they just took

00:33:03.240 --> 00:33:05.900
is the one that's causing your
application to request that access.

00:33:05.900 --> 00:33:08.440
If they can connect these
two actions in their mind,

00:33:08.710 --> 00:33:12.100
they're more likely to understand
the context of your request.

00:33:12.260 --> 00:33:14.390
And then lastly,
even if you've given them that

00:33:14.390 --> 00:33:16.850
initial choice of yes or no,
it's also important to give

00:33:16.850 --> 00:33:17.900
them control thereafter.

00:33:17.900 --> 00:33:20.300
Maybe they changed their mind,
and it could go either way, right?

00:33:20.300 --> 00:33:22.960
They could have said no initially,
done some additional research,

00:33:23.020 --> 00:33:25.800
decided that they really do want
to give your application access,

00:33:25.900 --> 00:33:29.000
or they want to turn it off,
maybe even temporarily for some reason.

00:33:29.000 --> 00:33:31.400
And so allowing the user to
remake that choice over time is

00:33:31.490 --> 00:33:35.180
another way to increase their
control over their privacy.

00:33:35.310 --> 00:33:37.200
And I'm just going to
keep on beating home.

00:33:37.200 --> 00:33:40.240
Fail gracefully,
because your application should try to

00:33:40.240 --> 00:33:43.550
provide the best experience in light of
the control that you give in the user.

00:33:43.710 --> 00:33:45.800
So in terms of data
collection techniques,

00:33:45.840 --> 00:33:48.980
I really believe it's true that all
collection efforts reduce privacy.

00:33:49.100 --> 00:33:51.690
If you're getting data,
that's impacting the user's privacy.

00:33:51.820 --> 00:33:54.800
That doesn't mean that the data
collection is necessarily bad or

00:33:54.800 --> 00:33:58.500
wrong or anything of that nature,
but you do have to think hard about the

00:33:58.500 --> 00:34:02.140
negative that's coming from the data
collection and make sure that that's

00:34:02.140 --> 00:34:05.800
outweighed by the positive in terms of
how you're improving your application,

00:34:05.950 --> 00:34:09.380
providing a better experience to the
user or a more tailored experience to

00:34:09.410 --> 00:34:13.300
the user so that the positives outweigh
the negatives from the data collection.

00:34:13.340 --> 00:34:15.700
And as I mentioned,
I think that's true both on

00:34:15.700 --> 00:34:17.160
the app and the server side.

00:34:17.330 --> 00:34:20.290
And as you collect data from users,
it's important to remember that

00:34:20.400 --> 00:34:22.280
holding on to rich data has risks.

00:34:22.300 --> 00:34:24.140
I think you guys read tech news.

00:34:24.210 --> 00:34:27.550
You've probably seen in the past couple
weeks a number of passwords being leaked.

00:34:27.710 --> 00:34:29.860
We've seen other data
breaches in the past.

00:34:29.940 --> 00:34:33.040
And if you have that data,
then an attacker might be able

00:34:33.040 --> 00:34:34.700
to get access to that data.

00:34:34.700 --> 00:34:38.370
And wouldn't it be just really
annoying for you and sad for your

00:34:38.430 --> 00:34:42.160
company's brand if an attacker
ferreted out data that you were holding

00:34:42.160 --> 00:34:43.580
on to that you didn't even need?

00:34:43.710 --> 00:34:46.460
So trying to reduce the data down
to just what you need to provide

00:34:46.470 --> 00:34:50.990
your products or services reduces
the risk to your company as well.

00:34:51.040 --> 00:34:54.500
So let me go through some techniques
that you can keep in mind.

00:34:54.500 --> 00:34:55.780
You're never going to use all of these.

00:34:55.820 --> 00:34:57.700
They're never each
appropriate all the time,

00:34:57.700 --> 00:35:02.020
but six different ways that you can
think about how to reduce the data that

00:35:02.020 --> 00:35:06.300
you're collecting while still satisfying
your business or your engineering goals.

00:35:06.330 --> 00:35:07.590
So I'll go through each
one of these in turn,

00:35:07.820 --> 00:35:10.220
starting with anonymization.

00:35:10.380 --> 00:35:10.900
So I'm going to use logline.

00:35:10.900 --> 00:35:13.400
So let's start with this first logline.

00:35:13.400 --> 00:35:15.480
And you can see it's something
that could be in a server log.

00:35:15.530 --> 00:35:16.800
It could be in syslog on the device.

00:35:16.900 --> 00:35:19.890
It could just be something you're
writing down and submitting to some

00:35:19.950 --> 00:35:22.700
back-end analytics of your application.

00:35:22.740 --> 00:35:25.000
But in this case, it says error,
and there's an illegal token,

00:35:25.000 --> 00:35:26.200
and then a whole path, right?

00:35:26.210 --> 00:35:30.460
And paths are very interesting or
scary things because if something's

00:35:30.460 --> 00:35:32.980
in the user's home directory,
well, the home directory is named

00:35:33.070 --> 00:35:35.680
with the user account name,
and a lot of Mac users,

00:35:35.790 --> 00:35:37.090
that's exactly their name.

00:35:37.160 --> 00:35:40.600
So here we've collected the fact
that this user is John Appleseed.

00:35:40.660 --> 00:35:43.020
And in addition to that,
we know a couple other interesting

00:35:43.020 --> 00:35:44.130
things out of this logline.

00:35:44.380 --> 00:35:46.130
We know that there's
some Project Zanzibar,

00:35:46.140 --> 00:35:48.740
whatever that is,
and that there's probably something

00:35:48.740 --> 00:35:50.670
going on in fiscal year 2013.

00:35:50.810 --> 00:35:54.480
All of this when we were really
perhaps focused on this illegal token.

00:35:54.630 --> 00:35:57.400
So we could do better and
not collect that whole path.

00:35:57.760 --> 00:36:00.570
Maybe you do want to know the files
that are causing illegal tokens.

00:36:00.630 --> 00:36:02.700
Okay, so we could log this instead.

00:36:02.790 --> 00:36:05.220
And this is clearly better
because we're not collecting all

00:36:05.220 --> 00:36:09.100
this ancillary data that wasn't
related to the actual document.

00:36:09.230 --> 00:36:10.300
But we still have a file name.

00:36:10.300 --> 00:36:13.260
That file name could be named
Project Zanzibar fiscal 13,

00:36:13.260 --> 00:36:13.800
right?

00:36:13.800 --> 00:36:16.000
There's still a lot of information there.

00:36:16.110 --> 00:36:19.660
And so if you're really maybe focused
on when these illegal tokens occur,

00:36:19.900 --> 00:36:21.700
you might want to just
step back and think,

00:36:21.740 --> 00:36:23.260
I want to know what the
type of the file is.

00:36:23.340 --> 00:36:25.880
I don't care about the file name at all,
but I do want to know that it was

00:36:25.880 --> 00:36:27.500
a keynote file that had this token.

00:36:27.500 --> 00:36:30.200
That maybe tells me where
I need to go test more.

00:36:30.310 --> 00:36:33.700
And so this would even further reduce and
make sure that there's no user-specific

00:36:33.730 --> 00:36:37.990
string there in the way of the path or
of the file name that you're collecting,

00:36:38.190 --> 00:36:39.960
just the type.

00:36:41.280 --> 00:36:44.830
Let's think about aggregation and now
take that same log line but realize that

00:36:44.830 --> 00:36:46.880
it's registering a particular event.

00:36:46.950 --> 00:36:49.250
It might even have a
timestamp associated with it,

00:36:49.350 --> 00:36:52.700
but it's a particular time and
instance where that token was seen.

00:36:52.800 --> 00:36:54.430
And maybe this isn't
important to you either.

00:36:54.430 --> 00:36:56.880
If we think back to the fact
maybe all you cared about was

00:36:56.880 --> 00:37:00.190
that it was a keynote file,
maybe what you really care about is the

00:37:00.280 --> 00:37:02.560
frequency at which these are occurring.

00:37:02.770 --> 00:37:05.970
So you might just log over the
lifetime of your application

00:37:05.970 --> 00:37:07.550
or once a day or once an hour.

00:37:07.830 --> 00:37:10.770
You might just write down the number
of times you've seen an illegal

00:37:10.830 --> 00:37:12.700
token in each different file type.

00:37:12.700 --> 00:37:15.700
So here we have it occurring
21 times in a keynote file,

00:37:15.700 --> 00:37:18.700
three times in some other kind of file,
and this would point you to the

00:37:18.700 --> 00:37:21.850
fact that the keynote files are
a much more interesting area to

00:37:21.850 --> 00:37:23.700
investigate than this other file type.

00:37:23.700 --> 00:37:26.630
And in this log line,
you haven't logged anything

00:37:26.710 --> 00:37:28.700
precisely about a single event.

00:37:28.700 --> 00:37:32.700
It's just a record of a set of events
that occurred over a period of time.

00:37:32.700 --> 00:37:35.610
So you're getting much less data
about the usage pattern while still

00:37:35.610 --> 00:37:38.690
getting all the data about the
occurrence of these illegal tokens.

00:37:38.700 --> 00:37:40.690
That's aggregation.

00:37:42.130 --> 00:37:44.610
You can also think in terms of sampling,
statistical sampling.

00:37:44.770 --> 00:37:47.500
So if we consider this
again as a particular event,

00:37:47.610 --> 00:37:51.090
you can ask yourself, well,
do I need each and every event

00:37:51.380 --> 00:37:54.240
from every single user who's
opted into my collection?

00:37:54.290 --> 00:37:55.130
And maybe you don't.

00:37:55.280 --> 00:37:58.110
Maybe you could say, well,
I could actually sample from just

00:37:58.110 --> 00:38:01.840
one in ten or one in 100 or one
in 1,000 of the user's computers.

00:38:01.890 --> 00:38:03.760
And if it's a statistically
random sample,

00:38:03.760 --> 00:38:05.920
it will be representative
of your population,

00:38:05.980 --> 00:38:08.660
and you'll get overall the same
distribution and same shape of the

00:38:08.660 --> 00:38:13.480
events without actually gathering data
from the vast majority of your users.

00:38:13.520 --> 00:38:14.790
So you've improved privacy.

00:38:14.810 --> 00:38:17.750
You know,
90% or more of your users aren't going

00:38:17.750 --> 00:38:20.100
to have any data collected from them.

00:38:20.200 --> 00:38:21.850
But if you think about
it a little harder,

00:38:21.850 --> 00:38:25.480
you're still collecting complete
pictures of those individual users.

00:38:25.580 --> 00:38:27.430
So if you really only
care about the events,

00:38:27.510 --> 00:38:31.070
you could go one step further and instead
sample on the basis of an operation.

00:38:31.110 --> 00:38:35.150
So you just roll that random die each
time you're parsing a file in this case,

00:38:35.250 --> 00:38:39.300
and if you get one in ten or
one in 100 or 1,000 operations,

00:38:39.300 --> 00:38:41.330
then you choose to log it then.

00:38:41.460 --> 00:38:45.190
You're getting the same quantity of data,
but you're no longer collecting a

00:38:45.190 --> 00:38:47.050
complete picture of any of your users.

00:38:47.080 --> 00:38:50.910
And so this is even better from a
privacy perspective than sampling

00:38:51.030 --> 00:38:53.230
on a per-user or per-device basis.

00:38:54.380 --> 00:38:56.390
Let's take a different log line
now and I want to talk about

00:38:56.460 --> 00:38:58.130
derezzing or de-resolving the data.

00:38:58.400 --> 00:38:59.300
So here's a log line.

00:38:59.300 --> 00:39:02.020
Maybe you might see this one
on a server on a client that,

00:39:02.060 --> 00:39:04.100
you know,
some action succeeded at that particular

00:39:04.210 --> 00:39:08.280
time and precise number there,
22,341 bytes were sent.

00:39:08.300 --> 00:39:11.290
And this looks like a pretty
anonymous log message.

00:39:11.340 --> 00:39:13.290
It doesn't have that same sort
of path information in it.

00:39:13.300 --> 00:39:15.350
But especially with
that precise byte count,

00:39:15.350 --> 00:39:17.880
and let's say that this was a
client message and there's a

00:39:17.880 --> 00:39:21.290
corresponding server message,
between that time stamp and the bytes,

00:39:21.290 --> 00:39:24.430
you might be able to start to
recombine those two logs that

00:39:24.430 --> 00:39:28.370
you thought were independent
because you can see that at 3:03,

00:39:28.450 --> 00:39:31.360
22,341 bytes were sent.

00:39:31.390 --> 00:39:32.300
And that would enable
you to re-correlate it.

00:39:32.370 --> 00:39:34.230
It's a very precise sort of action.

00:39:34.300 --> 00:39:36.850
And maybe you don't need this
level of precision in either

00:39:36.860 --> 00:39:38.300
of those two dimensions.

00:39:38.300 --> 00:39:40.700
So you might instead say, well,
we're really just doing

00:39:40.700 --> 00:39:43.300
this for load testing and,
you know, planning for scale.

00:39:43.300 --> 00:39:45.760
So I want to know the hour
of the day when this event

00:39:45.760 --> 00:39:48.300
occurred and I want to know,
you know, to the kilobyte,

00:39:48.300 --> 00:39:48.300
what data was sent.

00:39:49.300 --> 00:39:55.390
But now if it was 22,341 or 22,342,
those would look the same in terms

00:39:55.390 --> 00:39:57.980
of the number of kilobytes because
you've backed off the resolution

00:39:57.980 --> 00:39:59.300
that you're logging that at.

00:39:59.300 --> 00:40:02.150
And you should think about what
business or engineering decision is

00:40:02.190 --> 00:40:05.290
driving your collection and maybe you
can again go even further and say,

00:40:05.300 --> 00:40:07.300
well,
I don't need to know it was May 4th.

00:40:07.300 --> 00:40:10.300
I just want to know what my
heavy day of the week is.

00:40:10.300 --> 00:40:12.300
And actually, I don't need to know it
to the nearest kilobyte.

00:40:12.300 --> 00:40:14.280
I can do it to the nearest 10 kilobytes.

00:40:14.300 --> 00:40:17.470
Some simple math as you're writing
out that log line can really reduce

00:40:17.470 --> 00:40:21.260
the resolution and therefore the
amount of privacy that's impacted

00:40:21.260 --> 00:40:23.300
by logging this kind of message.

00:40:23.300 --> 00:40:26.300
So you can de-resolve
virtually any precise thing,

00:40:26.300 --> 00:40:31.300
a duration, a time stamp, a size,
any of those sorts of things.

00:40:33.350 --> 00:40:35.940
Maybe it is the case, though,
that you do need this level of

00:40:35.940 --> 00:40:38.990
precision in your log message,
that what you're actually doing is, say,

00:40:39.040 --> 00:40:42.300
something to track abuse
or an anti-fraud mechanism.

00:40:42.300 --> 00:40:44.300
You say, "No, no, no,
it's absolutely critical, actually,

00:40:44.300 --> 00:40:46.290
that I know the precise number
of bytes that were sent."

00:40:46.340 --> 00:40:50.240
And that may be true initially,
but you can also step back and think,

00:40:50.310 --> 00:40:54.560
"Well, how long does that initial purpose
last for?" A couple days later,

00:40:54.560 --> 00:40:58.300
do I really care about the precise
time that something happened?

00:40:58.320 --> 00:41:02.290
Because then I was already under
a denial of service attack or not.

00:41:02.300 --> 00:41:03.300
It's past.

00:41:03.300 --> 00:41:06.300
And so maybe you can go through
and reprocess your logs,

00:41:06.300 --> 00:41:08.300
say, after a week, and say,
"I don't need that

00:41:08.300 --> 00:41:09.300
exact timestamp anymore.

00:41:09.300 --> 00:41:12.170
I don't still have that need,
that purpose to hold on to

00:41:12.170 --> 00:41:15.300
the timestamp." And then
you can keep on doing this.

00:41:15.300 --> 00:41:18.290
So maybe after 30 days, you say, "Well,
the time doesn't matter at all now.

00:41:18.300 --> 00:41:21.300
And in fact, whatever I was using the
individual bytes for,

00:41:21.300 --> 00:41:24.360
now I don't need that either,
so I can back it off to the nearest

00:41:24.360 --> 00:41:27.300
kilobyte." And this is something that you
have the opportunity to do on any device.

00:41:27.300 --> 00:41:28.940
You have the opportunity
to do on any timescale,

00:41:28.940 --> 00:41:29.300
right?

00:41:29.300 --> 00:41:33.160
After six months, after two years,
you can continue to reduce the amount

00:41:33.540 --> 00:41:38.290
that's held in each of these log files or
each of these kind of data collections.

00:41:38.360 --> 00:41:42.300
And lastly, let's consider this log
message one more time.

00:41:42.300 --> 00:41:44.920
And this time, notice that it's an
info-level message that says,

00:41:44.920 --> 00:41:46.270
"Action succeeded," right?

00:41:46.300 --> 00:41:48.300
It's not actually even
talking about an error.

00:41:48.300 --> 00:41:51.300
And so you should ask yourself, "Well,
why am I collecting this?"

00:41:51.300 --> 00:41:53.250
And you may well have an answer.

00:41:53.300 --> 00:41:56.300
But if you can't answer to yourself
what purpose you have this data for,

00:41:56.300 --> 00:41:59.300
then maybe it's better
just not to log it at all.

00:41:59.330 --> 00:42:02.300
If you can't justify yourself why
you're holding onto this data,

00:42:02.300 --> 00:42:03.300
it presents risk to you.

00:42:03.300 --> 00:42:06.430
And the best thing you can do
for yourself and your users is

00:42:06.450 --> 00:42:08.300
simply not to collect the data.

00:42:08.300 --> 00:42:10.820
I put this one last so you
didn't just write me off as

00:42:10.820 --> 00:42:12.300
a privacy nut on slide one.

00:42:12.300 --> 00:42:15.300
But a lot of times, you can really just
not collect it at all,

00:42:15.300 --> 00:42:19.300
and that's the very best thing that
you can do from a privacy perspective.

00:42:21.040 --> 00:42:22.810
So I've covered these
six different techniques.

00:42:22.810 --> 00:42:24.750
And like I said,
you're never going to use all of them.

00:42:24.760 --> 00:42:27.540
But as you look at a piece of
data that you're collecting,

00:42:27.610 --> 00:42:30.530
you should always reflect back on what
the business or engineering decision is

00:42:30.630 --> 00:42:32.080
that's driving you to collect the data.

00:42:32.380 --> 00:42:35.780
And insofar as possible,
use one of these techniques or something

00:42:35.960 --> 00:42:39.920
similar to reduce the impact on privacy
while still bringing the benefits that

00:42:39.920 --> 00:42:42.240
you're trying to bring for your users.

00:42:42.560 --> 00:42:45.360
I covered a whole bunch of
very different things together,

00:42:45.470 --> 00:42:48.790
so I wanted to put the headline bullets
together for you on one slide at the end.

00:42:49.010 --> 00:42:51.820
First one,
discontinue the use of the UDID API and

00:42:51.820 --> 00:42:53.090
you should adopt the replacements.

00:42:53.310 --> 00:42:54.370
Pretty simple.

00:42:54.550 --> 00:42:59.030
You want to take these new data
isolation classes on both OS X and iOS

00:42:59.170 --> 00:43:00.500
and make sure that you're testing them.

00:43:00.500 --> 00:43:03.500
And one more time,
fail gracefully if the user says no.

00:43:03.500 --> 00:43:05.120
Give them a good experience.

00:43:05.270 --> 00:43:08.670
We have support for purpose
strings inside of those consent

00:43:08.740 --> 00:43:12.900
or those permission dialogs,
so add those to your info P list.

00:43:13.010 --> 00:43:15.900
Go ahead and submit a privacy
statement to the App Store now.

00:43:15.900 --> 00:43:18.900
It'll be displayed when
we update the App Store.

00:43:18.900 --> 00:43:21.630
And lastly, as far as data collection,
make sure users know what you're

00:43:21.690 --> 00:43:23.400
collecting and have some control over it.

00:43:23.590 --> 00:43:27.400
And lastly,
collect only what data you need.

00:43:27.570 --> 00:43:29.160
And that's it, so thank you very much.
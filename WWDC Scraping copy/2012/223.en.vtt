WEBVTT

00:00:02.050 --> 00:00:03.660
Good afternoon, everybody.

00:00:03.730 --> 00:00:13.110
And-- Thanks for coming back to
another session about UI Scroll View.

00:00:13.360 --> 00:00:15.600
For those of you that have
come in previous years,

00:00:15.680 --> 00:00:16.730
welcome back.

00:00:16.800 --> 00:00:18.840
And for those of you
that are new this year,

00:00:18.840 --> 00:00:20.300
thanks for coming.

00:00:20.300 --> 00:00:23.000
We've got some very cool things
to talk about today again,

00:00:23.040 --> 00:00:24.390
I hope.

00:00:24.480 --> 00:00:30.700
And if you've seen the previous sessions,
either in 2009, 2010, 2011,

00:00:30.700 --> 00:00:34.180
you're probably familiar with how we're
going to begin the presentation today.

00:00:34.340 --> 00:00:36.000
But that's just going
to be a couple minutes,

00:00:36.090 --> 00:00:39.660
and then we'll get into a lot
of more interesting things.

00:00:39.780 --> 00:00:42.680
So first off,
we're going to start about just a

00:00:42.680 --> 00:00:46.010
little bit of review about how to
configure your UI Scroll View and

00:00:46.010 --> 00:00:48.260
how UI Scroll Views work,
just the basics.

00:00:48.380 --> 00:00:50.530
So we're all on the same page.

00:00:50.720 --> 00:00:52.940
Once we finish that,
we're actually going to look

00:00:52.940 --> 00:00:56.980
back at something that we
talked about at WWDC 2010,

00:00:57.010 --> 00:01:01.360
which is building a great photo browser
that feels just like the photo browser

00:01:01.360 --> 00:01:03.340
that you find in the Photos app on iOS.

00:01:03.340 --> 00:01:07.980
And the reason we want to review this
a little bit more today is because with

00:01:07.980 --> 00:01:12.900
the introduction of a scrolling mode
on UI Page View Controller in iOS 6,

00:01:12.900 --> 00:01:16.450
building this photo browser has
become significantly easier than it

00:01:16.450 --> 00:01:18.300
was when we last talked about it.

00:01:19.620 --> 00:01:22.270
After we get done with
that little bit of review,

00:01:22.270 --> 00:01:26.530
then we're going to talk about something
brand new that we've really never even

00:01:26.530 --> 00:01:28.700
talked about at all before at WWDC.

00:01:28.700 --> 00:01:31.510
And that's integrating
UI Scroll View into your

00:01:31.510 --> 00:01:33.590
OpenGL games and applications.

00:01:33.600 --> 00:01:36.630
So if you're sitting there thinking,
well, you know,

00:01:36.630 --> 00:01:39.980
I don't have an OpenGL game or an app,
so maybe I'm just going to

00:01:39.980 --> 00:01:41.570
get out when that comes up.

00:01:41.620 --> 00:01:44.130
Don't worry,
there's actually a lot of really

00:01:44.130 --> 00:01:48.320
important things that we're going to
discuss in the context of the OpenGL that

00:01:48.320 --> 00:01:49.600
are actually broadly applicable.

00:01:49.620 --> 00:01:55.600
So if you use UI Scroll View,
UI Table View, UI Text View, UI Web View,

00:01:55.650 --> 00:01:59.620
or even the new
UI Collection View in iOS 6,

00:01:59.620 --> 00:02:02.970
the kinds of things we're going to
talk about with run loop modes and

00:02:02.970 --> 00:02:06.460
touch delivery and responder chain,
they are true for all of those

00:02:06.470 --> 00:02:09.700
different kinds of UI Scroll Views
with or without OpenGL.

00:02:09.700 --> 00:02:11.250
So stick around.

00:02:11.260 --> 00:02:14.360
And then at the end, actually,
we're going to get into something

00:02:14.360 --> 00:02:17.030
that was new in iOS 5 last year,
but that we didn't have

00:02:17.030 --> 00:02:18.160
time to talk about.

00:02:18.640 --> 00:02:22.050
And that's controlling the stop offset
of your Scroll View after the user

00:02:22.050 --> 00:02:23.910
scrolls and it comes to decelerate.

00:02:24.100 --> 00:02:26.700
You know, when your user scrolls a
little bit and lifts their

00:02:26.700 --> 00:02:29.760
finger while it's still moving,
the Scroll View comes to rest.

00:02:29.780 --> 00:02:32.880
The Scroll View has
decided where it will land.

00:02:32.880 --> 00:02:35.590
And with a new delegate
method introduced in iOS 5,

00:02:35.600 --> 00:02:39.480
it actually tells you where that will
be before the deceleration starts.

00:02:39.480 --> 00:02:41.820
But even better is you
can adjust that offset,

00:02:41.820 --> 00:02:44.220
which lets you do some
interesting things.

00:02:44.220 --> 00:02:48.200
So let's get started with the
quick review of UI Scroll View.

00:02:48.640 --> 00:02:50.640
So let's talk about the
UI Scroll View configuration.

00:02:50.640 --> 00:02:53.640
So the basics of UI Scroll View,
obviously, are that you have more content

00:02:53.640 --> 00:02:56.180
than can fit on any one screen
and you want to allow your users

00:02:56.250 --> 00:02:57.640
to scroll around within it.

00:02:57.640 --> 00:03:00.440
And you do that by just setting
one property on the UI Scroll View,

00:03:00.440 --> 00:03:01.610
and that's your content size.

00:03:01.640 --> 00:03:04.550
And the content size is just the
width and height of your content.

00:03:04.640 --> 00:03:07.050
And when you set that property,
UI Scroll View knows exactly how

00:03:07.070 --> 00:03:08.640
much it can scroll in any direction.

00:03:08.640 --> 00:03:13.380
And it all just works with
just that one property set.

00:03:14.230 --> 00:03:17.220
But sometimes you need to know which
part of the content is currently

00:03:17.220 --> 00:03:20.590
visible programmatically during
the execution of your application.

00:03:20.700 --> 00:03:24.470
And the way that we refer to that in
UI Scroll View is as the content offset.

00:03:24.670 --> 00:03:28.410
The content offset is the point in your
content that's currently visible at the

00:03:28.460 --> 00:03:30.600
top left of the scroll view's frame.

00:03:30.770 --> 00:03:35.200
So in this case where we only
have vertically scrolling content,

00:03:35.200 --> 00:03:40.600
the distance from the top to the point
that was visible is your content offset.

00:03:40.770 --> 00:03:44.600
Now, scroll view supports scrolling,
but it also supports zooming.

00:03:44.600 --> 00:03:47.240
And to add zooming to your scroll view,
there's just two things that

00:03:47.300 --> 00:03:48.600
you have to add on top of that.

00:03:48.600 --> 00:03:51.190
First, you have to have the content
that you want to have zoomed as

00:03:51.190 --> 00:03:54.580
a subview of your UI Scroll View,
and return that from a delegate method

00:03:54.640 --> 00:03:56.600
called ViewForZoomingInScrollView.

00:03:56.600 --> 00:03:58.600
That's the first thing.

00:03:58.600 --> 00:04:00.150
The second thing is
to set two properties,

00:04:00.150 --> 00:04:03.150
the minimum and maximum zoom scale,
that tell the scroll view how

00:04:03.270 --> 00:04:06.600
much the content is allowed
to be zoomed either in or out.

00:04:06.600 --> 00:04:08.680
And with those two things done,
your users can pinch to zoom

00:04:08.680 --> 00:04:10.080
in and out on the content,
or you can program the scroll view

00:04:10.080 --> 00:04:10.600
to zoom in and out on the content.

00:04:10.600 --> 00:04:12.600
And you can also programmatically
control the zoom scale.

00:04:12.600 --> 00:04:14.590
So it's pretty easy.

00:04:14.600 --> 00:04:16.600
The basics are really simple.

00:04:16.600 --> 00:04:18.530
If you're not already familiar
with those things or if any of

00:04:18.550 --> 00:04:20.660
that is a little surprising,
I recommend that you watch some

00:04:20.770 --> 00:04:25.040
of the previous sessions from
earlier WWDCs or check out the

00:04:25.040 --> 00:04:26.600
documentation at developer.apple.com.

00:04:26.770 --> 00:04:28.580
There's a lot more
there about the basics,

00:04:28.600 --> 00:04:31.170
but today I just want to get into
some of the more interesting advanced

00:04:31.180 --> 00:04:32.600
topics that we want to talk about.

00:04:32.600 --> 00:04:36.140
So first, let's take a look back at
page scrolling and that photo

00:04:36.140 --> 00:04:38.600
browser that we built in 2010.

00:04:38.610 --> 00:04:39.600
If you've seen the 2010 session or
are interested in the 2010 session,

00:04:39.600 --> 00:04:39.600
you can go to the page scrolling page
and click on the page scrolling button.

00:04:39.600 --> 00:04:42.630
If you've seen the 2010 session or if
you've downloaded the photo scroller

00:04:42.630 --> 00:04:45.360
sample app from developer.apple.com,
then you're already familiar

00:04:45.360 --> 00:04:47.600
with the kind of thing we're
about to be talking about.

00:04:47.600 --> 00:04:50.130
But if you haven't seen it,
just a quick review of what

00:04:50.130 --> 00:04:51.380
we're talking about here.

00:04:51.600 --> 00:04:55.600
You want to build the photo browser
that feels just like the Photos app.

00:04:55.600 --> 00:04:58.140
Your users can scroll back
and forth between photos,

00:04:58.140 --> 00:05:00.370
zoom in on them,
and then scroll back from the

00:05:00.370 --> 00:05:02.480
zoomed-in photo to photos next to them.

00:05:02.600 --> 00:05:07.440
So just that exact same kind of photo
browsing experience that you see on iOS.

00:05:07.570 --> 00:05:10.500
If you've seen the sample
code or watched the session,

00:05:10.540 --> 00:05:12.510
then you're familiar with the
view hierarchy that we built

00:05:12.510 --> 00:05:13.750
in order to make this happen.

00:05:13.900 --> 00:05:15.500
It looks something like this.

00:05:15.670 --> 00:05:19.990
We had an outer paging UI scroll view
that was the base of our view hierarchy,

00:05:20.010 --> 00:05:23.500
and we used that for scrolling back
and forth between photos horizontally.

00:05:23.500 --> 00:05:28.470
Then each page, each individual photo,
had its own zooming UI scroll view.

00:05:28.500 --> 00:05:30.690
So we created one
UI scroll view per page,

00:05:30.690 --> 00:05:33.500
and that was what we used to
zoom in and out on the photos.

00:05:33.640 --> 00:05:37.190
And then the photos themselves were
each UI image views added as sub

00:05:37.190 --> 00:05:39.110
views to those UI scroll views.

00:05:39.310 --> 00:05:41.660
So we spent basically an
entire session talking about

00:05:41.660 --> 00:05:43.200
how you put all this together.

00:05:43.200 --> 00:05:45.200
And there was really,
there's quite a lot of code behind it.

00:05:45.320 --> 00:05:48.200
And if you've looked at the sample code,
you're probably familiar with that.

00:05:48.370 --> 00:05:52.130
So the great news with iOS
6 is that that bottom part,

00:05:52.130 --> 00:05:55.340
the paging UI scroll view,
if you're using UI page

00:05:55.340 --> 00:05:58.190
view controller instead,
that can go away entirely.

00:05:58.200 --> 00:06:01.380
UI page view controller takes
care of that entire part of

00:06:01.380 --> 00:06:03.190
this view hierarchy for us.

00:06:06.980 --> 00:06:09.690
So now we're left with a little bit less.

00:06:09.700 --> 00:06:11.510
We just have these two
separate collections of

00:06:11.520 --> 00:06:12.450
views that we have to build.

00:06:12.450 --> 00:06:16.780
But you can simplify this even further
now because UIPageViewController

00:06:16.810 --> 00:06:19.460
is a view controller,
and view controllers are really great

00:06:19.460 --> 00:06:21.380
for building screenfuls of content.

00:06:21.380 --> 00:06:24.720
And really, each one of these photos is
a whole screenful of content.

00:06:25.370 --> 00:06:29.040
So all we have to really think about now
is building a view controller that knows

00:06:29.040 --> 00:06:31.930
how to zoom and display a single photo,
rather than having to

00:06:31.930 --> 00:06:33.250
worry about all of them.

00:06:33.250 --> 00:06:36.600
And once we have a view controller
that can display one photo,

00:06:36.640 --> 00:06:38.770
we can just allocate many of
those and keep handing them

00:06:38.820 --> 00:06:41.200
to the UIPageViewController
to display as many as we want.

00:06:41.240 --> 00:06:44.100
So really all we have to do now
is think about building a single

00:06:44.100 --> 00:06:47.400
zooming UI scroll view that knows
how to zoom a single image view.

00:06:47.400 --> 00:06:50.580
So much simpler to conceptualize
and really work on than

00:06:50.580 --> 00:06:52.090
what we had in the past.

00:06:54.780 --> 00:06:57.510
The other thing that we spent a lot
of time talking about in 2010 and that

00:06:57.510 --> 00:07:00.970
there's actually quite a bit of code
devoted to in the photo scroller sample,

00:07:01.040 --> 00:07:04.090
and not just quite a bit of code,
but kind of slightly

00:07:04.220 --> 00:07:08.030
confusing and unclear code,
I guess, is putting extra space

00:07:08.030 --> 00:07:09.700
between those photos.

00:07:09.700 --> 00:07:12.400
It'd be really nice if they weren't
abutting each other like they

00:07:12.400 --> 00:07:14.740
are in this picture right now,
because these greens are

00:07:14.770 --> 00:07:16.070
just blending together.

00:07:16.080 --> 00:07:19.190
And it'd be nice if you had some
black space between them to just give

00:07:19.190 --> 00:07:22.560
the user a good sense of where one
photo ends and the next one begins.

00:07:22.900 --> 00:07:24.910
So we just like to space
them out just a little bit.

00:07:25.150 --> 00:07:27.620
And it really was, well,
let's say a little bit of a

00:07:27.620 --> 00:07:31.100
hack the way it was done in the
original photo scroller sample.

00:07:31.100 --> 00:07:33.590
So it's much cleaner now.

00:07:33.600 --> 00:07:36.070
And in fact,
with UI Page View Controller,

00:07:36.070 --> 00:07:39.880
not only is it almost no code,
but it's really just one property.

00:07:39.880 --> 00:07:42.430
So when you create a
UI Page View Controller,

00:07:42.630 --> 00:07:46.160
you use this new key,
UI Page View Controller Option Interpage

00:07:46.230 --> 00:07:47.160
Spacing Key.

00:07:47.160 --> 00:07:52.430
And it may still be hard
because you can't remember that.

00:07:52.900 --> 00:07:54.060
But that's what completion is for.

00:07:54.060 --> 00:07:58.440
And that will let you specify exactly how
much space you want between those photos.

00:07:58.440 --> 00:08:01.020
And really,
it's as easy as just passing one option

00:08:01.020 --> 00:08:03.240
when creating the Page View Controller.

00:08:03.240 --> 00:08:05.730
So that's how we're
going to configure it.

00:08:09.800 --> 00:08:13.450
Next, let's just take a quick look at how
the page view controller will ask

00:08:13.460 --> 00:08:16.320
for the photos so that we know how
things will behave once we have our

00:08:16.320 --> 00:08:18.080
single view controller configured.

00:08:18.080 --> 00:08:21.440
So let's put this into an iPhone.

00:08:21.440 --> 00:08:24.660
Now, let's assume that the user puts
their finger down on the screen and

00:08:24.660 --> 00:08:26.500
starts scrolling to the next photo.

00:08:26.500 --> 00:08:29.300
At that point,
UI page view controller will ask for

00:08:29.300 --> 00:08:33.980
the next photo using a delegate method,
view controller after view controller.

00:08:34.980 --> 00:08:37.710
And at that point,
you just allocate a new copy

00:08:37.710 --> 00:08:40.850
of that same type of UI view
controller that you created to

00:08:40.860 --> 00:08:42.320
display and zoom a single photo.

00:08:42.320 --> 00:08:45.420
Put your new photo in it and return
it to the page view controller.

00:08:45.420 --> 00:08:48.380
Page view controller deals with
deciding when it should be added to

00:08:48.390 --> 00:08:50.100
and removed from the view hierarchy.

00:08:50.100 --> 00:08:52.680
It makes sure that it doesn't live
longer than it should so that if you

00:08:52.750 --> 00:08:55.060
scroll through a whole bunch of pages,
you don't end up with

00:08:55.060 --> 00:08:56.270
unbounded memory growth.

00:08:56.340 --> 00:08:59.350
It takes care of all the details of when
the view should be added and removed,

00:08:59.350 --> 00:09:01.290
and you don't have to
worry about any of that.

00:09:01.420 --> 00:09:03.880
And that was actually a big part of
the code that we had to write before.

00:09:04.980 --> 00:09:07.020
And then similarly,
when we scroll in the other direction,

00:09:07.020 --> 00:09:10.680
we'll get another delegate method,
view controller before view controller.

00:09:10.680 --> 00:09:14.540
And we can just return a new instance
to represent the previous photo.

00:09:14.540 --> 00:09:16.400
So it's pretty simple.

00:09:16.400 --> 00:09:20.130
With those things done,
all that's really left to implement

00:09:20.130 --> 00:09:24.130
then is zooming in and out on
that single picture that we have.

00:09:24.180 --> 00:09:26.620
And with the introduction
of UI page view controller,

00:09:26.620 --> 00:09:28.480
this hasn't really changed too much.

00:09:28.480 --> 00:09:31.240
So we're not really going to get
into the specifics of how this works.

00:09:31.240 --> 00:09:34.700
If you're not really familiar with how
to set up a zooming UI scroll view,

00:09:34.980 --> 00:09:37.790
the sample code is still available,
and there's actually new sample code

00:09:37.800 --> 00:09:39.700
this year based on the new stuff.

00:09:39.700 --> 00:09:42.740
And you can go check that out,
but we're not going to get too

00:09:42.780 --> 00:09:44.160
much into the details right now.

00:09:44.160 --> 00:09:47.080
But UI page view controller,
once it's zoomed in,

00:09:47.140 --> 00:09:50.540
does handle scrolling back
out to photos next to the one

00:09:50.550 --> 00:09:51.660
that you were zoomed in on.

00:09:51.660 --> 00:09:55.020
So with that in mind,
Eliza is going to come up and do

00:09:55.020 --> 00:09:57.250
a demo of how we can build this.

00:10:04.500 --> 00:10:05.500
Hi, Eliza.

00:10:05.500 --> 00:10:08.310
I'm an engineer on the Passbook team now.

00:10:08.310 --> 00:10:12.830
And I'm going to show you the demo
or just the sample code that we

00:10:12.830 --> 00:10:14.340
had from the demo two years ago.

00:10:14.370 --> 00:10:15.840
I've added one new feature to it.

00:10:15.840 --> 00:10:19.790
So let me switch over here.

00:10:20.500 --> 00:15:20.000
[Transcript missing]

00:15:20.710 --> 00:15:22.710
All right, we're going to make a
UIViewController subclass,

00:15:22.710 --> 00:15:25.290
and I'm going to call it
ImageViewController because

00:15:25.290 --> 00:15:26.990
its job is to display an image.

00:15:29.200 --> 00:15:31.200
I'm going to add that to the project.

00:15:31.200 --> 00:15:34.200
I'm just going to move it up
here so I've got it handy.

00:15:34.200 --> 00:15:37.180
Okay, so what is this image view
controller going to do?

00:15:37.210 --> 00:15:39.200
Turns out it's going to do pretty little.

00:15:39.200 --> 00:15:40.120
It's going to be really easy to write.

00:15:40.320 --> 00:15:43.820
So the first thing that I'm going to
do is declare a couple methods that

00:15:43.900 --> 00:15:45.170
this class knows how to implement.

00:15:45.370 --> 00:15:48.200
The first is a class method to
return an image view controller

00:15:48.200 --> 00:15:51.200
for a particular page index.

00:15:51.200 --> 00:15:55.440
And then we're also going to have these
image view controllers know how to vend

00:15:55.500 --> 00:15:58.200
the page index that they are displaying.

00:15:58.200 --> 00:16:03.750
So in the implementation for this,
let's get rid of some

00:16:03.750 --> 00:16:06.830
of this excess stuff.

00:16:07.030 --> 00:16:11.790
Okay, we need to import my image
scroll view subclass.

00:16:11.910 --> 00:16:14.900
Now, this is the same scroll view
subclass that we were using before.

00:16:14.900 --> 00:16:20.060
I'm not going to show you much about it,
except to note that the

00:16:20.170 --> 00:16:21.890
class vends this image count.

00:16:21.900 --> 00:16:24.670
So this scroll view subclass
is actually handling all of the

00:16:24.740 --> 00:16:27.870
logic for figuring out what image
to display on any given page.

00:16:28.080 --> 00:16:31.040
So we'll just keep that just the same.

00:16:31.900 --> 00:16:36.310
So we're going to need in this
image view controller class

00:16:36.430 --> 00:16:39.740
to have a page index IVAR,
and then we're going to need to

00:16:39.800 --> 00:16:41.030
implement just a few methods.

00:16:41.280 --> 00:16:44.450
So we need an initWithPageIndex
method just to set the page

00:16:44.450 --> 00:16:46.100
index on the new instance.

00:16:46.190 --> 00:16:51.840
We need a page index method to return
the page index for a given instance.

00:16:51.860 --> 00:16:56.380
Now let's go ahead and implement this
image view controller for page index

00:16:56.380 --> 00:16:58.700
method that I declared in the header.

00:16:58.900 --> 00:17:00.280
It's going to be pretty simple.

00:17:00.280 --> 00:17:00.550
What we want to do is we're going
to have a page index that's going

00:17:00.550 --> 00:17:00.780
to be a little bit more complex.

00:17:00.780 --> 00:17:00.780
So we're going to have a
page index that's going to

00:17:00.780 --> 00:17:00.780
be a little bit more complex.

00:17:00.780 --> 00:17:00.780
So we're going to have a
page index that's going to

00:17:00.780 --> 00:17:00.780
be a little bit more complex.

00:17:00.780 --> 00:17:00.780
So we're going to have a
page index that's going to

00:17:00.780 --> 00:17:00.830
be a little bit more complex.

00:17:00.920 --> 00:17:05.380
do is if the page index that was
passed in is a reasonable one,

00:17:05.380 --> 00:17:07.160
if we actually have an
image for that index,

00:17:07.240 --> 00:17:09.800
then we're going to return
one of these view controllers.

00:17:09.850 --> 00:17:11.510
If not, we're going to return nil.

00:17:11.510 --> 00:17:14.920
And you'll see in a minute that that
will turn out to be really handy when

00:17:14.920 --> 00:17:18.540
we're implementing the data source
methods for the UI page view controller.

00:17:18.540 --> 00:17:22.040
So if the page index is within range,
if it's greater than or equal

00:17:22.040 --> 00:17:25.510
to zero and less than the image
scroll view's image count,

00:17:25.510 --> 00:17:29.210
then we'll return a new instance,
initialized with the page

00:17:29.210 --> 00:17:30.810
index that we got asked for.

00:17:30.810 --> 00:17:32.640
And otherwise we'll return nil.

00:17:32.760 --> 00:17:33.350
All right.

00:17:33.370 --> 00:17:35.060
We're almost done with this class.

00:17:35.150 --> 00:17:37.620
Just two more methods -- rather,
three more methods to go.

00:17:37.630 --> 00:17:40.520
So we need to make a load view method.

00:17:40.520 --> 00:17:42.330
And in that method,
we're going to do nothing fancy.

00:17:42.400 --> 00:17:44.740
We're just going to create one
of these image scroll views,

00:17:44.910 --> 00:17:47.120
same class we were using before.

00:17:47.200 --> 00:17:50.020
Set its index to be our page index.

00:17:50.020 --> 00:17:53.550
Set its auto resizing mask to
give it flexible width and height.

00:17:53.730 --> 00:17:54.990
This is really important.

00:17:54.990 --> 00:17:57.370
If you notice that when we
initialized the scroll view,

00:17:57.370 --> 00:17:58.760
we actually didn't give it a frame.

00:17:58.760 --> 00:18:02.000
We are not responsible for
sizing our view ourself.

00:18:02.000 --> 00:18:04.660
The UI page view controller is
going to do that for us as long

00:18:04.730 --> 00:18:06.980
as we make ourselves flexible.

00:18:07.130 --> 00:18:08.820
So we're going to do that.

00:18:08.820 --> 00:18:12.490
We're going to set our view --
because we're a view controller here,

00:18:12.490 --> 00:18:12.770
right?

00:18:12.770 --> 00:18:14.860
So we're going to set our
view to be the scroll view.

00:18:14.860 --> 00:18:15.670
And that's pretty much it.

00:18:16.160 --> 00:18:21.400
We need to then also say
that we can auto rotate,

00:18:21.440 --> 00:18:23.120
just to continue to support rotation.

00:18:23.120 --> 00:18:27.580
So the way that UI page view controller
works is it asks its current page

00:18:27.580 --> 00:18:31.420
permission to rotate when it itself
is asked whether it's going to rotate.

00:18:31.420 --> 00:18:32.810
So we're going to say, yeah,
we support all of the

00:18:32.830 --> 00:18:33.860
interface orientations.

00:18:33.860 --> 00:18:34.950
All right.

00:18:35.060 --> 00:18:37.820
So that's pretty much it for
our image view controller.

00:18:37.820 --> 00:18:40.400
So as you can see, it's a lot less code
than we just deleted.

00:18:40.400 --> 00:18:45.320
And now all that we have left to
do is back in this app delegate,

00:18:45.320 --> 00:18:48.600
we need to import our new
class that we just made,

00:18:48.630 --> 00:18:49.600
our new header.

00:18:49.600 --> 00:18:53.540
And then we need to go ahead and
make this first page as we promised.

00:18:53.640 --> 00:18:56.810
So page zero,
it's just image view controller,

00:18:56.810 --> 00:19:00.020
image view controller page index zero.

00:19:00.020 --> 00:19:06.080
And then we need to set this page on
our UI page view controller instance.

00:19:06.080 --> 00:19:09.570
So it's another one of
these many argument methods.

00:19:09.720 --> 00:19:12.600
Set view controllers
direction animated completion.

00:19:12.600 --> 00:19:18.100
So the view controllers is just going to
be an array consisting of only page zero.

00:19:18.100 --> 00:19:21.640
The direction is forwards in this case.

00:19:21.640 --> 00:19:24.000
And we don't really want to animate
this or -- and we don't care about

00:19:24.000 --> 00:19:26.300
when it completes because this is
all being done before the app is

00:19:26.370 --> 00:19:28.220
actually even visible on the screen.

00:19:28.220 --> 00:19:28.220
So we're going to set
this page as page zero.

00:19:28.220 --> 00:19:29.320
So great.

00:19:29.320 --> 00:19:31.880
So we've got a first page.

00:19:31.880 --> 00:19:35.040
Now, if I were to run this now,
you would see the first page.

00:19:35.040 --> 00:19:38.690
But we would crash when we tried
to scroll because we haven't

00:19:38.690 --> 00:19:41.700
implemented our data source methods.

00:19:41.700 --> 00:19:44.440
So we need to implement those.

00:19:44.440 --> 00:19:46.460
We need two data source methods.

00:19:46.460 --> 00:19:49.770
Page view controller,
view controller before view controller,

00:19:49.900 --> 00:19:52.540
and view controller
after view controller.

00:19:52.540 --> 00:19:56.460
And these are going to be incredibly fast
to write because we just need to grab the

00:19:56.540 --> 00:19:58.040
page index out of the view controller.

00:19:58.040 --> 00:19:58.040
We don't want to have to do that.

00:19:58.040 --> 00:19:59.660
So we're going to return the page
index to the controller we were given.

00:19:59.660 --> 00:20:02.060
And in the case where we're
trying to make the one before it,

00:20:02.060 --> 00:20:05.340
we just need to subtract one and
return the page for that index.

00:20:05.340 --> 00:20:07.530
So I'm going to return
image view controller,

00:20:07.810 --> 00:20:10.810
image view controller for page index,
the one before.

00:20:11.200 --> 00:20:14.580
This is where it becomes
really handy that this method,

00:20:14.580 --> 00:20:17.620
image view controller for page index,
returns nil if the page

00:20:17.720 --> 00:20:18.950
index is out of bounds.

00:20:19.320 --> 00:20:22.520
Because the way that you tell
a UI page view controller to

00:20:22.770 --> 00:20:26.130
stop allowing scrolling is by
returning nil from this method.

00:20:26.170 --> 00:20:29.330
So if the page index is out of bounds,
we'll just automatically make it so

00:20:29.370 --> 00:20:31.460
scrolling comes to an end at that page.

00:20:31.460 --> 00:20:34.570
And then in the after case,
we do exactly the same

00:20:34.620 --> 00:20:36.000
thing but plus one.

00:20:36.000 --> 00:20:38.380
And now we can go ahead and run it.

00:20:42.200 --> 00:20:42.960
And here we go.

00:20:42.990 --> 00:20:45.090
It looks just the same as before,
which is a good sign.

00:20:45.120 --> 00:20:47.740
I can scroll from page to page.

00:20:47.810 --> 00:20:52.440
I can rotate and scroll back,
rotate again.

00:20:52.490 --> 00:20:56.100
And let's see, I can still zoom in,
zoom out.

00:20:56.440 --> 00:20:57.590
Everything's working just as before.

00:20:57.690 --> 00:21:00.310
So minus a lot, a lot of code.

00:21:00.320 --> 00:21:02.160
So back to Josh.

00:21:10.150 --> 00:21:14.310
So hopefully that is going to be a
really nice benefit for everybody and

00:21:14.310 --> 00:21:17.760
make it easier for everyone to get
scroll views and photo browsers that

00:21:17.840 --> 00:21:19.800
feel just like the Photos app on iOS.

00:21:19.800 --> 00:21:21.900
The next thing that
we want to talk about,

00:21:21.900 --> 00:21:24.440
I'm actually really,
really excited about.

00:21:24.440 --> 00:21:25.940
I think this is very cool.

00:21:25.940 --> 00:21:28.900
We're going to talk about
integrating UI Scroll View into

00:21:28.900 --> 00:21:30.970
your OpenGL games and applications.

00:21:31.000 --> 00:21:35.100
So you may wonder why you
might want to do this.

00:21:36.000 --> 00:21:40.640
A common thing that you end up finding is
that you've got something in your game,

00:21:40.640 --> 00:21:44.910
usually in a setup screen or a browser
of some sort at the beginning of a game,

00:21:44.920 --> 00:21:47.370
where you have to be able to
scroll through some content.

00:21:47.380 --> 00:21:51.810
And it's at first glance not obvious
how you might use UI Scroll View in

00:21:51.810 --> 00:21:55.620
order to actually scroll the
content in your OpenGL games,

00:21:55.620 --> 00:21:58.610
because the way UI Scroll View works
is that you put the scrollable

00:21:58.720 --> 00:22:02.080
content into the UI Scroll View,
and UI Scroll View moves it around.

00:22:02.080 --> 00:22:05.710
That's obviously kind of at
odds with your own OpenGL stuff,

00:22:05.940 --> 00:22:11.480
where everything exists in one UI view
that displays all the OpenGL content.

00:22:11.560 --> 00:22:15.080
So let's take a look at
how we might do this.

00:22:15.160 --> 00:22:20.160
I really wanted to get everyone really
invested in this and excited and pull

00:22:20.390 --> 00:22:22.200
you all right into the experience here.

00:22:22.290 --> 00:22:26.350
So I have some really amazing graphics
to really just illustrate this well.

00:22:26.460 --> 00:22:29.660
So let's assume that we've got
a game that we're going to build

00:22:30.000 --> 00:22:32.370
that is going to be a racing game.

00:22:32.440 --> 00:22:34.920
And of course, in your racing game,
you need to allow your users to

00:22:34.990 --> 00:22:36.710
pick which car they want to race as.

00:22:36.760 --> 00:22:39.640
And so let's imagine that
we're going to do that on some

00:22:39.640 --> 00:22:42.340
screen where we have a podium,
and we're going to place cars on it

00:22:42.340 --> 00:22:43.580
that the user can scroll through.

00:22:43.640 --> 00:22:47.760
So we've got this immersive
3D game with a podium that's

00:22:47.760 --> 00:22:49.000
going to display our cars.

00:22:49.000 --> 00:22:52.880
And I've drawn this myself,
so you know it's good.

00:22:53.010 --> 00:22:59.360
Now let's place our car on the podium,
and then we want to allow our users

00:22:59.360 --> 00:23:03.100
to scroll between different cars to
pick the one that they want to race as.

00:23:05.920 --> 00:23:08.380
If you were to do this in
just a regular 2D game,

00:23:08.520 --> 00:23:11.660
the way you would probably do
that is by taking this 3D scene,

00:23:12.130 --> 00:23:15.100
pulling the car out of it,
and putting it inside a UI scroll view

00:23:15.100 --> 00:23:16.650
so that you can scroll between that.

00:23:16.660 --> 00:23:19.660
But of course, in a 3D world,
this might not be possible.

00:23:19.910 --> 00:23:22.470
Because maybe you have some
other parts of the scene that

00:23:22.470 --> 00:23:23.660
interact with these cars.

00:23:23.740 --> 00:23:26.540
You might have some lights that
are on top shining down on the

00:23:26.540 --> 00:23:28.030
cars that you're trying to display.

00:23:28.420 --> 00:23:33.100
And maybe those lights are causing
reflections off the windows.

00:23:33.100 --> 00:25:55.300
[Transcript missing]

00:26:00.410 --> 00:26:05.240
You can see here the amazing
work of my OpenGL genius.

00:26:05.360 --> 00:26:07.800
This represents the outer
limit of my OpenGL competence,

00:26:07.890 --> 00:26:09.710
so be impressed.

00:26:09.980 --> 00:26:12.060
We've got a bunch of cubes
here that are rotating,

00:26:12.060 --> 00:26:15.620
and we have another really big
cube here that's rotating more

00:26:15.620 --> 00:26:17.620
slowly and changing color.

00:26:17.890 --> 00:26:23.580
So what we want to-- so here's
what this app does out of the box.

00:26:23.680 --> 00:26:27.480
You can tap on this bigger cube and
make it randomly change to a different

00:26:27.550 --> 00:26:30.300
color and a different rotation speed.

00:26:30.470 --> 00:26:34.300
You can also tap on these little cubes,
and they'll take on the properties

00:26:34.300 --> 00:26:36.130
of the big cube at that moment.

00:26:36.300 --> 00:26:39.290
So this way, we can-- for example,
if we wait a few seconds

00:26:39.350 --> 00:26:42.000
and tap on the next one,
you can see how the big

00:26:42.000 --> 00:26:45.800
cube is changing over time,
which is really useful.

00:26:45.990 --> 00:26:47.400
So there we go.

00:26:47.820 --> 00:26:51.800
So now we might want to be able to
track the big cube's progress over

00:26:51.800 --> 00:26:55.050
time-- over a longer period of time,
and so we might want to have more

00:26:55.050 --> 00:26:57.800
than just three of these little
cubes to record its progress.

00:26:57.800 --> 00:27:01.800
Okay, so we might want to be able
to actually add more cubes,

00:27:01.830 --> 00:27:04.300
and then we could scroll through them.

00:27:04.440 --> 00:27:07.550
So to do this,
we can use the trick that Josh just

00:27:07.670 --> 00:27:12.800
described of placing a scroll view
inside the OpenGL view to accept touches,

00:27:12.800 --> 00:27:19.250
and then we're going to set a new content
offset on the OpenGL view to change where

00:27:19.250 --> 00:27:21.800
the little cubes are being displayed.

00:27:21.960 --> 00:27:24.150
So let me move over to the code.

00:27:24.690 --> 00:27:27.300
And basically,
we've got a view controller here,

00:27:27.320 --> 00:27:30.300
which is a subclass of
GLK view controller,

00:27:30.300 --> 00:27:34.800
which is part of the standard setup
for making an OpenGL app on iOS.

00:27:34.900 --> 00:27:39.300
And then we have almost all of the work
is being done in this cube view class,

00:27:39.550 --> 00:27:42.220
which is essentially
drawing all that stuff.

00:27:42.300 --> 00:27:49.180
It's being updated at every frame
by the OpenGL rendering machine,

00:27:49.480 --> 00:27:52.530
and then it also vends a few properties
that are going to be useful when

00:27:52.530 --> 00:27:54.300
we want to set up this scroll view.

00:27:54.300 --> 00:27:58.300
So it vends a scrollable frame,
which is the frame in the OpenGL view

00:27:58.300 --> 00:28:02.920
that we want to make scrollable,
and it also gives us a scrollable content

00:28:02.920 --> 00:28:08.300
size telling us how much room there is
within that scroll view for scrolling.

00:28:08.350 --> 00:28:11.300
It also has a read/write property,
scroll offset,

00:28:11.300 --> 00:28:15.040
that we'll be able to set when the
scroll view scrolls so that the cube

00:28:15.040 --> 00:28:17.800
view will update its view accordingly.

00:28:17.800 --> 00:28:19.300
All right, so that's the setup.

00:28:19.450 --> 00:28:21.300
Let's go ahead and do it.

00:28:21.300 --> 00:28:26.300
So here in my viewDidLoad method,
I'm going to add a scroll view.

00:28:26.300 --> 00:28:29.060
I'm going to set the scroll
view's frame to be this scrollable

00:28:29.060 --> 00:28:30.300
frame vended by our view.

00:28:30.300 --> 00:28:36.010
And I'm going to set its content size
to be the scrollable content size.

00:28:36.100 --> 00:29:42.400
[Transcript missing]

00:29:42.600 --> 00:34:47.100
[Transcript missing]

00:34:48.090 --> 00:34:49.910
All right, my clicking is broken.

00:34:50.010 --> 00:34:52.900
So in fact, I've actually broken taps.

00:34:53.020 --> 00:34:55.310
So as you can see,
taps are actually still

00:34:55.310 --> 00:34:56.950
working in the rest of the app.

00:34:57.110 --> 00:34:58.840
So I haven't broken them altogether.

00:34:58.940 --> 00:35:02.180
But in the area where the scroll view is,
taps are not making it

00:35:02.260 --> 00:35:03.820
through to my OpenGL view.

00:35:04.170 --> 00:35:08.030
So to explain why that's going wrong,
I'm going to bring Josh back up.

00:35:08.400 --> 00:35:10.750
There's actually one other
mode that Eliza didn't mention,

00:35:10.800 --> 00:35:13.180
and that's the NSCommonRunLoopModes.

00:35:13.230 --> 00:35:17.050
Now, NSCommonRunLoopModes is actually a
combination of the other two modes,

00:35:17.050 --> 00:35:19.540
the default and the tracking RunLoopMode.

00:35:19.540 --> 00:35:22.960
So it's one constant,
NSCommonRunLoopModes,

00:35:23.270 --> 00:35:24.970
that actually encompasses both.

00:35:25.090 --> 00:35:27.530
So if you didn't want to schedule
in just one or the other but

00:35:27.530 --> 00:35:31.380
wanted to schedule for both,
you could just use NSCommonRunLoopModes.

00:35:31.590 --> 00:35:35.500
Now, Eliza mentioned all of this in
the context of OpenGL views,

00:35:35.580 --> 00:35:38.170
but what she didn't mention is
that this actually affects all

00:35:38.310 --> 00:35:43.200
UI scroll view subclasses everywhere,
such as UI TextView, UI WebView,

00:35:43.390 --> 00:35:46.590
the new UI CollectionView,
all of these things.

00:35:46.790 --> 00:35:49.210
So if you're using any
scroll view anywhere,

00:35:49.210 --> 00:35:51.540
you may have run into this in the past.

00:35:51.590 --> 00:35:55.260
One common example of other places
that you'll see this are places

00:35:55.260 --> 00:35:57.780
where you're using NSTimers.

00:35:57.820 --> 00:36:00.020
The way that you would
normally schedule a timer,

00:36:00.020 --> 00:36:03.450
the most convenient way,
is to call scheduled timer with time

00:36:03.880 --> 00:36:06.740
interval target selector repeats.

00:36:06.740 --> 00:36:10.140
And what this will do is
actually schedule this timer

00:36:10.340 --> 00:36:12.480
on the RunLoop on your behalf.

00:36:12.540 --> 00:36:15.510
But what it does is schedule
it in the default RunLoopMode.

00:36:15.600 --> 00:36:18.380
So if you schedule a timer like
this for one second from now,

00:36:18.460 --> 00:36:21.060
and one second from now the
user is scrolling a scroll view,

00:36:21.080 --> 00:36:23.520
that timer's not going to
fire at the time you expected.

00:36:23.520 --> 00:36:26.490
So you may have actually come
across this and not been entirely

00:36:26.490 --> 00:36:28.010
clear on what was happening.

00:36:28.120 --> 00:36:30.060
That's why it happens.

00:36:30.060 --> 00:36:33.830
So you can work around this with
NSTimer in particular by creating your

00:36:33.940 --> 00:36:38.960
timer using the other class method,
the timer with interval method.

00:36:38.990 --> 00:36:42.090
It takes all the same parameters,
but it doesn't get scheduled

00:36:42.090 --> 00:36:43.600
into the RunLoop automatically.

00:36:43.610 --> 00:36:46.380
Now the reason you'll do that
is because then you can use the

00:36:46.380 --> 00:36:50.040
NSRunLoop method to schedule the
timer yourself in a particular mode.

00:36:50.080 --> 00:36:53.990
So we can call NSRunLoop main RunLoop,
add timer for mode, and pass in,

00:36:53.990 --> 00:36:56.770
in this case,
NSCommon RunLoopModes to indicate

00:36:56.770 --> 00:36:58.780
that we want this timer to fire
regardless of whether we're in the

00:36:58.780 --> 00:36:59.260
default or tracking RunLoopMode.

00:36:59.260 --> 00:36:59.260
So we can call NSRunLoop main RunLoop,
add timer for mode, and pass in,

00:36:59.260 --> 00:36:59.260
in this case,
NSCommon RunLoopModes to indicate

00:36:59.260 --> 00:36:59.260
that we want this timer to fire
regardless of whether we're in the

00:36:59.260 --> 00:36:59.260
default or tracking RunLoopMode.

00:36:59.260 --> 00:37:01.700
or tracking run loop mode.

00:37:01.890 --> 00:37:03.360
So that's one common case.

00:37:03.400 --> 00:37:07.920
Another one then is the
performSelectorAfterDelay method.

00:37:08.000 --> 00:37:11.600
performSelector with object
after delay also schedules

00:37:11.600 --> 00:37:13.020
into the default run loop mode.

00:37:13.120 --> 00:37:15.580
So if you call this method,
even though it's not necessarily

00:37:15.580 --> 00:37:18.590
obvious that it's having anything
at all to do with run loops,

00:37:18.750 --> 00:37:21.400
if your user is scrolling
one second from now,

00:37:21.430 --> 00:37:24.160
the selector that you asked to
perform isn't gonna get called.

00:37:24.160 --> 00:37:27.500
This one's actually even easier
to fix in that there's just a

00:37:27.590 --> 00:37:30.500
slightly longer version of the
same method called performSelector

00:37:30.500 --> 00:37:33.680
with object after delay in modes.

00:37:33.700 --> 00:37:37.270
Now, it's slightly different in that this
actually takes an array of modes.

00:37:37.380 --> 00:37:42.000
So here we've used the new array
syntax introduced in iOS 6 to

00:37:42.000 --> 00:37:45.940
have a NSCommonRunLoopModes as
the single element in our NSArray.

00:37:46.140 --> 00:37:50.890
So if you happen to find that when
you're using your UI scroll views,

00:37:50.920 --> 00:37:53.600
something that you think should be
happening right now isn't happening

00:37:53.680 --> 00:37:56.460
until the scroll view finishes,
take a look at your run loop modes

00:37:56.520 --> 00:37:59.040
'cause that's probably what's going on.

00:37:59.070 --> 00:38:00.180
All right, so that's run loop modes.

00:38:00.180 --> 00:38:03.220
Now, let's see if we can't help
Eliza realize her dreams.

00:38:03.500 --> 00:38:06.520
So, UI responder and event delivery.

00:38:06.690 --> 00:38:08.610
This is...

00:38:09.310 --> 00:38:12.390
is really the foundation of
the basics of touch handling,

00:38:12.390 --> 00:38:15.150
ignoring UI gesture
recognizer for a minute,

00:38:15.150 --> 00:38:16.110
on iOS.

00:38:16.940 --> 00:38:19.910
So let's take, for an example,
a really simple case,

00:38:19.910 --> 00:38:22.270
ignoring the OpenGL view
and the UI scroll view.

00:38:22.320 --> 00:38:24.770
Let's just assume we
have some plain UI view,

00:38:24.780 --> 00:38:27.290
not a subclass of anything,
and that this thing

00:38:27.290 --> 00:38:29.260
has one child UI view.

00:38:29.260 --> 00:38:30.650
So we'll put that right in there.

00:38:30.650 --> 00:38:34.240
And now let's let our user put a
finger down inside of that child view.

00:38:34.240 --> 00:38:37.390
So the way event delivery on iOS
works is we hit test from the window

00:38:37.390 --> 00:38:40.720
out towards the user and find the
deepest view that we would have hit,

00:38:40.720 --> 00:38:44.390
in this case the child view,
and we deliver the touch to that view.

00:38:44.400 --> 00:38:48.060
So touches began with event will
get called on that child view.

00:38:48.190 --> 00:38:50.830
If you don't implement
touches began with event,

00:38:50.830 --> 00:38:53.990
and it will automatically get
forwarded by the UI responder

00:38:53.990 --> 00:38:55.640
methods up the responder chain.

00:38:55.640 --> 00:38:58.640
And the next responder from
a view is its super view.

00:38:58.640 --> 00:39:01.480
So it would get forwarded
to the parent UI view.

00:39:01.480 --> 00:39:05.470
Now, if the parent view didn't
implement touches began with event,

00:39:05.470 --> 00:39:07.870
the responder chain would
forward to the next responder,

00:39:07.870 --> 00:39:10.160
and the next responder in
this case would actually be,

00:39:10.160 --> 00:39:13.640
because let's assume that this
parent view has a view controller,

00:39:13.700 --> 00:39:15.380
would be the view's view controller.

00:39:15.380 --> 00:39:16.860
So child view,
and the next responder in this case

00:39:16.860 --> 00:39:18.730
would actually be child to parent
to that parent's view controller.

00:39:18.730 --> 00:39:21.040
Now, if the parent view
controller didn't handle it,

00:39:21.170 --> 00:39:24.040
the next responder is the UI window,
because there's no other super view.

00:39:24.040 --> 00:39:28.010
And if the UI window didn't handle it,
it would go to the UI application object.

00:39:28.070 --> 00:39:31.040
And finally, if it's not handled there,
it would go to the UI application

00:39:31.050 --> 00:39:33.660
delegate that you would have
set on your application.

00:39:33.770 --> 00:39:36.140
So that would be the normal
responder chain path,

00:39:36.230 --> 00:39:38.170
and any of these views would
have seen that touch if one

00:39:38.170 --> 00:39:39.110
of them didn't handle it.

00:39:39.200 --> 00:39:42.540
But clearly that's not what's
happening in Eliza's case,

00:39:42.550 --> 00:39:45.720
because the parent view,
which in her case was her NSOpenGL,

00:39:45.720 --> 00:39:50.950
or sorry, her... OpenGL view,
that subclass of UI view,

00:39:50.950 --> 00:39:53.410
is where she implemented
her touch handling logic.

00:39:53.540 --> 00:39:57.000
So according to this diagram,
her parent view, that OpenGL view,

00:39:57.000 --> 00:39:58.420
should have received the touch.

00:39:58.620 --> 00:40:00.830
So to understand why it didn't,
we have to take a look at

00:40:00.890 --> 00:40:04.010
the actual view hierarchy,
which is a UI scroll view embedded on

00:40:04.020 --> 00:40:09.170
top of an NSOpenGL... I keep saying
NSOpenGL... on top of an OpenGL view.

00:40:09.280 --> 00:40:12.190
So let's do the same thing here,
and have the user put a finger

00:40:12.190 --> 00:40:14.080
down in that UI scroll view.

00:40:14.240 --> 00:40:15.580
Of course,
we're going to deliver it right

00:40:15.580 --> 00:40:16.940
to the UI Scroll View first.

00:40:17.000 --> 00:40:19.830
But the problem in this case is
that that's actually where this

00:40:19.940 --> 00:40:21.600
responder chain ends delivery.

00:40:21.670 --> 00:40:24.650
Because UI Scroll View does implement
touches began with event and doesn't

00:40:24.650 --> 00:40:26.230
forward it up the responder chain.

00:40:26.340 --> 00:40:30.130
So it stops right there,
and her OpenGL view never sees it.

00:40:30.580 --> 00:40:33.390
So obviously we'll have to do something
in order to figure out how her

00:40:33.400 --> 00:40:37.000
OpenGL can get this touch because that's
where her touch handling logic lives.

00:40:37.030 --> 00:40:41.040
Now, one thing that I've seen a
number of times that I really,

00:40:41.040 --> 00:40:46.690
really, really want to discourage is
something that looks like this.

00:40:46.980 --> 00:40:50.140
You implement touches began with event
in your subclass of UI scroll view and

00:40:50.270 --> 00:40:54.260
manually call touches began with event on
some next responder or some other object.

00:40:54.330 --> 00:40:57.220
Now, this is really,
really not supported.

00:40:57.220 --> 00:41:00.560
We don't support forwarding
touches manually between

00:41:00.560 --> 00:41:02.580
views that are owned by UIKit.

00:41:02.600 --> 00:41:06.240
UIKit can no longer reason about
the flow of events once you've

00:41:06.370 --> 00:41:10.120
started manually forwarding views,
manually forwarding touches.

00:41:10.120 --> 00:41:12.700
It's just, it leads to bad news.

00:41:12.740 --> 00:41:15.440
It would actually turn your view,
or your responder chain into

00:41:15.440 --> 00:41:18.400
something that looked like this,
where you kind of manually

00:41:18.400 --> 00:41:20.260
forwarded it to the OpenGL view.

00:41:20.260 --> 00:41:22.420
But because UIKit didn't
know you were doing it,

00:41:22.420 --> 00:41:25.900
it would stop there and not get forwarded
on the rest of the chain anyway.

00:41:25.900 --> 00:41:28.240
It really isn't what you want.

00:41:28.300 --> 00:41:30.350
So, that's not going to work.

00:41:30.360 --> 00:41:33.710
We could try one other thing,
which is to put the OpenGL view

00:41:33.710 --> 00:41:36.740
inside of that UI scroll view,
because that would fix

00:41:36.760 --> 00:41:38.280
the responder chain.

00:41:38.280 --> 00:41:40.920
Our OpenGL view would start
getting the events then.

00:41:40.920 --> 00:41:44.540
But as we discussed earlier,
we don't want this view configuration

00:41:44.540 --> 00:41:48.050
because we want our scroll view to only
be on a small part of that OpenGL view.

00:41:48.060 --> 00:41:51.360
So, once again, it seems like we've kind
of gotten to an impasse.

00:41:51.360 --> 00:41:53.030
What can we possibly do?

00:41:53.040 --> 00:41:55.560
We can't have the OpenGL view
in the scroll view,

00:41:55.570 --> 00:41:58.640
and we can't have the scroll
view in the OpenGL view.

00:41:58.780 --> 00:42:01.590
Well, this is another place where we
have to stop and think a little

00:42:01.590 --> 00:42:04.730
bit differently than we would in
any other non-OpenGL application.

00:42:04.740 --> 00:42:06.850
And again,
it goes back to the fact that we

00:42:06.850 --> 00:42:10.070
don't actually want UI Scroll View to
do any of the drawing.

00:42:10.080 --> 00:42:13.440
All we're trying to do is
get its event tracking,

00:42:13.440 --> 00:42:16.340
its deceleration, and its bouncing.

00:42:16.340 --> 00:42:19.800
We just want the behaviors that
UI Scroll View is providing.

00:42:19.800 --> 00:42:22.210
So really,
we don't even need the scroll view to

00:42:22.220 --> 00:42:25.760
be in the view hierarchy visible at all,
because we're not relying

00:42:25.760 --> 00:42:27.180
on it drawing anything.

00:42:27.540 --> 00:42:31.080
So we could just try and hide it,
or move it off to the side,

00:42:31.080 --> 00:42:33.250
or add it as a subview somewhere
where you can't even see it,

00:42:33.340 --> 00:42:35.610
and it wouldn't actually
change our visuals at all.

00:42:35.620 --> 00:42:37.700
The only problem we'd
have left then is that,

00:42:37.810 --> 00:42:40.310
well, obviously it's not going
to get any touches if it's

00:42:40.360 --> 00:42:41.780
not visible and on screen.

00:42:41.780 --> 00:42:44.760
So we would have to come up with some
way to make sure that it's still got

00:42:44.820 --> 00:42:46.700
touches if we were to try and do this.

00:42:46.700 --> 00:42:49.500
And it turns out that we
actually can do exactly that.

00:42:49.500 --> 00:42:52.960
So let's put a dummy UI view in
its place just to provide the

00:42:53.250 --> 00:42:57.520
sizing exactly where we had had
it in the view hierarchy before.

00:42:57.520 --> 00:43:00.240
And this dummy view can
just be a plain UI view.

00:43:00.240 --> 00:43:01.680
It doesn't have to be a subclass at all.

00:43:01.680 --> 00:43:03.820
The most important property
of this view being that it

00:43:03.830 --> 00:43:06.700
doesn't implement touches began,
moved, ended, or canceled.

00:43:06.700 --> 00:43:10.060
And the reason for that is that
we've now fixed our responder chain.

00:43:10.060 --> 00:43:12.070
We've got a child view,
and it will forward events to the

00:43:12.070 --> 00:43:14.050
OpenGL view if it doesn't handle them,
which it won't,

00:43:14.050 --> 00:43:15.570
because we're not going to have it.

00:43:17.070 --> 00:43:19.120
So we've got the responder
chain back in order,

00:43:19.170 --> 00:43:22.340
but we still don't have our
UI scroll view receiving any touches.

00:43:22.390 --> 00:43:25.840
But we can fix that by taking
advantage of the fact that UI scroll

00:43:25.840 --> 00:43:28.960
view does its touch tracking
using UI gesture recognizers.

00:43:28.960 --> 00:43:31.270
So UI scroll view has
a number of UI gesture

00:43:31.270 --> 00:43:33.140
recognizers attached to itself.

00:43:33.140 --> 00:43:37.960
And those gesture recognizers are exposed
through properties on the UI scroll view.

00:43:37.970 --> 00:43:40.360
So we can grab them and
move them to another view.

00:43:40.360 --> 00:43:42.440
Once we've attached
them to that child view,

00:43:42.440 --> 00:43:46.030
they're in the view hierarchy in a place
where we want them to receive touches,

00:43:46.030 --> 00:43:48.130
and so they will start receiving touches.

00:43:48.160 --> 00:43:51.530
When those gestures recognize,
they'll notify the UI scroll view

00:43:51.530 --> 00:43:54.670
that they have been recognized,
and the UI scroll view will begin

00:43:54.670 --> 00:43:57.850
scrolling despite the fact that
it's not actually visible on screen.

00:43:57.860 --> 00:44:00.960
And really,
this will let us implement exactly

00:44:01.040 --> 00:44:02.960
what Eliza was trying to do.

00:44:03.050 --> 00:44:06.340
So in order to show how that works,
she's going to come back

00:44:06.340 --> 00:44:07.940
up and do one more demo.

00:44:14.470 --> 00:44:16.240
Okay,
this is going to be a really easy demo.

00:44:16.240 --> 00:44:19.180
We just need to replace our scroll
view with a dummy view and move

00:44:19.180 --> 00:44:20.960
the gesture recognizers over.

00:44:21.110 --> 00:44:24.220
So the first thing I'm going
to do is move the scroll view

00:44:24.390 --> 00:44:28.500
out of the way so that it stops
trying to usurp all my touches.

00:44:28.560 --> 00:44:31.780
And I can do that by moving it aside,
by sticking it under everything,

00:44:31.780 --> 00:44:34.840
but probably the easiest way
to do that is just to hide it,

00:44:34.910 --> 00:44:37.030
because hidden views don't get hit test.

00:44:37.150 --> 00:44:38.800
So I'm going to go ahead and hide it.

00:44:38.870 --> 00:44:43.160
And now I'm going to add a dummy view.

00:44:43.400 --> 00:44:46.660
I'm going to make the frame of the
dummy view be the same scrollable frame,

00:44:46.660 --> 00:44:51.190
because that's where we want to be
able to detect our panning gesture.

00:44:51.630 --> 00:44:54.790
I'm going to add the gesture
recognizers from the scroll view.

00:44:54.880 --> 00:44:59.040
So here I'm accessing the scroll
view's pan gesture recognizer property.

00:44:59.090 --> 00:45:02.560
I'm just taking that gesture recognizer
and I'm moving it over to the dummy view.

00:45:02.590 --> 00:45:06.080
I only care about the pan gesture
recognizer in this case because I'm

00:45:06.080 --> 00:45:08.660
not trying to allow zooming on my view.

00:45:08.660 --> 00:45:12.760
And then finally I'm going
to add this dummy view as a

00:45:12.760 --> 00:45:15.140
subview of my OpenGL view.

00:45:15.140 --> 00:45:16.080
And that's pretty much it.

00:45:16.080 --> 00:45:18.220
So that ought to solve our problem.

00:45:18.310 --> 00:45:21.540
So here we are scrolling.

00:45:21.540 --> 00:45:23.820
So I can still scroll, first of all,
which is pretty cool because

00:45:23.820 --> 00:45:26.140
the scroll view is actually
not even receiving touches now.

00:45:26.210 --> 00:45:31.060
And then I can actually now
tap these views and it works.

00:45:31.180 --> 00:45:34.540
So this actually does solve the problem.

00:45:34.840 --> 00:45:37.910
Now, it solves it in an odd way, right?

00:45:37.910 --> 00:45:41.740
We have this view here that's
kind of performing this

00:45:41.740 --> 00:45:43.050
weird function and it's --

00:45:43.680 --> 00:45:44.800
It's a little roundabout.

00:45:44.800 --> 00:45:48.050
So I want to just mention that
under some configurations,

00:45:48.050 --> 00:45:50.230
you wouldn't actually have to do this.

00:45:50.400 --> 00:45:53.500
So as it happens,
my cube view is detecting

00:45:53.500 --> 00:45:56.400
touches using touches began,
moved, ended, and canceled,

00:45:56.400 --> 00:45:59.000
which makes it vulnerable to
this responder chain problem.

00:45:59.000 --> 00:46:02.920
So we wanted to show this because we
think that people who already have

00:46:02.920 --> 00:46:07.340
existing OpenGL apps and have already
got their touch handling written might

00:46:07.340 --> 00:46:09.700
want to be able to adopt this method.

00:46:09.700 --> 00:46:13.060
But if you were writing an app from
scratch and you decided to use gesture

00:46:13.190 --> 00:46:16.760
recognizers for your touch handling,
then you wouldn't face the problem that

00:46:16.760 --> 00:46:20.410
I faced at the end of the last demo
because gesture recognizers don't depend

00:46:20.410 --> 00:46:22.060
on the responder chain to recognize.

00:46:22.100 --> 00:46:25.240
So had I been detecting taps
using a UITap gesture recognizer,

00:46:25.400 --> 00:46:28.380
we wouldn't have even had this
problem in the first place.

00:46:28.440 --> 00:46:32.210
So keep that in mind if you're
adopting this technique from scratch.

00:46:32.560 --> 00:46:36.200
In the case where you're using tap
gesture recognizers to do touch handling,

00:46:36.260 --> 00:46:37.860
then you could just leave
the scroll view there,

00:46:37.940 --> 00:46:40.600
not hide it, not have a dummy view,
and everything.

00:46:40.640 --> 00:46:44.590
All right, so turning it back over to
Josh for one more topic.

00:46:50.090 --> 00:46:51.130
All right.

00:46:51.230 --> 00:46:52.270
Thanks, Eliza.

00:46:52.390 --> 00:46:55.790
So the last thing we want to
talk about-- just kidding.

00:46:55.870 --> 00:47:00.550
I don't know why they put
that button on there-- is

00:47:01.100 --> 00:49:28.400
[Transcript missing]

00:49:36.900 --> 00:49:38.130
So let's add this.

00:49:38.390 --> 00:49:41.520
So in this case, let me switch back to
the application running.

00:49:41.730 --> 00:49:44.220
We don't have any cars,
because I couldn't possibly

00:49:44.290 --> 00:49:45.360
draw one in OpenGL.

00:49:45.360 --> 00:49:48.460
But let's make it so that every
time that you scroll this,

00:49:48.460 --> 00:49:52.530
you end up perfectly centered with
three cubes in the middle of the screen,

00:49:52.530 --> 00:49:55.340
so that this configuration
isn't a possible resting

00:49:55.420 --> 00:49:59.080
point for the scroll view,
just to demonstrate the concept.

00:49:59.460 --> 00:50:03.870
So in order to do that,
we're going to add a new method

00:50:03.880 --> 00:50:06.930
that this cube view implements.

00:50:06.930 --> 00:50:10.640
I'm calling it Scroll Offset
for Proposed Offset.

00:50:10.640 --> 00:50:14.000
So what the cube view is going to do is
go look at the offset that was proposed,

00:50:14.000 --> 00:50:16.830
figure out what's the nearest
one that would get three cubes

00:50:16.830 --> 00:50:19.540
perfectly centered on the screen,
and return that.

00:50:19.570 --> 00:50:22.020
So let's go ahead and implement that.

00:50:22.200 --> 00:50:26.810
So switching to my implementation,
I'm going to add it here

00:50:26.810 --> 00:50:29.440
under my scrollable content.

00:50:29.460 --> 00:50:33.630
So in this Scroll Offset
for Proposed Offset method,

00:50:33.630 --> 00:50:39.640
the first thing that I'm going to do
is calculate how much have we overshot.

00:50:39.810 --> 00:50:42.800
So basically,
you imagine that here's where you'd be if

00:50:42.880 --> 00:50:45.500
the three cubes were perfectly centered.

00:50:45.500 --> 00:50:49.130
But in fact, the user has dragged the
scroll view over to there.

00:50:49.130 --> 00:50:53.180
So we want to calculate how much
did we overshoot the perfect offset.

00:50:53.180 --> 00:50:59.380
And I'm doing that by taking,
I'm modding the actual offset.

00:50:59.460 --> 00:51:03.270
So I'm going to take the offset X by the
width of one of my little cubes to see

00:51:03.270 --> 00:51:05.180
how far into a little cube did we get.

00:51:05.610 --> 00:51:08.440
So now that I've
calculated that overshoot,

00:51:08.440 --> 00:51:11.490
I'm going to see, well,
did we overshoot by less than half

00:51:11.490 --> 00:51:13.430
or more than half of a little cube?

00:51:13.480 --> 00:51:15.300
Because if it's less than half,
we want to round down,

00:51:15.300 --> 00:51:17.240
and if it's more than half,
we're going to want to round up.

00:51:17.460 --> 00:51:23.460
So if the overshoot is less than
half of a little cube width,

00:51:23.460 --> 00:51:27.700
then we will make our offset X,
we'll subtract the

00:51:27.700 --> 00:51:29.460
overshoot from the offset.

00:51:29.460 --> 00:51:34.320
If it was more than half
of a little cube width,

00:51:34.540 --> 00:51:37.350
then we'll add on the rest
of that little cube width.

00:51:37.500 --> 00:51:39.460
So that's the little cube
width minus the overshoot.

00:51:39.460 --> 00:51:43.460
And then we're just going to return
the new offset that we calculated.

00:51:43.500 --> 00:51:45.460
All right, so let's call that from
our view controller.

00:51:45.460 --> 00:51:47.610
Once again,
we're going to add a final view

00:51:47.780 --> 00:51:51.340
controller delegate method,
the one that Josh just mentioned.

00:51:51.490 --> 00:51:53.460
Let me give us more room.

00:51:53.460 --> 00:51:55.930
So in this scroll view will
end dragging with velocity

00:51:55.930 --> 00:51:59.460
target content offset method,
we're going to add a new offset.

00:51:59.460 --> 00:52:03.460
So we're going to take the target content
offset here that you can see at the end,

00:52:03.460 --> 00:52:07.400
and we're going to pass that to our
cube view as the proposed offset.

00:52:07.530 --> 00:52:12.410
So we're going to say the new target
content offset that we're going to return

00:52:12.560 --> 00:52:17.730
via this in-out parameter is the result
of passing the one we were given to this

00:52:17.730 --> 00:52:19.460
scroll offset for proposed offset method.

00:52:19.460 --> 00:52:21.460
And that's pretty much it.

00:52:21.460 --> 00:52:27.460
So if I run this now,
you can see that when I scroll,

00:52:27.460 --> 00:52:31.420
it sort of decelerates slowly
to the exact right point.

00:52:31.530 --> 00:52:35.460
If I even were to drag a little way
into a cube and let go with no momentum,

00:52:35.460 --> 00:52:39.460
it would still come back to the
page boundary that we wanted.

00:52:39.460 --> 00:52:44.180
So that's a pretty useful
method that I think is cool

00:52:44.180 --> 00:52:45.460
that got added back in iOS 5.

00:52:45.460 --> 00:52:49.150
So that's pretty much it for my demos,
and I'm going to turn it back

00:52:49.150 --> 00:52:51.460
over to Josh to finish up.

00:52:57.700 --> 00:52:59.300
All right, well, thanks again for coming.

00:52:59.300 --> 00:53:03.080
If you have any more questions about
any of the content on the session here,

00:53:03.090 --> 00:53:06.760
Jake Behrens is the
UI Frameworks evangelist.

00:53:07.020 --> 00:53:09.870
If you want any more
documentation about Scroll View,

00:53:09.870 --> 00:53:13.380
of course, that's the Scroll View link
at developer.apple.com and

00:53:13.380 --> 00:53:15.010
obviously the dev forums.

00:53:15.020 --> 00:53:17.660
There's a couple of related
sessions later still this week.

00:53:17.700 --> 00:53:20.180
The Introducing Collection Views session.

00:53:20.280 --> 00:53:23.040
If you haven't seen the new
collection views introduced in iOS 6,

00:53:23.040 --> 00:53:24.640
this stuff is pretty cool.

00:53:24.640 --> 00:53:27.280
And you can learn all
about it in the repeat.

00:53:27.370 --> 00:53:29.120
Thursday at 9:00 AM.

00:53:29.230 --> 00:53:32.170
And then Building Advanced Gesture
Recognizers is also tomorrow,

00:53:32.170 --> 00:53:35.370
Thursday at 11:30 AM,
where we'll talk more about

00:53:35.370 --> 00:53:37.520
awesome things you can do
with gesture recognizers,

00:53:37.520 --> 00:53:39.920
if you haven't seen a lot about that yet.

00:53:40.030 --> 00:53:42.280
There's also a
Scroll View Lab tomorrow morning,

00:53:42.280 --> 00:53:43.740
first thing in the morning, 9:00 AM.

00:53:43.840 --> 00:53:46.000
So if you have more
Scroll View questions,

00:53:46.000 --> 00:53:47.270
come see us there.

00:53:47.380 --> 00:53:49.050
Thanks for coming.
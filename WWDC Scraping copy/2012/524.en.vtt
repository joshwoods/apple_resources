WEBVTT

00:00:10.730 --> 00:00:11.670
Good morning.

00:00:11.730 --> 00:00:13.300
Welcome to Understanding Core Motion.

00:00:13.420 --> 00:00:15.500
For those of you who
are new to Core Motion,

00:00:15.500 --> 00:00:18.300
this talk will provide an
overview of the framework,

00:00:18.320 --> 00:00:21.370
as well as helpful hints and
techniques for you to help

00:00:21.520 --> 00:00:23.120
bootstrap your motion-able apps.

00:00:23.120 --> 00:00:31.890
For those of you who are already
familiar with Core Motion,

00:00:31.890 --> 00:00:33.290
we'll dig deeper into sensor
and algorithm performance.

00:00:33.950 --> 00:00:37.980
Explore capabilities, usages,
help you refine ideas you have

00:00:37.980 --> 00:00:41.700
for your existing applications,
or perhaps come up with

00:00:41.700 --> 00:00:43.140
ideas for new ones.

00:00:43.240 --> 00:00:46.660
Additionally,
I'll also take you through the process

00:00:46.790 --> 00:00:51.440
of using Core Motion from A to Z,
pointing out design considerations

00:00:51.440 --> 00:00:53.750
and best practices along the way.

00:00:53.810 --> 00:00:59.560
And we will culminate today's talk by
reiterating some of the concepts we've

00:00:59.600 --> 00:01:02.760
covered today with a couple of demos.

00:01:02.830 --> 00:01:07.300
The code for which are going to be
available for download after this talk.

00:01:07.530 --> 00:01:12.790
So Core Motion is about the
sensors and sensor fusion.

00:01:12.800 --> 00:01:15.780
And I'm going to start with the sensors.

00:01:16.520 --> 00:01:20.590
We shipped the accelerometer
with the very first iPhone,

00:01:20.590 --> 00:01:23.480
and it's been really popular ever since.

00:01:23.500 --> 00:01:27.550
The accelerometer measures
gravitational as well as inertial

00:01:27.610 --> 00:01:29.280
forces that impinge upon it.

00:01:29.400 --> 00:01:33.190
What that means for you as a
developer is that there's actually

00:01:33.190 --> 00:01:37.840
quite a bit that you can do with it,
because if you can measure gravity,

00:01:37.850 --> 00:01:42.260
or to be more precise,
if you can figure out how gravity is

00:01:42.390 --> 00:01:47.080
oriented with respect to the device,
you can back out its pose, its attitude,

00:01:47.150 --> 00:01:48.750
its tip, or its tilt.

00:01:48.800 --> 00:01:53.200
And that's the principle behind
apps such as the iHandy Leveler,

00:01:53.200 --> 00:01:57.650
which surprisingly remains
one of the most popular apps

00:01:57.780 --> 00:02:01.340
among sensor-enabled apps,
I should say.

00:02:01.340 --> 00:02:05.900
So besides gravity,
you can ignore it altogether.

00:02:05.900 --> 00:02:09.310
For instance,
assume only horizontal motion.

00:02:09.320 --> 00:02:13.680
And that's the principle behind
games such as Shufflepuck,

00:02:14.120 --> 00:02:15.460
or Goff-Puck.

00:02:15.890 --> 00:02:17.880
Excuse me, Goff-Putt.

00:02:17.880 --> 00:02:24.320
The thing I like about the accelerometer
is that it is very efficient.

00:02:24.360 --> 00:02:27.610
To give you a sense of
how efficient it is,

00:02:27.750 --> 00:02:32.680
compared to the magnetometer,
it consumes 10 times less power,

00:02:32.680 --> 00:02:35.880
40 times less power than the gyro.

00:02:36.120 --> 00:02:42.220
What this means for you as a developer
is that if you are power conscious,

00:02:42.280 --> 00:02:46.590
You can still afford to be lax about
how long you run the accelerometer.

00:02:46.710 --> 00:02:52.200
Or you may want to look at the
accelerometer first as the first stop.

00:02:52.200 --> 00:02:53.650
It's also very responsive.

00:02:53.660 --> 00:02:55.980
And what I mean by that,
or what it means for you,

00:02:56.040 --> 00:02:59.570
is that you're going to be able to afford
to filter it much more aggressively

00:02:59.720 --> 00:03:01.650
if you need a really clean signal.

00:03:03.670 --> 00:03:07.440
You have to be careful, though,
about using the accelerometer by itself.

00:03:07.470 --> 00:03:12.070
And the reason is because of ambiguity.

00:03:12.100 --> 00:03:14.370
And to get a sense of
what I mean by that,

00:03:14.460 --> 00:03:16.070
take a look at this plot behind me.

00:03:16.100 --> 00:03:19.930
This shows basically the output
of the three-axis accelerometer.

00:03:19.930 --> 00:03:21.780
I'm only looking at the X and Y.

00:03:21.780 --> 00:03:26.150
And you can, just from basis on the plot,
you would be tempted to assume

00:03:26.150 --> 00:03:30.310
that that trajectory resulted from
a pure rotation of that device,

00:03:30.310 --> 00:03:31.080
right?

00:03:31.490 --> 00:03:34.360
First, it's canted at some angle,
so both the X and the Y axes

00:03:34.620 --> 00:03:36.460
pick up some measure of gravity.

00:03:36.460 --> 00:03:41.260
And then as the device is
rotated through a vertical,

00:03:41.260 --> 00:03:43.660
now all of the gravity
is sensed in the Y axis,

00:03:43.830 --> 00:03:45.430
and none of it is sensed in the X.

00:03:45.580 --> 00:03:49.580
But in fact,
that trajectory was created from a

00:03:49.580 --> 00:03:52.570
much more complex set of motions.

00:03:53.100 --> 00:03:59.550
Because you probably recall from
your first semester dynamics class,

00:03:59.550 --> 00:04:00.540
right?

00:04:02.700 --> 00:06:40.600
[Transcript missing]

00:06:41.500 --> 00:06:46.090
But the sensor is on the device,
which contains contributions from

00:06:46.090 --> 00:06:48.040
a lot of the nearby electric field.

00:06:48.150 --> 00:06:51.560
You've got electronics,
you've got electrons

00:06:51.560 --> 00:06:55.940
zipping down the traces,
you've got magnet speakers.

00:06:55.950 --> 00:06:58.570
All of these generate
a net magnetic field,

00:06:58.570 --> 00:07:02.010
which is going to cause your
reading to be offset by some

00:07:02.010 --> 00:07:05.020
potentially huge amount,
which is going to cause

00:07:05.080 --> 00:07:06.900
your heading to be off,
right?

00:07:07.640 --> 00:07:12.190
Now, it's interesting that
those contributions,

00:07:12.190 --> 00:07:16.330
since they travel with the sensor,
if you were to rotate your device

00:07:16.330 --> 00:07:20.600
again through a complete circle,
you'll trace yet another circle,

00:07:20.900 --> 00:07:24.860
and the center of that circle is going
to be offset by the net contribution of

00:07:24.870 --> 00:07:27.360
those disturbances that I talked about.

00:07:27.360 --> 00:07:33.780
So if you know that net offset,
then you can basically

00:07:33.780 --> 00:07:35.010
back out your new heading.

00:07:35.220 --> 00:07:39.490
And so that's the principle behind a lot
of the calibrations behind the compass.

00:07:39.570 --> 00:07:42.550
And I bring that up here because, again,
if you're going to use

00:07:42.620 --> 00:07:48.620
the raw magnetometers,
you have to be aware of both the

00:07:48.620 --> 00:07:51.030
contributions from the device
and also what you'll need to do

00:07:51.030 --> 00:07:51.030
to take that contribution out.

00:07:52.060 --> 00:07:55.410
After the magnetometer,
we started shipping the

00:07:55.410 --> 00:07:58.890
gyros with the-- 3GS.

00:07:59.040 --> 00:08:05.310
The gyro is actually one
of my favorite sensors.

00:08:05.310 --> 00:08:05.310
It is my favorite sensor.

00:08:05.310 --> 00:08:05.310
The reason I like the gyro is because,
unlike the other sensors,

00:08:05.310 --> 00:08:05.310
it's very precise.

00:08:05.920 --> 00:08:06.560
There's no ambiguity.

00:08:06.560 --> 00:08:09.670
It's going to measure
rotation and only rotation.

00:08:09.750 --> 00:08:11.330
It doesn't matter what
that device is doing.

00:08:11.330 --> 00:08:13.530
It's only going to pick
up the rotational part,

00:08:13.710 --> 00:08:15.680
the spin part of what
that device is doing.

00:08:15.680 --> 00:08:16.600
So it's very, very precise.

00:08:16.600 --> 00:08:17.770
So it's good for free space motion.

00:08:17.880 --> 00:08:19.580
You don't have to worry
about constraining it.

00:08:19.580 --> 00:08:21.740
You don't have to say, oh, you know,
I'm only going to use it in

00:08:21.740 --> 00:08:23.000
quasi-static state conditions.

00:08:23.000 --> 00:08:25.120
You're going to pick up
spin no matter what you do.

00:08:25.220 --> 00:08:26.500
So it's very, very responsive.

00:08:28.320 --> 00:08:31.180
The other thing I like about the sensor,
it's got a great dynamic range,

00:08:31.180 --> 00:08:34.480
which means that you're not going to
worry about saturating the sensor.

00:08:34.480 --> 00:08:35.800
You can use it however you want.

00:08:36.050 --> 00:08:38.140
Your user is going to use
your app however they want,

00:08:38.140 --> 00:08:40.660
and you don't really need
to worry about saturation.

00:08:43.300 --> 00:08:44.300
And as we said before, it's very precise.

00:08:44.440 --> 00:08:47.100
So since it does such a good
job with measuring spin,

00:08:47.100 --> 00:08:50.910
you're going to -- might be tempted
to want to integrate the signal to

00:08:50.910 --> 00:08:54.060
get the attitude because a lot of
games are really interested in where

00:08:54.060 --> 00:08:57.060
that device is pointing or where
the user is pointing that device.

00:08:57.390 --> 00:09:00.300
I would caution you against that.

00:09:00.300 --> 00:09:03.670
And the reason is because the gyro,
just like any sensor,

00:09:03.770 --> 00:09:08.200
it's going to contain some bias,
some non-zero reading while it's at rest.

00:09:08.350 --> 00:09:10.090
And that's going to be
common to any sensor.

00:09:10.360 --> 00:09:12.260
And in fact, this gyro is actually
very good about that.

00:09:12.370 --> 00:09:17.300
The bias offset is only about 1/100th
percent of its full dynamic range.

00:09:17.300 --> 00:09:20.290
So it's still a very good sensor,
but there is a bias.

00:09:20.300 --> 00:09:24.660
And that bias is non-zero so that
if you integrate that bias over

00:09:24.660 --> 00:09:29.300
time to try to get the attitude,
you know, within half a minute,

00:09:29.300 --> 00:09:33.280
you're essentially going to be pointing
45 degrees off from where you want to be.

00:09:33.410 --> 00:09:38.300
So again, you want to be careful about
integrating your measurements.

00:09:38.300 --> 00:09:42.160
So you're sitting there
and you're thinking,

00:09:42.160 --> 00:09:46.080
well, you told me I can't use
the gyro to get attitude,

00:09:46.080 --> 00:09:48.210
but I really need attitude.

00:09:48.300 --> 00:09:52.530
I can use the accelerometer to
give me the tip and the tilt,

00:09:52.540 --> 00:09:56.300
but only under quasi-static
state conditions.

00:09:56.300 --> 00:09:58.030
And the magnetometer
is great for heading,

00:09:58.030 --> 00:10:00.290
but I got to be wary about
all these other conditions.

00:10:00.300 --> 00:10:04.210
So what if --

00:10:04.950 --> 00:10:08.150
What if we can combine all
three of those sensors,

00:10:08.150 --> 00:10:13.990
fuse them all together to give you
basically the pointing stability of

00:10:13.990 --> 00:10:19.650
the magnetometer and the accelerometer
and the responsiveness of the gyro?

00:10:19.700 --> 00:10:21.240
And you could do that.

00:10:21.290 --> 00:10:24.930
We also do that for you,
and that's device motion.

00:10:25.070 --> 00:10:25.900
That's sensor fusion.

00:10:25.900 --> 00:10:31.460
It's basically going to be
able to give you accurate,

00:10:31.830 --> 00:10:37.100
responsive estimates of the
device's pose and motion throughout

00:10:37.100 --> 00:10:38.180
the entire range of motion.

00:10:38.180 --> 00:10:42.520
Use device motion,
use sensor fusion for your games if

00:10:42.520 --> 00:10:44.860
you need that full range of motion.

00:10:44.860 --> 00:10:47.470
If you need that responsiveness.

00:10:47.630 --> 00:10:48.430
You're racing games.

00:10:48.430 --> 00:10:49.980
If you need it to be more responsive.

00:10:49.980 --> 00:10:53.800
Your first-person shooter game,
if you need it to be more tight.

00:10:53.900 --> 00:10:57.460
Your augmented reality game,
if you need it to be more real.

00:10:57.540 --> 00:11:01.890
That's not to say that sensor fusion
is going to be the be-all and end-all.

00:11:01.900 --> 00:11:03.690
You'll always want to use sensor fusion.

00:11:03.700 --> 00:11:06.600
That's not what I mean because there
are going to be certain instances

00:11:06.600 --> 00:11:08.290
where you want to use the raw sensor.

00:11:08.300 --> 00:11:10.000
Accelerometer, for instance.

00:11:10.070 --> 00:11:11.900
We already said it's great for attitude.

00:11:11.900 --> 00:11:12.850
It's great for shape.

00:11:13.120 --> 00:11:15.580
But again, be careful about ambiguity.

00:11:15.600 --> 00:11:18.300
The magnetometer, good for heading.

00:11:18.300 --> 00:11:20.590
The gyro, great for spin.

00:11:20.600 --> 00:11:23.760
But again,
the sensor fusion is the one that,

00:11:24.320 --> 00:11:28.260
removes the uncertainty about
ambiguity so that you can get attitude.

00:11:28.310 --> 00:11:31.000
It does a lot of calibration
so you get the heading.

00:11:31.000 --> 00:11:33.940
And of course, it gives you the spin and
it gives you the shape.

00:11:34.230 --> 00:11:38.190
So, that, it gives you all of that.

00:11:38.560 --> 00:11:40.300
So,

00:11:40.750 --> 00:11:49.280
With that, let's dig a little deeper
into sensor fusion.

00:11:49.530 --> 00:11:54.800
We'll take a look at what it does,
what it gives you,

00:11:54.800 --> 00:11:54.800
what sensor fusion gives you,
and we'll just dive a little

00:11:54.800 --> 00:11:54.800
deeper into the framework.

00:11:56.030 --> 00:11:59.230
Your starting point is going
to be the Motion Manager.

00:11:59.430 --> 00:12:01.400
That essentially is your gateway.

00:12:01.400 --> 00:12:02.890
It's going to run in
your application space.

00:12:02.900 --> 00:12:05.030
You're going to create an
instance to the Motion Manager,

00:12:05.030 --> 00:12:08.400
and then through it,
you're going to specify what you want,

00:12:08.400 --> 00:12:12.790
whether you want the raw sensors
or whether you want sensor fusion.

00:12:13.080 --> 00:12:16.070
You're also going to specify
how often you want that data,

00:12:16.230 --> 00:12:19.400
and also you'll start
and stop the updates.

00:12:19.550 --> 00:12:20.880
That's all it is.

00:12:20.970 --> 00:12:23.540
So within the Motion framework,

00:12:24.230 --> 00:12:27.470
You'll get,
depending on your requirements,

00:12:27.590 --> 00:12:32.520
you'll get the raw accelerometer data,
the gyro, the magnetometer.

00:12:32.760 --> 00:12:34.610
We give that raw to you.

00:12:34.700 --> 00:12:37.040
We also give you the sensor fusion.

00:12:37.130 --> 00:12:39.170
See on device motion.

00:12:39.960 --> 00:12:47.700
So, sensor fusion, what it gives you,
and this is actually the meat of it,

00:12:49.100 --> 00:12:51.090
You'll get gravity.

00:12:51.110 --> 00:12:56.540
Again, this is gravity in a completely
unconstrained motion.

00:12:56.540 --> 00:12:59.700
Not the steady-state gravity,
but the dynamic gravity.

00:12:59.700 --> 00:13:03.490
It'll also disambiguate the
user acceleration for you.

00:13:04.640 --> 00:13:06.330
You also get the rotation rate.

00:13:06.330 --> 00:13:09.490
The difference between this one
and the raw gyro is that this one

00:13:09.540 --> 00:13:11.280
is going to be bias compensated.

00:13:11.280 --> 00:13:14.480
And then we give you the attitude
and also the magnetic field.

00:13:14.480 --> 00:13:16.780
And again,
the difference here between this

00:13:16.780 --> 00:13:20.090
one and the raw magnetic field is
that this is also bias compensated

00:13:20.170 --> 00:13:21.970
or disturbance has been removed.

00:13:22.120 --> 00:13:23.890
The sensor has been calibrated.

00:13:24.520 --> 00:13:26.100
So we'll start with
the user acceleration.

00:13:26.100 --> 00:13:28.100
It's a property of device motion.

00:13:28.160 --> 00:13:30.890
It's a struct CM acceleration.

00:13:30.890 --> 00:13:34.700
And it's essentially -- it's just the
inertial acceleration seen by the device.

00:13:34.850 --> 00:13:35.700
We remove gravity.

00:13:35.700 --> 00:13:36.900
That's all it is.

00:13:37.660 --> 00:13:40.550
The units are going to be in gravities.

00:13:40.550 --> 00:13:43.780
So one is 9.8 meters a second squared.

00:13:43.840 --> 00:13:46.240
And it's a struct just double XYZ.

00:13:46.410 --> 00:13:48.890
Nothing mysterious about it.

00:13:49.560 --> 00:13:50.740
Gravity.

00:13:50.740 --> 00:13:53.940
It's the same struct as user
acceleration as you would expect.

00:13:53.940 --> 00:13:55.400
The units are going to be the same.

00:13:55.500 --> 00:13:57.720
To describe gravity or
what we give for you,

00:13:57.830 --> 00:13:59.160
so take a look at this, right?

00:13:59.330 --> 00:14:01.960
Suppose you had a device that
was sitting flat on the table.

00:14:01.960 --> 00:14:07.830
You would expect that the horizontal
components of the gravity would be zero.

00:14:08.280 --> 00:14:11.830
Now, if you were to move that
device back and forth,

00:14:12.040 --> 00:14:15.980
You would get that kind of
signal on the X and Y axis.

00:14:16.070 --> 00:14:19.590
Now, without a priori assumptions
about whether that device

00:14:19.750 --> 00:14:23.110
is flat on the table or not,
you don't really know what gravity

00:14:23.120 --> 00:14:25.260
looks like throughout all this.

00:14:25.400 --> 00:14:34.040
But because sensor fusion knows
what the attitude of the device is,

00:14:34.040 --> 00:14:34.590
and it knows that in real time,
we can project that signal.

00:14:35.120 --> 00:14:39.640
on to the gravitational axis
and get what we estimate

00:14:39.780 --> 00:14:41.360
gravity is going to look like.

00:14:41.500 --> 00:14:43.890
And so as you can see,
it does a fairly good job

00:14:43.890 --> 00:14:47.100
of extracting gravity out,
disambiguating that from

00:14:47.220 --> 00:14:48.950
the user acceleration.

00:14:49.970 --> 00:14:52.660
The rotation rate,
that's just the device's spin.

00:14:52.700 --> 00:14:56.560
And again, as we said before,
it's corrected for bias.

00:14:56.690 --> 00:14:59.260
The units are gonna be
in radians per second.

00:14:59.320 --> 00:15:02.040
And the struct, again,
is gonna be given as x, y, z.

00:15:02.060 --> 00:15:05.160
Again, these are rotations following
the right-hand rule.

00:15:05.160 --> 00:15:09.080
So when we say rotation rate dot x,
it's essentially the

00:15:09.090 --> 00:15:11.210
rotation about the x-axis.

00:15:11.980 --> 00:15:13.900
The magnetic field.

00:15:14.000 --> 00:15:17.900
So this is given as a struct called
CM Calibrated Magnetic Field,

00:15:17.950 --> 00:15:21.690
and it's basically the nearby
magnetic field from everything.

00:15:23.140 --> 00:15:24.580
Corrected for bias.

00:15:24.670 --> 00:15:27.890
So again, when we talk about the device,
it's basically the magnetic field of

00:15:27.890 --> 00:15:29.580
everything external to your device.

00:15:29.580 --> 00:15:33.660
We calibrate it for the contributions
that are coming from the device.

00:15:33.700 --> 00:15:38.770
And it's filtered
because it's quite noisy.

00:15:39.450 --> 00:15:41.610
The results are stored in a struct.

00:15:41.650 --> 00:15:42.770
The struct contains two elements.

00:15:42.920 --> 00:15:46.320
One is the field itself,
and the other one is a measure of

00:15:46.320 --> 00:15:50.720
the accuracy you should expect if
you were to use this field that we

00:15:50.720 --> 00:15:55.400
give you in terms of how well we
think we've calibrated the device.

00:15:57.400 --> 00:16:02.100
So again, the magnetic field,
nothing surprising there.

00:16:02.100 --> 00:16:02.880
XYZ.

00:16:03.150 --> 00:16:06.370
The units are going to be micro-Tesla.

00:16:06.990 --> 00:16:09.600
Look,
it sounds like I'm repeating myself,

00:16:09.700 --> 00:16:10.380
you know, the units.

00:16:10.400 --> 00:16:12.760
I keep bringing the units back up.

00:16:12.910 --> 00:16:15.970
But I think it's an important
point enough to belabor because

00:16:16.040 --> 00:16:18.200
the units are so important,
right?

00:16:18.200 --> 00:16:25.860
Misunderstanding of units are the
cause of so many falling bridges,

00:16:26.000 --> 00:16:28.780
satellites lost in space, right?

00:16:29.180 --> 00:16:30.620
Much suffering in guilders.

00:16:30.820 --> 00:16:33.840
So I'm going to keep
hammering on the units.

00:16:34.220 --> 00:16:37.040
In addition to the magnetic field,
we provide what the

00:16:37.090 --> 00:16:38.650
calibration accuracy is.

00:16:38.730 --> 00:16:41.360
And I'm just going to go
through the enums real quickly.

00:16:41.360 --> 00:16:44.380
The first one is uncalibrated minus one.

00:16:44.380 --> 00:16:47.610
What that means is that if
the field that you get has

00:16:47.620 --> 00:16:51.350
uncalibrated level of accuracy,
it's essentially a random

00:16:51.690 --> 00:16:55.130
number generator for you
in terms of the heading.

00:16:56.570 --> 00:16:57.620
Low means it's marginal.

00:16:57.760 --> 00:17:00.280
You can get something out of it,
but you certainly wouldn't

00:17:00.420 --> 00:17:01.320
want to bet money on it.

00:17:01.370 --> 00:17:03.990
You really want to live around
the medium and the high.

00:17:03.990 --> 00:17:05.910
And again,
I'll tell you a little bit later

00:17:05.910 --> 00:17:08.800
of how you can prompt the user to
recalibrate the device so that you

00:17:08.800 --> 00:17:10.860
can improve the calibration accuracy.

00:17:14.220 --> 00:17:18.500
This is the core of device motion.

00:17:18.500 --> 00:17:19.130
It's the attitude.

00:17:19.220 --> 00:17:22.710
Everything we've done up to this
point essentially has been a byproduct

00:17:22.820 --> 00:17:24.120
of trying to get the attitude.

00:17:24.120 --> 00:17:27.050
And the attitude we presented,
the attitude is just

00:17:27.050 --> 00:17:28.940
the pose of the device,
right?

00:17:29.000 --> 00:17:30.390
It's how it sits in 3D space.

00:17:30.440 --> 00:17:32.100
We provide it in three flavors.

00:17:32.160 --> 00:17:36.070
Euler angles, quaternions,
and rotation matrices.

00:17:36.070 --> 00:17:40.160
Euler angles because it's intuitive.

00:17:40.160 --> 00:17:44.160
It's basically going to
be presented as doubles,

00:17:44.160 --> 00:17:45.190
roll, pitch, and yaw.

00:17:45.220 --> 00:17:48.160
And it's easily visualized,
so you're going to want to use

00:17:48.160 --> 00:17:51.180
Euler angles if you're going to
express the pose of the device

00:17:51.420 --> 00:17:52.870
through any user interface.

00:17:53.080 --> 00:17:55.090
And it's also familiar to the user.

00:17:55.100 --> 00:17:57.900
And so we provide it as a convenience.

00:17:57.900 --> 00:18:01.380
But mathematically, it's very,
very difficult to use, as you know.

00:18:01.380 --> 00:18:02.140
It's not.

00:18:02.160 --> 00:18:03.050
Efficient.

00:18:03.180 --> 00:18:05.010
It's not unambiguous.

00:18:05.170 --> 00:18:07.460
And you have the gimbal
lock issue problem.

00:18:07.460 --> 00:18:09.920
So we also provide quaternions.

00:18:09.950 --> 00:18:12.060
Quaternions, elegant.

00:18:12.110 --> 00:18:15.380
You can represent everything
through four scalars.

00:18:15.920 --> 00:18:19.870
Computationally, it's very,
very efficient and also avoids

00:18:19.950 --> 00:18:20.730
the gimbal lock problem.

00:18:20.740 --> 00:18:23.700
Another great thing
about the quaternions,

00:18:23.700 --> 00:18:27.410
as you probably already know,
provides smooth interpolation.

00:18:27.420 --> 00:18:30.280
So if you started out one
quaternion and you want to get to

00:18:30.280 --> 00:18:34.230
the other pose defined by the other
quaternion and you interpolate that,

00:18:34.550 --> 00:18:37.280
then your motion in real
space will also be very,

00:18:37.280 --> 00:18:38.220
very smooth.

00:18:38.220 --> 00:18:39.840
So that's a great
property of quaternions.

00:18:39.860 --> 00:18:46.560
So I like quaternions, but unfortunately,
oh, and it's given as WXYZ.

00:18:46.600 --> 00:18:52.560
Unitless, because it's some imaginary
fictitious concept.

00:18:52.560 --> 00:18:58.320
So we provide some utilities to
get you from the quaternions that

00:18:58.320 --> 00:19:00.780
you work with back to other angles.

00:19:00.780 --> 00:19:02.560
So let's take this example.

00:19:02.560 --> 00:19:04.360
You're going to start
out with a quaternion.

00:19:04.360 --> 00:19:06.740
So you're going to get it
from the device motion,

00:19:06.740 --> 00:19:09.520
motion manager.devicemotion.quaternion.

00:19:09.520 --> 00:19:11.240
And let's say you do some math with it.

00:19:11.410 --> 00:19:13.310
The point of this is not to
show you the quaternion math,

00:19:13.390 --> 00:19:14.790
but let's just say,
you can do some math with it.

00:19:14.880 --> 00:19:15.660
Right?

00:19:15.660 --> 00:19:17.410
And then again,
we provide the utilities so

00:19:18.320 --> 00:19:22.520
that at the end of all of that,
you can take your rotated quaternion

00:19:22.520 --> 00:19:24.650
and convert it back to roll,
pitch, and yaw.

00:19:24.780 --> 00:19:27.110
So everything is defined
in motionutils.h.

00:19:27.300 --> 00:19:28.220
Go ahead and check it out.

00:19:28.220 --> 00:19:30.810
It has a bunch of handy utilities
that go back and forth between

00:19:30.850 --> 00:19:32.240
older angles and quaternions.

00:19:32.260 --> 00:19:33.680
All right.

00:19:36.860 --> 00:19:42.840
If you're like some of those
developers who prefer to...

00:19:43.600 --> 00:19:46.430
I don't know,
eat broken glass in the morning rather

00:19:46.540 --> 00:19:48.300
than granola to get yourself going.

00:19:48.300 --> 00:19:51.530
If you like your math straight up.

00:19:52.890 --> 00:19:57.160
You want to do things in 3x3 matrices?

00:19:57.320 --> 00:19:57.770
That's fine.

00:19:57.990 --> 00:19:59.700
We give you rotation matrices.

00:19:59.700 --> 00:20:00.960
It's 3D representation.

00:20:01.050 --> 00:20:02.350
Like I said, it's math straight up.

00:20:02.410 --> 00:20:05.500
It's just math matrix, linear algebra,
stuff that you know

00:20:05.580 --> 00:20:06.930
from freshman college.

00:20:07.000 --> 00:20:10.320
We present it as a 3x3 struct.

00:20:10.320 --> 00:20:14.760
Elements are M11 all the way to M33.

00:20:14.760 --> 00:20:16.200
Again, no great mystery there.

00:20:16.200 --> 00:20:19.440
So I'm going to give you a
flavor of how you could do some

00:20:19.440 --> 00:20:21.550
operations with a matrix math.

00:20:21.930 --> 00:20:25.280
So let's take a look
at this sample snippet.

00:20:25.370 --> 00:20:31.540
This is actually -- we pulled this from
the demo that we're going to show later.

00:20:31.790 --> 00:20:34.700
and it's also going to be in that
code that's available for download.

00:20:34.700 --> 00:20:39.240
So suppose you had some GLK base effect,
and I'm not going to talk about

00:20:39.630 --> 00:20:44.700
how you initialize that and such,
but basically what you want to do is,

00:20:44.700 --> 00:20:46.700
you want to define some
operations on that object,

00:20:46.760 --> 00:20:50.280
and then you also want to then
apply the transformation that comes

00:20:50.280 --> 00:20:52.680
from the attitude of that device,
right?

00:20:52.700 --> 00:20:55.630
So let's get the attitude of
the device from DeviceMotion,

00:20:55.720 --> 00:20:58.700
and that's going to be a rotation matrix.

00:20:58.700 --> 00:21:02.700
So that's going to be r equals
MotionManager.DeviceMotion.RotationMatrix

00:21:03.570 --> 00:21:03.700
.

00:21:03.700 --> 00:21:07.680
Now, we're going to convert that 3 by
3 into a homogeneous transform.

00:21:07.780 --> 00:21:10.700
And again,
it's not the point of this thing,

00:21:10.700 --> 00:21:14.690
but basically it's going to include the
rotation piece and the translation piece,

00:21:14.700 --> 00:21:15.700
right, and then the one at the bottom.

00:21:15.740 --> 00:21:20.760
And that's just to get it into
that 4 by 4 so that we can use the

00:21:20.760 --> 00:21:22.650
matrix math that comes with that.

00:21:22.770 --> 00:21:27.300
And we get the--we establish
the model view of that object

00:21:27.320 --> 00:21:30.680
that we talked about earlier,
the GLK base effect,

00:21:30.810 --> 00:21:33.700
and then we're just going
to rotate it by pi over 3.

00:21:33.700 --> 00:21:36.700
And then in addition to that
rotation on that object,

00:21:36.700 --> 00:21:39.090
we're basically going to--

00:21:39.140 --> 00:21:42.030
Do another--we're gonna do the
transformation between our view,

00:21:42.070 --> 00:21:45.150
which is defined by the-- our
rotation matrix from the device

00:21:45.150 --> 00:21:49.080
motion and the rotation of the device,
and you just chain them together.

00:21:49.100 --> 00:21:50.100
That's it.

00:21:50.100 --> 00:21:56.050
And then when you basically
just update the view,

00:21:56.050 --> 00:21:59.260
you'll see the rotation.

00:21:59.260 --> 00:22:00.090
So it's really pretty neat.

00:22:00.090 --> 00:22:00.090
I'm sorry,
I seem to have gotten ahead of myself.

00:22:04.540 --> 00:22:06.390
That's it for attitude.

00:22:06.560 --> 00:22:10.760
But when we talk about attitude,
that presupposes a reference frame.

00:22:12.090 --> 00:22:15.440
And the reference frames that we use,
we actually allow you,

00:22:15.440 --> 00:22:18.000
the application developer, to specify.

00:22:18.000 --> 00:22:19.790
There's four of them.

00:22:19.920 --> 00:22:22.970
And I'm just gonna go through them.

00:22:23.250 --> 00:22:25.830
They all start out with
CM Attitude Reference Frame,

00:22:25.830 --> 00:22:29.600
but they're essentially
distinguished by one being arbitrary,

00:22:29.730 --> 00:22:33.100
another one essentially
being heading corrected,

00:22:33.100 --> 00:22:35.450
the other one,
the third one means that we

00:22:35.450 --> 00:22:37.970
peg it to magnetic north,
and the fourth means we

00:22:37.970 --> 00:22:39.100
peg it to true north.

00:22:40.150 --> 00:22:43.120
Then I'll go again into those in
greater detail in the following slides.

00:22:43.380 --> 00:22:49.210
And we allow you to query which of
these are going to be available,

00:22:49.210 --> 00:22:53.180
because by specifying one of
those four reference frames,

00:22:53.180 --> 00:22:57.140
you are going to specify the flavor of
sensor fusion that you're going to use.

00:22:57.720 --> 00:22:58.120
That's really important.

00:22:58.170 --> 00:22:59.780
But I'm going to say that again.

00:22:59.780 --> 00:23:03.840
You're going to specify the flavor of
the sensor fusion you use by specifying

00:23:03.930 --> 00:23:06.080
one of those four reference frames.

00:23:07.120 --> 00:23:09.100
And the reason why that's important
is because not all devices are

00:23:09.100 --> 00:23:09.110
going to have the same sensor
fusion as the other devices.

00:23:09.180 --> 00:23:10.660
are going to have all these sensors.

00:23:11.360 --> 00:23:13.720
'Cause you're going to want
to build your app once,

00:23:13.720 --> 00:23:17.000
and then it's going to, you know,
potentially run on the iPod-- iPod

00:23:17.110 --> 00:23:19.320
Touch versus the iPhone versus the iPad.

00:23:19.320 --> 00:23:20.520
And so you want to be very careful.

00:23:20.520 --> 00:23:22.220
And so that's why we
provide that bit master,

00:23:22.220 --> 00:23:25.110
that you can query the device
to see what's available before

00:23:25.120 --> 00:23:27.910
you go and start the updates.

00:23:27.940 --> 00:23:30.350
So once you've specified
the reference frame,

00:23:30.420 --> 00:23:33.050
then you essentially just
tell Device Motion to start

00:23:33.220 --> 00:23:37.010
sending you updates by calling
startDeviceMotionUpdates

00:23:37.090 --> 00:23:39.120
using the reference frame.

00:23:39.300 --> 00:23:40.320
So that's it.

00:23:40.320 --> 00:23:41.960
So again, coming back to the
reference frame choices,

00:23:42.050 --> 00:23:43.140
X arbitrary.

00:23:43.320 --> 00:23:46.710
So regardless of which
reference frame you specify,

00:23:46.860 --> 00:23:50.500
the only thing they're going to have
in common is that Z always is going to

00:23:50.500 --> 00:23:53.590
be aligned with the gravitational axis.

00:23:54.460 --> 00:23:56.950
Now,
using X arbitrary means that the X and Y,

00:23:56.950 --> 00:23:58.780
though, is completely undefined.

00:23:58.780 --> 00:24:02.000
It's basically going to specify
by the initial pose of the device,

00:24:02.000 --> 00:24:03.440
wherever it's sitting.

00:24:03.440 --> 00:24:06.480
So it could be rotated this way,
or it could be that way,

00:24:06.480 --> 00:24:07.910
or it could be that way.

00:24:07.920 --> 00:24:09.600
You basically have no control over that.

00:24:10.000 --> 00:24:13.760
Another thing that you want to be aware,
when you specify this frame choice,

00:24:13.890 --> 00:24:16.540
is that heading is not
going to be corrected.

00:24:16.540 --> 00:24:20.430
So not only is your initial reference
going to be completely arbitrary,

00:24:20.440 --> 00:24:23.650
but you're going to drift over
time with respect to that.

00:24:25.380 --> 00:24:28.430
Now,
if you specify X arbitrary corrected,

00:24:28.610 --> 00:24:30.600
the magnetometer kicks in.

00:24:30.620 --> 00:24:34.340
And so now we use the magnetometer
to essentially provide

00:24:34.400 --> 00:24:37.140
opportunistic heading corrections.

00:24:37.250 --> 00:24:39.600
Since the magnetometer
is additionally running,

00:24:39.690 --> 00:24:42.930
that means you're going to
consume a little bit more CPU,

00:24:42.940 --> 00:24:46.140
but it does provide you
better long-term Yaw accuracy.

00:24:46.170 --> 00:24:49.100
You don't have to worry
about drifting in your view.

00:24:49.100 --> 00:24:51.100
All right, but again,
the reference point is going

00:24:51.100 --> 00:24:53.900
to be arbitrary in the sense
that it's going to be pegged as

00:24:54.010 --> 00:24:56.940
soon as we start device motion,
depending on what your

00:24:56.950 --> 00:24:58.250
device is pointing.

00:24:58.680 --> 00:25:02.120
If you want it to be fixed on
absolute reference every time,

00:25:02.120 --> 00:25:03.610
then use Magnetic North.

00:25:03.850 --> 00:25:06.550
And for this one,
you were essentially using the compass.

00:25:06.600 --> 00:25:09.100
The difference between the
magnetometer and the compass,

00:25:09.220 --> 00:25:10.510
the magnetometer is a sensor.

00:25:10.600 --> 00:25:15.600
The compass is yet another sensor
fusion algorithm that is running using

00:25:15.600 --> 00:25:22.190
the magnetometer to give you the best
estimate of the Earth's Magnetic North.

00:25:23.610 --> 00:25:26.190
That means, though,
if you're gonna use XMagnetic North,

00:25:26.340 --> 00:25:28.300
calibration's gonna be required.

00:25:28.410 --> 00:25:32.500
So we're gonna provide you, basically,
a property that you can set.

00:25:32.630 --> 00:25:34.420
Show device movement display.

00:25:34.560 --> 00:25:37.000
It's gonna be set to false by default.

00:25:37.000 --> 00:25:40.480
You're gonna set it to true
if you want that HUD to pop

00:25:40.480 --> 00:25:45.070
up when you detect that the,
um-- when the device

00:25:45.070 --> 00:25:46.920
becomes uncalibrated.

00:25:50.230 --> 00:25:52.610
And lastly,
we go to X True North Z Vertical.

00:25:52.610 --> 00:25:55.450
So the difference here is
now your reference frame is

00:25:55.450 --> 00:25:58.090
pegged not to magnetic north,
but true north.

00:25:58.090 --> 00:26:01.250
And of course, as you know,
magnetic north isn't the same

00:26:01.250 --> 00:26:03.120
thing as geographic true north.

00:26:03.120 --> 00:26:06.880
It's going to differ by some amount,
and that amount actually varies

00:26:06.880 --> 00:26:10.930
throughout the globe because of
differences in the magnetic field.

00:26:11.940 --> 00:26:13.720
I won't bore you with the details,
but suffice to say that

00:26:13.720 --> 00:26:15.500
in some applications,
you're going to care

00:26:15.550 --> 00:26:16.440
about the difference,
right?

00:26:16.520 --> 00:26:20.790
If you're hiking,
you may care about the difference because

00:26:20.930 --> 00:26:24.180
you're going to lose hours walking if
you start heading in the wrong direction.

00:26:24.780 --> 00:26:29.380
If you're my mom and you're feng shui,
for feng shui purposes, you really,

00:26:29.620 --> 00:26:32.970
really need to know true north,
not magnetic north.

00:26:32.970 --> 00:26:34.690
You're going to care.

00:26:34.690 --> 00:26:38.790
I didn't know it was
that precise of an art.

00:26:42.800 --> 00:26:45.180
So why do you care, though,
about TrueNorth?

00:26:45.260 --> 00:26:47.500
Well, it's the direction that
we're most familiar with,

00:26:47.500 --> 00:26:50.250
and that's what maps are
using as a reference.

00:26:50.260 --> 00:26:53.440
So that's why you'll,
for navigation purposes,

00:26:53.440 --> 00:26:55.850
you'll really want the TrueNorth.

00:26:55.970 --> 00:26:59.050
We calculate TrueNorth for you,
but what that means is that you're

00:26:59.050 --> 00:27:02.180
going to have to enable location
services because we need to know

00:27:02.180 --> 00:27:05.660
where you are in the lat-long,
and then we use a model of the Earth's

00:27:05.730 --> 00:27:10.630
magnetic field or declination to give
you the approximate difference between

00:27:10.940 --> 00:27:12.710
the TrueNorth and the magnetic north.

00:27:14.920 --> 00:27:19.680
So key takeaways from this is
that sensor fusion does a lot of

00:27:19.680 --> 00:27:24.160
hard work for you if you're not
interested in separating out gravity,

00:27:24.340 --> 00:27:26.640
if you're not interested
in removing gyro bias,

00:27:26.700 --> 00:27:30.370
and if you're not interested in
calibrating the magnetometer.

00:27:30.420 --> 00:27:33.930
And also you can use the reference
range to specify different

00:27:33.980 --> 00:27:35.720
flavors of sensor fusion.

00:27:38.050 --> 00:27:43.440
So with that,
I think we're gonna step away from

00:27:43.890 --> 00:27:53.700
kind of the high-level view of what
sensors are and what sensor fusion is,

00:27:53.700 --> 00:27:53.700
and we'll actually get down to the nuts
and bolts of actually using Core Motion.

00:27:54.990 --> 00:27:57.710
So the outline for using Core Motion,
there's basically three steps.

00:27:57.710 --> 00:28:00.970
You set up, and during the setup,
you're essentially going

00:28:01.060 --> 00:28:04.420
to select what you want,
the raw sensor stream or sensor fusion.

00:28:04.420 --> 00:28:06.400
You're going to define
your update interval.

00:28:06.400 --> 00:28:09.640
And the second step, you're essentially
going to retrieve data,

00:28:09.640 --> 00:28:12.880
and when you're retrieving data,
you basically only have two

00:28:12.880 --> 00:28:14.270
questions you're asking yourself.

00:28:14.410 --> 00:28:17.720
Do I want device motion to push it to me,
or do I want to just

00:28:17.720 --> 00:28:19.260
pull to get the data?

00:28:19.260 --> 00:28:20.720
And then, of course,
you'll have to clean up,

00:28:20.720 --> 00:28:21.690
and that's the last step.

00:28:22.890 --> 00:28:26.840
So during the setup,
first thing you want to do

00:28:26.840 --> 00:28:31.120
is essentially allocate an
instance of the motion manager,

00:28:31.120 --> 00:28:35.280
calling CM Motion Manager, allocating it.

00:28:35.470 --> 00:28:39.230
Then what you want to do is
you want to make sure that if

00:28:39.230 --> 00:28:40.970
you're interested in the sensor,
that it's available.

00:28:41.000 --> 00:28:44.200
If you're interested in sensor fusion,
that it's available.

00:28:44.240 --> 00:28:46.660
Because like I said before,
not all devices are

00:28:46.720 --> 00:28:48.240
going to have everything.

00:28:48.240 --> 00:28:51.860
And next you're going to specify
the desired update interval.

00:28:51.860 --> 00:28:55.440
And I'll talk a little bit about
how you do that a little later.

00:28:55.440 --> 00:28:58.880
But you don't want to just generally
pick one because it actually has huge

00:28:58.930 --> 00:29:03.000
implications for the performance of your
app as well as power considerations.

00:29:03.000 --> 00:29:06.510
And then finally, you just start updates.

00:29:06.640 --> 00:29:10.690
And you do that by just calling
start accelerometer updates.

00:29:10.690 --> 00:29:17.180
You can also call start accelerometer
updates to queue with handler.

00:29:17.180 --> 00:29:18.520
And that's actually the push method.

00:29:18.570 --> 00:29:19.920
And we'll talk about that a little later.

00:29:19.920 --> 00:29:23.620
So to retrieve data,
all you have to do is just basically,

00:29:23.620 --> 00:29:26.720
since you're pulling
data from Motion Manager,

00:29:26.720 --> 00:29:30.270
all you have to do is in some
context basically just go and

00:29:30.270 --> 00:29:32.580
query the accelerometer data.

00:29:33.100 --> 00:29:36.450
So, what's going on underneath?

00:29:37.120 --> 00:29:40.680
Well, what Core Motion is doing
underneath on the framework side

00:29:40.680 --> 00:29:44.530
is it's creating its own threads,
and it's using that to essentially

00:29:44.610 --> 00:29:48.180
handle the raw data for you and also
to run the sensor fusion algorithms.

00:29:48.180 --> 00:29:52.320
On your side, if you decide to do push,
in other words,

00:29:52.320 --> 00:29:55.900
if you want Core Motion to
push the data to you,

00:29:55.980 --> 00:29:59.280
all you have to do is provide
an NSQ operation and block,

00:29:59.360 --> 00:30:03.260
and then your block will execute
essentially on your own threads.

00:30:04.270 --> 00:30:07.310
If you were to pull,
all you're doing then is periodically

00:30:07.610 --> 00:30:11.790
asking Core Motion for the latest update,
and again, you're going to do it

00:30:11.790 --> 00:30:13.240
in your own context.

00:30:15.960 --> 00:30:18.460
The difference between push and pull.

00:30:18.460 --> 00:30:21.200
With push,
you're never going to get a sample.

00:30:21.270 --> 00:30:25.240
Every sample that Core Motion gets
is going to push to you.

00:30:25.250 --> 00:30:29.970
But the disadvantage of that is
that you have increased overhead.

00:30:31.500 --> 00:30:33.970
And sometimes for your application,
you may not want every sample.

00:30:34.010 --> 00:30:35.500
It's okay to do best effort.

00:30:35.500 --> 00:30:37.700
You drop a couple of samples, so what?

00:30:37.720 --> 00:30:39.000
You'll catch up.

00:30:39.850 --> 00:30:43.060
And so you'll want to use
push only if your application

00:30:43.210 --> 00:30:45.400
absolutely needs every sample.

00:30:45.400 --> 00:30:46.970
When fidelity is really,
really important,

00:30:47.000 --> 00:30:50.000
then you'll want to use this
for data collection apps.

00:30:50.550 --> 00:30:52.410
But most other apps, pull is fine.

00:30:52.500 --> 00:30:55.000
It's more efficient,
less code is required.

00:30:55.000 --> 00:30:58.000
But again,
since you're providing your own context,

00:30:58.000 --> 00:31:01.000
you can piggyback onto something or
if you need to create another timer.

00:31:01.550 --> 00:31:04.490
So there's a little bit more
complexity involved there.

00:31:04.490 --> 00:31:08.000
And it's a mode that you'll want
to use for most apps and games.

00:31:09.340 --> 00:31:11.690
So the final step, cleanup.

00:31:11.770 --> 00:31:14.920
And there all you have to do is
essentially stop the accelerometer update

00:31:14.940 --> 00:31:16.600
and then set motion manager to nil.

00:31:16.600 --> 00:31:18.270
So it's just those three steps.

00:31:21.290 --> 00:31:24.680
We're going to talk a little
bit about the implications of

00:31:24.800 --> 00:31:27.630
everything that you're doing in
those three steps by going through

00:31:27.630 --> 00:31:29.310
these set of best practices.

00:31:29.320 --> 00:31:31.930
We'll talk about how you're going
to change reference frames or you'll

00:31:31.970 --> 00:31:35.390
want to change reference frames,
why you'll need to characterize

00:31:35.460 --> 00:31:39.310
the sensors in order to decide
which sensors or which sensor

00:31:39.310 --> 00:31:42.450
fusion algorithms to select,
what update rates that

00:31:42.460 --> 00:31:45.690
you're going to run it at,
how you're going to optimize all of that.

00:31:45.780 --> 00:31:49.230
And we'll also talk about
some common pitfalls that

00:31:49.390 --> 00:31:51.340
you'll want to try to avoid.

00:31:51.550 --> 00:31:55.260
All right, so what I said before
about the reference frame,

00:31:55.270 --> 00:31:56.470
it's kind of an overloaded term.

00:31:56.470 --> 00:31:58.020
So your device,
you'll start out and you'll

00:31:58.020 --> 00:32:00.280
have some reference frame,
and that is the reference frame

00:32:00.280 --> 00:32:02.390
from which all your attitude
is going to be referenced from,

00:32:02.440 --> 00:32:03.910
your role, pitch, yaw, whatever.

00:32:03.920 --> 00:32:06.310
But that may not be
convenient to express,

00:32:06.540 --> 00:32:07.900
especially through UI.

00:32:07.900 --> 00:32:11.080
And so, you know, say, for instance,
you want to reset that initial

00:32:11.080 --> 00:32:13.940
reference to something that
is pointing right at the user,

00:32:13.940 --> 00:32:16.520
some useful resting reference frame.

00:32:16.750 --> 00:32:22.590
So what you want to do there is you want
to cache the reference attitude that

00:32:22.590 --> 00:32:25.770
is something that is pleasing to you.

00:32:25.840 --> 00:32:29.480
And then during subsequent updates,
all you have to do is just take that

00:32:29.590 --> 00:32:31.900
attitude and multiply it by the inverse.

00:32:31.920 --> 00:32:36.480
And then you'll get essentially your new
attitude referenced through the reference

00:32:36.480 --> 00:32:38.620
frame that is a suitable reference.

00:32:41.250 --> 00:32:44.980
So characterizing sensors.

00:32:45.340 --> 00:32:52.070
These sensors are-- they've been specced,
basically, to meet the widest range of

00:32:52.070 --> 00:32:55.560
applications for a mobile device,
but that doesn't mean that they're

00:32:55.560 --> 00:32:57.240
gonna meet all applications.

00:32:57.240 --> 00:33:00.470
So before you use them,
make sure that you understand what the

00:33:00.470 --> 00:33:02.130
dynamic range of these sensors are.

00:33:02.310 --> 00:33:06.540
If the accelerometer's measuring 2G,
and you want to strap it onto a missile

00:33:06.540 --> 00:33:11.220
and shoot it up and impress your friends,
it's likely gonna saturate,

00:33:11.240 --> 00:33:13.490
so you want to avoid doing that.

00:33:13.620 --> 00:33:16.250
Sensitivity is the
converse of dynamic range.

00:33:16.420 --> 00:33:18.590
Dynamic range is how far can you measure.

00:33:18.650 --> 00:33:23.000
Sensitivity is essentially what is the
smallest change that you can sense,

00:33:23.000 --> 00:33:24.480
and again, that's something that
you want to characterize.

00:33:24.670 --> 00:33:29.460
Just put the sensor on a table,
collect the data, and see how it changes.

00:33:29.540 --> 00:33:32.370
Dynamic response,
that's a measure of how quickly it

00:33:32.390 --> 00:33:35.000
can respond to changing signals.

00:33:35.000 --> 00:33:37.660
Different sensors have
different dynamic responses,

00:33:37.710 --> 00:33:41.340
and your application,
obviously they'll have different needs.

00:33:41.340 --> 00:33:46.870
And basically the rule of thumb that
you want to do is-- or you want to use

00:33:47.100 --> 00:33:50.260
is that for more dynamic applications,
you'll want to sense faster

00:33:50.260 --> 00:33:53.640
and faster-- excuse me,
you'll want to sample faster and faster.

00:33:54.250 --> 00:33:54.710
Okay?

00:33:55.140 --> 00:33:58.600
Noise, that actually eats into
your dynamic response,

00:33:58.630 --> 00:34:01.130
because to get rid of noise,
you'll want to filter, and that'll,

00:34:01.230 --> 00:34:03.440
again, cut into your phase and margins.

00:34:03.480 --> 00:34:05.730
Bias we've already talked about,
so I won't belabor the point there.

00:34:05.760 --> 00:34:08.980
But again, the point of all of this
is before you do anything,

00:34:09.090 --> 00:34:13.060
before you even start writing the app,
start characterizing your sensors first.

00:34:14.820 --> 00:34:18.200
Update interval.

00:34:18.340 --> 00:34:23.190
So you saw that in the example code,
we just arbitrarily chose 1/60 hertz,

00:34:23.200 --> 00:34:26.590
and a lot of folks will do that
because that is also the frequency

00:34:26.790 --> 00:34:28.200
at which the scene is being rendered.

00:34:28.200 --> 00:34:31.200
So it's a very convenient
frequency to choose.

00:34:31.280 --> 00:34:36.700
But what's really driving how fast
you should sample the sensors?

00:34:36.930 --> 00:34:38.700
Well, one is fidelity, right?

00:34:38.720 --> 00:34:40.220
Nyquist.

00:34:40.710 --> 00:34:42.700
If you're gonna be
sensing a 10-hertz signal,

00:34:42.700 --> 00:34:44.700
you want to sample at least 20 hertz.

00:34:44.700 --> 00:34:47.700
But in fact, you want to sample more
because you have noise,

00:34:47.700 --> 00:34:52.570
and so you want to sample much,
much higher than Nyquist in order

00:34:52.570 --> 00:34:56.190
to do some filtering and yet be
able to reconstruct that signal.

00:34:56.200 --> 00:34:59.170
But the faster you go,
the more power it's gonna consume,

00:34:59.290 --> 00:35:01.700
so you're really gonna have to back off.

00:35:01.700 --> 00:35:04.600
And instead of sampling at
200 hertz like you really,

00:35:04.630 --> 00:35:07.700
really wanted to, maybe you've got to run
the gyro at 100 hertz.

00:35:07.700 --> 00:35:09.700
So again,
that's something that you're gonna

00:35:09.700 --> 00:35:11.700
have to do to optimize for your code.

00:35:14.250 --> 00:35:20.270
Now, for a lot of motion-enabled apps,
it's a bit of a quandary because

00:35:20.610 --> 00:35:27.300
you'll want to be aware of the time
in which you're getting these samples.

00:35:27.340 --> 00:35:35.450
But you're basically not getting these
samples under any defined contracts.

00:35:35.560 --> 00:35:38.920
In other words, you're going to specify
an update interval,

00:35:38.920 --> 00:35:42.500
but you may not necessarily going to get
an update interval because we're going to

00:35:42.500 --> 00:35:43.960
deliver the samples to you best effort.

00:35:44.100 --> 00:35:48.640
So you're going to get the samples
at the update frequencies that are

00:35:48.650 --> 00:35:51.090
defined by the sensors and by CoreOS.

00:35:51.100 --> 00:35:53.940
So, and on top of that,
there's going to be jitter.

00:35:54.150 --> 00:35:57.170
So if you really need to be aware,
if you really need to be

00:35:57.170 --> 00:36:00.110
time aware of your sensors,
you'll need to check the

00:36:00.230 --> 00:36:02.100
timestamp of the sensors.

00:36:02.100 --> 00:36:05.000
Okay, if you're going to
reconstruct the signal.

00:36:05.110 --> 00:36:08.230
That's really, really important,
especially for applications that

00:36:08.430 --> 00:36:10.100
are trying to reconstruct anything.

00:36:10.140 --> 00:36:12.970
But if you're going to use the timestamp,
use the correct one.

00:36:13.110 --> 00:36:14.100
There's two times,
there's multiple times.

00:36:14.100 --> 00:36:16.100
You can get timestamps
in a number of ways.

00:36:16.100 --> 00:36:19.100
The timestamp that we provide
for you in that sample,

00:36:19.100 --> 00:36:25.070
that is a timestamp that is generated
at the driver when we clock that signal.

00:36:25.140 --> 00:36:27.100
Basically when we clock
that sample off the sensor.

00:36:27.100 --> 00:36:28.940
So it's going to be the
most accurate timestamp.

00:36:29.170 --> 00:36:32.800
Don't use the timestamp in the
callback because who knows when that

00:36:32.800 --> 00:36:35.090
sample is actually delivered to you.

00:36:35.110 --> 00:36:38.100
So that's just something
to be careful about.

00:36:38.430 --> 00:36:41.010
Next, don't assume an update interval.

00:36:41.120 --> 00:36:43.060
I already touched on that before.

00:36:43.170 --> 00:36:46.000
So again, if you want 60 hertz,
you may not necessarily get 60 hertz.

00:36:46.100 --> 00:36:47.100
You're actually going to get 50.

00:36:47.100 --> 00:36:48.100
You may get 55.

00:36:48.100 --> 00:36:49.100
You may get 40.

00:36:49.100 --> 00:36:53.100
So if it's really important to you,
actually check the timestamps.

00:36:53.280 --> 00:36:54.100
Look at the difference.

00:36:54.100 --> 00:36:56.940
Now you want to be careful because
you don't want to just take two

00:36:57.220 --> 00:36:59.100
timestamps and look at the interval.

00:36:59.100 --> 00:37:02.960
You probably want to do a moving
average to smooth out the jitter in

00:37:02.960 --> 00:37:05.100
order to get the average delta T.

00:37:07.150 --> 00:37:13.230
And lastly, this may sound trivial,
but in fact, it's really important.

00:37:13.280 --> 00:37:16.830
So in your code,
what you do is you essentially say,

00:37:17.260 --> 00:37:19.700
start updates to queue with handler.

00:37:19.700 --> 00:37:20.710
Excuse me.

00:37:20.820 --> 00:37:22.620
You basically call start update.

00:37:22.620 --> 00:37:24.280
And then right away,
you want to get in there

00:37:24.280 --> 00:37:25.480
and start pulling the data.

00:37:25.480 --> 00:37:28.890
Well, the problem is that these sensors,
they're mechanical devices,

00:37:28.910 --> 00:37:30.650
and so there's some startup time.

00:37:30.670 --> 00:37:33.220
And different sensors will
have different startup times.

00:37:33.270 --> 00:37:35.140
The accelerometer starts up right away.

00:37:35.140 --> 00:37:37.080
The gyro takes a little longer,
as much as two minutes.

00:37:37.110 --> 00:37:38.410
It takes two seconds to spin up.

00:37:38.510 --> 00:37:40.110
So if you were to start
pulling right away,

00:37:40.120 --> 00:37:41.720
you're going to get nonsensical data.

00:37:41.720 --> 00:37:43.040
You're not getting data at all.

00:37:43.100 --> 00:37:45.580
So what we do is we hold that data
back until it becomes sensical,

00:37:45.580 --> 00:37:46.710
and then we push it on to you.

00:37:46.810 --> 00:37:48.920
So what you want to do before
you start doing anything on

00:37:48.920 --> 00:37:50.690
the data is check for no.

00:37:50.700 --> 00:37:51.890
Okay.

00:37:55.390 --> 00:37:57.080
Avoid integration.

00:37:57.130 --> 00:38:00.770
I think I kicked that horse to death,
so I won't belabor the point,

00:38:00.770 --> 00:38:03.960
but essentially,
anytime you integrate the signal,

00:38:03.960 --> 00:38:06.720
you have to worry about instability.

00:38:09.330 --> 00:38:12.170
Again, check for existence.

00:38:12.230 --> 00:38:13.800
Very important.

00:38:13.800 --> 00:38:15.440
So if you're going to do, say,
the sensor,

00:38:15.440 --> 00:38:17.530
check whether the magnetometer
is available or not.

00:38:17.600 --> 00:38:21.640
If you're going to use sensor fusion...

00:38:21.890 --> 00:38:24.860
This is just an example of how you
can check what reference frame is

00:38:24.860 --> 00:38:28.700
available by using the bit mask.

00:38:30.640 --> 00:38:32.310
So now we get to the coding examples.

00:38:32.430 --> 00:38:36.540
And again,
this is examples that we're going

00:38:37.010 --> 00:38:40.440
to have available for download.

00:38:40.440 --> 00:38:45.500
The first one is basically
going to be a motion graph.

00:38:45.710 --> 00:38:49.580
And what that does is it allows you
to essentially select what sensor

00:38:49.580 --> 00:38:50.600
signals you want to visualize.

00:38:50.600 --> 00:38:53.600
So, you know,
you want to plot accelerometer,

00:38:53.600 --> 00:38:55.300
you want to plot user acceleration gyro.

00:38:55.300 --> 00:38:58.600
So it's a great tool, again,
to help you characterize your sensors.

00:38:58.680 --> 00:39:02.100
Some of the concepts we cover in
there are push semantics and how

00:39:02.100 --> 00:39:06.600
to manipulate the update interval,
specify the update rates.

00:39:06.620 --> 00:39:11.040
So to start using that,
all you have to do is essentially

00:39:11.500 --> 00:39:14.470
import the Core Motion framework.

00:39:14.600 --> 00:39:19.670
I won't go into how you
actually set up the build,

00:39:19.680 --> 00:39:19.680
but...

00:39:20.030 --> 00:39:21.730
in the header.

00:39:21.790 --> 00:39:24.450
We put the motion
manager in the delegate,

00:39:24.450 --> 00:39:28.360
and the reason we do that here is because
this thing contains a lot of views,

00:39:28.410 --> 00:39:30.740
and we just wanted a
single motion manager,

00:39:30.740 --> 00:39:32.120
so we kept it in the delegate.

00:39:32.250 --> 00:39:37.810
And there we instantiate
the motion manager.

00:39:42.620 --> 00:39:48.990
So now in the view controller,
what we do is...

00:39:51.590 --> 00:39:57.960
We basically, in each view,
we get a reference to that motion manager

00:39:57.960 --> 00:39:57.960
that is shared among all the views.

00:39:59.660 --> 00:40:06.510
And then when the view appears,
all we do is we just call start update.

00:40:07.210 --> 00:40:08.990
essentially with the interval.

00:40:09.130 --> 00:40:11.340
That right there is just a wrapper,
which I'll show you the

00:40:11.340 --> 00:40:12.700
implementation underneath.

00:40:12.700 --> 00:40:16.130
So start updates with motion
data type and slider values,

00:40:16.180 --> 00:40:19.510
just a wrapper around the
start accelerometer updates,

00:40:19.510 --> 00:40:20.440
et cetera.

00:40:20.510 --> 00:40:23.330
And similarly, if you're going to
change the slider values,

00:40:23.340 --> 00:40:26.140
again, we just call that wrapper.

00:40:26.250 --> 00:40:31.000
So here,
that wrapper is essentially where we--

00:40:31.910 --> 00:40:35.040
Do all the things that I talked about,
how it's important to do.

00:40:35.040 --> 00:40:38.190
Check whether the
accelerometer is available.

00:40:38.300 --> 00:40:41.270
Set the update interval and
then essentially start the

00:40:41.400 --> 00:40:43.640
accelerometer updates to queue.

00:40:43.710 --> 00:40:45.270
And that's it.

00:40:48.340 --> 00:40:56.230
And then on cleanup,
we just... essentially

00:40:56.520 --> 00:40:58.230
call stop the updates.

00:40:58.360 --> 00:41:00.640
So that's it, really,
on that coding exercise.

00:41:00.640 --> 00:41:03.840
It's just a few lines of code,
a few handfuls of code,

00:41:03.840 --> 00:41:09.190
and what you would actually get are
some really cool plots of the sensor

00:41:09.210 --> 00:41:12.650
data so that you can play with it to
see what the difference is between

00:41:12.650 --> 00:41:16.990
gravity and user acceleration and get a
sense of how when you change the slider

00:41:16.990 --> 00:41:21.240
values and you add your own filtering,
how that degrades fidelity or not.

00:41:21.260 --> 00:41:26.320
The next demo, which I'm not going to
provide the code for,

00:41:26.340 --> 00:41:30.700
at least on the slides,
is a virtual... an augmented reality app.

00:41:30.800 --> 00:41:35.680
And here we show concepts such as
how you go from reference attitudes

00:41:35.740 --> 00:41:40.690
to chaining all the transformations
together so that you can basically

00:41:40.700 --> 00:41:45.230
visualize how... So the idea is that
you're going to hold this... device up,

00:41:45.230 --> 00:41:50.100
and as you rotate the device,
you'll visualize objects in

00:41:50.100 --> 00:41:52.120
3-space that you're seeing.

00:41:52.120 --> 00:41:56.520
So the device basically provides
a window into the solar system.

00:41:56.610 --> 00:41:58.600
So that's it.

00:41:58.650 --> 00:42:00.210
Thank you.
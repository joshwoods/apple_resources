---
Title:  Getting Around Using Map Kit
Year:   2012
Web:    https://nonstrict.eu/wwdcindex/wwdc2012/300/

[!] This transcript was generated using Whisper, it has known transcription errors.
---

All right, so hello, my name is Brady. I'm an engineer on the Maps client team, and I'd like to welcome you to this year's Map Kit talk called Getting Around with Map Kit. And in this talk we'll be going over what's new in Map Kit and iOS 6. So let's take a look at the agenda.

So we're going to begin with something I'm sure you're very interested in, the new look of Map Kit. We've got all new Apple Maps cartography in iOS 6 and this 2D cartography is coming to Map Kit. I'm going to be going over what this means to you as a Map Kit developer.

Then we're going to be introducing a new API called MKMapItem, which makes it really easy to launch maps with a minimal amount of code from your app. And then we're going to end by talking about something Scott hinted at yesterday, which is a new API specifically for routing apps to integrate directly with Maps. More about that later. Let's begin with a new look of Map Kit.

So we've got all new Apple Maps cartography and Apple Maps and iOS 6. Here it is on the iPhone. And of course, it's on the iPad as well. And this 2D cartography is coming to Map Kit. But I'm sure one question you have as a developer is, the maps look great, but what do I need to do to get Apple Maps working in my app? And I think you're going to like the answer. Some of you might have noticed already if you updated to the beta.

And the answer is absolutely nothing. It's just going to work straight out of the box. And the reason this is possible is because we brought the new Apple Maps cartography to the same API. So whatever Map Kit code you've already written or you're just starting to learn is still going to work.

So as an example of how this is still working, I want to show you Find My Friends, which uses an MKMapView and Map Kit. But this is the same binary that ran on iOS 5, now running on iOS 6. So here it is, no code changes, same binary, it just works. And it gets the new Apple Maps cartography. Now this is an example of standard map mode, but of course you have an updated satellite mode as well.

and a hybrid mode, which is a combination of the new Apple Maps satellite imagery with the standard roads and labels layered on top. So beginning the three new map modes with no code changes. If you're using annotations in your app before, they're still going to work. So here we have a sample app that would have worked just fine on iOS 5, but here it is running on iOS 6. And the annotations behave exactly the same. They're still MK annotations, but now they're being placed on top of the new Apple Maps cartography.

If you're using overlays in your app, those are also still going to work. So here we have another sample app where we have an MK Polyline overlay view for each county in California. And this app would have worked just fine on iOS 5, but here it is running on iOS 6, except with a new satellite mode.

So you're going to get the multiple map modes, and annotations and overlays are still going to work just like they did before. But we've improved the way we render the map in iOS 6. And you're going to be seeing the benefits of this in your Map Kit apps. So I want to show you one example with pinch to zoom.

So in iOS 5, the map was rendered using static images. And when you pinch to zoom, you have to stretch that static image. And when you pinch to zoom in your MKMapView, you would notice something like this. The roads and labels start to get blurry. And it wasn't until we hit that next zoom level that the new tiles would come in and the map look good again.

But in iOS 6, the map is dynamic. It renders on the fly. So if your app is using MKMapView and your user pinches to zoom, you'll notice that it's a nice, crisp zooming experience with readable labels. And there isn't any zoom levels anymore. It's just a consistent map as you pinch to zoom. So you'll be getting a much better zooming experience because we can render at any zoom level.

So because we can render at any zoom level, you're also going to get more control of your map region than you did in iOS 5. Let's look at an example of what you might have noticed in iOS 5. So say you call set region with this blue box. You would have expected that your MKMapView would give you a region just surrounding that blue box. But this wasn't always the case in your app. You would sometimes get this, which is a little more zoomed out than what you wanted. So what was happening here?

Well, as I said earlier, in iOS 5 we rendered using static images. And we can only make those images look crisp at certain zoom levels. So if you change the region by calling setRegion or setVisibleMapRect, what would happen is we would zoom you out to the previous zoom level to ensure that the map looked great, but also show that full region. So this is no longer necessary in iOS 6, because we can render a nice map at any zoom level. So if you relink your app with iOS 6, you'll get full control over your map region, which you didn't have before.

Another benefit you'll see as a result of how we've changed the rendering in iOS 6 is heading mode. We think it's going to be much more useful. So this is just a demonstration of what you would have noticed if you turned on heading mode in your MKMapView in iOS 5. As you turned it on and your user faced south, the labels would turn upside down.

And this is because with a static map, if it rotates upside down, the labels are part of that map and the map rotates with it.

[Transcript missing]

So that's the new look of Map Kit. And again, you could be getting the new display with the same APIs. It's still going to work out of the box.

You're also going to be seeing the benefits of improved map rendering, including an improved pinch to zoom experience in your MK Map View, better heading mode, and if you relink your app with iOS 6, you'll get full control over the map region. Test your apps. Although the API hasn't changed, the implementation has changed a lot.

So make sure you go through and test your apps. And if things aren't working the way you expect them to, please file a bug. So that's a new look of Map Kit. But for the most part, we don't have any new APIs here. We do have some new APIs to introduce today. So let's introduce a new API, MKMapItem.

So MKMapItem makes it really easy to launch maps with a minimal amount of code. Some of you might be doing this already in your Map Kit apps using URLs. But we introduced MKMapItem to make it really, really easy to do this. So why would you want to launch Maps? Well, one reason is we've got brand new turn by turn navigation in Apple Maps.

So if you have a store locator app or a restaurant guide, and the focus of your app is more finding places than getting directions, you can launch into Maps and let the user take advantage of the turn by turn navigation. And there's some other reasons why you might want to give the users the ability to jump into Maps, like to just drop a pin, or be able to save the data to their contacts or bookmarks in a familiar interface. Or even let the user explore the landmark in 3D.

So to help you open maps from your app, we're introducing MKMapItem. And before MKMapItem, if you wanted to open maps, you had to do it by generating a maps URL. And this was kind of cumbersome and limited in terms of what it could do. And it also seemed kind of silly to generate a URL just to open an app. You're not opening a website, you're opening an app.

So with MKMapItem, it's a fully objective C API where you can open maps with a minimal amount of code. You can even open maps with multiple pins if you want to. And we'll demonstrate this later. also gives you the ability to jump directly into directions, driving or walking, and even getting turn by turn navigation. And lastly, you can specify options to customize the map display.

So let's look at an example of an app that could use MKMapItem. So here we just have a sample app that's an Apple store locator and it shows nearby stores. And it's got a table view and a cell for each nearby store. We can use the UI table view methods to hook up tapping that cell to open maps with MKMapItem. And here we just open maps and drop the pin for where the Apple store is, the San Francisco store.

And we did this with a really small amount of code. Let's look at how it works. First, you instantiate an mkplace mark. And this is an existing API class that just lets you define a location and if you want to provide one an address dictionary. So the mkplace mark is the pin you want to open. Then you create this MKMap item. And the MKMap item has convenience methods for opening in the maps.

specifically open a map with launch options. If you call that on the MKMap item, it will take that map item, send it to Maps, and drop a pin. And here's the code. First you instantiate the MKMap item with a place mark you want to get directions to. And then you call open a Maps with launch options. So two lines of code, and you've opened Maps. That's it.

We want to add some more details here. Like if you notice, we've kind of lost some information about what we were showing. We're showing the address and the call out, but really this is more than an address. This is the Apple Store. And if you look at the info card, you don't see many details about it either. It's just the address and not much more.

What we'd really like it to look like is something like this. The Apple Store SF and a more interesting info card with a name, phone number, and URL of the place you're going. So by adding these additional details, when we launch Maps, it seems like a more seamless experience when jumping from your app to Maps.

MKMapItem makes it really easy to do this. So just like before, you start with a place mark you want to get directions to. And then you instantiate an MKMap item and provide the name, phone number, and URL if you would like. and then call Open in Maps. And when you do that, it'll send the placemark and the additional metadata and Maps will use this data to add details to the pin.

and we don't have much more code here either. We instantiate the MKMap item like we did before. And then below we call open a Maps. But in between we have this extra three lines of code to give it a name, a phone number, and a URL. And Maps will use this data when we're launched.

So I mentioned that you can also open multiple pins and maps with mkmapitem. So here we've modified our app to have it open all on Maps. And you might want to use this if you have multiple places that the user might want to go to, but you want to let the user choose which one is closest.

So here we've hooked up the Open All on Maps button to drop a pin for each one of the stores. And Maps will wrap those pins in a reasonable bounding box and show it all on the map. So we've got multiple pins. How do we do it? Well this time we're going to start with multiple MKMap items. One for each pin we want to drop in Maps. Then we group them together in an NSArray.

Once we have that array, we'll use a class method on an MKMapItem called OpenMapsWithItems, pass the array of items we want to drop. And when we call this, it will open maps, drop a pin for each one of those map items, and give you a nice bounding box around it.

Here's the code. First you instantiate an NSArray using the three items you want to open, or as many items as you want. And then use the class method, MKMapItem, open maps with items, and then pass the array of items. And when you do this, two lines of code and you have multiple pins open to maps. Really easy.

So we have this launch options dictionary, both for the instance method, open in Maps with launch options for one item, and for multiple items, open maps with items. So you can specify various properties with the launch options dictionary, and that will change what Maps does when it opens. You can give a specific map type if you want to change it to standard, satellite, or hybrid mode. You can even give a custom coordinate region. Or enable or disable traffic, all with a launch options dictionary.

So say your app wants to drop a pin at the White House. And you think it'd be more interesting to open maps in satellite mode. Well to do this, you create a dictionary. That'll be your launch options dictionary. And then for the map type key, you specify satellite mode.

So with this simple dictionary, we've opened Maps and enabled satellite mode. is a great example of how to integrate your app with your own map. But we can do a little more to make opening maps more interesting. Because we're kind of more zoomed out here than we'd like. Really, we just want to focus on a specific coordinate region. Specifically, this orange box. And by doing so, we'll get a nicer view just of the White House and the White House lawn.

So to do this, when we create our launch options dictionary, we'll specify some additional options. We'll give a custom map center with a center over the lawn. And this is an MK coordinate. And then we'll give a custom map span. In this case, a span over the White House. And when we do this, we get a nice region when we open maps. It's a beautiful view of the White House and we've centered over the lawn instead of the pin. All of this with a custom coordinate region.

You can even enable traffic or disable traffic with MKMapItem. It's just another key that shows traffic key and you can set it to yes or no and that will override whatever setting is currently in Maps. So we've got brand new turn by turn navigation in Apple Maps and your users might want to get access to it. And you can go directly into directions with MKMap Item for driving or walking directions.

So how do you do it? Well, it's just another launch options dictionary key. In this case, it's the directions mode key. And you can set it to driving or walking. And then you'll instantiate the MKMap item that you want, in this case, Moscone item, that you want directions to.

And when you call Open in Maps with Launch Options, It will understand that you want directions to that item from your current location. So when Maps is opened, you'll go directly into an overview of driving directions from your current location to Moscone. And then from there, the user can hit start to go directly into turn by turn navigation.

Here's the code. So like before, we start with the item that we want directions to. We create our launch options dictionary. And then on the item we want directions to, we call open a maps with launch options with directions to that item. And because the directions mode key is set to driving, we'll go directly into driving directions.

You can even specify a custom origin if you want. So say your app wants to show directions from the airport to Moscone, but the user isn't at the airport yet. Well, to get custom directions, you first create a map item for where you want to start and where you want to end. In this case, you want to start at the airport and end at the Moscone item.

Then you group these items together in an NSArray, just like we did before when we wanted to open multiple pins and maps. And we also set the directions mode key to whether we want driving or walking directions. Then we use the class method, open a map with items since we have multiple items. And when we do that, Maps will understand that we want directions from the first item to the last item. And when Maps launches, it'll show directions from that first item to the last item.

Here's the code. We first create an array with the first element being the airport where we want to start. And the destination MKMapItem Moscone West. Then we create our launch options dictionary with the driving mode key set, or the driving key, driving value set for driving. And then we use the class method MKMapItem, open maps with items, pass the array of items, and then pass the launch dictionary specifying we want driving directions.

So sometimes you might want to specify your current location with an MKMap item. Whether or not you want to open maps to show the current location or get directions from some point to your current location instead of from. To represent your current location, you don't have to use core location at all. You can just use mkMapItem, mapItem for current location.

And this will just return a symbolic map item referencing whatever your current location is right now. and because it's symbolic, it won't have a place mark. Instead, it will just have a flag set to is current location, yes. So this is just a singleton that represents whatever your current location is.

So say you want to get directions from Moscone to your current location for directions when you come back. To launch maps with directions to your current location, you create an array with the first element being where you want to start. And we've swapped out the last item to be our current location. And then everything else is the same. We've got the driving value set for directions. And we just use mkmapitem open maps with items. So that's mkmapitem. And it makes it really easy to open maps with a minimal amount of code from your app.

And we think this is great because if your app is a store locator app or a restaurant guide or any other app that might want to open maps, you can offer quick access in your app to navigation and other familiar maps features like bookmarks and contacts and even exploring in 3D.

And maybe your app doesn't even have a map view. You can use MKMapItem to keep your app focused on what it does, maybe finding certain data or addresses. And then if the user wants to see it in the map, you can use MKMapItem to open maps. So MKMapItem is an API that makes it really easy to go from your app into Maps. But the next API, specifically for routing apps, goes the other direction.

So in iOS 6, we're introducing a new API where if you're the developer of a routing app, you can make your app launchable by Maps. And we think this is going to be a really big opportunity. is a great example of how to integrate your app with your application.

Now, I'm going to talk about why. Because routing apps are extremely important. And they're really important because there isn't a single solution to routing. Instead, there are many solutions. And this is because there's all different kinds of transportation modes, and also different user experiences that people are looking for when taking that transportation mode.

So say you're trying to get to WWDC. One person might want to bike there, but he wants to do more than that. He also wants to share the route with his friends afterwards, or see the average speed of his ride. is a great app for people who are looking to build their own maps.

It's a great app for people who are looking to build their own maps. And another user, maybe she doesn't want to bike there, she wants to take public transit instead, but she wants to do more than that too. She would like to get a push notification if her bus is running late.

Maybe the third person is running late. He doesn't care about the route. He just wants a taxi to pick him up and take him there. These are all examples of routing apps with customized experiences for custom transportation modes. And this just shows you why there isn't a single solution. But instead, there are multiple solutions. And that's why we think that routing apps are really important on iOS. We think that they're so important that in iOS 6, we're going to let you integrate directly with Maps and be launchable by Maps.

So this is a big opportunity and I'm going to go over how this works. So for many people, many users, the starting point of figuring out where you're going is Maps. So say you want to get directions to Apple headquarters. Well, if you want to get directions, you hit the directions button.

And that presents the direction sheet. If you want to use the Routing Apps mode, you choose the third option, the Routing Apps option, and then hit Route. Here you'll be presented with a new Routing Apps UI. This is a combination of just Routing Apps, some installed, and some from the App Store.

And these are just Routing Apps that have integrated with Maps. At the top, we have recommended routing apps that are installed in the user's device. But this is only routing apps that Maps thinks is relevant. So if you're in San Francisco, it won't show routing apps that only apply to New York City.

Below we have routing apps from the App Store. And these are routing apps that the App Store think could possibly provide a route based off of the start and end point that we've selected in Maps. Notice that there are reviews and transportation modes with these routing apps. And there's even a price. And you'll be able to purchase these apps right inside of Maps. So we think this is a really big opportunity because you'll be able to get your app seen by users who really want to use it.

So once the app is installed, which you can do right in Maps, if you want to open an app, you hit Route. And when you hit Route, Maps will send the starting point and the ending point to that app. And that app can use it to provide an instant route. So for this demo, or for this presentation, we've made a sample app called WWDC Transit, which just provides basic Caltrain directions. So I'm going to show you how it works. You hit Route. It will jump us into our app.

And then here our sample app has told us that we should get on the San Francisco Caltrain station and get off at the Sunnyvale Caltrain station. So notice that the user hasn't done anything other than hit route. And it just jumped into our app and our app instantly provided a route. This showcases just how integrated these apps are.

So that's how the workflow is. But what does it take to become a routing app? And a routing app, again, is any app that helps you get where you're going. It doesn't necessarily have to show a route, like with a taxi example. First you have to declare your app as a routing app. And you do this in your Info.plist. But Xcode makes it really easy. The second step is you need to specify where your app is relevant geographically. And Maps will use this data to only show your app if it thinks you can provide a route.

And then the third step is you need to use the data that Maps sends you to instantly provide a route. And that will make your app seem much more integrated rather than just a basic app launch. So the first step is really easy. You just go into Xcode. And when you select your target, there'll be a new option in Xcode to enable directions. And then you can select what type of directions your app provides.

Then the second step is to specify where your app can provide routes. This is where you want users to be able to launch your app. So for our Caltrain example, this is a perfectly reasonable coverage area. And for this coverage area, if the starting point and ending point are within the region, then Maps will say, OK, your app can provide a route. But if you're out of the San Francisco area, or out of the Bay Area, then say, just the destination is outside, then it won't suggest our app. So they will only see your app when your app can provide a route.

So this is an example for what a Caltrain app might use. But maybe your app provides directions all over the US. This is a perfectly reasonable coverage region if your app covers most of the US. Or maybe your app has different spots where it has coverage. Here we have an app that might provide directions in various cities in Europe. And you can see here how you can specify multiple regions.

So how do you specify your geographic coverage? Well to do this, you'll create a file using the GeoJSON file format, which is a public standard for declaring geographic data. For the purposes of routing apps, we're going to use a subset of that standard, just a single multi-polygon. And a multi-polygon is a set of polygons where your app says it can provide directions.

So keep it simple. It's not all about fine tuning with a million points along the coastline. It's more just a general, where does your app provide directions? And if the start and end point are in that region, we'll suggest your app. So you shouldn't need to specify more than 20 polygons for most apps. And you don't need to get too fine tuned with your polygon. No more than 20 points.

One thing I want to mention is that this coverage file is not part of your app bundle. It's submitted to iTunes Connect separately. And the reason we're doing this is because we want to make it really easy to update where your app gives coverage. So you don't have to go through the app review process, you just upload it directly to iTunes Connect and then it will be delivered to all of your users. So it's really easy. To help you test this, we've now included Maps in the simulator. And this is going to make it really easy to test the whole workflow of your routing app, from starting in Maps to figure out where you're going, to launching your app.

When you're testing your routing app, you also want to make sure that your app only appears when it's relevant. And this is verifying whether or not your GeoJSON coverage file is behaving correctly. So you should only see your app in the top section when your app can provide a route.

One thing I want to mention is if you do not see your app when you expect it, there could be something wrong with your coverage file. Maps might not have been able to read it. And to catch this, if you don't see it, go in the console if you're using the simulator and look for a syslog for Maps. And we'll demo this in a moment, but Maps will log an error if it couldn't read your coverage file. If you're testing on the device, you can use Xcode Organizer to check the syslog.

So we have a sample app that I showed you, that WWDC Transit app. And currently it's in a state of a basic app. And I'm going to go through the process of converting it from a basic app to a Maps integrated routing app. So let's look at it. OK, so let me show you what I have so far.

And this is sample code that we'll be distributing later. And when you build and run, you'll see that our app is very basic, but it just has an annotation for each one of the stops on Caltrain. and you can tap on the stops and see what the stop is.

So it's not integrated with Maps yet. So if you want to get directions, you have to use its own built in UI. And the built in UI is very simple. You have to type in an address for the starting and ending point. So this is an example of an app that could definitely benefit from that integration with Maps, where the user experience for finding where you're going is much more polished. So I'm going to type in the address of Moscone.

[Transcript missing]

at the San Francisco Caltrain stop and get off at the Sunnyvale Caltrain stop. So now let's go through the process of getting it integrated with Maps. The first step, we need to go into our Info.plist. Or because Xcode has UI for editing it, we can just click the target, scroll to the bottom, And then check Enable Directions.

And then we'll say what kind of directions our app supports. In this case, we're a train app. But you can select multiple options. Now when I build and run, nothing has changed here. But if I go into Maps-- Then type in where I'm going, in this case, Apple Inc.

Hit the Directions button. Choose Routing Apps, hit Route. You'll see that our app appears. And notice this is the train option, which we selected in Xcode. So if you click the Route button, that'll just launch our app. But it doesn't do anything yet. It's showing the route from before, but it didn't do anything other than launch the app. And that's because we haven't handled the launch from Maps.

Also notice that we haven't done the second step yet, which is declaring our coverage file. And for debugging purposes, we're going to show your app even if it doesn't have a coverage file. But you won't be able to submit it to the App Store unless you provide a coverage file. So let's go through the process of testing that. To help you make a coverage file, we've made another sample app called Region Definer that we'll also be distributing.

So I'm going to build and run this. And with Region Definer, you can draw a region around the Bay Area. And you just do this by pressing and holding to drop a pin. And as I do this, you'll see a green polygon starts to appear. And this polygon represents our coverage area.

So here's a perfectly fine coverage file for the Bay Area. And if I hit Log, notice that it logs this coverage file to the console. And this is valid GeoJSON that we can use in our app. So for testing your GeoJSON, you can use this. And you don't have to deal with even learning the spec.

So let's take this GeoJSON and switch into our app. And then I'm going to go and create a new file. And then choose a resource GeoJSON file. I'm going to call this Bay Area.GeoJSON. Remember that you don't need to include it as part of your target because it's submitted separately. And it's also tested separately. So don't add it to your target.

And this just gives us a basic template with no polygons. But we already have our GeoJSON that we've made. So I'm just going to paste this in. And it's got our single polygon over the Bay Area. And then there's one more step for testing. Because it's not part of the app bundle, you need to edit your scheme, go to the Run option. And for routing app coverage file, choose your GeoJSON file. And now when you build and run, it'll use that GeoJSON file.

and close the other app. Now when I build and run. And then switch into Maps. So this example, our app should appear, because Apple Inc. is within the Bay Area. So when we hit Route, our app appears like we expected it to. But what if you choose--

[Transcript missing]

So what if something goes wrong when you're making a GeoJSON file? Like say, you forgot the last curly brace. Then what you're going to notice is Maps isn't going to be able to parse the file, and then it won't suggest your app. So to test this, I'm going to build and run and show you what you might see.

Switch to Maps. Get directions to Apple Inc, which should work. But our app isn't there. So what happened? Well, it couldn't parse our file. And Maps is going to complain when you hit that Route button. So if you go into Console-- and filter for logs from Maps, you'll see if you query for GeoJSON that Maps had an error parsing the file. And if you look at it, it said, unexpected end of file while parsing object. And this is because you didn't include that last curly brace. So if you don't see your app when you expect it to, check the logs.

So we've now done the first two steps. We've declared an app as a routing app, and then we've declared where it can provide routes. Let's go back to the slides. So we've got one last step. If you open our app, like we showed earlier, all we do is open the app. We don't do anything special about it. But what we'd really like to do is go directly into showing a route. That will make it seem much more seamless, and the user will enjoy jumping into your app more.

So how does this work? Well, we start with MKMap items, just like the same API you used for opening maps before. It's the same model. One for the starting point and one for the ending point. But in the example we've been showing, the first item is your current location.

Then Maps is going to create an MK directions request. And when you check the Enable Directions button, you said that your app can handle directions requests. Then Mas will create a URL pointing to that directions request and then use URL opening to open your app. So in your app, you'll get open from a URL, just like any other URL.

And when this happens, in your UI application delegate, you want to check to see is it an MK directions request URL. And there's a convenience method for doing this. If it is, then you're being launched from Maps. So you should instantiate the MK directions request using the URL.

Then this directions request will include a starting item and an ending item. In this case the starting point being our current location and the ending point being Apple headquarters. But remember that the current location MKMap item doesn't have a placemark. It doesn't have a coordinate associated with it.

So if you get that symbolic current location item, you need to use CoreLocation to resolve it to whatever the user's location is. This is pretty important. Once you have that information, then you should use it to provide a route. And remember that MKMap item has additional details like a title and maybe a phone number and URL. So you can use this to customize your display.

So here's the code. This is an existing UI application delegate method for handling opening URLs. And if you haven't implemented this already, you'll add that delegate and then add a check to see if the URL is an MK Directions Request URL. If it is, then you're being launched from Maps.

Then you can instantiate MK directions request using that URL. And then that directions request will have a start item and end item. And you can use these items to instantly provide a new route. So this is the starting code for providing custom directions. So let's go through that third step with our sample app of letting our app handle launches from Maps more gracefully. So I'm going to go to our application delegate. And we haven't implemented URL opening yet, so I'm just going to drag and code the exact code from the slides.

I just got to block a code here, but this is the same code from the slides. So it checks to see if you're being launched for a directions request URL. And if so, we instantiate one and then pull out the start item and end item. So now we need to do something with that information.

So I'm going to delete this to do. And then just drag in three lines of code that uses code that we've implemented in our app to first create a My Place model, which is just a custom model for our app representing the starting point. And you give it a name and coordinate from the MKMap item. And then we do the same for the end item.

And once we have those two My Places, our app has a method called Route From Place to Place. And it uses the start and end places to instantly provide a route. Now we're not done here yet. And this is because we haven't handled the case where the starting point is a current location MQMap item. But I'm just going to show you what happens. So I'm going to go into our app, hit Route. And now when I hit Route for our app, you'll see we get an error. So what's happening here? Well, I'm going to go into the debugger.

[Transcript missing]

You'll notice that the starting point is our current location. So that means it has a nil place mark. So we need to figure out what the user's location is before we try to provide a route. And the end item, this is false because this is Apple headquarters. So we already know what the latitude and longitude is for that endpoint. So let's get to fixing this.

So I've got another block of code that checks to see if either the start item or the end item is our current location. You don't have to worry about them both being your current location. So first we check to see if the start item is our current location. And if so, we know where the end item is, but we need to get our current location first before providing a route.

If the opposite is the case and the end item is our current location, then we know the starting point, but we need to get the current location before trying to provide a route. and these are two methods we still need to implement. In the else case, we know the start item and end item coordinates. So the code that we already had right here is still going to work. So I'm just going to cut that in and paste it into the else block.

So we just got a little more here. We need to implement these two methods, which look up our current location before providing a route. So this is implemented in our map view controller. So we go to the header file. And here's our route from place to place, which expects places with coordinates. I'm going to drag in two extra methods that we were looking for. One if the starting point is our current location and one if the ending point is our current location. Then I'm going to go into the implementation file, scroll down to that route from place method.

Here it is. And then below it, I'm going to implement the two methods we just added in the header. So these are pretty much the same method, but they're for the two different cases. And if you don't know the user's current location, but we know the end place, then first we acquire the user's current location. And then this block we've implemented has a block that, once it knows the user's location, will create a MyPlace for the current location and then call routeFromPlace, that method above, from our current location to the end place we already knew.

And pretty much the opposite for if we know the starting place but not the ending place, since it's our current location. So we get our current location, create a MyPlace for our current location, then call routeFromPlace with the start place we knew and the end place being our current location. And now we're done. So if I build and run-- Switch to Maps. Hit Directions.

And this time when we launch our app, we're going to do more than just launch our app. Our app is instantly going to provide a route. So you see the user hasn't hit anything else other than the Route button. And it knows that we should get on at the San Francisco Caltrain Station and get off at the Sunnyvale Caltrain Station.

But notice that you don't even have to have a map. If your app was a taxi example, the taxi app could just say your estimated price is this, taxi coming at this time. It's coming to pick you up now. So you don't need to use an MKMapView to be a routing app.

So this is it. We're done converting our app to a routing app. Go back to the slides. So I've told you how to make a routing app and why it's really great. But what are some good practices for making a routing app? Well, the first step is-- You want to minimize the user input after launch. And I've mentioned this a couple times, but it's really important because you want to make your app feel like it's just another directions mode. The easier it is, the more likely they are to jump into your app.

Also, because this is the same API where you can add extra metadata with MKMapItem, use that metadata to customize your route. Instead of saying directions to 39 latitude, negative 122 longitude, use that MKMapItem to use a title and phone number to make it really customized, like have a call this place button.

Lastly, be reasonable with your geographic coverage. Your users don't want to see your app where you definitely can't provide a route. But they also don't want to see your app missing where they expect it could. So be reasonable, but don't cover much more than you think you would or much less than you might. So that's the Routing Apps feature. And as we said, we think this is a great opportunity for Routing Apps because you'll now be able to integrate directly with Maps. And for many people, Maps is a starting point when figuring out where they're going.

So we expect that you'll see increased traffic because instead of being maybe buried in the third page of the home screen, now your app will be presented in Maps when you can really provide a route. You'll also get promoted to users that don't have your app when users care about using it. So this is targeted promotion based off the start and end point. So again, a big opportunity to be seen by users who want to use your app.

So that's the Routing Apps API. We've gone over a lot of new things in iOS 6. First, being we have all new maps with the same API. So your code is just going to work. And if you notice that something isn't behaving the way you expect, please file a bug.

Then we introduced MKMapItem, which makes it really easy to open maps with a minimal amount of code. And then lastly we went over this brand new integration with Routing Apps. We will integrate Routing Apps directly into Maps and launch your app. That's what's new with Map Kit and iOS 6.

If you'd like more information, our evangelist is Paul Marcos. You can send him an email. If you're new to Map Kit, this was more of what's new in iOS 6. But if you're new to Map Kit, check out the documentation. We've got really great documentation online. MKMapView specifically is a good starting point for how to use Map Kit. And it also links to other information, like how to use annotations and overlays. So it's a really good starting point. If you're looking to more in-depth coverage of how to use location services in your app, check out the Location Awareness Programming Guide.

It's got a lot of more stuff in detail. Also, because the API is the same, last year's WWDC talk is still relevant. So it's really good. It goes over a lot of the basics of Map Kit. You can check it out online. It's called Visualizing Information Geographically with Map Kit. And if you have any questions that don't get answered at the labs, feel free to ask them on the developer forums.

So we've got a repeat session this afternoon at 3:15 in Pacific Heights, if you know anyone who could make this one. If you're thinking about submitting a routing app, you'll be going over how to submit a GeoJSON file using iTunes Connect in the iTunes Connect session. That's at Nob Hill at Thursday on 9. And if your app uses Map Kit, location services is probably important to you. So I recommend checking out the Staying on Track with Location Services talk. And that's at Nob Hill on Wednesday at 2:00 PM. And that's Map Kit in iOS 6. Thank you.

WEBVTT

00:00:10.420 --> 00:00:12.120
Good morning.

00:00:12.240 --> 00:00:17.060
Welcome to session 213,
Introduction to High Resolution on OS X.

00:00:17.150 --> 00:00:21.110
My name is Dan Schimpf.

00:00:21.110 --> 00:00:21.110
I'm an engineer on the
Cocoa Frameworks team.

00:00:22.870 --> 00:00:26.200
I'd like to start with a
little bit of an introduction.

00:00:26.250 --> 00:00:28.900
As you all know,
2x Retina displays arrived

00:00:28.900 --> 00:00:31.800
first with the iPhone 4.

00:00:32.180 --> 00:00:34.090
On the Mac side,
we've only really had one scale

00:00:34.090 --> 00:00:36.600
factor to deal with for a long time.

00:00:36.600 --> 00:00:39.950
There's been many different screen sizes,
of course, but only one scale factor

00:00:40.020 --> 00:00:42.600
for the pixels on screen.

00:00:42.730 --> 00:00:45.450
That's, of course, until now.

00:00:46.530 --> 00:00:49.850
The good part is OS X takes care of a
lot of the details for you and your apps.

00:00:50.000 --> 00:00:54.530
But full adoption for your
applications will require some work,

00:00:54.660 --> 00:00:56.580
but it's going to be worth it, trust us.

00:00:58.960 --> 00:01:02.740
So here's what we're going
to be talking about today.

00:01:02.760 --> 00:01:05.340
Brief overview of what
High Resolution is for the Mac.

00:01:05.340 --> 00:01:08.160
Then we're going to talk about some
things you need to do to optimize

00:01:08.160 --> 00:01:11.260
your application for High Resolution.

00:01:11.320 --> 00:01:14.510
Talk about what to do
with your bitmap images.

00:01:16.850 --> 00:01:21.370
Talk about your icons in the
Finder and your document icons.

00:01:21.370 --> 00:01:24.480
Talk about some final touches
to make your application really

00:01:24.480 --> 00:01:25.660
the best on the new hardware.

00:01:25.660 --> 00:01:30.190
And some problems you may come into
while you're optimizing your application.

00:01:32.340 --> 00:01:35.080
So how does High Resolution work?

00:01:35.180 --> 00:01:38.040
So there are new High Resolution
display modes for the retina

00:01:38.040 --> 00:01:40.710
displays on the new hardware.

00:01:41.450 --> 00:01:46.770
The screens in the windows now
have a 4:1 pixel per point density.

00:01:47.320 --> 00:01:50.960
and the frameworks provide the
scaling between the 1X and the 2X

00:01:50.960 --> 00:01:53.820
operation for your Windows and screens.

00:01:54.410 --> 00:01:57.130
The Quartz Window Manager,
which manages all of the windows

00:01:57.170 --> 00:02:01.230
and the display on the screen,
ensures a consistent presentation

00:02:01.260 --> 00:02:05.720
of these windows across multiple
displays of different scale factors.

00:02:06.310 --> 00:02:07.200
What is High Resolution?

00:02:07.200 --> 00:02:10.200
What are we talking about here?

00:02:10.200 --> 00:02:12.360
Well, with High Resolution,
the number of pixels on

00:02:12.480 --> 00:02:13.800
screen actually quadruples.

00:02:13.870 --> 00:02:18.200
You may see 2X, but you actually get four
times as many pixels.

00:02:18.220 --> 00:02:21.200
So, that's four pixels on
screen for each point.

00:02:21.340 --> 00:02:23.240
Well, what is a point?

00:02:23.400 --> 00:02:24.800
Point is a unit of measurement.

00:02:24.910 --> 00:02:30.260
It's commonly referred
to as 1/72 of an inch,

00:02:30.260 --> 00:02:33.140
although on actual computer monitors,
this can vary.

00:02:33.880 --> 00:02:38.140
And what this leads to is more
pixels to display your text,

00:02:38.230 --> 00:02:41.790
sharper text and more detailed graphics,
as we say.

00:02:42.970 --> 00:02:45.740
So let's do a quick demonstration.

00:02:45.760 --> 00:02:48.180
This is a point on screen.

00:02:48.190 --> 00:02:52.200
There are many points like it,
but this one is mine.

00:02:53.060 --> 00:02:56.070
So at 1x,
that point corresponds to one pixel.

00:02:56.080 --> 00:02:59.850
That pixel may be big or small,
but it's one point equals one pixel.

00:02:59.860 --> 00:03:03.910
At 2x, we have the same point,
but that corresponds to four

00:03:04.700 --> 00:03:06.230
pixels in the same area.

00:03:09.710 --> 00:03:12.830
So how does this compare to iOS,
which you may be familiar with?

00:03:12.920 --> 00:03:15.310
Well, it's actually very similar.

00:03:15.340 --> 00:03:18.700
The basic tenets are the same
between the two platforms.

00:03:18.700 --> 00:03:21.600
They both have an
integral UI scale factor,

00:03:21.600 --> 00:03:24.970
1x and 2x,
and they both provide a lot of automatic

00:03:24.970 --> 00:03:26.780
scaling from the application frameworks.

00:03:28.580 --> 00:03:32.550
There are some enhanced functionality
for the unique needs of OS X,

00:03:32.880 --> 00:03:35.500
particularly in the realm
of multiple displays.

00:03:35.500 --> 00:03:38.360
If you have multiple displays attached,
one can be at 1X,

00:03:38.360 --> 00:03:41.000
another one can be at 2X,
depending on the capabilities

00:03:41.030 --> 00:03:42.040
of that hardware.

00:03:42.040 --> 00:03:44.800
So there's unique functionality
in OS X to handle this.

00:03:44.800 --> 00:03:47.170
This corresponds to
Windows versus screens,

00:03:47.250 --> 00:03:50.380
because different screens
have different scale factors,

00:03:50.380 --> 00:03:54.540
so that means different Windows can
have different scale factors as well.

00:03:55.140 --> 00:03:59.330
And the Mac has to be more dynamic
in terms of the resolution changes.

00:03:59.330 --> 00:04:03.450
Displays coming and going,
the user changing the settings as well.

00:04:05.760 --> 00:04:08.550
More pixels on screen means
we can do more with them.

00:04:08.690 --> 00:04:12.980
If there's a yellow blob on screen at 1X,
you can see there's lots

00:04:12.980 --> 00:04:16.100
of fuzziness on the edges.

00:04:16.230 --> 00:04:19.320
But if we take it to 2X,
we can show a finer detail.

00:04:19.460 --> 00:04:21.760
And with the same,
let's say the same shape,

00:04:21.850 --> 00:04:31.740
the same mathematical shape corresponds
to a sharper detail in that shape.

00:04:31.740 --> 00:04:31.740
So here we are at 1X again.

00:04:32.590 --> 00:04:37.980
16 by 8, 16 pixels, 16 points, with,
but we got a 2X,

00:04:37.980 --> 00:04:41.780
all of a sudden we have 32 pixels
for the same number of 16 points.

00:04:45.420 --> 00:04:46.700
So how does this work?

00:04:46.850 --> 00:04:48.980
On OS X,
we've got a unified coordinate system.

00:04:49.160 --> 00:04:52.010
That means all coordinates are in points.

00:04:55.070 --> 00:04:59.750
This means view frames, window locations,
screen sizes,

00:04:59.760 --> 00:05:01.500
all these things are in points.

00:05:01.500 --> 00:05:05.380
And because different displays
can be different scale factors,

00:05:05.380 --> 00:05:08.330
it can differ by screen and window.

00:05:10.890 --> 00:05:15.150
But the good news is, for the most part,
your apps don't need to care about this.

00:05:15.430 --> 00:05:17.040
You just pay attention to
what we're telling you,

00:05:17.040 --> 00:05:22.250
and your applications will probably work,
for the most part, without any changes.

00:05:23.170 --> 00:05:26.860
So here's two screens
hooked up to your system.

00:05:26.940 --> 00:05:29.170
They both have the same number of points.

00:05:29.320 --> 00:05:31.670
Because one is running at 2x,
they both show up with

00:05:31.670 --> 00:05:32.690
the same number of points.

00:05:32.700 --> 00:05:35.710
But it turns out the 2x one
actually has two times as

00:05:35.770 --> 00:05:39.060
many pixels on each dimension.

00:05:39.220 --> 00:05:43.700
So they come across as
the same logical size.

00:05:44.890 --> 00:05:47.800
So how does this work with
your current apps right now?

00:05:47.830 --> 00:05:50.240
Well, by default,
Cocoa apps are scaled automatically.

00:05:50.240 --> 00:05:57.400
That means that you get sharp text
and crisp Aqua graphics for free.

00:05:58.360 --> 00:06:00.600
Well,
except your custom bitmaps that you have,

00:06:00.640 --> 00:06:01.740
they're not going to be optimized.

00:06:01.740 --> 00:06:03.600
We can't invent pixels that aren't there.

00:06:03.600 --> 00:06:05.850
So they're just going to be magnified.

00:06:07.780 --> 00:06:10.490
By default, Carbon apps are magnified.

00:06:10.610 --> 00:06:14.820
This means that the text and
UI widgets are magnified as well

00:06:14.820 --> 00:06:18.190
and needing to be unoptimized.

00:06:18.970 --> 00:06:21.550
So here's what you need to
do with your app to make them

00:06:21.610 --> 00:06:24.330
ready for High Resolution.

00:06:24.440 --> 00:06:26.660
First, you're going to go through
all of your 1x bitmaps,

00:06:26.680 --> 00:06:30.160
and you're going to need to add
2x representations of all of them.

00:06:30.760 --> 00:06:32.380
and then you're going to
need to do High Resolution

00:06:32.450 --> 00:06:33.820
icons for use in the Finder.

00:06:33.820 --> 00:06:37.730
These are your application
icons and your document icons.

00:06:38.960 --> 00:06:42.300
Then you're going to need to look through
your code for any uses of deprecated API,

00:06:42.300 --> 00:06:44.820
things that may have been hanging
around maybe a bit too long,

00:06:44.820 --> 00:06:48.940
and now's a good time to switch to
a more modern equivalent because it

00:06:48.940 --> 00:06:53.680
turns out these modern methods are
more capable of handling things.

00:06:53.680 --> 00:06:54.840
They have more information.

00:06:54.840 --> 00:06:56.490
We can make better decisions about them.

00:06:58.520 --> 00:07:01.060
And while you're doing that,
also look through and see if you're

00:07:01.060 --> 00:07:02.540
making any bad assumptions about pixels.

00:07:02.540 --> 00:07:05.800
We've long said that one point
does not equal one pixel,

00:07:05.830 --> 00:07:08.720
and now's the time where
we're making it real.

00:07:10.640 --> 00:07:13.100
But perhaps the best thing
to do is just give it a try.

00:07:13.100 --> 00:07:15.880
If you get your hands on some hardware,
you can try it out there,

00:07:15.880 --> 00:07:17.800
but you can also try it
out on your home system.

00:07:17.800 --> 00:07:20.250
You don't need to wait for
your hardware to show up,

00:07:20.250 --> 00:07:22.520
and you may be surprised
by how well it works.

00:07:25.450 --> 00:07:29.590
So here's how to test it at home
before your hardware shows up.

00:07:29.870 --> 00:07:32.680
If you haven't already,
install the graphics tools for Xcode,

00:07:32.800 --> 00:07:36.110
because you're going to want to
open Quartz Debug and open the

00:07:36.110 --> 00:07:38.860
UI Resolution window from the menu bar.

00:07:38.980 --> 00:07:42.540
And you're going to select
High DPI Display Modes.

00:07:42.630 --> 00:07:47.820
And what that's going to do is
after you log out and log back in--

00:07:47.970 --> 00:07:50.180
You can use the
Display System Preferences pane

00:07:50.250 --> 00:07:52.270
to select a high DPI display mode.

00:07:52.280 --> 00:07:56.190
This is an example from a laptop,
which will be kind of small if you

00:07:56.190 --> 00:07:59.800
don't have the nice new hardware,
but you can still use it to test.

00:08:04.300 --> 00:08:06.490
Okay, I'm going to hand it over
to my colleague Patrick,

00:08:06.510 --> 00:08:08.540
who's going to talk more about
what to do with your artwork.

00:08:13.400 --> 00:08:15.980
Thank you, Dan.

00:08:16.100 --> 00:08:18.990
So, my name is Patrick Heynen,
and I'm here to tell you about artwork.

00:08:19.080 --> 00:08:20.300
Why are we talking about artwork?

00:08:20.390 --> 00:08:22.890
Well, at the end of the day,
with the Retina display,

00:08:22.890 --> 00:08:24.910
it's really all about pixels, isn't it?

00:08:25.120 --> 00:08:30.900
and well executed designs really can have
an extraordinary impact on the quality,

00:08:30.900 --> 00:08:34.950
on the impact on your application
and how well it looks.

00:08:35.720 --> 00:08:38.700
Let's take a look at some case
studies here of Standard Resolution

00:08:38.700 --> 00:08:41.370
versus High Resolution,
just to give you an idea of what the

00:08:41.470 --> 00:08:45.930
difference really is and what Retina
really gives you for your application.

00:08:46.550 --> 00:08:49.970
So this is Final Cut Pro X,
and what we're looking at here is

00:08:49.970 --> 00:08:53.430
a standard resolution screenshot.

00:08:53.620 --> 00:08:56.990
And this is the Retina
Resolution screenshot.

00:08:57.000 --> 00:08:59.250
I'm going to go back and forward.

00:08:59.360 --> 00:09:02.440
Now, what I'd like to call attention
to here is that it's not

00:09:02.560 --> 00:09:05.850
just a standard upscale here,
but the opportunity here is to

00:09:05.980 --> 00:09:11.370
actually add significant amounts of
detail to your application graphics

00:09:11.500 --> 00:09:13.990
and really put a whole different
look and feel onto your product.

00:09:14.090 --> 00:09:15.650
So, for example,
I'd like to call attention

00:09:15.710 --> 00:09:16.800
to the camera icon there.

00:09:16.800 --> 00:09:19.350
With Standard Resolution,
there's probably not much going on there,

00:09:19.430 --> 00:09:20.720
a few little details.

00:09:20.970 --> 00:09:23.560
But at High Resolution,
there's a whole lot more detail.

00:09:23.600 --> 00:09:27.180
And there's also other subtle things
you can do to your design on Retina

00:09:27.180 --> 00:09:30.350
Display that are just simply not
possible at Standard Resolution.

00:09:30.490 --> 00:09:32.160
Let's look at another example here.

00:09:32.160 --> 00:09:33.080
This is Reminders.

00:09:33.150 --> 00:09:38.940
This is Reminders at Standard Resolution
and at Retina Resolution.

00:09:39.110 --> 00:09:41.240
Standard Resolution.

00:09:42.580 --> 00:10:00.990
Retina Resolution.

00:10:00.990 --> 00:10:00.990
I'd like to call attention to the
finer detail on the paper texture

00:10:00.990 --> 00:10:00.990
and some of the subtle highlights and
gradients that are much more able to be

00:10:00.990 --> 00:10:00.990
rendered in a much more higher quality
fashion at the Retina Resolution level.

00:10:01.500 --> 00:10:04.590
What do you need to do to
achieve these kind of results?

00:10:04.680 --> 00:10:07.450
Well,
graphics resources simply need to be

00:10:07.450 --> 00:10:09.540
created at twice the pixel density.

00:10:09.610 --> 00:10:14.050
And you just need to integrate these new
@2x image resources into your project,

00:10:14.140 --> 00:10:14.690
and you're done.

00:10:14.800 --> 00:10:16.200
It's really that easy.

00:10:16.250 --> 00:10:19.900
There is not really, in normal cases with
well-behaved Cocoa applications,

00:10:19.900 --> 00:10:22.290
you really do not need to write
any code to integrate these

00:10:22.340 --> 00:10:24.260
High Resolution artwork assets.

00:10:24.380 --> 00:10:26.100
So it's really easy.

00:10:27.470 --> 00:10:32.760
A few things to keep in mind here,
uprezzing large quantities of

00:10:32.760 --> 00:10:36.140
graphics in applications that feature
a lot of graphic resources can

00:10:36.140 --> 00:10:37.860
be a very challenging design test.

00:10:37.910 --> 00:10:40.290
And I want to emphasize here
for those of you who are maybe

00:10:40.290 --> 00:10:43.250
involved in design test as well,
this is not to be underestimated,

00:10:43.260 --> 00:10:44.470
this portion of the project.

00:10:44.590 --> 00:10:48.640
In fact, it has been our experience that
artwork-related tasks can typically

00:10:48.680 --> 00:10:52.610
consume over 50% of the overall
effort of making your application

00:10:52.610 --> 00:10:54.720
optimized for the retina display.

00:10:54.720 --> 00:10:55.900
It's not just a bunch of image files.

00:10:55.900 --> 00:10:58.140
There's a huge amount of work
and there's a lot of organization

00:10:58.140 --> 00:10:59.400
that has to go into it.

00:10:59.430 --> 00:11:03.820
And good communication between
designer and developers are essential

00:11:03.960 --> 00:11:06.480
to making this process run smoothly.

00:11:06.480 --> 00:11:09.440
Otherwise,
it can be death by a thousand paper

00:11:09.800 --> 00:11:12.860
So let's get more into the
technical nitty-gritty.

00:11:12.930 --> 00:11:14.840
So what kind of image resource
categories do you have to worry

00:11:14.840 --> 00:11:16.920
about for High Resolution?

00:11:17.200 --> 00:11:19.850
Well, there's really three: a bitmap,
a vector,

00:11:19.850 --> 00:11:21.990
and application and document icons.

00:11:22.070 --> 00:11:25.020
I'm going to talk about each of these
and some of the unique considerations for

00:11:25.020 --> 00:11:27.740
each of these under the Retina display.

00:11:28.120 --> 00:11:29.840
So, bitmap image resources.

00:11:29.840 --> 00:11:33.760
This is perhaps the most common
category of image resources.

00:11:33.810 --> 00:11:35.220
And here,
the most important thing to know

00:11:35.220 --> 00:11:40.130
about is that there is a file naming
convention that we have taken from iOS,

00:11:40.280 --> 00:11:42.290
which is the @2x file name suffix.

00:11:42.420 --> 00:11:44.380
It works very simply
and straightforwardly.

00:11:44.450 --> 00:11:47.530
You have your standard resolution
asset with just a normal file name,

00:11:47.650 --> 00:11:51.800
and then you take that same file name,
add the @2x suffix,

00:11:51.980 --> 00:11:56.170
and that should be -- and that is how
you indicate to the system that this

00:11:56.170 --> 00:11:59.540
is a double resolution retina asset.

00:11:59.570 --> 00:12:03.320
So, some details about this.

00:12:03.660 --> 00:12:07.510
So the @2x assets differ from the
standard resolution assets in that

00:12:07.510 --> 00:12:10.700
they have exactly twice as many pixels.

00:12:10.780 --> 00:12:14.100
And they should be exactly twice
the width and height in pixels.

00:12:14.100 --> 00:12:18.000
Of course, the thing to keep in mind is,
on actual display,

00:12:18.000 --> 00:12:21.950
these things are going to be the same
physical size on the Retina display as

00:12:22.110 --> 00:12:24.790
their standard resolution counterparts.

00:12:24.880 --> 00:12:28.350
This is frequently forgotten,
but it's an essential point that

00:12:28.350 --> 00:12:31.200
I'm going to be circling around
in a bunch of different ways.

00:12:31.320 --> 00:12:33.680
So here, once again,
this is looking at things

00:12:33.680 --> 00:12:35.030
just pixel for pixel.

00:12:35.040 --> 00:12:37.190
But of course,
on the actual Retina display,

00:12:37.280 --> 00:12:40.590
point for point,
that's what it's going to look like.

00:12:40.850 --> 00:12:43.530
So, how does this look like in code?

00:12:43.550 --> 00:12:44.380
How do you achieve success?

00:12:44.460 --> 00:12:46.430
How do you get this magic automatic
behavior where you don't have

00:12:46.500 --> 00:12:47.300
to write a single line of code?

00:12:47.300 --> 00:12:50.060
Well, it does help if you've already
written the right code to begin with.

00:12:50.230 --> 00:12:56.670
So, NSImage will automatically locate
and use the high resolution 2x image

00:12:56.670 --> 00:13:03.710
representations if you use the image
lookup by name constructors for NSImage.

00:13:04.250 --> 00:13:07.320
NSImage also supports
multi-resolution TIFFs,

00:13:07.350 --> 00:13:11.560
which you can generate automatically
using Xcode's combined High Resolution

00:13:11.560 --> 00:13:13.040
images project build setting.

00:13:13.080 --> 00:13:15.810
And that presents some slight
efficiencies in file system and

00:13:15.810 --> 00:13:17.340
runtime performance as well.

00:13:17.410 --> 00:13:20.070
So that's another option
you have available to you.

00:13:20.160 --> 00:13:26.340
So how does NSImage help you
in this High Resolution world?

00:13:26.750 --> 00:13:30.850
Well, the magic thing about NSImage is
that it actually is able to handle

00:13:30.860 --> 00:13:33.560
rendering of an image at any resolution,
both Standard Resolution

00:13:33.570 --> 00:13:34.360
and High Resolution.

00:13:34.370 --> 00:13:39.510
And this is actually critically
important for the Mac compared to iOS,

00:13:39.560 --> 00:13:42.130
because on the Mac,
you have multiple displays with

00:13:42.180 --> 00:13:43.570
multiple possible resolutions.

00:13:43.600 --> 00:13:48.180
And in NSImage, because of its ability to
support multiple representations,

00:13:48.180 --> 00:13:52.440
both Standard and High Resolution,
in the same NSImage object instance,

00:13:52.660 --> 00:13:58.500
it can be ready for duty
in any resolution context.

00:13:58.660 --> 00:14:01.240
So, once again,
you need to make sure you use

00:14:01.290 --> 00:14:04.960
the by name lookup to get this
automatic behavior where it finds the

00:14:04.960 --> 00:14:06.500
appropriately named file name resources.

00:14:06.500 --> 00:14:10.020
There's either the classic
NSImageImageNamed or the

00:14:10.020 --> 00:14:14.630
new NSBundle category method
we introduced in 10.7 Lion,

00:14:14.780 --> 00:14:18.740
which allows you to do the same by name
lookup from any arbitrary NSBundle,

00:14:18.740 --> 00:14:21.190
not just the main app bundle.

00:14:21.740 --> 00:14:24.600
Keep in mind, with NSImage,
the size of the image,

00:14:24.600 --> 00:14:27.350
the size of the NSImage instance,
that is, is always in points.

00:14:27.380 --> 00:14:30.860
But the pixel geometry of the individual
representations may actually vary.

00:14:30.860 --> 00:14:34.080
In fact, for proper operation,
the second representation should

00:14:34.080 --> 00:14:36.940
always be ideally twice the
pixel geometry of the first.

00:14:36.940 --> 00:14:40.470
And then at draw time,
what NSImage does is it actually

00:14:40.470 --> 00:14:44.740
chooses the best representation to
draw based on the characteristics

00:14:44.740 --> 00:14:46.520
of the rendering destination.

00:14:46.520 --> 00:14:49.040
So it computes how many pixels
it's going to draw into,

00:14:49.040 --> 00:14:50.940
and then looks at the
representations it has,

00:14:51.160 --> 00:14:53.020
and picks the one that's
going to be the best match.

00:14:53.020 --> 00:14:56.310
So in a High Resolution scenario,
in a 32 by 32 point

00:14:56.310 --> 00:14:59.290
destination rectangle,
it's going to pick the 2x64

00:14:59.330 --> 00:15:01.020
by 64 pixel representation.

00:15:01.020 --> 00:15:06.040
In contrast, both CG image and UI image,
for that matter,

00:15:06.040 --> 00:15:08.640
have a geometry that's always in pixels.

00:15:08.640 --> 00:15:10.140
Actually,
CG image isn't always in pixels.

00:15:10.140 --> 00:15:11.210
UI image is slightly different.

00:15:11.220 --> 00:15:13.650
And it's only limited to one resolution.

00:15:13.680 --> 00:15:15.310
So if you're working
with CG image directly,

00:15:15.310 --> 00:15:17.400
you have to do some of this
management yourself and be

00:15:17.400 --> 00:15:19.020
aware of the difference there.

00:15:20.810 --> 00:15:25.400
Okay, so the next image category,
Vector Image Resources.

00:15:25.550 --> 00:15:28.200
Here we're really, at the end of the day,
talking about PDF.

00:15:28.200 --> 00:15:31.820
And the nice thing about PDF is
that they scale automatically,

00:15:31.820 --> 00:15:34.740
both to any user size, that is, you know,
size on screen,

00:15:34.740 --> 00:15:36.540
as well as to any pixel density.

00:15:36.540 --> 00:15:41.050
So that, in some ways,
they're ideal for High Resolution.

00:15:41.100 --> 00:16:16.400
[Transcript missing]

00:16:16.820 --> 00:16:21.560
The way template images work is we
just treat the image as a shape.

00:16:21.700 --> 00:16:26.240
And they're typically indicated
by either having the file

00:16:26.240 --> 00:16:30.040
name suffix and in template,
or you can mark an image as a

00:16:30.040 --> 00:16:33.720
template by saying NSImageSetTemplate,
yes?

00:16:34.200 --> 00:16:38.870
And what happens is at draw time,
AppKit actually takes that shape that

00:16:39.000 --> 00:16:43.660
you provide and uses some image effects
to actually provide context-specific

00:16:43.700 --> 00:16:48.040
appearance appropriate to the current
state of the control or the window.

00:16:48.040 --> 00:16:51.170
So, for example,
you automatically get pressed, disabled,

00:16:51.170 --> 00:16:53.720
inactive, you know, rollover appearances.

00:16:53.720 --> 00:16:58.130
All that stuff is provided
automatically and matches the

00:16:58.130 --> 00:17:00.510
look and feel of the system.

00:17:01.380 --> 00:17:04.170
And most importantly,
this effects rendering and the

00:17:04.170 --> 00:17:07.420
rasterization of your shape is
done at full backing resolution,

00:17:07.420 --> 00:17:11.220
which means you automatically
get a high-quality look on both

00:17:11.220 --> 00:17:13.360
standard and high resolution.

00:17:14.960 --> 00:17:17.720
Okay,
so that covers vector image resources.

00:17:17.910 --> 00:17:22.030
Now let's talk about
application and document icons.

00:17:22.440 --> 00:17:25.140
So you may have encountered these before.

00:17:25.140 --> 00:17:29.140
These are the traditional
back by ICNS files.

00:17:29.180 --> 00:17:31.500
And these are some-- and
they're used by Finder,

00:17:31.600 --> 00:17:34.820
Open Save Panel, Spotlight Menu,
a couple other areas.

00:17:34.900 --> 00:17:37.600
These are really the way your
application advertises itself

00:17:37.720 --> 00:17:38.770
to the rest of the system.

00:17:39.000 --> 00:17:42.160
So you don't typically see
these resources in your app,

00:17:42.230 --> 00:17:45.020
but they're typically consumed by
other Apple software or other pieces

00:17:45.020 --> 00:17:46.420
of software outside of your app.

00:17:46.420 --> 00:17:51.730
So they're an important part of
the overall imagery of your app.

00:17:52.650 --> 00:17:54.300
Now, they're kind of special, right?

00:17:54.370 --> 00:17:57.940
Because ICNS files and icons in general
are the only sort of image category that

00:17:57.940 --> 00:18:01.810
have both-- have a variable user size.

00:18:01.890 --> 00:18:04.930
They have the magical property that
they can be rendered any size and are

00:18:04.930 --> 00:18:10.540
supposed to have a high quality result at
almost any size that you draw them into.

00:18:10.750 --> 00:18:12.450
So, how does it do this?

00:18:12.590 --> 00:18:16.540
Well, ICNS, as you may know,
has five slots for providing

00:18:16.540 --> 00:18:19.050
individual bitmap representations.

00:18:19.050 --> 00:18:23.400
16x16, 32x32, 128, 256, and 512.

00:18:23.400 --> 00:18:27.190
And then what happens at draw time,
very similar to the way

00:18:27.190 --> 00:18:31.930
I described in this image working,
it just chooses the most appropriate

00:18:31.930 --> 00:18:36.100
pixel slot based on how many
pixels it's about to draw into.

00:18:36.120 --> 00:18:39.280
So, for example,
if on High Resolution we're drawing

00:18:39.280 --> 00:18:43.740
into a 128-point point rectangle,
which really is 256 pixels,

00:18:43.930 --> 00:18:46.740
it'll just go and find
that 256-pixel slot,

00:18:46.920 --> 00:18:49.400
take that representation, and draw it.

00:18:53.190 --> 00:18:54.060
So what's the problem?

00:18:54.200 --> 00:18:57.600
Why am I even blathering on about this?

00:18:57.630 --> 00:19:01.000
Well, there is a problem, unfortunately.

00:19:01.000 --> 00:19:03.530
Retina displays are different.

00:19:06.410 --> 00:19:09.220
Let's go into detail here,
what I mean here.

00:19:09.410 --> 00:19:12.540
So let's look at a 16 by 16 icon.

00:19:12.540 --> 00:19:15.180
So at 2x,
that's what you really want to draw,

00:19:15.180 --> 00:19:16.420
a 16 by 16 icon.

00:19:16.420 --> 00:19:20.380
As for example, in a list view in Finder
or in the Open Panel,

00:19:20.800 --> 00:19:24.210
you really need 32 pixels.

00:19:25.300 --> 00:19:35.700
[Transcript missing]

00:19:36.340 --> 00:19:37.220
Now, here's a key point.

00:19:37.220 --> 00:19:39.220
There's two key points I'm
going to talk about here.

00:19:39.270 --> 00:19:41.260
And I'm going to spend a
little bit of time on them.

00:19:41.270 --> 00:19:44.640
First off,
icons with the same pixel count,

00:19:44.710 --> 00:19:47.540
but different target resolution--
by target resolution,

00:19:47.540 --> 00:19:51.220
I really mean target pixel density--
may need different visual treatment

00:19:51.580 --> 00:19:53.500
because of the display size.

00:19:53.620 --> 00:19:57.780
Since these are not just the same-- these
are the same exact amount of pixels,

00:19:57.840 --> 00:20:02.350
but because on a retina display,
things are so much physically smaller,

00:20:02.350 --> 00:20:06.650
from a graphical design perspective,
you will probably find yourself

00:20:06.700 --> 00:20:10.150
needing to use different heuristics
to get the same perceptual effect.

00:20:10.270 --> 00:20:13.490
You might want to, for example,
strengthen and emphasize strokes,

00:20:13.490 --> 00:20:18.030
use slightly more saturated colors,
or just use a slightly different

00:20:18.030 --> 00:20:20.680
graphical treatment than you
would at the same physical size

00:20:20.790 --> 00:20:23.170
on a standard resolution display,
just because the perceptual

00:20:23.290 --> 00:20:26.530
characteristics of the
retina display are different.

00:20:30.100 --> 00:22:44.800
[Transcript missing]

00:22:45.640 --> 00:22:48.760
Okay, so what have we done to
actually make this happen?

00:22:48.800 --> 00:22:49.630
Two things.

00:22:49.710 --> 00:22:53.970
The first is we have enhanced
the ICNS format to support 2X

00:22:54.000 --> 00:22:57.240
variants for every user size slot.

00:22:57.320 --> 00:22:58.950
And by the way,
everything I mention here,

00:22:58.960 --> 00:23:01.040
although it's got that new badge,
it's actually new in

00:23:01.100 --> 00:23:02.930
10.7.4 and Mountain Lion.

00:23:02.930 --> 00:23:04.360
It's not just limited to Mountain Lion.

00:23:04.360 --> 00:23:08.120
So it's starting with the
new MacBook Pro right now.

00:23:08.940 --> 00:23:12.810
Under High Resolution,
these @2x variants are prioritized

00:23:12.950 --> 00:23:15.600
when you're actually drawing
to a retina display or a high

00:23:15.600 --> 00:23:18.370
resolution window backing store.

00:23:20.230 --> 00:23:23.800
and some of you who have been following
this story of High Resolution over

00:23:23.800 --> 00:23:28.440
the years would like to know that --
would be interested to know that the

00:23:28.440 --> 00:23:32.830
1024 by 1024 size that we introduced
last year has now been just relabeled.

00:23:32.830 --> 00:23:35.310
It's now the 512 by 512 at 2X.

00:23:35.320 --> 00:23:40.350
And the 1024 size slot itself
is effectively deprecated.

00:23:41.870 --> 00:23:47.280
Not every slot in this full matrix
needs to be populated for the Icon

00:23:47.390 --> 00:23:50.650
runtime machinery to work correctly,
but having all of the 2x

00:23:50.650 --> 00:23:53.300
counterparts is kind of
recommended as a practical measure.

00:23:53.300 --> 00:23:56.340
Because once you go to the effort of
doing your optimization for Retina,

00:23:56.350 --> 00:23:58.580
it's really just simpler
to just provide them all.

00:23:58.580 --> 00:24:01.230
That's been our experience
at the very least.

00:24:01.260 --> 00:24:02.040
Okay, next.

00:24:02.080 --> 00:24:04.940
So how do you actually create
one of these image resources

00:24:04.940 --> 00:24:06.560
with this crazy new format?

00:24:07.680 --> 00:24:12.560
Well,
you may have used Icon Composer before,

00:24:12.560 --> 00:24:17.020
and it's got the workflow of building
an icon one image well at a time.

00:24:17.020 --> 00:24:19.960
You get your graphics from wherever,
and then you've got to go drag

00:24:20.170 --> 00:24:21.800
them in into all these image wells.

00:24:21.980 --> 00:24:24.850
Well, we've decided that's just
fundamentally broken,

00:24:24.850 --> 00:24:26.090
that whole workflow.

00:24:26.280 --> 00:24:31.780
So Icon Composer is effectively
deprecated as of now.

00:24:32.370 --> 00:24:35.350
And there was much rejoicing.

00:24:35.500 --> 00:24:39.080
So what have we done to replace it?

00:24:39.220 --> 00:24:43.860
Well, we're introducing
something called Icon Sets.

00:24:43.910 --> 00:24:49.140
Icon Sets are a new icon art
delivery format for High Resolution.

00:24:49.820 --> 00:24:51.900
And what it really is,
it's really actually quite simple.

00:24:51.900 --> 00:24:53.420
It's almost too simple.

00:24:53.480 --> 00:24:56.140
It's just a folder and
file naming convention.

00:24:56.250 --> 00:24:59.740
So it's a folder, and it has to have a
suffix called .iconset.

00:24:59.840 --> 00:25:03.170
And what it contains inside of it
are a whole bunch of PNG files,

00:25:03.320 --> 00:25:07.160
and they look a little familiar,
and they should.

00:25:07.160 --> 00:25:09.730
They have their-- just like
standard bitmap graphic resources,

00:25:09.730 --> 00:25:11.170
except with one additional twist.

00:25:11.360 --> 00:25:14.760
They have encoded into the file name
not just whether they're standard

00:25:14.760 --> 00:25:19.160
resolution and high resolution,
but also what size slot they conform to.

00:25:19.700 --> 00:25:23.420
And so there's a standard naming
convention for each of these

00:25:23.420 --> 00:25:27.520
files organized into a folder
with the .iconset extension.

00:25:27.570 --> 00:25:32.190
And this is the way that we
expect you to integrate your

00:25:32.190 --> 00:25:34.490
artwork into your project sources.

00:25:35.700 --> 00:25:39.730
So, what are the features and
benefits of icon sets?

00:25:39.790 --> 00:25:43.230
Well, first and foremost,
they are a much better fit

00:25:43.370 --> 00:25:44.840
with existing design workflows.

00:25:44.840 --> 00:25:46.770
I'm going to demonstrate
this in a second,

00:25:46.800 --> 00:25:48.920
but really,
given that designers are working

00:25:48.920 --> 00:25:52.180
in some random image authoring app
to actually create these things,

00:25:52.180 --> 00:25:55.170
what they know how to do
really well and reliably,

00:25:55.200 --> 00:25:58.310
which is very important,
is create a bunch of bitmap

00:25:58.330 --> 00:25:59.960
images like PNG files.

00:26:00.760 --> 00:26:03.280
What nobody likes to do is have
to then use a different tool to

00:26:03.280 --> 00:26:06.100
transform what their master file
is into what they actually have to

00:26:06.100 --> 00:26:07.960
integrate into the project sources.

00:26:07.970 --> 00:26:10.470
So, this gets rid of that,
eliminates that middleman,

00:26:10.470 --> 00:26:13.100
and just allows designers to
create exactly what needs to be

00:26:13.100 --> 00:26:14.830
integrated into project sources.

00:26:14.860 --> 00:26:18.050
Also, not to be underestimated,
much more reliable color

00:26:18.050 --> 00:26:19.700
management because,
again,

00:26:19.700 --> 00:26:23.930
there's less transformation going on
between the icon art deliveries and what

00:26:23.930 --> 00:26:26.240
happens on its way into the software.

00:26:28.170 --> 00:26:29.700
And speaking of on its
way into the software,

00:26:29.700 --> 00:26:34.070
the magic thing about icon sets is we've
added support in Xcode to automatically

00:26:34.070 --> 00:26:38.820
transform these into compliant
ICNS files at project build time.

00:26:38.840 --> 00:26:44.470
So Xcode 4.4 and 4.5 have been
augmented to understand icon sets

00:26:44.470 --> 00:26:49.670
as a basic graphic resource and
can automatically transform these.

00:26:49.710 --> 00:26:52.530
Just like the way that ping
files and add to X pings can get

00:26:52.530 --> 00:26:55.950
transformed automatically to TIFFs,
it also knows how to convert

00:26:55.950 --> 00:26:57.350
icon sets into ICNSs.

00:26:58.100 --> 00:27:02.050
We've also provided a quick look
plugin for verification of icon sets.

00:27:02.140 --> 00:27:04.360
So for example, if you're a designer,
you want to make sure that

00:27:04.370 --> 00:27:06.640
what you've just generated is
actually working correctly and is

00:27:06.640 --> 00:27:08.140
properly registered and aligned.

00:27:08.140 --> 00:27:11.320
You can just hit the space bar in
the finder on the folder and it

00:27:11.320 --> 00:27:13.080
pops a little UI with a slider.

00:27:13.080 --> 00:27:14.260
I'll demonstrate that in a second.

00:27:14.260 --> 00:27:18.250
We've also provided a command line tool,
IconUtil, ships as part of the

00:27:18.340 --> 00:27:22.740
base system as of 10.7.4,
which allows you to go back and forth

00:27:22.840 --> 00:27:26.600
between ICNS files and icon sets,
convert back and forth.

00:27:26.730 --> 00:27:27.960
It's very simple, doesn't do much more.

00:27:28.100 --> 00:27:29.560
But it's quite handy.

00:27:29.560 --> 00:27:33.510
Also, one last little thing we
added to IconComposer,

00:27:33.590 --> 00:27:36.800
in case you've lost your original
sources to your icons and you need

00:27:36.800 --> 00:27:40.140
a way to bootstrap the process,
we've added a export to icon

00:27:40.140 --> 00:27:42.100
set feature to IconComposer.

00:27:42.210 --> 00:27:48.090
And that's available in the graphics
tools image for Xcode 4.4 and later.

00:27:48.760 --> 00:27:50.960
Okay, that's enough talking.

00:27:51.140 --> 00:27:53.240
Let's do some demoing.

00:27:53.240 --> 00:27:57.400
So, what we've got here is we've got an
actual MacBook Pro with Retina display.

00:27:57.400 --> 00:28:02.480
And the first thing I'm going to
demonstrate is how the process

00:28:02.480 --> 00:28:05.280
of adding High Resolution
artwork to your application.

00:28:05.280 --> 00:28:08.630
So, we've got a wonderful,
really mission-critical

00:28:08.630 --> 00:28:11.100
application here called Fishbike.

00:28:11.100 --> 00:28:14.310
And what I'd like to call your
attention to here is that it has

00:28:14.310 --> 00:28:16.390
pretty low resolution graphics.

00:28:16.520 --> 00:28:17.920
What is up with that?

00:28:17.920 --> 00:28:20.010
And it doesn't do much.

00:28:20.010 --> 00:28:24.020
It plays a few sounds if
the sound levels were up.

00:28:24.250 --> 00:28:25.840
But that's okay.

00:28:25.840 --> 00:28:29.910
We'll try that again when we
add our High Resolution artwork.

00:28:30.670 --> 00:28:35.750
So, I happen to have gotten an
artwork delivery from my designer.

00:28:35.990 --> 00:28:37.030
And look, there it is.

00:28:37.100 --> 00:28:40.560
There's the bike and the fish
with the appropriate file names,

00:28:40.560 --> 00:28:43.950
and I'm going to add it
to my resources folder.

00:28:43.950 --> 00:28:47.940
And I'm going to copy them into place.

00:28:48.710 --> 00:28:52.620
And I'm going to rebuild.

00:28:52.660 --> 00:28:54.710
And voila.

00:28:55.600 --> 00:28:56.580
It's that simple.

00:28:56.580 --> 00:28:58.140
There is no step three.

00:28:58.140 --> 00:29:00.220
Let's see if the sound works.

00:29:00.220 --> 00:29:00.810
Oh, yeah.

00:29:00.830 --> 00:29:02.680
That's a fish sound if I ever heard one.

00:29:04.000 --> 00:29:06.260
And that's a bike sound,
if I ever heard one.

00:29:06.260 --> 00:29:07.920
It's a really important app.

00:29:07.950 --> 00:29:09.170
OK.

00:29:09.250 --> 00:29:11.330
So that's the process of adding artwork.

00:29:11.450 --> 00:29:14.320
Now, but I'm still missing an
icon for my application.

00:29:14.320 --> 00:29:15.680
So what do I do about that?

00:29:15.680 --> 00:29:18.590
Well, my designer gave me a
folder called New Icon.

00:29:18.600 --> 00:29:19.170
What's in here?

00:29:19.180 --> 00:29:20.120
Oh my goodness.

00:29:20.120 --> 00:29:21.330
He gave me his source files.

00:29:21.380 --> 00:29:22.040
He was a bit lazy.

00:29:22.040 --> 00:29:23.340
He didn't create an icon set.

00:29:23.340 --> 00:29:26.640
Well, let's go figure out how
that's actually done.

00:29:26.740 --> 00:29:31.360
So what I have here is
I have a template file,

00:29:31.380 --> 00:29:34.650
which is a sort of a typical-- you
don't have to use this kind of workflow,

00:29:34.660 --> 00:29:36.420
but this is a very typical
kind of design workflow,

00:29:36.420 --> 00:29:38.980
where you have a single
Photoshop template with all

00:29:38.980 --> 00:29:40.460
of your various sizes in it.

00:29:40.460 --> 00:29:44.380
Over here are all the standard
resolution representations.

00:29:44.380 --> 00:29:48.600
And here are all the 2x representations.

00:29:48.900 --> 00:29:51.640
And you'll notice that
there are a variety,

00:29:51.640 --> 00:29:53.440
that the image is all sliced up.

00:29:53.500 --> 00:29:56.110
Every one of the representations
has a little slice around it.

00:29:56.260 --> 00:30:01.020
And what that allows me to do is
if I use the Save for Web feature,

00:30:01.190 --> 00:30:06.650
I can use this little setting
export that I created myself,

00:30:06.660 --> 00:30:09.150
and all this does is it just makes
sure that it places them all into

00:30:09.150 --> 00:30:10.940
a folder called myicon.iconset.

00:30:10.940 --> 00:30:13.860
It doesn't do anything
really fancy beyond that.

00:30:14.020 --> 00:30:16.070
Create those out.

00:30:16.400 --> 00:30:37.500
[Transcript missing]

00:30:41.120 --> 00:30:43.450
And you notice here,
you can sort of see here implicitly

00:30:43.450 --> 00:30:44.690
all the names of the files.

00:30:44.690 --> 00:30:47.000
So the file names are actually--the
little missing link I should have

00:30:47.070 --> 00:30:50.610
mentioned before is this is using
the Photoshop feature where the file

00:30:50.610 --> 00:30:55.090
names are encoded as slice names so
that when you do use the Safer Web,

00:30:55.090 --> 00:30:58.220
it automatically creates these files.

00:30:58.220 --> 00:31:00.490
And let's take a look

00:31:00.720 --> 00:31:01.400
And perfect.

00:31:01.510 --> 00:31:02.700
Fully transparent icon.

00:31:02.700 --> 00:31:03.680
Let me just demo it here.

00:31:03.680 --> 00:31:06.470
So this is the Quick Look plugin
that gives you the little slider

00:31:06.470 --> 00:31:09.360
that lets you exercise all the
different sizes of the icons.

00:31:09.360 --> 00:31:11.960
And actually,
if I had a multiple display set up here,

00:31:11.960 --> 00:31:14.780
if I had, say, this display hooked up
to this MacBook Pro,

00:31:14.890 --> 00:31:17.730
and I dragged this window across to it,
it would actually show

00:31:17.730 --> 00:31:19.340
the standard resolution.

00:31:19.340 --> 00:31:21.190
So what we're looking at
here are all the 2x reps.

00:31:21.270 --> 00:31:24.180
If I were to present that window
on the standard resolution display,

00:31:24.180 --> 00:31:25.600
it would show me the 1x reps.

00:31:25.700 --> 00:31:27.040
So it's a good way to debug your icon.

00:31:28.180 --> 00:31:44.250
So, well, how do we add it to our app?

00:31:44.310 --> 00:31:44.310
Well, first,
let's name it something appropriate.

00:31:44.310 --> 00:31:44.310
And now let's go back
to our Fishbike app,

00:31:44.310 --> 00:31:44.310
and let's add it to the resources here.

00:31:46.950 --> 00:31:50.150
And let's rebuild.

00:31:50.190 --> 00:31:52.440
And I don't know if you noticed that,
but I'll bring it up here.

00:31:52.440 --> 00:31:57.060
Voila,
we have a beautiful icon already built.

00:31:57.100 --> 00:31:59.570
Built automatically by Xcode.

00:31:59.710 --> 00:32:03.440
And just because it's fun,
play the sounds again.

00:32:03.440 --> 00:32:05.480
Oh, that's definitely a fish sound.

00:32:05.900 --> 00:32:16.450
: All right.

00:32:16.450 --> 00:32:16.450
I think we're done.

00:32:16.450 --> 00:32:16.450
We've got a perfectly optimized
High Resolution app for the

00:32:16.450 --> 00:32:16.450
MacBook Pro right in the display.

00:32:16.450 --> 00:32:16.450
All right.

00:32:17.810 --> 00:32:19.480
And that's the end of my demo.

00:32:19.520 --> 00:32:21.530
I'm going to hand it back
over to my colleague,

00:32:21.530 --> 00:32:21.870
Dan Schimpf.

00:32:21.930 --> 00:32:24.890
And he's going to talk about some
final touches you can put on your

00:32:24.890 --> 00:32:26.810
apps and some considerations.

00:32:26.820 --> 00:32:28.500
You go, Dan.

00:32:29.090 --> 00:32:30.270
Thank you, Patrick.

00:32:32.840 --> 00:32:34.800
Thank you.

00:32:34.800 --> 00:32:36.750
Okay.

00:32:36.820 --> 00:32:38.080
So what are some final things
you're going to need to know

00:32:38.080 --> 00:32:40.790
about as you work on this?

00:32:40.840 --> 00:32:43.960
As I said before,
the display scale is dynamic.

00:32:44.270 --> 00:32:44.960
It can change.

00:32:45.190 --> 00:32:47.900
The user is allowed
to change it any time.

00:32:47.950 --> 00:32:49.920
They can attach a different display.

00:32:50.050 --> 00:32:51.140
They can attach a projector.

00:32:51.330 --> 00:32:53.440
That is a different scale factor.

00:32:53.470 --> 00:32:56.070
They can drag a window from
one display to another.

00:32:56.080 --> 00:32:58.590
That's changing its scale factor.

00:32:59.330 --> 00:33:01.150
Here's a quick demonstration
of how that works.

00:33:01.210 --> 00:33:04.300
If I've got a 1x display and a 2x
display right next to each other,

00:33:04.300 --> 00:33:07.020
and I've got a window
straddled between both of them.

00:33:07.260 --> 00:33:09.200
As you can see,
the window is labeled 1x right now.

00:33:09.200 --> 00:33:12.190
That's because it's
primarily on the 1x side.

00:33:12.200 --> 00:33:18.200
The display that owns more of
the window wins in this case.

00:33:18.200 --> 00:33:23.190
So what happens when the user, say,
drags it over to the 2x side?

00:33:23.410 --> 00:33:26.300
Well, now more than 50% of that
window is on the 2X display,

00:33:26.300 --> 00:33:31.370
so the window automatically rebuilds
itself into a 2X backing store.

00:33:33.360 --> 00:33:33.880
So how do you do this?

00:33:33.970 --> 00:33:36.960
How do you react to display changes?

00:33:37.090 --> 00:33:39.060
Well, you don't need to do much.

00:33:39.130 --> 00:33:40.630
In fact,
you may not need to do anything at all.

00:33:40.720 --> 00:33:45.010
NSWindow automatically redraws
itself when it switches scale factor.

00:33:46.530 --> 00:33:50.700
So that means that any content that you
have that's dynamic automatically works.

00:33:50.700 --> 00:33:56.560
If you're caching bitmap drawing,
you may have to do some extra work.

00:33:56.710 --> 00:34:01.100
So preferably don't cache any
drawing at a specific scale factor.

00:34:02.800 --> 00:34:04.790
But if you do,
what you have to do is invalidate

00:34:04.820 --> 00:34:08.650
that cache at the react to
the change when it happens.

00:34:10.900 --> 00:34:14.020
Let's talk a little about deprecated
API that you may still be using,

00:34:14.020 --> 00:34:19.280
but is going to cause you some trouble
when moving to High Resolution.

00:34:19.700 --> 00:34:21.600
Convert Rect to Base.

00:34:21.600 --> 00:34:24.520
It turns out this method
had two uses in the past,

00:34:24.690 --> 00:34:28.910
and now in the High Resolution world,
those two different uses

00:34:28.910 --> 00:34:30.690
have two different answers.

00:34:30.690 --> 00:34:34.740
So we deprecated Convert Rect to Base,
and we're replacing it with two

00:34:34.740 --> 00:34:36.890
methods for each of those two uses.

00:34:37.460 --> 00:34:41.120
Convert Rect to Layer will deal
with converting a rectangle,

00:34:41.120 --> 00:34:44.780
or there's also corresponding
size and point variance.

00:34:44.780 --> 00:34:48.940
So you can convert those coordinates
from a view to its layer.

00:34:48.940 --> 00:34:53.850
And then there's Convert Rect to View,
which has been around for a long time,

00:34:53.850 --> 00:34:56.920
with a nil view to get
the window coordinates.

00:35:00.520 --> 00:35:04.560
NSImage composite to point,
also dissolve to point.

00:35:04.690 --> 00:35:09.350
This has been long deprecated and now
it will -- this is the time when you

00:35:09.350 --> 00:35:14.840
really want to get rid of these calls
because they will have funny behaviors

00:35:14.840 --> 00:35:17.520
at High Resolution in some cases.

00:35:17.840 --> 00:35:20.530
We recommend using the NSImage
methods that begin with draw.

00:35:20.800 --> 00:35:26.630
So if you're going to draw an image,
look for a method beginning with

00:35:26.630 --> 00:35:26.630
draw and you should be all set.

00:35:27.750 --> 00:35:34.260
NSScreen user space scale factor
is tied to the pre-10.7 model

00:35:34.260 --> 00:35:39.600
of High Resolution interface,
and it will always return one now.

00:35:40.300 --> 00:35:59.800
[Transcript missing]

00:36:01.040 --> 00:36:06.040
If you're caching those bitmap drawings,
you may have to take some special

00:36:06.040 --> 00:36:09.600
considerations to deal with
High Resolution accurately.

00:36:09.720 --> 00:36:14.910
So the preferred way to do this is to
create an NSBitmapImageRep and then use

00:36:14.910 --> 00:36:18.210
an NSGraphicsContext to draw it into.

00:36:19.180 --> 00:36:23.020
The benefits of this is that
it's automatically scaled to the

00:36:23.020 --> 00:36:27.990
correct scale factor for wherever
context you're drawing into.

00:36:28.300 --> 00:36:31.080
CG bitmap context,
which some of you may be using,

00:36:31.100 --> 00:36:33.800
is similar to CG image in
that it's measured in pixels.

00:36:33.800 --> 00:36:36.490
So if you're going to
use CG bitmap context,

00:36:36.490 --> 00:36:40.010
you're going to need to scale the
context yourself by the scale of

00:36:40.010 --> 00:36:42.050
your final drawing destination.

00:36:43.620 --> 00:36:50.050
Keep in mind that you need to
invalidate that cache when the

00:36:50.100 --> 00:36:54.820
destination scale factor changes.

00:36:54.820 --> 00:36:54.820
So that's something extra
you need to keep track of.

00:36:56.200 --> 00:36:57.200
Okay.

00:36:57.200 --> 00:37:01.120
So, let's talk about a few things,
a few problems you may run into

00:37:02.030 --> 00:37:05.470
when you're converting your
application into High Resolution.

00:37:07.310 --> 00:37:08.860
So my two X images aren't drawing.

00:37:08.860 --> 00:37:09.580
I've got them.

00:37:09.580 --> 00:37:11.850
I think they're there,
but I don't see them showing up.

00:37:11.920 --> 00:37:14.750
My images are still a little bit fuzzy.

00:37:15.030 --> 00:37:18.520
Well, first thing you should do is
check out your build product to

00:37:18.520 --> 00:37:19.520
make sure they're actually there.

00:37:19.520 --> 00:37:22.160
Maybe Xcode isn't including
them for some reason.

00:37:22.160 --> 00:37:23.090
They're in the wrong spot.

00:37:23.140 --> 00:37:26.780
Keep in mind that they
can either be at 2x ping,

00:37:27.040 --> 00:37:30.780
or if you combine them to
a High Resolution TIFF,

00:37:30.780 --> 00:37:33.390
you need to look for the TIFF.

00:37:34.810 --> 00:37:37.800
And there's a tool in Quartz
Debug that helps you with this.

00:37:37.880 --> 00:37:39.720
If you have Quartz
Debug installed already,

00:37:39.740 --> 00:37:43.920
you can use the Tools menu
to enable Color 1x Artwork.

00:37:43.940 --> 00:37:47.650
And this is similar to an option
that's available in the iOS Simulator,

00:37:47.710 --> 00:37:52.310
where it will paint any image
that is scaling up from 1x to

00:37:52.310 --> 00:37:55.470
2x to make them pop out at you.

00:37:58.990 --> 00:38:02.820
Now my image is actually
drawing four times as big.

00:38:02.880 --> 00:38:05.530
It's being scaled twice somehow.

00:38:05.620 --> 00:38:09.560
So make sure you're not scaling this
twice inadvertently or on purpose

00:38:09.950 --> 00:38:13.130
when we're already scaling it for you.

00:38:13.340 --> 00:38:17.940
And again, the best thing to do here is
ignore the 2x as much as possible

00:38:18.020 --> 00:38:19.860
and let AppKit handle it.

00:38:19.930 --> 00:38:23.530
That will make your code
cleaner and make this better.

00:38:24.000 --> 00:38:26.550
This is another case where
things like Composite to

00:38:26.550 --> 00:38:28.140
Point really come back to bite you.

00:38:28.140 --> 00:38:31.590
Depending on how your context is set up,
especially if you're doing

00:38:31.590 --> 00:38:35.570
off-screen bitmap drawing,
using Composite to Point can sometimes

00:38:35.570 --> 00:38:38.290
lead to image drawing way too big.

00:38:40.390 --> 00:38:42.160
Let's say my views aren't aligned.

00:38:42.160 --> 00:38:43.900
I'm doing some manual layout in code.

00:38:43.900 --> 00:38:46.600
I'm setting some frame,
I'm calculating frames,

00:38:46.600 --> 00:38:50.060
and now all of a sudden
they're just a little bit off.

00:38:50.240 --> 00:38:52.390
There's maybe some pixel cracks.

00:38:52.460 --> 00:38:56.270
So there's this method in NSView,
centerScanRect.

00:38:56.380 --> 00:38:59.100
You pass it a frame,
it gives you back another frame that's

00:38:59.100 --> 00:39:00.900
aligned on a good grid boundary.

00:39:00.900 --> 00:39:03.970
And you're going to want
to use that instead of,

00:39:03.970 --> 00:39:09.200
say, rounding the frame values yourself
or using floor or anything like that.

00:39:09.620 --> 00:39:14.510
Because it turns out at 2x,
you can actually have something at 0.5x

00:39:14.510 --> 00:39:19.470
and still be on a good grid boundary
because you've got a pixel there.

00:39:19.480 --> 00:39:21.650
So it's not going to be misaligned.

00:39:23.500 --> 00:39:42.900
[Transcript missing]

00:39:44.170 --> 00:39:47.960
There can be rounding differences
between 1X and 2X because all the

00:39:48.050 --> 00:39:50.150
pixel sizes are doubled at 2X.

00:39:50.310 --> 00:39:54.340
So that means that there are really
no odd pixel values at 2X unless

00:39:54.650 --> 00:39:55.980
you're doing something very custom.

00:39:55.980 --> 00:39:59.970
And that can lead to some
rounding differences.

00:40:01.340 --> 00:40:05.780
So if you can manage that,
try to control the rounding and see

00:40:05.780 --> 00:40:08.830
if you can modify your 1x to match it.

00:40:10.550 --> 00:40:14.100
So I'm doing some window layout,
and my window's in the wrong place now.

00:40:14.100 --> 00:40:15.820
If you've been doing
High Resolution before,

00:40:15.820 --> 00:40:18.010
you may be scaling your
window coordinates.

00:40:18.060 --> 00:40:19.800
But you don't need to do that anymore.

00:40:19.800 --> 00:40:21.940
Window coordinates,
just like everything else in the system,

00:40:21.940 --> 00:40:23.110
are in points.

00:40:27.600 --> 00:40:33.360
If I have a custom core animation layer,
it's not sharp, it's fuzzy.

00:40:33.360 --> 00:40:36.360
You need to set the content scale
on layers that you manage yourself.

00:40:36.360 --> 00:40:39.270
If AppKit is hosting that layer,
you don't need to worry about it.

00:40:39.280 --> 00:40:40.480
We'll handle all the details for you.

00:40:40.480 --> 00:40:43.380
But if you've got your own CA layer,
you need to handle the

00:40:43.380 --> 00:40:44.720
content scale on that.

00:40:44.760 --> 00:40:49.760
There's also a delegate method
you can handle this easily for

00:40:49.860 --> 00:40:52.550
custom contents in the layer.

00:40:53.820 --> 00:40:59.130
OpenGL content, by default,
for compatibility reasons,

00:40:59.320 --> 00:41:01.840
is not opted into 2x drawing.

00:41:01.840 --> 00:41:02.860
So you need to do that.

00:41:02.860 --> 00:41:05.170
You need to opt into
sharp OpenGL drawing.

00:41:05.180 --> 00:41:09.030
So now I'm going to do another
quick demo on some image drawing

00:41:09.030 --> 00:41:13.250
issues that you may run into and
some solutions that you can use.

00:41:17.890 --> 00:41:19.510
Let's open my project up.

00:41:19.510 --> 00:41:24.070
This is another incredibly sexy
application that draws three images.

00:41:24.070 --> 00:41:27.050
Helpfully,
my designer has chosen to embed the

00:41:27.050 --> 00:41:31.380
scale factor right into the image
so we can all tell what they are.

00:41:31.380 --> 00:41:33.820
And we're drawing this
in three different ways.

00:41:33.820 --> 00:41:37.130
This is the one on the left, obviously,
is a regular NS image view.

00:41:37.130 --> 00:41:39.400
The one in the middle
is an off-screen bitmap.

00:41:39.400 --> 00:41:42.980
And then the one on the right is
a custom layer that I'm inserting.

00:41:42.980 --> 00:41:47.780
So right now, we can see that all
these images are at 1x.

00:41:47.800 --> 00:41:49.220
Thanks.

00:41:49.720 --> 00:41:52.840
So the first thing I need to do,
like we did before,

00:41:52.880 --> 00:41:56.860
is grab my 2x image and just drag it in.

00:41:59.060 --> 00:42:11.660
and Rebuild.

00:42:12.910 --> 00:42:12.910
Now they're all drawn at 2x.

00:42:12.910 --> 00:42:12.910
Well, I'm done, right?

00:42:12.910 --> 00:42:12.910
Well, one thing that's somewhat hard to
demonstrate here is what happens

00:42:12.910 --> 00:42:12.910
if you've got one display at
1x and another display at 2x.

00:42:13.190 --> 00:42:19.540
What we're not seeing here is that
if this display was running at 1x

00:42:19.680 --> 00:42:24.120
and I had a 2x display attached,
the off-screen bitmap and the

00:42:24.120 --> 00:42:27.120
custom layer images would actually
always be drawing the 2x image.

00:42:27.270 --> 00:42:28.370
They'd just be scaling it down.

00:42:28.500 --> 00:42:30.100
And that's not any better.

00:42:30.100 --> 00:42:32.350
So we're actually still not done here.

00:42:32.360 --> 00:42:34.720
So let's look at how we're drawing
the off-screen bitmap image.

00:42:37.700 --> 00:42:41.150
I can see there's a cache image method
that he calls lock focus and then calls

00:42:41.240 --> 00:42:43.930
composite to point with another image.

00:42:44.280 --> 00:42:48.380
And then we're drawing that image
with composite to point again.

00:42:48.510 --> 00:42:51.240
So how can we make this better?

00:42:51.280 --> 00:42:56.600
Using my demo file that we all have.

00:42:56.680 --> 00:43:00.110
So I'm going to copy this and
I'll explain it once it's at

00:43:00.110 --> 00:43:02.010
its much larger font size.

00:43:02.240 --> 00:43:05.280
So here is a much larger method.

00:43:06.400 --> 00:43:12.100
[Transcript missing]

00:43:13.840 --> 00:43:16.540
at the pixel size,
so that's scaled up by the scale

00:43:16.550 --> 00:43:17.890
factor that we're drawing into.

00:43:19.900 --> 00:43:35.600
[Transcript missing]

00:43:36.210 --> 00:43:37.670
and Dan Schimpf.

00:43:37.800 --> 00:43:43.040
We're going to get a unit size,
use convert size to backing to see what

00:43:43.040 --> 00:43:49.620
in pixels how big that unit size becomes,
compare it against my cached image scale,

00:43:49.620 --> 00:43:53.320
then I can know if I need
to recache that image.

00:43:53.320 --> 00:43:58.510
Then we're going to draw that
cached image in the normal spot.

00:43:58.570 --> 00:44:01.210
You may think, well,
that's all fine and dandy.

00:44:01.210 --> 00:44:03.300
That's a lot more code
than I used to have,

00:44:03.370 --> 00:44:03.920
though.

00:44:03.920 --> 00:44:05.540
Is there anything better?

00:44:06.250 --> 00:44:08.450
And it turns out there is.

00:44:12.600 --> 00:44:28.560
. I can take all of this code, copy it,
and replace it with

00:44:28.560 --> 00:44:28.560
something much smaller.

00:44:28.560 --> 00:44:28.560
There's a new method on
NSImage and Mountain Lion for

00:44:28.560 --> 00:44:28.560
drawing NSImages using a block.

00:44:29.230 --> 00:44:33.130
So in my cache image method,
what we can do is create a new image with

00:44:33.130 --> 00:44:37.080
the logical size that we're drawing into,
the point size,

00:44:37.080 --> 00:44:38.790
and then using this block,

00:44:39.220 --> 00:44:43.030
AppKit will invoke this block when
it needs to redraw that image.

00:44:43.190 --> 00:44:46.570
So it will cache the bitmap,
cache the drawn contents.

00:44:46.570 --> 00:44:50.490
But any time we need to redraw it
because of scale factor changes,

00:44:50.550 --> 00:44:52.600
we'll use this block again.

00:44:52.900 --> 00:45:09.700
[Transcript missing]

00:45:10.300 --> 00:45:27.800
[Transcript missing]

00:45:28.200 --> 00:45:30.720
So what's the problem there?

00:45:30.930 --> 00:45:35.460
CA layers can have primarily
have CG images as their contents.

00:45:35.460 --> 00:45:36.440
And so what's the problem here?

00:45:36.440 --> 00:45:39.310
Well, if you've got a 1X
monitor and a 2X monitor,

00:45:39.310 --> 00:45:42.420
how is it going to know which
image to pick for this case?

00:45:42.530 --> 00:45:44.740
Because I'm not really passing
any context information in.

00:45:44.740 --> 00:45:45.960
So what's it going to do?

00:45:45.960 --> 00:45:50.190
It's going to pick the
densest screen and use that.

00:45:50.240 --> 00:45:53.140
So this is always going to pick
the 2X image and get me the

00:45:53.140 --> 00:45:54.900
CG image for that from the image.

00:45:55.900 --> 00:45:59.840
Well, since 10.6,
you can actually set the NS image

00:45:59.840 --> 00:46:01.740
as the contents of a CA layer.

00:46:01.820 --> 00:46:03.820
So that can be your first step.

00:46:03.840 --> 00:46:06.230
And then that could be it right there.

00:46:06.320 --> 00:46:10.320
Because AppKit will automatically
switch back and forth.

00:46:10.480 --> 00:46:13.820
If you've got an NS image in a layer,
it'll know to switch out the

00:46:13.990 --> 00:46:17.400
actual pixels based on what
scale factor it needs to draw.

00:46:18.190 --> 00:46:24.410
So you could stop right there.

00:46:24.410 --> 00:46:24.410
If you've got something more
complex than just a simple image,

00:46:24.410 --> 00:46:24.410
it's going to know to switch out
the actual pixels based on what

00:46:24.410 --> 00:46:24.410
scale factor it needs to draw.

00:46:24.620 --> 00:46:26.780
There's a couple other things you can do.

00:46:26.780 --> 00:46:28.260
You can use the delegate method.

00:46:28.260 --> 00:46:32.880
So, let's say,
let's replace this with -- I'm

00:46:32.880 --> 00:46:34.290
going to make myself the delegate.

00:46:35.590 --> 00:46:37.280
and Dan Schimpf, and then copy this.

00:46:37.280 --> 00:46:39.580
And again,
this is going to be more complicated than

00:46:39.710 --> 00:46:43.110
you need to just for a simple image case,
but if you've got more complicated

00:46:43.120 --> 00:46:45.980
drawing that you want to do over
that image or something else,

00:46:45.980 --> 00:46:47.530
this is a good way to do it.

00:46:47.800 --> 00:46:50.660
So then I have this delegate method,
should inherit content scale.

00:46:50.660 --> 00:46:53.460
I say, yes,
we do want to inherit that content scale.

00:46:53.460 --> 00:46:56.280
And that's going to then
immediately go back and try to

00:46:56.280 --> 00:46:59.300
redraw the contents of that image,
which is going to then

00:46:59.300 --> 00:47:02.140
call this other method,
the other delegate method,

00:47:02.140 --> 00:47:03.780
draw layer in the context.

00:47:03.880 --> 00:47:05.810
I'm going to make an
NSGraphics context out of that.

00:47:05.920 --> 00:47:07.750
And again,
if you've got something more complicated,

00:47:07.750 --> 00:47:08.960
you can replace this section.

00:47:08.960 --> 00:47:12.720
But this is just whatever you're
drawing into your layer can be here.

00:47:12.720 --> 00:47:15.550
But you'll get automatically
redrawn when that layer needs to

00:47:15.550 --> 00:47:17.130
be drawn at a new scale factor.

00:47:23.520 --> 00:47:28.000
Okay, so those are some simple problems
you may have drawing images.

00:47:28.000 --> 00:47:31.880
So for more information on all of this...

00:47:32.070 --> 00:47:38.960
and we highly encourage you to
check out the documentation.

00:47:38.960 --> 00:47:43.000
These are all new guides
on High Resolution.

00:47:43.070 --> 00:47:44.400
Highly recommend you check these out.

00:47:44.400 --> 00:47:45.730
It's a great read.

00:47:45.730 --> 00:47:47.760
Really keep you up at night.

00:47:47.770 --> 00:47:53.420
The Apple developer forums are
there for any help that you may need

00:47:53.580 --> 00:47:56.570
from your fellow developers and us.

00:47:56.570 --> 00:47:56.570
Okay.

00:47:56.570 --> 00:47:56.570
So a summary of what we covered today.

00:47:57.020 --> 00:48:03.070
There are new High Resolution display
modes for your hardware that corresponds

00:48:03.130 --> 00:48:05.980
to four pixels on screen for every point.

00:48:07.060 --> 00:48:10.980
So what you need to do to adapt this,
you need to add 2x bitmaps to

00:48:10.980 --> 00:48:14.650
your apps for all of your 1x art,
and you need to look at your

00:48:14.710 --> 00:48:17.870
icons and up-res them as well.

00:48:18.110 --> 00:48:21.060
You need to look at your code and
see what you can clean up for 2x.

00:48:21.190 --> 00:48:24.920
It may not be a lot,
and your users will definitely thank you.

00:48:26.640 --> 00:48:29.510
and you need to make sure that
you're handling display changes.

00:48:29.620 --> 00:48:32.480
So not just, I launch at 2x and I'm
always going to be at 2x,

00:48:32.560 --> 00:48:36.510
but I need to handle going from
1x to 2x and then back again.

00:48:36.710 --> 00:48:37.600
and Dan Schimpf.

00:48:37.600 --> 00:48:38.590
And then please read the documentation.

00:48:38.590 --> 00:48:42.600
We worked on it very hard and it's great.

00:48:42.640 --> 00:48:43.340
Thank you very much for coming.

00:48:43.540 --> 00:48:45.430
Have a great week.
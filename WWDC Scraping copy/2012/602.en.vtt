WEBVTT

00:00:10.200 --> 00:00:11.340
Hi, everyone.

00:00:11.350 --> 00:00:14.540
Welcome to session 602,
Delivering Web Content on

00:00:14.540 --> 00:00:16.070
High Resolution Displays.

00:00:16.370 --> 00:00:18.950
I'm Beth Dakin,
and I'm an engineer on the

00:00:18.950 --> 00:00:20.680
Safari and WebKit team.

00:00:22.160 --> 00:00:25.130
Remember when monitors
use to look like this?

00:00:25.280 --> 00:00:26.820
It really wasn't so long ago.

00:00:27.120 --> 00:00:29.520
Everything was grainy,
and you could literally count

00:00:29.520 --> 00:00:33.140
pixels without squinting
or leaning into the screen.

00:00:33.190 --> 00:00:34.630
Oh, those were the days.

00:00:34.880 --> 00:00:35.660
Okay, not really.

00:00:35.730 --> 00:00:36.770
These are the days.

00:00:36.930 --> 00:00:39.820
Screen resolutions got better
and better with incremental

00:00:39.860 --> 00:00:43.430
improvements to cinema displays,
better and better resolutions to our

00:00:43.720 --> 00:00:45.850
notebook displays over the years.

00:00:46.040 --> 00:00:50.340
But we've really reached the pinnacle of
this technology with the retina displays.

00:00:50.580 --> 00:00:54.060
If you've watched any of the videos
on Apple.com about how these are made,

00:00:54.200 --> 00:00:57.460
then you know that they're designed
to have pixels so small and so close

00:00:57.530 --> 00:01:02.510
together that the human eye is not
capable of distinguishing these pixels.

00:01:02.670 --> 00:01:05.590
The result is a display
that's a huge improvement over

00:01:05.590 --> 00:01:08.830
displays made only a year ago,
and it's just light

00:01:08.830 --> 00:01:10.860
years away from that CRT.

00:01:13.380 --> 00:01:16.220
Text is so crisp,
it's like you're reading

00:01:16.220 --> 00:01:17.840
a book on real paper.

00:01:17.910 --> 00:01:20.600
Apps and games come alive.

00:01:20.730 --> 00:01:24.400
And browsing the web is
a cinematic experience.

00:01:24.590 --> 00:01:26.350
Well, most of the time.

00:01:26.500 --> 00:01:29.560
But often you'll find yourself
on a web page like this one,

00:01:29.560 --> 00:01:34.170
where that photorealistic
illusion is broken by this fuzzy

00:01:34.240 --> 00:01:39.440
low-resolution image taking up
such a prominent space on the page.

00:01:39.440 --> 00:01:43.830
This is a moment that really disrupts
an otherwise amazing experience.

00:01:44.020 --> 00:01:47.440
Today, I'm going to teach you how to fix
this and make your web content

00:01:47.520 --> 00:01:49.900
look perfect on retina displays.

00:01:50.670 --> 00:01:54.750
Safari on the Mac and on iOS and many,
many other apps on those

00:01:54.750 --> 00:01:57.440
platforms are powered by WebKit.

00:01:57.440 --> 00:02:00.390
Most of you are probably at least
a little familiar with WebKit,

00:02:00.390 --> 00:02:03.060
but in case you're not,
it's the web rendering engine that

00:02:03.060 --> 00:02:04.590
powers Safari on all platforms.

00:02:04.880 --> 00:02:10.040
It's open source,
and it's responsible for loading,

00:02:10.260 --> 00:02:14.980
parsing, interpreting, rendering,
and managing web content

00:02:14.980 --> 00:02:14.980
in Safari and in many,
many other apps.

00:02:15.790 --> 00:02:19.290
WebKit actually does a great
job on these retina displays.

00:02:19.290 --> 00:02:23.830
Everything that WebKit draws from
scratch looks razor sharp out of the box.

00:02:23.850 --> 00:02:27.850
So things like text, form controls,
other things like borders.

00:02:27.850 --> 00:02:31.090
Anything that WebKit draws
itself just looks amazing.

00:02:31.350 --> 00:02:33.560
Other things like SVG graphics.

00:02:33.560 --> 00:02:36.720
But there are certain elements
that are kind of like little

00:02:36.720 --> 00:02:38.370
black boxes to a web browser.

00:02:38.380 --> 00:02:40.380
It doesn't draw them from scratch.

00:02:40.380 --> 00:02:42.580
It displays them as they are provided.

00:02:42.580 --> 00:02:44.660
And the images are just like that.

00:02:45.300 --> 00:02:48.730
WebKit can only do as good a job
as the original source material.

00:02:48.930 --> 00:02:51.620
So in other words,
WebKit can't make a low-resolution

00:02:51.620 --> 00:02:54.990
image look like a high-resolution image.

00:02:55.330 --> 00:02:58.060
Today we'll cover four main topics.

00:02:58.290 --> 00:03:05.440
First, I want to give you the foundation
to understand what's going on

00:03:05.870 --> 00:03:08.350
at the software level on these
retina displays so that you can

00:03:08.350 --> 00:03:08.350
understand the problem with images.

00:03:08.690 --> 00:03:12.190
Then I'll teach you how to
banish those blurry images.

00:03:12.350 --> 00:03:14.150
Next, we'll discuss the Canvas element.

00:03:14.440 --> 00:03:18.230
Canvas is a great way to add
dynamic graphics to your websites,

00:03:18.230 --> 00:03:19.740
apps, and digital books.

00:03:19.940 --> 00:03:22.670
Underneath the hood,
it's just implemented with a

00:03:22.670 --> 00:03:26.060
backing store that's a bitmap,
like an image.

00:03:26.070 --> 00:03:28.720
So you do have to take care
to make sure you're creating a

00:03:28.720 --> 00:03:33.040
high-resolution backing store when
you're targeting a retina display.

00:03:34.140 --> 00:03:36.820
Finally,
I hope that this talk inspires all of

00:03:36.820 --> 00:03:41.250
you to go out and generate and integrate
new versions of all of the artwork

00:03:41.250 --> 00:03:43.320
that you use in your web content.

00:03:43.630 --> 00:03:46.970
But if that seems like a
whole lot of work because you

00:03:47.030 --> 00:03:51.190
have a whole lot of images,
then I'm going to remind you about

00:03:51.250 --> 00:03:56.150
some great technologies that you can
often use in place of images and make

00:03:56.250 --> 00:03:59.210
WebKit do all of that heavy lifting
for you and make things automatically

00:03:59.210 --> 00:03:59.210
look perfect on retina displays.

00:04:00.110 --> 00:04:06.520
Okay, so let's begin with that foundation
of what's happening on these retina

00:04:06.520 --> 00:04:06.520
displays at the software level.

00:04:06.650 --> 00:04:08.040
I want to cover two topics here.

00:04:08.040 --> 00:04:11.150
I want to tell you about
the software scale factor,

00:04:11.250 --> 00:04:15.040
and I want to tell you why
images require special attention.

00:04:15.620 --> 00:04:18.320
So for many years,
as screen resolutions improved just

00:04:18.320 --> 00:04:21.980
through these incremental improvements,
it was a common thing that you

00:04:21.980 --> 00:04:25.280
would notice that UI would get
a little bit smaller each time.

00:04:25.280 --> 00:04:28.180
And it makes sense if you had
a UI element that took up,

00:04:28.280 --> 00:04:31.650
say, 100 pixels,
then as those pixels on the device

00:04:31.650 --> 00:04:35.510
got smaller and closer together,
the amount of space that 100

00:04:35.560 --> 00:04:37.760
pixels took up would be smaller.

00:04:37.760 --> 00:04:40.620
But on a retina display,
the pixels are way smaller

00:04:40.620 --> 00:04:42.230
and way closer together.

00:04:42.240 --> 00:04:45.470
This is a way more significant
improvement than we've ever seen before.

00:04:45.620 --> 00:04:48.740
For every pixel that
you have on an iPad 2,

00:04:48.840 --> 00:04:52.160
there are four in the same
place on the new iPad.

00:04:52.160 --> 00:04:56.930
So if we continued to let those
100-pixel UI elements continue to take

00:04:56.930 --> 00:05:02.200
up just 100 of these physical pixels,
things would be impossibly small.

00:05:02.200 --> 00:05:05.940
But as you know,
things are not impossibly small.

00:05:05.940 --> 00:05:10.350
And that's because at the most basic
level graphics context on the system,

00:05:10.350 --> 00:05:14.680
there's a scale factor of two in
place on all current retina displays.

00:05:14.680 --> 00:05:18.950
So the whole user interface is
being scaled up by a factor of two.

00:05:18.950 --> 00:05:21.860
On Mac OS X,
this is a per-window concept.

00:05:21.860 --> 00:05:24.860
So if you have a retina
MacBook Pro hooked up to an external

00:05:24.860 --> 00:05:28.170
display that's just a normal display,
then the display on your

00:05:28.170 --> 00:05:31.190
retina MacBook Pro will have
that scale factor built in,

00:05:31.190 --> 00:05:34.840
and the external display will just
have a normal scale factor of one,

00:05:34.840 --> 00:05:36.980
kind of like not scaling at all.

00:05:36.980 --> 00:05:39.330
And as you drag windows
between the two displays,

00:05:39.330 --> 00:05:43.160
they'll update automatically to either
have that scale factor or not have it.

00:05:43.860 --> 00:05:47.160
So a whole UI scaled
up by a factor of two.

00:05:47.390 --> 00:05:49.320
And that's great for native apps.

00:05:49.360 --> 00:05:52.940
But what about your web apps
where you've meticulously laid

00:05:52.990 --> 00:05:55.140
things out according to pixels?

00:05:55.390 --> 00:05:57.770
Well, it turns out they're
going to be just fine.

00:05:57.990 --> 00:06:02.000
CSS was designed with a future
in mind where pixels vary

00:06:02.000 --> 00:06:03.770
across different devices.

00:06:03.910 --> 00:06:07.660
So when you talk about one pixel
or one PX in your style sheets,

00:06:07.770 --> 00:06:11.340
you're not talking about one piece
of phosphorus soldered to silicon.

00:06:11.580 --> 00:06:15.970
You're talking about a relative
unit of measurement in the web page.

00:06:16.170 --> 00:06:19.810
Now, that may be surprising because
historically on the Mac,

00:06:19.810 --> 00:06:23.380
we did happen to map one CSS pixel
to one pixel on the device.

00:06:23.380 --> 00:06:25.820
So it would be easy to conflate the two.

00:06:25.820 --> 00:06:28.500
But even then,
that was only some of the time.

00:06:28.500 --> 00:06:31.450
The equivalency obviously
doesn't continue to hold

00:06:31.450 --> 00:06:33.050
once you start zooming in.

00:06:33.050 --> 00:06:35.830
So when you pinch to zoom or
double tap on a Mac with a

00:06:35.830 --> 00:06:38.980
trackpad or an iOS device,
the web page appears to get bigger

00:06:39.350 --> 00:06:42.680
because underneath the hood,
there's a scale factor applied

00:06:42.680 --> 00:06:44.560
to all of those CSS units.

00:06:45.400 --> 00:06:48.870
So really, you're already used to this
world where CSS pixels are

00:06:48.870 --> 00:06:50.520
relative units in the web page.

00:06:50.550 --> 00:06:53.890
And you've seen for yourself that this
doesn't break layouts or anything,

00:06:53.890 --> 00:06:54.890
that it all works.

00:06:55.960 --> 00:07:01.070
So not only that, but on iOS, by default,
we actually scale all web pages

00:07:01.070 --> 00:07:03.300
down to fit in the viewport.

00:07:03.300 --> 00:07:05.660
So let me explain viewport
just for a minute.

00:07:05.660 --> 00:07:09.440
I think this is a pretty good example
to illustrate what's happening.

00:07:09.440 --> 00:07:12.980
I have this div here with
a width of 320 pixels.

00:07:14.510 --> 00:07:16.190
So if you're familiar with
the iPhone screen size,

00:07:16.250 --> 00:07:19.200
you may know that it's 320 by 480.

00:07:19.280 --> 00:07:22.720
So you may expect this div
to fill the screen in mobile

00:07:22.720 --> 00:07:27.690
Safari horizontally when I load
this snippet of HTML in the browser.

00:07:28.880 --> 00:07:31.650
But as you can see,
it does not fill the screen horizontally.

00:07:31.650 --> 00:07:33.600
It takes up only about
a third of the width.

00:07:33.770 --> 00:07:36.470
And the reason for that is viewport.

00:07:37.160 --> 00:07:41.330
Most websites were designed with big,
resizable browser windows in mind.

00:07:41.390 --> 00:07:45.380
And so Mobile Safari assumes
a width of 980 pixels and then

00:07:45.380 --> 00:07:49.640
scales that down to fit within the
actual screen size of the device,

00:07:49.640 --> 00:07:51.180
320 pixels.

00:07:51.180 --> 00:07:54.220
And you end up with this
crazy fractional scale factor.

00:07:54.220 --> 00:07:57.540
And again, this is all viewport scaling.

00:07:57.650 --> 00:08:02.050
So if you had retina scaling in place,
that'd be a separate thing.

00:08:02.050 --> 00:08:02.050
It's a crazy number.

00:08:02.050 --> 00:08:02.050
Don't need to worry about it.

00:08:02.600 --> 00:09:08.400
[Transcript missing]

00:09:08.800 --> 00:09:11.160
Okay,
so that's the software scale factor,

00:09:11.180 --> 00:09:15.210
and you'll hear me and many other people
refer to this by many other names,

00:09:15.210 --> 00:09:18.790
and I apologize if that's confusing,
but display scale factor,

00:09:18.790 --> 00:09:20.320
device scale factor.

00:09:20.320 --> 00:09:24.120
If you're over in AppKit land,
you might hear backing scale factor.

00:09:24.120 --> 00:09:26.300
You'll hear me say device pixel ratio.

00:09:26.300 --> 00:09:28.930
All of these things
refer to the same thing.

00:09:28.930 --> 00:09:32.120
It's referring to that number
two on a retina display where

00:09:32.200 --> 00:09:35.480
the whole UI is scaled up by two,
and on a standard display,

00:09:35.480 --> 00:09:38.700
it would just be one,
whatever that scale factor is.

00:09:40.140 --> 00:09:42.800
Okay, so now I want to talk about images,
but to do that,

00:09:42.800 --> 00:09:46.400
I actually want to step back first
and talk about why other elements

00:09:46.400 --> 00:09:48.340
look great on retina displays.

00:09:48.340 --> 00:09:52.920
So consider this simple div,
10-pixel by 10-pixel div,

00:09:53.000 --> 00:09:56.710
on a standard display,
so a normal MacBook Pro like the

00:09:56.710 --> 00:09:57.920
one you have in front of you.

00:09:57.920 --> 00:10:02.090
And this is that sort of idyllic
old-school environment where one

00:10:02.090 --> 00:10:06.870
CSS pixel did happen to correspond
directly to one pixel on the device.

00:10:07.220 --> 00:10:11.290
If I were to draw a grid over this
div representing the CSS pixels,

00:10:11.320 --> 00:10:15.260
it would look like this: 10 by 10 pixels,
10 in each direction.

00:10:15.500 --> 00:10:18.700
And again, because this is that
old-school environment,

00:10:18.700 --> 00:10:21.450
if I were to draw a grid
representing the device pixels,

00:10:21.450 --> 00:10:23.070
it would be identical.

00:10:23.140 --> 00:10:27.670
But now let's consider the same
div on a retina MacBook Pro.

00:10:27.720 --> 00:10:30.580
The CSS pixels would look the same.

00:10:30.580 --> 00:10:34.200
Again, they're relative units,
so these things don't change between

00:10:34.230 --> 00:10:36.000
the non-retina and retina case.

00:10:36.050 --> 00:10:39.100
But the device pixels have
doubled underneath that.

00:10:39.240 --> 00:10:42.240
And this is what makes everything
that WebKit draws look so sharp.

00:10:42.330 --> 00:10:46.530
We can take advantage of those extra
pixels and make the curves on text,

00:10:46.530 --> 00:10:50.940
like in the letter S or the letter B,
look as smooth as silk.

00:10:51.900 --> 00:10:53.980
Now let's talk about images.

00:10:54.140 --> 00:10:58.440
So really we're talking about
raster images or bitmap images here,

00:10:58.510 --> 00:11:00.800
things like pings, tiffs, JPEGs.

00:11:01.070 --> 00:11:04.300
We're not talking about vector images,
which are different.

00:11:04.350 --> 00:11:08.500
But all raster images
have an intrinsic size.

00:11:08.900 --> 00:11:12.440
And this image has 400
by 250 pixels in it.

00:11:12.440 --> 00:11:13.990
It's a certain number of pixels.

00:11:13.990 --> 00:11:16.880
So, quick side note here.

00:11:16.880 --> 00:11:21.780
Photoshop encourages this idea
that you can somehow control the

00:11:21.780 --> 00:11:26.400
resolution independence of an
image file if you set its DPI,

00:11:26.400 --> 00:11:29.300
the dots per inch, in other words.

00:11:30.410 --> 00:11:34.200
This is not really a good thing
to think about in terms of images,

00:11:34.200 --> 00:11:35.910
and it doesn't really make sense.

00:11:36.000 --> 00:11:39.020
This adds some metadata to the file,
but it doesn't actually add

00:11:39.020 --> 00:11:40.600
any additional pixel data.

00:11:40.600 --> 00:11:42.710
So,

00:11:42.880 --> 00:11:45.750
It just doesn't make sense to think
of DPI in terms of images because

00:11:45.760 --> 00:11:49.060
how tightly packed those pixels
will be depends entirely on the

00:11:49.060 --> 00:11:53.420
display that's viewing the image and
it depends entirely on the container

00:11:53.420 --> 00:11:54.960
you choose to put the image inside.

00:11:54.960 --> 00:11:57.530
This bit of metadata
can't really control that.

00:11:57.730 --> 00:12:00.700
So it's best not to consider
that when you're thinking about

00:12:00.700 --> 00:12:02.200
creating high-resolution images.

00:12:02.200 --> 00:12:04.490
Just think about the number
of pixels in the image,

00:12:04.500 --> 00:12:05.320
the width and the height.

00:12:05.360 --> 00:12:06.780
So that's what we'll do here.

00:12:06.780 --> 00:12:12.280
This image has 400 by 250 pixels
in it and it will look best if

00:12:12.280 --> 00:12:17.260
it's displayed using the exact same
number of pixels on the display.

00:12:17.260 --> 00:12:19.480
This is something we're going
to keep coming back to so

00:12:19.580 --> 00:12:20.890
I really want to emphasize it.

00:12:21.150 --> 00:12:23.950
This image will look best if
it's displayed using the same

00:12:23.950 --> 00:12:27.880
number of device pixels as the
actual image file has available.

00:12:27.880 --> 00:12:32.240
So if I were to add this
image to my website,

00:12:32.240 --> 00:12:36.170
I would probably write some
HTML that looks like this.

00:12:36.330 --> 00:12:40.870
And here's what that would look like
on a standard non-retina display.

00:12:40.970 --> 00:12:43.510
And here I've set up a viewport
so there's no additional

00:12:43.780 --> 00:12:45.330
viewport scaling happening here.

00:12:45.620 --> 00:12:48.750
So I have a one-to-one
correspondence between all of my

00:12:48.750 --> 00:12:50.790
CSS pixels and my device pixels.

00:12:51.060 --> 00:12:54.620
Each of my image pixels gets to
render into exactly one device pixel.

00:12:54.630 --> 00:12:58.690
We're seeing the image in full
fidelity and its full glory.

00:12:59.450 --> 00:13:04.240
So just to recap that,
we have a certain CSS size,

00:13:04.240 --> 00:13:09.100
and our display is providing the
exact same number of actual physical

00:13:09.410 --> 00:13:11.880
device pixels within that CSS size.

00:13:11.910 --> 00:13:18.270
And that happens to be the
exact number of pixels we have

00:13:18.270 --> 00:13:18.270
available in our image as well.

00:13:20.410 --> 00:13:24.900
Now let's consider this same
HTML snippet on a retina display.

00:13:25.070 --> 00:13:27.720
Here the image looks blurry.

00:13:28.150 --> 00:13:31.860
And the reason for that is that we
have the same CSS size as before,

00:13:32.140 --> 00:13:38.360
but the number of device pixels
underneath that have actually quadrupled.

00:13:38.370 --> 00:13:43.680
And we still have only 400 by
250 image pixels to work with.

00:13:43.730 --> 00:13:47.990
So the underlying graphics library is
forced to try to scale this image up.

00:13:48.240 --> 00:13:52.180
It's filling in the details that
it doesn't know somewhat randomly.

00:13:52.190 --> 00:13:54.880
Unknown details are colored in,
and the result is an

00:13:54.880 --> 00:13:57.240
image that looks fuzzy.

00:13:59.070 --> 00:14:01.680
So now I want to teach you
how to fix this problem.

00:14:01.680 --> 00:14:03.300
So that takes us right
into the next section.

00:14:05.160 --> 00:14:09.440
The basic idea here is that you want
to take all of your existing images,

00:14:09.520 --> 00:14:15.400
and you want to generate new
versions that are twice the size,

00:14:15.400 --> 00:14:15.400
twice the number of pixels.

00:14:15.750 --> 00:14:19.950
And then you want to declare
what you have available.

00:14:19.950 --> 00:14:26.210
And then depending on the
technique that you choose to use,

00:14:26.400 --> 00:14:32.460
either WebKit will choose the best image
for the display or you'll explicitly

00:14:32.460 --> 00:14:32.460
tell WebKit which image to use.

00:14:32.460 --> 00:14:32.460
And you'll end up with something
that looks great on a retina display.

00:14:33.210 --> 00:14:36.230
We'll discuss three
techniques for achieving this.

00:14:36.380 --> 00:14:42.950
First, I'll tell you about CSS sizing and
then querying for device scale.

00:14:43.420 --> 00:14:45.500
And finally,
I'll tell you about a new option

00:14:45.500 --> 00:14:47.060
we have in WebKit called Image Set.

00:14:47.160 --> 00:14:50.140
We'll get to that in just a few minutes.

00:14:50.200 --> 00:14:52.900
For each of these techniques,
we'll grade them in three categories.

00:14:53.020 --> 00:14:54.880
We'll see how they are with performance.

00:14:54.890 --> 00:14:57.930
By performance,
I mean memory performance,

00:14:57.950 --> 00:15:01.300
also speed performance,
and even graphical performance,

00:15:01.310 --> 00:15:02.600
how things look.

00:15:02.620 --> 00:15:05.490
We'll discuss how simple it
is to integrate this technique

00:15:05.490 --> 00:15:06.980
into existing web content.

00:15:07.100 --> 00:15:09.180
And finally,
we'll discuss if the technique

00:15:09.260 --> 00:15:11.940
works across different browsers.

00:15:12.920 --> 00:15:16.400
Okay, so let's begin with CSS sizing.

00:15:16.450 --> 00:15:18.320
To do that,
I want to jump right back into that

00:15:18.480 --> 00:15:21.020
example we were just considering,
where we have an image

00:15:21.020 --> 00:15:25.350
that's 400 by 250 pixels,
but we have four times the

00:15:25.380 --> 00:15:28.300
number of device pixels to fill.

00:15:28.960 --> 00:15:32.850
So the way to integrate the
CSS sizing technique here is really

00:15:33.140 --> 00:15:38.290
just to leave everything the same,
but change the URL of the SRC attribute

00:15:38.450 --> 00:15:41.660
to point to a high-resolution
version of the image that actually

00:15:41.660 --> 00:15:44.390
has 800 by 500 pixels in it.

00:15:44.480 --> 00:15:48.380
So the key to this is that I have not
changed the width and height attributes,

00:15:48.620 --> 00:15:51.540
because I still want this image to
take up the same amount of space

00:15:51.730 --> 00:15:54.100
relative to other elements on the page.

00:15:54.100 --> 00:15:57.150
But I've provided an image
resource with enough data to

00:15:57.180 --> 00:15:58.880
fill all the device pixels.

00:15:58.960 --> 00:16:02.560
that are actually available
within that space.

00:16:03.600 --> 00:16:06.800
So there are a number of other ways
to integrate images into web content

00:16:06.800 --> 00:16:10.820
besides just using the IMG element,
and CSS sizing is something you can

00:16:10.820 --> 00:16:12.710
do for any of those different ways.

00:16:12.720 --> 00:16:17.640
Most similar to the IMG element is
just using the CSS content property.

00:16:17.640 --> 00:16:21.900
So here you can provide content that's
an image using the URL function,

00:16:21.900 --> 00:16:24.820
and then I'm just going to use
the width and height properties

00:16:24.820 --> 00:16:28.110
to set the size of that image,
very similar to the width and height

00:16:28.160 --> 00:16:32.380
attributes on the previous screen,
which were also supplied in CSS Pixels,

00:16:32.380 --> 00:16:33.400
I should note.

00:16:33.520 --> 00:16:36.200
That's the units here.

00:16:36.940 --> 00:16:40.240
And then for background images,
you can size the image using

00:16:40.240 --> 00:16:41.640
the background size property.

00:16:41.640 --> 00:16:47.040
If you have an image that repeats,
then the background size represents

00:16:47.040 --> 00:16:49.850
the size of each tile in the repeat.

00:16:52.320 --> 00:16:54.510
Finally,
you can do this for border image as well.

00:16:54.700 --> 00:16:57.340
It's a little bit trickier with
border image because you have to use

00:16:57.680 --> 00:17:01.440
two properties in conjunction with
one another to get the sizing right.

00:17:01.560 --> 00:17:04.430
On top of that,
they're expressed in different units.

00:17:04.490 --> 00:17:08.030
You use border width,
which is expressed in CSS pixels.

00:17:08.400 --> 00:17:11.730
That makes it very similar to width
and height and background size.

00:17:12.020 --> 00:17:17.140
Anything expressed in CSS pixels is not
going to change whether it's a 1x image

00:17:17.140 --> 00:17:19.160
or a 2x image for a retina display.

00:17:19.160 --> 00:17:21.700
These things will remain the same.

00:17:22.120 --> 00:17:25.510
However, border image slices,
these units are not CSS pixels.

00:17:25.510 --> 00:17:27.830
These are pixels in
the actual image file.

00:17:27.830 --> 00:17:30.280
They're in the image's coordinate space.

00:17:30.280 --> 00:17:33.990
So if the actual image changes in size,
then the values of the

00:17:34.030 --> 00:17:35.820
slices will also change.

00:17:35.820 --> 00:17:39.240
We'll come back to this in a few minutes
when we're talking about media queries.

00:17:41.230 --> 00:17:44.680
Okay, so you should always give
your images a size in CSS.

00:17:44.680 --> 00:17:47.230
And in fact,
you'll need to do that in order to

00:17:47.230 --> 00:17:50.490
be successful with the other two
techniques I'm going to tell you about

00:17:50.520 --> 00:17:52.390
in a minute with querying or image set.

00:17:52.400 --> 00:17:57.570
But the idea of doing only that as a
technique to integrate high-resolution

00:17:57.570 --> 00:18:01.910
images is that you always use that
high-resolution image resource.

00:18:01.920 --> 00:18:06.980
So let's grade this technique of always
using high-resolution images as a way

00:18:07.190 --> 00:18:09.020
to make your web content retina savvy.

00:18:09.020 --> 00:18:10.700
How is it with performance?

00:18:10.700 --> 00:18:13.660
Well, it's pretty bad with performance.

00:18:13.660 --> 00:18:16.100
It's really bad for performance,
actually.

00:18:16.100 --> 00:18:20.240
When you use this technique,
you'll be sending those really large

00:18:20.240 --> 00:18:24.060
image files to all of your users,
even your users without retina displays.

00:18:24.060 --> 00:18:27.280
So this is going to create
really long download times

00:18:27.280 --> 00:18:28.760
for users on older devices.

00:18:28.760 --> 00:18:32.140
Those images are going to take
up a lot more space and memory.

00:18:32.140 --> 00:18:34.450
Retina devices can handle that.

00:18:34.550 --> 00:18:36.580
They're built to handle
large image files,

00:18:36.580 --> 00:18:38.720
so the memory hits not as bad there.

00:18:38.720 --> 00:18:42.980
But a user on an iPhone 3GS having
a big image file loaded into memory,

00:18:42.980 --> 00:18:45.270
or many of them, could be a real burden.

00:18:45.280 --> 00:18:49.710
On top of that, you won't be delivering a
full fidelity image experience

00:18:49.720 --> 00:18:50.950
to all of your users either.

00:18:51.340 --> 00:18:54.420
Your retina users will be getting
that full fidelity experience,

00:18:54.420 --> 00:18:58.300
but everyone on an older display,
they'll be kind of experiencing the

00:18:58.320 --> 00:18:59.980
opposite of the image scaling up.

00:19:00.080 --> 00:19:04.430
The image here will be scaled down to fit
in a much smaller space because the image

00:19:04.560 --> 00:19:08.420
will have way more pixel data than the
device will have available to display.

00:19:08.520 --> 00:19:11.710
So the graphics library will have
to choose which pixels to leave out.

00:19:11.820 --> 00:19:13.400
It's not a full fidelity experience.

00:19:13.490 --> 00:19:17.220
The result is not nearly as bad
as when you scale up an image,

00:19:17.430 --> 00:19:18.980
but it's still not perfect.

00:19:20.640 --> 00:19:26.000
However, this technique is very simple
and it works across all browsers,

00:19:26.120 --> 00:19:29.200
so it does still have some merits.

00:19:31.160 --> 00:19:33.800
Okay,
so you may remember earlier I was telling

00:19:33.800 --> 00:19:38.050
you about the software scale factor
that's in place on all Retina devices,

00:19:38.140 --> 00:19:39.540
scale factor of two.

00:19:39.680 --> 00:19:45.130
So with this technique of
querying for the device scale,

00:19:45.180 --> 00:19:51.140
you use a technique to query for
exactly what that device scale

00:19:51.250 --> 00:19:53.490
factor or software scale factor is,
and then you choose which images

00:19:53.490 --> 00:19:53.490
to load based on the result.

00:19:54.240 --> 00:19:56.060
And the first way to do
this is with media queries,

00:19:56.110 --> 00:19:57.860
which have been around for a while.

00:19:57.860 --> 00:20:03.290
Media queries are a way to provide or
to define CSS rules that will apply

00:20:03.290 --> 00:20:07.400
conditionally based on characteristics
of the device viewing the content.

00:20:07.400 --> 00:20:10.490
So here I've created
two media query blocks,

00:20:10.510 --> 00:20:13.810
one to specify styles that
I want to apply when the

00:20:13.860 --> 00:20:17.840
content is viewed on a screen,
and a separate block to specify

00:20:17.840 --> 00:20:21.720
different styles that I want to
apply when the content is printed.

00:20:22.140 --> 00:20:25.860
This is a long-standing
way to use media queries.

00:20:26.130 --> 00:20:29.440
They've also become popular in
recent years as a way to target

00:20:29.440 --> 00:20:31.540
styles toward iPhone or iPad.

00:20:31.620 --> 00:20:34.640
And the most common way to do that
is to query for the device width,

00:20:34.640 --> 00:20:37.300
which is in CSS pixels, I should note.

00:20:37.300 --> 00:20:41.590
So here I have one block looking
for that device width of 320,

00:20:41.660 --> 00:20:44.140
so it's targeting iPhone,
and then targeting iPad

00:20:44.140 --> 00:20:46.780
with a device width of 768.

00:20:46.800 --> 00:20:51.780
And now you can query for that
device scale factor as well.

00:20:51.920 --> 00:20:54.020
So here I've set up two
different media query blocks.

00:20:54.040 --> 00:20:57.680
My first one is looking for
a device pixel ratio of one.

00:20:58.050 --> 00:21:01.300
This means all standard
non-retina displays.

00:21:01.310 --> 00:21:04.680
This is a display where that
software scale factor is just one.

00:21:04.740 --> 00:21:07.860
And in my second media query,
I'm looking for a minimum

00:21:07.860 --> 00:21:09.570
device pixel ratio of two.

00:21:09.730 --> 00:21:13.170
So this will apply to all current
retina devices and any future

00:21:13.170 --> 00:21:17.610
devices that happen to have an
even higher software scale factor.

00:21:18.560 --> 00:21:21.770
The way that people usually use this,
in the case for targeting

00:21:21.770 --> 00:21:25.290
retina or non-retina displays,
is to put most styles up

00:21:25.380 --> 00:21:27.080
in a common style block.

00:21:27.130 --> 00:21:29.790
Because most things aren't going
to change for the retina or

00:21:29.790 --> 00:21:31.100
non-retina version of your site.

00:21:31.200 --> 00:21:33.710
You really just need to
change those image URLs.

00:21:33.910 --> 00:21:35.680
So I even have my
background size up here,

00:21:35.720 --> 00:21:39.240
because that CSS Pixel,
and it's not going to change.

00:21:39.250 --> 00:21:44.500
And then down in the media queries,
I'm just defining my normal sized image

00:21:44.500 --> 00:21:50.300
and my 2x image for the two different
types of devices that I'm targeting.

00:21:50.360 --> 00:21:53.920
So there are a number of cool
things about media queries.

00:21:53.920 --> 00:21:56.580
First of all,
the CSS engine won't even evaluate

00:21:56.670 --> 00:21:59.950
the query if it doesn't apply to
the device viewing the content.

00:22:00.070 --> 00:22:03.090
So you'll always only download
the image targeted for the device.

00:22:03.200 --> 00:22:06.180
You don't have to worry about
downloading both images.

00:22:06.200 --> 00:22:09.960
You're always going to get the
correct image for that device.

00:22:09.990 --> 00:22:13.040
On top of that,
media queries will update dynamically

00:22:13.070 --> 00:22:15.440
if that device scale factor changes.

00:22:15.440 --> 00:22:18.680
So in other words,
if you have that Retina MacBook Pro in

00:22:18.680 --> 00:22:23.380
a multi-monitor scenario where
one monitor has a 1x scale factor,

00:22:23.380 --> 00:22:25.840
because it's a standard old display,
and the other monitor

00:22:25.840 --> 00:22:28.690
is the built-in display,
which has the 2x scale factor,

00:22:28.830 --> 00:22:31.150
your media queries will
re-evaluate as you drag the

00:22:31.400 --> 00:22:33.340
windows between those two displays.

00:22:33.470 --> 00:22:36.560
So you'll always get the
image that's targeted to the

00:22:36.750 --> 00:22:40.090
display that the content is on.

00:22:40.260 --> 00:22:44.180
A less verbose way to write this
code would be to write it like this.

00:22:44.340 --> 00:22:48.400
Here I'm putting the 1x image
URL up in the common style block,

00:22:48.560 --> 00:22:52.080
and then I'm overriding it with a
media query for retina displays.

00:22:52.090 --> 00:22:55.260
And you still don't have to worry about
both images being downloaded here.

00:22:55.260 --> 00:23:01.760
You'll override that before
any downloading happens.

00:23:01.760 --> 00:23:01.760
So you're still getting the
image targeted for the display.

00:23:01.910 --> 00:23:06.700
Another benefit here is that this will
actually target any displays that have

00:23:06.700 --> 00:23:09.600
a device scale factor between 1 and 2.

00:23:09.600 --> 00:23:14.040
And all current Apple devices have
a device scale factor of 1 or 2.

00:23:14.040 --> 00:23:18.100
But you never know with future devices
or devices from other manufacturers.

00:23:19.480 --> 00:23:22.690
So here I have, again,
the image URL for the 1x image

00:23:22.700 --> 00:23:24.370
in the common style block.

00:23:24.430 --> 00:23:27.780
I have to make sure, though,
that I write that code in that order.

00:23:27.780 --> 00:23:30.890
If I accidentally were to put
the media query block first,

00:23:30.890 --> 00:23:35.220
then I wouldn't end up getting that
retina targeted image on my retina

00:23:35.220 --> 00:23:39.930
display because I would end up overriding
it later with my normal 1x image.

00:23:40.060 --> 00:23:42.670
So this is just something to
be a little bit careful with

00:23:42.670 --> 00:23:44.500
when you're using media queries.

00:23:46.640 --> 00:23:48.100
I mentioned border image earlier.

00:23:48.100 --> 00:23:50.440
I just want to bring it up
again here quickly because of

00:23:50.450 --> 00:23:52.040
the complication with slices.

00:23:52.040 --> 00:23:55.180
So here I again have
a common style block.

00:23:55.240 --> 00:23:56.710
I can put the border width here.

00:23:56.760 --> 00:23:57.760
That won't change.

00:23:57.760 --> 00:24:02.460
But then I will need to redefine two
pieces of information instead of just

00:24:02.460 --> 00:24:05.180
the URL for the image in my media query.

00:24:05.180 --> 00:24:07.690
I need to redefine the
slices as well because,

00:24:07.780 --> 00:24:11.110
again, these are in terms of the
image's coordinate space.

00:24:11.110 --> 00:24:14.620
So if the image changes,
the slice values will change as well.

00:24:14.620 --> 00:24:16.430
Just something to be aware of.

00:24:18.170 --> 00:24:21.350
It's a pretty common technique
on websites with many images

00:24:21.350 --> 00:24:22.890
to load them in JavaScript.

00:24:23.070 --> 00:24:26.970
And if that's something that you do,
then you can still query for what this

00:24:26.970 --> 00:24:31.320
device scale factor is and choose which
images to load based on the result.

00:24:31.320 --> 00:24:34.560
So here I'm evaluating a
CSS media query in JavaScript.

00:24:34.820 --> 00:24:38.040
And then I'm deciding whether
I want the retina version of

00:24:38.040 --> 00:24:39.890
my image or the regular one.

00:24:40.660 --> 00:24:44.940
I could also use the
window.devicePixelRatio property.

00:24:44.940 --> 00:24:49.150
This will directly return whatever
the current software scale factor is.

00:24:49.290 --> 00:24:51.780
So again,
it will return one on all standard

00:24:51.810 --> 00:24:54.420
displays and two on all retina displays.

00:24:56.670 --> 00:25:00.000
One of the cool things that
I mentioned about CSS media queries

00:25:00.000 --> 00:25:03.910
is that they will update dynamically
if the scale factor changes,

00:25:04.000 --> 00:25:06.200
like in a multi-monitor scenario.

00:25:06.320 --> 00:25:09.640
So to hook into that goodness if
you're doing this through JavaScript,

00:25:09.680 --> 00:25:13.190
you have to be careful and make
sure that you add this event

00:25:13.240 --> 00:25:16.600
listener for match media for
this device pixel ratio changing.

00:25:16.600 --> 00:25:19.390
If you do this,
then you can also make sure that

00:25:19.460 --> 00:25:21.870
the images will update dynamically.

00:25:23.370 --> 00:25:27.340
Okay, so let's grade this technique.

00:25:27.360 --> 00:25:29.250
So this is great for performance.

00:25:29.260 --> 00:25:34.380
I mentioned a lot of this as we were
going through how to use media queries,

00:25:34.450 --> 00:25:36.990
but these are great for performance.

00:25:37.110 --> 00:25:40.100
You always only get the image
that's targeted for the device.

00:25:40.140 --> 00:25:45.950
They'll update dynamically
so you can always provide

00:25:46.510 --> 00:25:47.100
a full fidelity experience.

00:25:47.100 --> 00:25:47.100
They work really well.

00:25:47.610 --> 00:25:49.740
However,
this is not a super simple technique,

00:25:49.790 --> 00:25:52.420
also for reasons that I mentioned
as we were going through.

00:25:52.630 --> 00:25:56.710
You have to be careful when you're
using CSS media queries that

00:25:56.710 --> 00:25:57.840
everything's in the right order.

00:25:57.840 --> 00:26:00.040
That can be a little bit error-prone.

00:26:00.080 --> 00:26:02.900
You have to be careful with border image,
that you redefine the slices.

00:26:02.900 --> 00:26:06.420
You have to sort of think about that
and grok that they're in different

00:26:06.490 --> 00:26:08.700
coordinates than CSS pixels.

00:26:08.730 --> 00:26:10.350
And if you're doing
it through JavaScript,

00:26:10.410 --> 00:26:13.260
you have to remember to
implement that event listener.

00:26:13.310 --> 00:26:15.970
There are a lot of
things to keep straight,

00:26:16.030 --> 00:26:17.130
admittedly.

00:26:17.600 --> 00:26:19.540
It is, however, a cross-browser solution.

00:26:19.540 --> 00:26:22.740
I was using the -webkit
prefix on those slides,

00:26:22.740 --> 00:26:26.520
but this media query is also
implemented in Firefox and

00:26:26.520 --> 00:26:30.500
Opera with the -moz and -o prefixes,
respectively.

00:26:30.550 --> 00:26:36.430
Opera has a slightly different syntax
that you'll have to look up online.

00:26:36.500 --> 00:26:40.370
But overall,
this is a perfectly good technique

00:26:40.370 --> 00:26:43.480
to target all of the major
browsers that you could be using

00:26:43.480 --> 00:26:43.480
on your Retina MacBook Pro.

00:26:46.160 --> 00:26:49.740
Okay, so now I would like to
tell you about ImageSet.

00:26:49.910 --> 00:26:53.860
This is a new CSS function that
we came up with here at Apple for

00:26:53.860 --> 00:26:58.340
a more elegant solution to the
high-resolution image problem.

00:26:58.430 --> 00:27:01.060
We've proposed it to
the CSS Working Group,

00:27:01.130 --> 00:27:05.870
and it's currently scheduled to be
a part of the Images Level 4 module.

00:27:06.890 --> 00:27:08.240
So this slide should look familiar.

00:27:08.240 --> 00:27:10.320
This is a media query.

00:27:10.320 --> 00:27:12.760
Here I'm using a media query
to set up a background image.

00:27:12.760 --> 00:27:16.820
And you may recall all of the reasons
why this is great for performance.

00:27:16.820 --> 00:27:19.750
You're always getting the image
that's targeted for the device.

00:27:19.800 --> 00:27:23.340
The image will update dynamically
for a multi-monitor scenario.

00:27:23.340 --> 00:27:26.000
Well,
to get all of that goodness with much

00:27:26.000 --> 00:27:30.310
less code and much less error-proneness,
you can just use the new

00:27:30.310 --> 00:27:32.250
WebKit image set function.

00:27:32.260 --> 00:27:36.940
So everywhere in your style sheets
where you're currently using the

00:27:36.940 --> 00:27:40.810
URL function to point to an image,
you can instead use the WebKit image

00:27:40.810 --> 00:27:44.400
set function to list multiple URLs,
as many as you like.

00:27:44.480 --> 00:27:48.340
And for each URL, you'll provide an
associated scale factor.

00:27:48.340 --> 00:27:52.780
This tips WebKit off to know
what that image is appropriate

00:27:52.880 --> 00:27:54.070
for and how big it is.

00:27:54.080 --> 00:27:57.820
It doesn't have to download the
image to know what its size is.

00:27:57.820 --> 00:28:01.620
It can see from your scale factor
the 2x image must be twice the size.

00:28:03.450 --> 00:28:05.560
In this way,
things will update dynamically.

00:28:05.580 --> 00:28:08.750
You'll only ever download
what's targeted to the device.

00:28:08.750 --> 00:28:11.780
This is new in Safari 6 and
Safari on iOS 6 as well.

00:28:13.520 --> 00:28:16.300
This also greatly
simplifies border image,

00:28:16.300 --> 00:28:20.480
where you had to think about
that slice information before.

00:28:20.500 --> 00:28:23.380
Now, in addition to just taking
up less space with the URLs,

00:28:23.380 --> 00:28:25.640
you also only have to
define the slices once.

00:28:25.720 --> 00:28:28.350
You can just define them
in terms of the 1x image,

00:28:28.350 --> 00:28:30.740
and then WebKit will
extrapolate from there,

00:28:30.740 --> 00:28:33.310
based on the scale factors
that you've provided,

00:28:33.310 --> 00:28:37.780
what the slice values should be for the
higher resolution versions of the image.

00:28:38.850 --> 00:28:44.880
Okay, so let's grade this new image set
function on our little chart here.

00:28:45.030 --> 00:28:46.320
This is great for performance.

00:28:46.320 --> 00:28:50.690
It has all those same performance
characteristics of media queries.

00:28:51.100 --> 00:28:52.350
It's also very simple.

00:28:52.360 --> 00:28:55.680
You're just replacing the URL function
anywhere that you're using it with

00:28:55.680 --> 00:28:59.160
the WebKit image set function,
providing a tiny bit more information.

00:28:59.160 --> 00:29:02.000
Sadly, at this time,
it's not cross-browser.

00:29:02.000 --> 00:29:03.780
It's only implemented in WebKit.

00:29:03.780 --> 00:29:07.000
However, we are taking this through
the standardization route,

00:29:07.000 --> 00:29:11.400
so we anticipate other browsers
picking up on this and implementing it.

00:29:11.480 --> 00:29:14.120
So we anticipate this
X turning into a checkmark.

00:29:15.200 --> 00:29:18.160
So looking at this graph,
it may still be difficult to

00:29:18.230 --> 00:29:21.190
determine when you should use
which of these techniques which

00:29:21.190 --> 00:29:22.630
is right for you and your content.

00:29:22.740 --> 00:29:25.430
So let's talk about that.

00:29:27.140 --> 00:29:30.860
So you may recall CSS sizing has
all of these performance issues,

00:29:30.860 --> 00:29:34.010
but it's still an OK technique
to consider if you have a

00:29:34.010 --> 00:29:35.730
small number of local images.

00:29:36.070 --> 00:29:38.680
Local meaning they're
already on the device,

00:29:38.680 --> 00:29:40.420
so if you're an app or a book.

00:29:40.520 --> 00:29:46.860
You're still going to
pay that memory cost,

00:29:46.860 --> 00:29:46.900
which is why we recommend really
only a small number of images here.

00:29:47.090 --> 00:29:50.150
Media queries are great for many images,
and they're great for websites in

00:29:50.150 --> 00:29:54.990
addition to apps and books since they
have a really good cross-browser story.

00:29:55.360 --> 00:29:59.580
ImageSet is great for any
number of images as well,

00:29:59.760 --> 00:30:03.480
and it's great if
you're targeting WebKit.

00:30:03.480 --> 00:30:09.890
It's actually OK even if you're a website
that wants to work in many browsers

00:30:09.890 --> 00:30:13.090
because CSS degrades so gracefully.

00:30:13.090 --> 00:30:13.090
So other browsers would
just ignore this rule,

00:30:13.090 --> 00:30:13.090
and you would still get your
high-resolution images into

00:30:13.090 --> 00:30:13.090
any WebKit-based browsers.

00:30:14.840 --> 00:30:18.470
Okay, so hopefully now you all have a
full understanding of what you need

00:30:18.470 --> 00:30:21.610
to do to integrate high-resolution
artwork into your websites.

00:30:23.410 --> 00:30:25.630
Now I'd like to talk about Canvas,
and to do that,

00:30:25.680 --> 00:30:28.870
I would like to invite Dean Jackson,
my third favorite colleague,

00:30:29.020 --> 00:30:31.740
up to the stage.

00:30:33.600 --> 00:30:37.960
This time last year I was ninth,
so... Okay,

00:30:38.060 --> 00:30:44.350
so the example that Beth showed before,
it was pretty clear to demonstrate the

00:30:44.440 --> 00:30:49.690
significant difference in quality between
a photograph and the extremely crisp

00:30:49.690 --> 00:30:51.900
text that was displayed alongside it.

00:30:52.010 --> 00:30:55.720
And then Beth gave you a number of
techniques to banish those blurry images.

00:30:55.720 --> 00:30:59.370
But it turns out that photographs,
in fact, aren't always the types of

00:30:59.370 --> 00:31:02.660
images that are in most need of
improvement for written display.

00:31:02.940 --> 00:31:05.910
In fact, HTML Canvas is a great example
of something that needs a

00:31:05.920 --> 00:31:07.320
little bit more attention.

00:31:07.430 --> 00:31:09.310
So let's examine why.

00:31:09.440 --> 00:31:12.460
So here I have a photograph
of a three-headed alien from

00:31:12.460 --> 00:31:14.250
the planet Anthropologie.

00:31:14.350 --> 00:31:17.480
And actually,
this photograph is many times bigger

00:31:17.480 --> 00:31:21.140
than the size of this projector,
which is 19-20 across.

00:31:21.200 --> 00:31:23.070
But the photograph still looks good.

00:31:23.250 --> 00:31:25.350
In fact,
even when I scale it down 50% again,

00:31:25.350 --> 00:31:26.450
it still looks great.

00:31:26.500 --> 00:31:28.430
You can pick up a lot of detail.

00:31:28.600 --> 00:31:32.260
When I zoom it up to show it
at one-to-one pixel ratio,

00:31:32.280 --> 00:31:35.470
here we focus on the vicious
teeth of this creature.

00:31:35.580 --> 00:31:39.720
You can see there's a lot more
detail in the photograph than was

00:31:39.720 --> 00:31:41.820
shown when it was scaled down.

00:31:41.910 --> 00:31:45.230
Now I'm going to replace it
by an image that's the exact

00:31:45.230 --> 00:31:48.500
same region of the photograph,
but in this time I'm only going

00:31:48.510 --> 00:31:52.480
to use 256 pixels -- sorry,
240 pixels across and see if

00:31:52.480 --> 00:31:53.800
you can notice the difference.

00:31:53.990 --> 00:31:56.620
Full resolution, and there's the one.

00:31:56.750 --> 00:32:01.620
So here you've got something that's eight
times -- basically scaled up eight times.

00:32:01.620 --> 00:32:02.860
And it still looks okay.

00:32:02.860 --> 00:32:05.860
And that's because your brain and your
eyes are pretty good at fooling you into

00:32:05.910 --> 00:32:08.160
sort of de-blurring the image itself.

00:32:08.290 --> 00:32:12.170
Now when we take that photograph and
overlay it with an admittedly fake

00:32:12.300 --> 00:32:15.760
UI for a photo editing application,
we'll see that it's these types of

00:32:15.870 --> 00:32:19.960
synthetic or dynamically generated
images that are in most need of scaling.

00:32:20.090 --> 00:32:24.170
So here the photograph still looks fine,
but if I zoom in on the UI elements,

00:32:24.170 --> 00:32:28.050
you can see starting to see, like,
the chunks of text -- in this case,

00:32:28.050 --> 00:32:30.940
the text being drawn
directly into the image.

00:32:30.960 --> 00:32:34.400
The icons in particular looked
pretty terrible at high resolution.

00:32:34.460 --> 00:32:36.910
And here is a good example where
the straight lines have become

00:32:36.990 --> 00:32:40.260
these sort of stair steps,
and in fact the anti-aliasing of the

00:32:40.260 --> 00:32:44.710
horizontal lines is starting to look
awkward because the gaps between

00:32:44.710 --> 00:32:48.510
the lines have been interpolated.

00:32:48.790 --> 00:32:49.770
So that brings us to Canvas.

00:32:49.970 --> 00:32:52.600
These are the types of
images we want to talk about.

00:32:52.660 --> 00:32:54.080
So what is Canvas?

00:32:54.200 --> 00:32:57.630
It's a technique that was invented
by Apple a few years ago to allow

00:32:57.800 --> 00:33:01.580
you to dynamically generate images
in JavaScript in the browser.

00:33:01.580 --> 00:33:05.360
Since then, it's become one of the most
popular features in HTML5.

00:33:05.360 --> 00:33:08.370
People use it for maps and
decorations and games and

00:33:08.370 --> 00:33:10.330
charts and all sorts of things.

00:33:10.440 --> 00:33:12.910
And Apple uses it for a
few things in Dashboard,

00:33:12.910 --> 00:33:16.780
for example, the stocks widget and the
flight widget and the clock.

00:33:17.700 --> 00:33:22.340
So our goal for this part is to show
you how to create your Canvas to be as

00:33:22.340 --> 00:33:24.550
best as possible on a retina display.

00:33:24.550 --> 00:33:26.690
What do we got to cover?

00:33:26.750 --> 00:33:28.660
So first we have to describe
how the Canvas actually

00:33:28.660 --> 00:33:29.700
works on a retina display.

00:33:29.700 --> 00:33:32.700
Then we're going to talk about
how to improve your Canvas.

00:33:32.720 --> 00:33:34.660
And lastly, we're going to just show,
in most cases,

00:33:34.660 --> 00:33:37.410
you don't need to change your code,
but there are some cases where

00:33:37.410 --> 00:33:38.700
you need to update your code.

00:33:38.700 --> 00:33:42.480
So let's start with how does
Canvas behave on a retina display.

00:33:42.630 --> 00:33:46.700
And we'll start, in fact,
by describing how a regular image works.

00:33:46.700 --> 00:33:48.700
So Canvas doesn't have an image element.

00:33:48.700 --> 00:33:52.120
It typically starts with a referenced
file somewhere on the web or on

00:33:52.120 --> 00:33:53.680
a disk if you're a native app.

00:33:53.730 --> 00:33:55.620
And this file is a JPEG or a PNG.

00:33:55.860 --> 00:33:58.770
And the browser's got to read
that file and decode it into

00:33:58.770 --> 00:34:00.630
a rectangular array of pixels.

00:34:00.680 --> 00:34:02.700
Each pixel represents a color.

00:34:02.700 --> 00:34:05.800
When it comes time to draw,
it takes that rectangular array

00:34:05.800 --> 00:34:09.690
and basically puts it into another
rectangular region on the screen.

00:34:09.690 --> 00:34:11.700
And sometimes it has to
squish or stretch that array,

00:34:11.700 --> 00:34:15.700
making up pixels, as Beth said,
taking an educated guess.

00:34:15.700 --> 00:34:19.010
Canvas is, in fact, exactly the same,
except instead of coming

00:34:19.140 --> 00:34:22.690
from an image file,
we have something called a backing store.

00:34:22.700 --> 00:34:25.900
So it's actually JavaScript that's got
to tell the browser what the rectangular

00:34:25.900 --> 00:34:27.700
array of pixels is going to be sized at.

00:34:27.700 --> 00:34:30.700
In this case, I've just said 400 by 250.

00:34:30.700 --> 00:34:32.260
And it starts off blank,
so we need to write some more

00:34:32.370 --> 00:34:35.490
JavaScript that's going to set the
color of every one of those pixels.

00:34:35.700 --> 00:34:37.420
And there's a whole bunch
of commands to do that,

00:34:37.420 --> 00:34:39.700
and basically you end up with
the same rectangular array.

00:34:39.700 --> 00:34:41.700
And from that point on,
it's exactly the same.

00:34:41.700 --> 00:34:43.390
When we come to draw,
we take that and squish it

00:34:43.460 --> 00:34:44.700
and stretch it into the page.

00:34:44.700 --> 00:34:46.200
age.

00:34:47.950 --> 00:34:51.820
The goal, as with images for Canvas,
is to always have the same number

00:34:51.820 --> 00:34:54.760
of pixels in your backing store
or your image pixels as you do

00:34:54.760 --> 00:34:59.160
in the device pixels when you
actually display it on the screen.

00:34:59.820 --> 00:35:03.010
So let's talk about what happens
on a normal resolution display.

00:35:03.250 --> 00:35:08.940
So let's imagine I've got a canvas
that's sized at 400 by 250 CSS pixels.

00:35:09.100 --> 00:35:13.140
Now, on a non-retina display,
without this viewport scale

00:35:13.140 --> 00:35:16.820
or without the user zooming,
that's going to cover 400 by

00:35:16.910 --> 00:35:19.840
250 pixels on the display,
and unsurprisingly,

00:35:19.840 --> 00:35:24.530
this means you want a canvas
size of 400 by 250 pixels.

00:35:24.670 --> 00:35:25.720
So this bit of code is really simple.

00:35:25.720 --> 00:35:27.000
We're going to come
back to it a few times.

00:35:27.000 --> 00:35:28.760
This is the easy case.

00:35:28.870 --> 00:35:36.110
I start with some global variables that
define my width and height in CSS pixels.

00:35:36.800 --> 00:35:39.830
Then I go to get a reference
to my canvas element.

00:35:39.830 --> 00:35:42.380
And the next I want to set the width
and height of the canvas element

00:35:42.660 --> 00:35:43.940
to what the global variables were.

00:35:43.940 --> 00:35:44.700
Now, this is important.

00:35:44.700 --> 00:35:47.300
It's not actually changing the
size of the canvas on the page.

00:35:47.340 --> 00:35:50.940
It's telling the browser how many
pixels it needs in its backing store.

00:35:50.940 --> 00:35:53.110
So in this case,
it's going to create this rectangular

00:35:53.110 --> 00:35:56.250
array of 400 by 250 pixels,
which is exactly what we wanted.

00:35:56.950 --> 00:35:58.690
When we come to draw,
canvas has a whole set of

00:35:58.900 --> 00:36:00.040
commands for doing drawing.

00:36:00.040 --> 00:36:01.100
I'm not going to cover them.

00:36:01.100 --> 00:36:02.670
But in this case,
we just want to keep this

00:36:02.670 --> 00:36:03.720
one in mind as an example.

00:36:03.720 --> 00:36:07.050
I want to just draw a square
in the page that's covering 30

00:36:07.160 --> 00:36:09.230
CSS pixels by 30 CSS pixels.

00:36:09.230 --> 00:36:10.310
That's it.

00:36:10.360 --> 00:36:12.200
So that was the easy case.

00:36:12.200 --> 00:36:14.440
Let's talk about a retina case.

00:36:14.440 --> 00:36:18.120
We'll start with retina on
OS X because retina on iPad is

00:36:18.230 --> 00:36:20.380
like just so eight weeks ago.

00:36:20.380 --> 00:36:26.000
Now, the canvas size is exactly the same,
400 by 250 pixels.

00:36:26.470 --> 00:36:28.120
But when we display that,
as Beth mentioned,

00:36:28.120 --> 00:36:30.120
we're using a technique
called pixel doubling.

00:36:30.120 --> 00:36:33.120
So in fact,
it's going to cover 800 by 500 pixels.

00:36:33.120 --> 00:36:36.650
And because it's scaling
that original size up,

00:36:36.720 --> 00:36:40.380
it's going to look blurry unless
we actually allocate 800 by 500

00:36:40.470 --> 00:36:41.700
pixels in our backing store.

00:36:41.700 --> 00:36:44.920
Once we do that,
we actually get the nice output at the

00:36:45.180 --> 00:36:47.210
right size in the page in our canvas.

00:36:47.360 --> 00:36:51.510
So on OS X,

00:36:52.140 --> 00:36:55.240
We want, again,
400 by 250 pixel-sized canvas to end

00:36:55.240 --> 00:36:57.600
up with an 800 by 500 backing store.

00:36:57.600 --> 00:37:00.720
And the good news is, on OS X,
you don't actually have to do anything.

00:37:00.880 --> 00:37:02.940
We're doing the work for you.

00:37:02.940 --> 00:37:06.170
So the system's going to detect
that I'm on a Retina display,

00:37:06.170 --> 00:37:10.550
and we wanted all the web pages out there
in the world to look better on these new

00:37:10.550 --> 00:37:12.640
MacBook Pros without any code change.

00:37:12.750 --> 00:37:14.820
So behind the scenes,
WebKit is actually going to say, okay,

00:37:14.870 --> 00:37:17.300
Retina display,
I'm going to allocate twice as many

00:37:17.300 --> 00:37:21.100
backing store pixels as the user asked
for and produce the better display.

00:37:21.100 --> 00:37:23.050
So, in fact,
our code hasn't changed at all.

00:37:23.120 --> 00:37:26.750
Still got the global variables,
400 by 250, but down here,

00:37:26.750 --> 00:37:30.220
when we actually request the width
and height exactly the same as before,

00:37:30.220 --> 00:37:32.530
the system's going to say, well,
they asked for 400,

00:37:32.530 --> 00:37:35.930
but I know they really want
800 to make it look good.

00:37:37.870 --> 00:37:39.000
We now got a bigger backing store.

00:37:39.000 --> 00:37:42.120
Well, why don't we have to change our
drawing code because otherwise things

00:37:42.230 --> 00:37:43.680
will come-- will appear very small.

00:37:43.680 --> 00:37:46.100
It turns out we actually take care
of that for you automatically.

00:37:46.100 --> 00:37:50.150
So before we start drawing,
we apply a scale factor to all

00:37:50.150 --> 00:37:54.970
your commands so that everything's
going to come out twice the size,

00:37:55.180 --> 00:37:58.850
drawn with the best quality
into the backing store.

00:37:58.850 --> 00:38:01.670
So again, here, our 30 by 30 square is,
in fact, going to cover 60 by 60

00:38:01.670 --> 00:38:01.670
pixels in the backing store.

00:38:01.770 --> 00:38:05.900
So Canvas on OS X means with the
exact same code on a normal display,

00:38:05.900 --> 00:38:06.650
you get to get the output.

00:38:06.760 --> 00:38:08.810
With no changes,
you get a much better quality

00:38:08.880 --> 00:38:11.940
on the retina display,
and that's fantastic.

00:38:12.000 --> 00:38:14.770
But you probably know that there's
a couple hundred million devices out

00:38:14.770 --> 00:38:17.390
there with existing retina displays,
and that's iOS.

00:38:17.580 --> 00:38:19.460
And the story's a little
bit different there,

00:38:19.460 --> 00:38:21.920
so we're going to go through this now.

00:38:22.230 --> 00:38:27.100
So you're probably sick of this slide,
but again, 400 by 250 pixel canvas.

00:38:27.100 --> 00:38:30.340
We want it to be 800 by
500 backing store pixels.

00:38:30.340 --> 00:38:37.300
But on retina on iOS,
the system isn't going to automatically

00:38:37.400 --> 00:38:38.880
double the backing store for you.

00:38:38.880 --> 00:38:40.980
So why did we make this decision?

00:38:40.980 --> 00:38:42.480
There's basically two reasons.

00:38:42.480 --> 00:38:46.120
One is the very nature of these
devices is that the web content isn't

00:38:46.280 --> 00:38:48.640
always viewed at the one-to-one scale.

00:38:48.840 --> 00:38:50.490
Typically,
there's a viewport or the user is

00:38:50.630 --> 00:38:51.920
pinched to zoom or panned around.

00:38:51.920 --> 00:38:57.040
And it's quite often that the size you've
actually decided to render your page,

00:38:57.040 --> 00:38:59.560
it's not exactly how it's going to
be displayed on the user's device.

00:38:59.580 --> 00:39:04.110
The other thing is that memory use and
CPU performance and battery life is

00:39:04.110 --> 00:39:05.390
much more precious on these devices.

00:39:05.400 --> 00:39:08.720
So we wanted to make sure that
we didn't automatically double

00:39:08.720 --> 00:39:10.460
things and use up the resources.

00:39:10.480 --> 00:39:12.840
And it's up to you, the developer,
to choose how big you

00:39:12.840 --> 00:39:14.120
want your backing store.

00:39:14.120 --> 00:39:17.280
So in this case, I have to manually
double my backing store.

00:39:17.280 --> 00:39:18.810
I have to detect that I'm on a retina.

00:39:18.840 --> 00:39:20.960
I have to detect that I'm on a retina
display in order to decide whether

00:39:20.970 --> 00:39:22.220
I need to double my backing store.

00:39:22.220 --> 00:39:25.840
And I do this with the property device
pixel ratio that Beth mentioned before.

00:39:25.840 --> 00:39:30.400
So this is the scaling factor between
normal pixels and the retina pixels.

00:39:30.400 --> 00:39:33.460
So it's one on a normal device
and two on another device.

00:39:33.500 --> 00:39:35.990
So if the device pixel
ratio is undefined to one,

00:39:35.990 --> 00:39:37.700
you're on a non-retina device.

00:39:37.780 --> 00:39:40.020
If it's two,
then you're on a retina device.

00:39:40.020 --> 00:39:41.990
So this allows me to write
this little bit of code,

00:39:42.030 --> 00:39:43.490
and I'm going to come
back to it a few times,

00:39:43.610 --> 00:39:46.840
which is effectively telling me
how much I want to scale my canvas

00:39:47.000 --> 00:39:48.660
by or my backing store canvas
by and how much I want to scale

00:39:48.680 --> 00:39:48.820
my back-to-back store canvas by.

00:39:48.930 --> 00:39:51.590
So in this case,
it's a bit more complicated

00:39:51.860 --> 00:39:54.700
than it needs to be,
but you'll get the point that if

00:39:54.700 --> 00:39:58.130
my device pixel ratio is around,
then that's the scale factor I use.

00:39:59.680 --> 00:40:01.200
So,
now the code is just slightly different.

00:40:01.200 --> 00:40:04.450
I've added -- that's the same
and I've added a global variable

00:40:04.450 --> 00:40:05.830
which is my backing scale.

00:40:05.830 --> 00:40:08.360
I've used the function just
on the previous slide to

00:40:08.440 --> 00:40:10.870
work out the scale factor,
and then down below when

00:40:10.870 --> 00:40:13.480
I allocate my canvas,
I'm actually going to use that

00:40:13.480 --> 00:40:16.800
multiplying factor -- or use that
factor to multiply the width and

00:40:16.800 --> 00:40:18.850
height that I ask for my backing store.

00:40:18.850 --> 00:40:22.160
So, in this case,
it would be two by 400 or two by 250,

00:40:22.250 --> 00:40:24.420
800 by 500 canvas,
we've got what we want.

00:40:24.590 --> 00:40:27.010
But there's a problem,
and some of you might have

00:40:27.100 --> 00:40:28.280
picked up what the problem is.

00:40:28.280 --> 00:40:32.550
If I run this exact code on OS X,
what's going to happen is that

00:40:32.550 --> 00:40:36.770
I'm now specifically asking for
an 800 by 500 backing store,

00:40:36.780 --> 00:40:38.660
and the system is going to say, well,
I'm on a Retina device,

00:40:38.660 --> 00:40:41.430
I'll auto double it for you and
actually give you 1600 by 1000,

00:40:41.430 --> 00:40:43.570
which is going to be four
times bigger than you wanted,

00:40:43.620 --> 00:40:47.200
in fact, 16 times bigger than what
you originally asked for.

00:40:47.270 --> 00:40:50.060
So you need to be very careful that
if you're on a system that's manually

00:40:50.120 --> 00:40:53.200
doubling the backing store size for you,
you need to detect that.

00:40:53.400 --> 00:40:55.270
So how do we detect it?

00:40:55.350 --> 00:40:57.650
There's another property,
which is the WebKit Backing

00:40:57.720 --> 00:40:58.580
Store Pixel Ratio.

00:40:58.730 --> 00:41:01.530
So whereas the device pixel ratio told
you the multiplying factor between a

00:41:01.530 --> 00:41:05.710
normal pixel and the display pixel,
the WebKit Backing Store Pixel Ratio

00:41:05.710 --> 00:41:08.510
tells you the multiplying factor
between how many pixels you asked

00:41:08.510 --> 00:41:11.580
for in your backing store and how
many it's actually going to give you.

00:41:12.000 --> 00:41:14.250
If the back-and-stall pixel
ratio is undefined or 1,

00:41:14.250 --> 00:41:17.490
it would be undefined on a browser
that doesn't support this property,

00:41:17.490 --> 00:41:19.700
you're on a system that
does not auto-double,

00:41:19.700 --> 00:41:22.500
so that could be a non-retina
device or an iOS device.

00:41:22.640 --> 00:41:29.470
And if the WebKit back-and-stall
pixel ratio is 2,

00:41:29.670 --> 00:41:30.580
then you're on a system that
auto-doubles whatever you request,

00:41:30.580 --> 00:41:30.580
an OS X retina device.

00:41:31.070 --> 00:41:34.460
So this is getting a bit complicated,
so we'll just draw it as a flow chart.

00:41:34.690 --> 00:41:36.070
The first question
you're going to ask is,

00:41:36.080 --> 00:41:37.060
am I on a retina device?

00:41:37.060 --> 00:41:39.860
If I'm not on a retina device,
then I don't have to do anything.

00:41:39.870 --> 00:41:40.940
No scale needed.

00:41:40.940 --> 00:41:44.050
If I am on a retina device,
then the next question I have to ask is,

00:41:44.050 --> 00:41:46.900
is the system going to
auto-double the pixels for me?

00:41:46.900 --> 00:41:50.270
If it's not, then I have to manually
double the pixels.

00:41:50.410 --> 00:41:52.200
I'm on an iOS retina device.

00:41:52.280 --> 00:41:57.160
If it does auto-double the pixels,
then I, again, don't have to do anything,

00:41:57.160 --> 00:41:59.320
but I'm on a retina OS X device.

00:41:59.540 --> 00:42:01.700
So we flip this question
around to actually ask,

00:42:01.700 --> 00:42:03.580
what scaling factor do I need to apply?

00:42:03.580 --> 00:42:06.370
The answer is 1, 2, 1, and 1,
we don't have to do anything,

00:42:06.370 --> 00:42:07.920
and in fact, they're the same.

00:42:07.920 --> 00:42:10.110
So the really only case we
need to worry about is this.

00:42:10.110 --> 00:42:11.430
Am I on a retina device?

00:42:11.430 --> 00:42:11.780
Yes.

00:42:11.840 --> 00:42:14.290
And is the system going to
auto-double the pixels for me?

00:42:14.290 --> 00:42:14.620
No.

00:42:14.620 --> 00:42:16.280
In which case, multiply by 2.

00:42:16.280 --> 00:42:18.550
So I'm going to update my
code that I had before,

00:42:18.550 --> 00:42:21.110
and again,
there's many ways you can write this.

00:42:21.190 --> 00:42:22.130
This is the way I chose it.

00:42:22.260 --> 00:42:24.110
If the device pixel
ratio is greater than 1,

00:42:24.110 --> 00:42:24.820
I'm on retina.

00:42:24.820 --> 00:42:27.930
Or if the context WebKit back-install
pixel ratio is less than 2,

00:42:27.930 --> 00:42:29.240
I'm not auto-doubling.

00:42:29.650 --> 00:42:32.750
Then return the scaling factor
that the screen is using.

00:42:32.840 --> 00:42:36.030
I'm going to use this function
again in the same code.

00:42:36.500 --> 00:42:41.240
Instead of -- I'm going to declare
the variable initially to be nothing,

00:42:41.240 --> 00:42:44.460
and down below,
I need to actually have the context to

00:42:44.460 --> 00:42:46.030
decide whether it's going to auto-double.

00:42:46.140 --> 00:42:48.940
So here I set the global
variable to be the scale factor,

00:42:48.940 --> 00:42:52.190
which will be 2 on an iOS
retina device and 1 elsewhere.

00:42:52.240 --> 00:42:55.680
And now I can just use this same code,
so I'll get the right

00:42:55.820 --> 00:42:57.590
result on an OS X device.

00:42:57.980 --> 00:43:01.630
Now we're in a situation
where some devices actually

00:43:01.630 --> 00:43:04.420
have a doubled backing store,
some have an automatically

00:43:04.430 --> 00:43:07.220
doubled backing store,
and the drawing is taken care of,

00:43:07.370 --> 00:43:10.200
so I have to take care of the fact
where I'm actually manually drawing

00:43:10.200 --> 00:43:12.500
into a doubled backing store,
otherwise everything's going

00:43:12.610 --> 00:43:14.500
to appear really small and up
in the top left-hand corner.

00:43:14.500 --> 00:43:16.700
So I do this first in my,
this is my entry point

00:43:16.800 --> 00:43:18.020
to the draw function.

00:43:18.020 --> 00:43:20.140
I'm going to save the
state of the drawing,

00:43:20.220 --> 00:43:21.820
the context as it is right now.

00:43:21.820 --> 00:43:24.240
I'm going to apply the scale
factor that I calculated before.

00:43:24.860 --> 00:43:26.640
If this is one, of course,
it's not going to do anything,

00:43:26.640 --> 00:43:27.220
so it's fine.

00:43:27.220 --> 00:43:28.950
If it's two,
it's going to make all the drawing

00:43:28.950 --> 00:43:31.750
operations from here on in twice as big,
which is exactly what we want.

00:43:31.780 --> 00:43:34.170
And as I exit,
I reset the sale so it's not accumulating

00:43:34.170 --> 00:43:36.000
every time I come into this function.

00:43:37.680 --> 00:43:38.980
So there's some things to consider.

00:43:38.980 --> 00:43:42.240
The first is you are actually
going to use more memory,

00:43:42.390 --> 00:43:43.360
four times as much memory.

00:43:43.360 --> 00:43:46.480
And Beth mentioned why this
is important on some devices.

00:43:46.480 --> 00:43:47.980
The drawing performance,
you're drawing to four

00:43:47.980 --> 00:43:50.130
times as many pixels,
which is going to be a little bit slower.

00:43:50.240 --> 00:43:52.480
So it's really up to you
to decide or to determine.

00:43:52.480 --> 00:43:55.550
You might have the best idea of
what scale the user is actually

00:43:55.550 --> 00:43:56.660
going to view their canvas at.

00:43:56.660 --> 00:43:58.460
It might not be one-to-one.

00:43:58.460 --> 00:44:00.590
If you think they're never going
to zoom in on this element,

00:44:00.590 --> 00:44:03.640
you might not need a retina canvas.

00:44:04.080 --> 00:44:06.630
There are some code and API changes
I'll get to at the moment.

00:44:06.750 --> 00:44:09.330
So where are we in summary?

00:44:09.410 --> 00:44:12.220
We always want to pick the one-to-one,
the same number of image

00:44:12.220 --> 00:44:13.520
pixels as device pixels.

00:44:13.670 --> 00:44:16.880
You have to check
whether you're on Retina,

00:44:16.880 --> 00:44:21.930
in which case you're going to need
to double your back-end store.

00:44:21.930 --> 00:44:24.090
And then if the system is going to
automatically double the back-end store,

00:44:24.090 --> 00:44:24.090
you have to do it manually.

00:44:24.090 --> 00:44:24.090
If the system isn't,
you have to do it manually.

00:44:24.370 --> 00:44:26.300
So in our progress chart,
we actually were having so much fun,

00:44:26.300 --> 00:44:29.370
we skipped past one and now
we've covered two as well.

00:44:29.770 --> 00:44:33.180
So the last thing to cover is
what are the actual code changes?

00:44:33.280 --> 00:44:34.800
And there are three to cover.

00:44:34.940 --> 00:44:38.660
So there's this very handy function
called ability in Canvas to be

00:44:38.660 --> 00:44:40.900
able to access the pixels directly.

00:44:40.900 --> 00:44:43.010
In most cases,
you just use the JavaScript draw

00:44:43.010 --> 00:44:44.890
functions to draw shapes or whatever.

00:44:45.000 --> 00:44:47.150
In this case,
you might want to access the pixels

00:44:47.150 --> 00:44:50.400
and do something like increase the
brightness or set every other pixel

00:44:50.400 --> 00:44:52.300
to red or something crazy like that.

00:44:52.410 --> 00:44:56.130
So the idea is given a Canvas element,
you give a rectangle, a rectangle, x, y,

00:44:56.130 --> 00:44:59.170
width, height, and it's going to extract
that rectangle and give you a

00:44:59.170 --> 00:45:03.300
variable in your JavaScript,
which is the array of pixels there are.

00:45:03.300 --> 00:45:05.600
And you can iterate over
that array and set the color.

00:45:05.700 --> 00:45:06.800
Put image data does the same thing.

00:45:06.800 --> 00:45:10.820
It takes that array after you've
possibly manipulated it and puts it

00:45:10.960 --> 00:45:13.000
back into a region of the Canvas.

00:45:13.150 --> 00:45:16.020
Now, it's important to note,
even on a retina display,

00:45:16.100 --> 00:45:19.880
that these parameters to the
functions are actually in CSS pixels.

00:45:19.960 --> 00:45:22.060
So what this means, if you ask,
for example, say,

00:45:22.060 --> 00:45:26.640
for a 30x30 region on an
automatically doubled backing store,

00:45:26.640 --> 00:45:30.670
it's actually going to take a 60x60
pixel region and squish it down into the

00:45:30.670 --> 00:45:33.200
30x30 pixels and give it back to you.

00:45:33.260 --> 00:45:35.460
So the image is sort of being compressed.

00:45:35.600 --> 00:45:38.810
In the same way,
when you write a 30x30 pixel

00:45:38.810 --> 00:45:41.990
image into put image data,
the system's going to take

00:45:41.990 --> 00:45:44.140
that and stretch it out,
effectively making it blurry before

00:45:44.140 --> 00:45:45.440
it's putting it into the canvas.

00:45:45.440 --> 00:45:49.310
And the reason we did this is if you
look at most of the code on the Internet,

00:45:49.310 --> 00:45:52.020
when people call get image
data XY width height,

00:45:52.020 --> 00:45:55.900
they normally follow it up with something
like 4i equals 0 to width times height,

00:45:56.050 --> 00:45:57.700
do something with those pixels.

00:45:57.700 --> 00:46:00.650
So if we actually gave back more
pixels than they'd asked for,

00:46:00.650 --> 00:46:04.380
then all that code would break and
we'd effectively destroy the Internet.

00:46:06.390 --> 00:46:08.450
So what happens if you really
want access to the pixels?

00:46:08.560 --> 00:46:10.660
We've added two functions.

00:46:10.730 --> 00:46:12.800
So the first, the top ones are the ones
we're already familiar with.

00:46:12.800 --> 00:46:14.320
The parameters are in CSS pixels.

00:46:14.480 --> 00:46:23.510
If you want actual access to
whatever the backing store has,

00:46:23.510 --> 00:46:23.510
use these new methods,
WebKit Get Image Data HD and

00:46:23.510 --> 00:46:23.510
WebKit Put Image Data HD.

00:46:24.810 --> 00:46:27.770
It's important for that to
remember that you need to be

00:46:27.770 --> 00:46:29.480
aware of what region you are.

00:46:29.480 --> 00:46:33.500
If you actually want the 30 by 30
region on an auto-double scale,

00:46:33.500 --> 00:46:35.400
you need to make sure
you ask for 60 by 60.

00:46:35.400 --> 00:46:38.760
The second thing to consider is when
you're drawing images into a canvas.

00:46:38.760 --> 00:46:42.390
It's a pretty common thing to do,
but now we're in a situation where

00:46:42.390 --> 00:46:46.580
we don't necessarily know how big the
canvas is that we're drawing into.

00:46:47.720 --> 00:46:49.830
You should always,
as Beth mentioned before with CSS,

00:46:49.830 --> 00:46:52.340
you should always specify width
and height for your images.

00:46:52.340 --> 00:46:55.830
In fact,
there's one type of form of the draw

00:46:55.830 --> 00:46:59.340
image command in Canvas which seems
really convenient where you just say,

00:46:59.340 --> 00:47:02.460
here's my image in my XY position,
and it's going to put it into the canvas.

00:47:02.460 --> 00:47:04.810
Let's say you're drawing
one canvas into another.

00:47:04.810 --> 00:47:07.780
We don't actually know how many
pixels that image is going to cover,

00:47:07.850 --> 00:47:10.590
so it's really important to
know exactly what the dimensions

00:47:10.590 --> 00:47:12.180
of the output is going to be.

00:47:13.620 --> 00:47:16.860
The last change is another
convenient function,

00:47:16.860 --> 00:47:21.500
which is the ability to take a canvas
and extract it as an image file.

00:47:21.500 --> 00:47:24.180
And this is useful if, say,
you've got an application that's

00:47:24.180 --> 00:47:27.160
drawing onto the canvas and you want
to post the image up to your server.

00:47:27.170 --> 00:47:29.780
So given a canvas,
you call this function toDataURL,

00:47:29.780 --> 00:47:33.960
and it takes parameters of an image type,
but normally we just call it directly.

00:47:33.960 --> 00:47:35.730
And it returns this
string of gobbledygook,

00:47:35.760 --> 00:47:38.390
which is actually, for example,
in this case,

00:47:38.390 --> 00:47:40.500
a ping image encoded as text.

00:47:40.960 --> 00:47:45.270
Now, like the original
Get Image Data functions,

00:47:45.270 --> 00:47:48.410
this function works in CSS pixels.

00:47:48.620 --> 00:47:52.750
So if you are on an auto-double display,
you've got to get the

00:47:52.750 --> 00:47:56.500
CSS pixels you requested,
not the full size of the back-end store.

00:47:56.600 --> 00:47:59.250
So the three things to consider that
you might need to look for if your

00:47:59.250 --> 00:48:04.070
retina canvas isn't quite working is new
methods for extracting the exact pixels,

00:48:04.150 --> 00:48:04.950
if you need that.

00:48:05.080 --> 00:48:08.080
Always specify your width and height,
and be careful when

00:48:08.080 --> 00:48:10.210
you're using 2Data URL.

00:48:10.480 --> 00:48:13.070
And with that, we've finished the canvas.

00:48:13.140 --> 00:48:14.230
I'm going to invite Beth back.

00:48:14.310 --> 00:48:18.350
Beth obviously doesn't know I've
found her secret stash of cookies,

00:48:18.350 --> 00:48:20.560
and I'm still third in the ranking.

00:48:20.560 --> 00:48:23.260
Thanks.

00:48:23.260 --> 00:48:24.140
Thank you.

00:48:24.140 --> 00:48:25.510
Thank you, Dean.

00:48:25.580 --> 00:48:26.810
That was great.

00:48:29.030 --> 00:48:33.300
Okay, so as I'm sure you all know,
images are really an important part of

00:48:33.380 --> 00:48:35.460
creating an immersive web experience.

00:48:35.460 --> 00:48:38.960
And we understand that, too,
and that's why we've been talking

00:48:38.960 --> 00:48:42.330
at you for 45 minutes now about
how to make sure your images

00:48:42.330 --> 00:48:44.580
look fabulous on retina displays.

00:48:44.580 --> 00:48:48.280
But in many cases,
web technologies are sophisticated enough

00:48:48.310 --> 00:48:50.850
that you can use them in place of images.

00:48:50.850 --> 00:48:55.500
Make WebKit do all of the work to make
sure it looks great on retina displays.

00:48:55.960 --> 00:48:58.660
So I'm going to quickly take
you through three scenarios

00:48:58.660 --> 00:49:00.030
where you can do just that.

00:49:00.190 --> 00:49:03.720
First, I'll talk about making
image-free glossy buttons.

00:49:03.730 --> 00:49:06.720
And then we'll talk about
letting text be text.

00:49:06.780 --> 00:49:09.760
And finally, we'll discuss SVG.

00:49:10.220 --> 00:49:12.960
So,
on my little Hawaiian vacation blog here,

00:49:12.960 --> 00:49:15.430
I have this button,
and this is just a simple

00:49:15.760 --> 00:49:19.480
input type equals button,
but if I wanted to style this to give it

00:49:19.480 --> 00:49:24.520
a little bit more of that aloha spirit,
I would probably make it look like this.

00:49:24.520 --> 00:49:28.020
And it's a very common technique on
websites when styling a form control

00:49:28.020 --> 00:49:29.550
like this to use image assets.

00:49:29.570 --> 00:49:32.410
And if that's what you do and
what you want to continue doing,

00:49:32.530 --> 00:49:35.540
then I've taught you everything
that you need to know about how to

00:49:35.640 --> 00:49:38.030
integrate high-resolution image assets.

00:49:38.520 --> 00:49:41.670
But image assets are really a
bit brittle for such a small

00:49:41.780 --> 00:49:43.420
UI element like this one.

00:49:43.420 --> 00:49:46.140
If I wanted to change it
to make it a green button,

00:49:46.140 --> 00:49:48.190
then I'd have to go change
all those image files,

00:49:48.190 --> 00:49:50.700
the low-resolution ones and
the high-resolution ones.

00:49:50.700 --> 00:49:54.600
Having image files for such a
small element is like a little

00:49:54.900 --> 00:49:57.280
extra burden on the memory as well.

00:49:57.280 --> 00:49:59.200
So wouldn't it be great
if I didn't need them?

00:49:59.200 --> 00:50:00.210
Well, I don't.

00:50:00.220 --> 00:50:01.540
And I made this button with CSS.

00:50:01.540 --> 00:50:02.690
Let me show you what I did.

00:50:02.690 --> 00:50:04.690
So I started with a div,
and I gave it some really

00:50:04.700 --> 00:50:06.920
basic styles with height,
a border, and a size.

00:50:06.970 --> 00:50:07.520
So I started with a div,
and I gave it some really

00:50:07.650 --> 00:50:08.360
basic styles with height,
a border, and a size.

00:50:08.630 --> 00:50:12.250
Purple background color,
white text centered the text.

00:50:12.510 --> 00:50:13.500
All of this is really basic.

00:50:13.610 --> 00:50:18.190
But now I'm going to show you what
I did to make this really come alive.

00:50:18.340 --> 00:50:22.160
First,
I rounded the corners with border radius.

00:50:22.200 --> 00:50:25.150
And then I gave the button a
little bit of extra depth using

00:50:25.150 --> 00:50:29.710
shadow as a text shadow and a
box shadow on the button itself.

00:50:29.870 --> 00:50:31.960
And finally,
to really make that button come alive

00:50:31.960 --> 00:50:34.940
with that fully lickable appearance,
I gave it a background image

00:50:34.940 --> 00:50:36.900
that's a WebKit-generated gradient.

00:50:36.910 --> 00:50:40.190
That's all I really need
for this beautiful button.

00:50:40.230 --> 00:50:43.460
It's worth noting that you can use this
technique to make buttons that look

00:50:43.460 --> 00:50:45.840
exactly like the system buttons on iOS.

00:50:46.060 --> 00:50:49.550
So this is a little web app
mockup of the Notes app,

00:50:49.640 --> 00:50:53.280
and this button is created
in exactly the same way.

00:50:53.890 --> 00:50:55.680
Okay, now let's jump to text.

00:50:55.680 --> 00:51:00.310
So you may have noticed that I also
have this lovely masthead on my blog.

00:51:00.320 --> 00:51:03.070
And you may have noticed that it
didn't get blurry when we looked

00:51:03.110 --> 00:51:06.490
at my blog on the retina device,
unlike the image that's on this page,

00:51:06.490 --> 00:51:07.680
which did get blurry.

00:51:07.680 --> 00:51:11.470
And you may have expected it to get
blurry because many people make mastheads

00:51:11.520 --> 00:51:15.420
like this with images because of the kind
of design control that they provide for

00:51:15.540 --> 00:51:17.640
such an important UI element on my page.

00:51:17.640 --> 00:51:20.760
Well, this didn't get blurry
because it's just text.

00:51:21.630 --> 00:51:25.710
What I've done is that I have a
font that I have the ability to use.

00:51:25.780 --> 00:51:27.980
All fonts have licenses
associated with them,

00:51:27.980 --> 00:51:30.370
so you do have to make sure
you can use a font in this way

00:51:30.370 --> 00:51:31.840
before you go ahead and do it.

00:51:31.910 --> 00:51:35.540
And then I've just embedded it in my
CSS so that I can refer to it later.

00:51:35.540 --> 00:51:36.540
It's very simple.

00:51:36.540 --> 00:51:39.660
I've just used the at font face rule,
given it a font family name.

00:51:39.660 --> 00:51:40.640
I could call it anything.

00:51:40.640 --> 00:51:43.770
And then I'm using the
SRC property to point to where

00:51:43.770 --> 00:51:45.800
I have that font file stored.

00:51:45.800 --> 00:51:50.260
And then I can just refer back to that
font family name any time I want to,

00:51:50.260 --> 00:51:51.380
the same way I would refer.

00:51:51.520 --> 00:51:53.100
I can refer to any
other font family name.

00:51:53.100 --> 00:51:57.240
The result is something that
looks great at all sizes,

00:51:57.240 --> 00:51:59.380
so it scales really, really well.

00:51:59.380 --> 00:52:02.720
On top of that, it's more accessible,
more searchable,

00:52:02.720 --> 00:52:04.840
and more editable than what I had before.

00:52:04.840 --> 00:52:05.940
Okay.

00:52:05.940 --> 00:52:08.500
Finally, let's discuss SVG.

00:52:08.500 --> 00:52:11.850
So SVG is a way,
it's like a set of instructions

00:52:11.850 --> 00:52:13.760
for defining an image.

00:52:13.760 --> 00:52:17.100
So it's entirely instruction-based
instead of being pixel-based

00:52:17.380 --> 00:52:18.610
like other image formats.

00:52:18.710 --> 00:52:21.500
That can sometimes limit the use case.

00:52:21.500 --> 00:52:24.920
So SVG is a way to use a lot of
different interfaces for SVG,

00:52:24.920 --> 00:52:27.190
but it still has tons of applications.

00:52:27.260 --> 00:52:29.700
So rather than talk about it,
I'd rather show it to you.

00:52:29.740 --> 00:52:32.800
I'd like to bring someone who knows a
thing or two about SVG back to the stage.

00:52:36.360 --> 00:52:42.270
Okay, so as Beth mentioned,
SVG is an image format.

00:52:42.340 --> 00:52:44.590
It's actually an image format,
it's a text format as well,

00:52:44.590 --> 00:52:45.450
very similar to HTML.

00:52:45.700 --> 00:52:51.180
And the techniques Beth showed before
about replacing a chunk of -- sorry,

00:52:51.180 --> 00:52:55.250
collection of images with a chunk of CSS,
I've done the same thing here where

00:52:55.250 --> 00:52:59.430
instead of replacing a chunk of images
I'm just referencing a single SVG file.

00:52:59.760 --> 00:53:01.510
This is Beth's Hawaiian button.

00:53:01.510 --> 00:53:05.020
And you can see that it actually
looks fine at any resolution.

00:53:05.080 --> 00:53:07.700
If I pull up the inspector
-- I might have to make the

00:53:07.700 --> 00:53:09.450
window a little bit bigger.

00:53:09.980 --> 00:53:11.540
So here's my div.

00:53:11.540 --> 00:53:14.990
I'll swap to the style
panel and collapse this one.

00:53:14.990 --> 00:53:17.840
And you can see down here
that my background image

00:53:17.840 --> 00:53:19.370
is just -- let me zoom in.

00:53:19.470 --> 00:53:20.030
Nope.

00:53:20.250 --> 00:53:23.280
You can see the background
image is just one SVG file.

00:53:23.280 --> 00:53:25.490
If I open that SVG file
in its own window,

00:53:25.520 --> 00:53:27.440
it's a little easier to see.

00:53:27.440 --> 00:53:30.710
So the cool thing here is
that the browser or web kit is

00:53:30.840 --> 00:53:33.990
actually deciding what resolution
it needs to draw the image,

00:53:34.040 --> 00:53:37.530
and then creating the size -- you know,
the rectangular array of

00:53:37.530 --> 00:53:41.450
pixels and just rendering the
SVG instructions directly into that.

00:53:42.060 --> 00:53:43.840
Now I can actually edit this file.

00:53:43.840 --> 00:53:46.140
It's pretty easy if
you're familiar with HTML.

00:53:46.140 --> 00:53:51.920
You can see that really this one
image is made up of three rectangles,

00:53:52.010 --> 00:53:52.900
one with a gradient.

00:53:53.130 --> 00:53:57.420
So I can do something like
move my cursor up here.

00:53:57.620 --> 00:53:59.440
And change the-- well, let's do this one.

00:53:59.440 --> 00:54:05.470
Let's change the black stroke
to be something like orange.

00:54:05.470 --> 00:54:05.470
Oops.

00:54:06.170 --> 00:54:09.840
If I could type and save.

00:54:09.940 --> 00:54:13.200
I'll just reload the page here.

00:54:13.260 --> 00:54:14.170
And we've got the orange thing.

00:54:14.300 --> 00:54:15.950
So that's pretty easy.

00:54:16.080 --> 00:54:19.710
So you can see that actually
SVG is a great format to use and

00:54:19.840 --> 00:54:23.740
it's going to apply to a whole
bunch of use cases and you're free

00:54:23.800 --> 00:54:26.380
to use it wherever you need to.

00:54:27.230 --> 00:54:30.100
So, Beth?

00:54:30.100 --> 00:54:34.740
Well, okay, this is pretty cool, Dean.

00:54:34.770 --> 00:54:37.100
But, you know, I just showed everybody
how to build this in CSS,

00:54:37.100 --> 00:54:39.100
so can you, like, do something different?

00:54:39.100 --> 00:54:40.100
Right, okay.

00:54:40.100 --> 00:54:43.090
So what do you have in mind here?

00:54:43.100 --> 00:54:45.100
I don't know, just something with a
little more pizzazz.

00:54:45.100 --> 00:54:46.100
Okay.

00:54:46.100 --> 00:54:47.100
Maybe something wavy.

00:54:47.130 --> 00:54:49.100
Believe it or not,
I have something I prepared earlier.

00:54:51.830 --> 00:54:55.030
So in this case,
I've got a little bit more complex SVG.

00:54:55.380 --> 00:55:00.720
What I'm going to do here
is paste this element in.

00:55:02.400 --> 00:55:39.300
[Transcript missing]

00:55:39.640 --> 00:55:45.000
Okay, so here I've integrated
some SVG right into my HTML.

00:55:45.000 --> 00:55:48.810
So I have an HTML file,
and I'm using an HTML input element,

00:55:48.810 --> 00:55:51.140
and I'm decorating it using SVG.

00:55:51.140 --> 00:55:56.600
So I have this really cool focus
ring that also scales really well,

00:55:56.620 --> 00:55:59.280
and I can type into this file.

00:55:59.280 --> 00:56:06.580
So as I demonstrated,
and Beth also demonstrated,

00:56:06.580 --> 00:56:10.710
that SVG is a great image
format for some cases.

00:56:10.710 --> 00:56:13.020
There are some things
you should be aware of.

00:56:13.230 --> 00:56:16.460
It's not particularly well suited
to when you're going to display

00:56:16.460 --> 00:56:19.140
the image at a very low size,
or very small size,

00:56:19.240 --> 00:56:20.450
or very low resolution.

00:56:20.460 --> 00:56:24.460
And you're probably familiar with this
type of thing when you think back to

00:56:24.460 --> 00:56:29.220
8-bit arcade games where an artist wanted
to have exact control over every pixel.

00:56:29.280 --> 00:56:32.250
And vector artwork doesn't
always give you that.

00:56:32.590 --> 00:56:35.610
Designers often call this sort of like
pixel fitting or something like that.

00:56:35.620 --> 00:56:38.840
But with that aside,
you might find that SVG is a really

00:56:38.840 --> 00:56:42.820
handy image format to use for
all your multi-resolution needs.

00:56:42.840 --> 00:56:43.940
Thank you, Beth.

00:56:44.850 --> 00:56:45.100
Thanks, Dean.

00:56:46.260 --> 00:56:48.800
Okay.

00:56:51.600 --> 00:56:54.420
So you should really consider
some of these image alternatives.

00:56:54.520 --> 00:56:56.010
They're a win on so many fronts.

00:56:56.120 --> 00:57:00.350
You get all of that great retina goodness
that WebKit provides out of the box.

00:57:00.530 --> 00:57:02.940
On top of that,
you'll often use less memory,

00:57:02.960 --> 00:57:07.270
create something that's more accessible,
that's easier to edit down the line.

00:57:07.520 --> 00:57:12.100
It's a great thing to consider
these other technologies.

00:57:12.840 --> 00:57:14.900
Okay, so that's everything
we have for you today.

00:57:14.900 --> 00:57:17.060
I just want to leave you
with a few of our key points.

00:57:17.140 --> 00:57:21.200
Most things on Retina displays
are going to look great as is.

00:57:22.910 --> 00:57:28.000
Images do need a little
bit of special attention,

00:57:28.000 --> 00:57:34.110
and you want to make sure the
number of pixels in your image is

00:57:34.190 --> 00:57:38.600
equal to the number of pixels that
will be available on the device,

00:57:38.600 --> 00:57:38.600
and that's the way you'll
deliver the best experience.

00:57:38.600 --> 00:57:38.600
You want to always give
images a width and a height.

00:57:39.410 --> 00:57:43.240
And finally, remember to consider
those image alternatives.

00:57:43.260 --> 00:57:46.400
I can't wait to see all
of the beautiful websites,

00:57:46.400 --> 00:57:50.780
apps, and digital books that you all
create using these technologies.

00:57:51.190 --> 00:57:54.120
If you have any additional questions,
you can contact our evangelist,

00:57:54.120 --> 00:57:54.900
Vicki Murley.

00:57:54.900 --> 00:57:58.220
There are a number of
related sessions here.

00:57:58.220 --> 00:58:04.050
A couple of them have already happened,
and if you didn't see them,

00:58:04.050 --> 00:58:09.570
I encourage you to check out the
videos when they're released.

00:58:09.570 --> 00:58:11.450
And we still have a few more sessions
later today and tomorrow that

00:58:11.450 --> 00:58:11.450
I strongly encourage you to attend.

00:58:11.450 --> 00:58:11.450
Have a great conference.
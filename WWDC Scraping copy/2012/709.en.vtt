WEBVTT

00:00:10.910 --> 00:00:11.870
Hi.

00:00:12.000 --> 00:00:13.640
Welcome to What's New In The File System.

00:00:13.640 --> 00:00:15.000
I'm Deric Horn.

00:00:15.070 --> 00:00:18.920
I manage the engineering team
that works on the filesystem.

00:00:19.400 --> 00:00:21.810
So today we're going to cover
a whole bunch of small topics

00:00:21.860 --> 00:00:22.890
around the file system.

00:00:23.350 --> 00:00:27.760
Starting with some of the file system
updates with regards to frameworks,

00:00:27.910 --> 00:00:30.420
system architecture,
talk about what some of the

00:00:30.430 --> 00:00:32.760
trends are in the industry,
talk about what some of the

00:00:32.760 --> 00:00:34.520
recent changes are that we've
made to the file system.

00:00:34.620 --> 00:00:36.180
I'm not allowed to talk about
all the changes that we've made

00:00:36.180 --> 00:00:39.280
to the file system because some
of them haven't come out yet.

00:00:39.280 --> 00:00:42.010
Then we'll talk about a number of
best practices that hopefully you

00:00:42.010 --> 00:00:45.140
can take advantage of in your apps
or your tools or your file systems.

00:00:45.140 --> 00:00:47.710
And then we're going to spend the
last part of the section talking about

00:00:47.920 --> 00:00:49.810
FileVault 2 or full disk encryption.

00:00:49.880 --> 00:00:51.880
We'll talk a little bit about what it is.

00:00:51.880 --> 00:00:56.220
And then I'll bring Soren on stage
to talk about exactly how it works.

00:00:57.000 --> 00:01:57.400
[Transcript missing]

00:01:57.800 --> 00:01:59.980
Like I mentioned, it's best to use those
highest level APIs,

00:02:00.120 --> 00:02:02.360
but as you can see,
you're free to use any of those

00:02:02.360 --> 00:02:03.940
APIs all the way down the stack.

00:02:04.110 --> 00:02:07.010
So whether or not you're writing
a Cocoa application or even

00:02:07.010 --> 00:02:10.980
a UIKit-based application,
you're free to use those BSD-based APIs,

00:02:10.980 --> 00:02:13.770
the opens, closes, stats, and so forth.

00:02:13.900 --> 00:02:17.240
So let's talk a little bit about what the
filesystems are or what a filesystem is.

00:02:17.400 --> 00:02:19.040
I think typically when
you look at Mac OS X,

00:02:19.090 --> 00:02:21.930
people think we have one filesystem,
and that's HFS+. But in reality,

00:02:22.010 --> 00:02:24.040
we support six different filesystems.

00:02:24.140 --> 00:02:26.740
So back in Snow Leopard,
we added support for ExFAT.

00:02:26.800 --> 00:02:32.100
If you buy a camera today,
typically they have an SDXC card in them,

00:02:32.100 --> 00:02:35.180
and those cards are high
density and very fast.

00:02:35.290 --> 00:02:37.250
So in order to support those,
we added support in

00:02:37.250 --> 00:02:38.440
Snow Leopard for ExFAT.

00:02:38.490 --> 00:02:41.560
FAT is another interchange format
that we've supported for a long time.

00:02:41.670 --> 00:02:44.960
So if you have friends that are working
at a fast-paced company like the DMV and

00:02:44.960 --> 00:02:47.750
you want to interchange with them,
you could always use a

00:02:47.760 --> 00:02:49.260
thumb drive format as FAT.

00:02:49.530 --> 00:02:50.350
HFS.

00:02:50.460 --> 00:02:52.800
So we actually have two flavors of HFS.

00:02:52.900 --> 00:02:54.470
One that we call HFS standard.

00:02:54.600 --> 00:02:56.740
And this is the really ancient format.

00:02:56.740 --> 00:02:58.730
HFS standard is the
standard of our filesystem.

00:02:58.750 --> 00:03:00.730
HFS standard.

00:03:00.740 --> 00:03:02.740
Back in Lion, we turned it to read only.

00:03:02.740 --> 00:03:04.890
So if you have any floppy
disks and you want to use them,

00:03:04.890 --> 00:03:06.740
we'll still support
them in Mountain Lion,

00:03:06.740 --> 00:03:09.750
but they're going to be read only,
and now we spit a log message

00:03:09.750 --> 00:03:11.730
out that says that HFS standard
has been deprecated.

00:03:11.800 --> 00:03:13.740
HFS+ is our hallmark filesystem.

00:03:13.740 --> 00:03:15.730
It's the one that we use everywhere now.

00:03:15.750 --> 00:03:17.570
So we actually use
journaled HFS+ everywhere.

00:03:17.760 --> 00:03:20.520
The journal means that you can
pull the power at any time,

00:03:20.630 --> 00:03:22.740
and your filesystem is still intact.

00:03:22.740 --> 00:03:24.660
There shouldn't be any data corruption
or any volume corruption on that.

00:03:24.740 --> 00:03:24.740
So that's the standard.

00:03:24.740 --> 00:03:24.740
So we're going to talk about HFS+ now.

00:03:24.740 --> 00:03:24.740
We're going to talk about HFS+ now.

00:03:24.740 --> 00:03:24.740
We're going to talk about HFS+ now.

00:03:25.030 --> 00:03:28.770
volume corruption on that disk.

00:03:28.960 --> 00:03:31.760
Going right along,
we also support NTFS as read-only.

00:03:31.800 --> 00:03:33.890
So that's primarily for boot camp.

00:03:33.980 --> 00:03:35.400
You can go ahead and have
your Windows partition,

00:03:35.400 --> 00:03:37.290
your Mac partition,
be able to read that boot camp

00:03:37.350 --> 00:03:38.900
partition from your Mac partition.

00:03:39.110 --> 00:03:39.580
And UDF.

00:03:39.720 --> 00:03:43.490
We require UDF for DVDs, reads,
and writes.

00:03:45.380 --> 00:03:49.040
So one of the things that's a big
advantage to us is that we support the

00:03:49.070 --> 00:03:51.530
same code base on iOS and Mac OS X.

00:03:51.540 --> 00:03:54.750
And that really has been beneficial
to us by just having a few really good

00:03:54.760 --> 00:03:56.300
engineers working on this code base.

00:03:56.300 --> 00:04:01.040
As we fix bugs on one platform,
they're automatically fixed

00:04:01.040 --> 00:04:01.850
on the other platform.

00:04:01.860 --> 00:04:05.060
Or as we add performance
improvements on one platform,

00:04:05.060 --> 00:04:06.840
the other platform gets
to take advantage of them.

00:04:06.840 --> 00:04:08.460
Like an example of that was Trim.

00:04:08.460 --> 00:04:11.340
Trim is a command that we
can send down to the SSD.

00:04:11.340 --> 00:04:15.680
Basically,
it's a call that lets the SSD know we're

00:04:15.680 --> 00:04:17.030
not going to use these blocks anymore.

00:04:17.160 --> 00:04:18.840
And it can go ahead and do
its own garbage collection,

00:04:18.840 --> 00:04:21.040
its own cleaning,
and actually improve the

00:04:21.190 --> 00:04:22.340
lifespan by doing that.

00:04:22.440 --> 00:04:24.840
And by adding that on one platform,
the other one gets to

00:04:24.850 --> 00:04:26.000
take advantage of it.

00:04:26.250 --> 00:04:29.620
I'd say the one minor difference
between what we support on the desktop

00:04:29.820 --> 00:04:34.250
and the phone is that on the phone
we use what's called a case-sensitive

00:04:34.260 --> 00:04:37.510
version of HFS+. The main reason we
did that is so that we can reduce the

00:04:37.600 --> 00:04:41.070
overall footprint by not carrying around
these case folding tables with us.

00:04:41.200 --> 00:04:43.040
So the phone is case-sensitive.

00:04:43.040 --> 00:04:44.860
The things to keep in
mind about that are,

00:04:44.860 --> 00:04:47.400
for instance,
if you're doing iCloud synchronizations,

00:04:47.400 --> 00:04:49.810
you're working on the same
documents on your phone or your

00:04:49.810 --> 00:04:53.010
iPad as you are on your Mac,
it's perfectly fine to create two

00:04:53.040 --> 00:04:55.330
documents in the same directory
on your iPad that are called

00:04:55.440 --> 00:04:57.850
"hello," one all lowercase,
one all uppercase.

00:04:58.140 --> 00:05:00.660
But if you're going to try and sync
those with your Mac on the other side,

00:05:00.710 --> 00:05:02.140
you're going to have a collision.

00:05:02.200 --> 00:05:05.360
We have case-insensitive
on HFS+ on the Mac.

00:05:05.470 --> 00:05:08.420
The only other place where we
really have case-sensitivity on the

00:05:08.420 --> 00:05:10.110
Mac is on your time machine backups.

00:05:10.340 --> 00:05:12.450
By default,
those are also case-sensitive.

00:05:12.670 --> 00:05:13.440
You're free to use it.

00:05:13.440 --> 00:05:15.310
You're free to format a
drive as case-sensitive,

00:05:15.440 --> 00:05:20.400
but typically coming out of the factory,
they're case-insensitive on the desktops.

00:05:21.710 --> 00:05:25.050
Okay, so that was a little bit about the
filesystem and the frameworks updates,

00:05:25.110 --> 00:05:27.260
what they are,
just to give you a brief overview.

00:05:27.360 --> 00:05:28.530
Now I'm going to talk
about some of the more,

00:05:28.620 --> 00:05:30.850
I think, more interesting parts,
some of the storage industry trends.

00:05:30.860 --> 00:05:33.870
So not necessarily what
we're doing at Apple,

00:05:33.870 --> 00:05:37.020
but some of the trends that
we see across the industry.

00:05:37.160 --> 00:05:39.890
The first one that you've seen
is that machines are moving

00:05:39.900 --> 00:05:44.100
away from your typical spinning
hard drives and towards SSDs.

00:05:44.230 --> 00:05:47.840
And this is, I think, kind of a -- well,
it's kind of a pun -- but kind

00:05:47.840 --> 00:05:49.980
of a revolutionary change that
we're seeing in the industry.

00:05:50.100 --> 00:05:52.870
I mean,
I think about every 12 to 14 months,

00:05:52.940 --> 00:05:54.900
the speed of these SSDs is doubling.

00:05:55.100 --> 00:05:56.100
So it's really incredible.

00:05:56.100 --> 00:05:58.100
Where the speed of your
processor isn't doubling,

00:05:58.130 --> 00:06:00.100
we're really making
huge improvements here.

00:06:00.210 --> 00:06:03.100
And that contributes to the overall
performance of your machine,

00:06:03.100 --> 00:06:06.280
especially as you page
in and out of these SSDs.

00:06:06.560 --> 00:06:10.590
Something you see across the industry
is these SSDs are slowly moving over

00:06:10.680 --> 00:06:15.760
towards a PCI-based controller rather
than SATA bus for better performance.

00:06:15.760 --> 00:06:18.820
One of the two biggest
advantages I see to SSDs is

00:06:18.820 --> 00:06:20.740
for the random I/O performance.

00:06:20.740 --> 00:06:25.290
Random I/O on SSDs is about 100 times
faster than what you get on a hard drive.

00:06:25.290 --> 00:06:28.480
But the thing that's hard for me
to completely wrap my mind against,

00:06:28.490 --> 00:06:31.530
maybe it's because I come from software,
is that although they look like

00:06:31.590 --> 00:06:33.980
they're doing a lot better,
we're getting a lot faster,

00:06:33.980 --> 00:06:36.540
for some reason,
the write cycles are going down.

00:06:36.540 --> 00:06:39.320
So that means as you write
to the same area of this SSD,

00:06:39.320 --> 00:06:41.900
it will start to -- I don't know what
the right word is -- disintegrate.

00:06:41.900 --> 00:06:43.720
It will start to go bad.

00:06:43.720 --> 00:06:46.800
So they're coming up to a place
now where you can only write

00:06:46.800 --> 00:06:50.350
to this particular cell on an
SSD 3,000 times before it goes bad.

00:06:50.440 --> 00:06:52.760
So behind the scenes we do
a lot of shuffling around.

00:06:52.850 --> 00:06:54.550
So if you think you're writing
in the same area of the SSD,

00:06:54.570 --> 00:06:57.050
they're actually moving this around,
waving their hands around so it's

00:06:57.050 --> 00:06:58.830
actually getting spread across the disk.

00:06:59.000 --> 00:07:02.560
But that's one interesting thing
and a concern that we have and we're

00:07:02.560 --> 00:07:04.580
trying to improve on that as well.

00:07:04.580 --> 00:07:06.220
There's also security concerns.

00:07:06.250 --> 00:07:09.020
Like I mentioned,
if I write to one block on an SSD,

00:07:09.030 --> 00:07:10.860
behind the scenes it's
actually moving that around.

00:07:10.860 --> 00:07:13.240
So if I think that I've written
some critical data here and I go

00:07:13.240 --> 00:07:16.240
to do a clean wipe on writing
zeros all over that block again,

00:07:16.360 --> 00:07:19.970
I may think I've erased that from my SSD,
but you might have a grad student

00:07:20.040 --> 00:07:22.710
somewhere that hooks up their
thesis project and they're able

00:07:22.710 --> 00:07:25.370
to read directly from these SSDs,
they can actually find out that this

00:07:25.370 --> 00:07:28.960
has been moved to several other blocks
in the SSD and pull the data out.

00:07:29.080 --> 00:07:31.360
So several interesting areas
revolving around SSDs that we

00:07:31.370 --> 00:07:32.570
have to take into consideration.

00:07:32.580 --> 00:07:33.620
And lastly,
they're also more expensive than that.

00:07:33.620 --> 00:07:33.620
So I think that's a really good point.

00:07:33.850 --> 00:07:36.410
They're also more
expensive than hard drives.

00:07:36.600 --> 00:07:39.260
So what does that mean to
filesystems and what we're doing?

00:07:39.380 --> 00:07:42.070
I think first off,
with that fast random I/O,

00:07:42.300 --> 00:07:45.660
that kind of opens up a lot
more opportunity for us.

00:07:45.770 --> 00:07:48.580
It makes it more -- it adds a lot more
flexibility in the design decisions

00:07:48.580 --> 00:07:50.260
that we're going to make going forward.

00:07:50.300 --> 00:07:52.870
If we don't have to worry about
defragmentation so much or

00:07:52.870 --> 00:07:55.720
keeping those files and those
data structures contiguous,

00:07:55.820 --> 00:07:58.560
it allows us some more opportunity.

00:07:58.690 --> 00:08:01.710
Also, because it's trending towards,
as I mentioned, these fewer write cycles,

00:08:01.710 --> 00:08:03.060
we have to be cognizant of that.

00:08:03.160 --> 00:08:06.350
One way that we do that is now we
start to send those trim commands down.

00:08:06.470 --> 00:08:09.300
By having the filesystem send
a trim command down to the SSD,

00:08:09.400 --> 00:08:11.730
that lets that SSD know that
I'm not going to be using

00:08:11.730 --> 00:08:13.600
this area of your SSD anymore.

00:08:13.940 --> 00:08:16.720
You are free to go ahead
and assume that it's empty.

00:08:16.720 --> 00:08:18.060
You don't have to move
these blocks around.

00:08:18.060 --> 00:08:19.620
You don't have to
shuffle anything around.

00:08:19.750 --> 00:08:24.240
So it actually improves the lifespan of
your SSD and actually makes it faster.

00:08:24.470 --> 00:08:26.780
and I think the one thing
you can take away from this,

00:08:26.780 --> 00:08:30.340
whether you're working on an SSD,
whatever your application is,

00:08:30.480 --> 00:08:33.310
or a hard drive,
large sequential writes are always

00:08:33.310 --> 00:08:35.640
better than a lot of small random writes.

00:08:35.640 --> 00:08:38.150
You're always going to
get better performance.

00:08:39.610 --> 00:08:42.090
Another trend that we see
is in distributed storage.

00:08:42.090 --> 00:08:46.580
Kind of what we've seen over the
last couple of years is that our

00:08:46.580 --> 00:08:47.820
data is getting bigger and bigger.

00:08:47.820 --> 00:08:50.860
We're taking more digital photos,
have more music and so forth.

00:08:50.860 --> 00:08:54.250
But the devices that we use,
they're still relatively small.

00:08:54.250 --> 00:08:57.090
I mean, our phones are now at most
around 64 gigabytes or so.

00:08:57.120 --> 00:08:59.010
So that's a small window into our data.

00:08:59.010 --> 00:09:02.090
So what we're going to see a lot
more of is more distributed storage.

00:09:02.140 --> 00:09:06.170
And that means that I'm going to see
a window of my data on my iPad or

00:09:06.280 --> 00:09:08.030
my iPhone or even my MacBook Air.

00:09:08.350 --> 00:09:10.930
And as I need to reference
those songs or those pictures,

00:09:10.930 --> 00:09:13.700
they'll start to come
down from the cloud.

00:09:13.700 --> 00:09:16.830
Something else we see is that users
are getting more devices more often.

00:09:16.870 --> 00:09:20.140
So we have to take into
consideration backup,

00:09:20.140 --> 00:09:22.040
restore and migration.

00:09:22.040 --> 00:09:25.190
And when we store things in the cloud,
we always have to recognize that we

00:09:25.190 --> 00:09:30.630
have to be cognizant of secure backups,
efficient backups and also deduplication.

00:09:30.630 --> 00:09:34.110
That's kind of a fancy term for
meaning if we all own the same song,

00:09:34.110 --> 00:09:37.180
up in the cloud we only have to keep
one of those songs and let you all know.

00:09:37.180 --> 00:09:39.420
note, and then when you reference it,
you'll have access to that song.

00:09:42.130 --> 00:09:47.000
Okay, so that was a little bit about the
storage industry trends as a whole.

00:09:47.060 --> 00:09:48.630
Now I'll talk about some of
the recent changes that we've

00:09:48.630 --> 00:09:50.890
been making in the filesystem.

00:09:53.870 --> 00:09:55.460
So the first one,
this was actually introduced

00:09:55.460 --> 00:09:57.440
back in Mac OS 10.4,
but I just wanted to let

00:09:57.440 --> 00:09:58.770
everybody know about it.

00:09:58.780 --> 00:10:00.650
This is kind of one of those little
nuggets if you're looking for -- if

00:10:00.750 --> 00:10:04.850
you have a certain problem and this
might present a solution for you.

00:10:04.960 --> 00:10:06.590
And it's extended attributes.

00:10:06.590 --> 00:10:09.860
I don't think this is used
nearly enough by developers.

00:10:09.860 --> 00:10:12.360
Extended attributes are a way of
leaving like little breadcrumbs

00:10:12.360 --> 00:10:13.510
of data behind on a file.

00:10:13.510 --> 00:10:15.900
So if you're sharing a file
between different applications,

00:10:15.920 --> 00:10:16.690
maybe it's a PDF file.

00:10:16.780 --> 00:10:18.810
So you have many applications
that can open this up.

00:10:18.810 --> 00:10:20.910
And you want to leave a little
breadcrumb along that said,

00:10:20.910 --> 00:10:23.690
like, for instance,
you're the author of it or my

00:10:23.690 --> 00:10:25.610
application touched this last.

00:10:25.840 --> 00:10:28.660
But I don't want to interfere with
the format of that file itself.

00:10:28.660 --> 00:10:31.580
You can attach an
extended attribute to it.

00:10:31.580 --> 00:10:33.440
We have a pretty simple API set.

00:10:33.440 --> 00:10:34.800
It's just really four of them.

00:10:34.800 --> 00:10:37.390
That's all you need to be able
to get an extended attribute,

00:10:37.410 --> 00:10:40.450
set an extended attribute,
list them to see which ones are

00:10:40.860 --> 00:10:42.950
there or if you want to remove one.

00:10:43.360 --> 00:10:47.230
In the terminal, if you type in LS minus
L with the at sign,

00:10:47.230 --> 00:10:51.740
that at sign specifies list
out all my extended attributes.

00:10:51.740 --> 00:10:54.300
So I did this on some of my files.

00:10:54.300 --> 00:10:59.140
And you can see typically you're going
to store 32 bytes of finder info.

00:10:59.150 --> 00:11:02.470
That's going to contain some
things like the label that

00:11:02.470 --> 00:11:04.430
you have attached to the file.

00:11:04.430 --> 00:11:07.170
On mine,
I think I listed off my tax filing.

00:11:07.180 --> 00:11:10.520
So you can see Intuit attaches a
little breadcrumb on there that

00:11:10.520 --> 00:11:10.520
talks about my filing status.

00:11:11.190 --> 00:11:14.340
and in the past, before Lion,
extended attributes

00:11:15.090 --> 00:11:17.060
were limited to only 4K.

00:11:17.060 --> 00:11:19.100
So I think that's one of the reasons why
they didn't get a whole lot of adoption.

00:11:19.240 --> 00:11:22.330
It's hard to find what you
want to store in under 4K.

00:11:22.460 --> 00:11:25.040
So starting in Lion,
we increased the size of our

00:11:25.040 --> 00:11:27.220
extended attributes to be 128K.

00:11:27.750 --> 00:11:29.430
I want to give a little
bit of guidelines,

00:11:29.540 --> 00:11:31.720
some pros and cons of using
the extended attributes,

00:11:31.760 --> 00:11:33.690
the guidelines when you should use them.

00:11:33.750 --> 00:11:36.550
I think that they're ideal for
storing those little bits of metadata

00:11:36.550 --> 00:11:40.140
or what I call those breadcrumbs,
things like author, the window position,

00:11:40.140 --> 00:11:42.860
the window rectangle,
the history of this file.

00:11:42.990 --> 00:11:46.250
You can even attach extended
attributes onto directories.

00:11:46.660 --> 00:11:48.880
But kind of the one con of them,
or the one thing to be aware of,

00:11:48.880 --> 00:11:52.460
is I wouldn't recommend you
storing application critical

00:11:52.540 --> 00:11:54.720
data in extended attributes.

00:11:55.070 --> 00:11:58.450
I think application critical
data should always be stored

00:11:58.450 --> 00:12:00.360
in the data fork of your file.

00:12:00.360 --> 00:12:03.180
The reason being is we live in a kind of
a heterogeneous environment where we're

00:12:03.240 --> 00:12:06.420
copying files around across the web,
uploading them into Safari,

00:12:06.530 --> 00:12:07.640
across different people's machines.

00:12:07.680 --> 00:12:11.660
And as you do that,
not all different file transfer

00:12:11.660 --> 00:12:15.750
protocols or volume formats
support extended attributes.

00:12:15.860 --> 00:12:18.170
So as we move them around,
we actually have to split

00:12:18.170 --> 00:12:19.350
them off into two files.

00:12:19.480 --> 00:12:21.400
And if at any point we
lose one of those files,

00:12:21.400 --> 00:12:23.600
the file containing all
that extra information,

00:12:23.900 --> 00:12:26.570
what I call these dot underbar files,
you then lose all of

00:12:26.570 --> 00:12:27.970
your extended attributes.

00:12:28.100 --> 00:12:29.880
You know,
if another application opens up this file

00:12:29.920 --> 00:12:32.780
that you're working on and it decides to
rip out all those extended attributes,

00:12:32.910 --> 00:12:33.660
you can lose them.

00:12:33.750 --> 00:12:36.410
So I think it's perfect for storing
little bits of metadata around that

00:12:36.410 --> 00:12:39.890
make the user experience better,
but I wouldn't store your critical

00:12:39.890 --> 00:12:41.790
data as an extended attribute.

00:12:41.930 --> 00:12:44.320
And kind of last note on here,
just to take note,

00:12:44.320 --> 00:12:47.120
is that if you store a small
bit of metadata under 4K,

00:12:47.230 --> 00:12:49.320
we actually pack those
into the attributes B-tree.

00:12:49.320 --> 00:12:52.050
So we don't even allocate a
full allocation block on disk.

00:12:52.070 --> 00:12:55.730
If you want to store a couple bytes,
we only allocate a couple bytes

00:12:55.730 --> 00:12:57.390
to store that information.

00:12:58.680 --> 00:13:01.830
So I want to talk about a couple
of API sets that we've deprecated

00:13:01.840 --> 00:13:03.390
and what the replacements are.

00:13:03.440 --> 00:13:04.940
So these are some other recent changes.

00:13:05.060 --> 00:13:08.800
So starting in Mountain Lion,
the way that you mount

00:13:08.800 --> 00:13:11.960
servers has been changed,
and basically it's been modernized.

00:13:12.010 --> 00:13:15.360
We've replaced the option bits
with more modern dictionaries.

00:13:15.390 --> 00:13:19.970
We've replaced the CF run loops with
more modern GCD dispatch queues.

00:13:20.070 --> 00:13:23.660
So we have the FSMountServerVolumeSync,
which used to take option bits,

00:13:23.800 --> 00:13:24.700
now takes a dictionary.

00:13:24.760 --> 00:13:27.910
What used to take a run loop
now takes a dispatch queue.

00:13:29.400 --> 00:13:34.060
Another API set, just a drill at home,
is the file manager has been deprecated.

00:13:34.060 --> 00:13:36.340
And this is what I said is the
old Carbon file manager or old

00:13:36.410 --> 00:13:37.770
core services file manager.

00:13:37.910 --> 00:13:39.850
So when you used to get
metadata about files,

00:13:39.990 --> 00:13:42.640
you used to call something
called like FS get catalog info

00:13:42.780 --> 00:13:44.800
or FS get catalog info bulk.

00:13:44.890 --> 00:13:47.130
And when you call this on a file,
you're going to go ahead and get,

00:13:47.160 --> 00:13:50.070
for instance, the name of the file,
the modification date,

00:13:50.160 --> 00:13:53.300
the creation dates, and a bunch of other
metadata associated with it.

00:13:53.340 --> 00:13:57.920
Those have been replaced by
more modern property-based APIs,

00:13:57.920 --> 00:14:01.680
so the CF copy resource
properties for keys API.

00:14:01.820 --> 00:14:05.860
and also to note that those newer
APIs are available on iOS where the old

00:14:05.860 --> 00:14:07.940
file manager calls aren't available.

00:14:09.870 --> 00:14:11.470
So those are some of the recent changes.

00:14:11.520 --> 00:14:14.540
Now I'd like to talk about some of
the best practices and kind of some

00:14:14.540 --> 00:14:18.610
tips for you when you're trying to
eke out the best performance from your

00:14:18.620 --> 00:14:20.870
application or out of the filesystem.

00:14:22.150 --> 00:14:23.300
Throttled IO.

00:14:23.350 --> 00:14:27.800
So sometimes in your application you
want to do something in the background.

00:14:27.800 --> 00:14:30.340
You don't want it to interfere with
what the user is currently doing.

00:14:30.340 --> 00:14:34.540
You don't want to interfere with the user
experience that's going on right now.

00:14:34.540 --> 00:14:39.080
So if I'm writing an application that
has some sophisticated workflow to it

00:14:39.080 --> 00:14:43.260
and I'm manipulating some data right
now and at the same time maybe I want

00:14:43.370 --> 00:14:46.630
to create backups of that document,
I probably want to create those

00:14:46.710 --> 00:14:47.600
backups in the background.

00:14:47.600 --> 00:14:50.030
I don't want it to interfere with
what the user is currently doing now.

00:14:50.100 --> 00:14:54.280
So one way to do that is to say I want
to do this in a throttled IO way.

00:14:54.280 --> 00:14:56.590
This means that when the user
has their hands off the keyboard,

00:14:56.590 --> 00:14:59.300
I can create those, I can go ahead and
compress those backups,

00:14:59.440 --> 00:15:01.640
move them off to the side
and so forth at full speed,

00:15:01.640 --> 00:15:03.680
but when they're using the
computer and they're using data,

00:15:03.680 --> 00:15:06.730
reading in new data,
I want to kind of throttle that back.

00:15:06.730 --> 00:15:09.780
And that's what we call throttled IO.

00:15:09.780 --> 00:15:11.950
Typically on the system today we
use that in a number of places.

00:15:11.960 --> 00:15:15.050
You'll see it in, for instance,
spotlight, time machine backups,

00:15:15.480 --> 00:15:16.270
background encryption.

00:15:16.270 --> 00:15:18.780
So, for instance,
if you turn on full disk encryption,

00:15:18.780 --> 00:15:22.140
if you turn on -- If you're
not using your machine,

00:15:22.140 --> 00:15:24.910
we will go ahead and encrypt those
blocks as fast as we possibly can.

00:15:24.910 --> 00:15:27.440
But as soon as you put your hands on the
machine and start copying files around,

00:15:27.610 --> 00:15:30.240
we scale it way back and
start moving very slow.

00:15:30.280 --> 00:15:31.760
That's what throttled IO is.

00:15:31.760 --> 00:15:34.700
So if you have a need to do something
in the background or throttle your IO,

00:15:34.700 --> 00:15:38.820
the best way to do that, I would say,
is to use the grand central dispatch

00:15:39.070 --> 00:15:40.970
IO background queue mechanism.

00:15:40.970 --> 00:15:43.390
Any IO that you do on the
background queue will automatically

00:15:43.390 --> 00:15:45.900
be marked as throttled.

00:15:45.900 --> 00:15:49.160
The next topic I want to talk about
is kind of what I call playing nicely.

00:15:49.160 --> 00:15:51.220
Playing nicely with others.

00:15:51.220 --> 00:15:53.320
Memory on your system
is a shared resource.

00:15:53.320 --> 00:15:54.560
We have a small amount of memory.

00:15:54.560 --> 00:15:56.560
Maybe we have four gigabytes
of memory on your system.

00:15:56.560 --> 00:15:58.140
And we have a large drive.

00:15:58.230 --> 00:16:02.210
So every application, VM and so forth,
is vying to use that

00:16:02.210 --> 00:16:03.950
memory on that system.

00:16:04.010 --> 00:16:05.620
You're paging in and out from memory.

00:16:05.750 --> 00:16:08.870
When you read blocks off the disk,
they're being stored in memory.

00:16:08.880 --> 00:16:12.300
So you don't want to be a bad citizen
and blow everybody else's cash.

00:16:12.950 --> 00:16:13.380
Right?

00:16:13.380 --> 00:16:16.740
Kind of what I mean by that is if
I have a number of applications,

00:16:16.790 --> 00:16:18.830
they're all reading and
writing their files.

00:16:18.980 --> 00:16:21.020
But what really happens is
they've got a large amount

00:16:21.020 --> 00:16:23.060
of reads and writes going on,
but most of those are

00:16:23.060 --> 00:16:26.020
already held in the cache,
in the universal buffer cache.

00:16:26.020 --> 00:16:28.920
So we actually have to do very
little IO down to the disk.

00:16:28.920 --> 00:16:32.620
This becomes very important,
especially if you have a slow disk.

00:16:32.620 --> 00:16:34.070
This is what it usually looks like.

00:16:34.130 --> 00:16:36.890
Now, if I've just written my first
application and I want to read a large

00:16:37.030 --> 00:16:39.460
file to play my own type of a movie,
for instance,

00:16:39.460 --> 00:16:42.410
I come along and I say I want
to read four gigabytes.

00:16:42.440 --> 00:16:44.960
Next thing you know,
it reads four gigabytes and it fills up

00:16:44.990 --> 00:16:47.080
my whole cache and blows everybody out.

00:16:48.000 --> 00:16:49.310
So that's kind of a bad citizen.

00:16:49.400 --> 00:16:51.000
That's what you don't want to do.

00:16:51.000 --> 00:16:54.060
Then when those applications go
ahead and become active again,

00:16:54.060 --> 00:16:56.000
they want to go ahead and
access their files again,

00:16:56.100 --> 00:16:58.000
and they have to do a lot
of I/O down to the disk,

00:16:58.000 --> 00:16:59.000
and they blow you out of the cache now.

00:16:59.000 --> 00:17:01.340
So what you're doing is creating
this pattern of everyone's

00:17:01.430 --> 00:17:06.110
just thrashing on memory,
on the universal buffer cache.

00:17:06.970 --> 00:17:09.840
So that's where the F no
cache bit comes along.

00:17:09.910 --> 00:17:11.610
For I/O that you're
only going to read once,

00:17:11.800 --> 00:17:15.740
especially large I/O,
it's best to mark it as F no cache.

00:17:15.740 --> 00:17:17.000
This would be being a good citizen.

00:17:17.000 --> 00:17:20.400
That means I want to read this data,
but don't put it in the cache.

00:17:20.400 --> 00:17:24.160
Don't use up all those
extra buffers in the cache.

00:17:24.260 --> 00:17:26.660
I'm not going to read it again.

00:17:26.820 --> 00:17:31.090
So if you mark your I/O as F no cache,
that same application

00:17:31.160 --> 00:17:33.200
reads it right from disk,
and everybody's happy.

00:17:33.200 --> 00:17:33.200
So that's F no cache.

00:17:33.920 --> 00:17:36.650
Next performance tip,
kind of like Costco,

00:17:36.650 --> 00:17:40.370
you're always going to get a
better deal if you buy in bulk.

00:17:40.370 --> 00:17:43.830
And the better performance that you get,
the better battery life

00:17:43.830 --> 00:17:44.900
you're also going to get.

00:17:44.910 --> 00:17:46.560
That's just a general rule of thumb.

00:17:46.560 --> 00:17:49.010
If you're going to go, for instance,
buy six bottles of wine,

00:17:49.040 --> 00:17:52.040
you don't make six trips to the store,
you make one trip,

00:17:52.200 --> 00:17:55.300
you buy the six bottles
and you get your discount.

00:17:55.440 --> 00:17:58.320
Here are a few APIs to use if
you're going to go ahead and

00:17:58.390 --> 00:17:59.720
try to get a lot of information.

00:17:59.720 --> 00:18:01.740
Same thing,
you don't want to iterate through

00:18:01.740 --> 00:18:04.140
a bunch of files in the directory
getting information about them.

00:18:04.140 --> 00:18:06.340
You want to get it

00:18:07.010 --> 00:18:10.880
So the first one from the
application perspective is searching.

00:18:11.000 --> 00:18:12.860
So this is kind of related to Spotlight.

00:18:12.860 --> 00:18:15.640
The NSSearch field is typically
that field that you see at the

00:18:15.640 --> 00:18:18.940
top of Windows that's kind of that
oval with a magnifying glass in it.

00:18:19.030 --> 00:18:20.660
That's your NSSearch field.

00:18:20.710 --> 00:18:25.800
And the way it typically works is
through the NSMetadataQuery APIs.

00:18:25.860 --> 00:18:29.290
Those link down into
your Spotlight database.

00:18:29.410 --> 00:18:32.820
So the way that works is you
build up what's called a bunch

00:18:32.820 --> 00:18:37.540
of predicates if you're writing a
UI kit or app kit-based application.

00:18:37.600 --> 00:18:40.510
Basically, you would say, for instance,
you build up your predicates.

00:18:40.600 --> 00:18:42.860
So you say,
show me all presentations that

00:18:42.860 --> 00:18:46.080
I've created in the last week
that are over five megabytes.

00:18:46.120 --> 00:18:47.480
So you create these three predicates.

00:18:47.560 --> 00:18:50.690
You hook them to your NSMetadataQuery,
and it will just go ahead and

00:18:50.840 --> 00:18:54.000
return back everything in bulk for
you for you to iterate through.

00:18:54.390 --> 00:18:58.130
The other topic I want to talk about
is filesystem notification changes.

00:18:58.160 --> 00:19:01.440
So this is a very powerful
concept called FSEvents.

00:19:01.810 --> 00:19:04.390
We always get requests that say
how do I tell if a file has changed

00:19:04.470 --> 00:19:05.900
somewhere in the filesystem?

00:19:05.900 --> 00:19:08.240
I want to see this and I want to
know when this file has changed.

00:19:08.480 --> 00:19:09.890
Maybe it's in the directory,
maybe it's anywhere on

00:19:09.890 --> 00:19:10.720
the whole filesystem.

00:19:11.540 --> 00:19:14.710
And the best way to do
that is with FSEvents.

00:19:15.660 --> 00:19:18.530
FS events work in two different ways.

00:19:18.670 --> 00:19:23.550
You can either pull for those events or
else you can have them delivered to you.

00:19:23.630 --> 00:19:26.170
So the two ways that we
use them in the system,

00:19:26.210 --> 00:19:28.680
for instance,
one of them is in Time Machine.

00:19:28.750 --> 00:19:31.670
So every hour
Time Machine runs and it says,

00:19:31.870 --> 00:19:34.620
I want to know about all the
filesystem changes that have

00:19:34.620 --> 00:19:36.460
happened in the last hour.

00:19:36.520 --> 00:19:40.170
So it runs and we go ahead and
return back this big long list.

00:19:40.720 --> 00:19:42.950
Now, kind of to talk a little bit
about the history of that,

00:19:43.080 --> 00:19:45.660
before Lion, that big long list was
just a list of directories,

00:19:45.670 --> 00:19:47.400
and it was up to Time Machine to
figure out which one of those

00:19:47.540 --> 00:19:48.540
files in the directory has changed.

00:19:48.540 --> 00:19:51.700
Now, with Lion and later, when it says,
tell me all the filesystem changes

00:19:51.700 --> 00:19:54.310
that have happened in the last hour,
we actually return back a long

00:19:54.310 --> 00:19:56.230
list of every file that's changed.

00:19:56.240 --> 00:20:00.000
It then goes ahead and says,
I want to back up just these files.

00:20:00.000 --> 00:20:02.280
It doesn't have to iterate through
every single file in the source,

00:20:02.280 --> 00:20:05.020
every single file in your directory
and figure out which ones have changed.

00:20:05.020 --> 00:20:06.560
It just asks for the changes.

00:20:06.560 --> 00:20:09.120
So that's the polling method.

00:20:09.570 --> 00:20:12.590
Give me all the things that
have changed in the last hour.

00:20:13.020 --> 00:20:16.060
The push method, for instance,
would be where the finder comes in.

00:20:16.060 --> 00:20:20.090
So when you have a finder window open,
the finder has FSEvents

00:20:20.160 --> 00:20:20.990
on that directory.

00:20:21.160 --> 00:20:22.920
So if, for instance,
someone else on a different

00:20:22.990 --> 00:20:26.540
computer copies something into
that directory or creates a file,

00:20:26.590 --> 00:20:29.290
FSEvents then says, hey, look,
I've created this new file,

00:20:29.630 --> 00:20:31.700
finder gets a notification,
and it draws the icon.

00:20:31.950 --> 00:20:34.320
So it works in two
different methods there,

00:20:34.320 --> 00:20:35.680
either pull or push.

00:20:36.960 --> 00:20:38.970
And the last one also is
kind of goes along with the

00:20:39.070 --> 00:20:42.140
first one with the searching,
is if you want to get a bunch of

00:20:42.140 --> 00:20:43.780
metadata at one time about files.

00:20:43.800 --> 00:20:44.800
People typically do this.

00:20:44.800 --> 00:20:47.800
They look through directories worth
of files to look for the metadata.

00:20:47.800 --> 00:20:50.720
You can use those URL-based
APIs that I mentioned earlier.

00:20:50.790 --> 00:20:52.800
And those are all bulk-based.

00:20:52.800 --> 00:20:55.210
So once you get the results,
you create an enumerator and just

00:20:55.320 --> 00:20:56.800
enumerate through all the results.

00:20:59.730 --> 00:21:02.550
Okay, this is one of my favorite ones.

00:21:02.860 --> 00:21:06.250
If you've ever seen this
before in your application,

00:21:06.680 --> 00:21:07.600
You know, it's not a good sign.

00:21:07.600 --> 00:21:10.770
And there's only really one
reason why you'll ever see what we

00:21:10.800 --> 00:21:12.680
call a spod on your application.

00:21:12.690 --> 00:21:15.750
And the only reason you ever see
this is if you haven't serviced your

00:21:15.750 --> 00:21:17.580
event queue in the last two seconds.

00:21:17.580 --> 00:21:20.930
So that means basically you haven't
checked to see if there's something

00:21:20.940 --> 00:21:22.580
new for you off the event queue.

00:21:23.680 --> 00:21:26.250
This is almost maybe selfish,
but my engineers get tons of these

00:21:26.250 --> 00:21:28.990
bugs all the time where it says,
you know, the filesystem's broken,

00:21:28.990 --> 00:21:30.930
I was doing something,
and I see the spinning cursor,

00:21:30.930 --> 00:21:32.860
and my engineers spend all
sorts of time looking at it,

00:21:32.860 --> 00:21:34.460
and they go, well, it's not broken.

00:21:34.460 --> 00:21:36.680
You know, maybe we're just waiting
for your disk to spin up.

00:21:36.680 --> 00:21:38.530
With some computers,
it takes up to 10 seconds

00:21:38.530 --> 00:21:39.740
for these disks to spin up.

00:21:39.810 --> 00:21:41.390
You're on your main
thread trying to do UI,

00:21:41.390 --> 00:21:42.990
and we're waiting for
this disk to spin up,

00:21:42.990 --> 00:21:44.760
and someone thinks it's a filesystem bug.

00:21:44.760 --> 00:21:45.570
It's not a filesystem bug.

00:21:45.580 --> 00:21:49.690
I think the crux of this is that you
have to be able to expect large latencies

00:21:49.690 --> 00:21:52.020
from whenever you're getting files.

00:21:52.030 --> 00:21:54.960
Whether you're trying to get information
from a file across a network or

00:21:54.970 --> 00:21:58.110
a hard drive that's spun down,
this could happen.

00:21:58.210 --> 00:22:01.600
So what you should always do is
get your UI -- or excuse me --

00:22:01.670 --> 00:22:03.820
get your I/O off the main thread.

00:22:03.820 --> 00:22:06.150
There's a number of
different ways to do this.

00:22:06.410 --> 00:22:08.920
You can do it through
Grand Central Dispatch to create

00:22:08.920 --> 00:22:11.960
another thread to do that,
NSOperation is built on top of GCD,

00:22:11.960 --> 00:22:12.940
that's another way.

00:22:12.940 --> 00:22:16.190
There's also a method called, like,
perform selector on thread.

00:22:16.270 --> 00:22:19.460
That's probably the easiest way to
get your I/O off your main thread.

00:22:19.790 --> 00:22:23.390
Your main thread or your UI thread should
really only be used for two things,

00:22:23.390 --> 00:22:27.340
and that's to pull events off
the queue and to update your UI.

00:22:27.820 --> 00:22:30.990
Otherwise,
you're susceptible to getting your spots.

00:22:31.760 --> 00:22:35.190
I just want to talk a little bit
about the NS File Coordinator.

00:22:35.260 --> 00:22:37.840
If you're working with iCloud,
you're going to have

00:22:37.840 --> 00:22:39.500
some contact with this.

00:22:39.720 --> 00:22:44.780
The NS File Coordinator basically
serializes access to a file.

00:22:45.180 --> 00:22:46.810
This becomes important because,
for instance,

00:22:46.870 --> 00:22:50.060
if I'm writing an application like Pages,
I'm updating a file.

00:22:50.080 --> 00:22:52.170
And this file is going to get
synchronized to the cloud.

00:22:52.300 --> 00:22:54.710
So while my process, Pages,
is updating this file,

00:22:54.820 --> 00:22:58.920
I have another process that's called
the iCloud daemon that's trying to read

00:22:59.020 --> 00:23:00.640
this file and upload it to the cloud.

00:23:00.670 --> 00:23:03.970
Or possibly it sees a newer version of
that file and it's trying to download it

00:23:03.970 --> 00:23:06.280
from the cloud back down onto my disk.

00:23:06.400 --> 00:23:08.340
So we have to serialize
the access to this file.

00:23:08.340 --> 00:23:10.690
And we do that through
the NS file coordinator.

00:23:10.860 --> 00:23:15.920
So if you create a file presenter,
that basically means let me know when

00:23:15.920 --> 00:23:18.480
there's been a change to that file.

00:23:18.580 --> 00:23:21.340
So to put this in context,
if I'm Pages and I have this

00:23:21.340 --> 00:23:23.920
beautiful document up here and
I'm working with someone else,

00:23:23.950 --> 00:23:25.990
and I have a picture
up here in the corner,

00:23:26.120 --> 00:23:27.680
someone else may update that picture.

00:23:27.680 --> 00:23:29.450
When they do that,
I'm going to get called

00:23:29.550 --> 00:23:31.760
through my file presenter and
says there's been an update.

00:23:31.780 --> 00:23:34.870
Now it's my responsibility in my
application to go ahead and throw away,

00:23:34.990 --> 00:23:36.850
to deallocate everything
I've had with that file,

00:23:36.930 --> 00:23:39.530
read it off disk again,
and update all those data structures

00:23:39.640 --> 00:23:41.140
again so I get the new picture.

00:23:41.170 --> 00:23:43.760
If you don't use this method,
you're going to be fighting each other.

00:23:43.760 --> 00:23:45.900
You're both going to be saving
changes over each other.

00:23:45.930 --> 00:23:49.560
So the coordinator helps you coordinate
changes from multiple sources.

00:23:49.610 --> 00:23:51.980
Also, again, if you're using
UI document or NS document,

00:23:52.020 --> 00:23:53.420
you get a lot of this for free.

00:23:53.630 --> 00:23:57.410
It automatically takes care of
the file coordination for you.

00:24:01.040 --> 00:24:03.520
Okay, so this one,
now I'm slowly getting a

00:24:03.530 --> 00:24:04.240
little bit more technical.

00:24:04.240 --> 00:24:05.840
This is one of my favorite tools.

00:24:05.900 --> 00:24:09.570
There's two ways to analyze
performance of your filesystem.

00:24:09.890 --> 00:24:12.490
You can do it through instruments
and instruments will call the

00:24:12.520 --> 00:24:15.960
tool FSUsage or you can go right
to the terminal and call FSUsage.

00:24:15.990 --> 00:24:17.290
I'm just curious,
how many of you out there

00:24:17.290 --> 00:24:18.190
have ever run FSUsage?

00:24:18.220 --> 00:24:18.950
Great.

00:24:19.300 --> 00:24:19.920
Okay.

00:24:20.330 --> 00:24:20.870
Great.

00:24:21.260 --> 00:24:22.190
This is great.

00:24:22.240 --> 00:24:23.460
I heard like 60% of the people
were new to the conference.

00:24:23.460 --> 00:24:25.560
I thought nobody's probably
heard of FSUsage before.

00:24:25.560 --> 00:24:26.560
It's a great tool.

00:24:26.600 --> 00:24:28.410
Especially if you're having problems
with your -- if you want to analyze

00:24:28.410 --> 00:24:31.500
the file system performance or
see where your bottlenecks are.

00:24:31.500 --> 00:24:35.360
You run something like FSUsage and you
see a whole lot of text come through.

00:24:35.360 --> 00:24:37.710
And all that text is actually --
it's pretty impressive to me because

00:24:37.810 --> 00:24:40.930
that means that we've got so many
different processes all doing activity

00:24:40.930 --> 00:24:42.910
at the same time in the file system.

00:24:42.920 --> 00:24:44.470
So that's another place where
it's really important for us to

00:24:44.470 --> 00:24:47.260
make sure that we keep things
very tight inside the file system,

00:24:47.260 --> 00:24:50.980
keep our data structures small and
allow as many threads to access our data

00:24:50.980 --> 00:24:53.070
structures as possible at the same time.

00:24:53.080 --> 00:24:55.600
So you see a lot of
activity come through.

00:24:55.600 --> 00:24:57.680
It's easy to kind of trim this down.

00:24:57.680 --> 00:25:00.440
If you specify the name of your
application in the command line,

00:25:00.450 --> 00:25:02.770
in this case, TextEdit,
it will weed out all

00:25:02.770 --> 00:25:03.840
that extra information.

00:25:03.840 --> 00:25:07.390
So I just see the file system activity
that's responsible for what I'm looking

00:25:07.390 --> 00:25:08.700
at and that's my application text.

00:25:08.700 --> 00:25:09.100
Excedit.

00:25:11.010 --> 00:25:15.440
So in this case, all I did here at 2
o'clock in the afternoon,

00:25:15.460 --> 00:25:18.000
all I did was do a safe
save of a document.

00:25:18.000 --> 00:25:20.800
I had a file open, I made some changes,
and I hit Command-S,

00:25:20.820 --> 00:25:23.000
and I captured the FS usage.

00:25:23.120 --> 00:25:25.920
So I just kind of wanted to walk
through it with you to show you

00:25:26.000 --> 00:25:29.100
a little bit how to use FS usage
for your own applications.

00:25:29.140 --> 00:25:33.000
So the first thing that you notice
is we have this 2 over here.

00:25:33.070 --> 00:25:34.400
That's an error code.

00:25:34.570 --> 00:25:36.390
That's an enoint error.

00:25:36.570 --> 00:25:39.100
That means that this file does not exist.

00:25:39.210 --> 00:25:42.480
So to take a step back,
this is probably actually expected

00:25:42.760 --> 00:25:46.900
because the way the safe save works,
if I have my existing document here,

00:25:47.030 --> 00:25:50.100
what NSDocument does for me
is it creates a brand-new copy

00:25:50.100 --> 00:25:51.100
of the document over here.

00:25:51.160 --> 00:25:54.720
So I've got my old document here,
brand-new copy of my document here,

00:25:54.760 --> 00:25:57.050
and then the last step,
it does a rename to just

00:25:57.150 --> 00:25:58.460
replace the original one.

00:25:58.840 --> 00:26:01.980
We do it this way because at
any point during this process,

00:26:02.060 --> 00:26:04.240
if I were to pull the
plug on the machine,

00:26:04.240 --> 00:26:07.300
I will have a consistent
version of that document.

00:26:07.300 --> 00:26:09.860
So it's either all the old version of
the document or all the new version.

00:26:09.940 --> 00:26:13.300
I never end up with something that's
half-written when I pull that plug.

00:26:13.300 --> 00:26:15.730
So probably here when we get this enoint,
it's probably saying, like,

00:26:15.740 --> 00:26:17.300
I'm going to create this temporary file.

00:26:17.300 --> 00:26:18.230
Does it exist yet?

00:26:18.380 --> 00:26:20.900
Because I want to create a
file that doesn't exist yet.

00:26:20.900 --> 00:26:23.530
So now let's go ahead and
examine some of the other,

00:26:23.530 --> 00:26:27.620
I think, more interesting calls in what
we're looking at here just to kind

00:26:27.620 --> 00:26:29.930
of walk through what the output is.

00:26:30.680 --> 00:26:33.160
The first field of the output,
here we're going to open it,

00:26:33.300 --> 00:26:36.210
write the file, sync it to disk,
make sure everything's out on the disk,

00:26:36.230 --> 00:26:38.940
and then we're going to rename
it over the top of the file.

00:26:39.040 --> 00:26:41.870
So we opened it up at 2:06,
that's the time stamp

00:26:41.960 --> 00:26:43.320
where we opened it up.

00:26:43.420 --> 00:26:46.660
The system call that we made
was a write in this case.

00:26:47.470 --> 00:26:51.870
And we know that it
took 0.000018 seconds.

00:26:52.030 --> 00:26:53.460
So it's very quick.

00:26:53.490 --> 00:26:55.970
And then we have the
application of thread ID.

00:26:56.650 --> 00:26:59.110
One thing to take away from all
this is that I'm able to save

00:26:59.110 --> 00:27:00.890
in about 1/300 of a second.

00:27:00.920 --> 00:27:03.900
So the filesystem is something that
we see a lot -- kind of like memory,

00:27:03.900 --> 00:27:05.900
where we see a lot of people
beating it on at the same time,

00:27:05.960 --> 00:27:11.700
and it's very important and critical that
we perform it as quickly as possible.

00:27:11.810 --> 00:27:14.000
So that's a little bit
about how to use FS Usage.

00:27:14.050 --> 00:27:16.290
Kind of the takeaway is if you're
having filesystem performance

00:27:16.290 --> 00:27:19.690
problems or you suspect it,
I recommend that you run FS Usage.

00:27:19.700 --> 00:27:21.770
It's enlightening to see all the
things that are going on in the

00:27:21.780 --> 00:27:24.170
system when you run FS Usage,
just to see everything that's

00:27:24.170 --> 00:27:26.300
going on in the system,
maybe not only in your application,

00:27:26.320 --> 00:27:28.800
but it's pretty impressive to
see everything that happens,

00:27:28.820 --> 00:27:32.990
and you can easily identify
where you're spending your time.

00:27:34.990 --> 00:27:37.720
Now that I've talked about a
lot of the filesystem proper,

00:27:37.720 --> 00:27:41.150
I'd like to talk about FileVault 2,
or what we call full disk encryption.

00:27:41.350 --> 00:27:44.540
I'll talk about what it is and then
we'll have Sorin come up afterwards

00:27:44.590 --> 00:27:46.090
and talk about how it works.

00:27:46.780 --> 00:27:48.370
So before we started
the FileVault 2 project,

00:27:48.370 --> 00:27:53.340
or what we call full-disk encryption,
I've seen a lot of quotes like this.

00:27:53.410 --> 00:27:55.460
We have entire websites
dedicated to things like this.

00:27:55.460 --> 00:27:58.850
A thief recently stole a computer
server belonging to a major U.S.

00:27:58.850 --> 00:28:01.330
insurance company,
and company officials now fear

00:28:01.470 --> 00:28:05.000
that the personal data of nearly
1 million people could be at risk.

00:28:05.040 --> 00:28:08.110
California has a law,
as well as 41 other states,

00:28:08.280 --> 00:28:11.380
that require you,
if you lose someone's personal data,

00:28:11.380 --> 00:28:15.260
require you to let that person
know and also let the state know.

00:28:15.560 --> 00:28:18.410
So this becomes a very big PR issue for
companies if they start to lose social

00:28:18.480 --> 00:28:20.180
security numbers or credit card issues.

00:28:20.180 --> 00:28:22.140
So we thought, well,
this is a big problem.

00:28:22.140 --> 00:28:23.690
Let's go ahead and try and solve it.

00:28:23.720 --> 00:28:24.560
How hard could it be, right?

00:28:24.580 --> 00:28:25.540
Right?

00:28:25.540 --> 00:28:28.040
I mean, we saw some solutions out there.

00:28:28.040 --> 00:28:29.780
They looked like they were okay,
but we thought we could do better.

00:28:29.780 --> 00:28:32.690
We thought, you know, you take data,
you encrypt data, you store it on disk.

00:28:32.740 --> 00:28:35.350
Once you get it, you read it off disk,
you unencrypt it,

00:28:35.430 --> 00:28:36.090
and you return it back to the user.

00:28:36.120 --> 00:28:36.950
It seems like a simple problem.

00:28:36.950 --> 00:28:37.670
We can knock this one out.

00:28:39.220 --> 00:28:41.400
So we started drawing
it out on a whiteboard,

00:28:41.400 --> 00:28:43.500
and we got something like this.

00:28:43.560 --> 00:28:46.700
All of a sudden we noticed, like, okay,
we're going to have to write code in EFI,

00:28:46.700 --> 00:28:48.400
we're going to have to
write a lot of kernel code,

00:28:48.420 --> 00:28:49.900
we're going to have to
write user space code,

00:28:49.900 --> 00:28:50.760
user space library code.

00:28:50.970 --> 00:28:52.900
We didn't have anything
related to key management.

00:28:52.900 --> 00:28:54.370
We hadn't thought about that part yet.

00:28:54.480 --> 00:28:55.060
That's in there.

00:28:55.290 --> 00:28:57.440
And then we needed a bunch of
these applications on top to be

00:28:57.440 --> 00:28:59.200
modified to work with this too.

00:28:59.270 --> 00:29:01.630
So it quickly became much
more complicated than what

00:29:01.630 --> 00:29:02.900
we originally thought.

00:29:02.910 --> 00:29:05.650
But one of the big benefits, I think,
of working at Apple is that we're able

00:29:05.650 --> 00:29:09.940
to develop these integrated big solutions
and integrate it right into the system.

00:29:10.100 --> 00:29:13.510
So I kind of want to diverge a little
bit from FDE for one slide and talk

00:29:13.540 --> 00:29:17.000
about something right at the middle,
and that's this component right here.

00:29:17.010 --> 00:29:18.290
That's what we call CoreStorage.

00:29:18.420 --> 00:29:20.760
And that's the piece that I was
talking about where we thought we

00:29:20.760 --> 00:29:25.080
can go ahead and encrypt all the
data and do the decryption of it.

00:29:25.120 --> 00:29:29.720
So to take a closer look at how
that works and what CoreStorage is,

00:29:30.530 --> 00:29:32.650
Basically, where it fits in the stack,
if you think about it,

00:29:32.750 --> 00:29:34.570
HFS+ would be at the top over there.

00:29:34.690 --> 00:29:37.600
That's your logical volume, Mac HD.

00:29:37.730 --> 00:29:39.380
And then beneath that,
we have this whole layer

00:29:39.480 --> 00:29:40.430
called CoreStorage.

00:29:40.540 --> 00:29:43.960
You could think of it like a disk driver
or like a block storage device driver.

00:29:44.150 --> 00:29:47.850
This whole layer that's going to go ahead
and intercept all the data being written

00:29:48.290 --> 00:29:50.320
from HFS+ going down to your drive.

00:29:50.490 --> 00:29:53.500
And then at the bottom,
we have the actual drive itself.

00:29:53.710 --> 00:29:56.410
So if you look at the way it works,
we have our top secret

00:29:56.410 --> 00:29:57.760
document over there.

00:29:57.850 --> 00:30:00.940
We shuffle it down into CoreStorage
where we're going to encrypt it.

00:30:01.070 --> 00:30:04.240
And we actually go ahead and move
it to a different place on disk.

00:30:04.340 --> 00:30:05.540
And that's what the
address tree is about.

00:30:05.640 --> 00:30:08.510
We move it to a slightly
different location.

00:30:09.060 --> 00:30:10.760
But we're finding that
we can take this layer,

00:30:10.760 --> 00:30:13.920
this CoreStorage layer,
and it has a whole bunch of

00:30:13.940 --> 00:30:15.180
possibilities that we have here.

00:30:15.240 --> 00:30:16.740
Encryption is just one of them.

00:30:16.790 --> 00:30:19.720
This is a place we're hoping to
develop feature after feature for

00:30:19.720 --> 00:30:22.460
our users and where we're spending
a lot of time doing new development.

00:30:22.640 --> 00:30:25.850
So stay tuned to this layer,
and hopefully we'll have a lot

00:30:25.850 --> 00:30:27.600
of new information for you.

00:30:29.740 --> 00:30:33.450
Now back to FileVault 2.

00:30:33.690 --> 00:30:37.020
A little bit about what FileVault 2 is,
if you haven't used it yet.

00:30:37.020 --> 00:30:39.700
It password protects your entire volume,
like full disk encryption

00:30:39.800 --> 00:30:40.960
or whole disk encryption.

00:30:40.960 --> 00:30:44.200
It encrypts every block on your volume,
so like you saw in that last picture,

00:30:44.330 --> 00:30:46.860
it doesn't just encrypt
your payload data,

00:30:47.070 --> 00:30:49.200
it also encrypts your metadata.

00:30:49.200 --> 00:30:51.850
In fact, we go through every single
block of your HFS+ volume,

00:30:52.100 --> 00:30:55.240
whether it's free space or use space,
and we encrypt them all

00:30:55.240 --> 00:30:57.040
from one end to the other.

00:30:57.040 --> 00:30:58.920
We also support encryption
on external drives,

00:30:58.920 --> 00:31:01.060
so this becomes really cool
if you have a thumb drive,

00:31:01.300 --> 00:31:03.090
you can go ahead and
format it as encrypted,

00:31:03.190 --> 00:31:05.990
we can store that key in your key chain,
or your password in your key chain,

00:31:06.160 --> 00:31:08.270
that means whenever you put that
thumb drive in your computer,

00:31:08.270 --> 00:31:10.340
it just mounts,
but if someone steals it from you and

00:31:10.340 --> 00:31:13.950
they stick it in their own computer,
they'll be prompted for password

00:31:13.950 --> 00:31:15.880
and it's thoroughly encrypted.

00:31:15.880 --> 00:31:18.970
And we also support encrypted
time machine backups.

00:31:20.280 --> 00:31:24.200
So we use a method called
AES XTS for our encryption.

00:31:24.210 --> 00:31:27.250
It's basically AES 128
with some cipher stealing.

00:31:27.270 --> 00:31:31.150
What the cipher stealing means is that
we encrypt out of a 512-byte block,

00:31:31.250 --> 00:31:34.120
we encrypt the first 16 bytes,
we get the result of that,

00:31:34.120 --> 00:31:37.400
and we mix it into the next 16 bytes,
and we mix that into the next 16 bytes,

00:31:37.400 --> 00:31:39.590
and so forth, all the way along.

00:31:39.940 --> 00:31:41.720
The AES XDS is FIPS compliant.

00:31:41.810 --> 00:31:44.100
It's also what NIST recommends.

00:31:44.100 --> 00:31:47.650
So as of January 2010,
this was the most modern,

00:31:47.970 --> 00:31:52.200
best method that they recommended
for encrypting data at rest.

00:31:52.320 --> 00:31:56.830
So I think that what we've delivered is,
I think, sets the standard for encryption

00:31:57.140 --> 00:31:58.700
as well as performance.

00:31:58.820 --> 00:32:04.040
So one question I get, though, a lot,
though, is how can we use AES 128 and not

00:32:04.040 --> 00:32:06.600
this new thing called AES 256?

00:32:06.750 --> 00:32:10.840
So I ask you, how big is 2 to the 128th?

00:32:10.930 --> 00:32:13.360
So I kind of have a quote here
that I want to read to kind of

00:32:13.360 --> 00:32:16.540
set it in perspective so you
know the difference between 2

00:32:16.610 --> 00:32:18.900
to the 128th and 2 to the 256th.

00:32:19.310 --> 00:32:22.860
Imagine a computer the size of a grain
of sand that could test a key in the

00:32:22.860 --> 00:32:25.460
amount of time it takes for light
to cross that little grain of sand.

00:32:25.460 --> 00:32:29.980
If the whole planet were covered in
a meter of these little computers,

00:32:29.990 --> 00:32:34.300
it would take on average 1,000
years to crack a 128-bit key.

00:32:34.300 --> 00:32:37.820
So 2 to the 128th is, I think,
as close to infinity

00:32:37.820 --> 00:32:39.360
as you're going to get.

00:32:39.640 --> 00:32:42.490
When you're talking about
cracking encrypted volumes,

00:32:42.600 --> 00:32:45.160
people never talk about
cracking the keys.

00:32:45.160 --> 00:32:46.860
They talk about cracking passwords.

00:32:48.200 --> 00:32:51.870
I heard a good quote before,
and it's a lot easier just to go out

00:32:51.890 --> 00:32:55.500
and buy a $10 wrench to get someone's
password than it is to crack their key.

00:32:55.500 --> 00:32:58.780
So what is FileVault 2?

00:32:58.780 --> 00:33:01.940
One of the things that I'm most proud of,
I think,

00:33:01.950 --> 00:33:05.970
with the FileVault 2 project is the
way it integrates the whole system and

00:33:05.970 --> 00:33:07.640
the fit and finish that we put onto it.

00:33:07.740 --> 00:33:09.740
A couple of examples are
we have this feature called

00:33:09.740 --> 00:33:11.060
Treat First Reboot Special.

00:33:11.060 --> 00:33:15.450
So when you enable
full disk encryption...

00:33:15.620 --> 00:33:17.600
and the rest of the team.

00:33:17.600 --> 00:33:19.600
You're going to be prompted
for your password at EFI time.

00:33:19.600 --> 00:33:21.600
It looks just like the
real Cocoa login window,

00:33:21.660 --> 00:33:25.600
but we actually present that at
EFI login time as soon as you reboot.

00:33:25.600 --> 00:33:27.600
So sometimes your keyboards
don't always work from EFI.

00:33:27.610 --> 00:33:31.880
If I've got a third-party input device
that runs through some different

00:33:31.880 --> 00:33:34.600
type of a router and so forth,
it doesn't always match up.

00:33:34.660 --> 00:33:37.600
Sometimes my Bluetooth keyboard
isn't paired correctly.

00:33:37.600 --> 00:33:41.600
Or one thing that we get a lot, in fact,
when I called up AppleCare,

00:33:41.600 --> 00:33:45.720
I think the number one call driver
was people that owned iMacs or

00:33:45.720 --> 00:33:49.600
people that enabled password
login and forgot their passwords.

00:33:49.600 --> 00:33:53.940
So we wanted to be very sure that when
you enable full disk encryption that

00:33:53.940 --> 00:33:57.600
you're able to at least remember your
password or help you along a little bit,

00:33:57.600 --> 00:34:00.160
and we're not just going to completely
encrypt your data before you get

00:34:00.160 --> 00:34:01.430
a chance to type in your password.

00:34:01.600 --> 00:34:03.600
So we treat the first reboot special.

00:34:03.600 --> 00:34:06.530
We turn on CoreStorage, we reboot,
and we immediately ask

00:34:06.550 --> 00:34:07.600
you for your password.

00:34:07.600 --> 00:34:09.830
If you're having trouble
typing in the password or if

00:34:09.840 --> 00:34:12.920
you've forgotten your password,
what we do is go ahead and

00:34:12.930 --> 00:34:13.600
reboot into the recovery OS.

00:34:13.610 --> 00:34:16.970
You can disable FileVault
2 or you can change your

00:34:16.970 --> 00:34:19.600
password because at this point,
no encryption has been done.

00:34:19.600 --> 00:34:21.600
As soon as you type your
password in the first time,

00:34:21.850 --> 00:34:25.290
that's when we start encryption,
and that's when all bets are off.

00:34:25.600 --> 00:34:28.560
but actually not all bets are off
because we have this other feature

00:34:29.060 --> 00:34:30.680
that is called the recovery password.

00:34:30.680 --> 00:34:33.120
When you enable full disk encryption,
the first thing it does is

00:34:33.120 --> 00:34:36.770
print out a long ASCII string
of your recovery password.

00:34:36.770 --> 00:34:39.430
What that really is,
is kind of your fail safe.

00:34:39.450 --> 00:34:41.680
If you have forgotten your own password,
you can write this down

00:34:41.770 --> 00:34:42.970
and keep it in your safe.

00:34:42.970 --> 00:34:45.610
Something else you can do, though,
is we have an option where

00:34:45.650 --> 00:34:47.270
you can store it with Apple.

00:34:47.270 --> 00:34:50.630
It doesn't actually store your
recovery password with Apple.

00:34:50.850 --> 00:34:53.560
The next step it does is ask you
three banker-style questions,

00:34:53.560 --> 00:34:56.950
you know, what street did you grow up on,
who is your favorite teacher,

00:34:57.180 --> 00:34:58.430
what's your pet's first name.

00:34:58.430 --> 00:35:02.600
It takes all of these answers and
encrypts that recovery password and

00:35:02.600 --> 00:35:05.490
stores that encrypted blob up with Apple.

00:35:05.760 --> 00:35:08.000
So the next time you can go
up and call AppleCare and say

00:35:08.000 --> 00:35:10.300
I've forgotten my password,
can you help me in the

00:35:10.300 --> 00:35:11.460
last three questions?

00:35:11.460 --> 00:35:13.210
If you know the answers
to those three questions,

00:35:13.210 --> 00:35:14.860
they'll read off your recovery password.

00:35:14.950 --> 00:35:18.780
If you don't, though,
there's no way to get

00:35:18.780 --> 00:35:21.000
back in your computer.

00:35:21.000 --> 00:35:23.870
It doesn't matter who you are.

00:35:23.870 --> 00:35:26.740
There's nothing Apple can do.

00:35:26.740 --> 00:35:27.900
There's no back door.

00:35:27.900 --> 00:35:27.900
That machine is cryptographically
wiped for all intents and purposes.

00:35:28.850 --> 00:35:31.860
Okay, so that was a little bit
about what FileVault is.

00:35:32.010 --> 00:35:34.210
Now I'd like to bring Soren
Spies on stage to talk a little

00:35:34.220 --> 00:35:35.700
bit more about how it works.

00:35:35.700 --> 00:35:39.310
So, FileVault 2, we got CoreStorage,
we got HFS, we got encrypted data,

00:35:39.310 --> 00:35:40.500
we got unencrypted data.

00:35:40.690 --> 00:35:41.670
How do we get there?

00:35:41.700 --> 00:35:42.540
How do we set it up?

00:35:42.790 --> 00:35:43.700
How does it work?

00:35:43.700 --> 00:35:44.860
My name is Soren Spies.

00:35:45.000 --> 00:35:48.030
I work in storage technologies
with Deric and I had a lot of fun

00:35:48.030 --> 00:35:51.680
putting all this stuff together and
now hopefully explain it to you.

00:35:51.700 --> 00:35:55.010
So, first of all, I want to talk a little
bit more about CoreStorage,

00:35:55.010 --> 00:35:57.700
in particular how it does
the in-place encryption.

00:35:57.700 --> 00:36:00.090
Then I want to talk about
FileVault 2's key hierarchy,

00:36:00.090 --> 00:36:03.700
how we make it so that multiple people's
passwords can unlock a single disk.

00:36:03.700 --> 00:36:05.720
Also,
we're going to talk about how we secure

00:36:05.830 --> 00:36:07.670
those keys to make it hard to attack.

00:36:07.690 --> 00:36:10.950
We also are going to talk about
tools that you can manipulate

00:36:10.990 --> 00:36:12.700
CoreStorage FTE volumes with.

00:36:12.700 --> 00:36:16.700
And finally, I just have one little list
of requests to try to guide.

00:36:16.700 --> 00:36:19.500
We get a lot of different requests
for full disk encryption in FileVault

00:36:19.500 --> 00:36:21.700
2 and I want to try to guide those
in a way that's more user-friendly.

00:36:21.700 --> 00:36:27.700
So, first of all, at the low level,
you run DiskUtil List.

00:36:27.700 --> 00:36:29.680
How many people know how
to run DiskUtil List?

00:36:29.680 --> 00:36:30.700
Yes.

00:36:30.700 --> 00:36:31.690
Okay.

00:36:31.700 --> 00:36:32.700
You're in the right session.

00:36:32.700 --> 00:36:35.090
So, in the old days,
you just had your disk zero and

00:36:35.090 --> 00:36:36.590
you had a bunch of partitions.

00:36:36.700 --> 00:36:39.700
You probably noticed we added
this Apple boot partition in Lion.

00:36:39.700 --> 00:36:41.700
We store the recovery OS in there.

00:36:41.700 --> 00:36:45.580
But we also store what we call
the boot not equal to root pieces.

00:36:45.790 --> 00:36:48.850
Those are the unencrypted bits that we
need in order to boot something fancy

00:36:48.850 --> 00:36:50.680
like CoreStorage full disk encryption.

00:36:50.700 --> 00:36:50.700
So, in the old days,
we had this Apple boot partition.

00:36:50.700 --> 00:36:50.700
We store the recovery OS in there.

00:36:50.700 --> 00:36:50.700
But we also store what we call
the boot not equal to root pieces.

00:36:50.700 --> 00:36:50.700
Those are the unencrypted bits that we
need in order to boot something fancy

00:36:50.700 --> 00:36:50.700
like CoreStorage full disk encryption.

00:36:50.710 --> 00:36:55.700
So the input is sort of this
disk zero S2 in the slide,

00:36:55.700 --> 00:36:57.940
and then the output is
this new virtual disk,

00:36:57.980 --> 00:37:00.190
disk one,
and that's the unencrypted data.

00:37:00.270 --> 00:37:02.110
So when it's locked, there's no disk one.

00:37:02.160 --> 00:37:05.340
But as soon as you do the unlock,
then this disk one comes out,

00:37:05.340 --> 00:37:08.090
and it's partition type, you'll notice,
is Apple HFS.

00:37:08.360 --> 00:37:11.150
So it is an unencrypted volume
that just mounts like any other.

00:37:11.160 --> 00:37:15.940
So from an application perspective,
there's no specialness for FTE, really.

00:37:15.940 --> 00:37:18.560
There's nothing 5.2 makes
application do any differently.

00:37:18.560 --> 00:37:21.960
The only thing is sometimes
you attach a volume,

00:37:22.020 --> 00:37:24.560
and it doesn't come online
'cause it's not unlocked yet.

00:37:24.650 --> 00:37:28.740
So basically, disk zero S2 gets consumed,
and disk one gets produced,

00:37:28.740 --> 00:37:31.620
and there's a core storage driver
in the kernel that's doing that.

00:37:31.760 --> 00:37:33.530
So that's what we have.

00:37:33.840 --> 00:37:34.780
How do we get there?

00:37:34.820 --> 00:37:36.530
'Cause we want it to be
very smooth for users.

00:37:36.540 --> 00:37:38.950
We want them to click turn it on,
and we do make them reboot

00:37:38.950 --> 00:37:40.020
and type their password.

00:37:40.100 --> 00:37:42.130
Derek did not mention that
you can actually just power

00:37:42.130 --> 00:37:44.720
off on that very first reboot,
and we'll go ahead and

00:37:44.770 --> 00:37:46.000
turn off FTE for you.

00:37:46.070 --> 00:37:48.440
After that,
then you have to go to the recovery OS.

00:37:48.560 --> 00:37:53.560
So we have your HFS volume,
and we shrink it a little bit,

00:37:53.560 --> 00:37:56.090
and then we basically wrap
around it-- there's a tiny

00:37:56.090 --> 00:37:59.040
bit of space at the beginning,
fortunately, with HFS--we wrap around

00:37:59.410 --> 00:38:00.520
it core storage metadata.

00:38:00.620 --> 00:38:02.790
So we take--your HFS now
has some free space,

00:38:03.210 --> 00:38:05.790
and we go ahead and make
it into a core storage.

00:38:06.110 --> 00:38:08.560
And when we reboot,
the core storage driver comes up,

00:38:08.570 --> 00:38:11.560
and once we've made sure that you typed
in your password successfully at reboot,

00:38:11.560 --> 00:38:12.980
we start encrypting your data.

00:38:13.060 --> 00:38:15.540
And we encrypt your data
128 megabytes at a time.

00:38:15.720 --> 00:38:18.560
We basically take a
lockout on that segment.

00:38:18.560 --> 00:38:21.560
We encrypt it, but we write it into a
different part of the disk.

00:38:21.560 --> 00:38:25.680
And so we basically slide this
window throughout the disk so

00:38:25.880 --> 00:38:29.400
that at any given moment in time,
if you want to access a

00:38:29.430 --> 00:38:32.560
logical block of your HFS,
it's either encrypted or not encrypted,

00:38:32.580 --> 00:38:34.540
and we move that slowly over.

00:38:34.560 --> 00:38:39.560
If there is a crash,
we haven't erased the old data yet,

00:38:39.560 --> 00:38:44.560
and so we can go ahead and start over
on the most recent 128 megabyte segment

00:38:44.560 --> 00:38:47.540
if the computer happens to crash.

00:38:48.450 --> 00:38:49.290
Let's talk about the keys.

00:38:49.460 --> 00:38:54.860
How do we set up the keys so that you
can do the unlock with multiple secrets?

00:38:55.080 --> 00:38:57.930
First of all,
we generate a random volume key,

00:38:58.000 --> 00:39:00.990
so 128 bits of just random stuff
that we get of our dev random,

00:39:01.100 --> 00:39:03.640
and that is what we start
-- that's the low level.

00:39:03.640 --> 00:39:06.000
Each block is encrypted with that data.

00:39:06.000 --> 00:39:10.000
We also, for indirection purposes,
we do a key encrypting key.

00:39:10.000 --> 00:39:11.860
You'll see how that works in a second.

00:39:12.170 --> 00:39:15.000
And each user record,
whether that's sort of a real

00:39:15.010 --> 00:39:18.990
user like me or Deric or sort of a
role user like the recovery users,

00:39:19.130 --> 00:39:21.000
they each get a copy of
the key encrypting key.

00:39:21.000 --> 00:39:25.000
So if you have -- you know a secret,
you can unlock the key encrypting key.

00:39:25.000 --> 00:39:28.870
The key encrypting key
can unlock the volume key.

00:39:29.030 --> 00:39:30.930
So let's take a little look
at what that would be like.

00:39:30.990 --> 00:39:32.970
So Deric comes along.

00:39:33.060 --> 00:39:33.990
He types in his password.

00:39:34.000 --> 00:39:38.750
And we run it through a thing called
PBKDF2 with a lot of iterations.

00:39:39.190 --> 00:39:41.960
And then we get a passphrase drive key.

00:39:42.040 --> 00:39:44.450
Now, obviously,
we didn't store that anywhere,

00:39:44.620 --> 00:39:47.000
but we can use it to decode
the key encrypting key.

00:39:47.000 --> 00:39:51.000
There's one copy that Deric has,
and he can unlock it with his secret.

00:39:51.000 --> 00:39:53.000
And then we have a hash that
makes sure that we got it correct.

00:39:53.000 --> 00:39:54.990
And then we use that to
decrypt the volume key.

00:39:55.000 --> 00:39:59.000
This allows us to do I/O to the disk,
the encrypting and the decrypting.

00:39:59.000 --> 00:40:03.000
What's nice about this is that
if we want to add another user,

00:40:03.000 --> 00:40:05.870
we just set up that hierarchy
again for the second user.

00:40:06.200 --> 00:40:09.490
Nothing about Deric's setup is changed,
and we have an indirection so

00:40:09.550 --> 00:40:12.470
that we can change passwords,
and we can also change out the

00:40:12.470 --> 00:40:13.990
volume key from underneath.

00:40:14.000 --> 00:40:17.320
We're not currently doing that,
but that is something that we've

00:40:17.320 --> 00:40:19.090
architected it to be able to do.

00:40:19.300 --> 00:40:22.200
So we have, I mentioned,
these different types of user records.

00:40:22.200 --> 00:40:23.800
Most common is going to be your OS user.

00:40:23.800 --> 00:40:25.690
It stays in sync with the OS.

00:40:25.870 --> 00:40:31.670
So if your user has a
passphrase or a password,

00:40:31.670 --> 00:40:35.710
even if it's a terrible one like puppies,
then

00:40:35.820 --> 00:40:40.700
It's going to be enabled on the full
disk encryption part of the disk.

00:40:40.870 --> 00:40:43.610
So if you don't have a password,
we will not copy that

00:40:43.610 --> 00:40:45.100
user down to the disk.

00:40:45.230 --> 00:40:48.020
But if you do have a password,
we're going to go ahead and enable it.

00:40:48.040 --> 00:40:50.250
And in general,
all users are enabled all the time.

00:40:50.260 --> 00:40:53.610
So that there's a synchronization between
that so you don't add a user and then,

00:40:53.610 --> 00:40:55.160
oh, I forgot to add them to the disk.

00:40:55.270 --> 00:40:57.200
We just try to do that
automatically for you.

00:40:57.940 --> 00:40:59.630
We also have what's
called disk passphrase.

00:40:59.730 --> 00:41:02.570
So that's great for a disk
that doesn't have an OS on it.

00:41:02.570 --> 00:41:06.610
How many people are using
a Mac Pro every day?

00:41:06.770 --> 00:41:10.380
Okay, so how many of you have more
than one disk in your Mac Pro?

00:41:10.430 --> 00:41:11.400
Okay, you guys are pretty good.

00:41:11.400 --> 00:41:14.000
So you could have your secondary
disk if you didn't have any OSs.

00:41:14.000 --> 00:41:16.220
If it's like on my --
I don't have Mac Pros,

00:41:16.220 --> 00:41:18.300
but if I did,
they'd have a lot of OSs on them.

00:41:18.320 --> 00:41:22.960
But if you have a data disk,
then you can go ahead and encrypt

00:41:22.960 --> 00:41:28.580
that disk and have it used from,
say, Time Machine through your USB stick,

00:41:28.580 --> 00:41:29.270
et cetera.

00:41:29.600 --> 00:41:31.500
So that's a different
type of password record,

00:41:31.500 --> 00:41:33.300
and if you boot it up, you'll see, like,
a big disk,

00:41:33.300 --> 00:41:37.170
and it'll say "disk password," and
then you type in your disk password.

00:41:37.200 --> 00:41:40.400
It's sort of a slightly different
model than the OS password.

00:41:40.400 --> 00:41:43.760
If there's an OS on the volume,
it's generally a better experience

00:41:43.900 --> 00:41:47.900
to use the OS-synchronized passwords.

00:41:47.950 --> 00:41:49.800
Then we also have this
personal recovery key,

00:41:49.830 --> 00:41:51.570
which Deric talked about,
but we also have an

00:41:51.570 --> 00:41:53.990
institutional recovery key,
so you can install a

00:41:53.990 --> 00:41:58.000
public key on your system,
and when you turn on FileVault 2,

00:41:58.020 --> 00:42:01.570
we'll go ahead and make a secret
that can unlock the disk and we'll

00:42:01.570 --> 00:42:04.700
encrypt it with the public key,
and we'll store that.

00:42:04.750 --> 00:42:08.600
So if you have the private key back
home in your super-safe system,

00:42:08.600 --> 00:42:10.600
if that--you know,
if I were to leave Apple and

00:42:10.670 --> 00:42:13.690
somebody wanted to decrypt
my disk after I left Apple,

00:42:13.810 --> 00:42:17.500
they could take my computer,
and they could take Apple's private key,

00:42:17.520 --> 00:42:20.580
and they could bring them together
with the appropriate Disk Util

00:42:20.580 --> 00:42:23.400
command line and unlock that volume.

00:42:23.450 --> 00:42:26.430
So that's kind of an institutional
feature so that you can

00:42:26.430 --> 00:42:27.700
have thousands of machines.

00:42:27.720 --> 00:42:30.900
They're all unlockable
by a single private key.

00:42:30.920 --> 00:42:34.740
That also disables the personal
recovery key in the UI,

00:42:34.740 --> 00:42:39.580
which will prevent your customers or
the people you support from archiving

00:42:39.580 --> 00:42:43.900
their personal recovery keys with Apple,
which you probably don't want,

00:42:43.900 --> 00:42:46.400
depending on your security policies.

00:42:46.520 --> 00:42:49.900
So we have all this great encryption,
lots of keys.

00:42:49.900 --> 00:42:53.400
As a bonus for this,
we get sort of cryptographic wipe,

00:42:53.510 --> 00:42:56.400
a really fast, you know,
I just want a split-second,

00:42:56.410 --> 00:42:59.170
wipe-out access to this disk.

00:42:59.400 --> 00:43:00.900
So I mentioned--so how
are we gonna do this?

00:43:00.900 --> 00:43:03.600
We have multiple keys,
and they're variable size,

00:43:03.600 --> 00:43:05.600
and they move around the disk,
as it turns out.

00:43:05.600 --> 00:43:08.590
So what we do is we actually
take all of your metadata,

00:43:08.920 --> 00:43:12.690
things like your user pictures and
your usernames and even their password

00:43:12.690 --> 00:43:14.100
hints that we display at EFI Login.

00:43:14.100 --> 00:43:17.090
EFI Login is basically a slideshow.

00:43:17.100 --> 00:43:19.100
It's kind of scary if you look inside.

00:43:19.100 --> 00:43:24.100
But the--but it's very clever,
and it looks very beautiful.

00:43:24.100 --> 00:43:28.830
So we have all these nice,
rich UI elements, and they're actually

00:43:28.840 --> 00:43:31.300
stored in the metadata,
of course, storage,

00:43:31.300 --> 00:43:35.300
and we want those things to be gone if
you want to quickly erase your disk.

00:43:35.300 --> 00:43:37.280
You don't even want to
know whose disk it was.

00:43:37.350 --> 00:43:39.800
And so we basically
encrypt all of that data,

00:43:39.800 --> 00:43:42.790
including your secrets that are
encrypted with your password.

00:43:42.800 --> 00:43:44.800
So if I know my password,
then I need the metadata

00:43:44.800 --> 00:43:45.800
to get to the volume key,
right?

00:43:45.800 --> 00:43:47.800
There's the multi-step unlock.

00:43:47.800 --> 00:43:50.800
So we take all that metadata,
and we encrypt it with the wipe key.

00:43:50.800 --> 00:43:53.800
So this wipe key sits
actually on the disk.

00:43:53.800 --> 00:43:55.800
It's clear text on the disk.

00:43:55.800 --> 00:43:58.300
And the idea is you can
eliminate the wipe key,

00:43:58.300 --> 00:44:00.500
and then all you're left
with is this encrypted data.

00:44:00.500 --> 00:44:02.800
So if I know my password,
I can't unlock my disk because

00:44:02.800 --> 00:44:04.000
the wipe key has destroyed it.

00:44:04.050 --> 00:44:06.610
Now, if it's SSD,
when I destroy the wipe key, eh,

00:44:06.700 --> 00:44:10.160
who knows whether it's really destroyed,
so I still recommend multiple

00:44:10.160 --> 00:44:12.500
pass secure erase afterwards.

00:44:12.500 --> 00:44:18.690
But you get about 80% of the value very
quickly by destroying the wipe key.

00:44:19.430 --> 00:44:21.410
Let's talk about key security.

00:44:21.630 --> 00:44:24.460
How do we make the password
secure and then how do we also

00:44:24.460 --> 00:44:28.900
make the crypto that we do secure
so that it is harder to attack?

00:44:28.930 --> 00:44:31.600
First of all,
there's a couple types of attacks.

00:44:31.660 --> 00:44:33.300
There's password attacks.

00:44:33.300 --> 00:44:36.420
You take a dictionary and just encrypt
every single word in the dictionary,

00:44:36.600 --> 00:44:39.390
hash every key in the dictionary,
and you try to unlock this volume.

00:44:39.400 --> 00:44:40.140
Can I unlock?

00:44:40.140 --> 00:44:40.830
Can I unlock?

00:44:40.890 --> 00:44:41.650
Can I unlock?

00:44:41.770 --> 00:44:43.240
There's also algorithm attacks.

00:44:43.300 --> 00:44:45.390
AES-128, AES-256.

00:44:45.490 --> 00:44:47.100
There's been some cryptographic research.

00:44:47.100 --> 00:44:49.740
And there's, you know,
a few little -- they're kind

00:44:49.740 --> 00:44:52.560
of nibbling away at the edges
of is it really -- you know,

00:44:52.560 --> 00:44:53.980
what's -- how secure is it?

00:44:54.000 --> 00:44:55.800
And it's still pretty secure.

00:44:55.800 --> 00:44:57.200
But they're definitely
nibbling away at the edges.

00:44:57.200 --> 00:45:01.500
If you reduce it a little bit,
I'll talk about you can --

00:45:01.520 --> 00:45:02.800
you may be able to attack it.

00:45:02.860 --> 00:45:09.190
Our goal in full disk encryption is to
increase the cost of any attack against

00:45:09.230 --> 00:45:14.460
a particular volume and in particular to
make sure that we don't have one attack

00:45:14.570 --> 00:45:16.700
that can apply to multiple volumes.

00:45:16.810 --> 00:45:19.290
So first of all,
let's talk about password attacks.

00:45:19.420 --> 00:45:21.760
These are pretty
straightforward to understand.

00:45:21.800 --> 00:45:26.100
If I have a simple password like puppies,
then it's pretty easy for you to try

00:45:26.100 --> 00:45:30.500
that password and maybe a few other
common passwords and unlock my disk.

00:45:30.580 --> 00:45:37.300
So the worst case is if all of the
passwords were hashed the same way,

00:45:37.310 --> 00:45:40.190
you guys could go out and make
a huge lookup table of all the

00:45:40.190 --> 00:45:43.130
hashes of all the passwords and
then you'd be able to figure out,

00:45:43.130 --> 00:45:46.300
oh, hey, look, here's all the hashes
of all the passwords.

00:45:46.300 --> 00:45:50.640
I am going to now -- if I happen to
find any file vault encrypted computers,

00:45:50.640 --> 00:45:54.300
I will say, oh, look,
this hash matches this giant table.

00:45:54.300 --> 00:45:56.110
We definitely do not want that.

00:45:56.470 --> 00:45:57.200
That's the worst case.

00:45:57.300 --> 00:45:59.800
So we're going to talk about
how to solve that problem.

00:45:59.800 --> 00:46:02.300
We also have the general problem of just
-- there's a lot of computers out there.

00:46:02.300 --> 00:46:05.570
I can go on EC2 and get myself
like a supercomputer for a day

00:46:05.570 --> 00:46:07.800
and do a lot of password hashing.

00:46:07.800 --> 00:46:09.790
So we've got to make that expensive.

00:46:09.800 --> 00:46:11.300
You've got to assume the
attacker has everything.

00:46:11.300 --> 00:46:14.170
They've got your metadata with all
the password encrypted keys and

00:46:14.260 --> 00:46:15.900
they've got your encrypted keys.

00:46:15.900 --> 00:46:18.880
So they're holding on to the
encrypted data and then attacking

00:46:18.880 --> 00:46:21.870
the little metadata trying to
-- once they break the metadata,

00:46:22.030 --> 00:46:23.820
then they can go and read your data.

00:46:23.900 --> 00:46:26.790
And, you know,
especially with cloud computing,

00:46:26.790 --> 00:46:29.490
that whole time, money,
computing resources,

00:46:29.560 --> 00:46:31.950
who's your adversary,
they may have a lot of

00:46:31.950 --> 00:46:33.900
ability to crack your system.

00:46:33.920 --> 00:46:37.900
So number one thing we do
is do a lot of iterations.

00:46:37.900 --> 00:46:42.900
So it takes a while for any
particular password to be hashed.

00:46:42.900 --> 00:46:45.440
We also salt every single password.

00:46:45.500 --> 00:46:47.460
We try to calibrate even over time.

00:46:47.540 --> 00:46:51.250
Every time you change your password,
we say on this computer,

00:46:51.300 --> 00:46:55.340
how fast can we -- let's make it cost at
least a tenth of a second of real time

00:46:55.500 --> 00:46:55.500
to try to hash through this password.

00:46:55.530 --> 00:46:59.500
So that even if you do have EC2,
you've got to -- it's going to take you,

00:46:59.520 --> 00:47:03.500
you know, a while as you clunk through
trying all these passwords.

00:47:03.500 --> 00:47:06.070
Then, as I mentioned,
we store a hash of the key

00:47:06.070 --> 00:47:09.500
encrypting key to see whether
or not you got the value right.

00:47:09.500 --> 00:47:11.350
So that's a little bit of a challenge.

00:47:11.620 --> 00:47:15.100
So we're going to try to do that.

00:47:15.100 --> 00:47:17.090
We're going to try to make sure
that we get the value right.

00:47:17.170 --> 00:47:21.090
So that's another way,
because the key encrypting key is random,

00:47:21.090 --> 00:47:23.100
that also makes this unique.

00:47:23.100 --> 00:47:24.770
And you're not going to be able to
have a giant lookup table and say,

00:47:24.840 --> 00:47:26.550
oh, I found this computer and I know
that if his password was puppies,

00:47:26.590 --> 00:47:28.080
all the computers that have
puppies in their passwords are

00:47:28.080 --> 00:47:29.050
going to have the same hash.

00:47:29.440 --> 00:47:30.830
No.

00:47:31.220 --> 00:47:33.100
That's not how it works.

00:47:33.100 --> 00:47:35.100
Every key encrypting key is unique.

00:47:35.100 --> 00:47:37.100
Every salt of every password is unique.

00:47:37.100 --> 00:47:39.160
And we do a lot of iterations.

00:47:39.700 --> 00:47:43.670
disappears into random numbers and
that is all you have on your disk

00:47:43.670 --> 00:47:48.150
and it's unique to your user record
and if somebody wants to attack it,

00:47:48.220 --> 00:47:52.000
they can and if you have a bad password,
they will crack it.

00:47:52.000 --> 00:47:56.200
But if your password is decent,
it's going to take them a while.

00:47:56.280 --> 00:47:56.840
That is our goal.

00:47:56.840 --> 00:47:59.830
We cannot eliminate attacks but
we can make them more expensive.

00:47:59.910 --> 00:48:01.810
Let's talk about algorithm attacks.

00:48:01.910 --> 00:48:05.900
I mentioned, first of all,
if you can actually instrument a machine

00:48:05.900 --> 00:48:09.610
where the bits are in the registers,
you can kind of see when the

00:48:09.610 --> 00:48:11.550
power rails go high and stuff.

00:48:11.650 --> 00:48:12.580
Those are pretty cool.

00:48:12.610 --> 00:48:16.610
But you can also,
if you say AES 128 has 13 rounds at a

00:48:16.610 --> 00:48:21.540
certain state of mixing and you take
that down to nine rounds and you're like,

00:48:21.540 --> 00:48:25.660
oh, look, at nine rounds,
it doesn't mix it fully and I can kind of

00:48:25.980 --> 00:48:29.840
figure out what the key is without having
to guess every single possible key.

00:48:29.970 --> 00:48:32.840
There's also attacks where you
have two keys that are related in a

00:48:32.840 --> 00:48:36.010
certain way and you can do some math
and kind of -- you don't know one of

00:48:36.020 --> 00:48:38.950
the keys but you know the other one
and you do some math and then you

00:48:39.280 --> 00:48:40.840
figure out what the other key is.

00:48:40.840 --> 00:48:43.950
These first three are
sort of -- you know,

00:48:43.950 --> 00:48:48.840
these are known problems but
they're not practical attacks.

00:48:48.840 --> 00:48:51.580
They aren't things that people were
going to -- you're not going to

00:48:51.590 --> 00:48:53.830
have related keys in the real world,
for example.

00:48:53.960 --> 00:48:55.780
And unless your AES implementation
is truly broken,

00:48:55.780 --> 00:48:57.830
it's going to be doing the
correct number of rounds.

00:48:57.840 --> 00:48:59.840
But they're very interesting
for cryptographic applications.

00:48:59.840 --> 00:49:02.110
And you can see that from a graphic
standpoint because once you've

00:49:02.110 --> 00:49:04.840
broken a related key attack,
then you might think, oh, interesting.

00:49:04.840 --> 00:49:06.750
There's like a -- you know,
because it's trying to do all

00:49:06.750 --> 00:49:08.840
this mixing in a way that's
really hard to go backwards.

00:49:08.840 --> 00:49:13.180
But if you find some mistakes,
some of these other attacks can help

00:49:13.180 --> 00:49:15.840
you maybe extend out to the full AES.

00:49:15.840 --> 00:49:19.840
Known plaintext and chosen plaintext
are somewhat more practical.

00:49:19.840 --> 00:49:21.840
Your HFS volume structures
are pretty standard.

00:49:21.840 --> 00:49:24.790
So that's a known plaintext that's
on every core storage volume.

00:49:24.850 --> 00:49:29.720
So we want to make sure that that doesn't
look similar across multiple volumes.

00:49:29.840 --> 00:49:34.840
There's also big blocks of zeros and
popular pictures on the Internet.

00:49:34.840 --> 00:49:36.840
All that kind of stuff is going
to be on people's hard drives.

00:49:36.950 --> 00:49:39.840
Chosen plaintext, if I send you an email
with an attachment,

00:49:39.840 --> 00:49:43.040
I can probably put a plaintext
into your system and get

00:49:43.040 --> 00:49:44.810
it encrypted with your key.

00:49:44.870 --> 00:49:47.280
And if that plaintext is like
super magic -- I think there was

00:49:47.280 --> 00:49:49.990
a crypto system once where if you
put the right plaintext in there,

00:49:49.990 --> 00:49:53.200
it would just -- it would basically come
out as like a block of zeros because

00:49:53.260 --> 00:49:54.840
it was XORing itself or something.

00:49:54.890 --> 00:49:59.700
But anyway,
you can insert known tricky plaintext.

00:50:00.100 --> 00:50:04.680
And then you try to find them
wherever they end up on the disk.

00:50:04.840 --> 00:50:06.840
And you can go and attack them that way.

00:50:06.840 --> 00:50:07.840
So we want to make that difficult.

00:50:07.840 --> 00:50:10.350
And the way we make that
difficult is we've got to make

00:50:10.350 --> 00:50:13.840
the ciphertexts different every
place they appear on your volume.

00:50:13.840 --> 00:50:16.290
So if you have 50 copies of something,
like a block of zeros,

00:50:16.290 --> 00:50:17.840
they're different at every point.

00:50:17.840 --> 00:50:21.070
And also, if you store the same
text on different volumes,

00:50:21.130 --> 00:50:24.840
even if it's the same offset,
you want it to be unique.

00:50:24.840 --> 00:50:27.750
So the way we do that is for
within one volume for every block,

00:50:27.750 --> 00:50:29.840
we feed in the logical block address.

00:50:29.840 --> 00:50:32.840
So that will kind of change
the crypto algorithm.

00:50:32.840 --> 00:50:35.840
We tweak it,
feed it in as the initialization vector.

00:50:35.840 --> 00:50:37.830
And we say, okay,
kind of start over here.

00:50:37.840 --> 00:50:40.270
And then that will make the
output look different based on the

00:50:40.270 --> 00:50:41.840
location within a single volume.

00:50:41.840 --> 00:50:44.740
And then across multiple volumes
-- I already mentioned that

00:50:44.740 --> 00:50:45.840
we have a random volume key.

00:50:45.840 --> 00:50:47.840
So every volume is going
to have a different key.

00:50:47.840 --> 00:50:51.840
We also feed in --
Derek talked about the mixing.

00:50:51.840 --> 00:50:55.840
You know, you take each -- because AES is
only defined for 16 bytes.

00:50:55.840 --> 00:50:57.840
It's like this tiny little thing.

00:50:58.010 --> 00:50:59.820
And that's why they have AES XTS.

00:50:59.840 --> 00:51:01.840
AES 16 bytes at a time.

00:51:01.840 --> 00:51:05.310
And then XTS kind of swirls,
mixes it all together

00:51:05.310 --> 00:51:06.840
across those blocks.

00:51:06.840 --> 00:51:09.830
So that even if you change a
bit at the end of your block,

00:51:09.890 --> 00:51:12.840
it will actually have an
effect at the beginning.

00:51:12.950 --> 00:51:16.570
And we can tweak XTS also so
that its mixing algorithm is kind

00:51:16.570 --> 00:51:18.660
of offset within its abilities.

00:51:19.000 --> 00:51:22.900
And we do that by feeding in a
hash of the volume key plus the

00:51:22.900 --> 00:51:27.210
volume UUID just to kind of make it,
again, provide as much uniqueness as

00:51:27.320 --> 00:51:28.830
we can to the encryption engine.

00:51:28.890 --> 00:51:29.730
Here's a picture.

00:51:29.840 --> 00:51:32.810
Plain text on top, ciphertext on bottom.

00:51:32.910 --> 00:51:35.840
In particular, there's a per block tweak.

00:51:35.840 --> 00:51:39.390
And then there is the mixing tweak
that applies to the whole volume as

00:51:39.540 --> 00:51:42.710
well -- excuse me -- as the volume key.

00:51:44.170 --> 00:51:48.940
Talk a little bit about the tools that we
have to manipulate FileVault 2 volumes.

00:51:49.000 --> 00:51:52.680
So in particular, DiskUtil,
many of you are familiar with this.

00:51:52.800 --> 00:51:57.010
There's a subverb called CoreStorage,
which you can abbreviate as CS.

00:51:57.140 --> 00:52:02.480
And you can now encrypt and decrypt
in Mountain Lion existing volumes.

00:52:02.480 --> 00:52:04.940
So if you already have a volume
turned on for whatever reason you've

00:52:04.940 --> 00:52:08.010
been playing around with DiskUtil,
you can encrypt and

00:52:08.010 --> 00:52:09.750
decrypt an existing volume.

00:52:09.760 --> 00:52:13.310
You can also delete a volume,
which I don't think was there before.

00:52:13.320 --> 00:52:15.400
In Lion,
if you're not as familiar with this,

00:52:15.460 --> 00:52:19.220
there were create and create volume to
set up sort of a logical volume group,

00:52:19.220 --> 00:52:21.160
and then you can have
logical volumes in it.

00:52:21.210 --> 00:52:24.540
And also,
you can take an existing HFS volume

00:52:24.540 --> 00:52:27.410
and convert it over to CoreStorage,
optionally with a passphrase.

00:52:27.600 --> 00:52:29.660
That's one way to turn on FTE.

00:52:29.700 --> 00:52:33.540
Now, this way of turning on
FTE is great for data disks,

00:52:33.610 --> 00:52:35.780
but here's the big thing that
everybody's been wanting for,

00:52:35.780 --> 00:52:39.480
which is full FileVault
2 on the command line.

00:52:39.580 --> 00:52:41.540
So we have this tool called...

00:52:46.830 --> 00:52:51.440
I can't take direct credit for this,
but I did provide lots of advice.

00:52:51.440 --> 00:52:54.330
So using all the same
libraries as the UI,

00:52:54.330 --> 00:52:58.480
and it actually has a few extra
features that the UI does not have.

00:52:58.610 --> 00:53:01.240
So number one thing is
it's got the recovery key,

00:53:01.320 --> 00:53:04.480
and then it also can do nice
things like give you your

00:53:04.480 --> 00:53:06.440
status of how encrypted you are.

00:53:06.440 --> 00:53:08.610
So basically you type in
your pass -- you enable it,

00:53:08.610 --> 00:53:11.440
type in your pass phrase,
and then you reboot.

00:53:11.440 --> 00:53:14.360
So that will take you
through the whole process.

00:53:14.360 --> 00:53:17.790
If you power off after the first reboot,
it will not take effect, et cetera,

00:53:17.840 --> 00:53:18.600
et cetera.

00:53:18.600 --> 00:53:27.040
So this is great if you want to command
line automate turning on FDE FileVault 2.

00:53:27.040 --> 00:53:28.980
So we have some other examples here.

00:53:28.980 --> 00:53:30.520
You can add existing users.

00:53:30.520 --> 00:53:34.640
You know, I can add Deric,
and I can add our -- add his boss, Brad.

00:53:34.640 --> 00:53:37.240
But then later maybe I don't want
Brad to be on my computer anymore.

00:53:37.240 --> 00:53:39.760
So I can actually delete
him from the OS first,

00:53:39.780 --> 00:53:43.350
and then I tell FDE setup, hey,
go check the OS records,

00:53:43.430 --> 00:53:45.660
and if there's anything on
FDE that's not supposed to be there,

00:53:45.720 --> 00:53:45.720
get rid of it.

00:53:45.730 --> 00:53:50.640
FDE setup itself doesn't delete anything,
but it will synchronize and

00:53:50.700 --> 00:53:52.110
it will notice deletions.

00:53:52.120 --> 00:53:54.780
And then finally you can also
turn off from the command line,

00:53:54.990 --> 00:53:57.610
which you could do before,
but it's nice to have

00:53:57.700 --> 00:53:59.620
it all in one command.

00:53:59.620 --> 00:54:03.000
Also, super bonus,
if you're running remote desktop,

00:54:03.000 --> 00:54:06.650
you can, in fact,
set up a giant pipe command line,

00:54:06.650 --> 00:54:09.820
and it will accept XML and
it will spit out XML,

00:54:09.830 --> 00:54:15.180
and you can go out and FileVault
2 that person's computer.

00:54:15.180 --> 00:54:23.310
Magic FDE setup command.

00:54:24.380 --> 00:54:25.450
One more little tool.

00:54:25.460 --> 00:54:27.200
I want to talk about a
problem that people have and

00:54:27.200 --> 00:54:28.680
actually more of a solution.

00:54:28.750 --> 00:54:29.960
It's a really cool thing.

00:54:29.960 --> 00:54:31.740
So data at rest.

00:54:31.950 --> 00:54:34.060
FileVault 2 is designed for data at rest.

00:54:34.210 --> 00:54:35.930
But what is data at rest?

00:54:36.150 --> 00:54:38.570
I know that data at rest
is when my computer,

00:54:38.570 --> 00:54:40.300
like take my hard drive out.

00:54:40.300 --> 00:54:42.270
That data is at rest.

00:54:42.380 --> 00:54:44.290
And that's going to be
expensive to attack.

00:54:44.330 --> 00:54:48.400
But it turns out that most of us don't
take our computers apart that often.

00:54:48.400 --> 00:54:52.240
And most of us don't turn
our computers off that often.

00:54:53.620 --> 00:54:57.370
And unfortunately,
RAM is still sitting there

00:54:57.370 --> 00:54:59.600
with the volume key in it.

00:54:59.670 --> 00:55:04.370
And so very clever attackers
have figured out numerous ways to

00:55:04.370 --> 00:55:07.490
basically pop your RAM out and then...

00:55:07.690 --> 00:55:10.270
Suck out the volume key.

00:55:10.270 --> 00:55:14.040
So sleep is not maximally secure.

00:55:14.040 --> 00:55:19.400
And we have this great feature on some
of the newest portables called standby.

00:55:19.400 --> 00:55:23.480
And standby actually writes
your RAM to a file on disk.

00:55:23.600 --> 00:55:26.530
But for usability reasons,
we want to be able to open the

00:55:26.530 --> 00:55:28.460
lid and just go back right away.

00:55:28.460 --> 00:55:33.040
We actually stash a key so that we
can unlock that Hibernate image and

00:55:33.040 --> 00:55:35.810
get you back your volume key into RAM.

00:55:35.820 --> 00:55:40.240
So standby doesn't change anything
about making sleep more secure.

00:55:40.240 --> 00:55:43.420
Also, standby doesn't always kick in.

00:55:43.420 --> 00:55:46.130
Standby,
if you've got plugged in AC power,

00:55:46.140 --> 00:55:50.240
if you've got USB devices plugged in,
standby doesn't kick in.

00:55:50.240 --> 00:55:52.570
But standby is pretty
close to what you want.

00:55:52.700 --> 00:55:56.230
Because what you want is you want
everything on disk encrypted in a way

00:55:56.240 --> 00:56:00.190
that you with your secret can decrypt it,
but an attacker cannot.

00:56:00.190 --> 00:56:04.810
And with no secret stashed off in the
special hardware to bring it back.

00:56:05.260 --> 00:56:07.750
So we have the PM set command line.

00:56:07.820 --> 00:56:09.900
This is in the PM set man page.

00:56:09.900 --> 00:56:10.340
Don't worry.

00:56:10.420 --> 00:56:11.980
You don't have to write
this down right now.

00:56:11.980 --> 00:56:15.320
But destroy FV key on standby.

00:56:15.570 --> 00:56:18.320
That is not the default,
but it will make your

00:56:18.430 --> 00:56:19.980
machine more secure.

00:56:19.980 --> 00:56:20.470
It will make you type
your password twice.

00:56:20.590 --> 00:56:24.640
Once to unlock your kind of
Hibernate reanimation process.

00:56:24.640 --> 00:56:27.520
And then again at your screen lock,
which we always force

00:56:27.520 --> 00:56:28.720
screen lock to be on.

00:56:28.720 --> 00:56:33.400
Hibernate mode 25 is also there.

00:56:33.400 --> 00:56:37.190
That will basically force you
to go into hibernation right

00:56:37.190 --> 00:56:39.460
away every time you go to sleep.

00:56:39.460 --> 00:56:42.460
There's different options
that you can pass.

00:56:42.460 --> 00:56:44.870
But conceptually destroy
FV key on standby and force

00:56:44.870 --> 00:56:46.350
hibernation on every sleep.

00:56:46.400 --> 00:56:48.080
This will give you every
time you close your lid,

00:56:48.350 --> 00:56:51.810
you'll go into a highly secure
mode where basically you have to

00:56:51.930 --> 00:56:56.460
take apart your computer and start
attacking the keys to really get at it.

00:56:56.840 --> 00:57:01.460
Final slides here,
requests and investigations.

00:57:01.570 --> 00:57:02.720
First of all, no promises.

00:57:02.800 --> 00:57:06.000
I'm just trying to make
your bug reports better.

00:57:06.080 --> 00:57:07.300
People want authenticated reboot.

00:57:07.540 --> 00:57:09.390
They want a whole bunch of
stuff with recovery keys.

00:57:09.390 --> 00:57:12.200
They want to be able to rekey.

00:57:12.200 --> 00:57:15.490
They want more OS X server integration,
although I'm glad I will send

00:57:15.490 --> 00:57:18.160
back to the people that did
all that work for FD setup that

00:57:18.160 --> 00:57:19.880
you guys are very happy so far.

00:57:19.880 --> 00:57:21.660
Just, I mean,
happier than you were before.

00:57:22.240 --> 00:57:24.160
And finally, mandatory FileVault 2.

00:57:24.160 --> 00:57:27.030
A lot of people want to kind
of force it to be turned on.

00:57:28.270 --> 00:57:31.870
Okay, brings us to our little
wrap-up slides here.

00:57:32.190 --> 00:57:34.170
Paul Danbold is our evangelist.

00:57:34.380 --> 00:57:36.860
There's a filesystem programming
guide where you can get some of

00:57:36.860 --> 00:57:38.190
the latest on which APIs to use.

00:57:38.210 --> 00:57:41.440
And the developer forums are always
there to help you help each other.

00:57:41.440 --> 00:57:44.500
We have some excellent
sessions on responsiveness,

00:57:44.610 --> 00:57:46.780
getting things off the main thread.

00:57:46.780 --> 00:57:50.600
Tomorrow morning at 9 a.m., power
management and energy-efficient software.

00:57:50.600 --> 00:57:52.550
Learn how to really
optimize for battery life.

00:57:52.620 --> 00:57:55.650
Before you all leave,
performance and energy

00:57:55.650 --> 00:57:57.720
consumption go hand in hand.

00:57:57.790 --> 00:58:00.030
The filesystem is fast,
but if you use it less,

00:58:00.030 --> 00:58:01.440
it's better for everybody.

00:58:01.610 --> 00:58:03.820
Use our APIs.

00:58:03.910 --> 00:58:05.200
We are always going to
be making them better.

00:58:05.200 --> 00:58:08.190
And beware of unexpected delays.

00:58:08.330 --> 00:58:10.840
Don't do UI on the main thread.

00:58:11.260 --> 00:58:13.360
Thank you all for coming.

00:58:13.360 --> 00:58:16.870
I/O, I/O on the main thread.
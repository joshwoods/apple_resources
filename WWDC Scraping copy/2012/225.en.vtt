WEBVTT

00:00:10.310 --> 00:00:11.950
Welcome to the session Up and Running.

00:00:12.060 --> 00:00:12.960
My name is Jim Turner.

00:00:12.960 --> 00:00:15.570
I'm an iOS Frameworks Engineer.

00:00:17.300 --> 00:00:22.100
Application launch is a critical
point in your app's lifecycle.

00:00:22.230 --> 00:00:27.240
Users have come to expect a really
great experience from our apps,

00:00:27.370 --> 00:00:31.760
and they start forming opinions about
your app from the moment they launch it.

00:00:31.870 --> 00:00:34.240
Now, when you fail to deliver
on that experience,

00:00:34.370 --> 00:00:35.490
they tend to notice.

00:00:35.620 --> 00:00:38.060
They write bad reviews,
they delete your app,

00:00:38.160 --> 00:00:41.490
and that's certainly not
what we want our users to do.

00:00:42.550 --> 00:00:44.600
Now,
this talk could talk about a whole bunch

00:00:44.600 --> 00:00:48.370
of different things that we could do
to help your apps launch performance.

00:00:48.400 --> 00:00:51.040
But today we're going to
focus on a single method,

00:00:51.180 --> 00:00:54.840
and that is application did
finish launching with options.

00:00:54.920 --> 00:00:59.040
And focusing also on
the topic of blocking,

00:00:59.100 --> 00:01:02.660
blocking the process,
blocking a thread or a queue,

00:01:02.730 --> 00:01:06.880
or even blocking the user from
even using the application at all.

00:01:07.340 --> 00:01:09.240
When it comes to getting
your app up and running,

00:01:09.350 --> 00:01:13.140
blocking is really what you
want to avoid at all costs.

00:01:13.220 --> 00:01:16.990
So to help with this today,
Brandon's written -- my co-presenter

00:01:16.990 --> 00:01:19.640
Brandon has written a really
great application that's going

00:01:19.640 --> 00:01:21.530
to augment our conversation.

00:01:21.620 --> 00:01:24.520
It's going to focus on a lot of the
topics that we want to talk about,

00:01:24.760 --> 00:01:28.510
and I'd like to have him come up on
stage right now and show it to you.

00:01:32.700 --> 00:01:33.800
Hi, everyone.

00:01:33.900 --> 00:01:37.800
My name is Brandon Newendorp,
and I'm an iOS software engineer.

00:01:37.900 --> 00:01:41.360
To help us talk about application
did finish launching with options,

00:01:41.390 --> 00:01:44.840
I've put together a really
great demo application.

00:01:44.900 --> 00:01:48.030
I've tried to think about the
things that are common tasks a lot

00:01:48.030 --> 00:01:51.600
of you do in your applications and
tried to build them into my app.

00:01:51.650 --> 00:01:53.860
I called it Quick Pick,
and it's an application

00:01:53.860 --> 00:01:56.720
for social photo sharing,
and I'd like to show it to you now.

00:01:56.990 --> 00:01:58.100
I have it running on my phone here.

00:01:58.100 --> 00:02:00.440
You can see I have this
lovely eggplant icon.

00:02:00.510 --> 00:02:02.590
Let's just go ahead and launch it.

00:02:02.650 --> 00:02:03.760
Interesting.

00:02:03.830 --> 00:02:06.230
All right,
I'm going to find some crash logs.

00:02:06.610 --> 00:02:08.480
Give me a second.

00:02:08.710 --> 00:02:11.840
So I found a crash log,
a couple of them since I crashed twice,

00:02:11.970 --> 00:02:13.740
and I see a couple things
that are interesting.

00:02:13.980 --> 00:02:16.900
I have this exception
code of ate bad food,

00:02:17.060 --> 00:02:20.490
and the reason is that my
application failed to launch in time.

00:02:20.590 --> 00:02:22.300
This is not good.

00:02:22.740 --> 00:02:24.000
You know what that is, Brandon?

00:02:24.050 --> 00:02:25.080
That's the watchdog.

00:02:25.260 --> 00:02:28.590
The watchdog is a timer that's
used by iOS to monitor your

00:02:28.590 --> 00:02:32.550
application's launch times,
how quickly it responds to system events,

00:02:32.590 --> 00:02:37.600
and how quickly and how timely it can be
terminated or put into the background.

00:02:37.600 --> 00:02:40.460
Now, the amount of time that we actually
document -- we don't actually

00:02:40.500 --> 00:02:43.590
document the amount of time that we
give you to launch your application,

00:02:43.620 --> 00:02:47.600
but we highly recommend that you get
it launched in five seconds or less.

00:02:47.600 --> 00:02:51.500
And that's really not a lot of time,
if you think about it,

00:02:51.520 --> 00:02:55.820
especially if you're trying to
do a lot of network communication

00:02:55.910 --> 00:02:59.410
or complex computation,
especially at startup.

00:03:00.300 --> 00:04:14.900
[Transcript missing]

00:04:15.300 --> 00:04:16.460
We make some network calls.

00:04:16.460 --> 00:04:18.740
We are a social photo
sharing application,

00:04:18.740 --> 00:04:21.790
so we're going to talk to
at least one or two servers.

00:04:22.890 --> 00:04:26.840
There is a couple databases we
maintain for our geotagging and

00:04:26.850 --> 00:04:29.390
our comments done on photos.

00:04:30.610 --> 00:04:34.420
We have a couple thousand templates
and default photos that we need to

00:04:34.420 --> 00:04:39.420
install in the application documents
directory when the app starts up,

00:04:39.420 --> 00:04:41.820
and we want to make
those available to the

00:04:42.910 --> 00:04:46.180
There's an external library that
we employ that adds some imaging

00:04:46.180 --> 00:04:50.730
post-processing that needs an
initialization routine called on it.

00:04:50.840 --> 00:04:53.280
And finally, there's a couple other
odds and ends that we do,

00:04:53.370 --> 00:04:54.940
like starting up a Core Location Manager.

00:04:54.940 --> 00:04:57.990
We also use an IAD banner,
and we also look at what other

00:04:58.050 --> 00:04:59.690
options are passed to us.

00:05:00.100 --> 00:06:05.300
[Transcript missing]

00:06:05.570 --> 00:06:07.460
Like Brandon is.

00:06:07.490 --> 00:06:10.210
So we really only care about
Objective C in this call,

00:06:10.230 --> 00:06:12.870
and we're spending 90% of
our time in app launch.

00:06:12.970 --> 00:06:15.410
So we'll just drill down here.

00:06:15.960 --> 00:06:16.800
Oh, okay.

00:06:16.800 --> 00:06:19.360
UI application under load
main nib file name bundle.

00:06:19.360 --> 00:06:20.250
That's one of our methods.

00:06:20.310 --> 00:06:22.760
That's saying that we're trying
to load your main interface file.

00:06:22.760 --> 00:06:23.520
Could you show it to me?

00:06:23.840 --> 00:06:26.360
Yeah,
I just have one zip for my application.

00:06:26.420 --> 00:06:27.600
I just thought it was
kind of straightforward.

00:06:27.600 --> 00:06:30.830
So here's my app's nib.

00:06:32.500 --> 00:06:35.980
Okay, so clearly we need to talk
about interface loading.

00:06:36.100 --> 00:06:39.340
Most developers create their
interface graphically using

00:06:39.340 --> 00:06:41.100
the interface builder in Xcode.

00:06:41.230 --> 00:06:44.100
And if you're not,
we highly recommend it because it really

00:06:44.100 --> 00:06:46.700
does ease the creation of creating a UI.

00:06:46.800 --> 00:06:49.300
You get to see what your
users are going to see,

00:06:49.450 --> 00:06:53.000
and if you don't like it,
it allows for a lot of exploration and

00:06:53.000 --> 00:06:56.720
experimentation with things that you
can do in the UI that represents the

00:06:56.720 --> 00:07:00.010
data you're trying to get displayed.

00:07:00.740 --> 00:07:02.940
It also reduces a lot of code.

00:07:03.200 --> 00:07:06.160
Those of you who do create
your code programmatically,

00:07:06.220 --> 00:07:08.720
it's perfectly fine that you do that.

00:07:08.780 --> 00:07:12.160
But a nib can really get rid
of all that code that can be

00:07:12.240 --> 00:07:15.060
tedious and sometimes problematic.

00:07:15.060 --> 00:07:18.560
But zips play by a couple of rules
that everyone needs to be aware of.

00:07:18.560 --> 00:07:21.040
And the first being,
and the most important,

00:07:21.070 --> 00:07:22.990
is that no matter what
you put in that zip,

00:07:22.990 --> 00:07:25.570
we have to instantiate
the entire object graph,

00:07:25.570 --> 00:07:28.330
even if you only need one
or two parts out of it.

00:07:28.330 --> 00:07:31.090
And because this is all
dealing with user interface,

00:07:31.090 --> 00:07:32.360
this all happens on the main queue.

00:07:32.360 --> 00:07:34.940
And when you're doing this when
you're trying to launch your app,

00:07:34.940 --> 00:07:37.810
the watchdog kills you.

00:07:37.970 --> 00:07:42.440
And there's also some other subtle
side effects that can come into

00:07:42.440 --> 00:07:46.400
using a nib or a zib that some
people don't -- it's not obvious.

00:07:46.450 --> 00:07:50.030
Is that if you have an object
inside that zib that has an

00:07:50.110 --> 00:07:54.190
expensive initialization routine,
you're going to pay the penalty

00:07:54.200 --> 00:07:56.700
for that time as well when
you instantiate that nib,

00:07:56.700 --> 00:08:01.890
because we have to initialize that
nib or that object at the same time.

00:08:02.390 --> 00:08:03.870
So how do we fix this problem?

00:08:03.870 --> 00:08:06.360
Well,
there's two solutions that we can do.

00:08:06.360 --> 00:08:09.410
And the first is to throw
more zips at the problem.

00:08:09.750 --> 00:08:13.630
When you create your user
interface using multiple zips,

00:08:13.630 --> 00:08:15.900
you need to focus on lazy loading.

00:08:15.900 --> 00:08:20.250
Put into your nibs only that what
you'll need when you load the nib.

00:08:20.250 --> 00:08:24.600
So if you only need a table view
controller or a tab view controller,

00:08:24.600 --> 00:08:27.030
or maybe you only need a table view cell,
don't put a bunch of other

00:08:27.140 --> 00:08:29.980
stuff in there because,
again, you're going to have to

00:08:29.980 --> 00:08:31.340
load all of that code.

00:08:31.340 --> 00:08:33.300
So in Brandon's case,
we could maybe take that

00:08:33.300 --> 00:08:36.610
really complicated zip,
break it into six or seven files,

00:08:36.610 --> 00:08:40.500
and we load a much smaller
part of it at app launch.

00:08:40.820 --> 00:08:42.670
The second way is to use storyboards.

00:08:42.680 --> 00:08:46.300
And storyboards are actually the
preferred way of creating your

00:08:46.310 --> 00:08:50.620
user interface because it abstracts
and handles a lot of the issues

00:08:50.620 --> 00:08:52.830
we just pointed out with ZIBS.

00:08:52.940 --> 00:08:55.840
They're perfectly fine and
they're perfectly happy to

00:08:55.840 --> 00:09:00.660
allow you to create your entire
user interface in a single file.

00:09:00.780 --> 00:09:05.290
And they get to do that because both the
tools and the framework have really deep,

00:09:05.360 --> 00:09:09.400
intimate knowledge of how a storyboard
is actually built and constructed and

00:09:09.400 --> 00:09:12.120
how it wants to be unpacked at runtime.

00:09:12.660 --> 00:09:15.750
If you use Storyboards,
it really will simplify your

00:09:15.750 --> 00:09:18.900
user interface creation,
and it allows you to not worry

00:09:18.900 --> 00:09:22.870
about the implementation details of
how you're going to get your UI on

00:09:22.870 --> 00:09:25.510
screen when your application runs.

00:09:25.700 --> 00:09:29.060
It sounds like Storyboards would be
a fantastic tool for my application,

00:09:29.290 --> 00:09:31.700
because I have a pretty
complicated user interface.

00:09:31.850 --> 00:09:33.600
There's a lot going on there.

00:09:33.600 --> 00:09:37.680
But I'd really like to get my demo
application working for the talk today,

00:09:37.790 --> 00:09:41.600
so I think I'll migrate to
Storyboards in the next week or two.

00:09:41.860 --> 00:09:44.810
What I'd like to do right now
is take a couple key parts of

00:09:44.860 --> 00:09:48.650
my application's interface and
migrate them over to separate zips,

00:09:48.890 --> 00:09:51.600
just to get things up and running
nice and quickly right now.

00:09:51.610 --> 00:09:53.600
That's a good idea, Brandon.

00:09:53.600 --> 00:09:56.470
So once again, this is my application's
main zip right now.

00:09:57.010 --> 00:10:00.540
There's a lot going on here,
but there's really only two pieces

00:10:00.540 --> 00:10:03.490
that I have to have in order
to get my application launched.

00:10:03.760 --> 00:10:08.080
And that's really the key part,
is to think about what do I need

00:10:08.090 --> 00:10:10.330
just to launch my application.

00:10:10.650 --> 00:10:12.940
I need to have this table view,
and I need to have the

00:10:12.940 --> 00:10:14.600
corresponding table view cell.

00:10:14.600 --> 00:10:19.470
So I'm going to migrate each
of these into their own zips.

00:10:20.700 --> 00:10:23.160
Going to make a couple of
new zips for my project.

00:10:23.310 --> 00:10:25.900
Start off with empty ones.

00:10:26.020 --> 00:10:31.030
And first I'll create a
QP photo table view cell.

00:10:32.900 --> 00:10:36.700
Create the one that
I incidentally had around already.

00:10:36.780 --> 00:10:40.990
And we'll go ahead and make a second
one here for the QP Photo Table View.

00:10:45.250 --> 00:10:48.040
One of the convenient things
that we have in Interface Builder

00:10:48.130 --> 00:10:52.340
is the ability to cut and paste
objects from one zip into another,

00:10:52.340 --> 00:10:56.270
which is going to help me get this
process done nice and quickly.

00:10:56.890 --> 00:11:00.940
All I need to do is I'm going to cut
my table view out of one and move

00:11:00.940 --> 00:11:03.960
it into the QP photo table view.

00:11:04.160 --> 00:11:08.230
I'll go back to my view controller
and I'll grab that cell and simply

00:11:08.230 --> 00:11:10.230
paste that into the new ZIB.

00:11:10.420 --> 00:11:13.690
Now I've moved them into ZIBs,
but I need to do a little bit

00:11:13.690 --> 00:11:16.660
more work before I can actually
have my application use them.

00:11:16.710 --> 00:11:20.260
My app needs to know to
actually use these new ZIBs.

00:11:20.330 --> 00:11:23.970
It's very straightforward for
me to get my application to use

00:11:23.970 --> 00:11:26.140
a default ZIB when it launches.

00:11:26.200 --> 00:11:30.660
If I pick my Xcode project,
I can select my target and go to Summary,

00:11:30.740 --> 00:11:35.540
and change my application's main
interface to the QP Photo Table View.

00:11:35.710 --> 00:11:40.060
This is how Xcode defines what ZIB to
load when my application launches.

00:11:40.160 --> 00:11:43.660
And now it will just load that nice,
lightweight table view.

00:11:43.750 --> 00:11:48.120
I also need to update my
table view to use the cells.

00:11:48.300 --> 00:11:51.230
And there's a couple interesting things
that we can do to make that happen.

00:11:51.320 --> 00:11:55.740
I'm going to take advantage
of UINib to make this happen.

00:11:55.860 --> 00:11:59.390
So first,
I need to make a UINib property.

00:11:59.580 --> 00:12:01.260
Pretty straightforward.

00:12:01.380 --> 00:12:04.820
In my viewDidLoad, I need to do a little
bit of setup for this.

00:12:05.200 --> 00:12:09.700
The first thing I need to do is
assign that property to my nib.

00:12:09.700 --> 00:12:12.200
UINib has a method, nibWithNibName.

00:12:12.260 --> 00:12:15.690
I'm going to tell it to access my
QP Photo Table View cell and to look for

00:12:15.690 --> 00:12:18.410
that in my application's main bundle.

00:12:18.520 --> 00:12:21.320
The second thing here,
the second line is one of the really

00:12:21.320 --> 00:12:23.340
interesting bits that we offer.

00:12:23.340 --> 00:12:26.100
In iOS 5,
we added the ability for your table

00:12:26.100 --> 00:12:31.820
views to have a template cell that you
can assign a cell reuse identifier.

00:12:32.070 --> 00:12:35.010
And this actually simplifies
part of your table view code.

00:12:35.080 --> 00:12:38.880
In my case, I'm going to tell my table
view to register this nib.

00:12:38.880 --> 00:12:42.120
The key thing with registering
the nib is I can only have

00:12:42.120 --> 00:12:44.830
a single item in that nib,
my table view cell.

00:12:47.190 --> 00:12:50.020
Now,
I mentioned that this simplifies things.

00:12:50.020 --> 00:12:52.310
If I take a look at my
cell for RowIt index path,

00:12:52.610 --> 00:12:55.230
if you've ever used a table view,
I'm sure you're familiar

00:12:55.230 --> 00:12:56.200
with this method.

00:12:56.330 --> 00:12:58.540
And this bit of code
probably looks familiar.

00:12:58.600 --> 00:13:01.100
You dequeue a reusable
cell with identifier.

00:13:01.190 --> 00:13:03.660
If it's nil, you create a new one.

00:13:03.800 --> 00:13:09.130
The advantage of assigning that nib to my
table view is I can delete all of that,

00:13:09.250 --> 00:13:12.000
and the dequeue reusable
cell with identifier will

00:13:12.000 --> 00:13:16.480
automatically reuse a cell for me or
instantiate a new one from my nib.

00:13:16.700 --> 00:13:20.550
It's incredibly straightforward,
and this makes my application's

00:13:20.550 --> 00:13:22.990
interface loading occur much faster.

00:13:23.030 --> 00:13:25.390
All right, so what are the changes
that Brandon just made?

00:13:25.430 --> 00:13:28.500
What do they look like to the watchdog?

00:13:29.130 --> 00:13:32.350
We've reduced the amount of
time that we're spending in

00:13:32.350 --> 00:13:34.340
interface loading by quite a bit.

00:13:34.340 --> 00:13:36.330
But we're still incredibly long on time.

00:13:36.350 --> 00:13:37.740
There's no way our app's
going to launch still.

00:13:37.740 --> 00:13:41.380
So let's go right into
handling network communication.

00:13:42.520 --> 00:13:46.160
When your application is talking to
a server or service over the network,

00:13:46.190 --> 00:13:50.370
it's really easily defined as
you're writing in undefined

00:13:50.370 --> 00:13:52.090
behavior into your app.

00:13:52.200 --> 00:13:56.790
We can code as defensively as we
possibly can around every conceivable

00:13:56.790 --> 00:14:01.240
idea or problem or situation that our
network communication can get into,

00:14:01.240 --> 00:14:04.360
but there's still going to be
three things we didn't think about.

00:14:04.480 --> 00:14:07.050
And when you're programming
in the face of this,

00:14:07.050 --> 00:14:10.900
and when you're trying to get your
app launched in front of the user,

00:14:11.000 --> 00:14:14.660
you really want to focus on what's
going to block and what's going to

00:14:14.660 --> 00:14:17.400
remain usable while this is happening.

00:14:17.830 --> 00:14:21.240
And this actually applies to any kind
of synchronous method or behavior

00:14:21.240 --> 00:14:23.840
that you find in your application.

00:14:23.840 --> 00:14:28.870
So let's take a look at some basic
networking code that one app could

00:14:28.880 --> 00:14:31.400
actually do when it launches.

00:14:31.500 --> 00:14:33.460
And here it's nothing exciting.

00:14:33.460 --> 00:14:37.300
We have an NSXML parser that's
doing init with contents of URL.

00:14:37.340 --> 00:14:41.080
And init with contents of
URL is a blocking call.

00:14:41.120 --> 00:14:44.270
If this is happening on the main queue,
we're going to block until

00:14:44.270 --> 00:14:45.920
it returns an answer.

00:14:45.920 --> 00:14:48.440
Any method that has the name with
contents of URL in it is a really

00:14:48.930 --> 00:14:52.570
good indication that it's implemented
synchronously under the hood and

00:14:52.570 --> 00:14:54.590
it needs to be used with caution.

00:14:54.770 --> 00:14:57.720
Same goes for NSData,
data with contents of URL.

00:14:57.720 --> 00:15:02.550
And also the same for NSURL connection,
send synchronous request,

00:15:02.580 --> 00:15:03.640
returning response error.

00:15:03.640 --> 00:15:04.600
It's right in the name.

00:15:04.600 --> 00:15:06.560
It's synchronous.

00:15:06.930 --> 00:15:11.860
Another way of thinking about this is,
imagine that you on app launch have

00:15:12.330 --> 00:15:15.150
some files that you'd like to download,
and you start downloading

00:15:15.300 --> 00:15:18.180
your current info data,
but all these other files are

00:15:18.180 --> 00:15:19.920
waiting for you to download.

00:15:20.230 --> 00:15:25.400
These are going to take a long time,
especially in a bad network conditions,

00:15:25.470 --> 00:15:26.460
and your app's never
going to get launched,

00:15:26.510 --> 00:15:29.580
especially if this is
happening on the main queue.

00:15:30.760 --> 00:15:33.440
So the first approach to trying
to solve this problem would be to,

00:15:33.610 --> 00:15:37.200
well, if I'm blocking the main queue,
I'll just unblock it.

00:15:37.230 --> 00:15:39.410
Dispatch async puts it
in a background queue,

00:15:39.500 --> 00:15:41.550
and the problem goes away, right?

00:15:41.730 --> 00:15:43.880
Well, not exactly.

00:15:45.190 --> 00:15:48.390
While you have maybe solved the problem
of the main queue being blocked,

00:15:48.540 --> 00:15:50.550
the issue still remains.

00:15:50.680 --> 00:15:54.240
We'll put this in the background queue,
and now the user is able to use your app,

00:15:54.240 --> 00:15:57.100
but what actually happens in this case?

00:15:57.210 --> 00:16:00.740
Your current info gets downloaded,
but this JSON file is coming from a

00:16:00.740 --> 00:16:02.890
server that is just getting buried.

00:16:03.000 --> 00:16:09.160
It's responding incredibly slow,
but it's going to take it

00:16:09.160 --> 00:16:09.160
hours to get that data down.

00:16:09.840 --> 00:16:13.180
Your other parts of your application are
not going to be functioning correctly

00:16:13.460 --> 00:16:16.810
if they depend on the image data or
maybe a Twitter feed being pulled,

00:16:17.030 --> 00:16:20.100
because it's never going
to get that information.

00:16:20.690 --> 00:16:24.000
Okay, so if each individual part
needs to be asynchronous,

00:16:24.000 --> 00:16:26.330
we'll just wrap each one
of them in Dispatch Async,

00:16:26.330 --> 00:16:27.110
right?

00:16:27.220 --> 00:16:28.180
And you see where this is going.

00:16:28.430 --> 00:16:29.440
Not a good idea either.

00:16:29.440 --> 00:16:31.080
And there's a couple
different reasons here.

00:16:31.350 --> 00:16:34.640
First,
you lose a lot of ability to control

00:16:34.640 --> 00:16:38.060
the resources that your device
is consuming when you do this.

00:16:38.150 --> 00:16:41.590
And second, there's no real clear way to
build dependencies between

00:16:41.590 --> 00:16:43.590
one block of work and another.

00:16:43.720 --> 00:16:45.320
And third,
when you come back in six months

00:16:45.350 --> 00:16:47.690
and you need to add code to this,
where do you put it?

00:16:47.780 --> 00:16:50.290
I mean, it gets kind of confusing.

00:16:50.510 --> 00:16:51.940
There is a much better tool.

00:16:52.190 --> 00:16:54.150
It's NSOperation.

00:16:54.250 --> 00:16:57.400
NSOperation is both asynchronous
and can be made concurrent,

00:16:57.400 --> 00:16:59.230
which,
when you're dealing with network traffic,

00:16:59.270 --> 00:17:00.400
is really what you're looking for.

00:17:00.400 --> 00:17:04.280
Things happening in a background
queue and using the device's

00:17:04.280 --> 00:17:06.390
capabilities to its fullest.

00:17:07.420 --> 00:17:12.190
You can also tune resource usage with
NSOperation through NSOperation Queue.

00:17:12.380 --> 00:17:15.200
And NSOperation Queue is an
object that just manages a

00:17:15.200 --> 00:17:18.850
light collection of operations.

00:17:19.600 --> 00:17:22.640
You can form dependencies
between each NS operation.

00:17:22.640 --> 00:17:27.400
It's trivial to create one S operation
that can't run until another operation

00:17:27.400 --> 00:17:29.480
finishes doing what it's doing.

00:17:30.400 --> 00:17:32.960
And finally,
they had the idea of cancellation.

00:17:33.080 --> 00:17:36.740
If you create an NS operation and
add it into a queue and find that

00:17:36.740 --> 00:17:40.100
before it runs or before it completes,
you don't need that information anymore,

00:17:40.100 --> 00:17:43.640
you can just go ahead and cancel it,
and you don't pay the penalty for

00:17:43.640 --> 00:17:48.530
computing that work or pulling that
information down from the network.

00:17:49.220 --> 00:17:51.190
Now, Brandon, I have to ask this.

00:17:51.250 --> 00:17:53.100
How is our networking stack looking,
QuickPix?

00:17:53.100 --> 00:17:55.600
Does it have any problems like this?

00:17:55.710 --> 00:17:58.020
We probably have quite a few problems.

00:17:58.090 --> 00:18:02.210
I had no idea that data with contents
of URL would block my main queue,

00:18:02.220 --> 00:18:04.230
and I'm using it all over the place.

00:18:04.340 --> 00:18:05.870
Excellent.

00:18:05.900 --> 00:18:08.090
That's not good.

00:18:08.200 --> 00:18:10.200
This is really important,
especially in our application,

00:18:10.200 --> 00:18:12.350
because we're so network bound.

00:18:12.360 --> 00:18:14.910
We probably should take
some time and fix it up now.

00:18:15.110 --> 00:18:17.140
That's probably a great idea.

00:18:17.230 --> 00:18:20.020
There's a number of things that
QuickPix does when I launch

00:18:20.060 --> 00:18:21.980
it that are network dependent.

00:18:22.070 --> 00:18:25.710
My application launches,
and it needs to download two JSON files

00:18:25.710 --> 00:18:28.000
for a couple of different purposes.

00:18:28.110 --> 00:18:31.100
The application also launches
and downloads eight different

00:18:31.220 --> 00:18:32.570
photos from my servers.

00:18:32.690 --> 00:18:36.560
They change on a very regular basis,
which is why I download them every

00:18:36.560 --> 00:18:38.420
time my application launches.

00:18:38.690 --> 00:18:42.660
The problem right now is that my
application is using data with contents

00:18:42.660 --> 00:18:44.990
of URL to access all of those files.

00:18:45.000 --> 00:18:48.430
And if any of my servers is slow,
that JSON file, for example,

00:18:48.500 --> 00:18:51.320
will never download,
and my app will fail the launch.

00:18:51.440 --> 00:18:55.350
I'm going to take advantage of
NSOperation and NSOperationQueue

00:18:55.350 --> 00:18:58.490
to make this better,
and I'd like to show you how that works.

00:18:58.540 --> 00:19:04.220
NSOperation and NSOperationQueue are
fantastic tools for deferring some

00:19:04.220 --> 00:19:09.040
of the stuff and getting these tasks
off of your application's main queue.

00:19:09.100 --> 00:19:12.730
We provide NSOperation as
something that you can subclass

00:19:12.730 --> 00:19:14.960
and create your own operations.

00:19:14.960 --> 00:19:19.390
I'm going to be implementing
the start method in NSOperation,

00:19:19.610 --> 00:19:22.890
which is what you should implement if
you want to make concurrent operations.

00:19:22.920 --> 00:19:27.240
I've put together a couple of NSOperation
subclasses that we'll be using,

00:19:27.420 --> 00:19:29.920
one for JSON and one for photos.

00:19:29.920 --> 00:19:34.500
I'm going to bring my
JSON operations into my project here.

00:19:35.340 --> 00:19:38.140
And I'm going to go ahead and show
you a couple of the key things

00:19:38.140 --> 00:19:40.540
in how this works for networking.

00:19:40.930 --> 00:19:45.770
This is my QP JSON operation,
and the interesting stuff here

00:19:45.840 --> 00:19:47.640
is inside my start method.

00:19:47.640 --> 00:19:52.530
I'm taking advantage of NSURL request
and NSURL connection to download

00:19:52.530 --> 00:19:56.520
these files asynchronously and
to make sure that I don't block

00:19:56.600 --> 00:20:01.070
anything and to take full advantage
of my device's networking resources.

00:20:01.070 --> 00:20:05.540
I create an NSURL request
with the URL that's passed in,

00:20:05.620 --> 00:20:08.440
and then I create an NSURL connection.

00:20:08.440 --> 00:20:12.950
The key part of this is that I don't want
to start that connection immediately.

00:20:13.040 --> 00:20:16.530
Now, you might be thinking, "Brandon,
why would you not start that right away?

00:20:16.680 --> 00:20:20.650
We want it to be fast." The next
line is the real answer to that.

00:20:20.780 --> 00:20:24.350
We need to schedule our connection
in my application's main run loop,

00:20:24.480 --> 00:20:26.230
where we call data back with it.

00:20:26.560 --> 00:20:30.470
That way, we're not blocking anything
while my URL request is out

00:20:30.470 --> 00:20:32.280
there and sending data back.

00:20:32.400 --> 00:20:35.900
Once it's scheduled,
I can start the connection.

00:20:36.290 --> 00:20:38.500
So that's what my operations look like.

00:20:38.620 --> 00:20:40.300
How can I use them?

00:20:40.430 --> 00:20:44.740
This is my application's "application did
finish launching with options" method.

00:20:44.790 --> 00:20:48.080
I have a couple of things at the top
here just to get things up and running.

00:20:48.160 --> 00:20:49.840
We'll not worry about those.

00:20:49.980 --> 00:20:53.320
But here's my JSON operations,
or rather my data with

00:20:53.320 --> 00:20:55.340
contents of URL right now.

00:20:55.480 --> 00:20:58.640
They're going to block if the
network is slow or if a server

00:20:58.780 --> 00:21:00.580
is not responding very well.

00:21:00.750 --> 00:21:04.200
So what do I need to do to
take advantage of NSOperation?

00:21:04.310 --> 00:21:08.140
The first thing I need to
have is an NSOperation queue.

00:21:08.140 --> 00:21:09.720
I'm going to create that as a property.

00:21:10.000 --> 00:21:13.840
We'll call it Operation Queue,
because I like creative names like that.

00:21:13.980 --> 00:21:17.980
I'll create,
or rather instantiate my operation queue,

00:21:17.990 --> 00:21:20.340
and since I'm using this for
a lot of processing tasks,

00:21:20.340 --> 00:21:22.920
I'll call it my processing queue.

00:21:23.740 --> 00:21:26.900
So I need to use my JSON operation.

00:21:26.980 --> 00:21:30.510
Of course, I need to import a header
before I can do anything else.

00:21:30.730 --> 00:21:33.730
And then I'm going to add my
JSON operations and just replace

00:21:33.730 --> 00:21:38.760
my data with contents of URL with
my two QP JSON operations.

00:21:38.900 --> 00:21:43.070
Each of those get initialized with a URL,
and then I simply add them

00:21:43.070 --> 00:21:44.760
to my operation queue.

00:21:44.830 --> 00:21:49.440
I'm going to do something incredibly
similar for the QP photo operation.

00:21:49.520 --> 00:21:54.590
I'll add my operations to my project
and go through those same steps.

00:21:55.220 --> 00:21:57.320
Just import the header for it.

00:21:57.420 --> 00:21:59.980
And then down here is where
I download those photos.

00:22:00.040 --> 00:22:03.200
I'm creating an array of the
URLs that I'd like to download,

00:22:03.320 --> 00:22:05.640
and then I'm just enumerating
through that array,

00:22:05.850 --> 00:22:09.800
and right now calling data with
contents of URL for each one.

00:22:09.940 --> 00:22:13.330
For the photo operation,
I'm just going to replace that

00:22:13.330 --> 00:22:16.980
for loop and create a set of
QP photo operations and add each

00:22:16.980 --> 00:22:19.230
of those to my operation queue.

00:22:19.340 --> 00:22:21.990
And with that,
I've taken my networking and

00:22:21.990 --> 00:22:26.030
used NSOperation to make it both
asynchronous and concurrent,

00:22:26.040 --> 00:22:29.320
so I can take full advantage of my
device's networking resources to

00:22:29.400 --> 00:22:33.240
download multiple files at the same
time and not blocking any of my

00:22:33.240 --> 00:22:35.940
application's queues while it's doing it.

00:22:36.030 --> 00:22:39.080
This should make my networking
for my application much better.

00:22:39.170 --> 00:22:41.900
So to recap a little bit,
what we had before was

00:22:41.900 --> 00:22:45.830
a very synchronous,
very serial process, one file at a time,

00:22:46.200 --> 00:22:49.200
happening on the main queue
and irritating our user.

00:22:49.200 --> 00:22:52.380
And now what we have is a
very asynchronous process

00:22:52.380 --> 00:22:56.720
happening concurrently,
downloading multiple files and bringing

00:22:56.790 --> 00:23:01.270
your application and its functionality
up for the user much quicker.

00:23:01.800 --> 00:23:04.240
What does this look like to the watchdog?

00:23:04.320 --> 00:23:08.290
We move all that network time to
the background processing queue.

00:23:08.790 --> 00:23:10.970
But we still have a couple
other things that we're doing.

00:23:10.980 --> 00:23:14.170
We might launch okay,
but let's -- we should probably

00:23:14.170 --> 00:23:16.370
explore what's actually going on here.

00:23:17.100 --> 00:23:20.510
These three blocks of work
are database management,

00:23:20.510 --> 00:23:24.710
our payload installation,
all those images that we need to install,

00:23:24.870 --> 00:23:27.550
and the external library that
does some image processing.

00:23:27.660 --> 00:23:33.160
These things aren't really specific to --
or not really general to any application.

00:23:33.160 --> 00:23:35.150
It's specific to what we're doing.

00:23:35.270 --> 00:23:37.540
You may do some database
management as well.

00:23:37.680 --> 00:23:40.660
But in our case, it's what we do to make
our app what it does.

00:23:40.660 --> 00:23:43.640
And so it's just basic work
that we need to get done.

00:23:43.750 --> 00:23:46.760
But it doesn't necessarily need
to be work that blocks the user

00:23:46.760 --> 00:23:49.020
from being able to use the app.

00:23:49.120 --> 00:23:51.980
If we don't have all of our
templates installed before the

00:23:51.980 --> 00:23:55.340
app is completely launched,
then, you know, maybe we don't have those

00:23:55.340 --> 00:23:56.480
available to the user.

00:23:56.710 --> 00:23:58.400
Same with, like, the external library.

00:23:58.510 --> 00:24:01.940
Since it's for image processing,
maybe that functionality isn't

00:24:02.000 --> 00:24:04.740
online until it becomes available.

00:24:06.200 --> 00:24:08.840
These tasks also represent
things that are paralyzable.

00:24:08.950 --> 00:24:11.700
The output from the external
library doesn't depend on

00:24:11.700 --> 00:24:14.640
the payload installation,
which doesn't depend on if the databases

00:24:14.640 --> 00:24:17.660
get created correctly or in time.

00:24:17.770 --> 00:24:22.290
So these are things that can happen
concurrently while your app is launching.

00:24:22.420 --> 00:24:25.450
And finally, they may actually be
dependent on the network,

00:24:25.520 --> 00:24:27.260
and we mean that in two different ways.

00:24:27.400 --> 00:24:29.900
And the first being,
the external library,

00:24:29.900 --> 00:24:33.600
since it's a static library that
we don't have the source for,

00:24:33.690 --> 00:24:36.140
we're not really quite sure what
it does in its initialization.

00:24:36.140 --> 00:24:39.350
So if it calls home to, like,
check for an update,

00:24:39.500 --> 00:24:44.570
we don't want to pay that -- we don't pay
the price for that during our app launch.

00:24:44.760 --> 00:24:48.140
And the second meaning is
that our database may need to

00:24:48.400 --> 00:24:52.100
pull down a file to properly
initialize from one of our servers.

00:24:52.120 --> 00:24:55.260
So it may need to wait until
that data is available before

00:24:55.260 --> 00:24:57.060
it can actually start itself up.

00:24:57.400 --> 00:24:59.340
So if we take a look at how
we might be able to process

00:24:59.470 --> 00:25:03.300
some of this general data,
here we have two chunks of code.

00:25:03.420 --> 00:25:06.000
And in the first,
we have a DBManager object that looks

00:25:06.000 --> 00:25:08.100
like it's going to start up a database.

00:25:08.240 --> 00:25:11.640
And it just needs to update
itself when it gets running.

00:25:11.770 --> 00:25:15.040
It has no dependencies on any
other part of the application.

00:25:15.150 --> 00:25:20.500
And the application really doesn't depend
on it being ready at any point in time.

00:25:20.620 --> 00:25:23.560
So it's in this situation that
this might actually be a really

00:25:23.560 --> 00:25:25.120
good use of DispatchAsync.

00:25:25.230 --> 00:25:27.180
If there is no dependencies,
you don't really need

00:25:27.180 --> 00:25:28.180
to put it in a queue.

00:25:28.180 --> 00:25:31.510
You just want it to get
running at some point in time.

00:25:32.090 --> 00:25:35.090
This second chunk of work, though,
is going to be slightly more problematic,

00:25:35.090 --> 00:25:37.270
and for that reason right there.

00:25:37.360 --> 00:25:40.440
In it with data,
and we got that data from our server.

00:25:40.440 --> 00:25:43.620
It's problematic because now all of
our data is coming down asynchronously

00:25:43.620 --> 00:25:45.710
and concurrently in a background queue.

00:25:45.860 --> 00:25:49.910
So how do we make sure that the
XML parser gets initialized correctly,

00:25:49.910 --> 00:25:55.020
and how do we get it started the
minute that data is available to us?

00:25:55.060 --> 00:25:56.760
Let's take a look.

00:25:57.880 --> 00:25:59.880
So let's give ourselves
an operation queue,

00:25:59.930 --> 00:26:01.300
give it a name,
and we're going to have some

00:26:01.300 --> 00:26:03.810
network operations on it already.

00:26:04.710 --> 00:26:07.640
So we need to create an operation
that encompasses the work that

00:26:07.640 --> 00:26:10.030
parsing that XML file is going to do.

00:26:10.160 --> 00:26:13.680
And so we create that operation,
but before we put it into

00:26:13.680 --> 00:26:16.530
the processing queue,
we need to create the dependency between

00:26:16.540 --> 00:26:21.740
it and the network operation that's
going to be or is downloading that data.

00:26:21.820 --> 00:26:25.230
And we do that through
the add dependency method.

00:26:25.330 --> 00:26:28.330
And once we've added that dependency,
we add our operation

00:26:28.410 --> 00:26:29.810
to our operation queue.

00:26:30.580 --> 00:26:34.580
RQ is both synchronous and concurrent,
so all these operations could

00:26:34.580 --> 00:26:37.600
happen in any order at any time.

00:26:38.360 --> 00:26:41.920
And so we can keep adding in
objects and other operations,

00:26:41.920 --> 00:26:45.970
and they can get processed
as the queue gets to them.

00:26:46.310 --> 00:26:48.590
But what happens when
this one becomes slow?

00:26:48.860 --> 00:26:49.370
Doesn't matter.

00:26:49.580 --> 00:26:51.530
We can still add other operations.

00:26:51.600 --> 00:26:53.890
They get processed in time.

00:26:54.030 --> 00:26:57.920
And when that operation -- that
operation that's slow finally completes,

00:26:58.040 --> 00:27:02.720
the operation queue will tell our parsing
XML operation to go ahead and run itself,

00:27:02.890 --> 00:27:04.750
and then it finishes.

00:27:04.990 --> 00:27:08.230
There's a lot of tasks that the demo
application does that sound a lot like

00:27:08.230 --> 00:27:10.460
the general processing you're describing.

00:27:10.550 --> 00:27:13.350
There's a lot of things that
we're doing that I think I need to

00:27:13.350 --> 00:27:17.130
make asynchronous to try to keep
getting the application launched.

00:27:17.240 --> 00:27:22.200
When I launch the demo application,
we need to create a couple of databases.

00:27:22.300 --> 00:27:24.430
One of those databases
is for local photos,

00:27:24.430 --> 00:27:26.500
and it doesn't have any dependencies.

00:27:26.660 --> 00:27:30.600
It just needs to be created,
and when we get around to finishing it,

00:27:30.600 --> 00:27:31.700
that's great.

00:27:31.800 --> 00:27:34.770
The second database, however,
does rely on networking,

00:27:35.030 --> 00:27:36.900
kind of like what Jim was talking about.

00:27:37.000 --> 00:27:39.940
If you remember when I was
creating my networking operations,

00:27:40.150 --> 00:27:42.330
there's two JSON files I download.

00:27:42.440 --> 00:27:46.340
One of those JSON files is used
to initialize that database,

00:27:46.520 --> 00:27:49.140
and I have to have it to get
that database up and running.

00:27:49.260 --> 00:27:52.370
So I'll need to do some
dependency work for that.

00:27:52.500 --> 00:29:50.300
[Transcript missing]

00:29:50.570 --> 00:29:53.600
The next is that shared photos database.

00:29:53.600 --> 00:29:56.150
And this little bit right here
makes it a little bit more

00:29:56.150 --> 00:30:00.170
complicated because it relies on
data coming down from the network.

00:30:00.320 --> 00:30:05.550
This is a great place to use NSOperation
and take advantage of dependencies.

00:30:05.770 --> 00:30:09.600
Now, for something like my networking
traffic that I was using earlier,

00:30:09.600 --> 00:30:13.050
it's great to create your own
subclasses of NSOperation to

00:30:13.050 --> 00:30:14.940
do the tasks that you need.

00:30:15.050 --> 00:30:17.570
But sometimes you need something
that's straightforward and you

00:30:17.570 --> 00:30:21.740
don't want to have a list of,
you know, 50 operations that you created.

00:30:21.780 --> 00:30:24.680
To help you with that,
we provide NSBlockOperation.

00:30:24.680 --> 00:30:27.890
NSBlockOperation is very
similar to DispatchAsync,

00:30:27.980 --> 00:30:31.430
but it gives you the capability
to do the same things you do

00:30:31.510 --> 00:30:33.580
with any other NSOperation.

00:30:33.580 --> 00:30:36.770
And I'm going to use
NSBlockOperation here.

00:30:38.230 --> 00:30:42.360
So my Shared Photos database code
needs to be loaded with the dependency.

00:30:42.410 --> 00:30:47.300
I create a block operation,
and I call block operation with block.

00:30:47.410 --> 00:30:49.850
And just like with the
dispatch async above,

00:30:49.850 --> 00:30:52.640
I put my Shared Photos
database code in there.

00:30:52.790 --> 00:30:55.550
However, the second line of code
is what makes this work.

00:30:55.780 --> 00:30:59.900
I can add the dependency on
that earlier JSON operation.

00:31:00.010 --> 00:31:04.140
With the dependency in place,
I just add it to my operation queue,

00:31:04.140 --> 00:31:05.810
and it's taken care of.

00:31:06.420 --> 00:31:10.620
The next steps in my application
launch process is to copy some

00:31:10.620 --> 00:31:14.740
assets from my applications bundle
into the documents directory.

00:31:14.870 --> 00:31:16.660
The first of those is this initial plist.

00:31:16.860 --> 00:31:20.880
It's very small, it's very lightweight,
which is fortunate because I have

00:31:20.880 --> 00:31:23.200
to have it in this launch process.

00:31:23.310 --> 00:31:26.160
It's always good to think about
what you need there and what you

00:31:26.160 --> 00:31:27.620
don't need in your launch process.

00:31:27.840 --> 00:31:31.110
If you have to have it there,
by all means, have it there.

00:31:31.380 --> 00:31:34.900
And in this case,
I'm going to leave my plist in place.

00:31:35.220 --> 00:31:38.280
The next step, however,
is copying my default images

00:31:38.320 --> 00:31:41.960
and templates and other assets
into my documents directory,

00:31:41.960 --> 00:31:43.900
and this takes a long time.

00:31:44.030 --> 00:31:47.890
This is another place
to use NSBlockOperation.

00:31:48.620 --> 00:31:53.380
Once again, I create an NSBlock operation
and call BlockOperationWithBlock.

00:31:53.460 --> 00:31:56.070
I pass in, again,
the same code I was using

00:31:56.150 --> 00:31:57.900
to copy those photos.

00:31:58.030 --> 00:32:01.030
In this case, however,
I'm taking advantage of another

00:32:01.030 --> 00:32:04.350
feature that we have on NSOperation,
which is the ability to

00:32:04.570 --> 00:32:06.040
set a completion block.

00:32:06.170 --> 00:32:10.000
The completion block is something
that we guarantee you we will call

00:32:10.100 --> 00:32:12.200
after the operation is finished.

00:32:12.320 --> 00:32:15.030
And in this case,
I want to update my application's main

00:32:15.030 --> 00:32:19.600
user interface once those photos have
been copied into the documents directory.

00:32:19.730 --> 00:32:23.710
As you may or may not know,
your application's user interface can

00:32:23.840 --> 00:32:25.930
only be updated on the main queue.

00:32:26.360 --> 00:32:28.760
I need to guarantee that
this completion block,

00:32:28.760 --> 00:32:31.700
or the task in this block,
will occur on the main queue.

00:32:31.800 --> 00:32:35.100
However, if you take a look at the
documentation for completion blocks,

00:32:35.180 --> 00:32:38.500
we say it's highly unlikely that
that completion block will be

00:32:38.500 --> 00:32:40.010
called back on the main queue.

00:32:40.130 --> 00:32:42.040
So I need to guarantee
that it will happen myself.

00:32:42.040 --> 00:32:47.140
And to do that,
I'm using performSelectorOnMainThread.

00:32:47.210 --> 00:32:50.700
I'm asking my view controller
to load the photos on the main

00:32:50.700 --> 00:32:52.880
thread in my completion block.

00:32:53.310 --> 00:32:57.450
With the completion block in place,
I once again add the operation

00:32:57.450 --> 00:32:59.400
to my operation queue.

00:32:59.930 --> 00:33:02.980
The last thing I need to do
in speeding up or improving my

00:33:02.980 --> 00:33:07.080
application's launch performance is
to initialize my external library,

00:33:07.080 --> 00:33:08.890
which I call ImageStamper.

00:33:08.990 --> 00:33:12.860
This one has no other dependencies,
so this is yet another place

00:33:13.140 --> 00:33:15.320
to use an NSBlock operation.

00:33:15.320 --> 00:33:17.840
Like before,
I create the block and simply

00:33:17.840 --> 00:33:19.840
add it to my operation queue.

00:33:19.840 --> 00:33:24.140
And now I've taken a lot of those general
processing tasks that my application

00:33:24.140 --> 00:33:26.070
had and I've made them asynchronous.

00:33:26.270 --> 00:33:28.390
I'm not blocking my
application's main queue,

00:33:28.400 --> 00:33:32.240
and hopefully this will help me get
QuickPix up and running much faster.

00:33:32.260 --> 00:33:35.890
What do those changes
look like to the watchdog?

00:33:36.850 --> 00:33:39.840
Database work is now on
the background queue.

00:33:39.990 --> 00:33:42.700
Payload, image stamping,
external library is now

00:33:42.700 --> 00:33:43.930
on the processing queue.

00:33:43.940 --> 00:33:46.340
We still have that little
sliver of payload and some other

00:33:46.340 --> 00:33:48.970
things that we're going to do,
but the watchdog isn't

00:33:48.970 --> 00:33:50.360
going to bother us anymore.

00:33:50.460 --> 00:33:53.460
But at this point in time,
you're probably thinking to yourself,

00:33:53.460 --> 00:33:55.760
you guys have now put pretty
much everything that builds

00:33:55.760 --> 00:33:58.990
up the infrastructure of my
app in a background queue.

00:33:59.090 --> 00:34:02.660
What exactly do I show that
user wellness is all happening?

00:34:02.750 --> 00:34:04.540
At least three of you thought that.

00:34:04.640 --> 00:34:05.880
This is a really good question.

00:34:06.100 --> 00:34:09.870
But it's something you can do if you
put a little forethought and planning

00:34:09.870 --> 00:34:13.470
into creating your application or
when you're refactoring your app.

00:34:13.690 --> 00:34:17.010
And how we're going to
approach this in Quick Pick is,

00:34:17.170 --> 00:34:19.570
That initial data file
that Brandon loads,

00:34:19.570 --> 00:34:22.600
that P list,
it actually has a fake database in it.

00:34:22.600 --> 00:34:26.810
It shows, you know, 10, 15,
20 entries of what the user would

00:34:26.810 --> 00:34:30.590
normally see when the app is actually
doing what it's supposed to be doing.

00:34:30.760 --> 00:34:34.000
It has no images downloaded,
so we have a very tiny default

00:34:34.000 --> 00:34:36.100
image with a question mark in it.

00:34:36.160 --> 00:34:39.520
But when the user launches this
app and they're in a cornfield

00:34:39.520 --> 00:34:44.300
somewhere and they have no networking,
they get to still use the app

00:34:44.310 --> 00:34:45.890
like we would intend them to do.

00:34:46.000 --> 00:34:49.680
They can see the functionality and
they get to actually experience

00:34:49.680 --> 00:34:53.560
what we want them to experience
instead of showing them a spinner.

00:34:53.600 --> 00:34:56.730
Then as assets get downloaded,
here maybe one of our databases

00:34:56.740 --> 00:34:59.860
has finally come online and
we've downloaded a couple images,

00:35:00.080 --> 00:35:04.350
we're going to just seamlessly load those
into the UI as they become available.

00:35:04.480 --> 00:35:06.580
If we're lucky,
the user doesn't even realize

00:35:06.580 --> 00:35:08.100
this is actually happening.

00:35:08.140 --> 00:35:10.460
And then finally,
when the entire application

00:35:10.460 --> 00:35:13.430
is up and running,
it's come online, it's fully realized,

00:35:13.550 --> 00:35:15.110
we have all of our assets in place.

00:35:15.410 --> 00:35:19.120
The application is running as we
had seen it in our development

00:35:19.880 --> 00:35:23.780
environment and our users are
ecstatic and they give us more money.

00:35:24.540 --> 00:35:25.820
But what remains?

00:35:26.040 --> 00:35:29.660
What are the other things that we do
inside Application Did Finish Launching

00:35:29.680 --> 00:35:32.780
with Options that need to stay there?

00:35:34.090 --> 00:35:35.320
Core Location.

00:35:35.440 --> 00:35:38.840
We use Core Location for
geotagging our photos.

00:35:38.840 --> 00:35:41.970
But Core Location needs to be
instantiated -- an instance,

00:35:41.970 --> 00:35:44.550
excuse me,
of Core -- see a location manager --

00:35:44.670 --> 00:35:48.300
needs to be instantiated before your
application says that it's finished,

00:35:48.420 --> 00:35:52.260
before we return from application
did finish launching with options.

00:35:52.420 --> 00:35:55.730
And this is important
because in some instances,

00:35:55.730 --> 00:35:59.770
we will launch your app in
response to a location event.

00:36:00.130 --> 00:36:02.630
And when your app says
that you're up and going,

00:36:02.860 --> 00:36:06.120
we will immediately call you
back to give you updated location

00:36:06.120 --> 00:36:07.900
coordinates and information.

00:36:07.950 --> 00:36:11.140
And if you don't have a CO location
manager configured properly,

00:36:11.140 --> 00:36:13.290
you're going to miss that information.

00:36:14.480 --> 00:36:18.190
IAD, we have a single
IAD banner view in our app,

00:36:18.240 --> 00:36:22.190
and we only create one because it doesn't
make any sense to make more than one.

00:36:22.330 --> 00:36:24.660
You're not allowed to
show more than one anyway.

00:36:24.940 --> 00:36:29.030
And if you create one and you create
it in your application startup,

00:36:29.040 --> 00:36:31.340
you can share it amongst all
the view controllers that you're

00:36:31.340 --> 00:36:33.190
going to display in your app.

00:36:33.280 --> 00:36:36.220
And by doing it this way,
the IAD framework can actually

00:36:36.220 --> 00:36:39.820
optimize and more efficiently
deliver ads to your application.

00:36:40.030 --> 00:36:43.230
We also look at what other
options are passed into us.

00:36:43.270 --> 00:36:46.570
I mean, the method name is application
did finish launching with options,

00:36:46.640 --> 00:36:48.630
so there are other things
that come along for the ride.

00:36:48.810 --> 00:36:51.940
If you have a local or
remote notification,

00:36:51.940 --> 00:36:55.510
your app is launched in
response to one of those,

00:36:55.650 --> 00:36:58.390
the options dictionary
will tell you that.

00:36:58.590 --> 00:37:03.530
If you, perchance, have a custom scheme,
if you have a URL that your app

00:37:03.530 --> 00:37:07.420
will be launched in response to,
another application on the

00:37:07.420 --> 00:37:10.920
device could launch that URL,
and you're told not only the

00:37:10.920 --> 00:37:15.020
URL that the app requested,
but the app that actually requested it.

00:37:15.140 --> 00:37:17.890
So in this way,
maybe you update your UI to better

00:37:17.890 --> 00:37:19.820
match the app that called you.

00:37:19.890 --> 00:37:22.480
Maybe you are a newsstand application.

00:37:22.480 --> 00:37:27.260
We'll launch your application in response
to the user downloading new content

00:37:27.260 --> 00:37:29.530
that you need to make available to them.

00:37:30.560 --> 00:37:32.870
And then as the teaser showed you,
there's something new in iOS

00:37:32.870 --> 00:37:35.460
6 called State Restoration.

00:37:35.460 --> 00:37:37.700
And this is a really cool tool.

00:37:37.700 --> 00:37:42.950
It allows you to save and restore where
you're at in your application so that

00:37:42.950 --> 00:37:46.490
when the user comes back into your app,
they can be immediately returned

00:37:46.490 --> 00:37:50.200
to where they left it at,
whether they're 15 view controllers down

00:37:50.270 --> 00:37:55.760
in a nav controller or they've scrolled
16 pages in a web view that you host.

00:37:55.760 --> 00:37:57.220
Really interesting tech.

00:37:57.240 --> 00:37:59.430
It's great stuff,
and I think you guys are

00:37:59.440 --> 00:38:00.810
all going to love it.

00:38:01.020 --> 00:38:04.150
But to implement it correctly,
we needed to create a

00:38:04.150 --> 00:38:06.140
new delegate method.

00:38:06.290 --> 00:38:09.360
And we're talking about it here
because this entire conversation

00:38:09.880 --> 00:38:14.190
deals with application did
finish launching with options.

00:38:15.070 --> 00:38:17.370
But we need,
State Restoration needed your

00:38:17.370 --> 00:38:21.550
application to be up and running
before it can actually do what it does.

00:38:21.640 --> 00:38:24.800
So we needed to tell you that the
application was going to be launched,

00:38:24.910 --> 00:38:28.240
so we've made it application will
finish launching with options.

00:38:28.380 --> 00:38:30.650
Small, subtle change,
but what we recommend that

00:38:30.650 --> 00:38:33.540
you're actually doing in did
finish launching with options,

00:38:33.740 --> 00:38:36.480
you simply move it into will
finish launching with options.

00:38:36.650 --> 00:38:40.320
There was a talk on this yesterday,
but Gordy's doing another talk on

00:38:40.520 --> 00:38:43.200
it tomorrow in Russian Hill at 3:15.

00:38:43.320 --> 00:38:44.330
Highly recommend you check it out.

00:38:44.400 --> 00:38:45.630
It's really great stuff.

00:38:45.900 --> 00:38:47.750
And if you can get it
in your application,

00:38:47.750 --> 00:38:49.010
your users will love it.

00:38:49.150 --> 00:38:49.840
Woohoo!

00:38:49.910 --> 00:38:51.540
It works!

00:38:51.620 --> 00:38:52.090
Okay.

00:38:52.090 --> 00:38:52.710
Hi.

00:38:52.840 --> 00:38:55.300
So, clearly Brandon's got
this thing working better,

00:38:55.300 --> 00:38:56.310
so let's give him another chance.

00:38:56.340 --> 00:38:59.970
Let's start this whole demo over again
and give Brandon a chance to show

00:39:00.040 --> 00:39:01.970
you what this application can do.

00:39:02.330 --> 00:39:03.720
So, hi, everyone.

00:39:03.830 --> 00:39:06.840
My name is Brandon Newendorp,
and I'm an iOS software engineer,

00:39:07.060 --> 00:39:11.800
a much improved iOS software engineer,
after the last 45 minutes.

00:39:11.860 --> 00:39:14.320
I've taken a lot of -- a bit
of time here in our talk,

00:39:14.320 --> 00:39:18.200
anyway, to make my application's
launch process better.

00:39:18.260 --> 00:39:21.330
I've taken some of my networking code,
and I've made that both

00:39:21.370 --> 00:39:24.510
asynchronous and concurrent,
so I don't block my main queue

00:39:24.850 --> 00:39:28.340
and take full advantage of my
device's networking resources.

00:39:28.390 --> 00:39:31.580
I've made sure that my databases
are not blocking while they load.

00:39:31.640 --> 00:39:35.900
I've made sure that I'm copying my assets
appropriately out of my application

00:39:35.900 --> 00:39:38.240
bundle into the documents directory.

00:39:38.320 --> 00:39:41.120
And while I'm doing that,
I'm making sure I update my

00:39:41.120 --> 00:39:44.610
application's interface with
interesting data as it loads.

00:39:44.850 --> 00:39:48.140
So I'd like to show you what
QuickPix is supposed to be like.

00:39:48.210 --> 00:39:52.490
About 45 minutes ago,
I tried to show you QuickPix.

00:39:52.590 --> 00:39:56.730
And this is the application launch
experience I was giving my customers.

00:39:56.780 --> 00:39:57.260
It was less than a minute long.

00:39:57.270 --> 00:39:58.010
It was a little bit
more than a minute long.

00:39:58.150 --> 00:40:00.340
Less than ideal, shall we say.

00:40:00.470 --> 00:40:02.540
Because we were hitting the watchdog.

00:40:02.690 --> 00:40:05.120
With the changes I've made,
I've put together a new

00:40:05.120 --> 00:40:06.340
version of QuickPix.

00:40:06.480 --> 00:40:10.000
You can see it launches almost
immediately and then starts

00:40:10.000 --> 00:40:11.890
populating my interface.

00:40:17.460 --> 00:40:21.160
I'm making sure that my application
takes the time to only load photos

00:40:21.240 --> 00:40:25.710
when they're requested by the user,
when they scroll, as you'll see.

00:40:25.760 --> 00:40:29.820
I've also made sure that my image
post-processing library can initialize

00:40:29.820 --> 00:40:33.170
itself so that when I want to add
a little bit of extra character to

00:40:33.190 --> 00:40:36.830
my applications or to my photos,
it's ready to go.

00:40:36.940 --> 00:40:40.120
And this is the experience I like to
give my customers with Quick Pick,

00:40:40.420 --> 00:40:42.910
and I hope you enjoyed seeing it as well.

00:40:49.200 --> 00:40:50.050
Excellent, Brandon.

00:40:50.180 --> 00:40:51.740
What was that 45 minutes ago?

00:40:51.740 --> 00:40:52.100
All right.

00:40:52.220 --> 00:40:56.040
So now that Brandon's got his application
running the way that he wants it,

00:40:56.120 --> 00:40:58.180
how is he going to prevent regressing?

00:40:58.360 --> 00:41:02.440
How is he going to prevent going back
to what we had when we started this?

00:41:02.480 --> 00:41:03.700
Well, he's going to be vigilant.

00:41:03.700 --> 00:41:07.570
And that's a really simple way of saying
is that he's going to look really hard

00:41:07.570 --> 00:41:12.660
at the work he's trying to put into any
method that involves application launch,

00:41:12.660 --> 00:41:16.290
app coming back from the foreground,
even going into the background.

00:41:16.370 --> 00:41:19.210
Anything that is launch
or launch sensitive,

00:41:19.210 --> 00:41:23.110
he needs to really make sure that
what he's putting in there is

00:41:23.850 --> 00:41:25.820
important and needs to be done then.

00:41:25.870 --> 00:41:29.000
But vigilance only gets him so far.

00:41:29.130 --> 00:41:32.400
He really needs to automate
some performance testing.

00:41:32.440 --> 00:41:35.300
We've had the UI automation
framework around for several

00:41:35.540 --> 00:41:36.830
versions of the OS now.

00:41:36.850 --> 00:41:39.060
And if you're not familiar with it,
it's a framework that allows

00:41:39.060 --> 00:41:41.920
you to simulate user input
into your application,

00:41:41.920 --> 00:41:44.920
both on the device and in the simulator.

00:41:45.300 --> 00:41:46.280
And you can pair UI automation
with the UI application.

00:41:46.280 --> 00:41:49.520
You can pair UI automation with the
same time profiler that we used.

00:41:49.570 --> 00:41:52.630
And maybe every day that you
commit code to your repository,

00:41:52.630 --> 00:41:55.560
at night you can build,
run some automation against it,

00:41:55.560 --> 00:41:58.830
and in the morning see how bad you
actually regressed or what kind

00:41:58.830 --> 00:42:00.810
of progress you actually made.

00:42:02.270 --> 00:42:05.570
And to help with this,
iOS 6 also has another new feature,

00:42:05.600 --> 00:42:07.400
and that is the Network Link Conditioner.

00:42:08.490 --> 00:42:11.120
Yeah.

00:42:15.580 --> 00:42:19.220
So most of you are clearly familiar
with this from the desktop side.

00:42:19.220 --> 00:42:21.490
But if you're not,
the network link conditioner

00:42:21.490 --> 00:42:24.830
can help you simulate both a
slow and a high latency network.

00:42:25.090 --> 00:42:29.180
And now a slow network we've all
been -- we've all experienced.

00:42:29.180 --> 00:42:31.140
But a high latency network is one that,
you know,

00:42:31.140 --> 00:42:33.810
the data may flow at a normal rate,
but it's going to take you a

00:42:33.810 --> 00:42:35.560
long time to get it started.

00:42:35.560 --> 00:42:38.430
In both cases,
your application really needs to

00:42:38.480 --> 00:42:40.240
know how to handle those situations.

00:42:40.240 --> 00:42:44.110
And using the network link conditioner,
you can test for this and make sure

00:42:44.110 --> 00:42:48.650
that your app is doing the best it can
when the network's not cooperating.

00:42:50.180 --> 00:42:53.570
So to wrap up today's session,
if there was a single thing that we

00:42:53.570 --> 00:42:56.740
wanted you to take away from this,
a single question actually,

00:42:56.790 --> 00:42:59.800
is to ask yourself any time
that you're adding code,

00:42:59.860 --> 00:43:01.600
is do I need this here?

00:43:01.850 --> 00:43:04.340
If you are in your app's launch
routine or if you're trying to

00:43:04.340 --> 00:43:08.100
add code that's going to get
initialized in through a nib,

00:43:08.230 --> 00:43:12.070
ask yourself, the code I'm adding here,
is the result of the

00:43:12.100 --> 00:43:14.430
data that comes from it,
is it really important

00:43:14.430 --> 00:43:15.920
to have it right now?

00:43:15.990 --> 00:43:18.320
If it's not,
find somewhere else to put it.

00:43:18.530 --> 00:43:21.000
Maybe you can defer
it until a later time.

00:43:21.320 --> 00:43:24.210
Maybe you can make it asynchronous.

00:43:24.690 --> 00:43:28.010
Whatever it takes to make sure
that that information gets

00:43:28.100 --> 00:43:32.070
available when it's required,
but won't block the user from doing

00:43:32.070 --> 00:43:34.190
what they want to do with your app.

00:43:35.330 --> 00:43:40.460
The network doesn't like you or
your app or your users or anybody.

00:43:40.460 --> 00:43:44.210
And it's really something that you need
to be aware of because we're becoming

00:43:44.210 --> 00:43:48.180
more and more connected to servers
and services in our applications.

00:43:48.180 --> 00:43:53.090
Becoming defensive with the network and
trying to plan for the best that you

00:43:53.090 --> 00:43:58.140
can in worse situations is the best you
can do and really got to test for it.

00:43:59.070 --> 00:44:03.230
Dispatch Async and Grand Central Dispatch
are wonderful tools,

00:44:03.230 --> 00:44:05.760
but they can get you
in trouble sometimes.

00:44:05.860 --> 00:44:10.080
They can make really easy to
understand code kind of spaghettiish

00:44:10.080 --> 00:44:15.230
and can cause problems where a better
tool may exist through NSOperation.

00:44:15.340 --> 00:44:19.100
When you're trying to solve
a problem through Asynchrony,

00:44:19.100 --> 00:44:22.800
make sure you're trying to understand
what you're trying to solve first.

00:44:23.800 --> 00:44:27.720
And finally, when your application is
launching and it finds itself

00:44:27.820 --> 00:44:31.630
in a really horrible situation,
none of the content is available,

00:44:31.710 --> 00:44:36.060
or everything that you thought was
going to be there really isn't,

00:44:36.200 --> 00:44:38.660
what can you provide to the
user to show them that this

00:44:38.770 --> 00:44:44.910
is what my application can do,
what it's going to do,

00:44:44.910 --> 00:44:45.970
and this is just an anomaly, a fluke?

00:44:46.300 --> 00:44:48.830
If you can give that to your users,
they'll stay around until

00:44:49.210 --> 00:44:52.000
the app actually gets going,
and then they'll see what you can

00:44:52.060 --> 00:44:53.940
actually do with your application.

00:44:54.050 --> 00:44:56.790
Like we mentioned before,
the related session was Saving and

00:44:56.790 --> 00:45:00.920
Restoring Application State in iOS
tomorrow in Russian Hill at 3:15.

00:45:01.150 --> 00:45:03.600
Highly recommend you check that out.

00:45:04.010 --> 00:45:08.220
For more information,
Jake Behrens is our UI frameworks

00:45:08.270 --> 00:45:10.660
evangelist from the future.

00:45:10.660 --> 00:45:13.370
He likes email,
especially ones with cats.

00:45:13.510 --> 00:45:16.740
And there is lots of
documentation and all this stuff,

00:45:16.740 --> 00:45:19.050
application delegate protocol,
storyboards,

00:45:19.050 --> 00:45:22.780
and its operation and operation queue,
and especially on state restoration.

00:45:22.930 --> 00:45:25.800
And of course,
you're already on the forums,

00:45:25.800 --> 00:45:27.700
but if you're not, go there.

00:45:27.700 --> 00:45:29.730
Lots of great conversations.

00:45:29.730 --> 00:45:32.310
And that's the slide
that says we're done.

00:45:32.310 --> 00:45:32.310
Thank you, guys.
WEBVTT

00:00:11.090 --> 00:00:14.780
Good morning and welcome to session 714.

00:00:14.780 --> 00:00:17.360
For the next hour,
myself and my colleagues Conrad

00:00:17.360 --> 00:00:20.180
and Michael are going to be
talking about protecting the

00:00:20.180 --> 00:00:25.140
user's data and the part that you,
as developers, can play in that.

00:00:25.830 --> 00:00:28.200
First of all,
a little bit about ourselves.

00:00:28.300 --> 00:00:31.460
We are all members of the
platform security team at Apple.

00:00:31.580 --> 00:00:33.870
And we really operate
up and down the stack,

00:00:33.880 --> 00:00:36.060
all the way down from
the secure bootloader,

00:00:36.110 --> 00:00:38.690
all the way up to applications
and even the cloud.

00:00:38.800 --> 00:00:43.430
But sometimes what we are always
involved is when a cryptographic

00:00:43.430 --> 00:00:45.960
key is used to protect users' data.

00:00:46.300 --> 00:00:49.820
That's technologies you've
probably come across before.

00:00:51.100 --> 00:00:54.540
We also design and build
solutions for internal clients.

00:00:54.610 --> 00:00:56.480
For example,
we were involved with designing

00:00:56.650 --> 00:00:59.700
the cryptography used by iMessage.

00:01:01.430 --> 00:01:06.130
We expose a lot of that functionality
through APIs for use by third parties,

00:01:06.130 --> 00:01:11.090
such as yourselves, security framework,
common cryptobing examples.

00:01:11.550 --> 00:01:15.350
That same functionality is also
exposed by other Apple APIs at

00:01:15.350 --> 00:01:16.460
an even higher level.

00:01:16.540 --> 00:01:20.600
For example, NSFAR Manager, CF Network,
and we're going to be pulling from both

00:01:20.670 --> 00:01:23.270
of those layers during this presentation.

00:01:23.890 --> 00:01:26.100
What are we going to talk about?

00:01:26.210 --> 00:01:28.390
We're going to look
at a common situation,

00:01:28.440 --> 00:01:32.690
which is a client app
talking to a web service.

00:01:32.880 --> 00:01:35.780
We're going to subject it
to a hostile environment,

00:01:35.780 --> 00:01:40.120
a simulated attack,
and show what can happen,

00:01:40.200 --> 00:01:44.080
talk about why that matters,
and give some simple steps that

00:01:44.080 --> 00:01:49.630
you can put in your applications to
avoid falling foul of such attacks.

00:01:50.300 --> 00:01:52.880
Some things we're not going to cover.

00:01:52.930 --> 00:01:56.050
Securing your app from exploitation,
so sandboxing, hardening,

00:01:56.060 --> 00:01:58.100
securing coding practices.

00:01:58.150 --> 00:02:02.210
These are all very important topics,
but we're going to assume that's

00:02:02.210 --> 00:02:05.490
part of your standard flow
and you're doing this already.

00:02:06.570 --> 00:02:10.180
We're also not going to touch on
cryptographic protocol design,

00:02:10.280 --> 00:02:12.940
that is,
building things from primitives such

00:02:13.060 --> 00:02:15.110
as block ciphers or hash functions.

00:02:15.320 --> 00:02:18.640
That's really very tricky
and fraught with peril.

00:02:18.870 --> 00:02:23.510
If you find you can't use our high-level
APIs to do what you want and you're

00:02:23.510 --> 00:02:27.810
resorting to building your own,
file us a bug and tell us why.

00:02:29.190 --> 00:02:32.220
We're also not going to talk
about digital rights management,

00:02:32.270 --> 00:02:36.440
because whereas we're talking
about protecting the user's data,

00:02:36.560 --> 00:02:39.630
DRM is really protecting
data from the user,

00:02:39.630 --> 00:02:42.600
and that's an entirely
different problem domain.

00:02:47.460 --> 00:02:49.910
I've used the word "user
data" a lot so far.

00:02:50.060 --> 00:02:52.090
What do I mean by that?

00:02:52.250 --> 00:02:55.740
Well, really everything is user data.

00:02:55.990 --> 00:03:02.190
The documents your application processes,
be it images, text, audio,

00:03:02.320 --> 00:03:06.270
the main thing your application does,
that's obviously user data.

00:03:06.470 --> 00:03:10.470
But also, things like credentials,
usernames and passwords.

00:03:10.470 --> 00:03:13.110
Those, as we'll talk about later,
are particularly sensitive

00:03:13.720 --> 00:03:16.760
and worthy of protection.

00:03:17.250 --> 00:03:20.630
Things like preferences,
how the user wants to configure your app.

00:03:20.950 --> 00:03:23.540
Also user data,
but things you save in preferences

00:03:23.760 --> 00:03:25.990
really should be innocuous.

00:03:27.070 --> 00:03:29.940
Then there might be other things
that don't instantly spring to mind.

00:03:30.060 --> 00:03:31.880
For example, photo metadata.

00:03:31.950 --> 00:03:35.680
In there you can have
GPS coordinates and timestamps,

00:03:35.810 --> 00:03:37.550
things like that.

00:03:38.930 --> 00:03:42.320
And even as something as
innocuous as a unique identifier,

00:03:42.320 --> 00:03:46.330
perhaps could be used to correlate a user
coming from two different IP addresses.

00:03:46.420 --> 00:03:48.190
Maybe you could geolocate them.

00:03:48.250 --> 00:03:50.630
See that a user has been traveling.

00:03:51.970 --> 00:03:56.100
So if everything is user data,
user data is everywhere.

00:03:56.220 --> 00:04:00.040
It's obviously on the device when
your application is processing it,

00:04:00.170 --> 00:04:03.720
but applications really come into
their own when they get information

00:04:03.720 --> 00:04:06.280
from the network and they send
information to the network.

00:04:06.590 --> 00:04:10.230
So we need to protect
that data in transit.

00:04:11.380 --> 00:04:14.140
If you're sending your data somewhere,
obviously it's going

00:04:14.140 --> 00:04:16.940
perhaps to your server,
and you need to make sure that it's

00:04:17.070 --> 00:04:19.680
properly protected there as well.

00:04:20.140 --> 00:04:24.590
But it can also end up off the
device through means like backup,

00:04:24.590 --> 00:04:30.080
either tethered to iTunes or, indeed,
to iCloud.

00:04:30.240 --> 00:04:32.770
And one of the advantages of
using the high-level applications

00:04:33.060 --> 00:04:35.580
is you can tell the system,
"That file is important.

00:04:35.720 --> 00:04:40.680
Please protect it." And then when we go
and do things that maybe backup the file,

00:04:40.720 --> 00:04:44.120
we can do the very best we
can to try and make sure that

00:04:44.120 --> 00:04:46.970
protection remains in place.

00:04:47.710 --> 00:04:49.960
So to demonstrate some of this,
we have put a little

00:04:50.000 --> 00:04:52.910
application together,
which we're going to be demoing,

00:04:52.910 --> 00:04:56.860
and bring on to the stage now Conrad,
who's going to talk

00:04:56.880 --> 00:04:58.730
about that application.

00:05:04.160 --> 00:05:06.000
Right, so this is our common application.

00:05:06.000 --> 00:05:09.990
It's going to be a simple media client
because that's the nicest to demonstrate.

00:05:10.110 --> 00:05:12.080
What it's going to do,
it's going to download

00:05:12.080 --> 00:05:13.500
some images off the server.

00:05:13.530 --> 00:05:16.240
The server is of course going to
ask us for authentication so that we

00:05:16.240 --> 00:05:18.000
only get access to our own pictures.

00:05:18.080 --> 00:05:20.910
And then it's going to store them
so we can also view them later

00:05:20.910 --> 00:05:22.990
when we're not on a network.

00:05:23.000 --> 00:05:26.000
Just like last year,
we want to make the source available.

00:05:26.000 --> 00:05:28.990
We haven't quite worked that out yet,
but we have some hints how you can

00:05:29.130 --> 00:05:32.170
get to it later so you can see in
more detail how it works because

00:05:32.170 --> 00:05:35.000
in the slides we're only going
to focus on the key parts of it.

00:05:35.000 --> 00:05:37.970
And it may be helpful
to see how that works.

00:05:38.010 --> 00:05:40.190
And of course,
if the demo fails miserably today,

00:05:40.190 --> 00:05:43.000
you'll be able to play it at home.

00:05:43.890 --> 00:05:46.150
So first things first,
how do we download the data?

00:05:46.190 --> 00:05:48.240
Well, we're not going to come up
with our own custom protocol.

00:05:48.240 --> 00:05:50.950
HTTP suffices here just perfectly well.

00:05:51.010 --> 00:05:57.000
And what we do is we put that in the URL,
http://ourserver,

00:05:57.040 --> 00:06:00.340
and then we hand that off to an
NSURL request to start making that

00:06:00.340 --> 00:06:02.000
request and download the data.

00:06:02.000 --> 00:06:03.700
Some of you may already
be familiar with this,

00:06:03.730 --> 00:06:06.360
but I'm going to go over it anyway.

00:06:06.760 --> 00:06:10.660
So after we have this NSURL request,
we hand this off to an NSURL connection,

00:06:10.660 --> 00:06:13.460
which is going to take this request
through the many steps that are

00:06:13.490 --> 00:06:16.390
necessary-- finding the IP address,
connecting to the server,

00:06:16.410 --> 00:06:17.800
doing a whole bunch of stuff.

00:06:17.800 --> 00:06:21.600
And sometimes it will need to call
back into us and ask us to help out,

00:06:21.600 --> 00:06:24.380
for example, with authentication,
or just to present data

00:06:24.390 --> 00:06:25.800
that was downloaded.

00:06:25.800 --> 00:06:30.800
So we're going to declare that we support
the protocol that is used for this,

00:06:30.800 --> 00:06:33.840
and within that protocol
are various callbacks,

00:06:33.840 --> 00:06:37.200
did receive data every time data appears
that can be called multiple times,

00:06:37.200 --> 00:06:39.430
or maybe the connection actually fails.

00:06:39.440 --> 00:06:42.160
We'll get a "did fail" with error,
and that'll be the end of it.

00:06:42.160 --> 00:06:45.220
But everything goes right,
then at the end we'll get the connection

00:06:45.220 --> 00:06:47.920
"did finish loading," and we'll know
that the request has now succeeded

00:06:47.920 --> 00:06:51.450
and we have what we wanted to get.

00:06:51.480 --> 00:06:54.720
So that was downloading the data,
but as I said,

00:06:54.850 --> 00:06:58.500
the server's going to authenticate,
and it's going to request authentication

00:06:58.500 --> 00:07:01.780
after the first request goes through,
and then the callback

00:07:01.780 --> 00:07:04.530
will come in and say,
like, "Hey, the server expects some

00:07:04.680 --> 00:07:05.960
authentication here.

00:07:05.960 --> 00:07:09.940
What do you want to do about it?"
So that will be the "will send

00:07:10.000 --> 00:07:13.690
request for authentication" challenge,
and at that point in time,

00:07:13.690 --> 00:07:16.700
what we'll do is we're
going to support the default

00:07:16.760 --> 00:07:20.420
authentication method in this case,
and we're going to ask the user

00:07:20.420 --> 00:07:22.810
for a username and a password,
and we're going to construct an

00:07:22.810 --> 00:07:25.990
NSURL credential out of this,
and then we're going to pass

00:07:26.090 --> 00:07:28.880
that credential back to the
sender of this challenge and say,

00:07:28.880 --> 00:07:34.390
"Use this credential for
this particular challenge."

00:07:34.920 --> 00:07:38.240
Now, one thing you can do, in this case,
we were just presenting

00:07:38.250 --> 00:07:40.220
the credential and saying,
like, "Here you go.

00:07:40.370 --> 00:07:41.300
Use this for disconnection.

00:07:41.300 --> 00:07:44.470
Don't do any caching." But there
is support in this layer to

00:07:44.570 --> 00:07:46.400
actually take care of that for you.

00:07:46.400 --> 00:07:48.700
And if you make this
credential permanent,

00:07:48.790 --> 00:07:51.800
then the layers below you will
use the default keychain classes

00:07:51.800 --> 00:07:53.780
to store this password in there.

00:07:53.870 --> 00:07:55.800
And on the desktop,
that may mean that it's also

00:07:55.800 --> 00:07:57.280
available to other applications.

00:07:57.500 --> 00:07:59.650
On iOS, I think this is relevant.

00:07:59.650 --> 00:08:03.900
It's only available to
your application itself.

00:08:03.900 --> 00:08:07.000
And then when you make connection again,
it will ask you, "Hey,

00:08:07.000 --> 00:08:09.200
do you want to use this cached
credential that I have here?"

00:08:09.200 --> 00:08:10.340
And then you can say yes.

00:08:10.420 --> 00:08:12.700
And of course,
you will still need to handle

00:08:12.700 --> 00:08:15.700
the authentication challenge,
because maybe the password is wrong

00:08:15.720 --> 00:08:17.600
and you will need to figure that out.

00:08:17.600 --> 00:08:20.500
The sample will actually
show how that works.

00:08:20.500 --> 00:08:22.900
So now it's time for the demo.

00:08:22.900 --> 00:08:26.300
The demo may be ill-fated because
we have a lot of packet loss.

00:08:26.300 --> 00:08:29.800
And, well, hopefully,
we'll get something out.

00:08:29.800 --> 00:08:32.500
So we're going to give it a shot anyway.

00:08:32.510 --> 00:08:32.980
Otherwise, I apologize.

00:08:33.090 --> 00:08:39.200
But there will be something
to be seen when you take the

00:08:39.200 --> 00:08:41.290
sample home and look at it.

00:08:42.020 --> 00:08:42.990
Coming in?

00:08:43.040 --> 00:08:43.430
No.

00:08:43.660 --> 00:08:43.760
No.

00:08:43.760 --> 00:08:44.840
I'll take from here.

00:08:44.840 --> 00:08:46.760
All right.

00:08:46.760 --> 00:08:48.970
Luckily, I have a diagram.

00:08:54.990 --> 00:08:59.500
What I was meant to be doing was
sniffing the connection between

00:08:59.540 --> 00:09:00.900
the client and the server.

00:09:01.030 --> 00:09:04.750
And I was trying to simulate
a privileged network position,

00:09:04.750 --> 00:09:08.840
perhaps another wireless user in
an unprotected wireless network.

00:09:08.930 --> 00:09:12.940
So sitting down at your local
cafe that has unprotected network.

00:09:13.020 --> 00:09:15.840
And that doesn't work when
every single person seems to

00:09:15.840 --> 00:09:17.180
have a MiFi connection on.

00:09:17.560 --> 00:09:20.820
But anyway,
and all I was doing was passively

00:09:20.860 --> 00:09:23.120
sniffing network traffic.

00:09:23.190 --> 00:09:25.280
I wasn't attempting to
do anything special,

00:09:25.280 --> 00:09:26.990
like a man-in-the-middle
attack or out poisoning.

00:09:27.260 --> 00:09:29.600
I was just looking at the packets.

00:09:29.740 --> 00:09:34.510
What I would have seen was HTTP headers.

00:09:34.870 --> 00:09:36.140
and bodies.

00:09:36.210 --> 00:09:39.080
Saving out the body
straight gave me the image.

00:09:39.090 --> 00:09:43.130
I could literally just lop off the
first few lines in a text editor,

00:09:43.350 --> 00:09:44.660
save it down, open it in preview.

00:09:44.890 --> 00:09:46.540
There was the image.

00:09:46.590 --> 00:09:49.420
Also, I could have a look at the header.

00:09:49.470 --> 00:09:54.000
And it looked, perhaps,
like there was some encryption

00:09:54.000 --> 00:09:55.600
obfuscation going on.

00:09:55.730 --> 00:09:58.720
But I could base64 decode it.

00:09:58.790 --> 00:10:02.760
And then I had the username
and password right there.

00:10:03.660 --> 00:10:05.540
Well, why does this matter?

00:10:05.740 --> 00:10:11.300
Why should I really care that I would
have been able to pull those files off?

00:10:11.870 --> 00:10:15.640
The first is that whenever
you write an application,

00:10:15.680 --> 00:10:18.980
the use to which it's going to be
put by your users should really be

00:10:18.980 --> 00:10:21.230
limited only by their imagination.

00:10:21.320 --> 00:10:23.670
You might think that your
application couldn't possibly use

00:10:23.670 --> 00:10:28.550
for anything confidential or private,
but really, it could be sensitive.

00:10:28.660 --> 00:10:30.120
You really never know.

00:10:30.290 --> 00:10:35.500
So you've got to assume it
is and protect the data.

00:10:37.040 --> 00:10:39.300
So these threats are real.

00:10:39.410 --> 00:10:42.440
Public network sniffing is easy,
as I just demonstrated.

00:10:42.600 --> 00:10:44.170
And, um...

00:10:44.950 --> 00:10:45.720
People lose devices.

00:10:45.850 --> 00:10:48.560
I checked in with Lost and Found,
and just yesterday there

00:10:48.560 --> 00:10:50.800
were three iOS devices lost.

00:10:50.800 --> 00:10:55.350
So I hope they all had passcodes and
got back to their respective owners.

00:10:56.850 --> 00:10:59.940
Also, credentials are valuable.

00:11:00.000 --> 00:11:02.200
We have special APIs to
look after credentials,

00:11:02.200 --> 00:11:05.400
that's the key chain,
and they're valuable for two reasons.

00:11:05.470 --> 00:11:09.610
The first is that getting
into a place where I can sniff

00:11:09.610 --> 00:11:11.600
a network is quite tricky.

00:11:11.680 --> 00:11:15.300
And if I have the network,
then if I have the credentials,

00:11:15.350 --> 00:11:16.900
I don't need to be on the network.

00:11:16.960 --> 00:11:19.400
As long as I have access to
that server over the Internet,

00:11:19.470 --> 00:11:22.400
I could be in my evil lair
in a volcano somewhere,

00:11:22.450 --> 00:11:24.860
pull off all the images,
and don't need to be

00:11:24.860 --> 00:11:26.650
anywhere near your network.

00:11:26.990 --> 00:11:31.180
Also, even if you're really sure
that your application,

00:11:31.300 --> 00:11:34.000
your server,
isn't holding anything valuable,

00:11:34.070 --> 00:11:38.400
I think we are all guilty of reusing
passwords on different sites.

00:11:38.400 --> 00:11:41.700
So if I can grab your password
and your credential from your app,

00:11:41.750 --> 00:11:45.290
I can then start trying it on banking
applications and more sensitive

00:11:45.830 --> 00:11:47.690
things to see if I can get in.

00:11:49.270 --> 00:11:53.030
So we're going to take the basic
application and see if we can

00:11:53.050 --> 00:11:54.450
add some more protection to it.

00:11:54.620 --> 00:11:56.360
Here's Conrad again.

00:12:02.090 --> 00:12:04.330
All right, so let's start with that
password authentication,

00:12:04.340 --> 00:12:07.100
because I think that is actually
a pretty interesting problem,

00:12:07.100 --> 00:12:10.840
and it's in the news a lot,
so it deserves some attention.

00:12:10.910 --> 00:12:11.920
So how are we going to improve this?

00:12:12.000 --> 00:12:14.840
Well, in the previous case,
you would have seen that that default

00:12:14.840 --> 00:12:17.980
authentication actually just sends the
password more or less in the clear.

00:12:18.120 --> 00:12:19.840
Now, it doesn't necessarily
have to be in the clear.

00:12:19.840 --> 00:12:23.390
It could be over an encrypted
connection using HTTPS,

00:12:23.500 --> 00:12:24.840
but I'm getting ahead of myself.

00:12:24.940 --> 00:12:27.160
Let's talk about the password
authentication in itself.

00:12:27.280 --> 00:12:30.330
We're sending this password in the clear,
so your server knows the exact

00:12:30.380 --> 00:12:35.600
password that the user is using,
and if there's an attack on your server,

00:12:35.750 --> 00:12:37.840
then that password can be lost as well.

00:12:37.980 --> 00:12:39.540
What can we do instead?

00:12:39.650 --> 00:12:41.380
Well,
there are challenge response methods,

00:12:41.510 --> 00:12:45.140
and what happens in a challenge response
method is we don't send the password.

00:12:45.140 --> 00:12:46.380
We get a challenge.

00:12:46.500 --> 00:12:51.240
We derive something, a response from this
password and this challenge,

00:12:51.240 --> 00:12:52.980
and send that as the authenticator.

00:12:53.090 --> 00:12:57.300
And the key point in that is
that that is a one-way thing.

00:12:57.300 --> 00:13:00.480
When you get the authenticator,
it will be impossible to

00:13:00.480 --> 00:13:00.480
get back to the password.

00:13:00.480 --> 00:13:06.580
It will be a lot harder than
it is to just derive it.

00:13:06.680 --> 00:13:08.720
So the easiest way to do
this in the client is,

00:13:08.720 --> 00:13:10.920
of course,
after the server has been configured

00:13:11.240 --> 00:13:16.680
in the client to refuse to do
HTTP basic and only allow HTTP digest.

00:13:17.080 --> 00:13:21.300
Now, that means in the setup case,
though, you still are sending

00:13:21.570 --> 00:13:23.160
this plain password.

00:13:23.160 --> 00:13:27.560
And when that password is being sent,
it may be sent in a better environment.

00:13:27.560 --> 00:13:31.820
And you already cut it down now because
you're only entering it once to setup,

00:13:31.910 --> 00:13:35.040
and then at a later point in time,
you will basically only be

00:13:35.040 --> 00:13:40.350
using it to access your data,
and that happens much more often.

00:13:41.760 --> 00:13:44.800
So I talked a little bit
about the derivation.

00:13:44.880 --> 00:13:47.340
One thing that this derivation,
where we go from the password

00:13:47.380 --> 00:13:50.480
and a challenge to a response,
cannot happen is if someone

00:13:50.480 --> 00:13:51.850
has a weak password.

00:13:51.970 --> 00:13:55.360
Because instead of trying to go back,
I can obviously try all, say,

00:13:55.470 --> 00:13:57.050
four-digit pins easily.

00:13:57.150 --> 00:13:59.860
And that way,
I'll get all the possible authenticators,

00:13:59.860 --> 00:14:03.060
and I can just compare those against
the one that I saw on the wire,

00:14:03.060 --> 00:14:06.140
and now I will know
what the password was.

00:14:06.650 --> 00:14:08.830
So to get beyond that,
there are some more

00:14:08.920 --> 00:14:10.530
advanced alternatives.

00:14:10.530 --> 00:14:13.400
You can get out of this game
altogether by using certificates.

00:14:13.480 --> 00:14:17.480
Now the part where the user has
to pick a password goes away,

00:14:17.550 --> 00:14:22.290
but you do have to come up
with a way to provision the

00:14:22.300 --> 00:14:25.620
device with these certificates,
and that can be tricky.

00:14:26.000 --> 00:14:29.130
The other one is SRP,
which actually avoids sending the

00:14:29.210 --> 00:14:30.830
clear password even when you sign up.

00:14:30.970 --> 00:14:34.700
It will only ever send something that
is already derived from the password,

00:14:34.870 --> 00:14:37.900
and that will make it better
so that you have a variety.

00:14:37.900 --> 00:14:41.210
When you sign up on one
site with this password,

00:14:41.550 --> 00:14:45.300
that site doesn't necessarily get the
same authenticator as another site gets,

00:14:45.300 --> 00:14:49.990
and now you have put a little bit
of a firewall between those two.

00:14:51.190 --> 00:14:53.070
So what about the data on the wire?

00:14:53.150 --> 00:14:56.340
We'd like to have it
encrypted and authenticated.

00:14:56.340 --> 00:15:01.370
So what we're going to do is we're going
to just use TLS here because it provides

00:15:01.370 --> 00:15:04.100
us with confidentiality and integrity.

00:15:04.150 --> 00:15:07.620
And the reason why we want to use this,
too, is if we don't design

00:15:07.710 --> 00:15:11.090
this protocol ourselves,
then we can just wait for it to evolve.

00:15:11.100 --> 00:15:14.240
And evolve it will because there
is no such thing as a protocol

00:15:14.310 --> 00:15:15.980
that was right the first time.

00:15:16.430 --> 00:15:17.090
Everyone has bugs.

00:15:17.180 --> 00:15:19.100
We have them, too.

00:15:19.130 --> 00:15:23.370
So as we go through and depend on TLS,
we can just wait for the system to

00:15:23.370 --> 00:15:26.100
grow up in public and fix the issues.

00:15:26.100 --> 00:15:28.800
And from the application,
there is no difference,

00:15:28.800 --> 00:15:31.100
but I just get the best
experience as I go.

00:15:32.380 --> 00:15:35.780
So the new thing that comes in
there is the server authentication.

00:15:35.820 --> 00:15:38.450
What we want in this case is before
we send the password to the server,

00:15:38.450 --> 00:15:41.840
we'd like the server to actually
establish who it is so that we know

00:15:41.840 --> 00:15:45.920
that we're not sending the password or
something someone could use as a password

00:15:46.020 --> 00:15:48.090
to another site to the wrong entity.

00:15:48.250 --> 00:15:50.060
So we'll make sure of that first.

00:15:50.110 --> 00:15:53.050
And after we've made sure of that,
then we can establish the keys

00:15:53.080 --> 00:15:55.440
and make sure that we actually
encrypt the data that is being

00:15:55.440 --> 00:15:59.630
sent to the server so that only the
client and the server can see it.

00:15:59.850 --> 00:16:03.240
Another part that you may not have
thought of before is the integrity part.

00:16:03.240 --> 00:16:06.080
And what that essentially means
is when I send data to the server,

00:16:06.300 --> 00:16:10.880
it is not impossible for an attacker
to make part of this data disappear.

00:16:10.930 --> 00:16:13.360
If he controls enough of
the network infrastructure,

00:16:13.360 --> 00:16:16.640
he can just make sure that that data
never comes out on the other side.

00:16:16.660 --> 00:16:19.870
And even though it's encrypted,
encrypted does not mean that someone

00:16:19.870 --> 00:16:23.610
cannot just take a block of ciphertext
out and just have some of it disappear

00:16:23.610 --> 00:16:27.000
without you necessarily noticing,
because when you decrypt it,

00:16:27.020 --> 00:16:28.680
how do you know that it's still intact?

00:16:28.820 --> 00:16:29.760
So that is what data integrity is.

00:16:29.760 --> 00:16:33.530
It will not be able to stop
people from truncating the data,

00:16:33.810 --> 00:16:37.190
but it will be able to tell
you that that has happened.

00:16:38.210 --> 00:16:40.200
So let's go back to
server authentication,

00:16:40.270 --> 00:16:42.810
because I glossed over the
fact with the certificates.

00:16:42.860 --> 00:16:46.900
So here we have our server,
and we run this virtual server that

00:16:46.900 --> 00:16:49.470
will identify itself as server.com.

00:16:49.630 --> 00:16:52.390
And the first thing it will need to
do is we'll find ourselves someone

00:16:52.390 --> 00:16:54.150
who can provide us with a certificate.

00:16:54.190 --> 00:16:55.630
In this case,
we're going to go to HonestAge

00:16:55.760 --> 00:16:56.690
to get us a certificate.

00:16:56.810 --> 00:17:00.000
That's going to be the authority
that's going to issue us a certificate.

00:17:00.230 --> 00:17:03.000
So the next step,
we need to generate a key.

00:17:03.070 --> 00:17:07.320
This key will allow us to
prove to everyone who we are.

00:17:07.630 --> 00:17:10.340
But then the next step will be
we'll use this key to prove to

00:17:10.340 --> 00:17:13.240
ABEs we have control over this key,
and we'll say we'd like

00:17:13.240 --> 00:17:15.200
to be known as server.com.

00:17:15.250 --> 00:17:18.720
HonestAge will do some checks and hand
us back a certificate that now says,

00:17:18.760 --> 00:17:22.550
okay, the person that uses this key,
that is server.com.

00:17:22.690 --> 00:17:24.290
So that was the setup on the server.

00:17:24.290 --> 00:17:26.680
What happens when the client comes along?

00:17:27.020 --> 00:17:30.180
Server will go ahead and present its
certificate to the client and say,

00:17:30.280 --> 00:17:31.100
like, here I am.

00:17:31.190 --> 00:17:35.050
It will use its key to prove
to the client I am the server,

00:17:35.050 --> 00:17:38.850
because the client can see, okay,
if this key matches what

00:17:38.870 --> 00:17:42.940
you sent me as proof,
then I know that you must be server.com.

00:17:42.980 --> 00:17:43.840
But how does it know that?

00:17:43.990 --> 00:17:45.840
How does the client
actually believe HonestAge?

00:17:46.050 --> 00:17:48.420
Well, the client has already been
provisioned with all of these

00:17:48.440 --> 00:17:53.080
authorities that exist around the
world that pass out certificates.

00:17:53.110 --> 00:17:57.270
And therefore, if the client happens to
have HonestAge in its list,

00:17:57.370 --> 00:18:00.320
it can see, like, hey,
this certificate was issued by HonestAge,

00:18:00.330 --> 00:18:04.100
and therefore I will trust this server,
and then it can continue to send the

00:18:04.100 --> 00:18:06.420
password and communicate with the server.

00:18:07.910 --> 00:18:12.230
So in summary, certificates contain
an identity of sorts.

00:18:12.270 --> 00:18:15.780
This can be like an email address,
but in this case it is server.com.

00:18:15.930 --> 00:18:19.680
It identifies who we are
when people connect to us.

00:18:19.980 --> 00:18:23.450
And they also contain a verification key,
because we will send some form of

00:18:23.590 --> 00:18:26.760
proof that that key can be used
to validate that we have control

00:18:26.760 --> 00:18:28.300
over the other part of this key.

00:18:28.380 --> 00:18:31.570
And therefore,
in combination with this certificate,

00:18:31.660 --> 00:18:33.170
that will prove who we are.

00:18:33.470 --> 00:18:36.520
Now, how does the client find that out?

00:18:36.880 --> 00:18:40.250
Well, there is the authority that
issued us this certificate.

00:18:40.350 --> 00:18:42.420
And how does the authority
bind these two together?

00:18:42.520 --> 00:18:45.180
Well, they do something very similar
that we did when we presented

00:18:45.230 --> 00:18:46.700
this certificate to the client.

00:18:46.750 --> 00:18:50.080
They will use their key that's
in their certificate to prove,

00:18:50.420 --> 00:18:54.500
hey, this identity, server.com,
and this key that they were using,

00:18:54.530 --> 00:18:57.770
those two belong together
and form a signature over it

00:18:57.770 --> 00:18:59.620
that can then be validated.

00:19:00.370 --> 00:19:03.320
So, with that being true,
and we have a bunch of authorities,

00:19:03.320 --> 00:19:06.530
and they all issue leaves,
we can build a whole bunch of trees,

00:19:06.550 --> 00:19:09.080
and now we have,
with just a few authorities,

00:19:09.150 --> 00:19:11.630
we can actually have a whole
bunch of entities in the world

00:19:11.730 --> 00:19:13.060
that can trust each other.

00:19:13.090 --> 00:19:17.990
But that does assume the prearranged
trust of all of these authorities,

00:19:18.060 --> 00:19:19.860
that we all trust them.

00:19:19.960 --> 00:19:21.470
So, how do we do that in a client?

00:19:21.600 --> 00:19:23.860
Because the server was a
little bit more involved,

00:19:23.880 --> 00:19:25.500
but the client, of course,
is very simple.

00:19:25.500 --> 00:19:29.260
We go from HTTP to HTS,
which actually means just do HTTP,

00:19:29.310 --> 00:19:33.060
but do it over TLS or SSL,
as you may know.

00:19:34.990 --> 00:19:35.900
So what's next?

00:19:35.900 --> 00:19:37.000
Nothing can be that simple.

00:19:37.270 --> 00:19:38.140
Well, maybe it is.

00:19:38.140 --> 00:19:41.370
If you need to connect to a variety
of servers out there and you need to

00:19:41.370 --> 00:19:44.610
actually be able to trust a whole bunch
of them that you didn't know in advance,

00:19:44.700 --> 00:19:47.140
then you're done.

00:19:47.170 --> 00:19:50.190
But imagine that you are
still testing and you don't

00:19:50.220 --> 00:19:53.130
actually want to spring for,
like, a certificate just yet.

00:19:53.250 --> 00:19:56.790
Or maybe your application will be used
in a much more limited environment

00:19:56.910 --> 00:20:00.140
where you have a specific authority in
mind that is going to issue everyone

00:20:00.140 --> 00:20:02.400
that uses this server the certificates.

00:20:02.530 --> 00:20:06.120
Well, why not in your application limit
it to that one authority so that

00:20:06.120 --> 00:20:10.900
no one else can basically generate
certificates that all the devices

00:20:10.900 --> 00:20:14.190
using this service will trust?

00:20:14.650 --> 00:20:18.400
You may also want to use authentication
with client certificates.

00:20:18.400 --> 00:20:21.340
In that case, you will handle another
authentication challenge,

00:20:21.340 --> 00:20:26.240
and you will present this certificate
during the connection that is being made.

00:20:26.750 --> 00:20:29.200
And maybe you cannot actually use TCP/IP.

00:20:29.200 --> 00:20:32.080
Maybe you have a game or something
like that and you need to actually

00:20:32.430 --> 00:20:34.300
send data in UDP datagrams.

00:20:34.300 --> 00:20:38.530
And in that case, you would use DTLS,
but now you cannot use the

00:20:38.530 --> 00:20:40.200
higher-level clients anymore.

00:20:40.200 --> 00:20:42.970
So what happens when you run
into any of these situations?

00:20:43.070 --> 00:20:46.840
Well, most of them are handled by
authentication challenges that come in,

00:20:46.840 --> 00:20:49.880
either to do specific server trust,
where you don't want to

00:20:49.880 --> 00:20:53.110
necessarily trust all of the
authorities that the device trusts,

00:20:53.200 --> 00:20:56.700
or you want to provide a
client certificate to send.

00:20:56.700 --> 00:20:59.250
In the case of DTLS,
you will have to drop one

00:20:59.250 --> 00:21:02.430
layer down to secure transport,
because there is no general

00:21:02.430 --> 00:21:03.690
server infrastructure.

00:21:03.760 --> 00:21:05.700
So for servers, this would be the same.

00:21:05.700 --> 00:21:09.200
If you wanted to set up your own
little HTTPS server within your client,

00:21:09.200 --> 00:21:12.590
you'd also be forced to use
secure transport to do that.

00:21:12.780 --> 00:21:14.700
If you look at the sample
code from last year,

00:21:14.700 --> 00:21:18.200
we actually had multiple devices
that were doing peer-to-peer sharing,

00:21:18.200 --> 00:21:21.200
and all of them had their own
little server on the device as well,

00:21:21.200 --> 00:21:24.480
where a client of the other devices
would be able to share pictures.

00:21:24.570 --> 00:21:28.000
And so you can see an example of
how to use secure transport there.

00:21:28.550 --> 00:21:33.540
So now that we've fixed up everything,
we're going to give it another shot.

00:21:33.680 --> 00:21:35.540
Going to quickly rerun the first demo.

00:21:35.540 --> 00:21:36.540
Okay.

00:21:36.650 --> 00:21:39.240
So first we're going to
go back to no security,

00:21:39.360 --> 00:21:42.590
leaving no surprises there.

00:21:42.730 --> 00:21:44.640
We're going to authenticate
because the server said,

00:21:44.640 --> 00:21:49.890
"Hey, who are you,
and which pictures are we going to see?"

00:21:53.880 --> 00:21:55.580
And there we have some pictures.

00:21:55.680 --> 00:21:58.100
I know this one is pretty.

00:21:58.100 --> 00:22:02.260
So that was the standard demo.

00:22:02.260 --> 00:22:04.100
And that is me.

00:22:05.710 --> 00:22:09.100
I successfully captured
some packets there.

00:22:09.410 --> 00:22:13.120
And two stick out as being
particularly interesting,

00:22:13.120 --> 00:22:16.050
as they have a fairly large file size.

00:22:18.010 --> 00:22:22.780
I'm just going to have a look and
see that we have an HTTP header,

00:22:22.790 --> 00:22:29.320
MIME type of JPEG,
and there's the EXIF information.

00:22:29.330 --> 00:22:32.390
A little utility that
strips out the body.

00:22:36.940 --> 00:22:39.700
And we have the image captured.

00:22:39.750 --> 00:22:43.660
We showed that from the header,
we're using HTTP.

00:22:43.760 --> 00:22:47.200
So somewhere in there is a GET request.

00:22:49.060 --> 00:22:54.630
So let's take this file and
just look at its HTTP header.

00:22:55.740 --> 00:23:00.160
This is the... what
I assume to be the password.

00:23:00.160 --> 00:23:05.900
So I'm just going to decode it,
and there is the username and password.

00:23:09.980 --> 00:23:13.130
So I'm going to remove all this
so you can tell I'm not cheating

00:23:13.190 --> 00:23:15.770
for the next part of the demo,
when Conrad is going

00:23:15.850 --> 00:23:19.650
to run the application,
but this time using digest

00:23:19.650 --> 00:23:23.270
authentication and HTTPS.

00:23:24.020 --> 00:23:27.100
So we have a cleared screen again,
and the authentication is up again.

00:23:27.230 --> 00:23:29.720
We're going to do the same thing.

00:23:39.200 --> 00:23:45.440
There are the pictures, and, well,
they're the same ones as before.

00:23:45.570 --> 00:23:47.440
Let's see what Andrew got this time.

00:23:47.650 --> 00:23:49.430
So, again,

00:23:49.570 --> 00:23:52.470
I have some files in there,
and yet again,

00:23:52.470 --> 00:23:55.440
I've got a couple which seem
like they might be a bit more

00:23:55.470 --> 00:23:59.040
interesting due to their file size.

00:23:59.190 --> 00:24:02.550
And this time, can't see anything at all.

00:24:04.340 --> 00:24:06.350
all nicely opaque to us.

00:24:06.600 --> 00:24:10.740
I'm going to assume this is TLS,
and I'm going to assume that

00:24:10.740 --> 00:24:12.010
they're using certificates.

00:24:12.170 --> 00:24:16.280
So in this stream,
I can grep and see if there's

00:24:16.280 --> 00:24:18.180
any mention of certificates.

00:24:20.200 --> 00:24:22.580
So let's look at that.

00:24:22.630 --> 00:24:25.580
All I'm demonstrating here is
that even though the main content

00:24:25.710 --> 00:24:28.890
of the connection is encrypted,
the certificate exchange at the

00:24:28.890 --> 00:24:30.740
beginning happens in clear text.

00:24:30.800 --> 00:24:33.970
So here at the top I can see
there's part of an X509 certificate

00:24:34.030 --> 00:24:38.840
in there for honest aides,
and local is indeed oversharing.

00:24:41.180 --> 00:24:48.100
So, I've been locked out of mounting
my attack over the network.

00:24:48.440 --> 00:24:53.960
So, luckily,
Conrad has left his device lying around.

00:24:55.310 --> 00:25:00.400
And I've now moved from being an attacker
on the network to an attacker who has

00:25:00.400 --> 00:25:04.100
somehow gained control of the device.

00:25:04.250 --> 00:25:08.120
So I'm going to plug it into this system.

00:25:13.540 --> 00:25:18.170
And I have something that is
simulating a forensics tool,

00:25:18.170 --> 00:25:25.610
or perhaps a jailbreak that has
been able to get file system access.

00:25:25.790 --> 00:25:28.410
And it's managed to find
some files on there.

00:25:33.660 --> 00:25:36.600
has managed to pull off the file.

00:25:36.600 --> 00:25:39.530
So I've been defeated
as a network attacker,

00:25:39.580 --> 00:25:44.100
but I have succeeded in an attacker who
has gained control of the local device.

00:25:44.100 --> 00:25:46.300
So that also is not very good.

00:25:46.300 --> 00:25:49.000
So I want to invite
Michael onto the stage,

00:25:49.000 --> 00:25:54.390
who's going to talk about how
we can secure the data at rest.

00:26:01.130 --> 00:26:04.630
So as Andrew showed you,
securing a network is fairly simple.

00:26:04.750 --> 00:26:07.790
Just add an S to the protocol.

00:26:07.860 --> 00:26:13.280
Turns out, securing the data on the
device is almost as easy.

00:26:13.950 --> 00:26:17.490
So what we do is,
without doing any kind of

00:26:17.490 --> 00:26:20.300
security on the device,
as Andrew's shown,

00:26:20.300 --> 00:26:24.500
forensics tools or jailbreaks will
allow you access to the file system.

00:26:24.620 --> 00:26:28.070
In order to prevent that,
we can adopt data protection,

00:26:28.070 --> 00:26:31.960
and that will prevent an attacker
from getting to the user's data

00:26:31.960 --> 00:26:34.780
when their device is lost or stolen.

00:26:35.840 --> 00:26:40.060
Data protection will tie the data on
the device to the user's passcode,

00:26:40.180 --> 00:26:44.430
which means it is only as strong
as the passcode your user chooses.

00:26:44.530 --> 00:26:48.190
But if a user cares about the
security of their data and they

00:26:48.200 --> 00:26:51.630
choose a strong enough password,
their data will be protected,

00:26:51.650 --> 00:26:56.940
assuming you as a developer did your job
and adopted the data protection APIs.

00:26:58.460 --> 00:27:02.590
So you might be familiar with a
technology called full disk encryption,

00:27:02.590 --> 00:27:03.900
which we have on the desktop.

00:27:04.000 --> 00:27:08.300
And data protection differs from full
disk encryption in a number of ways.

00:27:08.440 --> 00:27:13.570
First way it differs is in addition to
the user's passcode protecting the data,

00:27:13.660 --> 00:27:19.930
data protection also ties the keys
that protect your data to the device.

00:27:20.910 --> 00:27:24.400
FDE is volume-based,
data protection is file-based.

00:27:24.400 --> 00:27:29.600
The reason for that is that on iOS,
devices are almost always on.

00:27:29.620 --> 00:27:32.800
And because of that,
there's different classes of

00:27:32.800 --> 00:27:37.140
data that need to be available
to access at different times.

00:27:37.140 --> 00:27:40.120
Some data needs to be
available after first unlock,

00:27:40.120 --> 00:27:42.300
which is basically what FDE does.

00:27:42.300 --> 00:27:45.010
When you first enter your password,
your data becomes available

00:27:45.480 --> 00:27:47.540
until you power the device down.

00:27:47.540 --> 00:27:53.980
That's the lowest level of protection
on iOS for data protection.

00:27:53.980 --> 00:27:57.180
Keys remain in memory until
you power off the device.

00:27:57.470 --> 00:28:03.240
The next mode is "while unlocked," and
this is what you really want to adopt,

00:28:03.240 --> 00:28:04.760
unless you have a really
good reason not to,

00:28:04.760 --> 00:28:08.130
which is while your device is
unlocked and the user is actively

00:28:08.130 --> 00:28:12.400
accessing -- using your application,
files are available.

00:28:12.500 --> 00:28:14.340
As soon as the user
presses the lock button,

00:28:14.380 --> 00:28:16.850
guaranteed within 10
seconds after that happens,

00:28:16.960 --> 00:28:19.400
the keys are purged from memory and
the data is no longer accessible.

00:28:19.400 --> 00:28:22.240
So if your application doesn't
need to run in the background,

00:28:22.240 --> 00:28:27.590
you should be using the while
unlocked data protection classes.

00:28:27.780 --> 00:28:28.870
So how does data protection work?

00:28:29.150 --> 00:28:29.920
What do we do?

00:28:30.080 --> 00:28:33.640
So, well, to start off,
let's say we have a protected file,

00:28:33.760 --> 00:28:36.800
one of the images that
the application's using.

00:28:36.940 --> 00:28:39.840
And for each file,
at the time the file is created,

00:28:39.950 --> 00:28:42.640
the system generates a random file key.

00:28:42.810 --> 00:28:47.280
That file key protects the file,
and that file key itself is

00:28:47.280 --> 00:28:48.960
protected by a class key.

00:28:49.090 --> 00:28:53.000
Which class key protects that key is
determined by the protection class

00:28:53.000 --> 00:28:55.600
you choose in your application.

00:28:55.820 --> 00:28:59.760
Now, that class key is normally
not available in memory,

00:28:59.760 --> 00:29:02.830
and when the user first
unlocks the device,

00:29:02.840 --> 00:29:07.950
what happens is we take the device key
and the passcode that the user enters,

00:29:08.120 --> 00:29:10.910
combine those two to
generate a master key,

00:29:10.990 --> 00:29:14.230
and that master key is then
used to decrypt the class key.

00:29:14.360 --> 00:29:17.470
So what's stored on the device
when the device is locked is

00:29:17.470 --> 00:29:19.230
just a protected class key.

00:29:19.380 --> 00:29:23.300
Now, once we've decrypted the class key,
we forget the master key

00:29:23.400 --> 00:29:25.240
and the user passcode again.

00:29:25.370 --> 00:29:29.230
So the class key stays in memory
while the device is unlocked,

00:29:29.240 --> 00:29:31.680
but the keys that were used
to protect the class key are

00:29:31.740 --> 00:29:33.390
actually gone at this point.

00:29:35.250 --> 00:29:40.360
So there's a number of APIs on the
system that let you control how files

00:29:40.850 --> 00:29:43.840
are protected using data protection.

00:29:43.890 --> 00:29:48.000
The File Manager is the first one,
and there's an attribute there

00:29:48.080 --> 00:29:51.220
called NSFileProtectionKey,
for which the values all

00:29:51.220 --> 00:29:53.750
start with NSFileProtection,
and there's different variants that

00:29:53.750 --> 00:29:56.860
let you choose the different classes,
which I'll get into.

00:29:56.910 --> 00:29:59.940
CoreData uses the same name.

00:30:00.000 --> 00:30:02.960
NSData has data writing options,
so if you're using

00:30:02.960 --> 00:30:06.150
NSData to write a file,
then you can choose during the

00:30:06.150 --> 00:30:09.530
writing of the file how you
want that file to be protected.

00:30:10.040 --> 00:30:13.370
And SQLite lets you set,
at the time you open the

00:30:13.370 --> 00:30:18.040
database or create the database,
how you want the database protected.

00:30:18.200 --> 00:30:20.540
The additional thing this does
is it also protects the journal

00:30:20.650 --> 00:30:22.060
files that SQLite might create.

00:30:22.060 --> 00:30:24.500
So it's not just the database,
but any journals that are

00:30:24.500 --> 00:30:28.200
made when you're committing
transactions are also protected.

00:30:28.570 --> 00:30:31.060
And then finally,
there's the SecItem API,

00:30:31.060 --> 00:30:36.140
which is also known as the Keychain API,
that uses the KSecAdderAccessible

00:30:36.440 --> 00:30:41.870
attribute that lets you control the
protection class of keychain items.

00:30:42.630 --> 00:30:47.940
So here's an example of how you
would use the NSData interfaces to

00:30:47.940 --> 00:30:50.260
protect a file when you create it.

00:30:50.260 --> 00:30:54.760
So the example is an
Objective-C method that takes an image,

00:30:54.820 --> 00:30:57.470
and we're going to extract
the JPEG representation of the

00:30:57.470 --> 00:30:59.930
image and write that to a file.

00:31:00.020 --> 00:31:03.700
So when we do that,
all we do is we add an option that

00:31:03.700 --> 00:31:07.920
says "NSDataWriting file protection
complete." File protection complete

00:31:08.300 --> 00:31:14.130
means the file is completely protected
unless the device is unlocked.

00:31:14.250 --> 00:31:18.260
So as soon as the device is locked,
the file is completely protected.

00:31:18.310 --> 00:31:21.980
While the device is in use,
obviously the file can be accessed.

00:31:23.570 --> 00:31:28.080
So some things to keep in mind, which is,
as I mentioned earlier,

00:31:28.080 --> 00:31:31.500
data protection is only as good as
the passcode that the user uses.

00:31:31.520 --> 00:31:36.230
So if a user uses a four-digit PIN, say,
that will protect against a

00:31:36.250 --> 00:31:40.500
hardened attacker that gains
physical access to the device,

00:31:40.520 --> 00:31:43.460
if they manage to try and
brute force that password,

00:31:43.490 --> 00:31:49.500
it'll take no less than eight minutes
or so to crack a four-digit PIN.

00:31:49.500 --> 00:31:52.500
But if you have an eight-
or a ten-digit PIN,

00:31:52.500 --> 00:31:54.890
we're talking about months
versus years of time that it

00:31:54.890 --> 00:31:56.440
would take to brute force that.

00:31:56.500 --> 00:31:59.730
And that's in part because we
tie the PIN or the passcode

00:31:59.730 --> 00:32:01.500
to the device key as well.

00:32:01.500 --> 00:32:07.380
And there's no way to attack
that password offline.

00:32:07.500 --> 00:32:11.500
So now another downside is
that if you're using complete,

00:32:11.500 --> 00:32:15.490
you can't access these files
while the device is unlocked.

00:32:15.570 --> 00:32:18.500
Now if you have an application where you
need to access files in the background

00:32:18.500 --> 00:32:19.500
because you're using a computer,
you can't access these files

00:32:19.500 --> 00:32:19.500
while the device is unlocked.

00:32:19.530 --> 00:32:22.690
So if you started, say,
recording a sound file and

00:32:22.790 --> 00:32:26.500
you want to continue recording
after the device is locked,

00:32:26.540 --> 00:32:29.600
well, you wouldn't be able to use
protection complete because ten

00:32:29.600 --> 00:32:31.350
seconds after the device locked,
you wouldn't be able to

00:32:31.350 --> 00:32:32.500
write to the file anymore.

00:32:32.500 --> 00:32:37.490
So for that, we have a mode called file
protection complete unless open.

00:32:37.750 --> 00:32:41.710
And what that does is it lets you
continue to read and write from

00:32:41.830 --> 00:32:45.500
that file as long as the device --
as long as you keep that file open.

00:32:45.500 --> 00:32:48.040
It also lets you create
files in the background when,

00:32:48.040 --> 00:32:49.450
say,
you have an application that responds

00:32:49.530 --> 00:32:54.500
to a background notification while
the device is in the user's pocket.

00:32:54.640 --> 00:32:56.470
And you might,
as a result of that notification,

00:32:56.600 --> 00:32:58.780
want to go out and, you know,
fetch some file and

00:32:58.780 --> 00:33:00.490
store it on the device.

00:33:00.500 --> 00:33:02.990
If you're doing that,
you can use file protection

00:33:02.990 --> 00:33:08.390
complete until open -- sorry,
unless open to create that file.

00:33:09.990 --> 00:33:11.900
Example of this would be a data dropbox.

00:33:11.900 --> 00:33:14.620
Let's say you have an application
that accepts a connection

00:33:14.620 --> 00:33:16.560
and lets you drop in a file.

00:33:16.680 --> 00:33:17.850
So what would we do?

00:33:18.110 --> 00:33:22.320
If we're writing this image,
we'll try and first write the image

00:33:22.610 --> 00:33:25.850
optimistically with protection complete.

00:33:26.100 --> 00:33:28.410
And if that fails,
we'll just try it again,

00:33:28.490 --> 00:33:31.400
and this time write it
with complete unless open.

00:33:31.500 --> 00:33:34.680
Now, one thing we recommend you do,
if you can,

00:33:34.820 --> 00:33:41.220
is when you're back to an unlocked state,
upgrade the protection class from

00:33:41.220 --> 00:33:44.950
complete unless open to complete,
assuming you don't need to continue

00:33:44.960 --> 00:33:46.950
accessing that file in the background.

00:33:47.050 --> 00:33:50.610
And the way to do that would be,
if we have this data dropbox,

00:33:50.880 --> 00:33:55.080
we'd use the file manager API to
iterate through the directory,

00:33:55.150 --> 00:33:58.660
Then look at each file in that directory,
check its file attributes.

00:33:58.660 --> 00:34:01.760
If the protection isn't
already protection complete,

00:34:01.810 --> 00:34:06.130
we create a dictionary with an
attribute that says "file protection

00:34:06.130 --> 00:34:10.220
complete," set that attribute
on the files protection class,

00:34:10.230 --> 00:34:11.480
and we're done.

00:34:12.060 --> 00:34:18.450
So that solves the cases of accessing
files while unlocked and basically

00:34:18.450 --> 00:34:21.860
continuing to access files that
you created while the device was

00:34:21.870 --> 00:34:24.900
unlocked or created in the background.

00:34:25.120 --> 00:34:29.240
What about if you get a notification and
you need to access some database to look

00:34:29.240 --> 00:34:31.780
something up while the device is locked,
and that database might

00:34:31.850 --> 00:34:32.830
not have been opened yet?

00:34:32.900 --> 00:34:36.150
Well, for that,
we have protection complete

00:34:36.350 --> 00:34:38.840
until first user authentication.

00:34:39.080 --> 00:34:45.350
This lets you access the file as long as
the user has unlocked the device once,

00:34:45.350 --> 00:34:48.400
and you continue to access those files,
both reading and writing,

00:34:48.450 --> 00:34:50.960
until the device is powered down.

00:34:52.280 --> 00:34:55.820
This protects the data from
reboot until first unlock,

00:34:55.850 --> 00:34:59.290
which means if you leave a device
somewhere and it's powered off,

00:34:59.410 --> 00:35:01.300
or you hand it to someone
while it's powered off,

00:35:01.390 --> 00:35:02.470
they can't get to the data.

00:35:02.540 --> 00:35:07.150
It also means that a forensics tool or a
jailbreak that requires a reboot to get

00:35:07.150 --> 00:35:11.970
to the user's data still wouldn't be able
to get to data protected by this class.

00:35:12.880 --> 00:35:18.460
So because of that, it's better than just
having no protection at all.

00:35:18.460 --> 00:35:22.340
Now, here's an example of how you would
create a database that's readable

00:35:22.340 --> 00:35:26.860
and writable in the background
even when the device is unlocked.

00:35:26.880 --> 00:35:32.310
So we'd use the SQLite open API and
pass the optional parameter of open

00:35:32.310 --> 00:35:37.560
file protection complete until first
user authentication to the open call.

00:35:39.160 --> 00:35:43.340
So, the more common case for most
of you is actually going to be

00:35:43.340 --> 00:35:46.180
that you have an application
that just runs in the foreground,

00:35:46.190 --> 00:35:48.540
and you don't really want to have
to add all these attributes and

00:35:48.540 --> 00:35:50.800
things to every single API you call.

00:35:50.800 --> 00:35:53.810
It turns out there's a
really easy way to do that.

00:35:53.950 --> 00:35:56.580
You add an entitlement
to your application,

00:35:56.600 --> 00:35:59.360
the default data protection entitlement.

00:35:59.360 --> 00:36:02.220
You set its value to
NSFileProtectionComplete.

00:36:02.390 --> 00:36:05.740
And at that point,
every file you create in your application

00:36:05.740 --> 00:36:09.680
is protected with that protection class,
including files created on your behalf

00:36:09.680 --> 00:36:12.160
by frameworks you're calling or,
you know, etc.

00:36:12.470 --> 00:36:14.610
So everything you create
in your application.

00:36:14.800 --> 00:36:18.150
Now, if you have exceptions to that rule,
let's say there's some files you

00:36:18.200 --> 00:36:20.670
need to access in the background,
you can still use the

00:36:20.670 --> 00:36:25.800
APIs I showed earlier to change
the default for those files.

00:36:25.860 --> 00:36:28.900
You will need a new provisioning
profile to use this because it's

00:36:29.340 --> 00:36:31.160
not currently on by default.

00:36:31.220 --> 00:36:36.360
And to do so, you need to go to the
provisioning portal,

00:36:36.420 --> 00:36:41.110
go into the App ID section,
and check the checkbox that says "Enable

00:36:41.220 --> 00:36:46.960
for data protection." And there you get
to choose the default class you want.

00:36:47.010 --> 00:36:50.700
Now you renew your provisioning
profile or just download a new

00:36:50.810 --> 00:36:52.280
profile in the Xcode Manager.

00:36:52.510 --> 00:36:53.500
And you're done.

00:36:53.540 --> 00:36:56.280
Xcode will automatically
add the entitlement to your

00:36:56.280 --> 00:36:58.210
application when you rebuild it.

00:37:00.110 --> 00:37:03.240
So, in summary,
use NS File Protection Complete for

00:37:03.250 --> 00:37:06.550
all your applications,
unless you have a reason not to.

00:37:06.770 --> 00:37:09.780
So if you have an app,
whether it's a game or any kind of app,

00:37:09.860 --> 00:37:10.860
it doesn't matter.

00:37:11.050 --> 00:37:14.690
If it doesn't run in the background,
set this entitlement.

00:37:15.350 --> 00:37:19.200
And with that, I'd like to start talking
about the keychain.

00:37:19.390 --> 00:37:22.820
So, the keychain, you think, "Well,
now we have data protection.

00:37:22.890 --> 00:37:25.700
I can just use data protection
files to store anything,

00:37:25.700 --> 00:37:31.250
building credentials." Well,
the keychain is actually a subset

00:37:31.290 --> 00:37:35.760
of the system where we do even more
work to protect the user's data.

00:37:35.760 --> 00:37:39.490
And in particular,
in the case of backups and migratability,

00:37:39.500 --> 00:37:41.920
the keychain gives you even
more fine-grained control

00:37:41.920 --> 00:37:43.260
than data protection.

00:37:43.260 --> 00:37:46.120
So when you're dealing with
user credentials like passwords

00:37:46.230 --> 00:37:49.270
or certificates and keys,
we really recommend you use

00:37:49.270 --> 00:37:51.100
the keychain to store those.

00:37:52.650 --> 00:37:57.290
So the keychain has the same
set of data protection classes

00:37:57.440 --> 00:38:01.440
that are available to files,
and they have slightly different names.

00:38:01.440 --> 00:38:06.350
So NSFileProtectionComplete
in the keychain is called

00:38:06.350 --> 00:38:09.100
accessible when unlocked.

00:38:09.100 --> 00:38:13.340
There's not really an equivalent
of unless open for the keychain.

00:38:13.340 --> 00:38:18.200
And for complete until
first user authentication,

00:38:18.200 --> 00:38:20.880
the keychain equivalent
is after first unlock.

00:38:20.880 --> 00:38:23.500
And then there's the fourth one,
which is none,

00:38:23.510 --> 00:38:26.710
which you should just not use.

00:38:27.410 --> 00:38:32.170
Now, in addition to these,
the keychain adds three variants of this,

00:38:32.170 --> 00:38:34.950
which add "this device
only" to the end of it.

00:38:35.080 --> 00:38:38.530
And what that does is,
if you create a keychain item and you

00:38:38.710 --> 00:38:42.460
set the accessible attribute to one
of the "this device only" variants,

00:38:42.460 --> 00:38:48.280
then in a backup,
the keychain data in the backup continues

00:38:48.290 --> 00:38:52.210
to be protected by the device key,
which means that even if someone were

00:38:52.290 --> 00:38:57.260
to gain access to your keychain backup
and gain access to the backup password,

00:38:57.510 --> 00:38:59.800
they still wouldn't be able to get
the data without physical access to

00:38:59.810 --> 00:39:02.390
the device that it was backed up from.

00:39:02.500 --> 00:39:04.610
So if an attacker got your
laptop with iTunes but they

00:39:04.610 --> 00:39:07.250
didn't get your iOS device,
they still wouldn't be

00:39:07.320 --> 00:39:08.900
able to get your data.

00:39:09.010 --> 00:39:14.470
The additional feature of this is that
if you backup that keychain to one device

00:39:14.480 --> 00:39:17.410
and restore it to a different device,
those keychain items will no

00:39:17.410 --> 00:39:19.090
longer exist on the new device.

00:39:19.230 --> 00:39:22.720
And this can be useful in the case of
storing things in the keychain that you

00:39:22.720 --> 00:39:25.100
really want to bind to a particular unit
rather than having to do it on your own.

00:39:25.100 --> 00:39:25.100
Michael Brouwel, Conrad Sauerwald,
Andrew Whalley Now, in addition to these,

00:39:25.100 --> 00:39:25.100
the keychain items will no
longer exist on the new device.

00:39:25.100 --> 00:39:25.100
And this can be useful in the case of
storing things in the keychain that you

00:39:25.100 --> 00:39:25.100
really want to bind to a particular unit
rather than having to do it on your own.

00:39:25.340 --> 00:39:29.120
it move with the user as
they move to a new unit.

00:39:29.930 --> 00:39:32.140
I'm going to show you some examples
of how to use the keychain.

00:39:32.140 --> 00:39:33.730
And I know a lot of
people are intimidated,

00:39:33.730 --> 00:39:35.850
and there's lots of, like,
keychain wrappers floating

00:39:35.860 --> 00:39:36.900
around on the network.

00:39:36.900 --> 00:39:40.240
And it turns out that you don't
really need a wrapper because you

00:39:40.240 --> 00:39:44.900
really only need about 10 lines
of code to access the keychain.

00:39:45.000 --> 00:39:48.900
So to do generic password,
which we're using here,

00:39:48.900 --> 00:39:52.900
we have one common method
called queryForAccount,

00:39:52.900 --> 00:39:56.850
which will basically create
a dictionary with the class,

00:39:57.070 --> 00:40:00.610
the service, and the account for the item
that you're trying to store

00:40:00.610 --> 00:40:02.900
or look up in the keychain.

00:40:02.900 --> 00:40:05.890
And we're going to use that in the
other three methods I'll go through.

00:40:05.990 --> 00:40:08.900
So we start with the
method passwordForAccount,

00:40:08.900 --> 00:40:12.160
which is a lookup to see, you know,
can I find a password for

00:40:12.160 --> 00:40:13.880
this account in the keychain?

00:40:13.940 --> 00:40:16.900
And the way we do that is
we first create the query,

00:40:16.900 --> 00:40:19.900
and then we add one extra
attribute to that query,

00:40:19.900 --> 00:40:21.410
which is,
please return the data of the item

00:40:21.410 --> 00:40:22.740
because I want to get the password out.

00:40:22.900 --> 00:40:23.900
Amen.

00:40:24.190 --> 00:40:27.520
Then we simply call secItemCopyMatching,
which will return any items

00:40:27.520 --> 00:40:29.820
matching the query you just gave it.

00:40:29.930 --> 00:40:33.930
And if the status returned
by that is not found,

00:40:34.080 --> 00:40:36.030
we'll set the found flag to false.

00:40:36.120 --> 00:40:39.580
If it's any other status,
then we'll assume we found the item.

00:40:40.100 --> 00:40:42.100
and return the data.

00:40:42.210 --> 00:40:45.180
So, now if we didn't find the data,
we're going to need a way to

00:40:45.270 --> 00:40:46.550
add a new item to the keychain.

00:40:46.560 --> 00:40:50.200
So for that,
we created a method called "setPassword."

00:40:50.260 --> 00:40:54.550
So setPasswordForAccount will start
off using the same queryForAccount

00:40:54.550 --> 00:40:56.500
method to get the basic query.

00:40:56.590 --> 00:40:58.100
And now we're going to
add two keys to that,

00:40:58.270 --> 00:41:02.400
first one being the valueData key,
which includes the actual password

00:41:02.400 --> 00:41:04.030
data we're trying to store.

00:41:04.140 --> 00:41:06.770
And the second one would be
the accessibility attribute

00:41:06.880 --> 00:41:08.040
that we want to set.

00:41:08.140 --> 00:41:12.040
So it happens that accessibleWhenUnlocked
is the default for newly created items.

00:41:12.040 --> 00:41:15.440
So this example, you could leave off
that second attribute,

00:41:15.510 --> 00:41:17.700
but I put it here for clarity.

00:41:17.780 --> 00:41:22.430
And then we call secItemAdd to
add the item to the keychain.

00:41:23.310 --> 00:41:28.480
Now, the last case would be if you
had an item in the keychain,

00:41:28.490 --> 00:41:31.740
but it turned out the password was wrong,
we prompt the user for a new password,

00:41:31.740 --> 00:41:34.350
and now we want to update
that existing item.

00:41:34.460 --> 00:41:38.180
So for that,
we need an update password call, which,

00:41:38.190 --> 00:41:40.660
again, we start by creating the query.

00:41:40.750 --> 00:41:45.460
Then we add--we create a new dictionary,
which are the attributes that we

00:41:45.540 --> 00:41:47.430
want to change for that query.

00:41:47.690 --> 00:41:50.180
And in that dictionary, we, again,
set the data,

00:41:50.410 --> 00:41:53.180
and we set the accessibility attribute.

00:41:53.440 --> 00:41:57.180
And then we call secitemupdate with the
query and the attributes that we want to

00:41:57.250 --> 00:42:00.120
change for any items matching that query.

00:42:00.820 --> 00:42:03.890
So tying it all together,
this is what the high-level keychain

00:42:03.890 --> 00:42:05.940
wrapper code would look like.

00:42:06.060 --> 00:42:10.900
We have a login to an account method,
and we start off by looking up

00:42:10.900 --> 00:42:13.190
the password in the keychain.

00:42:13.220 --> 00:42:15.510
If we find a password,
we try and login to the

00:42:15.510 --> 00:42:17.200
account with the password.

00:42:17.200 --> 00:42:20.200
This is a method you're going to write
in your own application somewhere.

00:42:20.430 --> 00:42:23.200
And if that succeeds, we're done.

00:42:23.210 --> 00:42:25.520
If it didn't succeed,
we're going to ask the

00:42:25.610 --> 00:42:28.090
user for the password,
attempt to login with the

00:42:28.160 --> 00:42:29.700
password the user just gave us.

00:42:29.710 --> 00:42:32.830
If that succeeds, then we'll,
based on whether we previously

00:42:32.940 --> 00:42:36.290
found the item or not,
we'll either update the password or

00:42:36.290 --> 00:42:38.510
add the password to the keychain,
and we're done.

00:42:38.700 --> 00:42:40.690
And that's it.

00:42:43.410 --> 00:42:46.290
So with that,
I want to bring Andrew back on stage

00:42:46.310 --> 00:42:50.290
and see how well he fares against a
version of Conrad's application that's

00:42:50.290 --> 00:42:53.820
been hardened by using data protection.

00:42:54.110 --> 00:42:55.710
Thank you.

00:42:59.000 --> 00:43:01.910
So Conrad, the author of Naivete,
has decided he wants to

00:43:01.920 --> 00:43:03.340
adopt data protection.

00:43:03.480 --> 00:43:06.860
And he's put out an update to his app,
which has done two things.

00:43:06.920 --> 00:43:09.900
It's set the default
data protection class,

00:43:10.010 --> 00:43:14.190
but also it has a routine based on
the iteration that Michael showed,

00:43:14.260 --> 00:43:17.190
which will go and look at the
existing files in his application,

00:43:17.190 --> 00:43:20.310
in the application folder,
and upgrade them,

00:43:20.310 --> 00:43:23.830
as the default only applies
to newly created files.

00:43:23.970 --> 00:43:27.360
So, yet again,
the device is lying around,

00:43:27.420 --> 00:43:31.010
and we can see that
it has a password set.

00:43:31.110 --> 00:43:34.090
Only we can't, but it has a passcode set.

00:43:35.210 --> 00:43:38.440
I now have my forensic tool again.

00:43:38.540 --> 00:43:39.940
I'm going to run it.

00:43:40.080 --> 00:43:44.310
And this time, you see,
we have operation not permitted.

00:43:44.590 --> 00:43:48.800
It might be worth pointing out that
I can still look at the file name.

00:43:48.900 --> 00:43:51.840
It's the main data of the
file that is encrypted.

00:43:51.930 --> 00:43:56.940
The key is stored in the metadata,
along with things like the file name,

00:43:56.990 --> 00:44:02.220
last modification time,
and NAT is not protected.

00:44:02.690 --> 00:44:08.230
So I have successfully been
able to show that the latest

00:44:08.350 --> 00:44:12.000
version of the Naivete app has

00:44:12.390 --> 00:44:16.300
protected itself from network
attack and also protected itself

00:44:16.820 --> 00:44:21.570
from an attacker who has gained
physical possession of the device.

00:44:23.000 --> 00:44:28.240
So, to summarize,
we've looked at some simple ways that

00:44:28.480 --> 00:44:31.090
you can protect your customers' data.

00:44:31.460 --> 00:44:34.780
Storing secrets in the keychain.

00:44:34.780 --> 00:44:37.640
Using the entitlement
provisioning profile to easily

00:44:37.640 --> 00:44:40.100
set the data protection class.

00:44:40.810 --> 00:44:46.120
worked out how to best possibly
protect data in each of the classes,

00:44:46.170 --> 00:44:49.550
and some really simple ways to encrypt,
authenticate,

00:44:49.550 --> 00:44:55.190
and protect network traffic,
and given some pointers to secure

00:44:55.190 --> 00:44:58.740
transport if you want to do some
more advanced things with it.

00:44:58.830 --> 00:45:02.190
And the last thing I would say
is please fire bugs against us.

00:45:02.380 --> 00:45:06.330
Especially if you're developing
security-critical applications yourself

00:45:07.010 --> 00:45:11.900
and think that our high-level APIs are
either lacking something or not clear,

00:45:11.970 --> 00:45:15.980
go to bugreport.apple.com,
put them in as feature

00:45:15.980 --> 00:45:19.210
requests or enhancements,
and we do really read them,

00:45:19.210 --> 00:45:22.690
and they are very important
when we do feature planning.

00:45:23.710 --> 00:45:27.940
So there's more information
at developer.apple.com.

00:45:28.040 --> 00:45:30.520
Some lots of good references up there.

00:45:30.610 --> 00:45:35.030
And also, only a few weeks ago,
we published a updated iOS security

00:45:35.030 --> 00:45:39.930
white paper that has a lot of technical
details about how this all works.

00:45:39.940 --> 00:45:43.310
I commend it to you,
even if I do say so myself.

00:45:44.160 --> 00:45:47.580
It's Friday, and all the related sessions
have already occurred,

00:45:47.650 --> 00:45:50.690
but whenever the videos come out,
make sure you catch up on

00:45:50.690 --> 00:45:54.210
the other security talks
that have occurred this week.

00:45:54.990 --> 00:45:58.430
Finally, the source code is not yet up,
but we'll work to get it up

00:45:58.570 --> 00:46:01.900
either on the WWDC site or in
the main example code section.

00:46:02.020 --> 00:46:04.900
So if you search there for
"naivete," it should come up.
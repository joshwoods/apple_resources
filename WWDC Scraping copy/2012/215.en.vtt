WEBVTT

00:00:11.130 --> 00:00:12.490
All right, good morning, everyone.

00:00:12.490 --> 00:00:14.840
My name is Doug Davidson,
and I'm here to talk to

00:00:14.990 --> 00:00:16.710
you about analyzing text.

00:00:16.710 --> 00:00:20.340
Now, every app has to deal with
text in one form or another,

00:00:20.340 --> 00:00:23.680
and there are other sessions at
the conference about inputting

00:00:23.740 --> 00:00:25.060
text and displaying text.

00:00:25.100 --> 00:00:28.300
But here what we're going to talk
about is what to do if you want to

00:00:28.300 --> 00:00:32.170
understand something about what is
in a piece of text that you have.

00:00:32.390 --> 00:00:36.860
And we built a powerful and flexible
toolkit for that into our frameworks,

00:00:36.860 --> 00:00:39.110
primarily at the foundation level.

00:00:39.160 --> 00:00:44.450
So all of the APIs I'm going to discuss
today are available on both OS X and iOS.

00:00:44.590 --> 00:00:46.770
And we've made it really
easy for you to use.

00:00:46.770 --> 00:00:48.860
I'm going to tell you about that today.

00:00:48.860 --> 00:00:50.970
I should say that
proper handling of text,

00:00:51.530 --> 00:00:53.930
especially international text,
is something that's

00:00:53.930 --> 00:00:55.270
very important to Apple.

00:00:55.400 --> 00:00:58.660
It's part of what allows us to
help people all around the world.

00:00:58.660 --> 00:01:02.670
And it should be important to you, too,
to get the same kind of global reach.

00:01:02.690 --> 00:01:05.460
So we're going to start with
some very basic things and

00:01:05.460 --> 00:01:07.580
then move quickly to the next.

00:01:07.600 --> 00:01:13.840
So the most very basic
is the class NSString.

00:01:14.020 --> 00:01:15.900
Now, we all use NSStrings all the time.

00:01:16.280 --> 00:01:18.810
It's worth remembering
what an NSString is.

00:01:18.920 --> 00:01:23.970
Conceptually,
it is a sequence of UTF-16 units,

00:01:24.110 --> 00:01:30.610
which the API refers to as characters.

00:01:30.610 --> 00:01:30.610
But when you're analyzing strings,

00:01:30.900 --> 00:01:34.180
Generally speaking,
we don't want you to be dealing

00:01:34.250 --> 00:01:36.130
with individual characters.

00:01:36.230 --> 00:01:38.560
I'll explain a little more
about that in a minute.

00:01:38.630 --> 00:01:42.590
What you should be referring
to as the pieces of analysis

00:01:42.660 --> 00:01:44.710
are ranges within a string.

00:01:45.180 --> 00:01:50.660
And all the APIs deal
with text in that way.

00:01:50.660 --> 00:01:52.650
In addition to NSString,
the companion class

00:01:52.650 --> 00:01:53.900
is NSAttributedString.

00:01:53.900 --> 00:01:57.250
And there's a whole session this
afternoon on attributed strings

00:01:57.250 --> 00:02:00.860
and another one tomorrow morning,
especially for iOS developers.

00:02:00.860 --> 00:02:05.310
So I'm not going to say a great
deal about attributed strings,

00:02:05.310 --> 00:02:10.230
but remember that an NSAttributedString
has an underlying NSString that

00:02:10.230 --> 00:02:13.820
you can get at readily and
cheaply with the string method.

00:02:13.820 --> 00:02:16.780
And in addition,
it has certain attributes

00:02:16.780 --> 00:02:21.060
that decorate it,
things like fonts, colors, underlines,

00:02:21.100 --> 00:02:25.820
etc., that again apply to ranges
of characters within the string.

00:02:25.820 --> 00:02:28.550
So anything you can do
analyzing an NSString,

00:02:28.550 --> 00:02:30.820
you can also do to an attributed
string by getting its output.

00:02:30.820 --> 00:02:32.750
So you can get the output
of this underlying string.

00:02:32.860 --> 00:02:35.190
And then you can do various things to it,
including manipulating the

00:02:35.200 --> 00:02:36.780
attributes on these ranges.

00:02:36.780 --> 00:02:39.760
So we'll use that in
some of the examples.

00:02:40.360 --> 00:02:45.300
So why don't you want to deal
with individual characters mostly?

00:02:45.300 --> 00:02:47.900
Because even the smallest
user visible unit,

00:02:47.910 --> 00:02:50.370
the thing that appears
as a character to a user,

00:02:50.370 --> 00:02:54.400
may in some cases be more than
one character in the string.

00:02:54.400 --> 00:02:58.160
For example,
many accented characters can be or

00:02:58.160 --> 00:03:06.470
must be represented as a base letter
followed by a combining accent character.

00:03:06.480 --> 00:03:09.030
And in some scripts,
like Korean especially,

00:03:09.040 --> 00:03:13.170
there are even more complex combinations
where multiple characters go up to

00:03:13.170 --> 00:03:16.840
make one user visible character,
which we refer to as a composed

00:03:16.930 --> 00:03:20.380
character sequence or sometimes
just a character cluster.

00:03:20.660 --> 00:03:23.580
In addition,
for any characters in Unicode

00:03:23.580 --> 00:03:29.580
beyond the basic multilingual plane,
they will be represented in UTF-16 terms,

00:03:29.760 --> 00:03:34.990
that is in NSString, as a surrogate pair,
two UTF-16 units.

00:03:35.410 --> 00:03:38.730
I should say that the characters that
are beyond the basic multilingual

00:03:38.730 --> 00:03:42.720
plane are not just obscure things
like hieroglyphics and cuneiform.

00:03:42.720 --> 00:03:45.020
This includes a lot of
characters in Chinese.

00:03:45.020 --> 00:03:46.660
We all want to handle Chinese well.

00:03:46.660 --> 00:03:48.980
It includes most of the
new emoji in Unicode.

00:03:48.980 --> 00:03:52.440
We certainly want to be
able to handle emoji well.

00:03:52.440 --> 00:03:53.570
So what do you need to do?

00:03:53.570 --> 00:03:55.930
Well, first of all,
just be sure you don't split

00:03:56.030 --> 00:03:59.540
the parts of a character cluster
when you're analyzing a string.

00:03:59.540 --> 00:04:03.280
If you use the APIs we're discussing,
they'll all take care of that for

00:04:03.280 --> 00:04:05.100
you with the ranges they give you.

00:04:05.100 --> 00:04:07.000
If you're in doubt,
you can call range of composed

00:04:07.050 --> 00:04:09.960
character sequence at index or range
of composed character sequences

00:04:09.960 --> 00:04:14.890
for ranges to get a good range that
doesn't split character clusters.

00:04:14.910 --> 00:04:17.200
If you do split them,
you might end up with odd things.

00:04:17.200 --> 00:04:20.640
Odd things like accents being divorced
from their base characters or half

00:04:20.640 --> 00:04:22.080
of a surrogate pair showing up.

00:04:22.200 --> 00:04:23.880
And if you don't
specifically test for it,

00:04:23.880 --> 00:04:28.260
you might not know it until you
get a bad review mentioning it.

00:04:28.260 --> 00:04:32.350
But I want to describe, first of all,
an API that we have for going

00:04:32.500 --> 00:04:37.530
through a string and looking at it,
character cluster by character cluster.

00:04:37.530 --> 00:04:40.260
And I want to use this to
illustrate a pattern that

00:04:40.340 --> 00:04:44.370
we'll see again and again here,
and that is analyzing text using

00:04:44.370 --> 00:04:47.000
APIs that are block iterators.

00:04:47.000 --> 00:04:47.570
Now, block is a string that's
not a string block.

00:04:47.570 --> 00:04:51.410
And blocks are pretty much perfectly
designed for analyzing text,

00:04:51.540 --> 00:04:53.050
because what do they do?

00:04:53.050 --> 00:04:58.590
They apply some chunk of code to,
in this case, one piece of text,

00:04:58.660 --> 00:05:04.160
one range of characters in a string,
then another, then another, and so on.

00:05:04.160 --> 00:05:07.050
So for this API,
enumerate substrings in range,

00:05:07.150 --> 00:05:11.960
if we pass it the option enumeration
by composed character sequences,

00:05:11.980 --> 00:05:16.230
then it will call your block
over and over again with each

00:05:16.230 --> 00:05:21.450
of the characters in the string,
and it will pass you here the substring

00:05:21.450 --> 00:05:25.780
range will be the range of the
characters in that character cluster.

00:05:25.780 --> 00:05:28.480
And then you can do with
those whatever you want.

00:05:28.480 --> 00:05:30.480
So, for example, here,
if you have a corresponding

00:05:30.480 --> 00:05:34.100
attributed string,
you can just add an attribute like a

00:05:34.120 --> 00:05:36.680
color to that range if you needed to.

00:05:36.750 --> 00:05:38.870
So let me show you how that works.

00:05:38.870 --> 00:05:43.940
Here, if we call that on this string,
our block will be called repeatedly with

00:05:43.950 --> 00:05:46.590
the ranges of each character cluster.

00:05:46.650 --> 00:05:50.190
And here, these are just single character
characters clusters so far.

00:05:50.260 --> 00:05:55.480
They'll be ranges of length one until
we get to a character that happens to

00:05:55.600 --> 00:05:59.380
be a character cluster that happens
to be two underlying characters.

00:05:59.380 --> 00:06:01.380
Here an E with an accent character.

00:06:01.380 --> 00:06:04.820
And then here an emoji character
that's a surrogate pair.

00:06:04.820 --> 00:06:07.430
And in these cases,
you would pass in the range of length two

00:06:07.580 --> 00:06:10.190
corresponding to this character cluster.

00:06:10.600 --> 00:06:13.570
Another unit of processing
that's especially important for

00:06:13.570 --> 00:06:15.960
linguistic-related tasks is the word.

00:06:15.960 --> 00:06:20.110
And we should remember that in
English we're used to thinking

00:06:20.110 --> 00:06:22.650
of words as being delimited
by white space or punctuation,

00:06:22.650 --> 00:06:24.830
but that's not the
case in every language.

00:06:24.870 --> 00:06:31.050
In languages like Chinese, Japanese,
and Thai, words may not be delimited by

00:06:31.340 --> 00:06:35.110
punctuation or white space,
and you need -- some analysis

00:06:35.170 --> 00:06:38.010
has to be done to determine
where the word boundaries are.

00:06:38.020 --> 00:06:41.300
So we have an API for going
through strings by words.

00:06:41.300 --> 00:06:45.420
In fact, it's just the same API that
I mentioned for character clusters

00:06:45.480 --> 00:06:47.040
but with a different constant.

00:06:47.040 --> 00:06:50.520
Use enumeration by words,
and instead your block will

00:06:50.520 --> 00:06:56.060
be called with the ranges of
the words in a piece of text.

00:06:56.060 --> 00:06:59.170
In this case,
let me pay a little closer attention

00:06:59.170 --> 00:07:00.760
to the arguments of the block.

00:07:00.760 --> 00:07:05.240
So the first one is substring,
that is the actual word as a string.

00:07:05.660 --> 00:07:07.940
Next is the range of it in the string.

00:07:07.940 --> 00:07:08.940
So the first one is substring,
that is the actual word as a string.

00:07:08.940 --> 00:07:09.940
Next is substring,
that is the actual word as a string.

00:07:09.940 --> 00:07:09.940
Next is substring,
that is the actual word as a string.

00:07:09.940 --> 00:07:15.380
And the enclosing range also includes,
if there is any, other stuff around the

00:07:15.380 --> 00:07:19.650
word up to the next word,
like punctuation or white space,

00:07:19.740 --> 00:07:21.340
if it happens to be there.

00:07:21.560 --> 00:07:26.480
and there's also in most of
these block enumerators an

00:07:26.480 --> 00:07:29.500
out point or Boolean argument,
stop,

00:07:29.500 --> 00:07:35.700
which you can set to yes to break out of
the iteration prematurely if you need to.

00:07:36.300 --> 00:07:38.700
Another unit of processing
is the paragraph,

00:07:38.700 --> 00:07:42.240
that is, text that's delimited by
some kind of paragraph break,

00:07:42.350 --> 00:07:46.830
carriage return, line feed, or both,
or Unicode paragraph break character.

00:07:46.950 --> 00:07:50.540
This is the largest unit you
have to consider at once for

00:07:50.540 --> 00:07:52.820
Unicode-related processing.

00:07:52.930 --> 00:07:55.800
And again, we have the same API for
enumerating through a string

00:07:55.800 --> 00:07:59.340
by paragraph by paragraph if
you pass it the right constant,

00:07:59.430 --> 00:08:01.150
enumeration by paragraphs.

00:08:01.250 --> 00:08:04.510
One common pattern is to nest these.

00:08:04.590 --> 00:08:06.640
You can go through a
string first by paragraphs,

00:08:06.820 --> 00:08:10.020
then, say, by words,
then maybe by character

00:08:10.070 --> 00:08:11.810
clusters if you need to.

00:08:11.920 --> 00:08:16.390
There's also a nice convenience API if
you're doing the Unity sort of thing of

00:08:16.390 --> 00:08:21.480
going through something line by line,
then we have an API enumerate lines

00:08:21.520 --> 00:08:25.760
using block that will take a string
and pass you each line at a time

00:08:25.760 --> 00:08:28.100
for you to do something with it.

00:08:29.090 --> 00:08:33.940
Suppose what you want to do is
to find the first occurrence of a

00:08:33.940 --> 00:08:37.000
particular substring within a string.

00:08:37.000 --> 00:08:41.000
Well, we have the range of string
class of APIs for that.

00:08:41.000 --> 00:08:43.000
And they take a number of options.

00:08:43.000 --> 00:08:46.830
In this case I've chosen
the case insensitive option,

00:08:47.060 --> 00:08:50.000
which means I'll find it
in upper or lower case.

00:08:50.000 --> 00:08:55.990
For this word it could be resume
or resume with some accents.

00:08:56.020 --> 00:08:56.400
I'll find either one.

00:08:56.480 --> 00:08:58.400
And width insensitive,
which will find either a single or

00:08:58.400 --> 00:09:03.750
double width versions of characters
that may occur in some Japanese text.

00:09:04.790 --> 00:09:07.770
If I don't want to find the
next occurrence of a substring,

00:09:07.770 --> 00:09:10.420
if I just want to check and see
if a substring is present at

00:09:10.480 --> 00:09:15.010
a given place in the string,
I can add the anchored search

00:09:15.010 --> 00:09:16.890
option to the same API.

00:09:17.020 --> 00:09:20.570
And this means it will find a
match only if the string we're

00:09:20.570 --> 00:09:26.200
looking for occurs starting at the
start of the range that we pass in.

00:09:26.280 --> 00:09:29.010
And this is useful in many
cases and much cheaper,

00:09:29.010 --> 00:09:32.210
of course,
than looking through the entire string.

00:09:32.730 --> 00:09:36.800
We also have search and
replace APIs based on these.

00:09:36.890 --> 00:09:42.060
One version that applies to immutable
strings and returns a modified copy.

00:09:42.250 --> 00:09:47.830
And another version that acts on mutable
strings and mutates them in place.

00:09:49.580 --> 00:09:53.110
Sometimes the thing you're looking
for is not a specific substring,

00:09:53.210 --> 00:09:59.220
but maybe characters from certain certain
class like punctuation or white space or

00:09:59.220 --> 00:10:03.240
digits or letters or uppercase letters.

00:10:03.400 --> 00:10:06.230
For that we have NSCharacterSet.

00:10:06.360 --> 00:10:12.010
Conceptually an NSCharacterSet is
just a bitmap over all of Unicode.

00:10:12.230 --> 00:10:16.980
It can be any subset
of Unicode characters.

00:10:17.040 --> 00:10:20.740
We have a bunch of predefined
examples in the API,

00:10:20.740 --> 00:10:23.530
white space, punctuation,
etc., that I mentioned.

00:10:23.600 --> 00:10:28.210
But you can create it with any
set of characters that you choose.

00:10:28.310 --> 00:10:30.670
You can pick a list.

00:10:30.800 --> 00:10:35.350
There's even a mutable variant of
NSCharacterSet so you can perform any

00:10:35.350 --> 00:10:41.110
sorts of set operations on it you like to
get the precise character set you want.

00:10:41.500 --> 00:10:44.720
And then there's a very similar API,
range of characters from set,

00:10:44.880 --> 00:10:50.610
that finds the next occurrence of
characters from this set in your string.

00:10:51.310 --> 00:10:55.170
and there is also a matching version
with an anchored search option

00:10:55.380 --> 00:10:59.560
that checks to see is there a
character from this set at the start

00:10:59.560 --> 00:11:02.000
of this range that I'm looking at.

00:11:02.170 --> 00:11:05.910
So let's see how some
of this works in code.

00:11:06.570 --> 00:11:12.050
And so I have a very simple sample
project that has some text and a

00:11:12.050 --> 00:11:17.190
number of methods for going through
it using various of these APIs.

00:11:17.200 --> 00:11:19.600
So here we're going to
go through it by words.

00:11:19.710 --> 00:11:23.380
Enumerate substrings in range by words.

00:11:23.380 --> 00:11:26.980
Now, the string here is the
underlying string of the text,

00:11:26.980 --> 00:11:29.380
which is a myattributed string.

00:11:29.380 --> 00:11:33.620
So I'm just going to add a color to
each word in my text just to show

00:11:33.620 --> 00:11:39.240
you that the examples on the slides
are really taken from running code.

00:11:39.240 --> 00:11:40.920
So let's see how that works.

00:11:40.920 --> 00:11:46.150
So I'll color all the words in the text
red and leave the nonword text uncolored.

00:11:46.510 --> 00:11:50.050
Maybe it's easier to see if we do
it in slow motion that shows how

00:11:50.050 --> 00:11:52.450
the enumeration actually works.

00:11:58.900 --> 00:11:59.610
Okay.

00:11:59.610 --> 00:12:00.320
Next.

00:12:00.320 --> 00:12:06.570
If I want to find a particular substring,
again, my resume or resume,

00:12:06.570 --> 00:12:09.840
one common pattern,
this range of string API just

00:12:09.840 --> 00:12:13.620
returns the first match,
so if I want to find them all,

00:12:13.620 --> 00:12:19.340
I can go through it in a while loop,
start and I look in a range that

00:12:19.340 --> 00:12:24.630
goes from the end of my previous
match to the end of the string and

00:12:24.630 --> 00:12:29.040
continue until I no longer find
any or reach the end of the string.

00:12:29.040 --> 00:12:32.940
When it doesn't find something,
it will return and it's not found,

00:12:32.940 --> 00:12:38.380
zero is the range and
I'll break out of my loop.

00:12:38.380 --> 00:12:38.380
So I'll try this.

00:12:41.400 --> 00:12:45.060
And okay,
I'll find all occurrences of that string.

00:12:45.060 --> 00:12:49.880
You notice that this substring
search is not a by word search.

00:12:50.050 --> 00:12:54.460
So it finds both resume and
resume as part of resumes.

00:12:54.550 --> 00:12:59.660
If I wanted to do it by word,
I can write this a little differently.

00:12:59.660 --> 00:13:02.360
And I could just use my
enumerate substrings in range,

00:13:02.360 --> 00:13:05.260
enumeration by words,
and go through word by word.

00:13:05.380 --> 00:13:10.190
And then I can use the range of
string API with the anchored search

00:13:10.520 --> 00:13:15.310
option to see if that range that
I found as a word actually matches

00:13:15.370 --> 00:13:17.450
the thing that I'm looking for.

00:13:19.100 --> 00:13:24.400
[Transcript missing]

00:13:25.930 --> 00:13:30.660
I just find the cases
that match a whole word.

00:13:30.660 --> 00:13:34.430
Now you'll notice that a number
of things in this text are in

00:13:34.470 --> 00:13:36.140
quotes of one form or another.

00:13:36.140 --> 00:13:37.890
There are a lot of characters
that are used as quote

00:13:37.990 --> 00:13:39.900
characters in various languages.

00:13:40.100 --> 00:13:44.900
So I want to find all the
quotes that occur in this text.

00:13:44.900 --> 00:13:48.040
So I have a method here that
creates a character set,

00:13:48.070 --> 00:13:50.890
and it creates a character set with
certain characters that I've listed

00:13:51.040 --> 00:13:52.900
by putting them in a string here.

00:13:52.900 --> 00:13:56.150
And it shows just all the characters
that I know that are used as

00:13:56.150 --> 00:13:57.900
quotes in various languages.

00:13:57.900 --> 00:14:02.610
And so I'm going to use that and
use the range of character from

00:14:02.610 --> 00:14:06.900
set API in the same way that
I use the range of string API.

00:14:06.900 --> 00:14:11.060
I'm going to go through in a
while loop until I no longer

00:14:11.060 --> 00:14:13.770
find characters from that set.

00:14:16.300 --> 00:14:18.060
And what does that look like?

00:14:18.060 --> 00:14:21.480
It colors all of the characters
that are used as quotes here,

00:14:21.510 --> 00:14:23.100
as red.

00:14:23.190 --> 00:14:27.390
Suppose I want to find the words
that are surrounded by quotes.

00:14:27.440 --> 00:14:30.090
Well,
I wrote a little helper method here to

00:14:30.090 --> 00:14:34.000
determine whether a particular range
of the text is surrounded by quotes.

00:14:34.080 --> 00:14:39.500
So I use that same quote character set,
and I look and see,

00:14:39.500 --> 00:14:43.200
using the anchored search option
to range of character from set,

00:14:43.240 --> 00:14:45.690
to ask,
is the previous character a quote,

00:14:45.690 --> 00:14:48.200
and is the following character a quote?

00:14:48.330 --> 00:14:52.090
So to look at the previous character,
I use backwards search,

00:14:52.160 --> 00:14:54.450
which is the option that starts
from the end of the range

00:14:54.520 --> 00:14:59.170
rather than the beginning,
and anchored search to check for a match

00:14:59.170 --> 00:15:02.000
right at the boundary of the range.

00:15:02.000 --> 00:15:04.760
And then to look at the
following character,

00:15:04.760 --> 00:15:08.400
I pass the anchored search option,
and I pass appropriate ranges.

00:15:08.400 --> 00:15:10.970
So in this case,
one that starts at the end of

00:15:11.080 --> 00:15:14.330
the range I'm looking at and
goes to the end of the string.

00:15:14.510 --> 00:15:17.000
And that tells me whether
a range is in quotes.

00:15:17.130 --> 00:15:20.530
So then I go through enumerate
substrings in range by words to

00:15:20.530 --> 00:15:23.980
go through word by word and ask,
is that word in quotes?

00:15:24.130 --> 00:15:26.630
If yes, color it.

00:15:26.990 --> 00:15:28.550
How does that work?

00:15:28.580 --> 00:15:29.940
Let's color all the words in quotes.

00:15:29.970 --> 00:15:33.100
So here are all the words
that are in quotes colored.

00:15:35.380 --> 00:15:38.200
Okay, let me go back to the slides.

00:15:38.310 --> 00:15:39.940
Let's move along to something
a little more powerful.

00:15:39.940 --> 00:15:42.120
Regular expressions.

00:15:42.250 --> 00:15:45.480
So probably you're familiar
with regular expressions.

00:15:45.540 --> 00:15:49.090
If not,
let me just say that regular expressions

00:15:49.230 --> 00:15:54.050
are patterns that include things
like literal strings or sets of

00:15:54.120 --> 00:16:00.050
characters or combinations of these
or repetitions of them or alternatives

00:16:00.600 --> 00:16:02.910
or more sophisticated things.

00:16:02.920 --> 00:16:08.150
The term regular expression by now
is a bit of a misnomer because modern

00:16:08.150 --> 00:16:11.870
regular expression APIs include
things that aren't formally regular

00:16:12.310 --> 00:16:16.370
like look ahead and look behind
and back references and so forth.

00:16:16.510 --> 00:16:18.040
But the term has stuck.

00:16:18.180 --> 00:16:22.610
So we have -- here's a very
simple example of a regular

00:16:22.610 --> 00:16:24.900
expression I'll use to demonstrate.

00:16:24.900 --> 00:16:29.890
It starts off with a word boundary,
finds a word break.

00:16:30.360 --> 00:16:34.430
continues by this first
parenthesized sub-expression

00:16:34.430 --> 00:16:36.640
matches either an I or an O.

00:16:36.790 --> 00:16:39.990
The second one matches
either an F or an N.

00:16:40.080 --> 00:16:42.990
Now these parenthesized sub-expressions
are sometimes referred to as

00:16:43.060 --> 00:16:46.060
capture groups for reasons
that will become clear later.

00:16:46.180 --> 00:16:48.040
And ends with another word boundary.

00:16:48.180 --> 00:16:54.180
So what this expression matches is
whole words that have two letters,

00:16:54.190 --> 00:16:57.040
the first of which is either I or O,
the second is either F or N.

00:16:57.040 --> 00:16:57.940
Very simple.

00:16:58.050 --> 00:17:00.670
This is how the regular expression looks.

00:17:00.820 --> 00:17:04.300
If we are putting it in
a literal string in code,

00:17:04.390 --> 00:17:07.540
we have to remember that the backslash
character needs to be escaped.

00:17:07.660 --> 00:17:11.040
So it would look like this
with the backslashes doubled.

00:17:11.080 --> 00:17:13.330
Just a little caution.

00:17:13.570 --> 00:17:21.160
And we have a powerful regular expression
facility in Foundation that is based

00:17:21.160 --> 00:17:23.860
on the ICU regular expression library.

00:17:24.020 --> 00:17:27.820
ICU is the standard library for
dealing with Unicode algorithms,

00:17:27.820 --> 00:17:32.080
so it's fully Unicode-compliant,
and has many different options.

00:17:32.080 --> 00:17:37.700
The things that are usual,
like case insensitivity, dot matches all,

00:17:37.700 --> 00:17:42.650
the so-called multi-line mode,
options for including comments

00:17:42.650 --> 00:17:46.320
in regular expressions,
and so on and so forth.

00:17:46.320 --> 00:17:49.810
You can read the header
for descriptions of these.

00:17:50.100 --> 00:17:54.400
The simplest API for finding
regular expressions is just the

00:17:54.400 --> 00:17:58.600
same API that we used before,
the range of string API.

00:17:58.600 --> 00:18:01.540
If we add the regular
expression search option to it,

00:18:01.580 --> 00:18:06.640
it means that the thing we're looking for
is now treated like a regular expression

00:18:06.640 --> 00:18:10.730
pattern instead of a literal string,
and we'll find a match.

00:18:10.800 --> 00:18:15.880
One interesting twist is that,
remember I said all these APIs return

00:18:15.880 --> 00:18:19.620
a range and it's not found zero
if they don't find a match.

00:18:19.850 --> 00:18:24.340
And for the previous APIs,
they'll always return a non-zero

00:18:24.340 --> 00:18:26.750
length range if they find something.

00:18:26.830 --> 00:18:30.530
There are certain regular expressions,
if you use look ahead or look behind,

00:18:30.530 --> 00:18:35.740
you can create one that will match
correctly with a zero length match.

00:18:35.840 --> 00:18:40.940
So I've chosen to determine whether
there's a match by comparing the location

00:18:40.940 --> 00:18:43.470
with "and it's not found" instead.

00:18:44.310 --> 00:18:48.200
For a little more flexibility,
we have a class, NSRegularExpression.

00:18:48.200 --> 00:18:53.990
With this you can control when the
NSRegularExpression object is created.

00:18:54.000 --> 00:18:56.820
Now when that happens,
the pattern gets compiled

00:18:56.820 --> 00:19:00.200
into an interval form,
so this is useful for

00:19:00.200 --> 00:19:01.400
performance reasons.

00:19:01.470 --> 00:19:04.800
And the class is fully thread-safe,
so you can just create one,

00:19:04.800 --> 00:19:09.030
keep it around as long as you need it,
and use it from all the threads you need.

00:19:09.160 --> 00:19:13.860
You create it by passing in
a pattern and some options.

00:19:13.860 --> 00:19:16.340
So here I've chosen the
case insensitive option.

00:19:16.340 --> 00:19:19.920
So this will match either
upper or lower case.

00:19:19.920 --> 00:19:26.300
And then the basic API on this regular
expression is just a block enumeration.

00:19:26.380 --> 00:19:30.740
Enumerate matches in string with options
and there are various options here.

00:19:30.740 --> 00:19:32.800
Again you can look in
the header for these,

00:19:32.800 --> 00:19:36.060
things like transparent
bounds or anchoring bounds.

00:19:36.120 --> 00:19:40.260
There's an option to regularly report
progress if it takes a long time.

00:19:40.260 --> 00:19:44.460
There's an option to tell you when
it's about to finish and so on.

00:19:44.460 --> 00:19:47.610
And then your block will be
called for each match of the

00:19:47.610 --> 00:19:51.020
regular expression in the string.

00:19:51.640 --> 00:19:56.200
So it would be called once for
each of these two-letter words that

00:19:56.200 --> 00:19:58.740
match my regular expression pattern.

00:19:58.830 --> 00:20:01.230
And what will it be called with?

00:20:01.370 --> 00:20:03.340
Here it's not just a
range that we passed in.

00:20:03.340 --> 00:20:08.450
We pass in an object representing the
match of class NSTextCheckingResult

00:20:08.470 --> 00:20:11.000
that has a number of properties.

00:20:11.110 --> 00:20:12.710
One property is a result type.

00:20:12.710 --> 00:20:14.500
That will be important later.

00:20:14.680 --> 00:20:19.640
The main property is the range property,
which is the overall range of the match.

00:20:19.750 --> 00:20:24.150
But with regular expressions you
also get to find the ranges of

00:20:24.210 --> 00:20:27.490
the individual capture groups,
that is these parenthesized

00:20:27.500 --> 00:20:30.980
sub-expressions,
which can be very useful in many cases.

00:20:31.100 --> 00:20:33.310
So range at index,
range at index 0 is the

00:20:33.310 --> 00:20:35.930
overall match range,
range at index 1 the range

00:20:36.070 --> 00:20:38.730
of the first capture group,
range at index 2 the range

00:20:38.730 --> 00:20:41.990
of the second capture group,
and so on and so forth.

00:20:42.560 --> 00:20:47.200
And so then you can go through
and in your block you can get

00:20:47.280 --> 00:20:50.200
the overall range of the match,
you can get the range of

00:20:50.200 --> 00:20:51.450
the first capture group.

00:20:51.450 --> 00:20:54.810
For this particular regular
expression it's the first

00:20:54.810 --> 00:20:57.140
letter of the two-letter word.

00:20:57.230 --> 00:20:59.640
You can get the range of
the second capture group.

00:20:59.710 --> 00:21:02.550
Again, for this one it's the second
letter of our two-letter word.

00:21:02.630 --> 00:21:06.380
And with those ranges you can
then do whatever you need to the

00:21:06.470 --> 00:21:09.440
match of your regular expression.

00:21:10.560 --> 00:21:14.620
The basic API is a block enumerator,
but there are plenty of other

00:21:14.620 --> 00:21:16.400
APIs if you don't need that.

00:21:16.400 --> 00:21:19.090
You can get all the matches of
the regular expression as an

00:21:19.090 --> 00:21:22.020
array if that's what you want,
or just count them,

00:21:22.230 --> 00:21:24.750
or just get the first one,
or maybe just the range of the

00:21:24.750 --> 00:21:26.500
first one if that's all you need.

00:21:26.500 --> 00:21:28.890
It's cheaper to do that
than to get them all.

00:21:29.020 --> 00:21:34.880
So you can just ask for the
range of the first match,

00:21:34.880 --> 00:21:34.880
and that will tell you
is there a match at all.

00:21:37.040 --> 00:21:41.070
Remember I mentioned the
convenience API to go through

00:21:41.260 --> 00:21:43.640
a piece of text line by line.

00:21:43.640 --> 00:21:46.990
If you were trying to do something
grep-like using NS regular expression,

00:21:47.010 --> 00:21:50.000
you could use that,
go through a string line by line.

00:21:50.090 --> 00:21:52.490
For each line, ask,
"Is there a match of my regular

00:21:52.580 --> 00:21:56.000
expression in the line?" And then if so,
do something like print it out.

00:21:56.230 --> 00:21:57.920
Very simple.

00:21:59.300 --> 00:22:02.900
There's also a search and replace
API on NSRegularExpression.

00:22:02.900 --> 00:22:08.440
Again, one method that takes an immutable
string and returns a modified copy.

00:22:08.530 --> 00:22:12.640
And another method that operates on a
mutable string and mutates it in place.

00:22:12.700 --> 00:22:16.220
But for these methods,
the thing that you're replacing

00:22:16.270 --> 00:22:18.860
with is not just a literal string.

00:22:18.900 --> 00:22:20.550
It's a template.

00:22:20.590 --> 00:22:23.220
This should be familiar for
users of regular expressions.

00:22:23.430 --> 00:22:27.640
Where $0 represents the
whole thing that was matched.

00:22:27.700 --> 00:22:30.000
$1 is the first capture group.

00:22:30.110 --> 00:22:32.520
$2 the second and so on and so forth.

00:22:32.520 --> 00:22:35.360
So here I picked $2, $1.

00:22:35.360 --> 00:22:38.080
That is,
contents of the second capture group,

00:22:38.080 --> 00:22:41.640
contents of the first capture
group will replace the match.

00:22:41.640 --> 00:22:44.230
So it should probably be
obvious what that's going to

00:22:44.310 --> 00:22:45.900
do to these two-letter words.

00:22:45.950 --> 00:22:48.090
It's just going to reverse them.

00:22:49.900 --> 00:22:54.040
There is also for convenience
a search and replace by regular

00:22:54.040 --> 00:22:57.020
expression API just on NSString.

00:22:57.020 --> 00:23:00.970
And it's the same API we saw
before on NSString but with the

00:23:00.970 --> 00:23:05.520
NSRegularExpressionSearch option
added which makes it treated

00:23:05.520 --> 00:23:08.130
as a regular expression search.

00:23:09.300 --> 00:23:13.040
So regular expressions are great
for things that are simple patterns.

00:23:13.040 --> 00:23:17.340
But for more complicated things
like URLs or email addresses,

00:23:17.450 --> 00:23:22.330
phone numbers, dates and times,
even street addresses,

00:23:22.420 --> 00:23:24.900
people sometimes try to find
these using regular expressions,

00:23:24.900 --> 00:23:28.760
but it's very difficult and
the regular expression is not

00:23:28.760 --> 00:23:32.940
likely to match the complexity,
especially of the wide range

00:23:32.940 --> 00:23:36.460
of international formats you'll
find for things like dates

00:23:36.460 --> 00:23:36.460
and times and phone numbers.

00:23:36.930 --> 00:23:42.640
So fortunately we have something
that's better for these applications.

00:23:42.640 --> 00:23:45.020
Faster, more powerful,
handles all sorts of

00:23:45.020 --> 00:23:46.500
international formats.

00:23:46.570 --> 00:23:48.500
And it's called Data Detectors.

00:23:48.570 --> 00:23:55.760
You're probably familiar with it
from seeing it find things like

00:23:55.760 --> 00:23:59.000
dates and times and addresses
in your mail at the UI level.

00:23:59.610 --> 00:24:04.590
It's also available as an API,
NSDataDetector.

00:24:04.590 --> 00:24:07.980
And NSDataDetector is just a
subclass of NSRegularExpression.

00:24:08.580 --> 00:24:10.530
You create an NSData detector.

00:24:10.660 --> 00:24:12.100
You don't pass it in a pattern.

00:24:12.100 --> 00:24:15.470
Instead,
you just pass it in a set of types

00:24:15.700 --> 00:24:19.380
of the sorts of things that you
want to find from the list of things

00:24:19.380 --> 00:24:21.160
that data detectors can find.

00:24:21.270 --> 00:24:22.600
And there are a bunch of these.

00:24:22.740 --> 00:24:26.290
So it can find dates and
times with a type date.

00:24:26.360 --> 00:24:29.740
It can find street addresses
with a type address.

00:24:29.860 --> 00:24:34.500
URLs and email addresses
with a type link.

00:24:34.680 --> 00:24:37.290
Phone numbers with a type phone number.

00:24:37.470 --> 00:24:40.270
Because this is just a subclass
of NIS regular expression,

00:24:40.270 --> 00:24:41.900
it has the same API.

00:24:42.000 --> 00:24:52.180
The block enumerator gets called for each
match of the sort of thing that your data

00:24:52.180 --> 00:24:52.180
detector is looking for in your string.

00:24:52.390 --> 00:24:55.560
And again,
it gets called with an object of

00:24:55.560 --> 00:24:58.540
class and its text checking result.

00:24:58.650 --> 00:25:02.920
Now here's where the result type
property of that class comes into

00:25:03.020 --> 00:25:07.290
play because it tells you what the
sort of thing is that was found.

00:25:07.320 --> 00:25:10.810
Is it a date or an address
or a phone number or URL,

00:25:10.940 --> 00:25:14.210
etc.? And there are some
additional properties that

00:25:14.210 --> 00:25:15.930
are specific to certain types.

00:25:16.110 --> 00:25:20.300
So if it's a date,
there's an NSDate property.

00:25:20.310 --> 00:25:23.050
If it's a street address,
there's the components dictionary

00:25:23.400 --> 00:25:27.100
which gives you the street and
city and state and so forth.

00:25:27.140 --> 00:25:31.000
If it's a URL or email address,
there's an NSURL property URL.

00:25:31.000 --> 00:25:34.800
If it's a phone number,
there's a phone number property.

00:25:34.800 --> 00:25:38.470
So you can go through and
for each match that you find,

00:25:38.720 --> 00:25:41.780
check the result type and see what
sort of thing it is you found.

00:25:41.800 --> 00:25:42.520
Is it a link?

00:25:42.520 --> 00:25:43.600
Okay, get the URL.

00:25:43.600 --> 00:25:45.290
We can do something with that.

00:25:45.410 --> 00:25:46.360
Is it a phone number?

00:25:46.360 --> 00:25:47.830
Okay, get the phone number.

00:25:47.830 --> 00:25:49.450
We can do something with that.

00:25:50.320 --> 00:25:52.010
And again,
because this is just a subclass

00:25:52.010 --> 00:25:55.070
of NS regular expression,
it has all the same additional methods

00:25:55.300 --> 00:25:59.390
to get all the matches in an array or
just count them or find the first one

00:25:59.390 --> 00:26:01.510
or just the range of the first one.

00:26:01.810 --> 00:26:04.990
As you can see,
if there is a match at all or not.

00:26:05.030 --> 00:26:07.330
Let's see how that works in code.

00:26:08.630 --> 00:26:12.450
Okay, so next I'm going to use the
regular expression that I showed.

00:26:12.510 --> 00:26:17.200
I create an NSRegularExpression with it,
make it case insensitive,

00:26:17.360 --> 00:26:20.500
and then just call
enumerateMatches in string.

00:26:20.620 --> 00:26:27.630
And for each match,
I'm going to color the

00:26:27.630 --> 00:26:27.630
range of the match.

00:26:27.630 --> 00:26:27.630
Very simple.

00:26:27.630 --> 00:26:27.630
Let's try it out.

00:26:30.610 --> 00:26:35.610
and you see that all of the two
letter words that match are colored.

00:26:35.620 --> 00:26:36.600
Very simple.

00:26:36.600 --> 00:26:38.760
You can use it for any
regular expression you like.

00:26:38.880 --> 00:26:40.470
Suppose I want to use data detectors.

00:26:40.470 --> 00:26:41.070
All right.

00:26:41.140 --> 00:26:43.090
I create a data detector with a type.

00:26:43.230 --> 00:26:51.760
In this case I'm just choosing
the type link that will find URLs.

00:26:51.760 --> 00:26:54.150
I use the same -- this is the same code.

00:26:54.150 --> 00:26:54.150
Enumerate matches in string.

00:26:54.150 --> 00:26:54.150
If I have a match, I color it.

00:26:58.700 --> 00:27:02.070
and it finds the URLs in this
piece of text and colors them.

00:27:02.140 --> 00:27:09.410
I should say this example here happens to
be an OS X application using NS TextView,

00:27:09.880 --> 00:27:15.590
but you could do the same sorts of
things on iOS with an attributed

00:27:15.590 --> 00:27:15.590
string and the underlying string.

00:27:16.950 --> 00:27:21.290
All right,
so let's go back to the slides.

00:27:21.300 --> 00:27:23.900
And let me move on to
the heavy artillery here,

00:27:24.020 --> 00:27:26.580
which is something a little special.

00:27:26.580 --> 00:27:28.920
We call it linguistic tagging.

00:27:29.030 --> 00:27:32.650
And what linguistic tagging --
what this functionality does is it

00:27:32.720 --> 00:27:37.060
takes a string and the first thing
it does is to analyze that string

00:27:37.240 --> 00:27:42.560
to cut it up first into paragraphs
and the paragraphs into sentences,

00:27:42.560 --> 00:27:46.120
and then the sentences into
what we refer to as tokens,

00:27:46.140 --> 00:27:50.310
which are the words or the other things
that show up in text -- punctuation,

00:27:50.320 --> 00:27:52.170
white space, et cetera.

00:27:52.180 --> 00:27:55.360
So it divides up the text,
it tokenizes it,

00:27:55.530 --> 00:28:00.530
and you can use it just for that
tokenization if what you need is word

00:28:00.530 --> 00:28:03.710
or sentence or paragraph boundaries.

00:28:03.790 --> 00:28:08.290
And then it attempts to determine
from the text what language a

00:28:08.290 --> 00:28:11.260
particular piece of text is in.

00:28:11.260 --> 00:28:13.680
So it's a language identification.

00:28:13.680 --> 00:28:17.320
And it can give you -- it
uses the standard BCP 47

00:28:17.320 --> 00:28:22.560
codes like EN for English,
FR for French, and so on and so forth.

00:28:22.560 --> 00:28:27.740
And also it determines what script a
piece of text is in -- Latin script or

00:28:27.810 --> 00:28:32.970
Cyrillic or Greek or Arabic or Chinese,
simplified Chinese or

00:28:32.970 --> 00:28:35.410
traditional or Japanese.

00:28:35.470 --> 00:28:39.470
And for those, it uses, again,
standard abbreviations

00:28:39.500 --> 00:28:40.970
like LATN and CYRL.

00:28:41.080 --> 00:28:44.790
So that's the basic analysis
that Linguistic Tagger

00:28:44.790 --> 00:28:46.620
does on a piece of text.

00:28:46.620 --> 00:28:48.720
And again,
many pieces of code use it just

00:28:48.720 --> 00:28:52.180
for the language identification,
the script identification.

00:28:52.180 --> 00:28:56.190
Then it can go on to do some
more sophisticated analysis.

00:28:56.250 --> 00:29:01.400
It can take a look at that text and try
to determine what part of speech each

00:29:01.570 --> 00:29:04.360
word in that text is being used as.

00:29:04.430 --> 00:29:08.470
Is this a noun, a verb, adjective,
and so on and so forth?

00:29:08.610 --> 00:29:10.870
It can take a look at word and text.

00:29:10.900 --> 00:29:11.640
It can take a look at the
text and see what it is.

00:29:11.640 --> 00:29:14.350
It can take a look at the text and say,
"All right, this is an inflected form,

00:29:14.350 --> 00:29:16.030
maybe a plural.

00:29:16.090 --> 00:29:19.060
What is the base form of
this word?" We use a little

00:29:19.060 --> 00:29:20.140
technical terminology here.

00:29:20.140 --> 00:29:21.440
We call this a lemma.

00:29:21.440 --> 00:29:25.400
That's what would appear as the head
word in the dictionary for this word.

00:29:25.400 --> 00:29:29.820
Maybe it's a verb form and you want
the infinitive form of the verb.

00:29:30.210 --> 00:29:34.230
It can also attempt to determine
whether a piece of text looks

00:29:34.320 --> 00:29:36.540
like it's part of a name or not.

00:29:36.540 --> 00:29:38.200
Named entity recognition.

00:29:38.290 --> 00:29:42.190
Whether it's a person name or
place name or organization name.

00:29:42.640 --> 00:29:45.050
Now,
the basic analysis of tokenization and

00:29:45.050 --> 00:29:49.010
language and script identification,
that we can do for

00:29:49.010 --> 00:29:51.500
arbitrary pieces of text.

00:29:51.600 --> 00:29:56.470
The more sophisticated linguistic
analyses are very language specific.

00:29:56.670 --> 00:30:01.500
They require sophisticated natural
language models for each language.

00:30:01.500 --> 00:30:05.490
So, these are provided only
for certain languages.

00:30:05.500 --> 00:30:12.090
Currently, on OS X,
we do parts of speech and

00:30:12.740 --> 00:30:17.500
base word identification,
lemmatization, for English, French,

00:30:17.500 --> 00:30:21.280
German, and New and Mountain Lion,
Italian, and Spanish.

00:30:21.710 --> 00:30:26.040
: We do named entity
recognition for English only.

00:30:26.170 --> 00:30:30.280
On iOS, for reasons of space,
currently we provide all these

00:30:30.300 --> 00:30:33.100
capabilities but only for English.

00:30:33.210 --> 00:30:35.970
Now,
precisely which languages are supported

00:30:35.970 --> 00:30:39.580
may change in the future if we add more,
so there is a method to

00:30:39.610 --> 00:30:43.790
determine what capabilities are
supported for a given language,

00:30:43.900 --> 00:30:46.620
available tag schemes for language.

00:30:47.540 --> 00:30:52.360
The object that does the linguistic
tagging is NSLinguisticTagger.

00:30:52.390 --> 00:30:56.500
To create one,
you create an NSLinguisticTagger

00:30:56.500 --> 00:31:00.060
and you pass it in the tag schemes.

00:31:00.150 --> 00:31:03.280
That is what we call the
list of the various kinds of

00:31:03.280 --> 00:31:05.340
analysis that you want it to do.

00:31:05.490 --> 00:31:07.500
There are constants for this.

00:31:07.500 --> 00:31:08.620
Here I've chosen token type.

00:31:08.710 --> 00:31:11.500
That's the basic tokenization.

00:31:11.500 --> 00:31:12.850
Lexical class.

00:31:12.960 --> 00:31:15.030
I say we use a little
technical terminology.

00:31:15.040 --> 00:31:20.260
Lexical class is our term for
the parts of speech analysis.

00:31:20.420 --> 00:31:23.630
Name type,
that's named entity recognition.

00:31:23.680 --> 00:31:26.630
Name type or lexical
class combines those two.

00:31:26.710 --> 00:31:30.900
It will give you whichever is most
salient for a given piece of text.

00:31:31.080 --> 00:31:35.230
And lemma type,
that gives you the base form of a word.

00:31:35.400 --> 00:31:39.370
Then you take your string
and you set it on the tagger.

00:31:39.550 --> 00:31:42.800
The reason we do this is because a
tagger does some fairly sophisticated

00:31:42.800 --> 00:31:46.530
analysis on a piece of text when it
needs to and then it holds on to it.

00:31:46.540 --> 00:31:51.330
So subsequent requests for information
about that text are very fast.

00:31:53.360 --> 00:31:56.500
And then the basic API on
NSLinguisticTagger,

00:31:56.500 --> 00:31:57.430
again, guess what?

00:31:57.490 --> 00:31:59.690
It's just a block enumerator.

00:31:59.810 --> 00:32:02.570
Enumerate tags in range.

00:32:02.710 --> 00:32:06.800
You pass it in a scheme, that is,
what kind of analysis do you want?

00:32:06.900 --> 00:32:08.890
Do you want, in this case,
I've chosen lexical class,

00:32:08.970 --> 00:32:11.300
I want to get parts of speech out.

00:32:11.420 --> 00:32:12.750
There are some options.

00:32:12.750 --> 00:32:16.800
You can choose to omit the white
space or punctuation or what have you.

00:32:17.290 --> 00:32:22.380
And then your block will get passed
in the range of given tokens,

00:32:22.380 --> 00:32:25.190
a word let us say, and the tag.

00:32:25.260 --> 00:32:31.080
And for the lexical class scheme the tag
is just what part of speech is this word.

00:32:31.450 --> 00:32:34.260
and I can take a look at that and say,
well, if it's a noun,

00:32:34.260 --> 00:32:35.230
I want to do something with it.

00:32:35.360 --> 00:32:39.910
Maybe I'm looking just for
nouns or adjectives or adverbs.

00:32:41.190 --> 00:32:42.700
How does this work?

00:32:42.790 --> 00:32:46.640
So if I were enumerating
through this particular string,

00:32:46.790 --> 00:32:52.090
say I was doing it either by
lexical class or by lemma.

00:32:52.240 --> 00:32:54.750
So for the first word,
lexical class would

00:32:54.750 --> 00:32:56.290
say this is a pronoun.

00:32:56.380 --> 00:33:00.500
Lemma would say the basic form
is "we." That's fairly simple.

00:33:00.690 --> 00:33:03.850
For the next one,
lexical class would say this is a verb.

00:33:03.980 --> 00:33:08.740
Basic form lemma would say this
is a form of the verb "say."

00:33:09.760 --> 00:33:12.390
The "to" is a preposition.

00:33:12.480 --> 00:33:13.870
"Him" is a pronoun.

00:33:14.100 --> 00:33:18.960
Basic form is "he." It also
identifies punctuation.

00:33:19.050 --> 00:33:22.100
In some cases it gives some
more specific identification.

00:33:22.100 --> 00:33:24.700
For example,
it determines this is an open quote.

00:33:24.700 --> 00:33:27.800
This is an interjection.

00:33:27.800 --> 00:33:34.130
It determines which
punctuation is sentence ending.

00:33:34.160 --> 00:33:34.970
And it determines that
this is a closed quote.

00:33:37.140 --> 00:33:40.760
The basic API on Linguistic
Tagger is the block enumerator,

00:33:40.760 --> 00:33:42.000
but there are additional ones.

00:33:42.000 --> 00:33:46.200
You can get a specific
tag if you just want one.

00:33:46.310 --> 00:33:47.800
Tag at index.

00:33:47.940 --> 00:33:52.700
You can get a set of tags and arrange
as an array if you choose to do so.

00:33:52.890 --> 00:33:58.360
So if I just wanted to look and say,
is the word here a noun,

00:33:58.360 --> 00:34:02.120
I ask it tag at index with
a lexical class scheme,

00:34:02.210 --> 00:34:06.110
and if the tag is noun,
then it thinks it's a noun.

00:34:06.750 --> 00:34:11.940
Now, remember I said the linguistic
tagger tries to identify the language

00:34:12.070 --> 00:34:15.360
of a piece of text from the text.

00:34:15.360 --> 00:34:17.140
And in most cases that's accurate.

00:34:17.180 --> 00:34:20.760
If there's only a few words,
a few words of text,

00:34:20.760 --> 00:34:23.300
it may not be possible to
identify the language accurately.

00:34:23.300 --> 00:34:24.660
It may not do it.

00:34:24.750 --> 00:34:28.110
In some cases, if you know already the
language of a piece of text,

00:34:28.190 --> 00:34:31.810
you can tell the tagger
and it will use that.

00:34:31.900 --> 00:34:35.550
And you do so by creating
an NSOrthography object,

00:34:35.550 --> 00:34:40.930
which is basically a list of the
languages that occur in a piece of text.

00:34:41.000 --> 00:34:42.200
And you create it here.

00:34:42.200 --> 00:34:45.440
I've said this text is
English in Latin script.

00:34:45.490 --> 00:34:48.390
And I call setOrthography on
the tagger with that orthography

00:34:48.390 --> 00:34:51.540
and it tells the tagger,
okay, treat this as English.

00:34:51.610 --> 00:34:54.630
Even if you can't identify it,
treat it as English.

00:34:55.990 --> 00:34:58.710
In addition to the
NSLinguisticTagger APIs,

00:34:58.830 --> 00:35:04.390
there's a convenience API on NSString.

00:35:04.480 --> 00:35:08.490
You can just take a string and say,
"All right, for this string,

00:35:08.710 --> 00:35:12.470
go through it and enumerate
linguistic tags in a range and

00:35:12.470 --> 00:35:14.960
pick your scheme." Lexical class,
let us say,

00:35:14.960 --> 00:35:19.890
"Give me the parts of speech for the
words in this string." And you can

00:35:19.890 --> 00:35:24.200
do all the same things that you can
do with LinguisticTagger with this,

00:35:24.350 --> 00:35:26.560
but of course,
you don't have the control over the

00:35:26.640 --> 00:35:30.890
lifetime of the tagger object and
the information that it holds onto,

00:35:31.010 --> 00:35:33.320
but it's a convenience.

00:35:33.460 --> 00:35:36.660
So let's take a look at
how this works in code.

00:35:37.670 --> 00:35:42.500
Suppose I wanted to go through that
same text and color only the nouns.

00:35:42.870 --> 00:35:45.890
Well,
it's not really any more complex than

00:35:45.890 --> 00:35:48.000
any of the other things I've been doing.

00:35:48.100 --> 00:35:50.610
I create an NSLinguisticTagger.

00:35:50.650 --> 00:35:52.640
I give it some tag
schemes to start off with.

00:35:52.640 --> 00:35:56.880
I say let's do basic tokenization,
parts of speech analysis,

00:35:56.880 --> 00:36:00.800
and name recognition because
I may want those later on.

00:36:00.870 --> 00:36:02.450
And I set my string on it.

00:36:02.450 --> 00:36:05.440
Then I call it numerate tags in range.

00:36:05.530 --> 00:36:06.850
Let's choose lexical class.

00:36:06.920 --> 00:36:09.390
I want parts of speech out of this here.

00:36:09.460 --> 00:36:13.510
And so it goes through token by token.

00:36:13.580 --> 00:36:17.300
And if I find a noun, I'll color it.

00:36:17.370 --> 00:36:18.190
Very simple.

00:36:18.330 --> 00:36:21.600
See how it works.

00:36:21.670 --> 00:36:22.480
All right.

00:36:22.640 --> 00:36:25.810
Let's color all the nouns
in this piece of text.

00:36:30.810 --> 00:36:37.000
Suppose I wanted to find just the nouns
that appear in quotes in this text.

00:36:37.060 --> 00:36:40.420
I can take the same tagger,
call the same set string

00:36:40.590 --> 00:36:42.740
and enumerate tags in range.

00:36:42.740 --> 00:36:47.390
I could use my previous method that I had
to find out if a word was in quotes,

00:36:47.640 --> 00:36:50.050
but I don't need to because,
as I mentioned,

00:36:50.050 --> 00:36:52.140
the tagger keeps track of quotes.

00:36:52.140 --> 00:36:53.800
So I can just ask the tagger.

00:36:53.800 --> 00:36:56.760
Remember,
I say additional queries to the tagger

00:36:56.960 --> 00:37:00.120
are cheap once it's done the analysis.

00:37:00.170 --> 00:37:04.220
I just ask using tag at index,
and I'll look at the range

00:37:04.220 --> 00:37:09.090
immediately before this word
and ask is that an open quote?

00:37:09.520 --> 00:37:16.290
And I'll take a look at the word
at the tag at index for the index

00:37:16.300 --> 00:37:20.710
immediately following my word and ask,
is that a close quote?

00:37:20.730 --> 00:37:25.240
And if both of those are true,
then my word is in quotes.

00:37:25.250 --> 00:37:26.800
So let's try that.

00:37:26.900 --> 00:37:30.290
So let's find all the nouns that
are in quotes in this piece of text.

00:37:30.350 --> 00:37:32.130
All right, nouns in quotes.

00:37:32.700 --> 00:37:35.220
So you'll notice the
verb see is in quotes,

00:37:35.220 --> 00:37:36.700
but it doesn't show up.

00:37:36.740 --> 00:37:39.140
The adjective human is in quotes,
but it doesn't show up here.

00:37:39.140 --> 00:37:42.110
I just get fox, dog, time, and events.

00:37:44.690 --> 00:37:52.190
And finally, let's try name recognition,
which is, again, same API.

00:37:52.190 --> 00:37:56.240
I create my linguistic tagger
and enumerate tags in range,

00:37:56.240 --> 00:37:59.890
and I use the name type, and I ask,
is this one of our

00:38:00.050 --> 00:38:01.400
types of names we know?

00:38:01.400 --> 00:38:04.160
Person, place, or organization?

00:38:04.160 --> 00:38:05.800
If so, I'll color it.

00:38:05.880 --> 00:38:12.450
Let's try coloring all of the names
that appear in this piece of text.

00:38:12.450 --> 00:38:13.780
And there they are.

00:38:15.910 --> 00:38:18.810
So what sorts of things
do we use this for?

00:38:18.960 --> 00:38:24.200
At Apple we use these APIs and
this technology to do things

00:38:24.290 --> 00:38:29.080
like improving our text checking
and our auto correction.

00:38:29.200 --> 00:38:32.510
We use it for things like
lookup where you tap on a word

00:38:32.560 --> 00:38:34.500
and get information on it.

00:38:34.500 --> 00:38:36.290
You look it up in a dictionary.

00:38:36.360 --> 00:38:39.630
There are many other applications
for this potentially.

00:38:39.690 --> 00:38:42.040
You can use this to
improve your indexing.

00:38:42.140 --> 00:38:46.620
You can use it to identify names
if you want to find out who

00:38:46.730 --> 00:38:48.820
is referred to in your text.

00:38:49.100 --> 00:38:53.000
: What I want to do is to bring
up my colleague Jennifer Moore to

00:38:53.000 --> 00:38:59.680
give a little bit more involved
example of the use of these APIs.

00:39:05.180 --> 00:39:06.890
Hi, I'm Jennifer.

00:39:06.980 --> 00:39:09.880
So one of the things that I love
about something like the iPad is

00:39:09.940 --> 00:39:11.860
that it displays text so beautifully.

00:39:11.860 --> 00:39:15.100
It makes it such a pleasure to read
my favorite books and magazines.

00:39:15.100 --> 00:39:18.920
But in application there's so
many more things you can do with

00:39:18.920 --> 00:39:23.100
text if you only knew something
about the content of that text.

00:39:23.130 --> 00:39:26.990
So we've been working really hard
to provide these sophisticated tools

00:39:27.060 --> 00:39:30.530
for analyzing text so that we can
leverage this content and add more

00:39:30.530 --> 00:39:33.960
functionality to our own applications
and also make it really easy for

00:39:33.960 --> 00:39:36.100
developers to do the same thing.

00:39:36.100 --> 00:39:38.640
So one of the things that we would
like to be able to do is maybe to

00:39:38.670 --> 00:39:40.100
be able to search through text.

00:39:40.100 --> 00:39:42.100
So that's what we're going to do today.

00:39:42.100 --> 00:39:44.980
So I have this application here.

00:39:45.070 --> 00:39:47.850
I'm just going to show
you what it looks like.

00:39:49.930 --> 00:39:54.380
So basically we have a collection
of articles about different topics.

00:39:54.380 --> 00:39:57.190
And what we wanted to be able to do
is allow the user to type in a search

00:39:57.190 --> 00:40:02.510
string and be able to get back a list of
all the articles that contain words from

00:40:02.640 --> 00:40:05.700
that search string in the body of the

00:40:05.980 --> 00:40:09.830
The easiest way to do this would
be to create a dictionary and index

00:40:09.830 --> 00:40:14.780
all of our articles by all the words
in the text and keeping track of

00:40:15.010 --> 00:40:16.900
all the articles that they occur in.

00:40:17.100 --> 00:40:20.990
But of course if our application is
indexing something like Wikipedia,

00:40:20.990 --> 00:40:24.900
the dictionary size might be huge in
size and probably not really feasible,

00:40:24.900 --> 00:40:27.650
especially for something like the iPad.

00:40:28.100 --> 00:40:34.030
If you think about it, what are the most
important pieces of text?

00:40:34.060 --> 00:40:35.440
Those would be the nouns.

00:40:35.440 --> 00:40:40.400
The nouns are the words that really
represent what an article is about.

00:40:40.400 --> 00:40:44.160
We could probably go a long way towards
providing really useful search if we just

00:40:44.290 --> 00:40:47.200
go and index all the nouns in our text.

00:40:47.200 --> 00:40:51.200
With NSLinguisticTagger we can do that.

00:40:51.220 --> 00:40:54.000
Today we're going to be looking
at content-based searching

00:40:54.000 --> 00:40:58.200
using NSLinguisticTagger
and the linguistic APIs.

00:40:58.340 --> 00:41:02.110
If we go and take a look at
how this might be implemented,

00:41:03.700 --> 00:41:06.850
First of all,
we have our -- we'll just start with

00:41:06.850 --> 00:41:10.860
a -- we have a class for managing
all the articles in our collection.

00:41:11.740 --> 00:41:13.600
Basically,
there are two things we need to do.

00:41:13.600 --> 00:41:17.200
We need to be able to index our
files and then we need to be

00:41:17.200 --> 00:41:21.600
able to return a set of filtered
articles by the search string.

00:41:21.600 --> 00:41:24.950
To start off,
we're just going to go and when

00:41:24.960 --> 00:41:29.040
we allocate our articles manager,
we're going to go and index

00:41:29.040 --> 00:41:30.600
all of our files all at once.

00:41:30.600 --> 00:41:34.560
Since we're going to be processing
a lot of text all at once,

00:41:34.580 --> 00:41:37.100
the most efficient way to do
this would be just to create

00:41:37.200 --> 00:41:38.600
a linguistic tagger object.

00:41:38.600 --> 00:41:41.420
We'll just do that to start.

00:41:41.420 --> 00:41:46.020
We need to specify all the tag schemes
that we might be interested in looking at

00:41:46.080 --> 00:41:48.600
because we don't want it to be doing any
processing that it doesn't need to do.

00:41:48.600 --> 00:41:52.810
Since we're going to go and we
want all the nouns out of our text,

00:41:53.070 --> 00:41:56.600
we're going to choose a tag
scheme for lexical class.

00:41:56.600 --> 00:42:00.630
Later on, we might be also interested in
keeping track of the languages

00:42:00.630 --> 00:42:02.600
that are being used in the text.

00:42:02.600 --> 00:42:05.550
For that,
we'll want to keep track of the language

00:42:05.600 --> 00:42:07.600
and also the script because we want
to be able to interface with the text.

00:42:07.600 --> 00:42:10.600
We want to be able to interface
with NS orthography with the tagger.

00:42:10.600 --> 00:42:15.640
Then we just initialize our
tagger with these tag schemes and

00:42:15.660 --> 00:42:18.600
also our search index for later.

00:42:18.600 --> 00:42:22.000
Then we go through and for
each article that we have,

00:42:22.000 --> 00:42:24.930
we're going to go and index this article.

00:42:25.130 --> 00:42:30.240
First thing we do is call set string on
our tagger with the text of the article.

00:42:30.270 --> 00:42:31.990
Now, at this point,
if we knew the language of the text,

00:42:32.100 --> 00:42:35.500
we could also call set
orthography on the tagger.

00:42:35.500 --> 00:42:37.720
But since we're dealing with
a good amount of text here,

00:42:37.720 --> 00:42:40.480
we can be pretty confident that it
will automatically guess the right

00:42:40.480 --> 00:42:41.910
language and do the right thing.

00:42:42.160 --> 00:42:44.390
So we can just go on to our block API.

00:42:44.730 --> 00:42:50.910
We're going to call enumerate tags in
range with the range of the article.

00:42:51.100 --> 00:42:53.400
with a tag scheme for lexical class.

00:42:53.400 --> 00:42:55.730
We're not really interested
in white space or punctuation

00:42:55.730 --> 00:42:57.550
so we could just emit those.

00:42:57.670 --> 00:43:00.160
And in our block we're going
to get the tag back for the

00:43:00.160 --> 00:43:02.000
current word in the token range.

00:43:02.130 --> 00:43:05.800
So all we have to do is say, you know,
if the tag is a noun,

00:43:05.870 --> 00:43:09.760
we're going to grab the substring
corresponding to that word,

00:43:09.850 --> 00:43:13.090
lowercase it so that we
normalize it with our index,

00:43:13.210 --> 00:43:15.600
and then we'll just add
it to our dictionary.

00:43:15.680 --> 00:43:17.900
And that's all we have to do.

00:43:17.900 --> 00:43:21.550
For later purposes, as I said,
we might want to keep track of

00:43:21.550 --> 00:43:23.610
the language that's being used.

00:43:23.800 --> 00:43:26.150
We don't really know if there's
mixed -- there could be mixed

00:43:26.150 --> 00:43:27.400
languages in this document.

00:43:27.530 --> 00:43:28.000
We're not sure.

00:43:28.000 --> 00:43:30.900
So for each word we're just going to
keep track of the languages that we see.

00:43:30.900 --> 00:43:37.840
So we could just call tag it index to get
the language out and also the script out.

00:43:37.900 --> 00:43:40.500
And then we can use this to
create an NSOrthography object

00:43:40.500 --> 00:43:42.240
and keep it around for later use.

00:43:42.340 --> 00:43:43.990
More on that later.

00:43:44.390 --> 00:43:46.860
That's all we have to
do to index our files.

00:43:46.910 --> 00:43:51.180
Next thing we want to do is be able
to return a list of all the articles

00:43:51.180 --> 00:43:55.490
that contain the search string.

00:43:55.490 --> 00:43:55.490
Let me make this bigger.

00:43:57.920 --> 00:44:01.370
As Doug mentioned before,
there are also convenience

00:44:01.370 --> 00:44:02.800
methods on NSString.

00:44:02.800 --> 00:44:04.090
I'm going to show you this here.

00:44:04.160 --> 00:44:06.310
Our search string is pretty short.

00:44:06.460 --> 00:44:08.840
Or probably pretty short.

00:44:08.840 --> 00:44:14.550
We have our search string and here
we're going to call enumerate linguistic

00:44:14.550 --> 00:44:17.510
tags in range directly on NSString.

00:44:18.400 --> 00:44:20.640
Basically,
we're going to enumerate through

00:44:20.640 --> 00:44:22.540
all the words in the search string.

00:44:22.540 --> 00:44:24.280
There might be one or more terms.

00:44:24.390 --> 00:44:26.240
We don't know.

00:44:26.330 --> 00:44:30.300
For now, we're just going to use the
tax scheme for token type.

00:44:30.300 --> 00:44:33.300
We're going to emit whitespace
and punctuation again.

00:44:33.430 --> 00:44:36.320
We don't know the language
of what the user is typing,

00:44:36.320 --> 00:44:38.330
so for now we'll leave that nil.

00:44:38.810 --> 00:44:44.560
We grab the substring, lowercase it,
and then we just go check

00:44:44.560 --> 00:44:46.700
is that word in our index.

00:44:46.700 --> 00:44:49.470
If it is,
grab all the titles that it occurs

00:44:49.470 --> 00:44:51.860
in and add it to our filtered set.

00:44:51.860 --> 00:44:52.940
And that's all we have to do.

00:44:52.940 --> 00:45:01.090
So now when we run this again,
now we have this list of articles

00:45:01.090 --> 00:45:01.090
and I can type in something like

00:45:02.100 --> 00:45:14.000
[Transcript missing]

00:45:14.600 --> 00:45:17.740
Now, just to make sure that it's clear,
we're only indexing all the nouns

00:45:17.740 --> 00:45:19.300
that are being used in our text.

00:45:19.320 --> 00:45:21.330
I just want to show you,
I don't know if you can see this,

00:45:21.440 --> 00:45:24.690
but there's a sentence here that says,
can't wait to share the latest news,

00:45:24.710 --> 00:45:25.210
right?

00:45:25.230 --> 00:45:28.710
And here,
the word share is being used as a verb,

00:45:28.710 --> 00:45:29.520
right?

00:45:29.620 --> 00:45:33.760
So we'd expect that if we typed in share,
you know, we wouldn't get this article,

00:45:33.760 --> 00:45:36.430
but maybe we'd get an
article on market share or,

00:45:36.430 --> 00:45:40.840
you know, stock shares,
like this nice Apple financial report,

00:45:40.840 --> 00:45:41.580
right?

00:45:42.160 --> 00:45:44.160
So, right.

00:45:44.180 --> 00:45:47.060
Yes.

00:45:48.190 --> 00:45:51.600
So let's go back to this example again.

00:45:51.600 --> 00:45:56.700
So here, I typed in developers,
which is the plural form of developer.

00:45:56.700 --> 00:46:00.790
But if I typed in just the singular form,
I don't get any results back,

00:46:00.930 --> 00:46:03.500
because that word didn't
actually occur in my text.

00:46:03.500 --> 00:46:06.820
And that's kind of a bummer,
because they mean the same thing.

00:46:06.820 --> 00:46:10.490
And especially for languages like
Italian and Spanish or German,

00:46:10.490 --> 00:46:13.700
there might be multiple forms
for the same kind of word.

00:46:13.780 --> 00:46:16.720
So I don't have to index
all those inflicted terms,

00:46:16.720 --> 00:46:21.840
or the user just has to know exactly
what word is being used in the text.

00:46:21.920 --> 00:46:25.370
So this is where something like
lemmatization would really come in handy,

00:46:25.370 --> 00:46:28.730
because instead of indexing
what I call the surface term,

00:46:29.000 --> 00:46:32.100
surface form of a word,
we could just go and index all the

00:46:32.100 --> 00:46:35.840
lemmas for each noun in our text.

00:46:35.840 --> 00:46:39.720
So let's go see how we
would do that instead.

00:46:39.720 --> 00:46:44.470
So we go back to our methods here,
two methods here.

00:46:46.110 --> 00:46:51.690
So up here in our index article,
let's just comment this guy out for now.

00:46:53.200 --> 00:46:58.200
I have a little snippet of code here.

00:46:58.210 --> 00:47:00.200
Just a little bit updated.

00:47:00.360 --> 00:47:04.200
To do this is really easy.

00:47:08.310 --> 00:47:11.000
So here instead,
so we say if the tag is a noun,

00:47:11.000 --> 00:47:15.470
instead of indexing just a substring,
we're going to call tag it

00:47:15.600 --> 00:47:17.860
index to get the lemma out.

00:47:17.860 --> 00:47:20.440
And if there's a lemma,
we set our index term to be the lemma.

00:47:20.440 --> 00:47:23.040
If not, we'll default to the substring.

00:47:23.040 --> 00:47:26.630
And then we just add it
to our index as usual.

00:47:26.630 --> 00:47:27.480
Right?

00:47:27.480 --> 00:47:32.390
And then for our filter articles,

00:47:34.900 --> 00:47:41.230
Okay, I'm going to actually
comment this whole block out.

00:47:48.350 --> 00:47:53.300
Grab this.

00:47:53.300 --> 00:47:55.760
Now, it's important to mention
that if we're searching,

00:47:55.760 --> 00:47:58.400
the search string is probably
going to be very short,

00:47:58.400 --> 00:48:01.760
so the -- so the tagger is
probably going to have a difficult

00:48:01.760 --> 00:48:03.270
time guessing the language.

00:48:03.270 --> 00:48:06.140
It's not going to be very
clear from one or two words.

00:48:06.140 --> 00:48:09.380
So all we have to do,
since we kept track of all the languages

00:48:09.380 --> 00:48:13.770
that we're being used in our text,
and because the search string is

00:48:14.330 --> 00:48:17.240
going to be very short instead,
anyway,

00:48:17.240 --> 00:48:20.040
we can just go through all the languages
that we know occur in our text and

00:48:20.130 --> 00:48:25.060
get the lemma out for that word and
check if it occurs in our index.

00:48:25.090 --> 00:48:27.020
So that's all we're going to do here.

00:48:27.020 --> 00:48:28.910
So for each of the languages
that occur in our texts,

00:48:29.090 --> 00:48:34.610
in our collection of text,
we will go and get all the lemmas out.

00:48:35.430 --> 00:48:39.110
using NST's linguistic
tag scheme for lemma.

00:48:39.310 --> 00:48:42.140
If there's a lemma available,
we'll set our search term to the lemma.

00:48:42.180 --> 00:48:45.940
If not, we will default to the substring.

00:48:45.940 --> 00:48:51.650
And that's all we have to do again.

00:48:51.650 --> 00:48:51.650
So we could just run this now.

00:48:52.060 --> 00:48:56.870
And now when we type in developer,
now we get our article.

00:48:56.910 --> 00:49:00.510
So here you can see all the instances
where developers were found with

00:49:00.550 --> 00:49:03.770
the lemma for the search string.

00:49:04.900 --> 00:49:08.190
And of course,
this is not just for English.

00:49:08.220 --> 00:49:11.740
So if I could type in
something like "monaten"

00:49:12.500 --> 00:49:18.660
. I will get this nice German article.

00:49:18.660 --> 00:49:21.200
Even though monaten
doesn't occur in this text,

00:49:21.200 --> 00:49:25.770
it will still find the text.

00:49:26.010 --> 00:49:29.290
That is multilingual content-based
searching using a Neslinguistic tagger.

00:49:29.290 --> 00:49:29.290
Thank you very much.

00:49:35.220 --> 00:49:36.900
Thanks, Jennifer.

00:49:36.900 --> 00:49:37.580
Okay.

00:49:37.650 --> 00:49:40.900
So let me summarize what
we've discussed here.

00:49:41.010 --> 00:49:45.770
The way that we want to promote for
you to analyze text is to find ranges

00:49:45.770 --> 00:49:49.200
of interest within your NSStrings.

00:49:49.300 --> 00:49:53.840
We use the Foundation APIs available
on both OS X and iOS to iterate

00:49:54.120 --> 00:49:55.900
over the ranges of interest.

00:49:55.900 --> 00:50:00.200
In many cases, block enumeration
APIs will do this for you.

00:50:00.200 --> 00:50:04.700
There are some other APIs that will
find a particular range of interest.

00:50:04.720 --> 00:50:08.300
And depending on the sort
of thing you're looking for,

00:50:08.420 --> 00:50:10.300
there are different APIs you can use.

00:50:10.300 --> 00:50:15.800
The NSString enumeration or search APIs,
NS character set search APIs,

00:50:15.920 --> 00:50:22.090
regular expressions, data detectors,
and finally, the linguistic tagger.

00:50:22.190 --> 00:50:27.100
And these all work together very well,
as we've shown in these examples,

00:50:27.180 --> 00:50:30.300
to find various pieces in combination.

00:50:30.520 --> 00:50:34.300
For more information,
you can contact our evangelist.

00:50:34.300 --> 00:50:39.170
We have a string programming guide for
Cocoa for the particular details of

00:50:39.200 --> 00:50:41.300
the regular expression syntax we use.

00:50:41.300 --> 00:50:46.300
It's provided by the
ICU regular expression library.

00:50:46.300 --> 00:50:50.290
I encourage you to take a look
at the headers for these classes.

00:50:50.300 --> 00:50:53.590
I actually wrote many of them,
so they contain detailed

00:50:53.590 --> 00:50:56.300
information on all of these things.

00:50:56.690 --> 00:50:59.570
There are some other related
sessions this afternoon.

00:50:59.610 --> 00:51:03.130
One on keyboard input in iOS,
which has a lot of things

00:51:03.130 --> 00:51:04.600
related to text handling.

00:51:04.600 --> 00:51:07.710
Attributed strings for
iOS this afternoon.

00:51:08.160 --> 00:51:09.550
An advanced session tomorrow.

00:51:09.580 --> 00:51:13.600
And internationalization on Friday.

00:51:13.760 --> 00:51:15.600
And that's what we have for you today.

00:51:15.600 --> 00:51:16.600
Thank you very much.
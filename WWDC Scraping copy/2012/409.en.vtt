WEBVTT

00:00:10.300 --> 00:00:11.290
Good afternoon.

00:00:11.290 --> 00:00:15.300
How is everyone doing?

00:00:15.300 --> 00:00:22.290
Show of hands,
how many people are first conference?

00:00:23.250 --> 00:00:23.530
Wow.

00:00:24.520 --> 00:00:26.800
How many people have used
Instruments even once?

00:00:27.540 --> 00:00:28.920
Whoa.

00:00:28.940 --> 00:00:30.150
Impressive.

00:00:30.280 --> 00:00:32.290
So we're here to talk
about learning Instruments.

00:00:32.380 --> 00:00:34.400
I've had the pleasure of
working with most of you in the

00:00:34.400 --> 00:00:35.520
lab for the past couple days.

00:00:35.520 --> 00:00:38.900
We'll be in labs for
the rest of the week.

00:00:38.900 --> 00:00:38.900
But let's get started.

00:00:39.800 --> 00:00:41.740
What are you going to go over today?

00:00:41.890 --> 00:00:43.530
First, we're going to go over
elements of performance.

00:00:43.530 --> 00:00:50.730
This is important to set baseline and
for us to figure out what we're talking

00:00:50.770 --> 00:00:50.770
about and what sorts of things we're
going to optimize our applications for.

00:00:50.980 --> 00:00:52.840
We're going to give you a
methodology for performance.

00:00:52.910 --> 00:00:56.030
This is a technique that's proven,
a technique I've gone over with many

00:00:56.030 --> 00:00:58.800
of you in the labs that have come
and spoke with us and the rest of

00:00:58.800 --> 00:01:00.690
the Instruments team all this week.

00:01:00.970 --> 00:01:02.410
We're going to give you a
brief tour of Instruments,

00:01:02.500 --> 00:01:04.120
although with the number
of people already seen it,

00:01:04.250 --> 00:01:06.060
maybe I should cut that part out.

00:01:06.200 --> 00:01:10.940
But, and then we have some excellent
iOS optimization demonstrations.

00:01:10.940 --> 00:01:12.760
We made an app special
for the conference.

00:01:12.910 --> 00:01:14.640
We have a few interesting problems.

00:01:14.710 --> 00:01:17.460
And we'll show you how you can use
Instruments to find those problems.

00:01:17.500 --> 00:01:19.420
I think you'll relate to
these problems and you'll find

00:01:19.420 --> 00:01:21.570
them to be very interesting.

00:01:22.090 --> 00:01:23.760
What is performance?

00:01:23.760 --> 00:01:24.710
This seems fairly obvious.

00:01:24.820 --> 00:01:28.200
The first one is probably a gimme,
but we'll start there.

00:01:28.280 --> 00:01:30.770
We all want our application to be fast.

00:01:30.880 --> 00:01:32.760
That's fairly obvious.

00:01:32.860 --> 00:01:35.490
But what some people don't
think of sometimes is we also

00:01:35.630 --> 00:01:37.160
want it to be responsive.

00:01:37.420 --> 00:01:40.660
And lastly, we want it to be efficient.

00:01:40.790 --> 00:01:44.260
So you can use Instruments to
accomplish all of these goals.

00:01:44.390 --> 00:01:46.400
And there's an interesting side effect.

00:01:46.540 --> 00:01:51.730
If you focus on these three elements,
you also tend to save battery life.

00:01:51.740 --> 00:01:53.700
And we're working with mobile devices.

00:01:53.840 --> 00:01:58.610
Our customers expect and demand that our
applications don't drain their battery.

00:01:59.080 --> 00:02:02.660
So, if you use Instruments to
profile your application,

00:02:02.660 --> 00:02:05.170
you'll be able to also
optimize for battery life.

00:02:07.000 --> 00:02:09.400
If you don't use Instruments
to profile your application,

00:02:09.400 --> 00:02:12.360
this might be one of
your app review comments.

00:02:12.530 --> 00:02:13.900
Or this one.

00:02:14.030 --> 00:02:17.390
And most certainly,
this will be your rating.

00:02:19.200 --> 00:02:22.330
So we consider performance a
feature of your application.

00:02:22.340 --> 00:02:25.840
It's just as important as
what your application does.

00:02:25.850 --> 00:02:29.040
Use Xcode to author and
build your application.

00:02:29.060 --> 00:02:31.540
Use Interface Builder to
put the bits on the screen,

00:02:31.540 --> 00:02:33.680
decide how your layouts are going to be.

00:02:33.680 --> 00:02:37.500
Use Instruments to
profile your application.

00:02:37.500 --> 00:02:39.070
It's just as important as the compile.

00:02:39.200 --> 00:02:41.200
It's just as important
as Interface Builder.

00:02:41.200 --> 00:02:43.280
You use it to optimize your performance.

00:02:43.320 --> 00:02:46.460
You can use it to reduce
crashes and terminations.

00:02:46.460 --> 00:02:49.080
And you can use it to
improve your power usage.

00:02:49.100 --> 00:02:50.390
Thank you.

00:02:51.160 --> 00:02:52.190
What is the process?

00:02:52.300 --> 00:02:54.820
I've had a lot of you come to
the lab this week and said,

00:02:54.890 --> 00:02:59.250
"What should I do?" And we have a
really excellent example in my opinion.

00:02:59.300 --> 00:03:01.440
A lot of you are familiar
with debugging your computer,

00:03:01.440 --> 00:03:05.250
and when you're debugging your computer,
when you're debugging your app,

00:03:05.310 --> 00:03:06.970
you reproduce your problem.

00:03:07.460 --> 00:03:10.840
You then use the debugger to
inspect the code and you maybe

00:03:10.840 --> 00:03:12.380
add some logging messages.

00:03:12.440 --> 00:03:15.100
Based on what you see in the debugger,
you form a hypothesis.

00:03:15.100 --> 00:03:18.850
"Hey, if I make this change,
my app's going to stop crashing."

00:03:18.850 --> 00:03:21.350
You then actually make the change.

00:03:21.900 --> 00:03:23.960
and reproduce the problem.

00:03:24.080 --> 00:03:27.750
Well,
the profile process is nearly identical.

00:03:28.350 --> 00:03:31.390
But instead of debugging a problem,
we're going to measure the problem.

00:03:31.400 --> 00:03:34.740
So you have an area of your
application that's going a little slow.

00:03:34.930 --> 00:03:37.060
Reproduce the slowness.

00:03:37.100 --> 00:03:39.900
Use Instruments to profile
your application while

00:03:39.900 --> 00:03:41.990
you're doing the slowness.

00:03:42.350 --> 00:03:46.200
Use the data Instruments showing you
in order to form a hypothesis about

00:03:46.200 --> 00:03:50.510
what you could do differently in your
application that might speed the code up.

00:03:51.390 --> 00:03:55.500
Make the change that
you hypothesized about.

00:03:55.600 --> 00:03:58.280
And most importantly,
go back and measure that you

00:03:58.280 --> 00:03:59.990
actually improved the situation.

00:04:00.090 --> 00:04:04.990
The number of people who sometimes
don't do this is interesting.

00:04:06.770 --> 00:04:07.920
Where can I find Instruments?

00:04:08.020 --> 00:04:10.450
Well, the good news is you don't
have to do anything else.

00:04:10.460 --> 00:04:11.630
It's included with Xcode.

00:04:11.800 --> 00:04:16.360
All of you who have Xcode on your
hard drive right now have Instruments.

00:04:16.360 --> 00:04:18.520
We've given you at least
two ways to access it.

00:04:18.630 --> 00:04:20.930
There's more,
but we'll go over the top two.

00:04:20.940 --> 00:04:22.900
The first way is under the Xcode menu.

00:04:23.090 --> 00:04:24.750
You can use open developer tools.

00:04:24.840 --> 00:04:28.710
And it's so important,
it's the first application listed.

00:04:30.170 --> 00:04:32.730
There's also the profile
command under the Run menu,

00:04:32.830 --> 00:04:34.690
or under the Project menu under Run.

00:04:34.770 --> 00:04:37.420
Profile is one of my favorite features
of Instruments because what it

00:04:37.420 --> 00:04:41.440
actually does is launches Instruments,
pre-targets your application,

00:04:41.440 --> 00:04:44.060
and will actually stop and start
your application as you start

00:04:44.060 --> 00:04:46.470
and stop traces in Instruments,
which you'll see later.

00:04:46.580 --> 00:04:50.000
So this is the easiest way
to get into Instruments.

00:04:50.680 --> 00:04:52.250
We have a little pro tip here.

00:04:52.370 --> 00:04:54.770
When Instruments is running,
it's actually a separate app bundle.

00:04:54.840 --> 00:04:56.200
It shows up in the dock.

00:04:56.340 --> 00:04:59.230
You can right-click on the dock icon and
choose to keep Instruments in the dock

00:04:59.420 --> 00:05:03.590
so that you always have quick access
to it to profile your applications.

00:05:04.870 --> 00:05:09.820
So we're going to give you a brief
tour right now on the screen behind me.

00:05:09.860 --> 00:05:10.880
Instruments is a document model.

00:05:10.880 --> 00:05:13.010
What that means is when
you launch Instruments,

00:05:13.010 --> 00:05:15.460
we ask you to pick a template,
much like Keynote asks

00:05:15.570 --> 00:05:18.350
you to pick something,
Pages asks you to pick a template.

00:05:18.370 --> 00:05:22.340
But Instruments templates are
common profiling operations

00:05:22.340 --> 00:05:24.060
that you'd want to perform.

00:05:24.370 --> 00:05:27.360
What you see on the screen is time
profile leaks and allocations.

00:05:27.420 --> 00:05:29.440
Once you pick a template,
you now have what we

00:05:29.440 --> 00:05:30.710
call a trace document.

00:05:30.890 --> 00:05:34.110
And all of the data that you record
will go into that trace document and

00:05:34.150 --> 00:05:37.150
you can save it after you've made
your recording and review it later

00:05:37.150 --> 00:05:39.150
or review it right after you're done.

00:05:39.290 --> 00:05:42.730
So it's a document model,
standard document window, fairly common.

00:05:44.820 --> 00:05:48.320
Once you have the document window open,
there are several elements on the screen,

00:05:48.320 --> 00:05:51.600
and we're going to tour these elements
on the screen so that all of you have

00:05:51.600 --> 00:05:53.320
an idea what function they perform.

00:05:53.320 --> 00:05:56.680
There's a toolbar, which lets you control
recordings and such.

00:05:56.730 --> 00:05:58.180
I'll go into more detail on that later.

00:05:58.180 --> 00:06:00.910
The left-hand side we
call the Strategy section.

00:06:00.920 --> 00:06:03.240
These are what instruments
you've added to your document.

00:06:03.240 --> 00:06:05.820
Normally what's there is what you
selected when you picked a template,

00:06:05.820 --> 00:06:09.250
but you can actually customize that
and add any instrument you want.

00:06:10.160 --> 00:06:11.000
There's a Timeline view.

00:06:11.000 --> 00:06:14.190
This is where we will show the
time-based data of what we were recording

00:06:14.190 --> 00:06:16.040
over time from your application.

00:06:16.040 --> 00:06:18.440
At the bottom, there's a Details section.

00:06:18.440 --> 00:06:20.180
This is really interesting.

00:06:20.180 --> 00:06:22.800
There's all sorts of interesting
information shows up here.

00:06:22.800 --> 00:06:26.440
But what's most interesting is the
Details section automatically configures

00:06:26.440 --> 00:06:30.140
itself and customizes itself to show
the most relevant information based on

00:06:30.210 --> 00:06:31.740
the instrument that you used to record.

00:06:31.740 --> 00:06:34.520
For example, when doing a time profile,
we get CPU usage,

00:06:34.520 --> 00:06:37.190
but when doing allocations,
you get the amount of memory

00:06:37.190 --> 00:06:39.740
that's been allocated,
as shown in the Details section.

00:06:39.920 --> 00:06:41.400
section.

00:06:41.710 --> 00:06:45.800
and the extended detail section
is also very powerful and can

00:06:45.800 --> 00:06:49.600
occasionally illuminate data that's
hard to see in the detail section.

00:06:49.740 --> 00:06:51.600
All of these will be used
in the demonstration.

00:06:51.600 --> 00:06:54.910
I think you'll enjoy
seeing what they can do.

00:06:55.310 --> 00:06:59.940
The toolbar is fairly important.

00:07:00.000 --> 00:07:04.520
The first and most important menu in the
toolbar is what are you going to target?

00:07:04.890 --> 00:07:07.650
Now, all processes is something we
do at Apple because we want to

00:07:07.860 --> 00:07:11.190
profile the entire operating system,
but most of you are app developers.

00:07:11.250 --> 00:07:14.300
And so it's important for you to
pick your application from the target

00:07:14.300 --> 00:07:16.200
menu before you start recording.

00:07:16.200 --> 00:07:22.110
In this case, we're picking Safari,
and I'm going to profile Safari and see

00:07:22.110 --> 00:07:22.200
if I can give the team some feedback.

00:07:22.930 --> 00:07:25.850
After you've picked your target,
you can use the record button

00:07:25.850 --> 00:07:27.720
to start and stop a trace.

00:07:27.840 --> 00:07:31.380
This will allow you to get
your application launched,

00:07:31.410 --> 00:07:33.200
get to where you want
to do the profile step,

00:07:33.530 --> 00:07:37.080
start recording, go reproduce the problem
with your application.

00:07:37.190 --> 00:07:40.480
When the problem reproduces,
you come back to your stop the recording,

00:07:40.520 --> 00:07:44.050
and now you have a precise trace
of what you were trying to analyze

00:07:44.050 --> 00:07:46.280
or what you were trying to profile.

00:07:46.900 --> 00:07:48.770
We have a timeline,
and this lets you set start

00:07:48.770 --> 00:07:50.300
and end points on the timeline.

00:07:50.300 --> 00:07:53.090
Sometimes you have too much data,
sometimes the data is too

00:07:53.230 --> 00:07:55.020
small or too compressed.

00:07:55.110 --> 00:07:57.600
You can use these controls
to zoom in on the timeline,

00:07:57.600 --> 00:07:59.860
pick a range of the timeline so
that you can focus on just the

00:07:59.960 --> 00:08:01.400
data that's most relevant to you.

00:08:01.400 --> 00:08:02.840
This is a time window.

00:08:02.920 --> 00:08:07.230
It shows you how long the trace data is,
how much trace data you have,

00:08:07.390 --> 00:08:08.910
how many runs you have.

00:08:09.000 --> 00:08:12.540
One of my other favorite features is
you can run a trace multiple times,

00:08:12.540 --> 00:08:15.790
and Instruments lets you compare
multiple runs side by side.

00:08:17.540 --> 00:08:20.920
Instruments is a pained window,
so you can actually choose

00:08:20.920 --> 00:08:22.380
what panes are showing.

00:08:22.440 --> 00:08:25.020
What's highlighted here is
the left-hand side is shown.

00:08:25.090 --> 00:08:27.500
The bottom and the
extended detail are hidden.

00:08:27.500 --> 00:08:31.360
You can click on that to use your
screen real estate appropriately

00:08:31.360 --> 00:08:34.970
to show more or less data based
on what you want to achieve.

00:08:35.300 --> 00:08:36.040
and the library.

00:08:36.040 --> 00:08:39.450
The library window lets you show
other Instruments that maybe weren't

00:08:39.550 --> 00:08:43.010
part of the template and add them
to the strategy section so that you

00:08:43.020 --> 00:08:47.440
could maybe combine file I/O tracing
along with your CPU load tracing and

00:08:47.530 --> 00:08:51.830
see if your file I/O has something
to do with your CPU load problems.

00:08:52.750 --> 00:08:55.260
This is a sample timeline
of a time profile I took of

00:08:55.260 --> 00:08:58.900
Safari reloading the Apple website
over and over and over again.

00:08:59.090 --> 00:09:02.390
The purple lines are CPU load.

00:09:02.560 --> 00:09:07.720
and you can see this is, you know,
it's a timeline from left to right.

00:09:07.720 --> 00:09:11.540
The three buttons above the time profile
icon are what we call the strategy view.

00:09:11.540 --> 00:09:14.160
And the strategy view you're
seeing here is the instrument view.

00:09:14.170 --> 00:09:16.860
And what we mean by that is this
is the way the instrument has

00:09:16.860 --> 00:09:18.390
chosen to represent its data.

00:09:18.480 --> 00:09:21.660
Different instruments will
draw the timeline differently.

00:09:21.660 --> 00:09:23.540
This instrument has an alternate view.

00:09:23.610 --> 00:09:26.070
This actually lets you see
all of the threads that your

00:09:26.070 --> 00:09:27.310
application was running.

00:09:27.420 --> 00:09:31.050
And each one of those little stopwatches
on there represents a different sample

00:09:31.070 --> 00:09:33.240
from where instruments took a sample.

00:09:33.270 --> 00:09:36.170
And that represents an entire
backtrace at that point in time

00:09:36.210 --> 00:09:40.580
of where your application was
executing when we took that sample.

00:09:40.580 --> 00:09:43.220
This is very useful for debugging
concurrency problems or optimizing

00:09:43.220 --> 00:09:46.300
performance where you can see how the
threads are interacting and ping-ponging.

00:09:48.270 --> 00:09:51.750
The last strategy view in Time Profile
is the Core Strategy View or

00:09:51.750 --> 00:09:53.720
the CPU Strategy View.

00:09:53.780 --> 00:09:58.080
And this lets you show what CPUs
your process was actually scheduled

00:09:58.080 --> 00:10:00.480
on by the operating system.

00:10:01.280 --> 00:10:04.060
This lets you see how much
parallelism you're actually achieving.

00:10:04.100 --> 00:10:06.820
If you've optimized your
code and choose parallel,

00:10:06.960 --> 00:10:10.930
what you should see is activity on
all of the cores simultaneously,

00:10:10.930 --> 00:10:13.740
and we'll have a
demonstration of that later.

00:10:15.240 --> 00:10:16.560
The timeline can be filtered.

00:10:16.680 --> 00:10:20.720
We've switched here from a time
profiler view to a system trace view,

00:10:20.720 --> 00:10:22.880
and you can see the data
is presented differently.

00:10:22.880 --> 00:10:26.370
The highlighted section there
I used by shift-clicking,

00:10:26.370 --> 00:10:31.030
and that allows me to zoom in on that
section and see the data in more detail.

00:10:34.710 --> 00:10:36.860
In this view is the
detail pan at the bottom.

00:10:36.860 --> 00:10:38.820
You can see what we call a call tree.

00:10:38.820 --> 00:10:41.300
This is probably the most,
the bread and butter data

00:10:41.580 --> 00:10:43.530
that Instruments presents.

00:10:43.530 --> 00:10:46.500
When Instruments runs,
most of the time we're sampling a

00:10:46.500 --> 00:10:49.790
backtrace and we have the actual
symbol from when we took a sample

00:10:49.790 --> 00:10:52.820
of your application of what it
was doing at that exact second.

00:10:52.820 --> 00:10:55.220
We sort, sift,
and present all of that information

00:10:55.230 --> 00:10:56.600
to you in the detail view.

00:10:56.600 --> 00:11:00.340
And we can normally show you the
line of code that allocated too much

00:11:00.340 --> 00:11:04.120
memory or took too much CPU time
or was on the CPU too frequently.

00:11:04.700 --> 00:11:06.840
The call tree views
in the detail section,

00:11:06.840 --> 00:11:07.920
as you can see here on the screen.

00:11:07.920 --> 00:11:12.630
And what you're seeing here on the screen
is main thread took 53.6% of our time.

00:11:12.920 --> 00:11:16.360
We could drill down there and find
out more details about why main thread

00:11:16.360 --> 00:11:18.500
was taking up that much of our time.

00:11:19.160 --> 00:11:22.600
I can change the views in the jump
bar by choosing a pop-up view,

00:11:22.600 --> 00:11:25.400
and you can see the actual
samples that we took.

00:11:25.420 --> 00:11:28.120
Again,
what's on screen is 0 through 7 and 8.

00:11:28.140 --> 00:11:31.310
There's probably 10,000,
12,000 samples in this list,

00:11:31.360 --> 00:11:33.120
but this is the actual
data that we sampled.

00:11:33.120 --> 00:11:37.210
Sometimes if the data's not being
illuminated in the call tree view,

00:11:37.310 --> 00:11:40.040
you can plow through the
detail view yourself and

00:11:40.110 --> 00:11:42.330
find interesting information.

00:11:43.480 --> 00:11:46.340
We can also show you your
source code in this view.

00:11:46.420 --> 00:11:49.400
So you can double click on a call tree,
click on the focus icon,

00:11:49.420 --> 00:11:51.230
and we'll actually show you the code.

00:11:51.380 --> 00:11:56.120
What this window is showing us is
that G-Lunar texture was 75% of the

00:11:56.120 --> 00:11:59.100
samples in this particular case.

00:11:59.240 --> 00:12:01.940
And if that was a problem for you,
you'd know that that was the

00:12:01.940 --> 00:12:05.470
line of code to work or replace
or find something different.

00:12:06.570 --> 00:12:08.120
This is the extended detail view.

00:12:08.130 --> 00:12:12.860
It sometimes shows information
that's more succinct or more precise.

00:12:12.960 --> 00:12:15.340
And you can see here that
for this particular sample,

00:12:15.340 --> 00:12:18.060
75% of the time was at
the value texture line,

00:12:18.060 --> 00:12:22.110
and the other 25% was spent
doing S print F buffer.

00:12:23.990 --> 00:12:25.830
We can also show you the disassembly.

00:12:25.920 --> 00:12:28.990
There are some cases where you have
handwritten assembly code or you

00:12:28.990 --> 00:12:32.090
have instruction scheduling issues,
and you can use Instruments

00:12:32.210 --> 00:12:35.990
to find out what instructions
are taking most of the time.

00:12:36.940 --> 00:12:39.420
This is a system call
view with a detailed pane.

00:12:39.690 --> 00:12:45.890
This is showing us that Mach timer
arm is taking 57% of our time.

00:12:46.020 --> 00:12:48.460
And you can see that the
timeline is radically different.

00:12:48.560 --> 00:12:50.720
Each of the samples on the
timeline above with the little

00:12:50.720 --> 00:12:52.320
telephone represents a system call.

00:12:52.320 --> 00:12:54.850
And I can actually get a back
trace of what my code was doing

00:12:54.860 --> 00:12:56.400
when it made that system call.

00:12:56.400 --> 00:12:58.660
If you're getting a
stall with a system call,

00:12:58.740 --> 00:13:02.390
you could actually see what part
of your program was causing that.

00:13:05.120 --> 00:13:06.300
Next slide.

00:13:06.330 --> 00:13:07.200
There we go.

00:13:07.200 --> 00:13:10.160
And this is just another example
of the variability in Instruments

00:13:10.160 --> 00:13:13.270
display and the flexibility in that
we can show the activity monitor,

00:13:13.270 --> 00:13:14.990
which provides an excellent summary.

00:13:15.030 --> 00:13:17.400
In this case,
the Galaxy's program was the

00:13:17.430 --> 00:13:21.430
lion's share of the CPU time,
and we have user load, system load,

00:13:21.430 --> 00:13:24.880
and various size and VM size
information up on screen.

00:13:25.210 --> 00:13:27.240
So Instruments is very flexible,
very versatile.

00:13:27.240 --> 00:13:29.410
We can show you data in
a lot of different ways.

00:13:29.410 --> 00:13:32.840
And at this time,
I'd like to bring Joe Grzywak on stage

00:13:32.910 --> 00:13:36.030
and quit talking about screenshots and
actually show you how to use Instruments

00:13:36.120 --> 00:13:37.680
to optimize an actual application.

00:13:37.780 --> 00:13:39.780
Thank you.

00:13:46.850 --> 00:13:48.590
Thank you, Dave.

00:13:48.840 --> 00:13:50.030
Hello, my name is Joe Grzywacz.

00:13:50.160 --> 00:13:51.680
I'm an engineer on the
Performance Tools team.

00:13:51.680 --> 00:13:54.680
And today I want to take you
through using Time Profiler template

00:13:54.680 --> 00:13:58.060
in order to optimize an example
application we wrote for you today.

00:13:58.060 --> 00:14:03.310
Okay, so we're going to get right to it,
launch our project in Xcode.

00:14:06.170 --> 00:14:07.740
Now,
the first thing we're going to do when

00:14:07.740 --> 00:14:11.370
we're running with Time Profiler is
make sure you're targeting your device.

00:14:11.580 --> 00:14:13.690
Running on the simulator will show
completely different performance

00:14:13.740 --> 00:14:16.770
characteristics as you're running on
your local host instead of the device.

00:14:16.810 --> 00:14:19.690
So make sure we have
our iPad here targeted.

00:14:19.770 --> 00:14:21.500
Click and hold on Run.

00:14:21.550 --> 00:14:22.680
Choose Profile.

00:14:22.730 --> 00:14:24.200
That'll build our
application in release mode.

00:14:24.200 --> 00:14:25.200
That's important.

00:14:25.200 --> 00:14:28.160
We want to make sure we're optimizing
the release bits that we're going

00:14:28.160 --> 00:14:29.580
to be giving to our customers.

00:14:29.810 --> 00:14:31.630
That'll sync to the device,
and up will pop the

00:14:31.630 --> 00:14:33.290
Instruments template chooser.

00:14:33.290 --> 00:14:35.980
Here we're going to be selecting
the Time Profiler template,

00:14:35.980 --> 00:14:38.980
as I have some performance
problems I want to investigate.

00:14:38.980 --> 00:14:40.230
So we'll choose Profile.

00:14:40.230 --> 00:14:44.260
Up immediately will pop Instruments,
and it's recording data in real time

00:14:44.290 --> 00:14:48.080
for us and updating the timeline,
so as I interact with the application,

00:14:48.080 --> 00:14:50.080
I get data feedback right away.

00:14:51.020 --> 00:14:54.360
I've stopped this recording because
I want to actually take this time

00:14:54.360 --> 00:14:55.980
to switch a recording option.

00:14:55.980 --> 00:15:00.020
You can do this by selecting in
the Time Profiler instrument,

00:15:00.020 --> 00:15:02.100
this little eye icon is your inspector.

00:15:02.100 --> 00:15:04.500
Open this up,
we see some recording options.

00:15:04.500 --> 00:15:06.890
We're going to select
Record Waiting Threads,

00:15:06.890 --> 00:15:09.780
and we'll get to why we did
that in just a little while.

00:15:11.490 --> 00:15:13.270
For now,
since we haven't made any code changes,

00:15:13.270 --> 00:15:16.020
you can actually just use the record
button right from Instruments.

00:15:16.070 --> 00:15:18.880
It'll launch your application once again.

00:15:19.480 --> 00:15:23.420
First,
I would like to go to the iPad device.

00:15:23.480 --> 00:15:25.400
We can see that.

00:15:25.460 --> 00:15:30.400
And now I will press
record within Instruments.

00:15:30.400 --> 00:15:30.400
And...

00:15:30.710 --> 00:15:30.980
All right.

00:15:31.040 --> 00:15:32.500
So we see our app came up.

00:15:32.500 --> 00:15:35.260
Once again,
I'm going to tap on the top paid ocean,

00:15:35.390 --> 00:15:37.770
and we're going to have
to refetch that RSS down,

00:15:37.850 --> 00:15:39.940
that feed, as we do that each time.

00:15:41.440 --> 00:15:43.700
Instruments is providing me with
real-time data here that I can

00:15:43.790 --> 00:15:44.860
see and you'll see in a moment.

00:15:44.860 --> 00:15:48.630
And while the application is running,
let me describe to you what it's doing.

00:15:48.630 --> 00:15:50.100
So it downloaded the RSS feed.

00:15:50.100 --> 00:15:53.020
It's going to start drawing
some icons across the screen.

00:15:53.020 --> 00:15:55.840
In order to do that,
it's going to go out to the internet,

00:15:55.840 --> 00:15:57.100
download the icons.

00:15:57.490 --> 00:16:00.340
And you can see we're actually running
here at a pretty miserable frame rate,

00:16:00.380 --> 00:16:01.740
something like five frames per second.

00:16:01.740 --> 00:16:04.120
Now I'm expecting 60 frames per second.

00:16:04.120 --> 00:16:06.780
When I wrote the application,
I created a timer,

00:16:06.780 --> 00:16:10.880
fire 60 times per second,
should call into my main thread,

00:16:10.880 --> 00:16:14.060
wake it up,
move all the icons across the screen,

00:16:14.150 --> 00:16:17.170
and then draw the screen
and go back to sleep.

00:16:17.380 --> 00:16:19.460
We can see here we have some
icons moving across the screen.

00:16:19.460 --> 00:16:21.420
There's some schools of icons.

00:16:21.420 --> 00:16:23.670
There's parents with their
children following behind them.

00:16:23.670 --> 00:16:27.000
And we're trying to collect
enough data here that we can

00:16:27.040 --> 00:16:29.260
actually analyze this problem.

00:16:29.960 --> 00:16:31.870
And so we're getting to a
point here where actually,

00:16:31.930 --> 00:16:34.050
OK, we got to another phase
where we're actually running

00:16:34.050 --> 00:16:37.540
a little bit more smoothly,
but still only at 12.5 frames per second.

00:16:37.540 --> 00:16:40.030
And that's what we want to
actually analyze at this point.

00:16:40.060 --> 00:16:43.300
So we're turning now to Instruments.

00:16:43.300 --> 00:16:46.520
Here's what Instruments has
been recording this entire time.

00:16:46.550 --> 00:16:49.540
I'm going to stop the recording,
as I have enough data.

00:16:50.900 --> 00:18:29.000
[Transcript missing]

00:18:29.230 --> 00:18:32.720
For now, I'm only interested in
what's taking all this time.

00:18:32.770 --> 00:18:36.230
And so I'm going to, on the left side,
choose this running sample times

00:18:36.230 --> 00:18:39.070
option in the sample perspective area.

00:18:39.100 --> 00:18:41.570
And what that will do is temporarily
just kind of put aside all

00:18:41.690 --> 00:18:43.860
those background samples we got.

00:18:43.990 --> 00:18:50.280
So now we have something
like 3,300 samples.

00:18:51.280 --> 00:18:53.300
Now, what is taking all of our time?

00:18:53.370 --> 00:18:56.930
Well, if you click and hold in
the ruler view up here,

00:18:56.980 --> 00:18:59.900
we can see that we're
using 100% of our CPU,

00:18:59.900 --> 00:19:02.360
80% of our CPU.

00:19:02.360 --> 00:19:06.090
This little inspection head, it's called,
will actually tell you how much CPU time

00:19:06.150 --> 00:19:07.900
you're using at the current moment.

00:19:08.130 --> 00:19:10.500
Okay,
so we seem to be using a lot of our CPU.

00:19:10.540 --> 00:19:11.500
Our frame rate's low.

00:19:11.500 --> 00:19:13.970
I'm going to, you know,
conjecture that I have a

00:19:14.020 --> 00:19:16.800
frame rate problem caused by,
you know, overuse of my CPU.

00:19:16.800 --> 00:19:18.420
So where's all that time going?

00:19:18.420 --> 00:19:20.930
Well,
the answer is here in the sample list,

00:19:21.040 --> 00:19:23.840
but it's kind of completely
unusable for humans,

00:19:23.840 --> 00:19:26.740
which is why we provide
you the call tree view,

00:19:26.740 --> 00:19:28.610
which is the default view you get
to because that's where you're

00:19:28.720 --> 00:19:29.840
going to want to spend your time.

00:19:31.190 --> 00:19:33.970
Now, we have a call tree for each thread.

00:19:34.250 --> 00:19:38.010
I'm going to go ahead and open
up a couple of these entries.

00:19:38.260 --> 00:19:39.140
So what exactly is a call tree?

00:19:39.140 --> 00:19:40.780
Well,
we took all those samples we took and

00:19:40.960 --> 00:19:44.290
all those backtraces and found all the
unique paths through those backtraces,

00:19:44.290 --> 00:19:46.950
combined them together into
a single tree structure.

00:19:46.960 --> 00:19:51.060
So we can see here our main thread
called down into the symbol main.

00:19:51.060 --> 00:19:53.640
The gray text to the side is
either your program name or

00:19:53.640 --> 00:19:55.360
the system library you're in.

00:19:55.360 --> 00:19:57.680
Here we started in my AppOcean program.

00:19:57.680 --> 00:20:03.180
And now when we generated that call tree,
we also generated how much time was

00:20:03.240 --> 00:20:05.790
spent in those sections of the call tree.

00:20:06.070 --> 00:20:09.260
Here we can see we spent
31,190 milliseconds,

00:20:09.320 --> 00:20:20.110
or 94% of our total samples were in
our main symbol and its children.

00:20:20.280 --> 00:20:22.200
And so we can continue moving down here.

00:20:22.200 --> 00:20:24.200
Main called into UI application main.

00:20:24.200 --> 00:20:25.830
That was in the UI kit framework.

00:20:26.070 --> 00:20:29.790
UI application main actually went
in and called two different symbols,

00:20:29.900 --> 00:20:34.910
gseventrunmodal,
as well as uiapplication_run.

00:20:35.510 --> 00:20:38.810
So how do we know where we should
continue drilling down now that we've

00:20:38.820 --> 00:20:40.310
hit actually one of these branch points?

00:20:40.390 --> 00:20:43.220
Well, simply just follow the big number.

00:20:43.290 --> 00:20:46.700
Here we have 86% of our time went
down this portion of the call tree,

00:20:46.700 --> 00:20:49.180
and so we're going to keep
on opening up each of these

00:20:49.180 --> 00:20:51.020
and continue following down.

00:20:51.020 --> 00:20:54.340
Now, there's a quicker way.

00:20:54.950 --> 00:20:57.560
To do that, and that's in the toolbar,
is opening up that

00:20:57.620 --> 00:20:58.730
extended detail view again.

00:20:58.740 --> 00:21:02.830
This time,
it has the heaviest stack trace for us.

00:21:04.540 --> 00:21:08.460
What we see here is the exact same
thing we were seeing in the main window,

00:21:08.590 --> 00:21:11.600
the main area in the detail pane,
that main called UI application main,

00:21:11.640 --> 00:21:12.110
et cetera.

00:21:12.270 --> 00:21:15.680
The gray text here, system libraries,
the black text, your code.

00:21:15.740 --> 00:21:17.860
Great way to go through this
quickly is just go ahead and

00:21:17.970 --> 00:21:20.360
scroll all the way to the bottom,
and then kind of scan your

00:21:20.360 --> 00:21:22.790
way back up until you start
seeing the black text again,

00:21:22.790 --> 00:21:24.430
which is your code.

00:21:24.530 --> 00:21:27.610
Here I'm going to go ahead and
click on Ocean View Draw Icons.

00:21:27.680 --> 00:21:34.320
And that highlighted that symbol
in our call tree area over here.

00:21:36.280 --> 00:21:36.890
And what can we see?

00:21:37.050 --> 00:21:40.810
Well, UI views,
draw layer and context called my code,

00:21:40.920 --> 00:21:44.140
AppOcean's code,
draw icons as well as draw rect.

00:21:44.410 --> 00:21:48.810
And between these two guys,
we spent about almost 80% of our time.

00:21:48.820 --> 00:21:51.460
So I know if we optimize this code,
we should see potentially

00:21:51.460 --> 00:21:52.890
a very large speedup.

00:21:52.910 --> 00:21:55.580
You can go ahead and see your source
code right within Instruments.

00:21:55.580 --> 00:21:56.760
Double-click the symbol.

00:21:58.320 --> 00:22:01.620
and your source code will show up
right inside the detail pane of

00:22:01.630 --> 00:22:03.940
Instruments for quick reference.

00:22:03.940 --> 00:22:06.450
And here,
if you're particularly eagle-eyed,

00:22:06.450 --> 00:22:08.660
you may have noticed
something interesting.

00:22:08.690 --> 00:22:12.150
I have my draw record routine,
which calls into both draw

00:22:12.150 --> 00:22:14.060
background and draw icons.

00:22:14.190 --> 00:22:16.660
However, back in my call tree view,

00:22:17.750 --> 00:22:20.960
We saw that it looked like that
draw icons routine was actually a

00:22:20.960 --> 00:22:22.780
child of this draw layer in context.

00:22:22.780 --> 00:22:24.080
Looks like he was called directly.

00:22:24.080 --> 00:22:25.760
That's not the case.

00:22:25.760 --> 00:22:28.500
What you're seeing is the fact that
we ran in release mode is the compiler

00:22:28.840 --> 00:22:30.560
is performing a lot of optimizations.

00:22:30.560 --> 00:22:32.400
One of them is called the
tail call elimination.

00:22:32.400 --> 00:22:35.260
So sometimes you'll encounter
this where it may look like your

00:22:35.260 --> 00:22:36.900
frames are slightly out of order.

00:22:36.900 --> 00:22:38.700
That's a compiler optimization.

00:22:38.700 --> 00:22:41.570
So I know that, in fact,
my draw rect routine actually

00:22:41.570 --> 00:22:43.300
did use 80% of the time.

00:22:43.300 --> 00:22:46.980
So I can double click on the symbol
again to go see that source code.

00:22:47.700 --> 00:22:50.090
And let's say I want to go change it.

00:22:50.180 --> 00:22:52.970
In the top section here
of the detail pane,

00:22:52.980 --> 00:22:54.680
there's a tiny Xcode icon.

00:22:55.150 --> 00:22:56.800
Click on him.

00:22:56.940 --> 00:23:01.510
Xcode will come up and it'll go actually
right to our source code for us.

00:23:01.510 --> 00:23:03.220
You can go ahead and
start making your changes.

00:23:03.220 --> 00:23:06.900
So this is the first point where
I actually would want to make my change.

00:23:06.900 --> 00:23:10.770
I know that this draw rect routine
and all of these methods above it

00:23:10.830 --> 00:23:14.230
that it's calling are really slow,
and so I'm going to get rid of them.

00:23:16.760 --> 00:23:19.930
The fix here,
if you read a bunch of documentation,

00:23:19.940 --> 00:23:22.580
is to use another technology
called Core Animation.

00:23:22.580 --> 00:23:25.710
Now, we don't have time to get into
all the details of Core Animation.

00:23:25.720 --> 00:23:27.870
It's a really cool technology,
but it's going to move all this

00:23:27.910 --> 00:23:31.510
redundant CPU calculation off to the GPU,
which is really good at it.

00:23:31.600 --> 00:23:34.400
And so we'll deal with
actually fixing that up later,

00:23:34.490 --> 00:23:36.790
but all that old code
is going to be gone.

00:23:36.800 --> 00:23:38.980
So we're turning to Instruments.

00:23:40.790 --> 00:23:43.040
There was one other thing
I wanted to look at before

00:23:43.040 --> 00:23:44.520
I made any of those code changes.

00:23:44.520 --> 00:23:47.970
And, well, that was,
we actually seem to have two different

00:23:47.980 --> 00:23:52.020
kind of regimes in this application here,
where at the end we saw a

00:23:52.130 --> 00:23:54.780
pretty solid purple bar,
and then kind of in the middle

00:23:54.780 --> 00:23:56.900
we see lots of peaks and valleys,
peaks and valleys.

00:23:56.900 --> 00:23:58.740
And so I want to know
what's going on there.

00:23:58.740 --> 00:24:02.450
Underneath this Instruments list,
there's a widget called

00:24:02.520 --> 00:24:04.220
the Track Scale Slider.

00:24:04.220 --> 00:24:06.720
You can drag it to the left,
it'll zoom out slowly.

00:24:06.720 --> 00:24:09.320
Drag it back to the right,
it'll zoom in slowly.

00:24:09.320 --> 00:24:13.520
And so right now I'm interested in
why do I have all of these gaps?

00:24:14.910 --> 00:24:17.010
Now, normally, when you have a gap,
that might be okay.

00:24:17.150 --> 00:24:19.110
If you have nothing to do
on your CPU and it's idle,

00:24:19.110 --> 00:24:19.900
it's a good thing.

00:24:19.900 --> 00:24:21.160
You're saving power.

00:24:21.160 --> 00:24:24.310
Here, however,
I have this 60 hertz timer firing,

00:24:24.310 --> 00:24:28.740
and I'm expecting my main thread to wake
up 60 times a second and do some work.

00:24:28.740 --> 00:24:31.560
We see here between 41 and 42 seconds.

00:24:31.560 --> 00:24:34.390
We actually see only maybe
it looks like one peak.

00:24:34.390 --> 00:24:36.070
We only had one thing wake up.

00:24:36.140 --> 00:24:38.860
So the question is, well,
what was my main thread

00:24:38.860 --> 00:24:40.040
doing at that time?

00:24:40.040 --> 00:24:44.780
And Instruments provides a great way to
actually answer that question by going

00:24:44.780 --> 00:24:48.080
over here to the top left of Instruments
and switching away from the default view,

00:24:48.080 --> 00:24:51.690
which is the Instruments strategy,
and selecting the third icon here,

00:24:51.690 --> 00:24:53.680
which is the Thread strategy.

00:24:55.260 --> 00:24:58.170
What happens now is that list of
instruments has been replaced with a list

00:24:58.250 --> 00:24:59.610
of all the threads in your application.

00:24:59.610 --> 00:25:00.980
We have a bunch of them here.

00:25:00.980 --> 00:25:03.380
Some of that background
RSS feeding and whatnot.

00:25:03.380 --> 00:25:06.020
We're interested in what
my main thread was doing,

00:25:06.020 --> 00:25:07.780
and I've highlighted it here.

00:25:07.780 --> 00:25:10.540
And now, as Dave mentioned,
there's a whole bunch of these

00:25:10.540 --> 00:25:12.390
little icons going across the screen.

00:25:12.420 --> 00:25:14.200
Those are the samples that we took.

00:25:14.240 --> 00:25:16.300
Some are darker and some
are lighter than others.

00:25:16.300 --> 00:25:19.360
The darker ones are when we took
a sample of something that was

00:25:19.360 --> 00:25:22.000
running on the CPU at that time,
which is the default

00:25:22.000 --> 00:25:23.350
mode for Time Profiler.

00:25:24.100 --> 00:25:28.330
We have these semi-transparent icons,
and those represent the samples of

00:25:28.330 --> 00:25:34.320
your application when it was not
running on any CPU at that time.

00:25:34.320 --> 00:25:37.110
We got those because we enabled
that record waiting threads option

00:25:37.160 --> 00:25:38.440
at the beginning of the demo.

00:25:38.440 --> 00:25:40.860
Now, I did that to save us a
couple minutes of demo time.

00:25:40.860 --> 00:25:44.590
If you didn't have that option enabled,
you'd see gaps in these regions instead

00:25:44.590 --> 00:25:46.460
of those semi-transparent icons.

00:25:46.460 --> 00:25:50.130
And what you would do is just go back,
enable that option, do another recording.

00:25:50.130 --> 00:25:50.980
Not a big deal.

00:25:52.830 --> 00:25:56.040
And so now what I should be able
to do is click on one of these

00:25:56.670 --> 00:25:58.600
particular semi-transparent guys.

00:25:58.600 --> 00:26:01.600
And now with one click,
I've answered the question of, well,

00:26:01.600 --> 00:26:03.800
what was my main thread
doing at this time?

00:26:03.800 --> 00:26:06.310
Because we can see we took
an idle call stack sample.

00:26:06.380 --> 00:26:08.710
Our CPU ID is, well,
not running on a CPU because

00:26:08.710 --> 00:26:10.240
it was in the background.

00:26:10.240 --> 00:26:12.320
And we have the call stack here.

00:26:13.120 --> 00:26:16.270
And if we just scroll down it,
we see the black text is my code.

00:26:16.270 --> 00:26:18.820
Some sort of icon
downloader start download.

00:26:18.820 --> 00:26:21.060
That went and called
into NSURL connection

00:26:21.060 --> 00:26:22.680
send synchronous request.

00:26:22.680 --> 00:26:24.420
And so right there, I know the problem.

00:26:24.420 --> 00:26:27.180
I did a synchronous request out
to the Internet on my main thread,

00:26:27.180 --> 00:26:29.640
and that's going to block
everything from happening.

00:26:29.640 --> 00:26:30.770
Your user can't interact.

00:26:30.930 --> 00:26:33.310
There's no responsiveness
to the user for touches.

00:26:33.310 --> 00:26:35.940
The screen won't be animating,
and you won't even get timer

00:26:35.950 --> 00:26:37.810
firings until this data comes back.

00:26:37.880 --> 00:26:40.030
And so it's obviously
a performance issue,

00:26:40.100 --> 00:26:41.800
but it could be worse than that.

00:26:41.820 --> 00:26:45.000
If you make this Internet connection and
it doesn't come back within 10 seconds,

00:26:45.000 --> 00:26:49.160
the system's going to terminate your
application because you took too long,

00:26:49.180 --> 00:26:52.260
and your user's going to see
what appears to be a crash.

00:26:52.260 --> 00:26:55.550
So make sure to move all of these
synchronous requests off to a

00:26:55.550 --> 00:26:59.340
background thread using one of
the asynchronous APIs we provide.

00:27:00.710 --> 00:27:04.950
Okay,
so that's two problems and two fixes.

00:27:05.040 --> 00:27:06.770
There's one final thing
I want to look at,

00:27:06.770 --> 00:27:10.160
and that is going back to the
Instruments Strategy View.

00:27:10.160 --> 00:27:14.270
We can go ahead and quickly
zoom back out using the View,

00:27:14.390 --> 00:27:16.890
Snap, Track to Fit menu item.

00:27:17.230 --> 00:27:20.270
And what that'll do is go ahead and,
you know, bring all the samples back

00:27:20.310 --> 00:27:21.440
into view really quickly.

00:27:21.440 --> 00:27:25.100
And now I want to focus in on this
startup time here at the beginning.

00:27:25.100 --> 00:27:29.160
And so using a shift
and mouse drag gesture,

00:27:29.160 --> 00:27:31.070
I'll quickly just zoom in on that region.

00:27:31.080 --> 00:27:33.860
And so now what we're looking
at is my startup time.

00:27:33.860 --> 00:27:35.800
We can go ahead and drag
this a little bit larger.

00:27:37.350 --> 00:27:41.450
And so what I want to do now is
option drag over this region,

00:27:41.660 --> 00:27:42.760
and that's going to do two things.

00:27:42.770 --> 00:27:47.410
This little pop over here is
telling me that it's taking 2.85

00:27:47.430 --> 00:27:49.370
seconds to do my startup routine.

00:27:49.380 --> 00:27:52.240
And when I let go,
I've now applied a time filter.

00:27:52.240 --> 00:27:54.850
Now, for temporarily,
all the samples outside of

00:27:54.850 --> 00:27:57.930
this highlighted blue range,
we're just ignoring them.

00:27:57.970 --> 00:27:59.410
It's very easy to clear it.

00:27:59.520 --> 00:28:01.500
They're using that inspection
range in the toolbar.

00:28:01.500 --> 00:28:05.170
You can go ahead again and set it to
any ranges you want really quickly,

00:28:05.170 --> 00:28:06.060
pretty easy.

00:28:06.580 --> 00:28:08.750
And so now what we've done
is highlighted this region,

00:28:08.750 --> 00:28:11.760
and now I want to go back and see what
was actually taking our time again.

00:28:11.760 --> 00:28:14.560
So using the jump bar,
we're going to click on call tree again.

00:28:14.560 --> 00:28:17.450
This has now been updated
with just the samples that

00:28:17.450 --> 00:28:19.320
are in this particular range.

00:28:19.320 --> 00:28:23.040
And as we did before, very quickly,
go to the extended detail view.

00:28:24.320 --> 00:28:27.000
And we have a very long call tree here.

00:28:27.010 --> 00:28:30.280
And what we see here at the bottom is
some of my routines at the very bottom.

00:28:30.280 --> 00:28:31.350
I'm going to click on that.

00:28:31.360 --> 00:28:35.960
And now it's highlighted
here in the call tree for us.

00:28:35.970 --> 00:28:38.180
Let's get this up a little bit.

00:28:38.870 --> 00:28:39.880
And what are we seeing here?

00:28:39.880 --> 00:28:42.830
The view loaded,
and I did some compositing of

00:28:42.830 --> 00:28:45.200
images that took 70% of my time.

00:28:45.200 --> 00:28:48.360
There was some loading of images
that took another 27% of my time.

00:28:48.360 --> 00:28:50.140
So once again,
I have about 98% of my time

00:28:50.180 --> 00:28:51.600
was spent in these functions.

00:28:51.600 --> 00:28:53.740
And you'd want to go
through the same routine of,

00:28:53.740 --> 00:28:55.420
well, let's try to optimize that.

00:28:56.360 --> 00:28:59.780
Unfortunately, let's say I tried that,
I couldn't get out any more time,

00:28:59.820 --> 00:29:01.130
and so the code is what it is.

00:29:01.140 --> 00:29:02.840
I can't make it any more efficient.

00:29:02.840 --> 00:29:03.480
Or can I?

00:29:03.480 --> 00:29:08.340
Well, the last thing we want to look at
is the third and final strategy,

00:29:08.610 --> 00:29:10.420
which is the CPU strategy.

00:29:10.420 --> 00:29:13.270
When we click on that,
now our list of instruments is replaced

00:29:13.440 --> 00:29:15.120
with the list of cores in my device.

00:29:15.120 --> 00:29:17.330
This is an iPad 2, so there's two cores.

00:29:17.330 --> 00:29:23.890
And what we can see now
is these blue sample bars.

00:29:23.960 --> 00:29:26.340
Each blue sample bar
represents a different CPU.

00:29:26.360 --> 00:29:27.980
And so we took a sample
on that particular core.

00:29:27.980 --> 00:29:30.260
The height of it represents
the depth of the backtrace.

00:29:30.280 --> 00:29:34.280
And if you take a really quick glance,
you may say, yes, we actually have some

00:29:34.600 --> 00:29:35.960
parallelism going on here.

00:29:35.960 --> 00:29:37.310
In fact, we don't.

00:29:37.320 --> 00:29:40.370
We can grab that same inspection
head before and kind of help

00:29:40.470 --> 00:29:43.630
us draw a vertical line and see
that any time there's a blue bar

00:29:43.640 --> 00:29:46.850
on one core or the other core,
but never at the same time.

00:29:46.860 --> 00:29:50.940
So we actually are making only,
using 50% of our CPU resources,

00:29:50.940 --> 00:29:55.720
we can actually make this much more
efficient by doing some work in parallel.

00:29:56.360 --> 00:29:59.420
So the code change that I need
to make is to take that daytime

00:29:59.420 --> 00:30:02.900
and nighttime loading of images
and do them at the same time.

00:30:02.900 --> 00:30:07.980
And then break up those images
into a bunch of tiles and use GCD,

00:30:07.980 --> 00:30:09.640
Grand Central Dispatch,
to actually create a whole bunch

00:30:09.640 --> 00:30:12.480
of threads in the background to
work on those tiles in parallel

00:30:12.480 --> 00:30:15.310
and then display them to the user.

00:30:15.740 --> 00:30:19.520
Now, I did one other final enhancement
to that was that as soon

00:30:19.520 --> 00:30:22.420
as the daytime image loads,
I can display that to the user

00:30:22.420 --> 00:30:24.770
immediately so they can begin
interacting with the application

00:30:24.800 --> 00:30:26.680
as quickly as possible.

00:30:26.760 --> 00:30:31.660
Meanwhile, all those computations will be
happening in the background and will

00:30:31.660 --> 00:30:34.120
show up for the user as they complete.

00:30:34.270 --> 00:30:35.370
So now we're going to Xcode.

00:30:35.390 --> 00:30:38.800
As promised, start making some of
these coding changes.

00:30:40.720 --> 00:30:45.500
Except I'm going to take the cooking
show approach and cheat a little bit.

00:30:45.510 --> 00:30:47.360
As these changes take
a little while to make,

00:30:47.430 --> 00:30:50.380
so I've prepared some pound
of fines ahead of time.

00:30:50.440 --> 00:30:52.220
First one is let's go ahead
and use Core Animation.

00:30:52.220 --> 00:30:53.820
That removes all our draw rect code.

00:30:53.840 --> 00:30:57.810
It enables us to use the
CA layer type technology.

00:30:57.870 --> 00:31:00.360
Again, I would recommend you go
see a Core Animation talk

00:31:00.580 --> 00:31:01.880
to learn more about that.

00:31:02.000 --> 00:31:06.160
The second fix was let's do all of
our icon downloading asynchronously,

00:31:06.160 --> 00:31:07.830
get it off the main thread.

00:31:08.040 --> 00:31:11.590
And third and finally,
let's rewrite that initial map

00:31:11.590 --> 00:31:17.300
loading algorithm to actually do
things more in parallel and use GCD.

00:31:17.510 --> 00:31:18.720
So save those changes.

00:31:18.900 --> 00:31:23.640
And this time I want to make sure
to select Profile from within Xcode.

00:31:23.640 --> 00:31:26.330
Since we have coding changes,
we need to make sure we profile sync

00:31:26.400 --> 00:31:28.360
the latest bits over to the device.

00:31:28.360 --> 00:31:32.160
So before I do that,
let's go back to the iPad.

00:31:32.170 --> 00:31:32.410
Okay.

00:31:32.590 --> 00:31:36.000
So now I'll select Profile
again within Xcode.

00:31:36.000 --> 00:31:39.280
It's compiling,
syncing it over to the device.

00:31:39.300 --> 00:31:41.570
And this time we see the daytime
image comes up really quickly.

00:31:41.640 --> 00:31:43.200
The nighttime image
blends in the background.

00:31:43.200 --> 00:31:47.320
The entire time, the user interface was
interactive for the user.

00:31:47.370 --> 00:31:49.530
I can tap on the top paid ocean.

00:31:49.570 --> 00:31:53.890
And again, it's going to go out,
load that RSS feed again for us.

00:31:55.020 --> 00:31:58.060
And after it does that,
the icon should start downloading.

00:31:58.160 --> 00:32:00.850
And now we can see my frames per
second counter is actually running

00:32:00.850 --> 00:32:02.500
at 60 frames this entire time.

00:32:02.500 --> 00:32:03.980
I don't see any random stutters.

00:32:03.990 --> 00:32:05.940
The children are following
their parents quite nicely.

00:32:05.940 --> 00:32:07.650
And everything looks great.

00:32:07.710 --> 00:32:10.650
I'm pretty sure I've verified that
I've actually fixed the problem.

00:32:10.840 --> 00:32:13.430
But what does Instruments
have to say about it?

00:32:14.380 --> 00:32:15.530
Returning to Instruments.

00:32:15.610 --> 00:32:18.890
Let me see what the graph looks like now.

00:32:18.900 --> 00:32:22.100
Our CPU usage is much lower.

00:32:22.240 --> 00:32:23.220
And so that looks great.

00:32:23.320 --> 00:32:25.940
We can drag the inspection head
even while it's running and see

00:32:26.120 --> 00:32:28.660
that 30%, 20%, much lower CPU usage.

00:32:28.900 --> 00:32:29.980
Great.

00:32:30.020 --> 00:32:31.950
Stop this recording.

00:32:32.030 --> 00:32:34.540
The last thing I wanted to
look at was that startup time.

00:32:34.750 --> 00:32:37.620
Shift-drag to zoom in on that.

00:32:39.700 --> 00:32:41.890
I can go ahead now and once
again do the option drag,

00:32:41.890 --> 00:32:44.290
which will time filter this region
as well as let me measure it.

00:32:44.510 --> 00:32:46.920
The duration now is down
to about 1.7 seconds,

00:32:46.920 --> 00:32:48.900
so we took off a little over a second.

00:32:48.900 --> 00:32:51.220
And did we do this more efficiently?

00:32:51.220 --> 00:32:55.020
This time we can see that in
our core strategy view that,

00:32:55.080 --> 00:32:57.800
yes, indeed,
we actually have samples now running

00:32:57.800 --> 00:32:59.480
on both of our cores at the same time.

00:32:59.480 --> 00:33:02.080
And that's where we got that big
speed up as we were using both

00:33:02.120 --> 00:33:03.700
of our cores' top efficiency.

00:33:05.310 --> 00:33:08.150
The last thing I'd like to show you
is the all-new threads and process

00:33:08.220 --> 00:33:09.380
picker that we have this year.

00:33:09.380 --> 00:33:10.660
We open that up.

00:33:10.660 --> 00:33:14.780
The left box actually lists all
the processes that we recorded.

00:33:14.780 --> 00:33:17.380
We only recorded our one application,
so there's just one.

00:33:17.380 --> 00:33:20.610
The left panel shows us all the
different threads that were actually

00:33:20.610 --> 00:33:22.460
involved in our process this time.

00:33:22.460 --> 00:33:25.560
There's a bunch here,
and there's some quick shortcuts to say,

00:33:25.560 --> 00:33:28.880
if I want to focus in on my main thread,
click the main thread filter,

00:33:29.050 --> 00:33:32.640
check that box, and now we'll be focusing
in on just our main thread.

00:33:32.900 --> 00:33:35.100
So when I return to
this core strategy view,

00:33:35.110 --> 00:33:37.340
we can see the blue samples
now are our main thread.

00:33:37.340 --> 00:33:39.200
All the gray samples was
all that background code,

00:33:39.200 --> 00:33:42.200
all the compositing logic
that GCD is handling for us.

00:33:42.200 --> 00:33:46.610
And if I option drag over this region,
and I'll see the duration

00:33:46.610 --> 00:33:48.960
was 413 milliseconds.

00:33:48.960 --> 00:33:52.270
So the user was able to start tapping,
interacting with my application

00:33:52.490 --> 00:33:55.620
in under half a second versus
the almost three seconds before.

00:33:55.620 --> 00:33:59.010
And with that,
I'll turn to slides and summarize

00:33:59.040 --> 00:34:01.060
what we just went through.

00:34:05.200 --> 00:34:05.540
Thank you.

00:34:05.540 --> 00:34:12.220
So the first thing we did was
actually want to analyze where

00:34:12.270 --> 00:34:13.470
we were spending all our time.

00:34:13.480 --> 00:34:15.270
And that's what the call
tree view is really good for.

00:34:15.280 --> 00:34:18.290
It took us a matter of a minute
to just find these two methods,

00:34:18.320 --> 00:34:22.100
in this case, drawIcons and drawRect,
that were taking most of our time.

00:34:22.100 --> 00:34:23.460
We went and optimized those away.

00:34:23.460 --> 00:34:27.960
Then we had a responsiveness problem
where our main thread wasn't responding.

00:34:27.960 --> 00:34:29.500
It was hanging a little bit.

00:34:29.540 --> 00:34:33.020
And we went to the thread strategy,
which very quickly allowed us to see

00:34:33.020 --> 00:34:36.230
that I was actually doing this blocking
synchronous call on my main thread.

00:34:36.240 --> 00:34:38.220
And that's where those little
hangs were coming from.

00:34:39.600 --> 00:34:41.800
And third,
we went and used the CPU Strategy View.

00:34:41.800 --> 00:34:44.200
That told us how efficiently
we were doing our work.

00:34:44.220 --> 00:34:45.910
Here, we weren't actually doing
it efficiently at all.

00:34:45.940 --> 00:34:47.640
We were only using half of our resources.

00:34:47.710 --> 00:34:50.880
So we went back in,
made our code more parallel, used GCD,

00:34:50.890 --> 00:34:53.770
and then we used all of our CPU cores.

00:34:54.120 --> 00:34:56.290
And with that,
I'd like to introduce Victor Hernandez,

00:34:56.290 --> 00:34:58.390
who's going to take you through
a memory profiling optimization

00:34:58.490 --> 00:34:59.660
on the same application.

00:34:59.660 --> 00:35:01.030
Thank you.

00:35:06.300 --> 00:35:07.680
Thanks, Joe.

00:35:07.780 --> 00:35:09.740
My name is Victor Hernandez,
and I'll be showing you how

00:35:09.740 --> 00:35:12.820
to use Instruments to fix
memory issues in your app.

00:35:12.880 --> 00:35:16.090
It's really important that you do
this because memory is a shared,

00:35:16.180 --> 00:35:18.440
constrained resource on the device.

00:35:18.480 --> 00:35:20.580
And fortunately,
Instruments provides tools

00:35:20.580 --> 00:35:22.020
that makes this easier to do.

00:35:22.070 --> 00:35:24.910
I'll be going over two tools,
the leaks instrument and

00:35:24.910 --> 00:35:26.500
the allocations instrument.

00:35:26.630 --> 00:35:29.150
So let me go to the demo machine.

00:35:29.270 --> 00:35:29.740
Here we go.

00:35:29.840 --> 00:35:35.380
I'm going to bring this up in Xcode.

00:35:35.380 --> 00:35:35.380
Okay.

00:35:38.550 --> 00:35:40.260
So I have it running on the iPad.

00:35:40.260 --> 00:35:40.730
That's great.

00:35:40.870 --> 00:35:44.830
I'm going to check the
profile action here.

00:35:44.830 --> 00:35:48.340
And unlike Joe, I'm not going to be using
the time profiler template,

00:35:48.340 --> 00:35:52.500
but instead I'm going to be choosing
right here the leaks template.

00:35:52.500 --> 00:35:56.090
So let me choose that
and click on profile.

00:35:56.770 --> 00:36:00.840
This launches Instruments,
and it's already started recording.

00:36:00.960 --> 00:36:07.100
So I'm going to start using the app and
using it just bringing up some oceans.

00:36:07.210 --> 00:36:09.690
Here I'm bringing up the first ocean.

00:36:10.360 --> 00:36:13.160
I'm going to wait until a
few apps are swimming around,

00:36:13.180 --> 00:36:16.650
and I basically want to exercise the
app like your user would be doing.

00:36:16.760 --> 00:36:19.040
All right,
I have a few oceans swimming around.

00:36:19.040 --> 00:36:19.890
That's great.

00:36:19.980 --> 00:36:22.900
Let me swipe away and
bring up another ocean.

00:36:23.910 --> 00:36:27.870
And you'll see it's still
collecting more information.

00:36:27.970 --> 00:36:32.430
And I'm waiting for that
ocean to be filled with apps.

00:36:33.980 --> 00:36:36.600
Let's see, it's taking a little while
to download our assess feed.

00:36:36.600 --> 00:36:39.660
Oh, wait a second.

00:36:39.960 --> 00:36:42.280
I should stop this right away.

00:36:42.700 --> 00:36:45.690
Because if you'll notice right here,
if you look at the reason

00:36:45.780 --> 00:36:49.210
I stopped immediately is because
the leaks instrument is already

00:36:49.210 --> 00:36:51.150
showing me that I have some leaks.

00:36:51.260 --> 00:36:55.270
What this means is that there is some
memory that is not accessible for my app,

00:36:55.420 --> 00:36:56.510
yet has not been freed.

00:36:56.770 --> 00:36:59.820
This is an issue that needs to
be resolved as soon as possible,

00:36:59.820 --> 00:37:01.280
and I want to start there.

00:37:02.770 --> 00:37:06.220
So how I go about doing this is
first I need to find out what the

00:37:06.220 --> 00:37:08.150
information that it's showing me is.

00:37:08.240 --> 00:37:14.920
If I go over here on the left-hand side,
you will see--

00:37:16.110 --> 00:37:20.290
It says right here that the leaks
instrument is doing automatic

00:37:20.360 --> 00:37:24.310
snapshotting every 10 seconds and

00:37:25.960 --> 00:37:32.400
What that's showing me means is that this
is the first time it detected any leaks,

00:37:32.470 --> 00:37:37.780
and it detected 220 leaks,
and about 10 seconds later,

00:37:37.820 --> 00:37:40.880
it then detected 304 leaks.

00:37:40.900 --> 00:37:43.090
All right,
so I'm leaking about 15 kilobytes,

00:37:43.120 --> 00:37:45.000
and I need to take care of that.

00:37:45.040 --> 00:37:49.700
Now, the way I go about doing that is
right here in the detail view.

00:37:51.160 --> 00:37:55.480
I have the different categories
of objects that are being leaked.

00:37:55.480 --> 00:37:58.870
If I organize this,
I should start by looking

00:37:58.870 --> 00:38:00.980
at objects from my own app.

00:38:01.070 --> 00:38:04.030
The ones I notice here are
app child and app parent.

00:38:04.030 --> 00:38:06.420
As Joe mentioned,
when the apps are swimming

00:38:06.550 --> 00:38:08.860
around in the oceans,
we have some of them that

00:38:08.860 --> 00:38:10.360
are leading other apps.

00:38:10.360 --> 00:38:12.930
Those are the parents,
and they're leading their

00:38:12.930 --> 00:38:15.700
little school of fish,
and that's the app child.

00:38:16.020 --> 00:38:19.750
Well, it looks like some of
these are being leaked.

00:38:19.750 --> 00:38:22.980
In fact,
I have 79 app childs being leaked

00:38:22.980 --> 00:38:25.790
and 28 app parents being leaked.

00:38:25.810 --> 00:38:29.100
Now, I'm rather surprised that
they're being leaked because

00:38:29.100 --> 00:38:30.610
I wrote this code using Arc.

00:38:30.680 --> 00:38:33.140
Aren't I supposed to avoid
these sorts of issues?

00:38:33.140 --> 00:38:35.880
Well,
even though Arc makes it much easier to

00:38:35.890 --> 00:38:40.220
write retain and release memory apps,
you can still fall into the same

00:38:40.220 --> 00:38:44.160
pitfalls that you did before
with that kind of technology.

00:38:45.460 --> 00:38:49.490
Fortunately, Instruments makes it pretty
easy to identify one of the

00:38:49.490 --> 00:38:53.280
common sources of leaked memory,
which is a retain cycle.

00:38:53.280 --> 00:38:57.110
And the way you find this information
is you go right here in the jump bar

00:38:57.110 --> 00:38:59.050
and you choose cycles and routes.

00:39:00.920 --> 00:39:05.530
And so what you have here is what
Instruments has recorded for you are

00:39:05.590 --> 00:39:10.010
all of the different cycles and routes.

00:39:10.810 --> 00:39:13.200
Specifically,
I want to go to my App Parent,

00:39:13.280 --> 00:39:16.250
the objects for my own code,
and it brings up this graph.

00:39:16.340 --> 00:39:21.870
What we're seeing here is we're seeing
a reference graph for the App Parent.

00:39:21.880 --> 00:39:26.030
The App Parent has this red arrow,
and the red arrow indicates that

00:39:26.030 --> 00:39:30.350
there is a strong ARC reference
from the App Parent to a mutable

00:39:30.640 --> 00:39:33.450
array for its children property.

00:39:34.740 --> 00:39:40.530
That mutable array has a blue dotted
non-ARC reference to a buffer,

00:39:40.530 --> 00:39:46.090
and then that buffer has another
non-ARC reference to an app child.

00:39:46.100 --> 00:39:49.600
And finally,
this app child has a red strong

00:39:49.600 --> 00:39:55.240
reference back to its parent that's
stored in its parent property.

00:39:55.240 --> 00:39:57.920
Well, that's really surprising.

00:39:57.920 --> 00:40:00.420
I didn't expect this to be
a strong reference at all.

00:40:00.440 --> 00:40:03.410
The other thing I want to point out is,
as I told you earlier,

00:40:03.780 --> 00:40:06.350
this memory isn't accessible
from the rest of your app,

00:40:06.350 --> 00:40:08.880
and sure enough,
there are no references to this

00:40:08.880 --> 00:40:10.990
App Parent from anywhere else.

00:40:11.000 --> 00:40:12.860
They're only from the app child.

00:40:12.860 --> 00:40:15.480
So I need to find out why
this is a strong reference,

00:40:15.520 --> 00:40:17.560
even though I didn't expect it to be.

00:40:17.560 --> 00:40:21.180
So if I double-click on that arrow,
it takes me to Xcode,

00:40:21.180 --> 00:40:23.480
and it'll actually take me to
the definition of app child.

00:40:23.480 --> 00:40:25.060
Here we go.

00:40:25.060 --> 00:40:30.960
Here is the line where I'm setting
the parent property in app child.

00:40:30.960 --> 00:40:32.990
Nothing looks wrong about that.

00:40:33.100 --> 00:40:37.220
So let me actually go to the
header and see what's going on.

00:40:38.280 --> 00:40:43.710
Now if I scroll down to
the property declaration,

00:40:43.820 --> 00:40:45.400
aha, I see what's going on.

00:40:45.560 --> 00:40:48.900
I forgot that by default,
properties are declared

00:40:48.900 --> 00:40:52.690
to have strong references,
and I in fact need to explicitly

00:40:52.790 --> 00:40:54.940
state that this is a weak reference.

00:40:54.960 --> 00:40:58.950
So I think that should fix my leak,
and now I need to run again

00:40:58.950 --> 00:41:02.510
in Instruments to verify
that I've in fact done that,

00:41:02.600 --> 00:41:03.730
fixed the leak.

00:41:03.780 --> 00:41:08.390
In the interest of time,
I'm going to be...

00:41:10.750 --> 00:41:14.240
I'm going to be loading
a pre-saved trace.

00:41:14.320 --> 00:41:16.040
So let me go ahead and save this one.

00:41:16.110 --> 00:41:19.210
And here's my pre-saved trace.

00:41:19.290 --> 00:41:25.370
And so this is now Instruments
recording data running through

00:41:25.370 --> 00:41:27.590
multiple oceans in my app.

00:41:28.000 --> 00:41:28.980
After I fix the leak.

00:41:29.050 --> 00:41:31.870
Well, first of all,
I'll notice that the leaks

00:41:31.890 --> 00:41:34.970
timeline shows no leaks at all.

00:41:35.020 --> 00:41:36.080
So I think I fixed the problem.

00:41:36.190 --> 00:41:36.800
That's great.

00:41:36.810 --> 00:41:38.880
Now what's the next thing I need to do?

00:41:38.880 --> 00:41:43.120
Well, I need to go to the allocations
timeline and see if it's telling me that

00:41:43.180 --> 00:41:45.500
there's something that I need to fix.

00:41:45.800 --> 00:41:48.720
Before I do that,
I want to show you that I've added

00:41:48.720 --> 00:41:51.110
these flags throughout the timeline.

00:41:51.190 --> 00:41:55.590
These are really useful for correlating
behavior in the app to data that's

00:41:55.660 --> 00:41:58.220
been collected inside of Instruments.

00:41:58.300 --> 00:42:00.800
You'll see right here,
I've labeled this flag

00:42:00.800 --> 00:42:02.780
to say map of the world,
and in fact,

00:42:02.790 --> 00:42:06.760
it's the point in time when the app
has brought up the map of the world.

00:42:06.760 --> 00:42:10.510
My next flag identifies
that at this point in time,

00:42:10.640 --> 00:42:13.880
the top paid ocean has
been displayed once,

00:42:13.880 --> 00:42:15.700
and there's a whole bunch
of apps swimming in there.

00:42:15.700 --> 00:42:18.510
And then I have one for
the new paid app ocean,

00:42:18.510 --> 00:42:22.250
and then finally, I brought up the top
paid app ocean again.

00:42:22.330 --> 00:42:25.760
It's pretty easy to add
these flags to your trace.

00:42:25.760 --> 00:42:29.460
You just move the inspection
head anywhere along the

00:42:29.460 --> 00:42:32.040
timeline and go to edit,
add flag.

00:42:32.050 --> 00:42:35.330
It adds it,
and then if you double click on it,

00:42:35.330 --> 00:42:38.170
you can go ahead and
put a label in there,

00:42:38.170 --> 00:42:40.720
which you can reference later.

00:42:40.720 --> 00:42:43.510
I'm going to go ahead and
remove this since we're not

00:42:43.510 --> 00:42:45.420
actually going to use that one.

00:42:45.800 --> 00:42:48.830
But this is really useful,
especially if you save your trace and you

00:42:48.830 --> 00:42:50.840
want to access that information later.

00:42:50.840 --> 00:42:54.210
So let me go to view,
snap track to fit to make this

00:42:54.210 --> 00:42:56.040
thing take up the whole screen.

00:42:56.040 --> 00:42:56.760
Okay, great.

00:42:56.760 --> 00:42:59.620
Now that we know what our
app is doing over time,

00:42:59.620 --> 00:43:02.310
we need to see what
its memory profile is.

00:43:02.320 --> 00:43:07.470
So the allocations instrument
in the timeline shows you the

00:43:07.750 --> 00:43:15.160
amount of memory used by all of
the malloc objects in your heap.

00:43:15.680 --> 00:43:19.270
Initially,
when the map of the world was shown,

00:43:19.270 --> 00:43:21.980
I'm using about 910 kilobytes.

00:43:22.040 --> 00:43:24.570
And by the time I bring
up the first ocean,

00:43:24.640 --> 00:43:27.690
I'm using 3 megabytes.

00:43:27.790 --> 00:43:32.740
And on the second ocean,
I'm using 4.56 megabytes.

00:43:32.830 --> 00:43:35.640
And finally, I'm up to 6.38 megabytes.

00:43:35.640 --> 00:43:38.540
Well, that's pretty bad,
because that makes it sound like if

00:43:38.550 --> 00:43:41.750
I keep on bringing up more oceans,
I'm eventually going to

00:43:41.750 --> 00:43:44.850
just increase memory usage,
and eventually my app is

00:43:44.850 --> 00:43:46.640
going to get terminated,
and my users are going

00:43:46.720 --> 00:43:47.720
to see this as a crash.

00:43:47.720 --> 00:43:49.260
I definitely have to fix this.

00:43:49.540 --> 00:43:53.690
On top of that, this doesn't match my
expectations for my app.

00:43:53.700 --> 00:43:59.080
I know that I'm using the same amount of
objects to display each of the oceans.

00:43:59.080 --> 00:44:03.720
In fact, I expect this to be flat,
and it seems like there's objects being

00:44:03.720 --> 00:44:09.180
used for earlier oceans that are sticking
around when I'm displaying later oceans.

00:44:09.190 --> 00:44:10.980
Well, I definitely need to fix that.

00:44:10.990 --> 00:44:12.470
But how do I go about doing that?

00:44:12.520 --> 00:44:16.230
Well,
that's where the rest of the allocations

00:44:16.230 --> 00:44:19.220
instruments data comes into play.

00:44:19.740 --> 00:44:23.400
What the allocations instrument
is doing is it's recording every

00:44:23.400 --> 00:44:28.570
single memory event for every single
object allocated during that trace.

00:44:28.570 --> 00:44:31.870
It's recording its allocation,
all the retain and releases,

00:44:32.010 --> 00:44:33.250
and then eventually it's free.

00:44:33.280 --> 00:44:34.240
It's a lot of data.

00:44:34.330 --> 00:44:40.090
That's why the app runs a bit slower
on your iPad when you're recording with

00:44:40.090 --> 00:44:43.410
the allocations instrument turned on.

00:44:44.380 --> 00:44:47.430
Down here it displays the
different categories of objects

00:44:47.530 --> 00:44:49.390
that have been allocated.

00:44:49.390 --> 00:44:53.660
And to show you what's in here,
let me filter out.

00:44:53.720 --> 00:44:55.960
I go to the search field
and I type in string.

00:44:55.960 --> 00:44:59.040
And this shows me all the different
types of strings that I've allocated.

00:44:59.040 --> 00:45:03.010
If we look specifically
at immutable CFStrings,

00:45:03.030 --> 00:45:08.040
we'll see that 20,202 of
them have been allocated and

00:45:08.040 --> 00:45:16.240
that at the end of the trace,
there are 3,525 that are still living.

00:45:16.250 --> 00:45:18.760
Those are the key numbers
you should pay attention to.

00:45:18.760 --> 00:45:24.870
Also, if I focus in right
here and I press that,

00:45:24.870 --> 00:45:24.870
it shows me the number of
strings that have been allocated.

00:45:25.150 --> 00:45:29.760
I now get a list of actually
all of those instances.

00:45:29.860 --> 00:45:32.400
But specifically to know which
instances of all the ones

00:45:32.400 --> 00:45:35.280
I've allocated I'm showing,
I actually look over here

00:45:35.280 --> 00:45:38.270
at the allocation lifespan
on the left-hand side,

00:45:38.270 --> 00:45:41.960
and I'm currently selected
created and still living.

00:45:41.960 --> 00:45:45.970
So these are all the immutable
CFStrings that were created during

00:45:45.970 --> 00:45:50.060
my complete trace that are still
living at the end of the trace.

00:45:50.060 --> 00:45:52.930
If I instead click on
created and destroyed,

00:45:52.950 --> 00:45:56.800
now the list will be updated to
show me those instances that were

00:45:56.800 --> 00:46:00.920
created but have already been
destroyed before the trace ends.

00:46:00.920 --> 00:46:02.660
It went by so quickly that I can't tell.

00:46:02.660 --> 00:46:03.170
There we go.

00:46:03.310 --> 00:46:03.880
It updated.

00:46:03.880 --> 00:46:05.000
There's a lot of them.

00:46:05.040 --> 00:46:05.840
Okay.

00:46:05.840 --> 00:46:11.420
Well, for my analysis, I'm worried about
objects that are created.

00:46:11.960 --> 00:46:15.000
And I expected them to be destroyed,
but unfortunately they're still living.

00:46:15.000 --> 00:46:17.540
So I'm going to switch it back
to created and still living.

00:46:17.540 --> 00:46:20.740
And I'm going to go back
to my object summary.

00:46:22.810 --> 00:46:25.060
And I'm not going to search for strings.

00:46:25.170 --> 00:46:28.700
And now I'm presented with all these
different types of objects again.

00:46:28.760 --> 00:46:30.220
Now where do I go from here?

00:46:30.350 --> 00:46:32.990
Well, this can really feel like trying to
find a needle in a haystack because

00:46:33.100 --> 00:46:34.680
we're presenting so much information.

00:46:35.560 --> 00:46:40.830
Well, the best way to go about using
this is to think about -- actually,

00:46:40.920 --> 00:46:45.490
pick an object in your own code
and check to see if the data

00:46:45.720 --> 00:46:50.960
recorded about its object lifespan
matches your own expectations.

00:46:50.960 --> 00:46:58.000
So I'm going to do that specifically
for the Ocean View class in my app.

00:46:58.000 --> 00:46:59.160
Great.

00:46:59.260 --> 00:47:01.030
There it is.

00:47:02.430 --> 00:47:05.740
All right, and now what I have here
is this is presented to me.

00:47:05.790 --> 00:47:11.560
I create an ocean view every time an
ocean is displayed on the iPad screen,

00:47:11.560 --> 00:47:13.980
and then when I swipe away,
it should go away.

00:47:14.010 --> 00:47:15.680
So let's see what it's telling me.

00:47:15.720 --> 00:47:18.420
What it's telling me that I've
created three of them overall.

00:47:18.420 --> 00:47:19.250
That makes sense.

00:47:19.290 --> 00:47:20.520
That's what I expected.

00:47:20.520 --> 00:47:23.430
But it's unfortunately telling
me that there's three living

00:47:23.430 --> 00:47:24.700
at the end of the trace.

00:47:24.700 --> 00:47:26.560
Well, that's not what I expected.

00:47:26.560 --> 00:47:30.000
In fact,
what I expected was what we're seeing

00:47:30.080 --> 00:47:34.560
for ocean view controller right above,
that I had three total,

00:47:34.560 --> 00:47:37.630
but at the end of the trace,
I have one that's still living.

00:47:37.640 --> 00:47:41.220
So now I need to figure out
why I still have -- why these

00:47:41.220 --> 00:47:43.380
ocean views are still alive.

00:47:44.220 --> 00:47:47.600
Let me click on here to get to there.

00:47:47.770 --> 00:47:51.010
And you'll see that now I have
a list of all my OceanViews.

00:47:51.070 --> 00:47:55.070
If I scroll through these,
you'll see that the inspection

00:47:55.070 --> 00:47:58.300
head moves to the point in time
when each of them got allocated.

00:47:58.390 --> 00:48:02.920
Well, now I need to click on
the first instance again.

00:48:03.050 --> 00:48:06.490
And now this brings up the
complete memory history

00:48:06.490 --> 00:48:08.800
for the OceanView instance.

00:48:10.210 --> 00:48:13.680
Starting from its initial allocation,
that gets me a ref count of one,

00:48:13.680 --> 00:48:16.750
followed by retain and releases
that increase the ref count.

00:48:16.780 --> 00:48:18.900
That's the key number
here in this column.

00:48:18.900 --> 00:48:21.210
And eventually,
this should get all the way down to zero,

00:48:21.210 --> 00:48:22.220
and it'll get freed.

00:48:22.220 --> 00:48:24.760
But it's not getting freed
because it never gets to zero.

00:48:24.760 --> 00:48:26.800
So who's holding a reference to this?

00:48:26.800 --> 00:48:29.000
Well,
the best way to find out is to move the

00:48:29.010 --> 00:48:32.820
inspection head along in the timeline
to a point in time where I expect that

00:48:32.930 --> 00:48:35.140
ocean view to have already been freed.

00:48:35.140 --> 00:48:37.800
How about right here where
the second ocean is displayed?

00:48:38.300 --> 00:48:43.010
At that point in time,
the memory events being recorded are

00:48:43.150 --> 00:48:46.190
retain and releases from NSFireTimer.

00:48:46.200 --> 00:48:48.940
Well, that's the timer that Joe was
mentioning was telling the

00:48:48.940 --> 00:48:50.460
ocean view to animate itself.

00:48:50.460 --> 00:48:51.280
That's weird.

00:48:51.280 --> 00:48:53.220
I don't expect this to be happening.

00:48:53.220 --> 00:48:55.740
So for some reason,
the timer hasn't released its

00:48:55.740 --> 00:48:57.290
reference to my ocean view.

00:48:57.290 --> 00:49:03.070
I need to go back to the very beginning
and find out when that ocean view got

00:49:03.070 --> 00:49:06.490
its initial reference to my ocean view.

00:49:06.510 --> 00:49:08.960
So I've got a reference to my ocean view.

00:49:08.990 --> 00:49:10.990
Well,
that seems like it happens right here.

00:49:11.070 --> 00:49:19.180
If I bring up the extended detail view,
I'll see that that is -- okay.

00:49:19.400 --> 00:49:21.430
Well, basically,
what's happening here is that this

00:49:21.430 --> 00:49:25.770
is being called from start animation
in my own code in the ocean view.

00:49:26.120 --> 00:49:36.300
So now I'm going to go back to
Xcode and take a look at that code.

00:49:36.300 --> 00:49:36.300
And I'm going to look
for start animation.

00:49:41.200 --> 00:49:46.930
I see that in start animation,
I am creating the timer and it's

00:49:47.530 --> 00:49:49.820
passing itself as the target.

00:49:49.820 --> 00:49:53.620
And stop animation right down
here is correctly invalidating

00:49:53.620 --> 00:49:54.940
the animation timer.

00:49:54.940 --> 00:49:58.460
So I need to find out why I'm not
calling stop animation at the right time.

00:49:58.660 --> 00:50:01.130
So if I do that,

00:50:02.330 --> 00:50:03.760
I see that I'm actually
not calling at all.

00:50:03.760 --> 00:50:06.590
I have a declaration, a definition,
and no call to it.

00:50:06.740 --> 00:50:08.140
So that's wrong.

00:50:08.240 --> 00:50:11.700
So I now know that I need to
match my stop animation call with

00:50:11.700 --> 00:50:15.210
where I call start animation,
and it should be right here

00:50:15.210 --> 00:50:18.130
in view will disappear,
which gets called when

00:50:18.130 --> 00:50:19.920
I swipe away the ocean.

00:50:19.920 --> 00:50:23.040
So let me fix that,
and I'm going to run this again

00:50:23.040 --> 00:50:27.060
in Instruments to verify that
I've made the correct fixes.

00:50:27.060 --> 00:50:31.640
So let me pick the leaks profile,
and I'm going to be recording here again.

00:50:32.300 --> 00:50:34.250
Okay, let me bring it up.

00:50:34.300 --> 00:50:37.050
I'm going to highlight ocean view.

00:50:37.950 --> 00:50:42.000
And sure enough,
there are no ocean views being displayed,

00:50:42.050 --> 00:50:43.120
being recorded.

00:50:43.160 --> 00:50:46.700
And I went to an ocean,
and now I do have an ocean view.

00:50:46.770 --> 00:50:47.800
So that's good.

00:50:47.830 --> 00:50:50.430
Now let me see if I swipe away
from the ocean if it goes away.

00:50:50.430 --> 00:50:52.280
All right, it did.

00:50:52.410 --> 00:50:52.630
Good.

00:50:52.700 --> 00:50:53.460
I think I fixed something.

00:50:53.460 --> 00:50:55.420
Let me do it again.

00:50:55.420 --> 00:50:57.240
Well, actually,
I don't have time for that,

00:50:57.240 --> 00:50:58.420
so I'm going to stop this.

00:50:58.420 --> 00:51:03.780
The other thing to note is that it
looks like as I bring up more oceans,

00:51:03.910 --> 00:51:07.650
the amount of memory I'm
using is not going up.

00:51:09.150 --> 00:51:13.270
You'll see that I'm hovering
it around 1.12 megabytes,

00:51:13.270 --> 00:51:15.110
so that's really good.

00:51:15.330 --> 00:51:17.790
This is an iterative process,
and this is only the beginning.

00:51:17.800 --> 00:51:20.970
I really need to verify all of
the object lifespans for all my

00:51:20.990 --> 00:51:24.700
different classes to figure out how
best to fix all of my memory issues.

00:51:24.700 --> 00:51:28.740
But that's basically the leaks instrument
and the allocations instrument.

00:51:28.740 --> 00:51:32.730
Applause

00:51:39.650 --> 00:51:40.490
So what have I shown you?

00:51:40.490 --> 00:51:43.440
I showed you how to use the leaks
instrument and specifically the

00:51:43.500 --> 00:51:46.380
cycles and routes to identify
retained cycles in your code.

00:51:46.380 --> 00:51:50.540
And secondly,
I used allocations to determine why

00:51:50.580 --> 00:51:55.540
memory was increasing over time and
specifically checking my assumptions

00:51:55.580 --> 00:51:57.560
about the lifespan of my objects.

00:51:57.640 --> 00:52:02.060
And now I'd like to return
the floor back to Dave.

00:52:02.100 --> 00:52:03.270
Thank you, Dave.

00:52:09.870 --> 00:52:13.690
So what you saw on stage was Victor and
Joe following the profile process.

00:52:13.820 --> 00:52:17.740
They reproduced a problem,
they measured it with Instruments,

00:52:17.780 --> 00:52:19.800
came up with a theory about
what changes they could make

00:52:19.800 --> 00:52:23.300
to actually cause a change,
made those changes,

00:52:23.330 --> 00:52:26.820
and then went back and reverified that
they'd actually fixed the problem.

00:52:26.950 --> 00:52:28.180
This is a critical process.

00:52:28.290 --> 00:52:30.980
If you follow it, you'll have results.

00:52:31.770 --> 00:52:35.040
The instruments templates used
was we used Time Profiler,

00:52:35.160 --> 00:52:37.490
for which Joe found three
improvements fairly easily,

00:52:37.560 --> 00:52:41.050
a startup time improvement,
a drawing animation improvement,

00:52:41.050 --> 00:52:43.170
and we fixed an async problem
or a synchronous problem that

00:52:43.270 --> 00:52:44.260
was blocking the main thread.

00:52:44.260 --> 00:52:46.970
And Victor managed to find
two memory leak improvements

00:52:47.060 --> 00:52:48.720
by using the leaks template.

00:52:48.880 --> 00:52:52.260
This is by no means
the end of instruments.

00:52:52.340 --> 00:52:54.770
We can profile virtually
anything on the operating system.

00:52:54.840 --> 00:52:57.740
And if you read the documentation
or look at the library thing,

00:52:57.740 --> 00:53:01.470
we have over 35 instruments that
can profile different aspects,

00:53:01.590 --> 00:53:04.020
core profile, core animation, GCDQs.

00:53:04.020 --> 00:53:05.010
Come see us in the labs.

00:53:05.060 --> 00:53:07.020
We can tell you if you are
having a particular problem

00:53:07.020 --> 00:53:09.820
with a particular subsystem,
there's probably an instrument that

00:53:09.820 --> 00:53:14.090
will illuminate the data and what
your application is doing with it.

00:53:14.960 --> 00:53:18.550
If you do the profile process,
these are the reviews that you're going

00:53:18.550 --> 00:53:20.280
to get on your app on the App Store.

00:53:20.280 --> 00:53:21.440
Fantastic and fast.

00:53:21.490 --> 00:53:23.030
Must buy this app.

00:53:23.140 --> 00:53:24.900
And the ratings are going
to be radically different.

00:53:27.320 --> 00:53:29.730
If you need more information,
I encourage you to

00:53:29.730 --> 00:53:31.260
contact Michael Jurowicz.

00:53:31.300 --> 00:53:33.810
Instruments documentation
is included with Xcode and,

00:53:33.810 --> 00:53:35.100
of course, the Apple Developer Form.

00:53:35.100 --> 00:53:39.740
There's a vibrant community discussing
instruments on the Apple Developer Form.

00:53:39.740 --> 00:53:42.250
I appreciate everyone's time and
have an excellent conference.
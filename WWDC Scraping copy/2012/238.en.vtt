WEBVTT

00:00:10.440 --> 00:00:11.200
Hello, everyone.

00:00:11.240 --> 00:00:12.380
My name is Dan Crosby.

00:00:12.560 --> 00:00:14.800
I'm an engineer on the
iOS performance team.

00:00:14.800 --> 00:00:18.920
And I'm going to be talking about
graphics and animation performance today.

00:00:19.000 --> 00:00:21.170
So when I say graphics
and animation performance,

00:00:21.290 --> 00:00:24.930
what I really mean is two things that
we think really help to distinguish a

00:00:24.940 --> 00:00:31.340
really good functional app on iOS from
a really great -- an app that makes the

00:00:31.340 --> 00:00:32.870
user really glad to be using an app.

00:00:32.930 --> 00:00:36.110
And that's responsive animations
and smooth animations.

00:00:36.110 --> 00:00:38.360
And by responsiveness,
I mean an animation that

00:00:38.360 --> 00:00:41.250
begins immediately when the
user expects it to begin,

00:00:41.260 --> 00:00:44.600
when they gesture or tap or rotate
or whatever it is that they do.

00:00:44.700 --> 00:00:46.870
And by smooth animations,
I mean animations that

00:00:46.870 --> 00:00:49.350
don't drop any frames,
that don't stutter,

00:00:49.570 --> 00:00:52.080
that seem to be smooth
all the way through.

00:00:52.080 --> 00:00:54.100
And then -- so we're going
to be talking about today an

00:00:54.100 --> 00:00:56.600
introduction to animations,
how animations work on iOS.

00:00:56.600 --> 00:00:59.390
We're going to be talking about
how to make your animations in

00:00:59.390 --> 00:01:01.020
your app responsive and smooth.

00:01:01.050 --> 00:01:03.620
And then in particular,
we're going to talk about scrolling,

00:01:03.620 --> 00:01:05.760
which is a special type
of animation on iOS,

00:01:05.760 --> 00:01:08.960
which is particularly difficult
sometimes to stay smooth.

00:01:08.960 --> 00:01:11.360
So we have a lot to talk about.

00:01:11.360 --> 00:01:12.160
I'm going to dive right in.

00:01:12.160 --> 00:01:15.610
But first, I want to remind you of this
performance bug workflow,

00:01:15.650 --> 00:01:19.020
which you may have seen if you
went to the learning instruments

00:01:19.020 --> 00:01:21.130
or responsiveness talk earlier.

00:01:21.460 --> 00:01:24.190
This is a really important set
of steps that are useful in

00:01:24.190 --> 00:01:27.830
any performance bug analysis,
but they're especially important

00:01:27.830 --> 00:01:30.030
in graphics and animations bugs.

00:01:30.280 --> 00:01:32.690
So whenever you encounter a problem,
a performance problem,

00:01:32.690 --> 00:01:35.920
you want to start by measuring the
problem so you have a baseline so

00:01:35.990 --> 00:01:37.740
you know when you fix the problem.

00:01:38.010 --> 00:01:38.870
Then you want to profile -- and I'm
going to show you how to do that.

00:01:38.870 --> 00:01:41.800
So you want to profile using the tools,
form a hypothesis from the

00:01:41.800 --> 00:01:45.280
data you get from that profile,
maybe choose another profiling method

00:01:45.400 --> 00:01:48.420
to further hone that hypothesis,
iterate on that a few times.

00:01:48.420 --> 00:01:50.600
Do that before you make a change.

00:01:50.750 --> 00:01:53.330
Then make a change,
and you can start with a simple,

00:01:53.340 --> 00:01:56.900
you know, not shippable code change
just to test your fix.

00:01:56.900 --> 00:01:59.520
And then, most importantly of all,
measure the problem again so that you

00:01:59.520 --> 00:02:01.010
know that you've actually fixed it.

00:02:01.170 --> 00:02:03.690
And this is especially important
for graphics and animations because

00:02:03.740 --> 00:02:06.590
some of the strategies I'm going to
be talking about will help in some

00:02:06.590 --> 00:02:10.220
situations and will actually make your
problem worse in other situations.

00:02:10.220 --> 00:02:12.870
So you don't want to blindly
do any of the advice that I'm

00:02:12.870 --> 00:02:14.440
going to be giving you here.

00:02:14.620 --> 00:02:15.360
Okay.

00:02:15.420 --> 00:02:17.370
So let's start with an
introduction to animations.

00:02:17.570 --> 00:02:19.280
How do animations work on iOS?

00:02:19.280 --> 00:02:22.400
Well, let's start with a very brief
introduction to how views and

00:02:22.400 --> 00:02:24.170
layers and animations work.

00:02:24.210 --> 00:02:28.090
So if you've worked with UIKit at all,
of course you've worked with UI views,

00:02:28.090 --> 00:02:31.260
either creating them with interface
builder and putting them in a nib file

00:02:31.260 --> 00:02:33.420
or creating them programmatically.

00:02:33.420 --> 00:02:37.950
But in fact, every UI view on iOS is
backed by a CA layer.

00:02:37.950 --> 00:02:37.960
And it's the same thing with UI views.

00:02:37.960 --> 00:02:39.170
You can create a UI view on iOS,
and it's the CA layer that actually

00:02:39.170 --> 00:02:40.370
does most of the heavy lifting.

00:02:40.370 --> 00:02:44.310
That's what core animation acts on to
display something to the screen or to

00:02:44.310 --> 00:02:46.680
perform an animation on or whatever.

00:02:46.750 --> 00:02:49.320
So when you're doing view
layout in your application,

00:02:49.370 --> 00:02:51.230
you're actually doing layer layout.

00:02:51.250 --> 00:02:54.610
And when you draw rect to
draw the contents of a view,

00:02:54.640 --> 00:02:58.350
you're actually drawing into
the CA layer's backing store.

00:02:58.350 --> 00:03:00.920
And that backing store is what
gets shipped off to the render

00:03:00.920 --> 00:03:04.460
server and then sent off to the
GPU to display on the screen.

00:03:04.590 --> 00:03:07.420
Now, that part, the layout and draw rect
happens in your application.

00:03:07.460 --> 00:03:07.460
But you can actually do
that in your application.

00:03:07.460 --> 00:03:08.460
So you can actually do
that in your application.

00:03:08.460 --> 00:03:11.560
But layer properties and animations
are actually handled in another

00:03:11.560 --> 00:03:14.400
process in the render server,
which lives in a process called

00:03:14.400 --> 00:03:18.690
springboard if you're working before
iOS 6 or an application called --

00:03:18.690 --> 00:03:21.000
a process called backboard in iOS 6.

00:03:21.190 --> 00:03:24.840
That's where the actual animations
and layer properties are handled.

00:03:24.920 --> 00:03:27.730
And any changes you make to your
layer tree are committed to the

00:03:27.730 --> 00:03:31.020
render server inside a function
called CA transaction commit.

00:03:31.070 --> 00:03:32.440
Now, you never call that yourself.

00:03:32.440 --> 00:03:36.960
That's called implicitly when you
create an animation and start it going.

00:03:36.960 --> 00:03:36.960
Or implicitly when you
create an animation,

00:03:36.960 --> 00:03:39.620
or implicitly at the end of the run
loop if you make any changes to your

00:03:39.620 --> 00:03:42.610
layer tree outside of an animation,
happens at the end of the run loop.

00:03:44.600 --> 00:03:47.300
So when you kick off an animation,
there's three stages

00:03:47.300 --> 00:03:48.310
that it goes through.

00:03:48.430 --> 00:03:51.670
The first stage is to create the
animation and update the view hierarchy,

00:03:51.680 --> 00:03:54.890
and I'll be talking about each of
these in a little bit more detail.

00:03:54.890 --> 00:03:57.280
The second is to prepare
and commit the animation,

00:03:57.320 --> 00:03:59.290
and finally,
to render each frame and turn.

00:03:59.290 --> 00:04:02.280
Now, that first phase,
creating an animation,

00:04:02.300 --> 00:04:04.530
happens inside your application,
and it's the part you

00:04:04.530 --> 00:04:05.700
usually do explicitly.

00:04:05.730 --> 00:04:08.270
So you have some simple
animation like this where I'm

00:04:08.280 --> 00:04:10.960
going to create a new view,
start it with a transform

00:04:10.960 --> 00:04:12.200
to make it very,
very small,

00:04:12.270 --> 00:04:15.510
and then inside an animation block,
I'm going to add it to a super view and

00:04:15.910 --> 00:04:17.490
expand it by changing the transform.

00:04:17.490 --> 00:04:21.030
That'll get animated up
over a half-second duration.

00:04:21.080 --> 00:04:23.580
At the end of this,
a CA transaction will be

00:04:23.580 --> 00:04:26.220
implicitly committed for you.

00:04:26.600 --> 00:04:28.200
The next phase is
preparing the animation.

00:04:28.210 --> 00:04:31.400
That also happens in your application,
but it happens implicitly.

00:04:31.400 --> 00:04:33.840
You don't ever actually call
anything to make this happen.

00:04:33.950 --> 00:04:37.360
And at the beginning of an animation,
if you were to take a time profile,

00:04:37.530 --> 00:04:38.830
you'd actually see something like this.

00:04:38.930 --> 00:04:41.870
So all the stages I'm going to
be talking about in more detail,

00:04:41.920 --> 00:04:44.260
you can actually see in
your time profiler trace.

00:04:44.360 --> 00:04:46.810
And there's four steps to
preparing the animation.

00:04:46.940 --> 00:04:50.600
There's layout to set up the views,
display to draw the views,

00:04:50.710 --> 00:04:53.160
prepare to do other core animation
work that needs to be done

00:04:53.160 --> 00:04:55.450
before the animation can begin,
and commit,

00:04:55.580 --> 00:04:59.300
where we actually package up the views
and send them off to the render server.

00:04:59.300 --> 00:05:02.440
So in the layout phase,
this is where you actually put the

00:05:02.520 --> 00:05:06.460
subviews in the place where they need
to be at the end of the animation.

00:05:06.680 --> 00:05:08.900
So this often has
expensive view creation.

00:05:08.900 --> 00:05:11.610
The first time you go to a given view,
we may have to create the

00:05:11.610 --> 00:05:14.100
subviews underneath it if
they've never been drawn before.

00:05:14.100 --> 00:05:17.300
We may have to do some expensive
data lookup to populate the views.

00:05:17.300 --> 00:05:20.350
So if you need to set text on some
strings or something like that,

00:05:20.730 --> 00:05:22.930
you might look up in a database.

00:05:23.180 --> 00:05:26.180
It's often--it's usually
CPU bound in this phase,

00:05:26.180 --> 00:05:30.080
but sometimes it can become I/O bound if
you're doing some of that database work,

00:05:30.090 --> 00:05:33.130
or maybe you've got a worker thread
going on in the background and

00:05:33.130 --> 00:05:37.020
you need to check up with that,
synchronize with that to get your data.

00:05:37.090 --> 00:05:40.990
So it's usually CPU bound,
but sometimes I/O bound.

00:05:41.450 --> 00:05:43.560
The next phase is display,
and this is where we actually

00:05:43.560 --> 00:05:45.390
draw the contents of your views.

00:05:45.540 --> 00:05:48.720
So if you've overridden drawRect in any
of the classes that are-- any of the

00:05:48.730 --> 00:05:51.840
views that are involved in the animation,
this is where we'll call drawRect.

00:05:51.880 --> 00:05:53.660
And implicitly,
lots of other drawRects get

00:05:53.740 --> 00:05:56.770
called for string drawing and
other very expensive things.

00:05:56.950 --> 00:06:00.400
So this is also usually CPU-bound.

00:06:01.290 --> 00:06:02.590
The next step is the prepare phase.

00:06:02.740 --> 00:06:06.560
This is where CA does other work to get
ready the contents of the layers that

00:06:06.560 --> 00:06:07.940
aren't happening inside a draw rect.

00:06:08.060 --> 00:06:11.330
So the most obvious example of
this would be in an image view.

00:06:11.420 --> 00:06:13.310
An image view doesn't
even implement draw rect,

00:06:13.310 --> 00:06:15.540
so it doesn't draw the
contents of the image,

00:06:15.690 --> 00:06:20.430
but it's updating the CA layer's
contents with the bitmap of that image.

00:06:20.540 --> 00:06:22.760
So this is where you'll see
Core Animation do work like

00:06:22.760 --> 00:06:25.690
decoding the image that's going
to be displayed in an image view.

00:06:25.870 --> 00:06:28.100
Now be careful with this one.

00:06:28.390 --> 00:06:30.900
If you are decoding images,
sometimes not all the time

00:06:30.900 --> 00:06:33.670
will show up in this backtrace
in the time profiler trace.

00:06:33.830 --> 00:06:36.000
Sometimes we do image
decoding in parallel,

00:06:36.000 --> 00:06:39.150
and so you may see like this
copy image block set ping

00:06:39.220 --> 00:06:40.750
happening on multiple threads.

00:06:40.870 --> 00:06:43.050
So when you're trying to
time how long this takes,

00:06:43.050 --> 00:06:44.590
you need to watch out for that.

00:06:44.960 --> 00:06:47.700
Finally, the commit phase is where we
package up all the layers,

00:06:47.780 --> 00:06:51.580
encode them for IPC,
and send them off to the render server.

00:06:51.610 --> 00:06:53.400
Usually, this doesn't take very long,
and in this case,

00:06:53.400 --> 00:06:54.990
it's like five milliseconds.

00:06:55.010 --> 00:06:58.190
But if you have a very expensive,
a very complex view hierarchy

00:06:58.200 --> 00:07:02.300
with lots and lots of sublayers,
you can see this taking a long time.

00:07:02.560 --> 00:07:06.000
And after this part,
now the work has left your application.

00:07:06.140 --> 00:07:10.080
It's gone off to the render server,
and it's going to take care of updating

00:07:10.080 --> 00:07:12.620
the animation every frame after that.

00:07:12.720 --> 00:07:15.260
So this phase is outside
your application.

00:07:15.260 --> 00:07:16.860
It's usually GPU bound.

00:07:16.860 --> 00:07:20.340
But if you were to look at a
CPU strategy view of a time profile

00:07:20.410 --> 00:07:23.320
or trace during an animation,
you'd see something like this.

00:07:23.590 --> 00:07:26.490
Those blue parts are not your app,
but they're the render server,

00:07:26.490 --> 00:07:29.700
so springboard or backward,
spinning up 60 times a second

00:07:29.700 --> 00:07:31.290
to prepare the next frame.

00:07:31.460 --> 00:07:34.200
Usually this doesn't take very long,
but if you have a very complex

00:07:34.200 --> 00:07:36.970
view hierarchy and you're
running on a single core device,

00:07:36.970 --> 00:07:39.170
that work can be interfering
with work that you're trying

00:07:39.170 --> 00:07:40.230
to do in your application.

00:07:40.270 --> 00:07:42.370
So you do want to watch out for that.

00:07:42.820 --> 00:07:44.360
Okay,
so with that very brief introduction

00:07:44.360 --> 00:07:47.960
to how views and animations work,
let's talk about making

00:07:47.960 --> 00:07:49.800
animations responsive.

00:07:49.800 --> 00:07:53.140
So going back to our chart,
the three stages of the animation,

00:07:53.140 --> 00:07:55.720
we're worried about the first
two stages in this case:

00:07:55.910 --> 00:07:58.790
creating the animation and then
preparing and committing the animation.

00:07:58.860 --> 00:08:01.490
Now,
the first part you can profile yourself.

00:08:01.560 --> 00:08:02.900
That's something you're doing explicitly.

00:08:02.900 --> 00:08:05.820
So the second part is what
I'm going to focus on here.

00:08:05.820 --> 00:08:08.150
So some of the things that
delay an animation are,

00:08:08.150 --> 00:08:10.180
first of all, layout.

00:08:10.180 --> 00:08:13.040
You might have slow layout because
you have a very complex hierarchy.

00:08:13.040 --> 00:08:16.290
You are trying to position lots and lots
of subviews in their appropriate places.

00:08:16.340 --> 00:08:18.860
You have to do a lot of
expensive calculation.

00:08:18.870 --> 00:08:20.300
We do lazy construction of views.

00:08:20.420 --> 00:08:23.480
So the first time that you
go to a particular view,

00:08:23.480 --> 00:08:25.500
if you're animating a flip
or something like that,

00:08:25.500 --> 00:08:27.960
we have to create all those subviews.

00:08:27.960 --> 00:08:29.430
And then, of course,
if you have to populate the

00:08:29.510 --> 00:08:31.790
views by doing database access
going down to the flash,

00:08:31.790 --> 00:08:33.910
something like that,
to populate the views,

00:08:33.910 --> 00:08:36.580
that's also very time consuming.

00:08:37.060 --> 00:08:39.200
Drawing can also slow your animation.

00:08:39.280 --> 00:08:42.690
It's important to note that
we do all the work to prepare

00:08:42.690 --> 00:08:44.700
the entire animation up front.

00:08:44.700 --> 00:08:48.460
So even if you have a view that doesn't
appear until frame 15 of your animation,

00:08:48.490 --> 00:08:51.640
we're going to lay out and
draw that view ahead of time.

00:08:51.640 --> 00:08:54.770
So any draw rect that's going to
be used anywhere in your animation,

00:08:54.770 --> 00:08:58.220
we have to do it up front,
and that's going to delay the beginning.

00:08:58.220 --> 00:09:00.240
So if you've got your own draw rect,
of course,

00:09:00.300 --> 00:09:02.190
that can take arbitrarily long.

00:09:02.210 --> 00:09:05.240
String drawing is expensive,
especially on a retina display.

00:09:05.280 --> 00:09:07.360
We have to render four
times as many pixels,

00:09:07.360 --> 00:09:09.440
so string drawing can take a long time.

00:09:09.440 --> 00:09:11.460
And image decoding,
depending on the size of the image,

00:09:11.470 --> 00:09:12.640
can be very time consuming.

00:09:14.370 --> 00:09:17.290
So we're going to talk about a number of
steps to help you improve responsiveness.

00:09:17.300 --> 00:09:19.300
We'll talk about doing less
setup and less drawing.

00:09:19.300 --> 00:09:20.800
That obviously is always good.

00:09:20.800 --> 00:09:24.300
We'll talk about being smart with images
to make those as fast as possible.

00:09:24.440 --> 00:09:28.930
We'll talk about a new feature in iOS
6 called Draws Asynchronously that can

00:09:28.930 --> 00:09:31.300
help in drawing particularly slow layers.

00:09:31.300 --> 00:09:34.200
And finally, speculative preparation.

00:09:34.500 --> 00:09:36.920
So doing less setup is stuff
that sounds kind of obvious,

00:09:36.980 --> 00:09:40.070
but if you take a time profiler trace
and you see that most of your time

00:09:40.080 --> 00:09:43.910
is in the layout if needed part,
this is the first place you should look.

00:09:44.130 --> 00:09:48.370
Try to avoid any CPU heavy or blocking
operations during your layout phase.

00:09:48.420 --> 00:09:50.450
So if you're doing really
expensive database work,

00:09:50.680 --> 00:09:53.240
could you have that -- the part
of the database that you need,

00:09:53.260 --> 00:09:57.000
could you have the actual entries that
you need cached and ready up front?

00:09:57.060 --> 00:09:59.680
Cache whatever information
you're going to need for the

00:09:59.680 --> 00:10:01.830
next time that you draw the view.

00:10:01.880 --> 00:10:05.060
If you do have to do database lookup
during a scroll operation or during

00:10:05.060 --> 00:10:07.780
the beginning of an animation,
make sure that you have the

00:10:07.780 --> 00:10:11.620
appropriate indices on your database
to make it as performant as possible.

00:10:11.690 --> 00:10:15.320
And finally, always reuse your cells and
sometimes even reuse views.

00:10:15.320 --> 00:10:17.990
So for UI table view
and UI collection view,

00:10:18.270 --> 00:10:21.590
there's really easy API for reusing
those table cells so you don't have

00:10:21.590 --> 00:10:22.810
to reconstruct them every time.

00:10:22.810 --> 00:10:25.180
Make sure that you're using
the correct identifier so you

00:10:25.180 --> 00:10:27.560
can reuse as much as possible.

00:10:27.660 --> 00:10:31.300
Keep similar types of
cells grouped together.

00:10:31.300 --> 00:10:32.170
But even views.

00:10:32.170 --> 00:10:33.160
If you have a view -- two views,
you can use a table view to make sure

00:10:33.170 --> 00:10:35.480
that you're using two very similar
looking views that appear at completely

00:10:35.550 --> 00:10:37.360
different places of your application.

00:10:37.360 --> 00:10:41.590
Can you reuse the view from the other
spot and simply give it a new super view?

00:10:43.500 --> 00:12:08.000
[Transcript missing]

00:12:08.340 --> 00:12:11.430
If you do have to implement draw
rect and call set needs display,

00:12:11.730 --> 00:12:14.890
try to implement a smart draw rect,
that is one that only redraws the

00:12:14.970 --> 00:12:18.740
part of the rectangle that has
been passed in as having changed,

00:12:18.840 --> 00:12:22.400
and then call set needs display and rect,
so that if you only have a section

00:12:22.400 --> 00:12:25.140
of your view that's changed,
you'll only redraw that section.

00:12:25.230 --> 00:12:29.130
The core graphics drawing functions
are usually pretty smart about this.

00:12:29.220 --> 00:12:32.690
Make sure that your own draw rect
code is also smart about only

00:12:32.690 --> 00:12:34.730
redrawing the parts it needs to.

00:12:35.350 --> 00:12:40.540
When possible, instead of using DrawRect,
try to use CALayer properties instead.

00:12:40.780 --> 00:12:44.140
This gets the work out of your
application and during the DrawRect

00:12:44.440 --> 00:12:47.320
part of your application and sends
the work over to the render server

00:12:47.340 --> 00:12:51.140
and hopefully even to the GPU,
where it won't take any CPU time at all.

00:12:51.200 --> 00:12:53.140
Now, this isn't true for
all CALayer properties.

00:12:53.140 --> 00:12:55.930
If you're using CALayer properties
for things like shadows,

00:12:55.940 --> 00:12:58.680
which actually sound like
they should be expensive,

00:12:58.890 --> 00:13:00.930
that can sometimes be slower
than drawing it yourself,

00:13:00.940 --> 00:13:02.240
so you'll want to experiment with this.

00:13:02.240 --> 00:13:05.020
But in general,
try to use CALayer properties.

00:13:05.560 --> 00:13:06.600
Now, a very simple example.

00:13:06.600 --> 00:13:11.250
Suppose we have a case where we
have a view that all is really being

00:13:11.250 --> 00:13:16.080
used for is a background color in
which we put subviews on top of it.

00:13:16.260 --> 00:13:20.130
So it's just a colored place where we
position different views on top of it.

00:13:20.190 --> 00:13:22.790
Well, one way to achieve that
would be to call drawRect,

00:13:22.900 --> 00:13:27.330
set red as our fill color,
and then call UIRectFill on our bounds.

00:13:27.450 --> 00:13:28.940
Well, there's a couple of
things wrong with this.

00:13:28.940 --> 00:13:31.660
One is that this is something
we can achieve perfectly well

00:13:31.660 --> 00:13:33.520
with a CA layer property,
as I'll show you in a moment.

00:13:34.010 --> 00:13:36.340
The other one is that you
notice in my UIRectFill,

00:13:36.340 --> 00:13:40.440
I'm filling the entire bounds of my view,
which I don't really have to do.

00:13:40.440 --> 00:13:43.040
I really should only be calling
that on the rect that was passed in.

00:13:43.060 --> 00:13:47.310
But a better way overall to do this
is ditch the drawRect entirely and

00:13:47.560 --> 00:13:51.140
call setBackgroundColor on the view.

00:13:51.140 --> 00:13:53.380
That will in turn set the
background color on the layer,

00:13:53.380 --> 00:13:55.240
and we can avoid calling drawRect at all.

00:13:55.240 --> 00:13:58.260
There's no backing store to allocate,
and everything should perform better.

00:13:58.260 --> 00:14:00.380
Now, there's some exceptions to this,
as we'll see,

00:14:00.380 --> 00:14:03.020
but generally this is the pattern
you want to try to follow.

00:14:04.560 --> 00:14:06.500
Now let's talk about
being smart with images.

00:14:06.500 --> 00:14:09.340
And so I want to start by
talking a little bit about how

00:14:09.340 --> 00:14:10.500
images work on our platform.

00:14:10.500 --> 00:14:13.190
The way you would usually
display a picture in an iOS

00:14:13.190 --> 00:14:17.420
app is using a UI image view,
which of course is backed by a UI image.

00:14:17.500 --> 00:14:22.500
What all UI image is actually is a very
lightweight wrapper around CG image.

00:14:22.500 --> 00:14:25.860
It's a core graphics data structure
that does most of the heavy

00:14:25.860 --> 00:14:29.500
lifting of scaling the image,
blending it, and so forth.

00:14:29.500 --> 00:14:33.500
And then the image decoding part is in
a related framework called Image.io.

00:14:33.500 --> 00:14:36.490
So UI image does a little bit of work,
but really most of it lives

00:14:36.490 --> 00:14:37.500
over there in CG image.

00:14:37.500 --> 00:14:41.450
Well, as we know,
all views are backed by CA layers.

00:14:41.500 --> 00:14:45.570
So with a UI image view,
what's actually happening is the CG image

00:14:45.730 --> 00:14:49.490
is set as the contents of the CA layer.

00:14:49.500 --> 00:14:54.500
So both the UI image and the CA layer
are both backed by that CG image.

00:14:54.500 --> 00:14:58.500
So when it's time to display this image,
UI image view doesn't have a draw rect.

00:14:58.500 --> 00:15:02.500
The layer simply asks the CG image for
the contents that it needs directly.

00:15:02.500 --> 00:15:06.890
By the way, a CG image works,
it usually starts its existence

00:15:06.890 --> 00:15:08.500
backed by a file or backed by data.

00:15:08.500 --> 00:15:11.500
So it might be backed by a ping,
for instance.

00:15:11.500 --> 00:15:13.490
It doesn't decode that ping in advance.

00:15:13.500 --> 00:15:15.500
It doesn't decode it until it needs to.

00:15:15.500 --> 00:15:17.480
So when you create a
CG image or a UI image,

00:15:17.480 --> 00:15:19.500
you'll find it's usually very cheap.

00:15:19.640 --> 00:15:22.500
But then the first time
you display it on screen,

00:15:22.500 --> 00:15:24.500
that's when the bitmap gets decoded.

00:15:24.500 --> 00:15:27.500
And that bitmap is then what gets
sent off to the render server.

00:15:27.500 --> 00:15:30.740
So one of the consequences of these is
that generally you want to use these

00:15:30.740 --> 00:15:31.500
UI image views whenever you want.

00:15:31.500 --> 00:15:36.650
It's generally a better strategy than
using the UI image draw at point or

00:15:36.660 --> 00:15:39.500
draw in rect methods in your draw rect.

00:15:39.500 --> 00:15:42.480
Some of the advantages of this are that,
for instance,

00:15:42.540 --> 00:15:45.740
core animation will ask directly
for the bitmap data in exactly

00:15:45.740 --> 00:15:46.500
the format that it needs it.

00:15:46.500 --> 00:15:50.640
Instead of allocating a separate
backing store and then copying

00:15:50.640 --> 00:15:52.450
that bitmap data into it.

00:15:52.500 --> 00:15:55.140
It also allows any blending,
if there's blending into other

00:15:55.140 --> 00:15:56.500
things that are in the view.

00:15:56.500 --> 00:16:00.500
It allows that blending to happen
on the GPU instead of on the CPU.

00:16:00.500 --> 00:16:02.500
So that's one of the kind
of things GPUs are good at.

00:16:02.500 --> 00:16:04.640
And it also gives you some
extra forms of bitmap caching,

00:16:04.640 --> 00:16:07.500
which we'll look at in
more detail in a moment.

00:16:08.200 --> 00:19:32.300
[Transcript missing]

00:19:36.080 --> 00:19:37.950
The other image format
to consider is JPEG,

00:19:38.050 --> 00:19:40.140
and this is a bit of a
change from the past.

00:19:40.200 --> 00:19:43.070
We used to say JPEG was slow
on iOS and to avoid using it.

00:19:43.370 --> 00:19:46.740
We've made a lot of improvements in
the last few major revisions of iOS,

00:19:46.790 --> 00:19:48.600
and now JPEGs are pretty fast.

00:19:48.670 --> 00:19:51.660
So this, of course,
gives you great compression, small files.

00:19:51.660 --> 00:19:54.180
It's great compression,
especially for very noisy images,

00:19:54.200 --> 00:19:57.250
things that don't compress well in ping.

00:19:57.350 --> 00:19:59.290
But it does sometimes
have noticeable artifacts,

00:19:59.300 --> 00:20:02.680
so we don't recommend
JPEG for UI elements,

00:20:02.680 --> 00:20:03.460
for instance.

00:20:03.460 --> 00:20:05.190
Stick with pings for those.

00:20:05.250 --> 00:20:07.820
It also--JPEGs can't have alpha,
so if you actually need

00:20:07.870 --> 00:20:10.540
transparency in your image,
you have to stick with ping for that.

00:20:10.640 --> 00:20:13.810
But sometimes you can play a trick,
like using the center of the

00:20:13.810 --> 00:20:16.260
image where there is no alpha,
use a JPEG for that,

00:20:16.270 --> 00:20:20.920
and then have a border with alpha as a
series of pings or something like that.

00:20:21.380 --> 00:20:24.800
Now, of course, those aren't the only two
image formats out there.

00:20:24.800 --> 00:20:27.830
There's TIFFs, there's JPEG 2000,
there's things like that.

00:20:27.830 --> 00:20:29.780
But our advice for that is very simple.

00:20:29.870 --> 00:20:32.280
Don't use anything else.

00:20:32.350 --> 00:20:35.000
Ping and JPEG have been
really well optimized for iOS.

00:20:35.000 --> 00:20:37.340
We're going to continue
to optimize those.

00:20:37.740 --> 00:20:41.560
Really, our focus is not on any
other image formats.

00:20:41.560 --> 00:20:45.310
You might think that you have--maybe
you found a raw bitmap-based format that

00:20:45.310 --> 00:20:49.220
seems to--you take a time profiler trace,
it seems to be really fast.

00:20:49.220 --> 00:20:53.700
Usually, with those other formats,
any win you get in decode time on CPU is

00:20:53.810 --> 00:20:58.300
going to be made up for by the extra
time in I/O when we have to actually

00:20:58.300 --> 00:21:00.580
pull the less compressed image off disk.

00:21:00.730 --> 00:21:03.470
So--and because of the page
cache and a lot of things,

00:21:03.470 --> 00:21:05.730
it's really hard for you to
tell when that's happening.

00:21:05.730 --> 00:21:08.880
So our advice really is stick with
Ping and JPEG unless you have a really

00:21:08.880 --> 00:21:11.980
overwhelming reason to do something else.

00:21:12.180 --> 00:21:14.650
Now, of course,
the best image decode of all is

00:21:14.650 --> 00:21:16.100
the one that you don't have to do.

00:21:16.250 --> 00:21:20.360
So we do have a number of unfortunately
complicated caching strategies for

00:21:20.360 --> 00:21:24.120
images on iOS where we'll actually cache
the bitmap so we don't have to decode

00:21:24.120 --> 00:21:26.040
it every time you display the image.

00:21:26.120 --> 00:21:28.170
And as I say,
this is a little bit complicated,

00:21:28.220 --> 00:21:28.940
so bear with me.

00:21:28.940 --> 00:21:31.090
But when you're drawing
into a bitmap context,

00:21:31.090 --> 00:21:33.940
so when you're using UIImage,
Draw and Rect, or Draw at Point,

00:21:34.120 --> 00:21:37.320
it depends on how you made
the image whether we're going

00:21:37.320 --> 00:21:39.100
to cache the bitmap or not.

00:21:39.100 --> 00:21:41.770
So if you created your image
using UIImage Image Named,

00:21:41.880 --> 00:21:44.080
we will cache the image
in purgeable memory,

00:21:44.130 --> 00:21:46.320
so it'll stick around until
we're under severe memory

00:21:46.420 --> 00:21:48.100
pressure and then we'll evict it.

00:21:48.100 --> 00:21:51.670
And we'll also cache it in UIKit's
Image Table in case you call

00:21:51.670 --> 00:21:54.100
Image Named on that same image again.

00:21:54.100 --> 00:21:57.490
But if you create your image with
UIImage Image with Contents of File and

00:21:57.490 --> 00:22:01.100
you draw it into a bitmap context,
we will not cache the bitmap for you.

00:22:01.180 --> 00:22:04.100
We'll have to re-decode
it every time you draw it.

00:22:04.100 --> 00:22:07.020
So keep that in mind when you're
deciding both how to draw your

00:22:07.020 --> 00:22:09.100
images and how to create your images.

00:22:09.100 --> 00:22:11.520
All CG images,
no matter how they were created,

00:22:11.630 --> 00:22:15.070
cache their bitmaps when they're
set as the contents of a layer.

00:22:15.150 --> 00:22:17.560
So if you use UIImageView,
you don't have to worry about

00:22:17.560 --> 00:22:19.100
how the CG image was created.

00:22:19.100 --> 00:22:21.100
We will always cache the bitmap for you.

00:22:21.100 --> 00:22:24.110
Now if you're not using UIKit,
if you're using CG image

00:22:24.110 --> 00:22:27.570
functions to create your images,
if you set the case CG image

00:22:27.570 --> 00:22:30.100
source should cache flag
when creating the image,

00:22:30.100 --> 00:22:35.060
we'll give you the same caching
and purgeable memory behavior.

00:22:35.120 --> 00:22:37.940
So generally try to rely on
these bitmap caching strategies.

00:22:38.100 --> 00:22:39.100
Don't try to cache the bitmap.

00:22:39.100 --> 00:22:42.750
There are various ways you can do that by
drawing into a bitmap context and getting

00:22:42.830 --> 00:22:45.100
an image out of the bitmap context.

00:22:45.100 --> 00:22:47.100
There are situations
where that's called for,

00:22:47.100 --> 00:22:51.090
but generally you want to try to rely
on the built-in image caching strategies

00:22:51.090 --> 00:22:55.100
because it will do the right thing
under low memory and things like that.

00:22:56.190 --> 00:22:58.130
So here's another very,
very simple example.

00:22:58.360 --> 00:23:02.100
Suppose we want to draw an image
scaled to the size of the view

00:23:02.100 --> 00:23:03.660
that we're displaying it in.

00:23:03.700 --> 00:23:06.640
Well, we could implement a draw
rect and call draw in rect

00:23:06.670 --> 00:23:11.060
using the bounds of our view,
and that will scale it appropriately.

00:23:11.110 --> 00:23:16.430
But a much better way to do it is simply
set the CG image out of that image

00:23:16.430 --> 00:23:18.780
as the contents of the view's layer.

00:23:18.820 --> 00:23:20.720
That will give you more bitmap caching.

00:23:20.720 --> 00:23:23.090
You don't have to worry about
where the image came from.

00:23:23.100 --> 00:23:25.070
In the first example,
we don't know how the image was

00:23:25.070 --> 00:23:28.050
created at this point in the code,
so we don't know whether the

00:23:28.050 --> 00:23:29.940
bitmap's going to be cached or not.

00:23:29.940 --> 00:23:32.400
It will also allow blending
to happen on the GPU.

00:23:32.500 --> 00:23:36.810
And this is exactly what happens
if you create your--if you use a

00:23:36.880 --> 00:23:40.380
UI image view instead of drawing it.

00:23:41.230 --> 00:23:42.220
Okay.

00:23:42.690 --> 00:23:45.090
Now I'm going to talk about the
only new feature in iOS 6 that I'm

00:23:45.090 --> 00:23:48.440
going to be talking about here,
which is a new flag on a CA layer

00:23:48.440 --> 00:23:50.040
called Draws Asynchronously.

00:23:50.050 --> 00:23:52.750
And a bunch of people are going to
get very excited when I say this,

00:23:52.850 --> 00:23:56.670
but this is not as exciting
as it first sounds.

00:23:56.810 --> 00:24:00.860
Draws Asynchronously is hardware
accelerated drawing for your views.

00:24:00.960 --> 00:24:02.920
So what we'll actually
do is in your draw rect,

00:24:03.000 --> 00:24:07.600
instead of drawing into the
contents immediately on CPU,

00:24:07.730 --> 00:24:11.010
Core Graphics will queue up the
drawing commands and have the

00:24:11.040 --> 00:24:13.680
GPU fill in the backing store later.

00:24:13.740 --> 00:24:16.330
And the GPU can usually
do that very fast,

00:24:16.460 --> 00:24:17.780
but this has a high setup cost.

00:24:17.940 --> 00:24:21.350
So when we do this,
there's a fixed cost associated with a

00:24:21.350 --> 00:24:23.200
view that's going to happen every time.

00:24:23.230 --> 00:24:25.090
And there's also a
high fixed memory cost.

00:24:25.130 --> 00:24:29.700
So the very first time that you set
Draws Asynchronously on any layer,

00:24:29.700 --> 00:24:31.520
there's going to be a memory hit
that you're never going to get back.

00:24:31.610 --> 00:24:33.060
That's just going to stick around.

00:24:33.230 --> 00:24:36.630
So this is very good if you're
drawing lots and lots of things

00:24:36.630 --> 00:24:38.850
into a single large view,
so a view that would

00:24:38.850 --> 00:24:39.200
look like a web page,
for instance,

00:24:39.200 --> 00:24:43.190
Draws Asynchronously can work very,
very well for you.

00:24:43.200 --> 00:24:46.700
If you're doing lots of views and
drawing a little bit into each view,

00:24:46.700 --> 00:24:49.200
this will probably
actually make things worse.

00:24:49.200 --> 00:24:51.680
So you always want to test your
performance before enabling

00:24:51.700 --> 00:24:54.200
Draws Asynchronously and
then test it again afterward.

00:24:54.200 --> 00:24:58.120
And turn it off if you don't
see a noticeable improvement.

00:24:58.400 --> 00:25:01.150
This is the kind of thing that if
you set it and forget about it,

00:25:01.160 --> 00:25:03.050
it might end up biting you later on.

00:25:04.350 --> 00:25:06.040
Okay, finally,
if you tried all those other

00:25:06.040 --> 00:25:08.760
strategies for speeding up your
layout in your drawing and it's

00:25:08.760 --> 00:25:12.460
still not fast enough and your
animation's still not responsive,

00:25:12.460 --> 00:25:15.090
the last strategy is
to do speculative work.

00:25:15.180 --> 00:25:18.780
And that's where you actually do work
in advance so that it's already ready in

00:25:18.780 --> 00:25:20.960
those first two stages of the animation.

00:25:20.960 --> 00:25:24.780
So this might mean looking up the data
you need to populate future table views.

00:25:24.800 --> 00:25:27.600
It might mean before you flip
over to go to that other view,

00:25:27.600 --> 00:25:29.130
you create those views in advance.

00:25:29.140 --> 00:25:32.930
You can even do the image decoding on a
background thread so that it's all ready.

00:25:32.960 --> 00:25:36.230
But any time you do this,
you're going to end up doing some

00:25:36.230 --> 00:25:38.570
work that's going to turn out you
didn't need because you don't know in

00:25:38.570 --> 00:25:40.090
advance what your user's going to do.

00:25:40.120 --> 00:25:43.460
And caching this stuff is
going to entail a memory hit.

00:25:43.460 --> 00:25:46.640
So this is really something
to do only as a last resort.

00:25:46.720 --> 00:25:49.930
And it's also not easy to
do safely and performantly.

00:25:49.960 --> 00:25:52.770
In fact, it's easy to do this and
make your application worse.

00:25:52.800 --> 00:25:55.260
If you think just a little bit about it,
you have to have some

00:25:55.260 --> 00:25:56.460
kind of thread-safe cache.

00:25:56.460 --> 00:25:58.720
You have to have some kind
of cancellation mechanism.

00:25:58.720 --> 00:26:01.610
You have to know--the main thread has to
know when it gets to a bit of a dead end.

00:26:01.620 --> 00:26:01.620
And that's what we're going to do.

00:26:01.620 --> 00:26:01.620
So this is a little bit of a
summary of what we're going to do.

00:26:01.620 --> 00:26:01.620
And this is a little bit of a
summary of what we're going to do.

00:26:01.720 --> 00:26:03.960
When it gets to a bit
of data that it needs,

00:26:04.100 --> 00:26:06.210
whether that data is already
being generated in the background

00:26:06.210 --> 00:26:09.180
thread or whether it should
generate itself right now.

00:26:09.500 --> 00:26:11.780
So there are times where
this can really save you,

00:26:11.920 --> 00:26:13.860
but it's also difficult to get right.

00:26:13.990 --> 00:26:17.580
So it really ought to be
the last thing that you try.

00:26:17.680 --> 00:26:20.420
For my first demo,
I've got a very simple painting

00:26:20.420 --> 00:26:24.460
application that it turns out
performs pretty well on older iPads,

00:26:24.460 --> 00:26:28.620
but strangely enough, on the newest iPad,
it doesn't perform as well as it used to.

00:26:28.730 --> 00:26:31.080
And it's a very simple painting
application that all it does

00:26:31.080 --> 00:26:31.580
is it has a page that says,
"I'm going to do this." And it's a very

00:26:31.580 --> 00:26:31.580
simple painting application that all
it does is it has a page that says,

00:26:31.580 --> 00:26:31.580
"I'm going to do this." And it's
a very simple painting application

00:26:31.580 --> 00:26:33.950
that all it does is it has a page
paint view that has a touches began,

00:26:33.950 --> 00:26:36.450
touches moved, and touches ended.

00:26:36.490 --> 00:26:41.670
It tracks where the user's touches are
going and then it adds to a CG path

00:26:41.670 --> 00:26:45.030
with the line from the previous point.

00:26:45.030 --> 00:26:47.400
It also allows you to choose a color.

00:26:47.620 --> 00:26:51.230
And then in the draw rect,
it draws all the previous paths

00:26:51.420 --> 00:26:54.850
that since the -- where the user
drew something and then let go

00:26:54.950 --> 00:26:57.740
and then draw something new,
it draws all the previous paths

00:26:57.820 --> 00:27:02.200
with their colors and then it draws
the current path with its color.

00:27:02.200 --> 00:27:06.790
So, when I run this,

00:27:09.400 --> 00:27:12.160
When I run this, okay, I'm painting,
and that's great,

00:27:12.240 --> 00:27:17.270
but responsiveness is poor,
to say the least.

00:27:17.320 --> 00:27:21.460
At the beginning, everything's fine,
but then after I draw a little bit,

00:27:21.470 --> 00:27:24.840
it starts taking a long time
to track what I'm doing.

00:27:24.870 --> 00:27:27.360
Okay, so I have no idea why that's
happening to start with.

00:27:27.500 --> 00:27:30.080
A good strategy whenever you
have any performance issue you

00:27:30.080 --> 00:27:32.340
don't know what else to do about,
it's always a good idea to

00:27:32.340 --> 00:27:33.450
start with Time Profiler.

00:27:33.460 --> 00:27:36.460
Time Profiler is a good-- I don't
know what else to look at,

00:27:36.460 --> 00:27:37.960
and we'll see what this turns up.

00:27:37.960 --> 00:27:40.460
We'll see what's going on on CPU.

00:27:40.460 --> 00:27:45.330
So I'm gonna run Time Profiler
on my application.

00:27:47.390 --> 00:27:53.760
And as I draw,
I see that the CPU time on my main

00:27:53.760 --> 00:27:55.540
thread is basically maxing out.

00:27:55.540 --> 00:27:58.790
It's basically counting out with
the wall clock time as I draw.

00:27:58.880 --> 00:28:00.220
And that's not a good sign.

00:28:00.220 --> 00:28:03.340
And I'll blow that up
a little bit for you.

00:28:03.340 --> 00:28:06.660
So obviously I seem to have
a CPU bound problem here.

00:28:06.660 --> 00:28:10.760
So I'm going to open up my extended
view and go to the main thread.

00:28:10.760 --> 00:28:14.540
And this shows me the heaviest call
trace of anything that's going on in what

00:28:14.540 --> 00:28:17.380
I have selected over here on the left.

00:28:17.380 --> 00:28:22.580
And I see that all of my time is in
my draw rect in my paint view and

00:28:23.000 --> 00:28:25.650
specifically in the CG context draw path.

00:28:25.650 --> 00:28:29.970
So I'm actually spending all of
my CPU time drawing these paths.

00:28:30.080 --> 00:28:32.300
And in particular, the current path.

00:28:32.410 --> 00:28:34.330
This is not inside the array enumeration.

00:28:34.340 --> 00:28:36.170
This is inside the current path.

00:28:36.450 --> 00:28:37.220
Okay.

00:28:37.460 --> 00:28:39.740
So my next step is to
try to confirm that.

00:28:39.860 --> 00:28:42.040
So I have a hypothesis that
my draws are taking too long.

00:28:42.040 --> 00:28:45.700
I'm going to try to confirm that by
actually instrumenting my draw rect.

00:28:45.700 --> 00:28:49.000
So I'm taking the absolute
time at the beginning and

00:28:49.000 --> 00:28:51.200
the absolute time at the end.

00:28:51.200 --> 00:28:51.800
And I'm logging this.

00:28:51.800 --> 00:28:53.940
Don't leave this in your shipping code,
please, by the way.

00:28:53.940 --> 00:28:58.190
But this is a good way to
instrument and verify my theory.

00:28:58.190 --> 00:29:01.730
And I see in the console
view down below that

00:29:12.400 --> 00:29:20.040
Okay, so now I have a good theory that
-- and I'll be able to -- because

00:29:20.040 --> 00:29:22.350
I've got this profiling in place,
I'll know when I fixed it.

00:29:22.360 --> 00:29:22.360
When those times get down much smaller,
it's going to look good.

00:29:22.360 --> 00:29:22.360
I still don't really know
why this is happening,

00:29:22.360 --> 00:29:22.360
so I'm going to set a breakpoint
in draw rect and just see if

00:29:22.360 --> 00:29:22.380
there's anything obvious that's
-- that's going to be there.

00:29:34.330 --> 00:29:34.330
Okay, so now I have a good theory that
-- I'll be able to -- because

00:29:34.330 --> 00:29:34.330
I've got this profiling in place,
I'll know when I fixed it.

00:29:34.330 --> 00:29:34.330
When those times get down much smaller,
it's going to look good.

00:29:34.330 --> 00:29:34.330
I still don't really know
why this is happening,

00:29:34.330 --> 00:29:34.330
so I'm going to set a breakpoint
in draw rect and just see if

00:29:34.330 --> 00:29:34.330
there's anything obvious that's
-- that's going wrong here.

00:29:34.540 --> 00:29:40.840
So I set my breakpoint in DrawRect,
and I don't really need it yet.

00:29:40.840 --> 00:29:42.880
Draw a little bit.

00:29:42.890 --> 00:29:44.830
Set my breakpoint.

00:29:45.880 --> 00:29:47.690
and see if there's
anything obviously wrong.

00:29:47.700 --> 00:29:52.200
And one thing jumps out to me right away,
and that is that the rect

00:29:52.350 --> 00:29:55.720
that's being passed in here
is the size of my entire view.

00:29:56.020 --> 00:29:58.540
Now, remember that we have
a scale factor of 2,

00:29:58.630 --> 00:30:02.560
so the entire screen
size is only 768 by 1024.

00:30:02.710 --> 00:30:07.260
So we're redrawing the entire
rect here on every draw rect.

00:30:07.400 --> 00:30:08.790
So that's bad.

00:30:08.980 --> 00:30:13.300
So I know that someone must be
calling set needs display on me,

00:30:13.430 --> 00:30:15.750
so I'll just do a quick search.

00:30:16.660 --> 00:30:18.900
Okay, I'm calling set needs
display in my erase method.

00:30:18.900 --> 00:30:21.520
That seems like it's probably right.

00:30:21.520 --> 00:30:24.750
And I'm calling set needs display
in my touches moved method.

00:30:24.780 --> 00:30:27.470
So that's causing me to mark
the entire rectangle as dirty

00:30:27.470 --> 00:30:29.100
and redraw it from scratch.

00:30:29.210 --> 00:30:31.520
Now, I've already done the work here
to calculate the dirty rect.

00:30:31.520 --> 00:30:32.270
It's very simple.

00:30:32.320 --> 00:30:37.760
It's just the previous point to
the current point is my dirty rect.

00:30:37.760 --> 00:30:43.790
So let's change this to set needs
display in rect dirty and try it again.

00:30:49.100 --> 00:30:54.150
And that is a whole lot better.

00:30:54.150 --> 00:30:55.860
That is a whole lot better.

00:30:55.940 --> 00:30:58.390
And I'll ask you to take my
word for it that it is actually

00:30:58.400 --> 00:30:59.880
behaving much more responsively.

00:31:00.120 --> 00:31:01.810
But it's still not great.

00:31:01.950 --> 00:31:03.660
You notice that after a
little bit of drawing,

00:31:03.660 --> 00:31:07.290
I'm still getting up to 19,
20 milliseconds here,

00:31:07.290 --> 00:31:09.050
and that's still too much.

00:31:09.060 --> 00:31:11.830
So my next strategy is
I look at my draw rect,

00:31:11.830 --> 00:31:15.830
and I notice that I'm redrawing all the
previous paths that the user already

00:31:15.840 --> 00:31:19.040
drew in addition to the one that they're
currently in the process of drawing.

00:31:19.040 --> 00:31:20.150
That seems wasteful.

00:31:20.200 --> 00:31:22.760
It seems like the ones that
have already happened and are

00:31:22.760 --> 00:31:24.020
not going to change again.

00:31:24.020 --> 00:31:26.160
I shouldn't need to
redraw those every time.

00:31:26.230 --> 00:31:29.170
So that's where you have to think
a little creatively and decide what

00:31:29.280 --> 00:31:31.760
is it that I could do about that.

00:31:31.760 --> 00:31:34.490
And what I decided to do was...

00:31:34.640 --> 00:31:38.890
In my view controller,
I created a background view in

00:31:38.890 --> 00:31:43.210
addition to the paint view that
I can put in anything that I want.

00:31:43.250 --> 00:31:45.570
And it's actually a
UI image view at the moment.

00:31:45.590 --> 00:31:48.650
So, what I'm going to do,
when I get the delegate callback from my

00:31:48.650 --> 00:31:52.970
paint view saying that the user lifted up
and finished drawing a particular path,

00:31:52.970 --> 00:31:56.230
I'm going to merge the paint
view into that background view

00:31:56.230 --> 00:31:57.750
so I don't have to draw it again.

00:31:57.750 --> 00:31:59.160
And there's no magic to this.

00:31:59.160 --> 00:32:02.210
All I'm going to do is create
a new graphics context.

00:32:02.210 --> 00:32:05.190
I'm going to draw the
current background view here.

00:32:05.190 --> 00:32:06.910
So,
what's already in the background view,

00:32:06.960 --> 00:32:09.560
I'm going to draw that into
the current background -- into

00:32:09.570 --> 00:32:11.410
the current graphics context.

00:32:11.410 --> 00:32:14.500
Then I'm going to draw
the current paint view,

00:32:14.500 --> 00:32:16.580
render that into the
current graphics context,

00:32:16.730 --> 00:32:17.800
and erase the paint view.

00:32:17.860 --> 00:32:21.110
So, now all the paths that are
rendered into my background view,

00:32:21.110 --> 00:32:24.210
we're not going to redraw
in the paint view anymore.

00:32:24.270 --> 00:32:29.220
And then get the current -- get the
image from the current graphics context,

00:32:29.220 --> 00:32:29.220
set that as the background view.

00:32:29.220 --> 00:32:29.220
And then I'm going to draw
the current paint view,

00:32:29.220 --> 00:32:29.220
render that into the
current graphics context,

00:32:29.220 --> 00:32:29.220
and erase the paint view.

00:32:29.220 --> 00:32:29.220
So, now all the paths that are
rendered into my background view,

00:32:29.220 --> 00:32:29.220
we're not going to redraw
in the paint view anymore.

00:32:29.220 --> 00:32:29.220
And then get the current -- get the
image from the current graphics context,

00:32:29.220 --> 00:32:30.220
set that as the current graphics context,
set that as the new background view.

00:32:30.220 --> 00:32:32.230
So, essentially,
I've taken the existing paths

00:32:32.230 --> 00:32:35.720
from my paint view and flattened
them into a background view,

00:32:35.720 --> 00:32:38.920
so we only have to draw the
new paths on every draw rect.

00:32:39.120 --> 00:32:42.620
So, I've already implemented that code.

00:32:42.620 --> 00:32:45.180
All I have to do is turn it on.

00:32:45.180 --> 00:32:45.190
And then I'm going

00:32:50.350 --> 00:32:56.460
And let's see if our
draw recs are any better.

00:32:56.620 --> 00:32:58.220
So, it's not perfect.

00:32:58.370 --> 00:33:01.310
There's still some things I could do,
but in two very simple steps,

00:33:01.410 --> 00:33:04.760
I actually went from several
hundred milliseconds per draw rec,

00:33:04.760 --> 00:33:06.600
sometimes over a second,
to I'm very rarely over

00:33:06.600 --> 00:33:08.040
10 milliseconds here.

00:33:08.240 --> 00:33:12.840
That might actually be good
enough to stay responsive.

00:33:12.990 --> 00:33:15.830
Oh, yay.

00:33:17.980 --> 00:33:19.690
Okay,
so we talked about responsive animations.

00:33:19.770 --> 00:33:22.300
Now let's take a look at
making animations smooth.

00:33:22.430 --> 00:33:24.800
Now, animation smooth, as I said,
means it doesn't stutter,

00:33:24.800 --> 00:33:26.300
it doesn't drop any frames.

00:33:26.440 --> 00:33:29.800
So what does it take for your
animation to be smooth on iOS?

00:33:29.890 --> 00:33:31.890
This is very, very simple.

00:33:32.020 --> 00:33:33.960
60 frames per second.

00:33:34.170 --> 00:33:37.970
Not 24 frames per second, not 30,
not even 55.

00:33:38.220 --> 00:33:41.400
And it occurred to me the other day
working with a developer in a lab,

00:33:41.400 --> 00:33:45.650
the way to think about this is,
"So why is 55 so much worse than

00:33:45.680 --> 00:33:49.600
60?" 55 frames per second means
that in a one-second animation,

00:33:49.600 --> 00:33:51.600
you dropped five frames.

00:33:51.670 --> 00:33:53.890
And the user will definitely see that.

00:33:53.970 --> 00:33:57.590
So you need to aim for 60 frames per
second if you can possibly reach it.

00:33:57.700 --> 00:34:00.200
Anything less than that is
going to be noticeably worse,

00:34:00.200 --> 00:34:02.790
even if it's 58, 59.

00:34:02.980 --> 00:34:06.600
Doing some very simple math,
that means we have 16 milliseconds,

00:34:06.600 --> 00:34:10.550
or 16 two-thirds milliseconds,
per frame to do all the work we need to

00:34:10.590 --> 00:34:12.800
do to put that frame onto the screen.

00:34:14.750 --> 00:34:17.540
Okay, so going back to our three
stages of the animation,

00:34:17.570 --> 00:34:18.860
we're done with the first two stages.

00:34:18.860 --> 00:34:20.800
That was in responsiveness,
and now we worry about

00:34:20.840 --> 00:34:22.160
rendering each frame.

00:34:22.290 --> 00:34:25.940
Now, I said before, rendering each frame,
that happens outside your application,

00:34:25.940 --> 00:34:29.490
in the render server and on the GPU,
but there's still a lot you can do

00:34:29.490 --> 00:34:32.820
in your application to make this
work as easy as possible for the

00:34:32.820 --> 00:34:34.980
render server to complete in time.

00:34:35.200 --> 00:34:37.800
So the first thing you need to
do when you have a smoothness

00:34:37.970 --> 00:34:42.260
problem is determine whether your
problem is CPU bound or GPU bound.

00:34:42.430 --> 00:34:45.170
Now remember we talked
before that CG drawing and

00:34:45.180 --> 00:34:48.600
image IO for image decoding,
those things are CPU bound,

00:34:48.750 --> 00:34:50.900
but usually those things
have already happened by the

00:34:50.900 --> 00:34:52.220
time the animation starts.

00:34:52.260 --> 00:34:55.140
Now scrolling, which I'll get to soon,
is an exception to that,

00:34:55.280 --> 00:34:57.260
but usually that's already done.

00:34:57.400 --> 00:35:00.980
But work in the render server to
actually determine where each layer

00:35:00.980 --> 00:35:04.510
needs to be in the next frame,
that takes CPU that's a

00:35:04.510 --> 00:35:06.740
cost per layer every frame.

00:35:06.800 --> 00:35:09.580
So the more layers you shipped
off to the render server,

00:35:09.580 --> 00:35:11.670
the more CPU work it's going
to have to do every frame.

00:35:11.800 --> 00:35:14.370
Now the rendering itself,
where we actually composite those layers

00:35:14.370 --> 00:35:18.760
together and produce the final display,
that's usually GPU bound.

00:35:18.800 --> 00:35:21.330
So the way you figure out
which your application is is

00:35:21.330 --> 00:35:22.800
by using instruments again.

00:35:22.850 --> 00:35:24.800
And I'll be showing this
in a demo in a moment,

00:35:24.800 --> 00:35:28.720
but the first thing you usually want
to do is use the OpenGL ES instrument.

00:35:28.800 --> 00:35:31.760
You go to the Configure FlipView,
which I'll take you through,

00:35:31.890 --> 00:35:32.800
and there's a little bit of a demo here.

00:35:32.800 --> 00:35:35.800
So you can see that it's a device
utilization percentage checkbox.

00:35:35.800 --> 00:35:38.680
When you enable that,
it will actually tell you how busy

00:35:38.770 --> 00:35:40.890
the GPU is during your animation.

00:35:41.000 --> 00:39:41.100
[Transcript missing]

00:39:41.420 --> 00:39:44.220
Another core animation instrument
that is sometimes helpful,

00:39:44.220 --> 00:39:46.900
another checkbox there,
is off-screen rendering.

00:39:46.900 --> 00:39:49.900
And this one I'm going to show you here
because I'm not going to be demoing it.

00:39:50.010 --> 00:39:52.590
In the list of checkboxes
there on the bottom left,

00:39:52.590 --> 00:39:55.040
there's one that's color
off-screen rendered yellow.

00:39:55.190 --> 00:39:58.180
This shows you its colors on the
screen every time we had to go off

00:39:58.270 --> 00:40:01.790
into one of those separate off-screen
contexts to create some effect.

00:40:01.870 --> 00:40:04.870
Now, this is most often needed either
because you use set should rasterize,

00:40:04.880 --> 00:40:07.130
and we had to go off-screen for that,
or if you have any kind

00:40:07.140 --> 00:40:08.200
of masking going on.

00:40:08.330 --> 00:40:12.180
So if you either used a mask layer or if,
as very commonly,

00:40:12.200 --> 00:40:16.700
you use the corner radius
property of your CA layer,

00:40:16.700 --> 00:40:19.700
in order to get that corner
radius properly right,

00:40:19.700 --> 00:40:21.700
we actually have to go
off-screen to do the masking,

00:40:21.700 --> 00:40:24.200
and that requires a context switch.

00:40:24.200 --> 00:40:28.670
It also requires some extra
compositing by the GPU.

00:40:28.930 --> 00:40:30.700
And so that can slow you down.

00:40:30.760 --> 00:40:34.120
But once again,
there's usually ways to avoid this,

00:40:34.310 --> 00:40:36.180
but don't go out of your way to
avoid it until you've determined

00:40:36.230 --> 00:40:37.700
that you're actually GPU bound.

00:40:37.700 --> 00:40:38.830
Thank you.

00:40:39.710 --> 00:40:43.140
Okay, the last type of animation I want
to talk about is scrolling,

00:40:43.140 --> 00:40:45.940
which is particularly difficult
because it works very differently

00:40:45.940 --> 00:40:47.200
from other animations.

00:40:47.200 --> 00:40:49.990
So for most animations,
if you have a half-second animation,

00:40:50.000 --> 00:40:52.600
so it's going to be 30 frames,
you kick it off at the beginning,

00:40:52.600 --> 00:40:55.110
you do all the work ahead of time,
and then it simply renders

00:40:55.180 --> 00:40:58.300
each of those 30 frames,
and your application's work is done.

00:40:58.440 --> 00:41:00.150
But for scrolling,
we don't work like that.

00:41:00.300 --> 00:41:02.600
For scrolling,
we actually do a separate animation

00:41:02.600 --> 00:41:04.700
for every single scroll update.

00:41:04.840 --> 00:41:08.230
So in one 16-millisecond window,
we have to calculate

00:41:08.230 --> 00:41:11.200
the new scroll position,
prepare and commit the animation,

00:41:11.200 --> 00:41:14.190
so all the stuff that I talked
about in responsiveness,

00:41:14.250 --> 00:41:15.880
and render the frame,
so all the stuff I talked

00:41:15.880 --> 00:41:19.800
about in smoothness,
all has to happen in 16 milliseconds.

00:41:19.800 --> 00:41:22.500
And that's a pretty tall order.

00:41:22.540 --> 00:41:26.430
In particular, for table view scrolling,
the table view cells that

00:41:26.430 --> 00:41:28.590
are already on screen,
of course, we're not going to

00:41:28.590 --> 00:41:29.590
redraw those every time.

00:41:29.600 --> 00:41:32.000
We're only going to redraw
them the first time.

00:41:32.050 --> 00:41:34.600
But the first time a new table
view cell appears on screen,

00:41:34.600 --> 00:41:38.100
we have to lay out and draw
that table cell from scratch,

00:41:38.100 --> 00:41:40.290
and we've only got 16
milliseconds to do that,

00:41:40.580 --> 00:41:43.900
and that's assuming that the user
is scrolling relatively slowly.

00:41:43.900 --> 00:41:46.790
If they're scrolling quickly,
two table cells or three

00:41:46.790 --> 00:41:50.000
or the entire screen might
appear all in the same frame.

00:41:50.000 --> 00:41:52.320
So your goal for this is not
to get the layout and drawing

00:41:52.320 --> 00:41:53.790
down to 16 milliseconds.

00:41:54.030 --> 00:41:57.130
Your goal is to get it down
just as low as you possibly can,

00:41:57.240 --> 00:42:00.600
so that you'll maintain a
smooth scrolling experience,

00:42:00.840 --> 00:42:04.500
even if the user scrolls very,
very quickly.

00:42:04.810 --> 00:42:07.470
So the strategies for scrolling are
some of the same strategies we talked

00:42:07.540 --> 00:42:09.400
about in responsiveness and smoothness.

00:42:09.530 --> 00:42:12.530
Reuse your cells and views
always whenever you can.

00:42:12.790 --> 00:42:15.400
Minimize your layout and drawing
time using the same strategies we

00:42:15.400 --> 00:42:17.000
talked about in responsiveness.

00:42:17.120 --> 00:42:18.550
Consider doing speculative work.

00:42:18.780 --> 00:42:22.030
So when row 47 comes up on screen,
should you be kicking off a

00:42:22.100 --> 00:42:25.750
background thread to get rows 48,
49, 50 ready?

00:42:25.850 --> 00:42:29.010
That's something you'll have to decide
depending on your own circumstances.

00:42:29.150 --> 00:42:32.440
And look at flattening your view
hierarchy if you're GPU bound.

00:42:32.440 --> 00:42:36.090
But this, more than any other,
is a test and iterate case.

00:42:36.290 --> 00:42:38.710
If you start out GPU bound
and you flatten a little bit,

00:42:38.800 --> 00:42:40.550
you might get to where
you're not GPU bound anymore.

00:42:40.710 --> 00:42:41.380
Great.

00:42:41.510 --> 00:42:44.530
If you flatten a little bit more,
you might become CPU bound from

00:42:44.530 --> 00:42:46.130
doing all those draw racks.

00:42:46.210 --> 00:42:49.900
So sometimes you want to reduce, say,
from 100 layers down to 50,

00:42:49.900 --> 00:42:53.380
but if you go less than 50,
it's going to actually make it worse.

00:42:53.380 --> 00:42:57.580
So you need to find what the right
place for your particular scenario is.

00:42:57.630 --> 00:42:58.410
Okay.

00:42:58.600 --> 00:43:02.280
And that brings us to our second demo,
which is the WWF.

00:43:02.280 --> 00:43:04.080
And that's the WWC app.

00:43:04.080 --> 00:43:06.880
If you saw the responsiveness talk,
you saw a performance problem

00:43:06.880 --> 00:43:09.980
fixed -- one particular performance
problem in the WWC app fixed.

00:43:09.980 --> 00:43:11.280
Now we're going to look at another one.

00:43:13.500 --> 00:43:14.480
We didn't have mirroring
on the original iPad.

00:43:14.500 --> 00:43:15.940
Okay.

00:43:15.940 --> 00:43:19.300
So when I scroll on an original
iPad in the schedule view,

00:43:19.440 --> 00:43:21.100
it's pretty choppy.

00:43:21.240 --> 00:43:24.840
It's not terrible, and you can't see just
how bad it is up there,

00:43:24.840 --> 00:43:27.740
unfortunately, but it is not great.

00:43:27.740 --> 00:43:30.500
We're clearly not getting
60 frames per second.

00:43:30.660 --> 00:43:35.000
So I'm going to start this investigation,
again, by profiling,

00:43:35.000 --> 00:43:39.000
but this time I'm going to use
the Core Animation Instrument

00:43:39.000 --> 00:43:44.000
to get a baseline for what my
scrolling performance is right now.

00:43:44.000 --> 00:43:46.500
So I'm going to pull up in the graphics.

00:43:46.500 --> 00:43:49.040
I'm going to use the
Core Animation Instrument.

00:43:49.440 --> 00:43:52.510
I'm going to scroll and watch my
core animation frames per second.

00:43:52.510 --> 00:43:54.650
And for this,
remember that you want to keep

00:43:54.740 --> 00:43:57.610
it moving continuously because
the screen's not going to update

00:43:57.610 --> 00:43:59.000
unless it actually needs to.

00:43:59.080 --> 00:44:01.380
So as I scroll around here,
I see that I'm getting in the

00:44:01.380 --> 00:44:05.710
mid-30s for my frames per second,
which is not very good.

00:44:06.190 --> 00:44:09.520
So I'm going to then try,
since I've already got the

00:44:09.520 --> 00:44:12.620
core animation instrument open,
I'm going to switch over so

00:44:12.630 --> 00:44:13.520
you can see what I'm doing.

00:44:13.520 --> 00:44:18.660
I'm going to check the color
blended layers checkbox.

00:44:18.920 --> 00:44:21.240
So this is going to,
as I showed you before,

00:44:21.370 --> 00:44:25.300
it's going to color the opaque parts
green and the blended parts red.

00:44:26.350 --> 00:44:29.130
And when it comes up here,
I immediately see there's quite

00:44:29.130 --> 00:44:30.620
a lot of blending in this view.

00:44:30.720 --> 00:44:33.110
The top and bottom are
almost completely blended,

00:44:33.110 --> 00:44:36.210
some of it's very deeply blended,
and I've got a lot of blending in

00:44:36.210 --> 00:44:37.980
the actual grid cells themselves.

00:44:37.980 --> 00:44:39.710
And so,
and this is actually the debugging

00:44:40.240 --> 00:44:42.300
process we went through here,
I think, okay,

00:44:42.300 --> 00:44:45.240
I've got too much blending,
I'm going to try to reduce that.

00:44:45.240 --> 00:44:47.950
And the easiest way to do that,
if I go to my grid view where

00:44:47.950 --> 00:44:51.050
I'm actually creating the thing,
here I'm creating the labels,

00:44:51.160 --> 00:44:53.320
adding them as subviews,
I've also got a couple

00:44:53.320 --> 00:44:55.050
of images in there.

00:44:55.800 --> 00:44:57.700
I'm going to try just to see if it helps.

00:44:57.810 --> 00:45:03.750
I'm going to do self layer
should rasterize equals yes.

00:45:15.670 --> 00:45:15.670
So that's going to set should rasterize,
as I talked about before.

00:45:15.670 --> 00:45:15.670
And so I'm going to run that.

00:45:15.670 --> 00:45:15.670
Actually, I'm going to profile that.

00:45:15.670 --> 00:45:15.670
I'll do that from over there.

00:45:15.670 --> 00:45:15.670
Okay.

00:45:15.670 --> 00:45:15.670
So I'm going to run that.

00:45:16.500 --> 00:45:29.800
[Transcript missing]

00:45:30.740 --> 00:45:31.690
I see this.

00:45:31.700 --> 00:45:35.860
So my grid cells that are
already on the screen are green.

00:45:35.860 --> 00:45:40.290
When new ones come on screen,
they're red, which is expected,

00:45:40.290 --> 00:45:43.460
because I have to cache at one time.

00:45:43.460 --> 00:45:46.100
And then they're green after that.

00:45:46.100 --> 00:45:48.340
So my cache is working.

00:45:48.340 --> 00:45:49.060
But if I --

00:45:50.370 --> 00:45:53.490
Uncheck that, attach to all processes,
and record again to see

00:45:53.620 --> 00:45:55.480
what my frame rate is.

00:45:58.330 --> 00:46:04.440
My frame rate is not actually any
better as I'm scrolling around.

00:46:04.510 --> 00:46:06.400
Eh, maybe a little bit better,
which is unexpected.

00:46:06.570 --> 00:46:08.470
But for the most part...

00:46:09.880 --> 00:46:12.940
The most part, if I scroll very quickly,
this has not actually helped,

00:46:12.940 --> 00:46:14.940
which makes me wonder,
my cache is working.

00:46:14.990 --> 00:46:18.050
Why am I still only getting in
the 30s for my frames per second?

00:46:18.050 --> 00:46:22.310
Well, the answer is that I didn't do what
I said I should do and start by looking

00:46:22.310 --> 00:46:24.620
at the device utilization percentage.

00:46:24.620 --> 00:46:28.020
I'm running low on time,
so I'm not going to actually do that,

00:46:28.020 --> 00:46:31.120
but the device utilization percentage,
if I run this,

00:46:31.120 --> 00:46:34.880
tells me I'm actually only in
the 20s for my utilization.

00:46:34.880 --> 00:46:38.080
So that makes me wonder, okay,
if I'm not GPU bound,

00:46:38.080 --> 00:46:39.780
what actually happens?

00:46:39.800 --> 00:46:40.790
And that's actually my problem.

00:46:40.880 --> 00:46:43.100
Fortunately, when you run the core
animation instrument,

00:46:43.160 --> 00:46:45.660
you also get the time profiler
instrument along with it.

00:46:45.810 --> 00:46:49.770
So I'm going to bring that up,
and we see something very surprising.

00:46:49.910 --> 00:46:53.870
Most of my CPU time is not in
my application as I'm scrolling.

00:46:53.870 --> 00:46:57.050
Most of the CPU time is in Springboard,
which is the process where

00:46:57.060 --> 00:46:58.460
the render server lives.

00:46:58.480 --> 00:47:04.900
That gives me a new theory
that I have too many layers.

00:47:04.900 --> 00:47:04.900
So I'm

00:47:05.090 --> 00:47:10.930
by going to a place where I know
that all my layers are going to be in

00:47:10.940 --> 00:47:15.820
place and using a little trick that
a lot of developers don't know about.

00:47:15.820 --> 00:47:18.620
So I'm going to my view
controller's scroll view did

00:47:18.640 --> 00:47:22.880
scroll method where I know that
all the layers are actually there.

00:47:22.880 --> 00:47:27.330
And I'm going to set a break point there.

00:47:43.590 --> 00:47:43.590
And then I'm going to scroll.

00:47:43.590 --> 00:47:43.590
So I break.

00:47:43.590 --> 00:47:43.590
And I'm going to use a special
method called recursive description.

00:47:43.590 --> 00:47:43.590
Let's clear the contents here
because this is a lot of data.

00:47:43.590 --> 00:47:43.590
So I'm going to print out

00:47:45.960 --> 00:47:51.680
I'm going to print out
self.view recursive description.

00:47:51.680 --> 00:47:54.120
And this is actually going to
recursively go through all the

00:47:54.120 --> 00:47:56.900
views and show all the subviews.

00:47:57.030 --> 00:47:59.840
And I get an absolute mountain of text.

00:47:59.900 --> 00:48:02.300
If I put that into a text
editor where I get line numbers,

00:48:02.460 --> 00:48:04.880
there are about 700
layers in this display,

00:48:04.910 --> 00:48:05.740
which is a lot.

00:48:05.740 --> 00:48:09.080
So that tells me, yes,
I probably have too many layers.

00:48:09.700 --> 00:48:12.850
What I do then to test this theory
and make sure that the number

00:48:12.850 --> 00:48:16.230
of layers is actually a problem,
I'm going to do something very,

00:48:16.230 --> 00:48:17.490
very strange here.

00:48:19.240 --> 00:48:20.860
I'm going to remove the
set should rasterize,

00:48:20.860 --> 00:48:22.480
which I know didn't help.

00:48:22.540 --> 00:48:25.820
I'm still going to do all the work to
create those subviews because I don't

00:48:25.820 --> 00:48:28.140
want to disturb this more than I have to.

00:48:28.250 --> 00:48:32.700
But I'm simply going to go and
remove all the add subviews.

00:48:33.830 --> 00:48:36.820
So I'm still going to do all
the work to create these things.

00:48:36.890 --> 00:48:39.900
I'm not reducing the amount of
drawing because I don't draw

00:48:39.920 --> 00:48:41.940
them every single time anyway.

00:48:42.240 --> 00:48:47.560
I'm just going to display the background,
make sure that I still get --

00:48:47.560 --> 00:48:51.920
I get 60 fips in this scenario,
and then I'll know that the number

00:48:51.920 --> 00:48:55.550
of layers was actually the problem.

00:48:56.590 --> 00:48:58.500
So basically the process
that I went through here is

00:48:58.500 --> 00:49:02.180
I removed all the subviews,
I verified that in fact I get 60

00:49:02.180 --> 00:49:04.900
fips without the views being there,
the subviews being there.

00:49:05.050 --> 00:49:08.920
And then I decided, well,
let's test out what happens if I actually

00:49:08.920 --> 00:49:11.260
draw these instead of using subviews.

00:49:11.400 --> 00:49:14.560
So I implemented a draw rect
that is not shippable code,

00:49:14.650 --> 00:49:17.770
and that's okay at this
stage of prototyping it,

00:49:17.800 --> 00:49:21.390
where I simply take those subtitles and,
you know, the title, the subtitle,

00:49:21.680 --> 00:49:23.860
all those subviews that I created.

00:49:23.920 --> 00:49:26.600
I have them draw themselves
in my draw rect instead of

00:49:26.600 --> 00:49:28.300
setting them up as subviews.

00:49:28.420 --> 00:49:31.200
So now the same drawing
is going to occur,

00:49:31.310 --> 00:49:34.460
but the render server doesn't
have to process so many layers.

00:49:34.550 --> 00:49:39.960
And when I did this and ran it
in the OpenGL instrument again,

00:49:40.040 --> 00:49:42.960
now I get 60 fips and my
content actually looks right.

00:49:43.080 --> 00:49:45.690
Now I'm creating a lot of views
that I'm not actually using.

00:49:45.930 --> 00:49:49.280
I'm also calling drawTextInRect,
which is documented but says

00:49:49.280 --> 00:49:50.890
don't call this directly.

00:49:51.010 --> 00:49:52.620
So I'm not going to ship this code.

00:49:52.620 --> 00:49:54.820
But for a prototype,
this works perfectly well and

00:49:54.820 --> 00:49:58.190
demonstrates that the number of
layers actually was the problem.

00:49:59.060 --> 00:50:01.400
So, a couple of final thoughts.

00:50:01.560 --> 00:50:03.530
Test animations on a
wide range of devices.

00:50:03.600 --> 00:50:05.390
It's not just a matter
of raw performance.

00:50:05.400 --> 00:50:09.400
It's a matter of the particular
capabilities of the device in question.

00:50:09.400 --> 00:50:11.390
Some devices are more
likely to be CPU-bound,

00:50:11.470 --> 00:50:12.840
some GPU-bound.

00:50:13.000 --> 00:50:15.400
Different scenarios call
for different solutions.

00:50:15.400 --> 00:50:17.400
Measure, test, and iterate.

00:50:17.400 --> 00:50:19.820
Okay, for more information,
talk to Michael Jurowicz,

00:50:19.900 --> 00:50:22.900
the evangelist for performance.

00:50:23.250 --> 00:50:24.900
Visit the developer forums.

00:50:25.020 --> 00:50:27.900
We talked about animations,
responsive animations, smooth animations,

00:50:27.900 --> 00:50:28.900
and I think I'm over time.

00:50:28.900 --> 00:50:31.790
So thank you very much.
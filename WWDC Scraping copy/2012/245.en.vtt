WEBVTT

00:00:10.060 --> 00:00:14.340
My name is Patrick Heynen and I'm here to
talk to you about high resolution again,

00:00:14.410 --> 00:00:16.390
but this time in a new
and more trickier fashion.

00:00:16.400 --> 00:00:19.710
So what are we really,
what's the purpose of this talk?

00:00:19.940 --> 00:00:21.430
Well,
any of you who have been involved in

00:00:21.440 --> 00:00:26.890
writing real products know that 80%
of the tasks are easy and it's that

00:00:26.890 --> 00:00:32.440
last 10 to 15% that's where a lot of
the important stuff happens to make

00:00:32.440 --> 00:00:33.880
your product actually go out the door.

00:00:33.880 --> 00:00:37.390
So what we're going to do in this session
is try to go deeper into high resolution,

00:00:37.390 --> 00:00:39.550
pull back the covers a bit,
talk a little bit about

00:00:39.550 --> 00:00:43.970
how some of that works,
and how to take full advantage of all the

00:00:43.970 --> 00:00:46.840
new APIs to achieve full pixel precision.

00:00:46.930 --> 00:00:50.590
So that you can both work around any sort
of subtle bugs you might have and achieve

00:00:50.650 --> 00:00:52.680
the highest quality you possibly can.

00:00:52.740 --> 00:00:55.040
Also leveraging advanced
technologies under high

00:00:55.040 --> 00:00:58.750
resolution if you're using those,
things like Core Automation and OpenGL.

00:00:58.820 --> 00:01:01.760
And just how to get the best visual
quality and performance for your

00:01:01.760 --> 00:01:05.650
application on these wonderful,
new machines that you may have

00:01:05.660 --> 00:01:09.230
hopefully had a chance to look
at and play with this week.

00:01:09.350 --> 00:01:09.660
All right.

00:01:09.820 --> 00:01:14.400
So what are we hoping that you
will learn in this session?

00:01:14.550 --> 00:01:17.280
How to work with OpenGL contexts.

00:01:17.280 --> 00:01:20.750
We're going to cover some very
specific things about OpenGL contexts

00:01:21.010 --> 00:01:25.450
that apply to usage in AppKit and
high resolution displays.

00:01:26.690 --> 00:01:28.960
Also,
if your application takes advantage of

00:01:28.960 --> 00:01:32.830
Core Animation directly and you have
custom Core Animation layer trees,

00:01:32.940 --> 00:01:37.610
there are some unique considerations
that we're going to tell you

00:01:37.740 --> 00:01:40.170
about how to handle them properly.

00:01:40.480 --> 00:01:43.850
Also, drawing into off-screen bitmaps,
you know, it's not all about on-screen

00:01:43.850 --> 00:01:44.950
into window drawings.

00:01:44.960 --> 00:01:47.450
All the things that we made easy,
you know, artwork and all the Quartz,

00:01:47.530 --> 00:01:49.000
you know, resolution independent drawing,
well,

00:01:49.000 --> 00:01:51.560
sometimes you have to do stuff yourself,
right?

00:01:51.560 --> 00:01:53.500
You have to draw into pixel,
into bitmaps yourself.

00:01:53.610 --> 00:01:56.870
We're going to cover some of the things
you need to be aware of for that.

00:01:56.970 --> 00:01:59.870
And most importantly, once again,
I want to remind you the thing that

00:01:59.870 --> 00:02:03.110
makes high resolution different on the
Mac and the Mac different in general

00:02:03.230 --> 00:02:07.720
from iOS Retina is that we have a
much more dynamic display environment.

00:02:07.770 --> 00:02:11.800
And you can have multiple displays
and you can have any one display

00:02:11.800 --> 00:02:15.320
going between low resolution
and high resolution at any time,

00:02:15.320 --> 00:02:16.260
given the way the Mac works.

00:02:16.380 --> 00:02:18.440
It's a much more dynamic
kind of environment.

00:02:18.500 --> 00:02:20.530
That's a strength,
but it's also a situation

00:02:20.610 --> 00:02:23.160
that your software needs to
really take into account.

00:02:23.170 --> 00:02:25.540
and handle appropriately.

00:02:25.750 --> 00:02:27.990
Then we're going to go into sort
of an interesting deep dive,

00:02:27.990 --> 00:02:29.820
but an important one,
because text is really the

00:02:29.820 --> 00:02:31.030
primary feature of Retina.

00:02:31.030 --> 00:02:33.170
If you've had a chance to
look at these displays,

00:02:33.250 --> 00:02:34.630
it's all about the text.

00:02:34.730 --> 00:02:37.510
You just look at that and you're like,
wow, this is almost like looking

00:02:37.510 --> 00:02:38.450
at a laser printout.

00:02:38.480 --> 00:02:41.930
Well, but there are some implications
for some of the text and font

00:02:41.930 --> 00:02:44.280
technologies that we have in our system.

00:02:44.280 --> 00:02:47.780
And for those of you who spend a lot
of time with text in your applications,

00:02:47.850 --> 00:02:49.620
you may want to be aware of these.

00:02:51.080 --> 00:02:53.480
Also, just some final,
some best practices throughout

00:02:53.480 --> 00:02:56.080
all these different sections
about how to achieve quality and

00:02:56.080 --> 00:02:57.810
performance under high resolution.

00:02:57.820 --> 00:03:00.140
So we've got a lot of material here.

00:03:00.140 --> 00:03:01.540
Hope you had your coffee.

00:03:01.540 --> 00:03:04.610
As a brief backgrounder,
before we dive into the

00:03:04.610 --> 00:03:07.900
individual sections,
I just want to go over what the

00:03:07.900 --> 00:03:11.570
technology we're talking about is,
if you haven't been to

00:03:11.570 --> 00:03:13.340
the introduction talk.

00:03:13.400 --> 00:03:17.460
We have new high resolution
display modes for Retina displays.

00:03:17.520 --> 00:03:20.540
And the consequence of
this is that screen.

00:03:21.080 --> 00:03:26.170
Screens and windows each have a two
to one pixel per point density ratio.

00:03:27.660 --> 00:03:31.160
And the frameworks are providing
automatic scaling to your applications

00:03:31.160 --> 00:03:35.400
to ensure consistent coordinate
system between 1X and 2X operation.

00:03:35.400 --> 00:03:38.600
It means your software sees the
same thing going on for screen,

00:03:38.670 --> 00:03:40.950
view,
and window coordinate systems across both

00:03:41.070 --> 00:03:44.200
standard resolution and high resolution,
which is great for compatibility,

00:03:44.260 --> 00:03:46.000
but it doesn't mean you're
abstracted from the pixels.

00:03:46.000 --> 00:03:47.630
So sometimes you need to
know about the pixels,

00:03:47.630 --> 00:03:48.980
and that's what this talk is about.

00:03:49.030 --> 00:03:52.180
And then, of course, finally,
the Quartz Window Manager ensures

00:03:52.280 --> 00:03:54.960
consistent presentation
across multiple displays.

00:03:55.090 --> 00:03:58.840
This is what's allowing things like
window drags between a high resolution

00:03:58.840 --> 00:04:03.040
retina panel and a low resolution
external display to work seamlessly.

00:04:03.040 --> 00:04:07.020
But there are some details
which we're going to go into.

00:04:07.570 --> 00:04:11.510
Okay, speaking of details,
I'd like to bring up Mr.

00:04:11.510 --> 00:04:13.820
Chris Dreessen, who's going to tell you
all about Innis Image.

00:04:13.820 --> 00:04:15.300
Thank you, Patrick.

00:04:16.870 --> 00:04:21.240
So let's talk about NS Image.

00:04:21.240 --> 00:04:25.470
As most of you probably know NS Image can
contain multiple NS Image reps.

00:04:25.470 --> 00:04:28.800
And until now you've probably not
been taking advantage of that feature.

00:04:28.800 --> 00:04:32.660
You've most likely been using a single
bitmap representation in your artwork.

00:04:32.660 --> 00:04:35.520
So now that you have let's say
two bitmap representations,

00:04:35.520 --> 00:04:37.660
how does NS Image pick which one to draw?

00:04:37.660 --> 00:04:41.290
And the important thing to bear
in mind when you're wondering how

00:04:41.290 --> 00:04:44.260
an NS Image does this is that it
doesn't actually make a distinction

00:04:44.260 --> 00:04:45.900
between high and low resolution.

00:04:45.920 --> 00:04:47.660
It really just cares about pixels.

00:04:47.740 --> 00:04:49.970
Specifically when you draw,
it's going to try to

00:04:49.970 --> 00:04:53.850
find the representation,
the smallest bitmap representation that

00:04:53.850 --> 00:04:56.580
has as many pixels as the destination.

00:04:56.580 --> 00:04:58.280
So a picture is worth a thousand words.

00:04:58.280 --> 00:05:00.850
In high resolution it's
probably worth 4,000 words.

00:05:00.960 --> 00:05:02.800
So I don't want to show
you what I mean by that.

00:05:02.800 --> 00:05:06.980
So we've got our image here that
has a 1X ping and a 2X ping.

00:05:07.100 --> 00:05:10.690
And it's probably a little tough to
see on screen but you can definitely

00:05:10.840 --> 00:05:12.610
tell the 1X one has less detail.

00:05:12.750 --> 00:05:14.130
And physically they're the same size.

00:05:14.130 --> 00:05:14.140
But 1X is the same size.

00:05:14.140 --> 00:05:14.140
But 1X is the same size.

00:05:14.140 --> 00:05:14.140
And you can see that the
image is a little bit smaller.

00:05:14.140 --> 00:05:14.150
And you can see that the
image is a little bit smaller.

00:05:14.150 --> 00:05:14.330
And you can see that the
image is a little bit bigger.

00:05:14.330 --> 00:05:14.800
And you can see that the
image is a little bit bigger.

00:05:14.820 --> 00:05:15.200
And you can see that the
image is a little bit smaller.

00:05:15.200 --> 00:05:15.730
But the 2X one has way more pixels.

00:05:15.800 --> 00:05:18.660
And from NS Image's perspective, though,
it looks like this.

00:05:18.800 --> 00:05:21.700
We've got a 2X representation
that's much larger.

00:05:21.790 --> 00:05:24.200
So if we're drawing without
any scaling into a 1X and

00:05:24.280 --> 00:05:27.270
2X destination respectively,
it's kind of easy to figure

00:05:27.360 --> 00:05:28.540
out what's going to happen.

00:05:28.740 --> 00:05:33.020
Draw without any scaling, 1X gets 1X,
2X gets 2X.

00:05:33.400 --> 00:05:36.660
But what happens if we do
something a little unexpected?

00:05:36.780 --> 00:05:41.040
Let's say we draw to something
that's 100 pixels tall.

00:05:41.770 --> 00:05:43.050
by 150 pixels wide.

00:05:43.230 --> 00:05:44.530
What are we going to get?

00:05:44.680 --> 00:05:46.470
And it's not the 1x representation.

00:05:46.590 --> 00:05:49.570
We're actually going to
get the 2x representation.

00:05:50.330 --> 00:05:51.700
And you can see it's stretched there.

00:05:51.700 --> 00:05:54.640
And this produces a better quality
result because we're working with more

00:05:54.640 --> 00:05:56.540
pixels from the 2x representation.

00:05:56.690 --> 00:05:59.600
But there's a few places where this
might happen and you might be a bit

00:05:59.730 --> 00:06:03.040
surprised by this result instead
of pleased by the higher quality.

00:06:03.180 --> 00:06:09.250
Specifically if you're stretching images,
especially three-part images or banners.

00:06:09.360 --> 00:06:12.240
Like in this case we've got two end
caps that aren't going to be scaled

00:06:12.260 --> 00:06:15.060
and a middle piece that's going to
be stretched over the entire center.

00:06:15.190 --> 00:06:18.570
And what happens at 2x is we're going to
notice there's no scaling involved on the

00:06:18.570 --> 00:06:20.690
end caps and draw the 1x representations.

00:06:20.790 --> 00:06:23.840
In the center piece we're going to
notice we're covering a lot more

00:06:23.840 --> 00:06:25.900
pixels than the 1x representation has.

00:06:26.000 --> 00:06:29.000
And the 2x representation involves
stretching a little bit less.

00:06:29.100 --> 00:06:31.200
And that's probably not what you want,
especially if you have a clever

00:06:31.240 --> 00:06:33.360
artist that's taking advantage
of the extra pixels and isn't

00:06:33.360 --> 00:06:37.050
giving you just scaled up,
scaled down artwork.

00:06:37.160 --> 00:06:39.330
So if you're hitting this case,
we recommend instead of

00:06:39.340 --> 00:06:42.320
drawing these yourself,
you use NSDraw3partImage

00:06:42.330 --> 00:06:44.060
and NSDraw9partImage.

00:06:44.160 --> 00:06:46.480
And these are going to tile the
image instead of stretching it.

00:06:46.610 --> 00:06:48.150
So what do I mean by tiling?

00:06:48.260 --> 00:06:50.290
Well, if you take a look at these images
here with this grass texture,

00:06:50.420 --> 00:06:51.220
this is stretching.

00:06:51.220 --> 00:06:54.510
You can see the middle piece is -- well,
I hate to say the word again,

00:06:54.510 --> 00:06:55.350
but stretched.

00:06:55.440 --> 00:06:58.790
If we're tiling,
we don't actually pull it out like that.

00:06:58.870 --> 00:07:03.950
We instead go ahead and draw the image
multiple times adjacent to each other.

00:07:04.060 --> 00:07:06.560
So if your image is only, say,
one pixel wide or one pixel tall

00:07:06.560 --> 00:07:09.800
and you're stretching it like that,
you're not going to notice a difference.

00:07:09.900 --> 00:07:12.020
But tiling gives us the information
we need to know that we don't

00:07:12.020 --> 00:07:13.700
actually have to scale this thing
and choose a 2x representation.

00:07:14.110 --> 00:07:17.130
If you really don't want to tile,
like you have a gradient or

00:07:17.130 --> 00:07:21.350
something you're trying to stretch,
consider this API called

00:07:21.380 --> 00:07:22.870
setMatchesOnlyOnBestFittingAxis.

00:07:23.060 --> 00:07:26.960
It tells the NS image that if one of the
image reps fits perfectly on one axis,

00:07:27.090 --> 00:07:31.580
it's okay to use it even if the
other rep fits a little bit better

00:07:31.600 --> 00:07:34.000
on the other axis but not perfectly.

00:07:34.790 --> 00:07:37.520
So the other thing I want to mention
here is if you're drawing off screen,

00:07:37.520 --> 00:07:42.700
which is you're probably using
NSImage lock focus and unlock focus,

00:07:42.700 --> 00:07:44.540
there's a few things you
should really be aware of.

00:07:44.600 --> 00:07:48.000
The first is try not to
use NSImage lock focus.

00:07:48.050 --> 00:07:49.680
And the reason is that
your drawing is going to be

00:07:49.760 --> 00:07:51.360
flattened into a single bitmap.

00:07:51.460 --> 00:07:54.510
So all of the color space information
and resolution information of that

00:07:54.520 --> 00:07:56.540
bitmap is going to be crystallized there.

00:07:56.540 --> 00:07:59.780
You're going to throw away detail.

00:08:00.100 --> 00:08:05.560
We have a new API in 10.8 called image
with size flipped drawing handler.

00:08:05.560 --> 00:08:08.960
Drawing handler is a block there.

00:08:08.970 --> 00:08:11.840
So if you were using lock
focus and unlock focus before,

00:08:11.840 --> 00:08:14.820
all that code between those two calls
you'd now sandwich in your block.

00:08:15.060 --> 00:08:20.000
And I want to especially call out how
this behaves with regards to caching.

00:08:20.000 --> 00:08:22.480
Basically,
the first time we draw the image,

00:08:22.540 --> 00:08:25.910
we're going to invoke your drawing
block into an offscreen bitmap that's

00:08:25.910 --> 00:08:27.000
appropriate for the destination.

00:08:27.000 --> 00:08:28.910
So if we're going to a 1x window,
we're going to invoke

00:08:28.920 --> 00:08:29.990
it against a 1x bitmap.

00:08:30.000 --> 00:08:32.000
And then if that image is
drawn repeatedly there,

00:08:32.000 --> 00:08:35.000
we're going to draw from the
bitmap and not invoke your block.

00:08:35.050 --> 00:08:37.700
If that window is then, say,
moved to a 2x screen,

00:08:37.700 --> 00:08:40.340
the next time it draws,
we're going to re-invoke your

00:08:40.420 --> 00:08:44.000
block into a 2x bitmap and then
redraw that bitmap as necessary.

00:08:44.000 --> 00:08:45.420
So you have that caching behavior.

00:08:45.420 --> 00:08:48.320
You don't have to worry about losing
performance by switching to this if you

00:08:48.320 --> 00:08:50.000
had a lock focus based version before.

00:08:50.000 --> 00:08:53.770
The other thing I want to mention is if
you're trying to manage your own bitmap

00:08:53.770 --> 00:08:57.400
caches of vector artwork or other things,
you may be able to get away

00:08:57.400 --> 00:09:00.600
with just using this instead
of managing it yourself.

00:09:01.030 --> 00:09:06.710
There are some cases where you're not
going to be able to use that because,

00:09:06.710 --> 00:09:10.840
say, you're capturing transient state in
your drawing and having the block

00:09:10.840 --> 00:09:13.990
invoked repeatedly might invoke
different things and it's not worth

00:09:14.060 --> 00:09:15.670
your effort to capture that state.

00:09:15.720 --> 00:09:18.060
Or capturing the bitmap is just fine.

00:09:18.060 --> 00:09:20.780
And that works,
but you need to be aware of a few things.

00:09:20.880 --> 00:09:24.190
The first is you're going to still
want to create a multirep image.

00:09:24.190 --> 00:09:27.670
And you're going to do that by explicitly
creating an NSBitmap image rep.

00:09:27.670 --> 00:09:30.050
And this is what lock focus
is doing behind the scenes.

00:09:30.050 --> 00:09:32.660
So if you look at our snippet here,
it looks like a lot of code.

00:09:32.670 --> 00:09:34.700
It's actually just two
method invocations.

00:09:34.760 --> 00:09:37.020
But the important thing I want you
to look at are the pixels wide and

00:09:37.110 --> 00:09:40.550
pixel high arguments on line 3 and 4
here where you see we're multiplying

00:09:40.650 --> 00:09:44.460
our width and heights by whatever
scale factor we're targeting.

00:09:44.460 --> 00:09:48.250
I said we want to add
multiple bitmap image reps.

00:09:48.340 --> 00:09:51.650
So we're going to call this probably
once for 1x and once for 2x.

00:09:51.750 --> 00:09:55.680
And if you notice the very bottom
line we're calling my rep set

00:09:55.680 --> 00:09:57.960
size with the size and points.

00:09:58.150 --> 00:10:01.250
And what that's doing is we have
a virtual size and points and the

00:10:01.390 --> 00:10:06.840
physical size and pixels and that lets
us know the resolution of the image.

00:10:06.860 --> 00:10:11.260
And that's important when we
get to drawing it in a second.

00:10:11.580 --> 00:10:14.060
So the next thing you're going to do is
you're going to use NSGraphicsContext

00:10:14.060 --> 00:10:15.990
to render into this bitmap.

00:10:16.060 --> 00:10:18.900
And this is going to be a sequence
of calls where you're going to tell

00:10:19.000 --> 00:10:22.190
NSGraphicsContext to save the current
graphic state so that any existing

00:10:22.190 --> 00:10:25.190
drawing that's going on has something
to return to that makes sense.

00:10:25.280 --> 00:10:26.480
You're going to replace
the current context,

00:10:26.590 --> 00:10:28.300
and you're going to do it
using this method here.

00:10:28.370 --> 00:10:31.500
NSGraphicsContext,
GraphicsContextWithBitmapImageRep.

00:10:31.570 --> 00:10:33.700
And that takes the bitmap
image rep we just created.

00:10:33.740 --> 00:10:35.600
And I was mentioning calling
setSize explicitly to

00:10:35.630 --> 00:10:36.940
communicate that resolution.

00:10:36.940 --> 00:10:39.380
That's very important here because
this will set up the transformation

00:10:39.380 --> 00:10:42.430
matrix on the context automatically.

00:10:42.640 --> 00:10:45.400
And then in here we're just
drawing a red rectangle here.

00:10:45.440 --> 00:10:48.280
And this code doesn't have to care
whether or not we're drawing at 1X or 2X.

00:10:48.440 --> 00:10:51.650
The scaling handled by the
context does that for us.

00:10:51.740 --> 00:10:54.800
And finally, when we're done drawing,
we restore the current graphic state.

00:10:54.860 --> 00:10:57.180
And that allows us -- we're
called within a view's drawRect.

00:10:57.240 --> 00:10:58.600
The view can do other
drawing and whatnot.

00:10:58.620 --> 00:11:01.940
If we don't call that,
we're going to have problems.

00:11:02.040 --> 00:11:05.930
So the takeaway from that, though,
is really NSGraphicsContext will

00:11:05.930 --> 00:11:09.500
automatically set up the scale for you
if you've built the NSImageRep correctly.

00:11:09.560 --> 00:11:12.290
And you should really try
to take advantage of that.

00:11:12.800 --> 00:11:15.450
The other thing I want to call out
again is you do need to invoke that

00:11:15.450 --> 00:11:17.110
code multiple times to get best results.

00:11:17.200 --> 00:11:20.440
One for your 1x screen,
one for your 2x screen.

00:11:21.990 --> 00:11:23.940
Some other things I wanted to call out.

00:11:23.980 --> 00:11:27.920
There's a few methods in NSImage we'd
really like you to move off of now.

00:11:27.970 --> 00:11:29.960
Caposite to point, dissolve to point.

00:11:30.020 --> 00:11:32.060
And the problems are they
don't fully respect the

00:11:32.060 --> 00:11:33.640
context transformation matrix.

00:11:33.690 --> 00:11:37.680
And you'll notice a lot of our drawing
these days at 1x and 2x really ties in

00:11:37.720 --> 00:11:39.910
with that context transformation matrix.

00:11:40.030 --> 00:11:42.020
Most of the time we get it right,
but there's edge cases.

00:11:42.070 --> 00:11:44.930
And if you move off of these,
you won't hit them.

00:11:46.050 --> 00:11:49.270
A good rule of thumb here is that if
the method doesn't begin with draw,

00:11:49.270 --> 00:11:51.500
don't use it to draw the NSImage.

00:11:51.750 --> 00:11:54.400
Instead, here's the master drawing
method for NSImage.

00:11:54.410 --> 00:11:57.700
Draw on rect, from rect, operation,
fraction, respect, flip, hints.

00:11:57.700 --> 00:11:59.760
It sounds like a mouthful,
but if you look at this

00:11:59.800 --> 00:12:02.350
little snippet here,
the important part is really just

00:12:02.350 --> 00:12:03.960
the destination rect parameter.

00:12:04.030 --> 00:12:09.180
Everything else you can just
copy and paste the code here.

00:12:09.530 --> 00:12:11.330
It'll be available later.

00:12:11.660 --> 00:12:14.070
But that'll handle 90%
of your drawing cases,

00:12:14.070 --> 00:12:15.040
probably more.

00:12:15.160 --> 00:12:18.100
So that covers what I want
to tell you about NSImage.

00:12:18.140 --> 00:12:19.740
I know some of you are
doing OpenGL stuff,

00:12:19.740 --> 00:12:22.120
and you're going to be interested
in this next section about

00:12:22.120 --> 00:12:23.530
OpenGL and high resolution.

00:12:23.640 --> 00:12:26.800
And if you just run your app today
on modified on one of these systems,

00:12:26.860 --> 00:12:28.970
you're going to notice
things look scaled up,

00:12:29.080 --> 00:12:34.380
and that's because we create the
surfaces at the standard 1x resolution.

00:12:34.670 --> 00:12:37.990
This is the most compatible thing to do
because points and pixels still match,

00:12:38.030 --> 00:12:40.800
but it's not the result
you're probably looking for.

00:12:40.850 --> 00:12:43.180
If you want to have nice,
crisp results on these displays,

00:12:43.250 --> 00:12:45.660
you're going to need to do a little
bit of work to opt in to this.

00:12:45.820 --> 00:12:48.220
And you do that using this
new NSView method called

00:12:48.660 --> 00:12:51.800
SetOnceBestResolutionOpenGLSurface.

00:12:51.860 --> 00:12:54.180
And you pass yes,
and that tells us that we can

00:12:54.360 --> 00:12:56.380
allocate a full 2x surface for you.

00:12:56.480 --> 00:12:57.630
And you have to do a
little bit more than that,

00:12:57.630 --> 00:12:58.000
though.

00:12:58.000 --> 00:12:59.810
If you don't update
your GL viewport code,

00:12:59.810 --> 00:13:02.200
you're going to find your
drawing in the wrong place.

00:13:02.300 --> 00:13:06.380
And GL viewport takes
arguments in pixels.

00:13:06.380 --> 00:13:08.520
And until now,
you've probably been propagating -- or

00:13:08.520 --> 00:13:11.870
getting your arguments for GL viewport
by just asking for your view's bounds.

00:13:12.060 --> 00:13:14.830
In 2x, of course, the pixels and points
don't match up anymore.

00:13:14.980 --> 00:13:17.330
And there's this method called
ConvertRecToBacking we'd like you to

00:13:17.330 --> 00:13:21.900
use that will take your local points
and convert them into display pixels.

00:13:21.950 --> 00:13:25.660
And you'll use the results of
that to pass on to GL viewport.

00:13:25.780 --> 00:13:30.010
Some other things I want to mention
is that if you're doing UI stuff,

00:13:30.090 --> 00:13:32.490
you're probably going to want to
incorporate the UI stuff by scale

00:13:32.580 --> 00:13:34.620
factor into your model view transform.

00:13:34.680 --> 00:13:38.980
And that's so things like buttons and
text appear the same size physically

00:13:38.980 --> 00:13:40.280
in the real world as they did before.

00:13:40.280 --> 00:13:43.400
Otherwise,
it's tricky to click very tiny buttons.

00:13:43.470 --> 00:13:45.810
The other thing is we
have way more pixels.

00:13:46.100 --> 00:13:48.730
You'll probably want to update
your texture resources to

00:13:48.740 --> 00:13:50.280
take full advantage of them.

00:13:50.400 --> 00:13:55.300
Let's go ahead and show you exactly
what I was talking about here with

00:13:55.370 --> 00:13:58.630
the chess application in Mac OS X.

00:13:58.700 --> 00:14:01.570
You're probably all familiar with chess.

00:14:03.270 --> 00:14:04.200
And let's just run it here.

00:14:04.200 --> 00:14:06.500
We're on a 2x screen,
and this is an unmodified

00:14:06.500 --> 00:14:08.830
version of the chess program.

00:14:10.390 --> 00:14:15.720
And if we go ahead and look at our board,
zoom in, you're going to notice the

00:14:15.930 --> 00:14:17.260
pieces are a little blocky.

00:14:17.260 --> 00:14:20.140
Like, especially if you compare the
text up here with the pieces,

00:14:20.140 --> 00:14:24.060
you'll notice they're not the
resolution we want to be rendering at.

00:14:24.170 --> 00:14:25.520
So I mentioned we had to opt in.

00:14:25.690 --> 00:14:28.060
And I'm not especially
familiar with Chess,

00:14:28.190 --> 00:14:29.460
but I do know they use an OpenGL view.

00:14:29.460 --> 00:14:31.860
So I'm just going to find
where their OpenGL view is.

00:14:31.930 --> 00:14:34.460
They have this MBC Board View class.

00:14:34.510 --> 00:14:38.110
And let's check the implementation
of it and just find the init method.

00:14:38.300 --> 00:14:41.990
So here's init with frame in
their OpenGL view subclass.

00:14:42.060 --> 00:14:44.420
And here's the call to
super init with frame.

00:14:44.460 --> 00:14:47.970
And if we just add a self,
set once best resolution

00:14:47.970 --> 00:14:51.450
OpenGL surface here,
we can see the results.

00:14:52.900 --> 00:14:55.590
So that looks crisper.

00:14:55.700 --> 00:15:00.150
I mean, these pixels are a lot sharper,
but there's a problem.

00:15:00.370 --> 00:15:02.360
I'm not quite sure what it is.

00:15:02.470 --> 00:15:04.550
Oh, oh, the board is really tiny.

00:15:04.610 --> 00:15:06.850
That's the problem.

00:15:06.930 --> 00:15:08.850
So I mentioned we had to
update our call to GL viewport.

00:15:08.900 --> 00:15:10.010
It's expecting arguments in pixels.

00:15:10.090 --> 00:15:12.240
So let's just see where
we're calling GL viewport.

00:15:12.240 --> 00:15:14.640
Here it is in MBC board view draw.

00:15:14.640 --> 00:15:16.610
And we have this variable called bounds.

00:15:16.710 --> 00:15:18.530
If we scroll up,
we can see that bounds is

00:15:18.600 --> 00:15:20.850
definitely equal to self bounds.

00:15:20.850 --> 00:15:23.850
So if we just do self
convert rec to backing,

00:15:24.330 --> 00:15:27.620
and pass in the existing bounds argument.

00:15:27.810 --> 00:15:29.520
Now we're going to have
a bounds rect in pixels.

00:15:29.520 --> 00:15:31.590
Let's see what that looks like.

00:15:33.090 --> 00:15:34.440
That is the right size.

00:15:34.440 --> 00:15:36.990
And if we zoom in,
we notice these pieces are really crisp.

00:15:37.000 --> 00:15:40.000
They match our game
center warning resolution,

00:15:40.050 --> 00:15:40.470
too.

00:15:40.510 --> 00:15:44.240
So that's fantastic.

00:15:44.260 --> 00:15:46.000
So that was a simple case.

00:15:46.000 --> 00:15:47.240
There's more complicated ones.

00:15:47.240 --> 00:15:50.790
But for a lot of cases,
this will be exactly what you need to do.

00:15:51.830 --> 00:15:54.190
So some other things
you should be aware of.

00:15:54.210 --> 00:15:58.100
GL viewport isn't the only thing
that takes device-dependent geometry.

00:15:58.100 --> 00:16:00.460
It's not the only thing
that takes pixels.

00:16:00.510 --> 00:16:03.550
Scissors, stencils,
many other OpenGL functions

00:16:03.550 --> 00:16:06.540
do expect input in pixels,
so you're going to need to modernize your

00:16:06.640 --> 00:16:11.370
code to use convert_rec to backing or
convert_point to backing there as well.

00:16:11.550 --> 00:16:13.410
In general,
we find it may be easier to just,

00:16:13.430 --> 00:16:16.050
when dealing with OpenGL,
convert all of your inputs into

00:16:16.140 --> 00:16:19.600
pixel space and then back into
whatever your OpenGL world looks like.

00:16:19.600 --> 00:16:23.420
You don't have to do this,
but it tends to simplify things.

00:16:23.530 --> 00:16:27.450
The other bit, if you have pre-rendered
text or GUI elements,

00:16:27.560 --> 00:16:30.440
you're going to want to re-render
those and probably have separate 1x

00:16:30.550 --> 00:16:32.790
and 2x versions that you can display.

00:16:32.900 --> 00:16:37.470
Text especially looks not so
great when we scale it up or down.

00:16:37.750 --> 00:16:40.030
Something else you should be aware of,
if you're using multi-sample

00:16:40.030 --> 00:16:42.300
anti-aliasing or other
full-scene anti-aliasing stuff,

00:16:42.350 --> 00:16:44.760
it's really expensive,
especially with regards to memory,

00:16:44.830 --> 00:16:47.730
and you might find that that
memory usage is better spent

00:16:47.730 --> 00:16:49.450
on higher quality textures.

00:16:49.590 --> 00:16:52.530
So you might try turning it off
or just dialing down via the

00:16:52.600 --> 00:16:54.800
multi-sampling factor you're using.

00:16:55.270 --> 00:16:58.700
Some other notes if you're
doing OpenGL full screen.

00:16:58.700 --> 00:17:02.070
Some of you are capturing the
display and changing the resolution,

00:17:02.070 --> 00:17:04.700
and we'd really prefer if
you stopped doing that.

00:17:04.700 --> 00:17:09.700
Instead, create a window that
covers the entire screen.

00:17:09.800 --> 00:17:13.610
And some of you may have been concerned
about performance problems using a window

00:17:13.710 --> 00:17:16.900
instead of a full screen OpenGL context,
and we actually detect this case and

00:17:16.910 --> 00:17:20.200
go ahead and make sure your bits get
to the screen as fast as possible.

00:17:20.200 --> 00:17:23.380
So there's no performance penalty for
having an OpenGL full screen window

00:17:23.390 --> 00:17:25.020
as opposed to capturing the display.

00:17:25.200 --> 00:17:29.110
And the other thing this lets us do
is present critical system alerts.

00:17:30.190 --> 00:17:32.260
So I mentioned this convert
rec to backing method.

00:17:32.260 --> 00:17:33.850
What do I mean when I say backing?

00:17:34.060 --> 00:17:36.240
Let's talk about backing
coordinate systems.

00:17:36.240 --> 00:17:38.000
Backing coordinate systems are
really what we're talking about

00:17:38.000 --> 00:17:39.640
whenever we're referring to bitmaps.

00:17:39.720 --> 00:17:42.340
And you're most likely going to
deal with these in a Cocoa world

00:17:42.340 --> 00:17:44.740
if you're calling convert rec to
backing or convert rec to backing.

00:17:44.740 --> 00:17:48.180
It's a method that exists on NSView,
NSWindow, and NSScreen.

00:17:48.280 --> 00:17:52.810
NSView also has methods to convert
points and sizes to backing.

00:17:52.950 --> 00:17:56.530
Let's discuss the specifics of that
coordinate system a little bit.

00:17:56.910 --> 00:17:59.140
So the first thing is that
the units in the back-end

00:17:59.140 --> 00:18:00.880
coordinate system are in pixels.

00:18:00.940 --> 00:18:02.760
I don't think anyone's surprised by that.

00:18:02.890 --> 00:18:07.540
And it's the standard Cocoa coordinate
system orientation where the lower left

00:18:07.640 --> 00:18:10.030
is increasingly negative coordinates,
and as you go to increasingly

00:18:10.030 --> 00:18:12.540
positive coordinates,
you're approaching the upper right.

00:18:12.680 --> 00:18:15.930
So that means that you can say
floor value to move it down

00:18:16.070 --> 00:18:17.800
or seal value to move it up.

00:18:17.910 --> 00:18:21.740
And finally, the integral values in the
space are pixel aligned.

00:18:21.840 --> 00:18:24.660
And you'll notice I didn't say
anything about absolute coordinates,

00:18:24.730 --> 00:18:28.100
and that's because we don't actually
make any guarantees about what the

00:18:28.100 --> 00:18:31.620
local coordinate to back-end coordinate
transformation is going to look like.

00:18:31.620 --> 00:18:35.560
Specifically, don't anticipate that just
because your bounds origin is 0,

00:18:35.560 --> 00:18:39.290
0, that your bounds origin and
back-end coordinates is 0,

00:18:39.390 --> 00:18:39.740
0.

00:18:39.880 --> 00:18:43.680
The view can be rendered to a surface or
a layer or have various flips involved on

00:18:43.680 --> 00:18:46.540
its way up to the window back-end store.

00:18:46.650 --> 00:18:48.900
So you're going to see some weird
coordinates every now and then.

00:18:48.900 --> 00:18:51.550
Like you'll throw in a positive
view coordinate and get back a

00:18:51.550 --> 00:18:53.300
very negative back-end coordinate.

00:18:53.380 --> 00:18:54.590
And don't be surprised by that.

00:18:54.600 --> 00:18:58.360
If you're concerned about distances or
relative to a certain point in your view,

00:18:58.530 --> 00:19:01.420
convert that point to back-end also and
do your calculations in back-end space

00:19:01.480 --> 00:19:04.940
and treat them as relative coordinates.

00:19:05.220 --> 00:19:07.820
Finally, the back-end coordinate
system is different for

00:19:07.820 --> 00:19:09.570
every view window and screen.

00:19:09.760 --> 00:19:12.720
So if you use convert rect to back-end
and are trying to round trip data,

00:19:12.900 --> 00:19:16.560
make sure you use the exact same object
to call convert rect from back-end on it.

00:19:16.560 --> 00:19:19.810
If you mix and match objects doing that,
you're going to have

00:19:19.810 --> 00:19:21.850
really weird results.

00:19:25.040 --> 00:19:26.880
So a few of you are
here for core animation,

00:19:26.890 --> 00:19:27.490
I'm sure.

00:19:27.500 --> 00:19:30.700
Let's talk a bit about
core animation now.

00:19:30.700 --> 00:19:32.170
Especially if you're managing
custom CA layer content,

00:19:32.170 --> 00:19:33.440
here's some things you should know.

00:19:33.550 --> 00:19:36.880
One, on Mountain Lion,
layer bounds and position are in points.

00:19:37.040 --> 00:19:38.240
They're virtual.

00:19:38.380 --> 00:19:41.040
And to get results that are
appropriate for the display,

00:19:41.040 --> 00:19:44.750
you need to be aware of the contents
properties and contents scale properties.

00:19:44.940 --> 00:19:46.800
If you're getting the
contents scale wrong,

00:19:46.800 --> 00:19:49.440
you're most likely going to
see unsatisfactory results.

00:19:49.440 --> 00:19:51.640
The other thing you should be aware of
is if you're playing with the contents

00:19:51.640 --> 00:19:54.200
gravity property of your layer,
that's going to affect the positioning

00:19:54.200 --> 00:19:57.170
of the bitmaps within that layer.

00:19:57.390 --> 00:19:59.740
We'll talk a bit more
about that in a moment.

00:19:59.780 --> 00:20:02.790
If you're using the
drawLayerInContext delegate method

00:20:02.790 --> 00:20:06.390
or subclassing drawInContext,
these will already conclude the

00:20:06.980 --> 00:20:10.600
scaling if you are adjusting the
contents scale of the layer correctly.

00:20:10.640 --> 00:20:12.690
Provided you're doing that,
you don't have to modify

00:20:12.690 --> 00:20:13.800
any of your drawing codes.

00:20:13.900 --> 00:20:16.390
So that's kind of a handy thing to know.

00:20:16.970 --> 00:20:19.100
Another thing that's handy to know
is that you can use an NSImage

00:20:19.170 --> 00:20:20.340
as the contents of a layer.

00:20:20.340 --> 00:20:21.190
This is really convenient.

00:20:21.200 --> 00:20:23.660
We just have this one-line snippet here.

00:20:23.660 --> 00:20:25.900
And this works for
multi-resolution images.

00:20:25.900 --> 00:20:29.500
Let me describe how we pick a
representation to use in this case.

00:20:29.550 --> 00:20:32.110
Basically,
we go ahead and look at the resolution

00:20:32.120 --> 00:20:33.870
of the screen the layer tree is on.

00:20:34.180 --> 00:20:37.060
So if you're on a 1X screen,
we're going to pick the representation

00:20:37.060 --> 00:20:38.960
most suitable for 1X inside the image.

00:20:39.060 --> 00:20:41.240
If you're on a 2X screen,
we're going to pick the representation

00:20:41.320 --> 00:20:42.560
most suitable for 2X on the image.

00:20:42.850 --> 00:20:47.020
And that probably covers 80%
of cases you'll care about.

00:20:47.040 --> 00:20:48.130
It's really handy.

00:20:48.210 --> 00:20:51.220
But there's some edge cases you should be
aware of if you're doing fancier things.

00:20:51.330 --> 00:20:53.140
And let me illustrate those for you.

00:20:53.230 --> 00:20:56.810
So we have our cake image again
with 1X and 2X cake variants.

00:20:56.930 --> 00:21:00.700
And here's a layer tree where we're
just displaying a centered layer here.

00:21:00.790 --> 00:21:02.550
So on 1X, we display the 1X image.

00:21:02.600 --> 00:21:03.790
And on 2X, we display the 2X image.

00:21:03.920 --> 00:21:04.880
So far, so good.

00:21:05.040 --> 00:21:07.700
But let's say we change
the transform on the layer,

00:21:07.700 --> 00:21:10.630
the bounds on the layer,
so it's larger now.

00:21:10.870 --> 00:21:12.580
What we're going to see is
that the 1X screen is going

00:21:12.580 --> 00:21:12.760
to be a little bit bigger.

00:21:12.760 --> 00:21:14.760
And on the 2X screen,
even though we could use the 2X screen

00:21:14.760 --> 00:21:16.760
and get more pixels and display them,
it doesn't happen.

00:21:16.760 --> 00:21:19.760
And that's because we don't actually
know the display size of the layer.

00:21:19.760 --> 00:21:22.630
We just know the resolution
of the screen it's on.

00:21:22.770 --> 00:21:24.250
I mentioned contents gravity.

00:21:24.370 --> 00:21:28.260
Contents gravity is used in conjunction
with content scaling to -- or to

00:21:28.380 --> 00:21:32.130
-- or content scale to position
the contents within the layer.

00:21:32.480 --> 00:21:35.500
By default, the contents gravity is
one of the resize modes,

00:21:35.520 --> 00:21:38.120
which doesn't affect the content
scale or ignores the content

00:21:38.260 --> 00:21:39.060
scale once positioning it.

00:21:39.190 --> 00:21:41.440
If you're using a non-resize
mode like top left here,

00:21:41.600 --> 00:21:42.720
you'll notice that when
we provide the 2X mode,

00:21:42.720 --> 00:21:47.480
Core Animation treats it like a 1X bitmap
and displays it in a much larger area.

00:21:47.480 --> 00:21:49.990
So instead of just showing
the wrong number of pixels,

00:21:50.070 --> 00:21:52.280
we're actually drawing
things incorrectly.

00:21:52.330 --> 00:21:56.990
And that's true for various other
non-resize orientations like top right.

00:21:57.760 --> 00:22:01.360
So to summarize those images,
we can't pick up transforms and

00:22:01.360 --> 00:22:03.460
bounds changes in the layers.

00:22:03.460 --> 00:22:06.050
And additionally, if you're using NSImage
as a layer content,

00:22:06.050 --> 00:22:09.320
you need to be sure your contents
gravity is one of resize,

00:22:09.330 --> 00:22:11.560
resize aspect, or resize fill.

00:22:11.560 --> 00:22:15.690
Now suppose you do want to take advantage
of bounds changes or transforms or you

00:22:15.690 --> 00:22:21.600
want a non-resize contents gravity,
we have API for you.

00:22:21.600 --> 00:22:24.400
So that API comes in the form
of two methods on NSImage,

00:22:24.530 --> 00:22:28.440
recommended layer content scale and
layer contents for content scale.

00:22:28.470 --> 00:22:31.800
Recommended layer content scale,
you pass in a desired content scale.

00:22:31.800 --> 00:22:34.700
So let's say you're in a
2X window and you have a 3X

00:22:34.700 --> 00:22:38.170
transform attached to your layer,
you would go ahead and say,

00:22:38.170 --> 00:22:41.600
"Recommended layer content scale
6." And NSImage will return the

00:22:41.690 --> 00:22:44.840
content scale most appropriate
for the image reps in that image.

00:22:44.970 --> 00:22:48.120
So if you're doing the standard 1X,
2X bitmap configuration in that image,

00:22:48.120 --> 00:22:50.600
we'll go ahead and say, "Well,
2 is way closer to 6 than 1,

00:22:50.600 --> 00:22:53.280
so we're going to say 2 is the
desired content scale you want to

00:22:53.360 --> 00:22:56.170
use." If it were a PDF image rep or
something resolution-independent,

00:22:56.260 --> 00:22:59.080
we would instead probably
return the factor you pass in.

00:22:59.210 --> 00:23:01.420
And that can be used in
conjunction with the next method,

00:23:01.420 --> 00:23:03.050
layer contents for content scale.

00:23:03.060 --> 00:23:05.820
In that, you pass in the content scale
you're going to set on the layer,

00:23:05.820 --> 00:23:09.400
and we give you back an opaque object
to set as the contents of the layer.

00:23:09.400 --> 00:23:12.170
And if you use those two in sync,
you can use all the contents gravity

00:23:12.320 --> 00:23:15.580
modes just fine in Core Animation.

00:23:18.090 --> 00:23:22.100
So I mentioned the content scale here,
and you're probably wondering how

00:23:22.100 --> 00:23:25.330
do you know about that and how
do you react to changes in that?

00:23:25.730 --> 00:23:28.490
And at the layer level,
we have this new delegate method called

00:23:28.530 --> 00:23:30.760
layerShouldInheritContentScaleFromWindow.

00:23:30.890 --> 00:23:32.440
And it returns a Boolean.

00:23:32.540 --> 00:23:35.570
If you return yes from this method,
we're going to go ahead and update the

00:23:35.570 --> 00:23:39.260
content scale of the layer to match the
scale we've passed in this method and

00:23:39.260 --> 00:23:42.070
then call setNeedsDisplay on the layer.

00:23:42.380 --> 00:23:45.700
So if you're using the
drawLayerInContextDelegate method,

00:23:45.700 --> 00:23:48.630
this is a very natural pairing
for you to automatically update

00:23:48.630 --> 00:23:50.220
the content scale and redraw.

00:23:50.310 --> 00:23:52.800
If you return no, we're going to keep our
hands off the layer,

00:23:52.800 --> 00:23:55.870
and you can instead take this
opportunity to update the contents

00:23:55.870 --> 00:23:57.400
and content scale yourself.

00:23:57.560 --> 00:23:59.930
Something you should be aware of,
if you do return yes from this,

00:24:00.070 --> 00:24:03.190
you absolutely need to implement
displayLayer or drawLayerInContext.

00:24:03.290 --> 00:24:05.610
And the reason for this is that
when you mark a layer as dirty,

00:24:05.620 --> 00:24:08.350
which we'll do when you return yes,
it blows away the existing

00:24:08.450 --> 00:24:09.610
contents on the layer.

00:24:09.700 --> 00:24:11.860
So if you don't implement
displayLayer or drawLayerInContext,

00:24:11.980 --> 00:24:14.640
you're going to notice the contents of
your layer disappears instead of being

00:24:14.640 --> 00:24:17.920
updated for the resolution you want,
which is probably not the

00:24:17.920 --> 00:24:19.760
effect you're going for.

00:24:19.760 --> 00:24:21.800
The other bit to be aware of
is that this delegate method,

00:24:21.800 --> 00:24:23.000
it's not invoked by CoreAnimation.

00:24:23.000 --> 00:24:24.800
It's actually invoked by NSView.

00:24:24.910 --> 00:24:27.760
So if you add a layer to an
existing layer tree that's hosted,

00:24:27.760 --> 00:24:29.560
we don't know about it,
and we can't invoke that

00:24:29.560 --> 00:24:30.610
delegate method for you.

00:24:30.740 --> 00:24:32.900
The takeaway from that is when
you're creating these layers,

00:24:32.900 --> 00:24:35.860
you should probably take care to
set the content scale manually.

00:24:35.970 --> 00:24:39.540
And you can do that by asking the
window for its backing scale factor,

00:24:39.540 --> 00:24:40.430
for example.

00:24:40.970 --> 00:24:46.500
And let's go ahead and see what
taking this advice looks like.

00:24:46.500 --> 00:24:48.390
This is the unmodified
version of the app.

00:24:48.410 --> 00:24:51.640
So on the left is a layer that uses
draw layer and context to draw.

00:24:51.640 --> 00:24:54.410
And within that it uses the
NSImage draw and rect method as

00:24:54.570 --> 00:24:58.060
well as NSRect fill with a blue
color to make the blue background.

00:24:58.060 --> 00:25:00.340
The layer on the right is
actually set by setting the

00:25:00.440 --> 00:25:05.020
background color of the CA layer,
setting the contents gravity to center,

00:25:05.020 --> 00:25:07.980
and setting the contents to our NSImage.

00:25:07.980 --> 00:25:11.060
And so it's displaying
more or less correctly,

00:25:11.060 --> 00:25:13.790
but those are some really fuzzy cakes.

00:25:14.020 --> 00:25:17.500
If we go ahead and look
at our KCAT 2X PNG,

00:25:17.500 --> 00:25:20.300
the first thing we're going to do is
we're going to add it to our target.

00:25:20.400 --> 00:25:22.530
And we've updated our artwork.

00:25:22.540 --> 00:25:23.650
Everything should look great.

00:25:23.770 --> 00:25:28.140
And we can see the image on
the left doesn't look so great.

00:25:28.140 --> 00:25:31.040
It's still pretty blurry.

00:25:31.120 --> 00:25:33.310
And the image on the right
is the different size.

00:25:33.520 --> 00:25:37.070
So we're getting very different
results than what we had before.

00:25:37.180 --> 00:25:39.810
And let me show you how
we set up that layer.

00:25:39.870 --> 00:25:43.040
So an application did
finish launching here.

00:25:43.040 --> 00:25:45.160
The layer on the left,
it's pretty simple.

00:25:45.160 --> 00:25:47.300
We just set ourselves as the delegate,
set needs display,

00:25:47.400 --> 00:25:49.260
and call set needs display
on ourselves there.

00:25:49.260 --> 00:25:51.190
The one on the right does
exactly as I said where it

00:25:51.190 --> 00:25:53.690
sets the background color,
the contents gravity,

00:25:53.690 --> 00:25:58.330
and it calls this configure contents
for view two method which just

00:25:58.550 --> 00:26:02.190
sets the contents to an NS image.

00:26:05.400 --> 00:26:09.530
Using layers should
inherit content scale.

00:26:09.540 --> 00:26:12.060
So let's go ahead and do that.

00:26:12.060 --> 00:26:13.300
And let's take this one layer at a time.

00:26:13.300 --> 00:26:15.920
So we're going to start by working
with the layer on the left.

00:26:15.920 --> 00:26:18.030
Let's just add this delegate method here.

00:26:18.940 --> 00:26:21.020
So we're going to go ahead and run this.

00:26:21.300 --> 00:26:23.720
And you'll note nothing has changed.

00:26:23.850 --> 00:26:26.300
The image still looks
just like it did before.

00:26:26.300 --> 00:26:29.680
So the problem with this is
that when we call -- when we

00:26:29.680 --> 00:26:33.730
set the layer on this view,
it's already hosted in a window.

00:26:33.970 --> 00:26:39.520
So we don't get the notification
that we're adding a layer to it all.

00:26:39.710 --> 00:26:42.840
And this method is never invoked.

00:26:42.840 --> 00:26:44.330
And the solution to that is to
update the content scale manually.

00:26:44.370 --> 00:26:47.080
So I mentioned the window
backing scale factor method,

00:26:47.090 --> 00:26:48.560
and that's something we can use here.

00:26:48.870 --> 00:26:55.560
So we just add view1.layer.contentScale
equals view1.windowbackingscaleFactor.

00:26:55.650 --> 00:26:59.610
And now we see a -- well,
it may be difficult for

00:26:59.610 --> 00:27:01.930
you to see out there,
but this is a much crisper 2X

00:27:01.930 --> 00:27:03.500
variation of the cake image.

00:27:03.500 --> 00:27:05.840
Let's go ahead and start
working on the right side layer,

00:27:05.840 --> 00:27:09.230
the one that's using the layer
properties to display itself.

00:27:09.520 --> 00:27:13.190
So I mentioned we're using the contents
gravity of contents gravity center,

00:27:13.360 --> 00:27:17.240
which means we can't just set the image
as the contents of the layer anymore.

00:27:17.380 --> 00:27:21.810
So let's go ahead and update this
method to use an explicit content scale.

00:27:22.690 --> 00:27:26.090
So in this case,
we have our new configure contents

00:27:26.200 --> 00:27:29.540
review to method that takes a scale,
and it goes ahead and

00:27:29.630 --> 00:27:32.340
grabs the cake image again,
and then asks for the recommended

00:27:32.430 --> 00:27:35.300
content scale for that image,
and we go ahead and

00:27:35.300 --> 00:27:39.900
set that on the layer,
and then also pass this to the

00:27:39.900 --> 00:27:45.310
layer contents for content scale
method and update the layer

00:27:45.310 --> 00:27:45.310
contents using the result of that.

00:27:45.310 --> 00:27:45.310
So we've changed our method name here.

00:27:45.490 --> 00:27:49.260
Let's go ahead and just start with
a 1X scale and see what happens.

00:27:49.390 --> 00:27:55.000
And we've noticed now that we are
actually getting a pretty decent result.

00:27:55.100 --> 00:27:56.240
It's still the 1X image.

00:27:56.240 --> 00:27:58.040
It's not as sharp as it should be.

00:27:58.170 --> 00:28:01.410
So we want to update this to be
similar to our code here where we're

00:28:01.410 --> 00:28:02.840
manually passing the scale factor.

00:28:03.050 --> 00:28:05.130
Instead of using
view1.window.back_in_scale_factor,

00:28:05.140 --> 00:28:08.500
we're going to use
view2.window.back_in_scale_factor.

00:28:09.140 --> 00:28:11.520
And now you can see we're getting
consistent drawing between the

00:28:11.520 --> 00:28:14.700
left and right layers again,
which is exactly what we wanted,

00:28:14.700 --> 00:28:17.060
and it's using our 2x resources.

00:28:17.060 --> 00:28:18.060
So that's great.

00:28:18.060 --> 00:28:19.000
That's what we were targeting.

00:28:19.040 --> 00:28:21.460
I mentioned we were handling
this layer by layer.

00:28:21.460 --> 00:28:23.710
We added layer should
inherit content scale,

00:28:23.720 --> 00:28:25.700
but we didn't handle layer 2 in it.

00:28:25.750 --> 00:28:27.080
And in this case,
it doesn't make a difference

00:28:27.080 --> 00:28:29.240
because we're not responding
to a dynamic screen change,

00:28:29.270 --> 00:28:31.820
but that's something we will have
to respond to in the real world.

00:28:31.910 --> 00:28:33.330
So you would add code
like this to notice,

00:28:33.370 --> 00:28:34.660
oh, we're talking about layer 2?

00:28:34.760 --> 00:28:37.810
Let's call configure contents for
view 2 again with the new scale factor

00:28:37.870 --> 00:28:39.380
passed into the delegate method.

00:28:39.410 --> 00:28:40.980
And it's very important
that we return no here.

00:28:40.980 --> 00:28:43.120
If we were to return yes,
we would blow away the contents

00:28:43.130 --> 00:28:46.340
we just set on the layer
and undo all of our work.

00:28:49.050 --> 00:28:51.600
All right,
so we've seen using that a bit.

00:28:51.600 --> 00:28:55.440
Now, I mentioned the should
inherit content scale method.

00:28:55.440 --> 00:28:59.830
So you've probably picked up
that resolutions can change.

00:29:00.090 --> 00:29:01.840
Let's talk about that a bit more.

00:29:01.970 --> 00:29:04.600
So the resolution can
really change at any time.

00:29:04.600 --> 00:29:08.760
You can't necessarily predict
that things will hold constant.

00:29:08.760 --> 00:29:12.670
Someone can hot plug an external
display or mirror or extend the desktop.

00:29:13.630 --> 00:29:17.010
And just because the internal
display is 2x doesn't mean the

00:29:17.010 --> 00:29:19.000
external displays are going to be 2x.

00:29:19.120 --> 00:29:22.370
You do have to deal with heterogeneous
environments where you have a 1x

00:29:22.370 --> 00:29:24.900
display and a 2x display simultaneously.

00:29:25.020 --> 00:29:28.430
And in those cases,
when Windows drag between displays,

00:29:28.430 --> 00:29:30.900
it's going to update automatically.

00:29:31.040 --> 00:29:35.090
So let's talk a bit more about how
that window updates its resolution.

00:29:35.220 --> 00:29:38.470
It's going to try to make its
backing resolution match the backing

00:29:38.470 --> 00:29:40.600
resolution of the associated NSScreen.

00:29:40.680 --> 00:29:42.600
And that means if you're
straddling displays,

00:29:42.600 --> 00:29:45.700
it's going to pick the screen with
the largest part of the window is on.

00:29:45.970 --> 00:29:48.290
If you're offscreen entirely,
we're going to do something different.

00:29:48.300 --> 00:29:51.050
We're going to use the resolution
of the highest resolution

00:29:51.120 --> 00:29:52.920
display attached to the computer.

00:29:53.240 --> 00:29:56.100
And when we do change the backing
scale factor of the window,

00:29:56.100 --> 00:29:57.700
we post a notification about it.

00:29:57.840 --> 00:30:00.840
And that notification is
NSWindowDidChangeBackingProperties.

00:30:00.850 --> 00:30:03.250
And that's also called when
the color space or bit depth

00:30:03.250 --> 00:30:04.400
of a window changes as well.

00:30:04.710 --> 00:30:07.100
If you're using the WindowDelegate,
you can go ahead and implement

00:30:07.100 --> 00:30:10.280
WindowDidChangeBackingProperties instead,
which will pass you the

00:30:10.280 --> 00:30:12.140
notification as an argument.

00:30:12.360 --> 00:30:14.200
Views are similar.

00:30:14.200 --> 00:30:17.840
We have a new method on NSView called
ViewDidChangeBackingProperties.

00:30:17.960 --> 00:30:18.650
You can subclass that.

00:30:18.760 --> 00:30:20.100
There's no equivalent notification.

00:30:20.100 --> 00:30:23.000
And that's called when the view
is added to a window or when

00:30:23.000 --> 00:30:26.640
the window changes its backing
resolution or the color space changes.

00:30:26.640 --> 00:30:29.600
Here's a little snippet demonstrating
what you might do in that method.

00:30:29.600 --> 00:30:31.770
Here we call
SuperViewDidChangeBackingProperties.

00:30:32.000 --> 00:30:35.040
And if you recall from the demo,
the new NSImageContentScale-based

00:30:35.040 --> 00:30:36.910
methods,
we use that to explicitly

00:30:36.910 --> 00:30:40.680
manage the contents and content
scale of a layer we're hosting.

00:30:40.810 --> 00:30:41.710
Something to be aware of.

00:30:41.890 --> 00:30:46.010
The properties -- well, this method,
for one, isn't invoked when a view

00:30:46.010 --> 00:30:47.400
is removed from a window.

00:30:47.450 --> 00:30:52.070
And additionally, if you were to say,
"Convert REC to backing on a view not

00:30:52.070 --> 00:30:55.700
in a window," the view will act as if
it's on the highest resolution screen.

00:30:55.700 --> 00:30:57.260
So that's consistent with NSWindow.

00:30:57.390 --> 00:31:00.070
The other bit is before you
add a view to the window,

00:31:00.220 --> 00:31:02.850
it's doing the same thing.

00:31:04.490 --> 00:31:07.190
So I'd like to go ahead and bring
up our resident text expert,

00:31:07.190 --> 00:31:10.860
Akie Inoue, to talk about text rendering
in high resolution.

00:31:12.900 --> 00:31:15.230
Thank you, Chris.

00:31:15.340 --> 00:31:15.910
Good morning.

00:31:16.060 --> 00:31:16.990
I'm Aki Inoue.

00:31:17.270 --> 00:31:20.200
I'm the text guy from the Cocoa Group.

00:31:20.280 --> 00:31:23.630
Today,
I'm gonna cover how you can achieve the

00:31:23.630 --> 00:31:28.450
best text quality for your application
in your high-resolution world.

00:31:29.060 --> 00:31:34.760
So let's get started with exciting
new stuff in Mountain Lion.

00:31:34.940 --> 00:31:38.710
Actually,
there's no new text system API in

00:31:38.710 --> 00:31:41.950
order to support high resolution.

00:31:44.130 --> 00:31:46.230
Why is that?

00:31:46.390 --> 00:31:53.340
The tech system is designed as
resolution diagnostics throughout.

00:31:53.570 --> 00:31:59.600
It's been working with no identity
coordinate system for years.

00:31:59.600 --> 00:32:02.180
For example,
we've been working with ZoomView in

00:32:02.180 --> 00:32:09.640
TextEdit or we've been rendering into
totally resolution independent PDF files.

00:32:09.760 --> 00:32:15.600
So there was no need to add new API.

00:32:16.110 --> 00:32:21.630
We are introducing some significant
behavior change in Mountain Lion.

00:32:22.200 --> 00:32:23.800
Screen Fonts.

00:32:23.840 --> 00:32:30.130
We are duplicating the usage of
screen fonts starting mountain lane.

00:32:30.160 --> 00:32:33.870
So let's review what screen fonts are.

00:32:34.750 --> 00:32:39.080
The screen form is a
variant of your base form,

00:32:39.080 --> 00:32:45.570
and it uses integral advances instead
of the default floating point values.

00:32:47.340 --> 00:32:51.710
As you can see, with the base font,
the width of the character

00:32:52.700 --> 00:32:54.230
is in floating point value.

00:32:54.450 --> 00:32:58.050
That's taken from the font file itself.

00:33:00.980 --> 00:33:07.530
On the other hand, with screen fonts,
the weather spacing is tweaked so

00:33:07.530 --> 00:33:13.180
that the origin of the character is
aligned to the integral position.

00:33:13.570 --> 00:33:19.870
Remember, in low resolution,
one point used to be typically one pixel,

00:33:19.870 --> 00:33:26.830
so you get the effect of pixel
aligning the character in some cases.

00:33:28.170 --> 00:33:34.190
So with this, we were able to achieve
pretty decent text quality

00:33:34.270 --> 00:33:37.540
in lower resolution displays.

00:33:37.640 --> 00:33:41.550
And, you know,
quotes could be able to use the

00:33:41.640 --> 00:33:45.660
same shape bitmap caching easily.

00:33:45.760 --> 00:33:52.120
And it used to work with hand-tuned,
ancient, ancient bitmap fonts.

00:33:54.320 --> 00:33:58.170
These days,
these advantages are getting less

00:33:58.170 --> 00:34:03.420
relevant because of the newer course
technology such as font smoothing,

00:34:03.580 --> 00:34:07.140
subpixel quantization,
and on-screen tinting.

00:34:07.180 --> 00:34:11.170
And also,
the disadvantages of using screen

00:34:11.170 --> 00:34:14.600
fonts are outweighing advantages.

00:34:14.760 --> 00:34:21.010
For example, because of the rounding,
the glyphs are spaced uneven.

00:34:21.770 --> 00:34:30.030
And the gap created this uneven
spacing is more apparent or uglier

00:34:30.580 --> 00:34:33.470
when you're running in high resolution.

00:34:33.800 --> 00:34:37.740
Also,
we are not using kerning or rilature,

00:34:37.740 --> 00:34:43.420
the higher advanced typographic
features with screen fonts because

00:34:43.420 --> 00:34:47.790
these features are designed with
floating-point value in mind.

00:34:48.040 --> 00:34:52.330
So they don't work too
well with integer advances.

00:34:52.430 --> 00:34:58.440
And finally,
because of the tweaked letters,

00:34:58.460 --> 00:35:03.940
it often doesn't have consistent
scaling between point sizes.

00:35:04.090 --> 00:35:08.440
So if your applications are using
multiple font sizes such as graphics

00:35:08.500 --> 00:35:13.390
tools or presentation tools,
you might encounter surprises

00:35:13.390 --> 00:35:16.190
sometimes caused by this effect.

00:35:18.170 --> 00:35:24.810
So as I mentioned before,
using the base 14-point form

00:35:25.000 --> 00:35:29.060
gives you the best text quality,
both in low resolution

00:35:29.060 --> 00:35:30.920
and high resolution.

00:35:31.740 --> 00:35:35.880
Because of that,
these floating point advances are

00:35:35.880 --> 00:35:39.180
often referred to as ideal advances.

00:35:39.180 --> 00:35:43.970
And that gives you taking
advantage of the higher density

00:35:43.990 --> 00:35:49.960
in high resolution because we're
not rounding to pixel alignment.

00:35:50.370 --> 00:35:57.400
And we are now enabling Cognitive
Literature everywhere by default.

00:35:58.040 --> 00:36:05.090
And this is how actually the font
design was originally imagined.

00:36:06.660 --> 00:36:12.250
And you have the uniform
scaling between point sizes and

00:36:12.250 --> 00:36:14.980
different coordinate systems.

00:36:15.530 --> 00:36:18.920
For those reasons,
we've been actually using the

00:36:18.920 --> 00:36:21.560
base fonts in many places.

00:36:21.830 --> 00:36:25.750
For example, our system font,
Lucida Grande,

00:36:25.750 --> 00:36:31.370
has been using the floating point
advances since Mac OS X 10.0.

00:36:31.560 --> 00:36:37.270
And also many applications such as iWorks
been using floating point advances.

00:36:37.380 --> 00:36:42.140
And finally, in fact,
iOS itself doesn't have the concept

00:36:42.190 --> 00:36:45.450
of the screen formats altogether.

00:36:46.720 --> 00:36:49.390
So let's take a look at the screenshot.

00:36:49.630 --> 00:36:51.250
This is from 10.7.

00:36:51.410 --> 00:36:55.890
We're showing Helvetica
and times from 12.2,

00:36:56.010 --> 00:36:57.990
18.

00:36:58.460 --> 00:37:04.440
As you can see, the line edges are pretty
much jagged in some places.

00:37:04.590 --> 00:37:08.740
And this is how it looks with 10.8.

00:37:08.900 --> 00:37:17.260
The lines are scaled smoothly and
consistent between point sizes.

00:37:17.400 --> 00:37:19.930
Let's zoom into some of the world.

00:37:21.400 --> 00:37:27.660
In 10.7, you might notice the
glyphs are placed unevenly,

00:37:27.730 --> 00:37:33.210
and especially between W and E,
the job is pretty ugly.

00:37:33.340 --> 00:37:40.090
With 10.8, the glyphs are spaced evenly,
and the W and E are placed

00:37:40.260 --> 00:37:42.990
handsomely using kerning.

00:37:44.850 --> 00:37:49.640
So take a look at the
actual TextSystem API here.

00:37:49.780 --> 00:37:54.660
As you may know,
the Cocoa has three main groups of

00:37:54.660 --> 00:37:58.710
text rendering and measuring APIs.

00:37:58.830 --> 00:38:01.040
and NSLayoutMonitor.

00:38:01.100 --> 00:38:08.760
One of the core tech system APIs,
along with TextView and NSTextStorage,

00:38:08.760 --> 00:38:09.990
provides the

00:38:10.180 --> 00:38:13.760
Power and extensibility
to the text engine.

00:38:13.790 --> 00:38:17.660
And NSStringDraw API,
such as DrawingRack,

00:38:17.660 --> 00:38:21.740
gives you a convenient
way to render NSString and

00:38:21.800 --> 00:38:24.790
attribute string efficiently.

00:38:24.900 --> 00:38:32.690
And NSCell renders many user
interface control strings.

00:38:33.230 --> 00:38:37.960
And these APIs can be
categorized into two groups,

00:38:37.960 --> 00:38:38.700
Father.

00:38:39.790 --> 00:38:42.320
One is for document contents.

00:38:42.420 --> 00:38:47.540
NSLayoutManager and other
text system luminaries.

00:38:47.630 --> 00:38:54.260
NSTextView and NSTextRage usually take
this burden to support large documents.

00:38:54.360 --> 00:38:59.390
And user interface elements
are usually rendered using

00:38:59.390 --> 00:39:02.400
NSStreamDrop API and NSCell.

00:39:02.530 --> 00:39:05.520
For these groups,
we have the specific API for

00:39:05.710 --> 00:39:11.340
controlling the screen font
setting already from 10.0.

00:39:11.460 --> 00:39:15.590
For NSLayoutManager,
we have userScreenFont method.

00:39:15.680 --> 00:39:20.440
When it returns, yes,
NSLayoutManager uses screen font.

00:39:20.590 --> 00:39:22.960
If no, it doesn't.

00:39:23.210 --> 00:39:27.740
Similarly, we have
NSStreamDrawingDisabledScreenFontSubst

00:39:27.870 --> 00:39:29.100
itution flag.

00:39:29.250 --> 00:39:32.000
It's used for extended
stream drawing API,

00:39:32.000 --> 00:39:35.940
such as draw with red options.

00:39:36.000 --> 00:39:41.300
By specifying this method,
you can disable the substitution

00:39:41.510 --> 00:39:48.370
of screen font with these APIs.

00:39:49.460 --> 00:39:58.380
So with 10.7, these were set to-- your
screen fonts were set to yes,

00:39:58.380 --> 00:39:58.380
and for--

00:39:58.910 --> 00:40:03.040
User interface element setting,
it was default to be no,

00:40:03.040 --> 00:40:08.140
so we were always using screen fonts,
and on 10.8,

00:40:08.260 --> 00:40:13.900
they were flipped so that the layout
manager doesn't use screen fonts,

00:40:13.910 --> 00:40:19.080
and NS3 drawing disabled screen
font substitution is implied.

00:40:21.060 --> 00:40:25.140
So typically you are
using the font object.

00:40:25.260 --> 00:40:31.200
You send NSFontFactory message,
such as font with name size,

00:40:31.340 --> 00:40:34.440
and you get back a base font.

00:40:34.580 --> 00:40:40.580
And you pass that font object
to one of the text system APIs.

00:40:40.860 --> 00:40:43.420
And the tip framework
takes over from there.

00:40:43.730 --> 00:40:50.490
You can use these fonts and measure
and render text through these API,

00:40:50.490 --> 00:40:52.310
text system APIs.

00:40:52.690 --> 00:40:58.910
So your application actually
don't see the screen font itself.

00:41:00.130 --> 00:41:06.680
Behind the scene,
the tech system swaps the base font you

00:41:06.680 --> 00:41:13.470
specify with its corresponding screen
font dynamically whenever necessary.

00:41:15.190 --> 00:41:16.750
There are two APIs for that.

00:41:16.910 --> 00:41:22.710
NSLayoutManager, a substitute for phone,
and NSPhoneScreenPhone.

00:41:23.420 --> 00:41:28.220
And actually,
this is somewhat what Substitute Font for

00:41:28.220 --> 00:41:31.840
Font in NSLab Manager implementation.

00:41:32.940 --> 00:41:36.830
It checks if it's supposed
to use screen fonts,

00:41:36.900 --> 00:41:43.800
and if so, it calls NSFontScreenFont to
substitute and get the screen font.

00:41:45.920 --> 00:41:51.360
So, behind the scene,
the tech system sends the

00:41:51.360 --> 00:41:55.490
substitute font for font itself,
and...

00:41:56.380 --> 00:42:01.990
Get the screen phone and use it
dynamically for measure and render.

00:42:06.890 --> 00:42:15.200
So, as I mentioned that because of
those changes in mountain lying,

00:42:15.270 --> 00:42:18.910
you can take advantage
of the higher density.

00:42:19.000 --> 00:42:31.600
[Transcript missing]

00:42:31.940 --> 00:42:37.580
Because the width of the
letters are different between

00:42:37.580 --> 00:42:46.830
screen fonts and idea fonts,
the number of characters that

00:42:46.830 --> 00:42:46.830
can fit in the line changes.

00:42:47.880 --> 00:42:54.140
And these changes are often you
want to avoid because you want

00:42:54.140 --> 00:42:59.230
to have the same appearance of
your document between releases.

00:42:59.400 --> 00:43:02.820
So, if your application
falls into this category,

00:43:02.950 --> 00:43:07.760
you can manage your screen font
setting per document using,

00:43:07.760 --> 00:43:12.820
for example, APIs such as NSLite Manager,
useScreenFont.

00:43:13.380 --> 00:43:18.300
And actually, we're introducing a
new document attribute,

00:43:18.490 --> 00:43:24.990
an used screen font document attribute
that you can specify so that your

00:43:24.990 --> 00:43:29.820
per-document used screen font setting
can be stored into your document data.

00:43:29.820 --> 00:43:33.230
And actually,
text edit is already enhanced to take

00:43:33.270 --> 00:43:35.740
advantage of new functionalities.

00:43:35.820 --> 00:43:40.120
So you can look into the source
example and adopt the same

00:43:40.280 --> 00:43:43.010
strategy in your application.

00:43:43.300 --> 00:43:44.380
Thank you.

00:43:45.550 --> 00:43:51.760
Also, we are introducing a new pref
key and it's phone default

00:43:51.860 --> 00:43:54.770
screen for substitution enabled.

00:43:55.240 --> 00:44:00.600
It controls the default setting
for the screen font usage.

00:44:01.370 --> 00:44:06.230
If your application is
linked against 10.sdk,

00:44:06.340 --> 00:44:07.400
it defaults no.

00:44:07.400 --> 00:44:10.840
That means you are not
using screen fonts.

00:44:11.100 --> 00:44:14.360
And if you're linking
against previous sdk,

00:44:14.400 --> 00:44:15.400
it's yes.

00:44:15.560 --> 00:44:18.490
So we're preserving the Lion behavior.

00:44:18.660 --> 00:44:22.290
So using this key,
you can control your screen fonts,

00:44:22.290 --> 00:44:26.960
the default screen font usage
in your application explicitly.

00:44:28.180 --> 00:44:30.910
Now I'd like to switch
over to Dan Schimpf,

00:44:31.030 --> 00:44:35.840
who's going to discuss the
intricacy of pixel aligning.

00:44:38.600 --> 00:44:41.200
Thank you, Akki.

00:44:41.380 --> 00:44:46.300
Okay, I'm going to talk about a couple
issues with aligning pixel-based art.

00:44:46.300 --> 00:44:50.110
This is most helpful
with drawing UI controls,

00:44:50.110 --> 00:44:52.160
like buttons and things.

00:44:52.750 --> 00:44:55.940
So what are the issues
that you may run across?

00:44:56.110 --> 00:44:58.540
Well,
there are some situations in your drawing

00:44:58.540 --> 00:45:02.570
your UI art that may have worked well
at 1x that will seem to fail at 2x.

00:45:02.710 --> 00:45:05.590
It'll be out of line.

00:45:05.790 --> 00:45:08.960
And this usually comes down
to rounding differences,

00:45:08.960 --> 00:45:13.090
causing some layout that, again,
worked at 1x to change at 2x,

00:45:13.090 --> 00:45:15.030
just change their values.

00:45:15.130 --> 00:45:17.410
And this is because there
are no odd pixels at 2x.

00:45:17.520 --> 00:45:21.020
Because everything is doubled,
even three points all of a

00:45:21.020 --> 00:45:23.060
sudden becomes six pixels.

00:45:23.060 --> 00:45:25.790
So there's no odd pixel values.

00:45:26.550 --> 00:45:28.710
So here's a couple examples of
things that actually worked.

00:45:28.970 --> 00:45:33.490
So I have a four-point tall space,
and I want to fit something that's

00:45:33.600 --> 00:45:35.200
two points big inside of it.

00:45:35.280 --> 00:45:37.240
And you can see at 1x, it works out fine.

00:45:37.240 --> 00:45:38.640
We can center it just fine.

00:45:38.640 --> 00:45:42.980
And at 2x,
the blue bar is in the same spot.

00:45:43.070 --> 00:45:46.740
My one point turns into two pixels,
and it's just okay.

00:45:46.860 --> 00:45:48.320
Yay.

00:45:48.580 --> 00:45:51.500
Same thing works for
odd inside odd as well.

00:45:51.500 --> 00:45:54.620
We center it,
one point turns into one pixel,

00:45:54.620 --> 00:45:58.560
one point turns into two pixels,
everything's happy.

00:45:58.610 --> 00:46:00.680
The trouble begins

00:46:00.930 --> 00:46:03.800
When we have even things
inside of an odd space,

00:46:03.850 --> 00:46:07.740
we try to center it
at 1x with 1.5 points,

00:46:07.740 --> 00:46:08.860
so we round it.

00:46:08.950 --> 00:46:12.580
That goes up to two pixels
to have a good appearance.

00:46:12.750 --> 00:46:15.580
But at 2x, well,
we have enough pixels that we can

00:46:15.580 --> 00:46:17.630
actually put it where it belongs.

00:46:17.790 --> 00:46:21.630
So while it's more technically correct,
it's all of a sudden in a different spot.

00:46:21.670 --> 00:46:23.220
It's shifted down a bit.

00:46:23.350 --> 00:46:28.140
And maybe you've already accounted for
that rounding up in your design at 1x,

00:46:28.140 --> 00:46:30.140
and now it looks wrong.

00:46:31.600 --> 00:46:33.900
Just for completeness,
here's the equivalent example

00:46:33.900 --> 00:46:37.370
of an odd-sized item inside
of an even-sized space.

00:46:37.400 --> 00:46:39.560
It shifts down again.

00:46:40.170 --> 00:46:40.650
So what do we do?

00:46:40.650 --> 00:46:43.530
How do we see these things?

00:46:43.530 --> 00:46:47.250
The easiest way to see these things
really is to just look at it.

00:46:47.260 --> 00:46:52.090
I mean, you can do a lot of math,
but testing is going to be your key here.

00:46:53.760 --> 00:46:55.800
If you have two displays,
it's really the easiest.

00:46:55.800 --> 00:47:00.800
If you can set one at 1x and one at 2x,
then you can just drag your window back

00:47:00.800 --> 00:47:04.940
and forth between the two displays and
see how it changes as you move them.

00:47:05.010 --> 00:47:06.730
So the window switches,
as we said before,

00:47:06.740 --> 00:47:10.230
when the window hits the
midpoint of the screen divide.

00:47:10.260 --> 00:47:15.040
When a window has more of its screen,
more of its area on the other screen,

00:47:15.060 --> 00:47:17.760
the window rebuilds to 2x.

00:47:18.110 --> 00:47:19.650
So that's where you can
observe any visual shifts.

00:47:19.810 --> 00:47:23.540
Things should stay at the same spot,
at 2x and 1x.

00:47:23.550 --> 00:47:26.990
And your eye can really
pick those differences out.

00:47:27.190 --> 00:47:30.440
If you only have one display,
don't worry, you can still do this.

00:47:30.550 --> 00:47:33.300
Take screenshots in both modes.

00:47:33.630 --> 00:47:36.750
And then open them up in preview or any
sort of other image viewer where you can

00:47:36.750 --> 00:47:42.700
line them up in the same spot on screen
and scale the 1X screenshot so you can,

00:47:42.810 --> 00:47:45.460
again, they'll occupy the same
amount of area on screen,

00:47:45.610 --> 00:47:46.570
and then just flip back and forth.

00:47:46.680 --> 00:47:49.490
And you can see those same
kind of visual shifts.

00:47:49.940 --> 00:47:52.870
So here's an example of a pixel shift.

00:47:52.910 --> 00:47:55.540
This is a button with
a glyph inside of it.

00:47:55.590 --> 00:47:57.900
And here it is at 1x,
but obviously scaled up

00:47:57.940 --> 00:47:59.400
a bit so you can see it.

00:47:59.460 --> 00:48:01.990
And I'm going to flip it to 2x.

00:48:02.620 --> 00:48:04.500
So it's subtle, but it moved.

00:48:04.630 --> 00:48:05.540
It moved up.

00:48:05.740 --> 00:48:08.960
I'm going to flip back and forth a bit,
and you can see it.

00:48:09.780 --> 00:48:11.870
And while if you're just
sitting there at 2x,

00:48:11.870 --> 00:48:16.350
you may not see these sort of things,
but it means your layout is wrong,

00:48:16.350 --> 00:48:18.290
your UI is incorrect.

00:48:18.400 --> 00:48:21.030
And especially if your
user flips back and forth,

00:48:21.240 --> 00:48:23.770
they're going to notice
these kinds of things.

00:48:24.670 --> 00:48:26.580
So where's the problem here?

00:48:26.690 --> 00:48:30.130
Well, this time it actually
might be the design.

00:48:30.220 --> 00:48:33.950
If you can redesign the 1X
appearance to eliminate these odd

00:48:33.950 --> 00:48:41.680
inside of even sort of situations,
that's really the best thing

00:48:41.680 --> 00:48:41.680
to do because then you get to
have correct math at 2X as well.

00:48:41.750 --> 00:48:45.400
If you can't change that because of
legacy concerns or historical reasons,

00:48:45.400 --> 00:48:49.400
or maybe you just like it better,
you might have to introduce 2X

00:48:49.400 --> 00:48:51.810
specific code just to handle this.

00:48:53.650 --> 00:48:58.260
So you can experiment with
the rounding direction.

00:48:58.260 --> 00:49:01.940
There's a method backing
aligned rect and options.

00:49:01.940 --> 00:49:04.130
You pass it in a rect and it
gives you back a rect that's

00:49:04.130 --> 00:49:05.820
aligned on the backing coordinates.

00:49:05.880 --> 00:49:09.140
It's not exactly -- it hasn't
changed coordinate spaces,

00:49:09.140 --> 00:49:11.500
but it's aligned on a good pixel grid.

00:49:11.500 --> 00:49:18.360
And the options that flag that you pass
in provide you explicit control about

00:49:18.360 --> 00:49:18.360
how it's rounded in each direction.

00:49:19.390 --> 00:49:23.270
So, but if that doesn't work,
you may have to add a half a point or

00:49:23.270 --> 00:49:28.290
one pixel if you've got it in pixel
space explicitly when running at 2X.

00:49:28.470 --> 00:49:31.080
But as you might tell,
this is a little fragile and not

00:49:31.080 --> 00:49:34.910
exactly the cleanest code in the world,
so really do this only

00:49:35.040 --> 00:49:36.960
if absolutely necessary.

00:49:38.550 --> 00:49:40.260
So scale factors.

00:49:40.260 --> 00:49:43.240
We've given you a couple cases
in this session alone about where

00:49:43.240 --> 00:49:46.760
scale factors are important,
but there are some cases --

00:49:46.940 --> 00:49:50.410
but we want to caution you
from overusing scale factors.

00:49:50.620 --> 00:49:53.290
So some background on
coordinate spaces first.

00:49:53.530 --> 00:49:55.720
We talked a little bit about
the back-end coordinate space,

00:49:55.720 --> 00:49:56.940
but there's some other ones.

00:49:57.030 --> 00:50:09.520
Cocoa actually has a lot of them.

00:50:10.680 --> 00:50:10.690
Each NSWindow, NSView, CA Layer,
bitmap context that you might have,

00:50:10.690 --> 00:50:10.690
and OpenGL context, they each have their
own coordinate space.

00:50:10.960 --> 00:50:13.500
To talk about positions,
you have to convert

00:50:13.590 --> 00:50:14.380
between one or the other.

00:50:14.550 --> 00:50:16.610
And it may seem like a lot of work,
but by dealing in the

00:50:16.610 --> 00:50:20.560
correct coordinate space,
your code actually stays cleaner.

00:50:21.480 --> 00:50:24.030
And the best part is the scale
factor is already accounted

00:50:24.130 --> 00:50:26.710
for in all of these contexts.

00:50:28.020 --> 00:50:30.900
So when you want to convert
things from one area to another,

00:50:30.900 --> 00:50:33.570
let's say you've got a view,
you want to go to a different view,

00:50:33.700 --> 00:50:36.410
you use Convert Rect to View,
and there's also Convert

00:50:36.530 --> 00:50:38.010
Point and Convert Size.

00:50:39.190 --> 00:50:41.440
If you want to have a view
go to a window coordinates,

00:50:41.440 --> 00:50:44.250
you use convert_rect_to_view again,
but you pass in a nil view,

00:50:44.350 --> 00:50:46.940
and that will get you the
base window coordinates.

00:50:47.070 --> 00:50:50.240
This is also when you have something
like an NS event location window,

00:50:50.240 --> 00:50:52.570
you get the point back from an NS event.

00:50:52.940 --> 00:50:56.400
That's in window base coordinates,
so you can convert that from the

00:50:56.400 --> 00:51:01.110
nil view to get your point back
in your view's coordinate space.

00:51:01.270 --> 00:51:03.750
So if you have an NS window,
you want to take something like a point

00:51:03.800 --> 00:51:08.600
or a rec to the NS screen that it's on,
you can use convert rec to screen.

00:51:08.710 --> 00:51:13.480
And NS view to its hosted CA layer,
you can use convert rec to layer.

00:51:15.800 --> 00:51:18.130
And again, we mentioned this before,
but if you have anything and you want to

00:51:18.170 --> 00:51:22.090
take it to its backing coordinate space,
you can use Convert Rect to Backing.

00:51:22.580 --> 00:51:25.000
So where don't you want
to use scale factors?

00:51:25.000 --> 00:51:27.640
Let's say I'm drawing
something in my DrawRect,

00:51:27.640 --> 00:51:32.290
and I really want to get something on
a pixel boundary or pixel coordinate.

00:51:32.400 --> 00:51:38.490
Well, I can take my frame or my
bounds and get my window scale

00:51:38.490 --> 00:51:38.490
factor and do some math myself.

00:51:38.950 --> 00:51:40.830
But this is actually not going
to work out in a couple cases.

00:51:40.930 --> 00:51:43.700
You don't--if you're in a layer or if
you're in some other kind of context,

00:51:43.720 --> 00:51:47.900
you've got some other scaling applied,
and it's also going to be dependent on

00:51:47.900 --> 00:51:50.290
the window that you're drawing into.

00:51:50.920 --> 00:51:54.790
So the better thing to do is, again,
use these convert back to backing calls,

00:51:54.810 --> 00:51:56.460
and that will give you your pixel origin.

00:51:56.650 --> 00:52:02.060
Just applying your window scale
factor is not usually the best case.

00:52:03.440 --> 00:52:05.500
So some tips with first scale factors.

00:52:05.500 --> 00:52:06.870
Work in points wherever possible.

00:52:06.880 --> 00:52:09.540
It makes your code cleaner and simpler.

00:52:10.540 --> 00:52:14.600
And be prepared for fractional points
and positions at 2x because they're okay.

00:52:14.600 --> 00:52:18.580
If you're at 3.5 points,
that's actually 7 pixels.

00:52:18.630 --> 00:52:19.700
You're still aligned.

00:52:19.700 --> 00:52:21.370
You're okay.

00:52:21.770 --> 00:52:24.430
And you want to convert any coordinates
and sizes that you use to the

00:52:24.550 --> 00:52:26.800
appropriate space before using them.

00:52:26.800 --> 00:52:30.800
Even NSView to NSView,
even if they're in the same parent view,

00:52:30.960 --> 00:52:34.900
because they may have special
view-specific transforms.

00:52:34.980 --> 00:52:40.060
And if you can get by,
don't ask for the current scale factor.

00:52:40.150 --> 00:52:42.480
But if you absolutely need to, again,
some of the cases that we've

00:52:42.570 --> 00:52:45.580
discussed in this advanced session,
use your current window or

00:52:45.580 --> 00:52:48.090
the tightest context you can.

00:52:48.160 --> 00:52:50.700
If you don't have a window
or screen that you can use,

00:52:50.700 --> 00:52:52.720
you can ask for its current scale factor.

00:52:52.970 --> 00:52:54.390
It might be time to rethink your design.

00:52:54.400 --> 00:52:57.760
Because again, some cases where you
have 1x and a 2x display,

00:52:57.760 --> 00:52:59.450
what is the right answer there?

00:52:59.550 --> 00:53:02.270
It's hard to say.

00:53:03.500 --> 00:53:05.620
Okay, and I'm going to hand
it back to Patrick here.

00:53:05.690 --> 00:53:08.120
He's going to talk
about onscreen content.

00:53:09.360 --> 00:53:10.790
Thank you, Dan.

00:53:12.300 --> 00:57:50.200
[Transcript missing]

00:57:50.910 --> 00:57:53.530
Now, the difference here,
and this is the important point,

00:57:53.600 --> 00:57:55.680
is you need to calculate
that image's size.

00:57:55.710 --> 00:57:57.460
Because it's a CG image
you're getting back,

00:57:57.470 --> 00:57:59.940
that is not going to be -- its
size and its width and height

00:57:59.940 --> 00:58:02.260
are not going to be in points,
rather it's going to be

00:58:02.300 --> 00:58:03.410
an image space or pixels.

00:58:03.550 --> 00:58:06.880
So in order to create an appropriate
image with that CG image,

00:58:06.880 --> 00:58:12.680
you actually need to convert from
backing to compute that size in points.

00:58:12.810 --> 00:58:17.660
And you need to do that with the screen
object that you captured from in order

00:58:17.660 --> 00:58:21.620
to get the right result so that you get
whether it's a 1X screen or a 2X screen,

00:58:21.620 --> 00:58:23.760
you take that into account appropriately.

00:58:23.810 --> 00:58:25.710
Here's a little tip.

00:58:25.710 --> 00:58:30.650
If you saw the CG display ID, well,
how do you get there from AppKit?

00:58:30.650 --> 00:58:33.840
Well, it turns out if you ask the
NSScreen for its device description,

00:58:33.970 --> 00:58:35.970
ask that for an object
for key NSScreen number,

00:58:35.970 --> 00:58:40.420
it turns out that that is magically and
very usefully the CG direct display ID.

00:58:40.420 --> 00:58:44.720
So you can use that to sort of connect
the dots in the sequence of APIs.

00:58:44.780 --> 00:58:45.170
Okay.

00:58:45.170 --> 00:58:49.640
Now, talking a little bit about app
performance under high resolution.

00:58:49.640 --> 00:58:51.430
Really, I'm not going to go into
this nitty-gritty like,

00:58:51.430 --> 00:58:52.420
you know, code techniques.

00:58:52.500 --> 00:58:54.880
I'm really just going to talk about
the philosophy of performance under

00:58:54.880 --> 00:58:58.120
high resolution and give you some
sort of general parameters here.

00:58:58.120 --> 00:59:00.440
So first and foremost,
the thing to remember

00:59:00.440 --> 00:59:04.130
with these products here,
with this particular product especially,

00:59:04.170 --> 00:59:06.610
is your application is going
to be processing four as many

00:59:06.620 --> 00:59:09.900
as seven times the amount of
pixels under high resolution.

00:59:09.900 --> 00:59:13.080
The 7X, of course,
comes from these wonderful new expanded

00:59:13.080 --> 00:59:16.300
desktop high resolution downscaling
modes that you can get to where

00:59:16.590 --> 00:59:19.000
it goes up to 1920 by 1200 at 2X.

00:59:19.150 --> 00:59:22.240
So that's a lot of pixels.

00:59:22.240 --> 00:59:23.580
And you might come away
from that thinking,

00:59:23.580 --> 00:59:26.780
how can anything ever possibly be
fast if you have that much more?

00:59:26.780 --> 00:59:29.160
It's almost an order of
magnitude more pixel content.

00:59:29.160 --> 00:59:30.560
What's going to go on?

00:59:30.560 --> 00:59:33.430
Well, I'd like to give you the message,
don't despair.

00:59:33.510 --> 00:59:34.600
The hardware is there.

00:59:34.600 --> 00:59:37.010
The hardware,
especially on these new products,

00:59:37.010 --> 00:59:39.970
is more than capable of handling it,
as can be evidenced if you

00:59:40.030 --> 00:59:41.500
have a chance to play with it.

00:59:41.500 --> 00:59:44.780
Even the most aggressive system
animations that we do and scrolling

00:59:44.780 --> 00:59:48.140
and a lot of dynamic behaviors,
it's more than able to handle

00:59:48.140 --> 00:59:51.480
that without even breaking a
sweat and getting out of low power

00:59:51.480 --> 00:59:53.200
states or anything like that.

00:59:53.200 --> 00:59:56.400
In particular,
the key thing that we have discovered

00:59:56.400 --> 01:00:00.210
while developing this product is
that most often performance problems

01:00:00.350 --> 01:00:03.320
are not because you're hitting some
fundamental hardware limitation.

01:00:03.320 --> 01:00:04.990
Obviously,
I want to say here there are cases

01:00:05.030 --> 01:00:08.810
where if you're like a game or really
aggressively focused on GPU programming

01:00:08.880 --> 01:00:12.040
where obviously the hardware is going
to be your bottleneck and there's

01:00:12.040 --> 01:00:13.680
special considerations for that.

01:00:13.680 --> 01:00:15.790
But if you're just a
regular Cocoa application,

01:00:15.810 --> 01:00:19.520
it's typically not the case that
you're going to be fundamentally

01:00:19.550 --> 01:00:21.840
limited by the hardware.

01:00:21.840 --> 01:00:24.640
And most important is to make sure
that your application actually

01:00:24.640 --> 01:00:28.080
leverages the system graphics
technologies as much as possible.

01:00:28.080 --> 01:00:30.930
Make sure that when you are profiling
your application that you're spending

01:00:30.930 --> 01:00:33.910
most of your time asking the system
to do work for you rather than like

01:00:33.910 --> 01:00:37.140
waiting for one of your threads
to give a response to the other

01:00:37.340 --> 01:00:39.560
one and just waiting around a lot.

01:00:39.580 --> 01:00:42.680
Typically we've looked at a lot of
applications and it's usually some sort

01:00:42.680 --> 01:00:47.320
of choreography problem rather than a
fundamental software hardware limitation.

01:00:47.320 --> 01:00:50.300
Another thing I want to point out
on the topic of performance is

01:00:50.300 --> 01:00:53.040
be aware of time space tradeoffs.

01:00:53.040 --> 01:00:56.080
Because of this significantly
larger amount of pixels that

01:00:56.320 --> 01:00:59.760
your application is processing,
some caching strategies that may

01:00:59.810 --> 01:01:03.720
have been advantageous under standard
resolution may no longer be advantageous

01:01:04.130 --> 01:01:07.620
under high resolution because now
that you have to suddenly not only

01:01:07.670 --> 01:01:11.730
cache 2X sized images but you might
also have to cache both 1X and 2X to

01:01:11.730 --> 01:01:13.760
be able to handle any possible display,
it may now,

01:01:13.770 --> 01:01:19.450
and especially with the fan-to-fan,
it may now be advantageous to render

01:01:19.450 --> 01:01:24.390
all the time and stop caching.

01:01:24.440 --> 01:01:28.990
It's a pretty big change and you may
want to revisit the base assumptions

01:01:29.000 --> 01:01:33.170
of some of your caching strategies
and make sure that it still fits.
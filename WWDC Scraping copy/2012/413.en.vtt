WEBVTT

00:00:09.590 --> 00:00:10.900
Good afternoon.

00:00:11.200 --> 00:00:12.140
I'm Malcolm Crawford.

00:00:12.140 --> 00:00:13.500
I work for Developer Publications.

00:00:13.500 --> 00:00:16.350
Welcome to Migrating
to Modern Objective-C.

00:00:16.880 --> 00:00:25.640
Consider an unfortunate developer
who tragically went into a coma

00:00:25.640 --> 00:00:30.490
in 2005 at the height of his game.

00:00:31.310 --> 00:00:36.830
Miraculously, a few weeks ago,
he came to.

00:00:36.870 --> 00:00:40.140
It wasn't miraculous that he came to,
it was miraculous that he managed

00:00:40.140 --> 00:00:43.800
to come to at exactly the right
moment to get a WWDC ticket.

00:00:45.140 --> 00:00:50.600
So, he's here now, and obviously,
as he regained consciousness,

00:00:50.600 --> 00:00:56.630
many thoughts went through his mind,
but eventually,

00:00:57.080 --> 00:01:00.520
he came to the really important issues.

00:01:04.790 --> 00:01:07.930
What's happened to Objective-C?

00:01:07.980 --> 00:01:10.460
Why?

00:01:10.460 --> 00:01:15.140
And perhaps most importantly,
how do I use it?

00:01:15.140 --> 00:01:17.640
So, in addition to just
thinking of Rip Van and S.

00:01:17.640 --> 00:01:19.540
Winkle,
think about this yourselves as well,

00:01:19.540 --> 00:01:26.900
as you're looking at code that you
might have had for the better part

00:01:26.900 --> 00:01:26.900
of a decade or more that might be
improved in some way or another.

00:01:28.720 --> 00:01:32.590
The agenda is as follows.

00:01:32.600 --> 00:01:35.900
To start,
we'll consider a bit of philosophy.

00:01:35.900 --> 00:01:38.600
Think about why it is that
some things have changed.

00:01:38.790 --> 00:01:42.010
Then we'll just start looking
at code to see what code you

00:01:42.040 --> 00:01:46.670
might have written some time ago,
what we'd expect you to do now, and why.

00:01:47.160 --> 00:01:49.680
So,
to start off with some of the philosophy,

00:01:49.680 --> 00:01:51.820
Objective-C certainly has evolved.

00:01:51.870 --> 00:01:55.160
Originally,
it was just a thin layer atop of C.

00:01:55.160 --> 00:01:58.260
Now, it is still atop C,
but there's much more to it.

00:01:58.260 --> 00:02:00.280
It's certainly not such
a thin layer anymore.

00:02:02.730 --> 00:02:05.730
If you sort of start looking at some
of the things that RIP might look at,

00:02:05.730 --> 00:02:09.650
there's a whole load of other
features that have come into play,

00:02:09.740 --> 00:02:12.100
different patterns and
that sort of thing.

00:02:12.210 --> 00:02:15.290
In general, and you might have seen
this slide elsewhere before,

00:02:15.410 --> 00:02:20.300
this fits in with our general
evolution of Objective-C as a language.

00:02:20.430 --> 00:02:24.030
Starting from pure C,
we've added object orientation

00:02:24.030 --> 00:02:28.600
on top and these other features
to progress it in the direction

00:02:28.600 --> 00:02:31.170
of making it simpler and safer.

00:02:32.380 --> 00:02:34.540
Together with these
changes in the language,

00:02:34.640 --> 00:02:38.540
then, have come changes in the way
that we use the language,

00:02:38.540 --> 00:02:40.890
the way that we use the environment,
and so on.

00:02:40.990 --> 00:02:43.970
In particular, then,
some of the conventions

00:02:43.970 --> 00:02:45.770
that we use have evolved.

00:02:45.780 --> 00:02:49.240
And this is really important because
Cocoa has very strong conventions.

00:02:49.240 --> 00:02:54.020
You know pretty quickly if somebody
isn't following the right conventions.

00:02:54.020 --> 00:02:56.300
We talk about fighting
the framework and so on.

00:02:57.170 --> 00:02:59.440
In general, again,
we hope that the new features

00:02:59.440 --> 00:03:03.800
are making your code simpler,
more compact, and so on,

00:03:03.800 --> 00:03:04.880
in addition to being safer.

00:03:04.880 --> 00:03:11.170
But we're also moving in the direction,
then, of building some of the conventions

00:03:11.200 --> 00:03:15.840
that previously you just had to know
about actually into the language.

00:03:15.840 --> 00:03:18.290
And in particular,
into the language so that you

00:03:18.350 --> 00:03:19.990
don't have to think about them.

00:03:20.000 --> 00:03:23.440
The philosophical coder here,
a quote from Bertrand

00:03:23.470 --> 00:03:25.700
Russell's thesis supervisor.

00:03:25.700 --> 00:03:27.100
You don't get much more philosophical.

00:03:27.120 --> 00:03:29.190
in that.

00:03:29.620 --> 00:03:33.830
The goal is to reduce
the number of mundane,

00:03:33.940 --> 00:03:37.730
repetitive things that
you have to consider,

00:03:37.730 --> 00:03:40.940
so that you can concentrate
on the interesting code that

00:03:40.940 --> 00:03:43.570
differentiates your application.

00:03:44.130 --> 00:03:49.000
So, by way of warming up,
a couple of trivial little aspects.

00:03:49.000 --> 00:03:54.300
Importing headers, fairly mundane thing,
but you might see, from a while back,

00:03:54.460 --> 00:03:56.000
code that looks like this.

00:03:56.170 --> 00:04:00.430
You might import individual headers
files for individual classes.

00:04:00.580 --> 00:04:03.000
You might forward declare
classes and so on,

00:04:03.140 --> 00:04:09.000
possibly in some effort to make things
easier for the compiler or whatever.

00:04:09.060 --> 00:04:09.640
Don't do that.

00:04:09.640 --> 00:04:11.900
It doesn't actually make
things easier for the compiler.

00:04:12.080 --> 00:04:15.360
The appropriate thing to do now
is simply import the umbrella

00:04:15.360 --> 00:04:16.890
header for the framework.

00:04:17.320 --> 00:04:20.010
Straightforward enough,
it also reduces then the cognitive

00:04:20.010 --> 00:04:23.000
load on you in maintaining
the list of import statements.

00:04:23.000 --> 00:04:25.020
So, trivial start.

00:04:25.990 --> 00:04:29.520
That all came into play a while back,
something much more recent,

00:04:29.520 --> 00:04:32.290
and again a small change,
but a useful one.

00:04:32.610 --> 00:04:35.500
Enums of fixed underlying type.

00:04:35.590 --> 00:04:38.090
Historically,
we might have had enums that

00:04:38.090 --> 00:04:39.970
were declared rather like this.

00:04:40.520 --> 00:04:41.230
standard C.

00:04:41.370 --> 00:04:47.410
We tried to make things rather better by
indicating their type with a type def.

00:04:47.450 --> 00:04:50.560
But this doesn't give you an
awful lot of help when you are

00:04:50.620 --> 00:04:52.680
actually writing your code.

00:04:52.680 --> 00:04:57.890
Adopting the new pattern means you
actually get compiler help or Xcode

00:04:58.140 --> 00:05:01.050
help with code completion and so on.

00:05:01.060 --> 00:05:06.020
So you can be guaranteed then that the
constant that you use in a particular

00:05:06.020 --> 00:05:08.580
situation is an appropriate one.

00:05:08.580 --> 00:05:11.100
So small but useful increment.

00:05:11.100 --> 00:05:15.500
Moving on to rather bigger issues and
perhaps rather more contentious issues.

00:05:15.500 --> 00:05:16.620
Accessor methods.

00:05:16.620 --> 00:05:20.030
Start off by looking at the
use of accessor methods.

00:05:20.170 --> 00:05:24.360
In this example,
you can see that following

00:05:24.380 --> 00:05:28.430
appropriate conventions,
we're using the accessor

00:05:28.670 --> 00:05:32.560
method for the area property.

00:05:32.560 --> 00:05:34.250
This is appropriate.

00:05:34.250 --> 00:05:37.770
Almost certainly,
given what we'll see in a moment,

00:05:37.770 --> 00:05:40.080
the area property is a derived property.

00:05:40.080 --> 00:05:44.070
If you try to access it directly,
it won't exist.

00:05:44.420 --> 00:05:51.210
Have a look, though,
at the surrounding context.

00:05:51.210 --> 00:05:51.210
There are memory management methods.

00:05:51.360 --> 00:05:55.750
Dealing with memory management methods
in this scenario is almost certainly

00:05:55.750 --> 00:05:58.100
going to lead to problems at some stage.

00:05:58.170 --> 00:06:01.970
You'll forget to put a method in,
put an extra method in, or whatever.

00:06:01.980 --> 00:06:06.270
Using accessor methods
pervasively gives you safer code.

00:06:06.270 --> 00:06:09.180
You're less likely to make a mistake.

00:06:09.180 --> 00:06:12.730
Moreover, it's the appropriate thing to
do for following encapsulation.

00:06:12.740 --> 00:06:19.140
You don't necessarily know what the side
effects might be of any accessor method.

00:06:19.190 --> 00:06:22.660
Using accessor methods pervasively
insulates you from those.

00:06:22.800 --> 00:06:25.070
Quick aside,
I said we were doing contentious.

00:06:25.070 --> 00:06:27.540
It's also possible to
use dot syntax in these.

00:06:27.770 --> 00:06:31.490
That's as much as I'm going to say.

00:06:31.970 --> 00:06:33.800
Personal preference.

00:06:33.800 --> 00:06:38.450
Having used square brackets for a
little bit more than two decades now,

00:06:38.450 --> 00:06:42.300
I'm actually fine with .syntax,
but personal preference.

00:06:42.300 --> 00:06:44.790
If you don't like it, don't use it.

00:06:45.040 --> 00:06:49.540
The important thing is
always use accessor methods,

00:06:49.720 --> 00:06:52.140
except -- and we'll come
back to this in a bit -- in

00:06:52.140 --> 00:06:55.550
initializer methods and dialog.

00:06:55.980 --> 00:06:58.420
Another favorite subject,
memory management.

00:06:58.420 --> 00:07:01.960
We just touched on that in the preceding.

00:07:02.090 --> 00:07:05.160
Memory management has
always been a thorny issue.

00:07:05.260 --> 00:07:09.800
I'll abide by my own dictum
of not repeating the rules.

00:07:10.040 --> 00:07:13.760
I hope you will appreciate, though,
that the code shown here

00:07:13.760 --> 00:07:16.860
does abide by the rules.

00:07:17.010 --> 00:07:20.340
So does this code.

00:07:20.520 --> 00:07:23.700
So does this code.

00:07:24.440 --> 00:07:30.280
Choosing between them is more
stuff for you to think about.

00:07:30.800 --> 00:07:34.010
Hopefully, though, if you're sufficiently
familiar with the rules,

00:07:34.010 --> 00:07:36.780
it becomes second nature,
and you don't think about it too much

00:07:36.780 --> 00:07:39.850
until you get to a situation like this.

00:07:40.340 --> 00:07:44.780
If you start removing objects
from a collection and using them,

00:07:44.780 --> 00:07:49.450
now you're not necessarily sure
of the lifetime of that object.

00:07:49.630 --> 00:07:53.060
This is a pattern that perhaps over time,
and with a certain amount of debugging,

00:07:53.060 --> 00:07:54.800
you get to recognize.

00:07:54.870 --> 00:07:57.510
And you realize then that
this is the sort of thing that

00:07:57.620 --> 00:07:59.220
you've got to do in response.

00:07:59.350 --> 00:08:02.020
You must make sure that you claim
ownership of any object that

00:08:02.020 --> 00:08:04.590
you pull out of a collection,
and then relinquish ownership

00:08:04.590 --> 00:08:06.000
after you've finished using it.

00:08:06.050 --> 00:08:06.500
Great.

00:08:06.550 --> 00:08:07.980
Okay, so you learned that.

00:08:08.130 --> 00:08:12.730
Next up, though, we get to a slightly
more complex situation.

00:08:13.850 --> 00:08:16.800
I'll leave a second or two if anybody
can see what the problem is there.

00:08:16.870 --> 00:08:19.100
It's a little bit more tricky
just to follow through there.

00:08:19.100 --> 00:08:22.620
It actually follows pretty much, though,
the same pattern as before.

00:08:25.770 --> 00:08:32.480
The solution to all of these is
simply to switch over to Arc.

00:08:33.810 --> 00:08:37.380
Two other sessions to look at,
one we did yesterday, the other tomorrow,

00:08:37.380 --> 00:08:39.190
to look at adopting Arc.

00:08:39.300 --> 00:08:42.900
If you adopt Arc,
all of the code that you write

00:08:43.440 --> 00:08:48.360
simply works as it should do,
without you having to think about it.

00:08:48.480 --> 00:08:50.590
Modulo, perhaps.

00:08:51.330 --> 00:08:53.870
Interaction with Core Foundation.

00:08:54.080 --> 00:08:59.410
Core Foundation is still a little bit
problematic in that you might have to

00:08:59.410 --> 00:09:06.800
put in casts to indicate to the compiler
what the memory management semantics are,

00:09:07.020 --> 00:09:08.740
whether you're transferring
ownership or whatever.

00:09:09.640 --> 00:09:13.600
In general, a better solution,
if you can find it,

00:09:13.600 --> 00:09:18.080
is to not use Core Foundation objects
in the first place.

00:09:18.080 --> 00:09:24.340
In the case of this example,
instead of CFUUID, we now have NSUUID.

00:09:24.340 --> 00:09:28.450
So,
elevate things to Objective-C objects,

00:09:28.520 --> 00:09:29.780
if you can.

00:09:29.790 --> 00:09:33.570
A quick aside on that, in general,
there's a certain amount of lore

00:09:33.570 --> 00:09:37.030
about why you might want to use
Core Foundation-style objects

00:09:37.030 --> 00:09:39.260
rather than Objective-C objects.

00:09:39.260 --> 00:09:41.140
Most of that is just now lore.

00:09:41.340 --> 00:09:43.240
There is no reason, really,
certainly in terms of

00:09:43.240 --> 00:09:46.190
performance and so on,
to prefer CF-style objects

00:09:46.200 --> 00:09:48.360
over Objective-C objects.

00:09:48.360 --> 00:09:54.880
One of the things that Arc doesn't
prevent you from doing is a sort of thing

00:09:54.880 --> 00:10:00.010
that you were able to do before Arc,
and that's create retain cycles,

00:10:00.020 --> 00:10:04.350
or as we call them now,
strong reference cycles.

00:10:05.310 --> 00:10:09.080
The answer is still exactly
the same as you had before,

00:10:09.080 --> 00:10:15.370
to use an appropriate pattern to include,
for example, weak references.

00:10:16.620 --> 00:10:21.520
Weak references include, say,
from child back to parent objects,

00:10:21.520 --> 00:10:27.620
delegate objects, data source objects,
and so on, should typically be weak.

00:10:27.700 --> 00:10:31.630
So follow the same patterns that
you would have followed if you were

00:10:31.970 --> 00:10:35.490
using manual memory management.

00:10:35.820 --> 00:10:40.060
Now to a rather bigger subject
for a variety of reasons.

00:10:40.390 --> 00:10:43.530
If we have a look at properties,
this is one case where I'll give

00:10:43.540 --> 00:10:45.230
a sort of big before and after.

00:10:45.470 --> 00:10:50.830
Here's code that you or Rip might
have written back in 2005.

00:10:50.890 --> 00:10:52.260
As code, it's fine.

00:10:52.370 --> 00:10:55.850
The left-hand side actually
shows the complete declaration

00:10:56.100 --> 00:10:58.990
of a putative thing class.

00:10:59.160 --> 00:11:06.510
The right-hand side shows the beginning
of the implementation of the thing class.

00:11:06.750 --> 00:11:09.640
As you can see, that pretty much fills
up the whole slide,

00:11:09.650 --> 00:11:12.600
and there's a lot of
implementation missing.

00:11:12.690 --> 00:11:16.500
What we're aiming for is this:

00:11:17.200 --> 00:11:23.300
I hope everyone will agree
that there's less code.

00:11:23.300 --> 00:11:23.300
Trick question.

00:11:23.710 --> 00:11:26.160
It's also, hopefully,
rather more approachable.

00:11:26.250 --> 00:11:31.710
We've got a very clear contract
expressed in the interface,

00:11:31.740 --> 00:11:36.320
and almost nothing then to
write in the implementation.

00:11:36.470 --> 00:11:38.440
Let's drill down into that in detail.

00:11:38.570 --> 00:11:44.460
Start off with the instance variables.

00:11:45.600 --> 00:11:48.470
Historically,
you might have declared the instance

00:11:48.470 --> 00:11:53.120
variables in the interface of a class.

00:11:53.120 --> 00:11:57.320
The trouble with this is that this
is exposing what's really a private

00:11:57.320 --> 00:12:00.180
implementation detail of the class.

00:12:00.180 --> 00:12:03.240
There's no reason why anybody
who's actually using your class

00:12:03.250 --> 00:12:06.900
needs to know what the instance
variables are that it uses.

00:12:07.500 --> 00:12:11.250
Moreover,
it's just space that's taken up in your

00:12:11.250 --> 00:12:16.620
interface for people to read past to
get to the actual interesting stuff.

00:12:16.620 --> 00:12:20.270
You can now,
if you absolutely need to declare

00:12:20.270 --> 00:12:26.740
instance variables independently,
move those to the implementation block.

00:12:26.740 --> 00:12:31.430
So put instance variable declarations
in the @implementation block

00:12:31.430 --> 00:12:35.600
hidden away in your .m file.

00:12:35.600 --> 00:12:35.610
Better still,
you can use the instance variables

00:12:35.890 --> 00:12:38.590
don't declare instance variables at all,
and we'll come back to that

00:12:38.630 --> 00:12:42.800
in the subject of properties,
or the declared properties, in a moment.

00:12:42.980 --> 00:12:45.970
Next up,
the accessor method declarations.

00:12:46.430 --> 00:12:50.390
Again, code that would have been
perfectly fine a decade or so ago,

00:12:50.390 --> 00:12:52.160
now we can do rather better.

00:12:52.160 --> 00:12:55.000
If we start off with
the title declaration,

00:12:55.010 --> 00:12:57.300
there's two lines of code there.

00:12:57.410 --> 00:12:59.690
We can do rather better
in a single line of code,

00:12:59.880 --> 00:13:01.300
rather more expressive.

00:13:01.300 --> 00:13:05.530
You just use a declared property
to replace the two lines of the

00:13:05.530 --> 00:13:08.180
access and method declarations.

00:13:09.260 --> 00:13:11.540
We can actually go a little
bit further than that,

00:13:11.540 --> 00:13:12.100
though.

00:13:12.100 --> 00:13:18.880
Usually, with value-style properties,
you actually want your object

00:13:18.880 --> 00:13:22.080
to have a private copy of those.

00:13:22.200 --> 00:13:28.320
So, simply adding a copy attribute
indicates then that this -- whatever

00:13:28.380 --> 00:13:31.480
value -- if a new value is passed in,
it's going to be copied

00:13:31.490 --> 00:13:33.450
rather than simply owned.

00:13:33.970 --> 00:13:36.190
Concentrate next on the radius.

00:13:36.390 --> 00:13:39.650
Again, we can do a similar thing.

00:13:40.840 --> 00:13:43.460
straightforward replacement
of the two accessor methods.

00:13:43.460 --> 00:13:48.920
We're left, though,
with the declaration of

00:13:48.920 --> 00:13:48.920
the derived property.

00:13:49.860 --> 00:14:00.290
Because it's still a
characteristic of the object,

00:14:00.290 --> 00:14:00.290
it's reasonable then to replace that with

00:14:01.090 --> 00:14:04.490
A Property Declaration as well.

00:14:04.490 --> 00:14:07.200
Now, the audience participation part.

00:14:07.290 --> 00:14:09.510
What's wrong with this?

00:14:10.260 --> 00:14:13.000
They survived through a lot of revisions.

00:14:13.040 --> 00:14:15.720
The default declaration
of a property is atomic.

00:14:15.790 --> 00:14:18.650
So, strictly speaking,
since a property declaration

00:14:18.650 --> 00:14:25.780
represents a contract,
we should add the non-atomic decorator.

00:14:25.920 --> 00:14:29.450
Because our implementation,
that I skipped past rather

00:14:29.450 --> 00:14:33.580
quickly perhaps earlier,
of the area method was not atomic.

00:14:35.000 --> 00:14:37.300
Switch then to delegate.

00:14:37.310 --> 00:14:39.300
Again,
follow the same sort of thing as before,

00:14:39.410 --> 00:14:44.000
but following conventions,
we can now actually specify,

00:14:44.070 --> 00:14:49.170
as part of a declared contract,
that our relationship to the

00:14:49.170 --> 00:14:51.790
delegate is going to be weak.

00:14:52.550 --> 00:14:55.970
That goes through the
method declarations,

00:14:55.970 --> 00:15:00.390
turning then to the implementation
of the accessor methods.

00:15:00.940 --> 00:15:04.940
Again,
a subject that caused endless debate on

00:15:04.980 --> 00:15:08.520
various mailing lists over the years.

00:15:08.580 --> 00:15:12.040
What's the right implementation
of an accessor method?

00:15:12.040 --> 00:15:16.410
Most of the debates ended up missing the
simple fact there isn't any one right

00:15:16.410 --> 00:15:18.580
implementation of an accessor method.

00:15:18.580 --> 00:15:22.430
Exactly how you implement it
depends on what it is that the

00:15:22.430 --> 00:15:24.920
accessor method is intended to do.

00:15:24.920 --> 00:15:29.270
For example, whether you want to copy
a value that's passed in.

00:15:29.360 --> 00:15:33.820
Given the contract that you specify
in the declared property now,

00:15:33.820 --> 00:15:39.010
you can ask the compiler to come up with
the appropriate implementation of the

00:15:39.110 --> 00:15:45.140
accessor method to meet the specification
that you gave in the declared property.

00:15:45.140 --> 00:15:50.970
So, we can represent... We can
replace the entire implementation

00:15:50.970 --> 00:15:54.430
of the accessor method simply
with a synthesize statement.

00:15:55.400 --> 00:15:58.060
One of the things that's been
a little bit in transition,

00:15:58.060 --> 00:16:01.420
though, and another thing that's
been subject of law,

00:16:01.800 --> 00:16:05.430
generally,
we would actually now encourage

00:16:05.450 --> 00:16:09.680
you to prepend instance variable
names with an underscore.

00:16:09.680 --> 00:16:12.610
Now,
let's just clarify something about this.

00:16:12.620 --> 00:16:17.010
This is an instance variable name,
not accessor method name.

00:16:17.020 --> 00:16:23.560
Apple does reserve underscore
prefix for accessor method names,

00:16:23.560 --> 00:16:27.720
not, however,
for instance variable names.

00:16:27.720 --> 00:16:32.590
The reason for prepending an instance
variable name with an underscore is to

00:16:32.590 --> 00:16:37.440
try to dissuade people from accessing
the instance variable directly.

00:16:37.440 --> 00:16:41.260
Remember what I said about using
accessor methods pervasively?

00:16:41.260 --> 00:16:44.380
This is to help people in that direction.

00:16:44.380 --> 00:16:48.050
As a quick tangent on this,
one of the most common mistakes,

00:16:48.060 --> 00:16:51.460
one of the most common reasons for
errors with core data applications

00:16:51.460 --> 00:16:54.040
over the years turns out to have
been because people have been trying

00:16:54.040 --> 00:16:58.780
to access the managed object context
directly using the instance variable.

00:16:58.780 --> 00:17:02.660
And lo and behold,
it's actually not initialized yet,

00:17:02.660 --> 00:17:04.290
so they're accessing a nil value.

00:17:04.300 --> 00:17:06.600
Prepending the instance
variable name with an underscore

00:17:06.600 --> 00:17:08.320
helps mitigate that problem.

00:17:10.130 --> 00:17:18.830
We're actually going a stage further now,
though, with the most recent compiler.

00:17:18.830 --> 00:17:18.830
Using auto-synthesize, we do one better,
and...

00:17:20.250 --> 00:17:21.960
it just goes away completely.

00:17:21.960 --> 00:17:25.120
So, declare the property
and you're done with it.

00:17:25.120 --> 00:17:28.600
Switching to a slightly different area,
but still under the general

00:17:28.600 --> 00:17:32.000
heading of properties,
in some situations you might want

00:17:32.050 --> 00:17:34.320
your object to maintain private state.

00:17:34.320 --> 00:17:37.620
It's not supposed to be
accessed by any other object.

00:17:37.930 --> 00:17:41.490
Putting it into the @interface
declaration is clearly then

00:17:41.490 --> 00:17:43.170
not the right thing to do.

00:17:43.180 --> 00:17:46.500
That's an open invitation then
to people to meddle with it.

00:17:46.500 --> 00:17:52.770
What you can do is, first of all,
replace that with a property declaration.

00:17:52.970 --> 00:17:58.580
You can, though,
move the instance variable declaration

00:17:58.950 --> 00:18:02.700
to the implementation block,
as suggested earlier,

00:18:02.700 --> 00:18:09.280
better still actually provide
a property for that as well.

00:18:09.700 --> 00:18:13.140
Notice in this case,
the property is declared

00:18:13.140 --> 00:18:15.040
in a class extension.

00:18:15.130 --> 00:18:19.510
So the class extension you are
able to hide away in your .m file.

00:18:20.670 --> 00:18:25.750
So, takeaway message:
If you want to keep private state,

00:18:25.750 --> 00:18:29.960
maintain private state,
use a class extension

00:18:29.960 --> 00:18:32.820
hidden away in the .m file.

00:18:33.760 --> 00:18:37.480
A similar thing might
have applied to methods,

00:18:37.630 --> 00:18:39.740
private methods that
you wanted to declare.

00:18:39.740 --> 00:18:43.170
In order to keep the compiler
happy and avoid complaints about

00:18:43.170 --> 00:18:49.720
missing method declarations,
you might in the past have had to declare

00:18:49.720 --> 00:18:55.010
methods in a category in your .m file.

00:18:55.270 --> 00:18:58.500
The problem with this is now you
have to keep this up to date.

00:18:58.500 --> 00:19:00.840
You might actually change your
method name somewhere along the line,

00:19:00.840 --> 00:19:05.380
and now what you've declared in your
private category is out of sync with

00:19:05.450 --> 00:19:07.840
what you've actually implemented.

00:19:07.880 --> 00:19:12.490
A possible way of getting around that
is to then use a class extension.

00:19:12.880 --> 00:19:14.640
This way,
the compiler will actually tell you,

00:19:14.640 --> 00:19:16.660
at least,
if you haven't provided an implementation

00:19:16.660 --> 00:19:20.060
of the methods that you've promised it.

00:19:20.200 --> 00:19:22.100
Better still,

00:19:23.190 --> 00:19:25.490
Again, actually using the latest
version of the compiler,

00:19:25.500 --> 00:19:28.620
you don't need to provide a
forward declaration of methods.

00:19:28.770 --> 00:19:31.000
The compiler will be able
to find them for you anyway.

00:19:31.100 --> 00:19:35.070
So the benefit here is less
work again for you to do in

00:19:35.150 --> 00:19:40.060
maintaining the private category,
maintaining the class extension,

00:19:40.100 --> 00:19:44.080
keeping the declared methods in sync with
the methods you've actually implemented.

00:19:44.100 --> 00:19:47.090
So less work for you to do.

00:19:48.340 --> 00:19:52.780
Further in the direction of
state maintenance and properties,

00:19:52.790 --> 00:19:53.940
outlets.

00:19:53.950 --> 00:19:57.060
Historically,
given the strong conventions that we had,

00:19:57.060 --> 00:20:03.160
outlets were the least well-specified,
least well-understood aspect, perhaps,

00:20:03.250 --> 00:20:04.720
of our entire interface.

00:20:05.320 --> 00:20:09.060
There is nothing in the traditional
declaration of an outlet that

00:20:09.060 --> 00:20:12.290
tells you anything about its
memory management semantics.

00:20:12.290 --> 00:20:15.640
There's nothing that says how
you're expected to use it,

00:20:15.640 --> 00:20:17.060
whether it's supposed to
be a strong reference,

00:20:17.060 --> 00:20:18.260
a weak reference, and so on.

00:20:18.260 --> 00:20:21.650
It's also, again,
exposing a private implementation detail.

00:20:21.650 --> 00:20:25.020
It shouldn't matter to any other
object what outlets you have.

00:20:25.020 --> 00:20:28.200
Instead...

00:20:31.560 --> 00:20:37.890
Now use a property declaration that makes
the memory management semantics explicit.

00:20:38.970 --> 00:20:46.830
At the moment, to help with tool support,
you might well make these

00:20:46.830 --> 00:20:46.830
declarations in the interface block.

00:20:48.260 --> 00:20:51.940
In the future, what we'd actually-- a
big one-- in the .h file,

00:20:51.940 --> 00:20:54.600
in the implement interface
block in the .h file.

00:20:54.640 --> 00:20:56.790
In the future,
what we're actually probably likely

00:20:56.810 --> 00:20:59.840
to do is to move that into a--

00:21:00.490 --> 00:21:06.220
Private Class Extension,
again in the .m file.

00:21:06.550 --> 00:21:09.130
The reason for this is,
for the most part,

00:21:09.230 --> 00:21:14.470
the outlets that you declare are likely
to be a private implementation detail

00:21:14.470 --> 00:21:17.260
of your view controller or whatever.

00:21:17.330 --> 00:21:19.290
Obviously, there may be some that
you need to expose,

00:21:19.320 --> 00:21:22.670
but in general,
whatever clients your view controller

00:21:22.670 --> 00:21:27.850
has should be passing information,
data or whatever,

00:21:27.850 --> 00:21:32.160
to the view controller directly,
rather than accessing the outlets.

00:21:33.700 --> 00:21:41.210
Consider also whether you want a weak
or a strong reference in general.

00:21:42.140 --> 00:21:46.790
Outlets to subviews of a
view controller's main view,

00:21:46.790 --> 00:21:51.590
or to a window controller's window,
are likely to be weak.

00:21:52.460 --> 00:21:58.610
It's the main view or the window that
is expected to manage the lifetime

00:21:58.670 --> 00:22:02.000
of the views contained within it.

00:22:02.120 --> 00:22:05.950
Outlets to top-level objects,
such as the main view itself or

00:22:05.950 --> 00:22:10.510
a window controller's window,
should be strong.

00:22:10.730 --> 00:22:14.320
Switching to other things that
weren't particularly tidy in the past,

00:22:14.320 --> 00:22:17.700
a variety of different ways
have been used over the years

00:22:17.700 --> 00:22:19.800
of implementing init methods.

00:22:19.800 --> 00:22:21.400
Here's one example.

00:22:21.400 --> 00:22:24.060
Historically,
we might have invoked the superclass's

00:22:24.160 --> 00:22:29.480
designated initializer and done a
test to see if you got a value return.

00:22:29.710 --> 00:22:31.760
More recent implementations
of the compiler actually

00:22:31.830 --> 00:22:34.930
provided a warning on this,
so we changed that then to add an

00:22:34.930 --> 00:22:38.340
additional pair of parentheses,
just to confuse people

00:22:38.550 --> 00:22:41.360
who looked at it and said,
"This is clearly a mistake,

00:22:41.360 --> 00:22:44.680
isn't it?" No,
it was to keep the compiler happy.

00:22:44.710 --> 00:22:47.800
Instead, adopt now the -- oh,
I beg your pardon.

00:22:47.800 --> 00:22:49.000
There was another thing to call out here.

00:22:49.000 --> 00:22:54.000
Also notice, typically in the past,
you've used accessor methods

00:22:54.010 --> 00:22:58.700
to initialize values in
an initializer method.

00:22:58.700 --> 00:23:01.900
Again, don't want to do that.

00:23:01.900 --> 00:23:07.000
In an initializer method,
the state of your object is not defined.

00:23:07.000 --> 00:23:11.300
It hasn't been fully initialized yet.

00:23:11.340 --> 00:23:15.720
To be safe, therefore,
don't invoke accessor methods.

00:23:15.810 --> 00:23:18.650
Simply set property values
directly if you need to.

00:23:18.700 --> 00:23:22.980
And then this is a new pattern that
we recommend for the implementation

00:23:22.980 --> 00:23:25.250
of the initializer method itself.

00:23:26.350 --> 00:23:31.370
For dialog, again,
historically you might well

00:23:31.370 --> 00:23:34.640
have used accessor methods.

00:23:35.190 --> 00:23:38.330
The object during a dialog method is
in the process of being torn down.

00:23:38.390 --> 00:23:40.540
Its state is not fully determined.

00:23:40.650 --> 00:23:44.630
So don't use accessor
methods in the dialog either.

00:23:45.990 --> 00:23:48.730
Message the instance variable directly.

00:23:48.920 --> 00:23:53.020
Ideally, of course, if you use Arc,
you don't have to worry

00:23:53.020 --> 00:23:55.000
about this at all anyway.

00:23:55.130 --> 00:23:58.900
Moving away from properties onto
a different subject entirely,

00:23:58.900 --> 00:24:03.740
something that's somewhat small,
but in some respects rather profound.

00:24:03.850 --> 00:24:04.450
Protocols.

00:24:04.520 --> 00:24:10.600
Protocols provide a mechanism for
formalizing communication channels.

00:24:10.720 --> 00:24:13.600
Imagine, for example,
that you're hiring a butler,

00:24:13.680 --> 00:24:15.780
as I'm sure many of you are.

00:24:16.280 --> 00:24:20.670
butlers, as I'm sure you're aware,
have a variety of roles or tasks

00:24:20.740 --> 00:24:22.980
that you might want them to perform.

00:24:23.230 --> 00:24:25.780
Obviously,
they need to be able to make tea,

00:24:25.910 --> 00:24:27.430
serve sandwiches.

00:24:27.520 --> 00:24:32.340
A rather unusual thing that you might ask
a butler to do would be to mow the lawn.

00:24:32.560 --> 00:24:36.530
If you had a reference to
a butler as a property,

00:24:37.280 --> 00:24:42.150
You might then want to impose
your will on the butler and say,

00:24:42.150 --> 00:24:45.790
"If you used a formal protocol,
you're specifying then that

00:24:45.790 --> 00:24:51.790
the butler must mow the lawn."
That's a rather heavy imposition.

00:24:52.980 --> 00:24:56.350
It might be rather difficult
to get a butler that's also

00:24:56.350 --> 00:24:58.270
willing to mow the lawn.

00:24:58.600 --> 00:25:02.730
To sort of work around that,
we introduced the idea

00:25:02.730 --> 00:25:04.610
of -- historically,
there'd been the idea

00:25:04.780 --> 00:25:06.720
of informal protocols.

00:25:06.810 --> 00:25:12.360
An informal protocol is simply a
list of methods that are declared

00:25:12.360 --> 00:25:15.070
on a category of NSObject.

00:25:15.980 --> 00:25:19.770
The problem here is instead
of being overly specific,

00:25:19.780 --> 00:25:21.860
now we're under-specific, as it were.

00:25:21.920 --> 00:25:24.060
We haven't sufficiently well
specified what we're actually

00:25:24.060 --> 00:25:25.690
expecting the butler to do.

00:25:25.790 --> 00:25:30.540
The only thing that we can say is
the butler is likely to be an object.

00:25:30.590 --> 00:25:32.860
We're not actually making
any demands of them at all,

00:25:32.860 --> 00:25:37.330
or specifying the sorts of tasks that
we're actually expecting of them.

00:25:37.980 --> 00:25:42.100
The advance that was made
with protocols was to add

00:25:42.470 --> 00:25:45.940
optional methods in a protocol.

00:25:46.090 --> 00:25:48.800
Now we can say we are going
to require our butler to make

00:25:48.800 --> 00:25:50.440
tea and serve sandwiches.

00:25:50.500 --> 00:25:54.940
It's up to them, however,
whether they're willing to mow the lawn,

00:25:55.010 --> 00:25:59.200
which puts far less constraints
on the sort of object then that

00:25:59.200 --> 00:26:03.330
we're expecting to be a butler,
but also still allows us to be

00:26:03.330 --> 00:26:06.570
quite specific in our expectations.

00:26:06.730 --> 00:26:14.310
So, again, we're getting a much clearer
establishment of an API contract here.

00:26:15.210 --> 00:26:20.150
So, any places where in your code at the
moment you might be using an informal

00:26:20.150 --> 00:26:24.740
protocol to provide a list of methods,
now move across to using formal

00:26:24.740 --> 00:26:28.010
protocols with optional methods,
if appropriate.

00:26:28.020 --> 00:26:30.350
Places where these
particularly come into play,

00:26:30.350 --> 00:26:33.150
you'll have seen these in data
source and delegate methods,

00:26:33.150 --> 00:26:36.120
particularly in table views and so on,
on both platforms.

00:26:36.600 --> 00:26:40.690
On iOS in particular,
you might have seen these used

00:26:40.690 --> 00:26:45.220
as a communication channel
between a view controller and

00:26:45.220 --> 00:26:47.800
its parent view controller.

00:26:47.900 --> 00:26:52.060
So you're encouraged to use
formal protocols to define the

00:26:52.170 --> 00:26:57.000
communication channel between view
controllers in an iOS application.

00:26:57.050 --> 00:27:02.360
Other smaller but hopefully -- I believe,
actually, welcome features that save

00:27:02.360 --> 00:27:05.490
an awful lot on typing,
the new support for

00:27:05.490 --> 00:27:07.600
collections and literals.

00:27:07.670 --> 00:27:12.310
Historically, you'd have written code
that looks like this.

00:27:12.930 --> 00:27:18.480
rather long-winded code to
create a number as an object,

00:27:18.480 --> 00:27:23.320
to create a dictionary or an array,
other collections and so on.

00:27:23.420 --> 00:27:26.860
If you're creating an
array or a dictionary,

00:27:26.860 --> 00:27:28.200
two problems.

00:27:28.200 --> 00:27:31.590
First of all, you have to remember to
end your list with nil.

00:27:31.600 --> 00:27:35.200
The compiler actually reminds
you now if you make that mistake.

00:27:35.200 --> 00:27:38.200
Secondly, if you're creating a
dictionary specifically,

00:27:38.200 --> 00:27:42.590
you have to remember to put your
keys and values in the wrong order.

00:27:47.400 --> 00:27:52.100
I suspect that most people have
discovered now that the compiler now

00:27:52.320 --> 00:27:57.060
supports number and collection literals,

00:27:57.220 --> 00:28:03.490
Which considerably reduce the amount
of code that you have to write,

00:28:03.490 --> 00:28:03.490
and again make it safer,

00:28:04.150 --> 00:28:10.620
in that there's no requirement now to
terminate your initializer with a nil,

00:28:11.150 --> 00:28:14.590
and you get to put your,
in the case of the dictionary,

00:28:15.280 --> 00:28:19.180
Keys and values in the right order.

00:28:19.230 --> 00:28:22.180
Just one example that I was
particularly happy with myself,

00:28:22.200 --> 00:28:26.090
this came out of a sample
code that I was updating,

00:28:26.090 --> 00:28:31.260
and so the code went from this to this.

00:28:31.260 --> 00:28:36.120
Oh, an applaud.

00:28:36.120 --> 00:28:36.120
Thank you.

00:28:38.420 --> 00:28:41.360
I'll take that on behalf
of the compiler team.

00:28:41.470 --> 00:28:44.450
So thank you very much to them
for providing these features.

00:28:44.550 --> 00:28:45.540
There are additional features.

00:28:45.540 --> 00:28:49.400
So subscripting then makes some
of the other code that you might

00:28:49.400 --> 00:28:52.100
have written to deal with arrays
and dictionaries rather easier.

00:28:52.100 --> 00:28:55.780
So extracting values and replacing
values become rather easier,

00:28:55.780 --> 00:28:58.670
and hopefully the syntax is more
amenable to people coming from

00:28:58.670 --> 00:29:00.900
other environments and so on.

00:29:00.900 --> 00:29:05.850
So arrays and dictionaries.

00:29:06.060 --> 00:29:09.140
I certainly find it easier now
to use the latter in the case of

00:29:09.140 --> 00:29:12.070
setting a value for the dictionary.

00:29:12.420 --> 00:29:15.760
The compiler team also provided,
a while back,

00:29:15.790 --> 00:29:20.680
better ways of enumerating over
the contents of collections.

00:29:21.180 --> 00:29:26.150
Historically, you might have written
rubbish code like this.

00:29:26.860 --> 00:29:30.030
In particular,
this tends to crop up a lot,

00:29:30.030 --> 00:29:33.560
invoking count on each
time around the array,

00:29:33.560 --> 00:29:37.840
which isn't very good.

00:29:37.960 --> 00:29:41.000
But you're still left,
even when you do that properly,

00:29:41.000 --> 00:29:41.000
you have to hoist out a
separate count variable.

00:29:41.380 --> 00:29:45.610
You're still left within the
body of the enumeration with the

00:29:45.630 --> 00:29:50.290
task of actually pulling out the
value that you're interested in.

00:29:50.390 --> 00:29:52.620
Any code that you see

00:29:52.820 --> 00:29:57.180
Like that,
replace now with fast enumeration.

00:29:57.220 --> 00:30:01.330
As the name suggests, first of all,
it's fast.

00:30:01.420 --> 00:30:03.090
It's also a more compact syntax.

00:30:03.100 --> 00:30:08.690
It saves you from having to declare
local variables separately and so on.

00:30:08.850 --> 00:30:14.030
So, in addition to being more compact,
it's also considerably more efficient.

00:30:14.170 --> 00:30:18.250
However, potentially in some situations,

00:30:19.020 --> 00:30:26.770
The for-in syntax,
the fast enumeration syntax,

00:30:26.770 --> 00:30:26.770
may not be quite as general as you want.

00:30:27.000 --> 00:30:29.900
There are some situations in which you
want a little bit more flexibility.

00:30:29.900 --> 00:30:32.310
It's also perhaps sometimes
a little bit difficult to add

00:30:32.310 --> 00:30:36.500
support for fast enumeration
to your own classes and so on.

00:30:36.620 --> 00:30:42.000
To address that and other issues,
we now have blocks.

00:30:42.580 --> 00:30:47.200
To illustrate that,
consider what you might have used in the

00:30:47.200 --> 00:30:52.160
past to sort the contents of an array.

00:30:52.600 --> 00:30:57.140
Historically, you might have used sorted
arrays using function and passed

00:30:57.290 --> 00:31:00.370
in a reference to a function.

00:31:00.910 --> 00:31:06.270
The problem here is now you have
a reference to a function that you

00:31:06.270 --> 00:31:10.710
have to implement somewhere else,
outside of the scope of the

00:31:11.020 --> 00:31:14.410
actual use of that sort operation.

00:31:14.420 --> 00:31:17.990
So somewhere you have to think about,
well, what did I actually want

00:31:17.990 --> 00:31:19.300
to do in that context?

00:31:19.300 --> 00:31:20.840
How do I implement sort function?

00:31:20.840 --> 00:31:24.760
And especially if you actually want to
make use of any contextual information,

00:31:24.760 --> 00:31:28.000
you've got to pass that in through
a rather unpleasant void star.

00:31:29.030 --> 00:31:31.000
Instead,

00:31:31.330 --> 00:31:37.720
You can now use the-- you should
now use the block-based API

00:31:38.390 --> 00:31:42.200
Which has the advantage
then of being in place.

00:31:42.370 --> 00:31:48.340
You get to implement the sort function
exactly where it is that you're using it.

00:31:48.700 --> 00:31:57.230
If we go back to the issue of
enumerating the contents of the array,

00:31:57.230 --> 00:31:57.230
it also

00:31:57.660 --> 00:32:03.550
means that you have access to
additional local information,

00:32:03.720 --> 00:32:04.600
like the actual index.

00:32:04.680 --> 00:32:05.960
of the object that you're looking at.

00:32:06.060 --> 00:32:09.550
So if for some reason you need
to actually get at the index of

00:32:09.550 --> 00:32:13.140
the item that you're looking at,
you have access to that now

00:32:13.140 --> 00:32:14.900
within the block as well.

00:32:17.230 --> 00:32:21.900
This is particularly handy
in the case of dictionaries.

00:32:22.080 --> 00:32:26.700
With a dictionary,
the fast enumeration gave you all

00:32:26.700 --> 00:32:28.500
of the keys in the dictionary.

00:32:28.500 --> 00:32:34.690
It was still up to you, however,
to extract the corresponding objects.

00:32:34.790 --> 00:32:38.880
If you switch this over to
using the block-based API,

00:32:39.160 --> 00:32:43.950
you're conveniently given both key
and object at the same time without

00:32:43.950 --> 00:32:46.150
having to do additional work.

00:32:46.860 --> 00:32:50.960
A place where blocks have had a
somewhat more profound impact still

00:32:51.040 --> 00:32:55.750
is in what you might call callbacks.

00:32:56.810 --> 00:33:00.700
If you consider the way that you
might use a notification center,

00:33:00.710 --> 00:33:05.700
historically,
you'd have added an object as an observer

00:33:05.820 --> 00:33:11.320
and told the notification center the
name of the method that you want to be

00:33:11.330 --> 00:33:14.170
invoked if this notification occurs.

00:33:14.360 --> 00:33:16.410
First of all, that's error-prone.

00:33:16.520 --> 00:33:20.300
You must make sure that you get
the name of your selector correct.

00:33:20.420 --> 00:33:23.760
Secondly, again,
you're left with the problem of having

00:33:23.760 --> 00:33:29.990
to implement the method somewhere else,
outside of the context of

00:33:30.070 --> 00:33:32.200
where you're actually using it.

00:33:32.330 --> 00:33:38.740
Better now, switch that code over to
using the block-based API.

00:33:39.090 --> 00:33:42.150
With a block-based API,
you get to implement the

00:33:42.150 --> 00:33:45.640
callback in exactly this place
that you actually use it.

00:33:45.790 --> 00:33:48.620
Moreover, again,
because it's block-based,

00:33:48.870 --> 00:33:54.550
you get to use any additional
contextual information that you wanted.

00:33:54.550 --> 00:33:54.550
As a bonus,

00:33:54.940 --> 00:34:00.150
One of the perennial problems
with notifications was getting

00:34:00.150 --> 00:34:05.800
notifications on a queue or thread that
you weren't expecting to get them on.

00:34:05.920 --> 00:34:09.590
With block-based API, you get to say,
I want to have this delivered to me on,

00:34:09.590 --> 00:34:12.160
typically, the main queue,
the main thread.

00:34:12.160 --> 00:34:14.900
So if you need to update
the user interface,

00:34:15.020 --> 00:34:16.040
you get it on the right place.

00:34:16.040 --> 00:34:19.920
Sorry for finishing off on one caveat.

00:34:19.920 --> 00:34:25.190
One thing to call out, though,
is be careful in blocks of

00:34:26.330 --> 00:34:32.210
capturing strong references to
self and setting up retain cycles.

00:34:33.310 --> 00:34:36.940
A pattern you can use here
is to create a local weak

00:34:37.400 --> 00:34:39.820
reference to self and use that.

00:34:39.830 --> 00:34:44.640
So, to wrap up,
for more information about all of this,

00:34:44.780 --> 00:34:46.850
talk to Michael Jurowicz.

00:34:47.270 --> 00:34:51.040
There are several sessions,
two of which have already happened.

00:34:51.110 --> 00:34:55.970
There is also now a new document
that actually describes -- well,

00:34:56.040 --> 00:34:59.090
hopefully everybody is adopting all
of the latest features and using

00:34:59.090 --> 00:35:02.250
the latest version of Xcode anyway,
but if you do need to support a

00:35:02.250 --> 00:35:06.580
particular version of the tools,
there's now a document that tells

00:35:06.580 --> 00:35:11.390
you what features are available in
which particular release of the tools.

00:35:11.530 --> 00:35:15.540
The important thing, though,
is adopt these new features.

00:35:15.600 --> 00:35:18.370
They'll make your code better
and give you less to type.

00:35:18.410 --> 00:35:19.960
Thank you.
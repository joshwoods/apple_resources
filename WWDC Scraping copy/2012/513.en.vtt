WEBVTT

00:00:11.100 --> 00:02:17.100
[Transcript missing]

00:02:17.830 --> 00:02:20.440
So in OS X, it's a very similar picture.

00:02:20.440 --> 00:02:25.210
We have OpenGL 2 and
OpenGL 3 core profile.

00:02:25.220 --> 00:02:30.360
And so OpenGL core profile also allows
you to basically take advantage of

00:02:30.360 --> 00:02:33.000
the newest GPUs in your systems.

00:02:33.000 --> 00:02:36.740
And also today we're,
or this week we've been saying

00:02:36.740 --> 00:02:39.590
that GLKit is now on Mountain Lion.

00:02:39.600 --> 00:02:44.510
So that basically enables you to
quickly get your OpenGL 2 apps

00:02:44.610 --> 00:02:47.640
running on OpenGL 3 core profile.

00:02:47.640 --> 00:02:51.720
By utilizing like the effects libraries
and the math that's built into that.

00:02:54.450 --> 00:02:58.920
So today, we're going to be going over
some new extensions in iOS 6,

00:02:58.920 --> 00:03:01.660
so like programmable blending for one.

00:03:01.660 --> 00:03:06.590
Then we're also going to go into
GLKit and do a quick refresh of that.

00:03:06.810 --> 00:03:11.540
It's already been in iOS 5,
but on Mountain Lion, it's new on OS X,

00:03:11.540 --> 00:03:14.340
so we'll get into how it works on OS X.

00:03:16.440 --> 00:03:19.610
And then finally,
we'll be going into supporting the

00:03:19.680 --> 00:03:21.750
MacBook Pro with Retina displays.

00:03:21.750 --> 00:03:25.040
So with that, I'm going to hand it
off to Allan Schaffe,

00:03:25.040 --> 00:03:28.370
our graphics and game
technologies evangelist.

00:03:28.380 --> 00:03:29.760
Allan Schaffe, Graphics and
Game Technologies Evangelist Thank you,

00:03:29.760 --> 00:03:30.380
Chris, and hello, everyone.

00:03:30.380 --> 00:03:30.840
Good afternoon.

00:03:30.840 --> 00:03:33.670
So, you know,
there's this point we've been sort of

00:03:33.720 --> 00:03:38.180
making here at the conference that among
a lot of the really leading-edge games,

00:03:38.180 --> 00:03:41.520
it's become less and less common
for them to just simply render

00:03:41.640 --> 00:03:44.320
OpenGL scenes and have that be
what's displayed on the screen.

00:03:44.320 --> 00:03:47.750
And, you know,
what's really become a lot more common

00:03:47.750 --> 00:03:52.320
now is for games to be composing
their scenes through multiple passes,

00:03:52.320 --> 00:03:57.820
like, you know,
rendering a particular pass,

00:03:57.850 --> 00:04:00.920
sampling that texture in the next
pass in their fragment program,

00:04:00.950 --> 00:04:04.470
and so on, and then compositing the
results together at the end.

00:04:04.480 --> 00:04:08.030
That's just, that's really become the
meta trend that is going on.

00:04:08.120 --> 00:04:11.630
And this first extension goes
right to the heart of that.

00:04:11.750 --> 00:04:13.540
So let's talk about
programmable blending.

00:04:14.500 --> 00:04:17.280
And I'll start with the
graphics pipeline itself.

00:04:17.280 --> 00:04:20.720
No surprise to anyone, I'm sure,
who's in this room that

00:04:20.800 --> 00:04:24.090
we start with a teapot,
go through the, you know,

00:04:24.240 --> 00:04:27.130
go through the transform
and lighting stage,

00:04:27.130 --> 00:04:29.950
the output of that,
then the spans and fragments get

00:04:29.950 --> 00:04:34.000
iteratively rasterized and go into
the fragment stage of the pipeline.

00:04:34.000 --> 00:04:38.130
Output of that goes through
a depth and stencil test.

00:04:38.310 --> 00:04:41.290
Anything that is,
that survives that then goes through

00:04:41.290 --> 00:04:44.280
blending and eventually out to your,
to your game.

00:04:44.280 --> 00:05:02.420
And then the output of that
goes through your destination,

00:05:02.940 --> 00:05:13.780
usually the color render buffer.

00:05:14.230 --> 00:05:14.260
Right?

00:05:14.260 --> 00:05:15.880
And the nomenclature of the destination.

00:05:15.880 --> 00:05:19.520
Then there is some function
that is being applied to each

00:05:19.520 --> 00:05:21.960
of those colors that it's read.

00:05:21.980 --> 00:05:25.560
Some product is created and
then the two are added together.

00:05:25.560 --> 00:05:28.000
That becomes the final color
and it's written back out

00:05:28.100 --> 00:05:29.440
to the destination again.

00:05:29.440 --> 00:05:30.200
Right?

00:05:30.200 --> 00:05:31.910
That's how typical blending works.

00:05:32.040 --> 00:05:37.940
But so what's changing in iOS 6 is that
your applications now have the ability to

00:05:38.100 --> 00:05:44.220
effectively ignore the built-in blending
stage and just directly read values.

00:05:44.370 --> 00:05:50.320
So, you can see that the And this
ends up being really,

00:05:50.320 --> 00:05:51.090
really powerful.

00:05:51.100 --> 00:05:54.990
Because there's a lot of things
now that you can do in a fragment

00:05:55.110 --> 00:06:00.110
shader that just weren't built into
the standard blending operations.

00:06:00.120 --> 00:06:02.560
So, let's start taking a
look at how this works.

00:06:02.680 --> 00:06:06.820
There's a new built-in
variable called GLFragDataSub0.

00:06:06.820 --> 00:06:09.250
It's going to provide you
with the current frame

00:06:09.700 --> 00:06:11.280
buffer color for that pixel.

00:06:11.280 --> 00:06:14.180
But back in your fragment shader,
you can just actually read the color.

00:06:14.260 --> 00:06:15.220
You can access it.

00:06:15.220 --> 00:06:16.220
It's something that you can read.

00:06:16.220 --> 00:06:18.130
And then you do your own math on it.

00:06:18.230 --> 00:06:21.220
And then finally you write
out your color just normally.

00:06:21.470 --> 00:06:26.220
This is provided on all of the
devices that support iOS 6.

00:06:26.470 --> 00:06:30.350
And it's worth just mentioning
it can actually coexist with

00:06:30.350 --> 00:06:34.520
the built-in blending if you
had some reason to use both.

00:06:34.760 --> 00:06:36.890
Now, here's an example shader.

00:06:36.940 --> 00:06:41.420
So I'm starting out just by saying, okay,
I intend to use this extension,

00:06:41.420 --> 00:06:42.780
shader framebuffer fetch.

00:06:42.870 --> 00:06:48.730
And you can see I have a color that's
coming in from the vertex stage.

00:06:49.280 --> 00:06:52.070
Now, just here's a couple of different
things you might do with it.

00:06:52.070 --> 00:06:56.610
So here, if I had a decal, for example,
this might be the blending operation

00:06:56.710 --> 00:06:58.010
that I would do for a decal.

00:06:58.030 --> 00:07:02.840
I would be taking all of the source
color and then one minus the alpha

00:07:02.840 --> 00:07:05.840
multiplied by the destination color.

00:07:05.840 --> 00:07:08.170
And that would give
me a decal-type blend,

00:07:08.170 --> 00:07:08.760
right?

00:07:08.760 --> 00:07:11.080
Let's look at one that's
a little more advanced,

00:07:11.080 --> 00:07:11.580
though.

00:07:11.580 --> 00:07:14.640
Because obviously you can go
beyond just the built-in stuff.

00:07:14.700 --> 00:07:18.280
So here, for example,
would be a difference blend.

00:07:18.920 --> 00:07:22.890
So I'm subtracting the destination
color from the source color and

00:07:22.890 --> 00:07:25.270
taking the absolute value of that.

00:07:25.400 --> 00:07:27.280
And that becomes my output color.

00:07:27.280 --> 00:07:30.040
And what's cool here, you start to see.

00:07:30.410 --> 00:07:34.440
So there's no built-in blending
functions that have absolute

00:07:34.520 --> 00:07:36.770
value as one of the operations.

00:07:36.780 --> 00:07:40.840
So you can do this here because
it's in your fragment shader.

00:07:40.970 --> 00:07:44.200
You get to use all the
standard syntax of GLSL.

00:07:44.500 --> 00:07:45.840
Let's go even further.

00:07:45.960 --> 00:07:50.510
So some of these things like a
difference blend or a hard light

00:07:50.610 --> 00:07:54.110
blend and so on are things you
might see in photography packages.

00:07:54.250 --> 00:07:58.950
But now you can implement those things
directly into your GL-based apps.

00:07:59.960 --> 00:08:04.440
Now, ignoring the math here, you know,
a hard light blend looks at the color.

00:08:04.440 --> 00:08:07.440
It sees to see if it's less than 0.5.

00:08:07.440 --> 00:08:11.570
If so, we take 2 times the source
times the destination.

00:08:11.660 --> 00:08:16.660
Otherwise, if it's greater than 0.5,
then we take 1 minus all of

00:08:16.970 --> 00:08:18.800
this product that's there.

00:08:19.040 --> 00:08:20.910
Okay,
but the point of this isn't the math.

00:08:20.940 --> 00:08:23.230
This is just,
that's the hard light shader.

00:08:23.240 --> 00:08:27.720
But it's the fact that look at these
different operations that we could do.

00:08:27.720 --> 00:08:29.840
I showed you absolute value
on the previous slide.

00:08:29.840 --> 00:08:31.580
Here is a branch, right?

00:08:31.590 --> 00:08:36.080
So we have a conditional here that's
going to take two different values

00:08:36.230 --> 00:08:41.080
depending on the actual color that could
be sitting either in the destination

00:08:41.090 --> 00:08:43.750
already or coming in from the source.

00:08:43.840 --> 00:08:48.080
So and then down here,
we just fill out our color values.

00:08:48.080 --> 00:08:50.630
Okay, so pretty cool extension.

00:08:50.630 --> 00:08:55.110
Let's take it even one step
further than what I've shown you.

00:08:56.860 --> 00:09:00.910
You could use this to do
local post-processing on your

00:09:00.910 --> 00:09:03.400
entire frame if you wanted to.

00:09:03.400 --> 00:09:06.630
So in this example,
you could kind of think

00:09:06.720 --> 00:09:07.970
of this in a few steps.

00:09:08.030 --> 00:09:11.070
Step one would be to draw
your entire scene normally

00:09:11.070 --> 00:09:12.980
into the color render buffer.

00:09:12.980 --> 00:09:16.960
Then step two,
the last thing you draw that

00:09:16.960 --> 00:09:21.480
frame could be a full-screen
quad with a shader attached.

00:09:21.480 --> 00:09:26.340
And this might be the shader,
where it's going to essentially sample

00:09:26.340 --> 00:09:30.940
the destination values for every pixel,
and then just do some full, you know,

00:09:30.940 --> 00:09:34.190
for every single one,
do an operation on that.

00:09:34.240 --> 00:09:37.960
So here, the operation I just chose,
because it's nice and short,

00:09:37.970 --> 00:09:40.090
it fits on the slide,
is to convert whatever

00:09:40.090 --> 00:09:41.670
the color is to grayscale.

00:09:41.670 --> 00:09:42.080
Right?

00:09:42.230 --> 00:09:43.580
And so that's what I'm doing here.

00:09:43.580 --> 00:09:48.880
I'm calculating a luminance value by
multiplying each channel of the current

00:09:48.880 --> 00:09:52.610
destination color by those values,
and then applying that

00:09:52.620 --> 00:09:55.290
luminance into red,
green, and blue.

00:09:55.320 --> 00:09:56.060
Right?

00:09:56.760 --> 00:10:00.430
So -- but if you think about this,
this is more efficient than, for example,

00:10:00.570 --> 00:10:01.900
rendering to texture.

00:10:01.900 --> 00:10:05.460
And you get to take
advantage of pipelining here.

00:10:05.560 --> 00:10:08.650
This shader just happens
to be the last one that you

00:10:08.650 --> 00:10:10.730
would execute for that frame.

00:10:10.740 --> 00:10:16.410
There's nothing special that you have
to do as a post-processing effect.

00:10:16.740 --> 00:10:20.370
Now, so we've already gone
pretty far with this.

00:10:20.420 --> 00:10:23.200
One more,
some more directions that you can

00:10:23.200 --> 00:10:27.940
kind of take and discuss with us on
your own as far as going even further.

00:10:27.940 --> 00:10:31.240
I mentioned some of these
unique blends that we can do,

00:10:31.320 --> 00:10:34.120
you know,
things like hard light and different

00:10:34.220 --> 00:10:36.180
kind of photographic effects.

00:10:36.470 --> 00:10:41.640
You could use this to do custom overlays
and kind of more atmospheric lighting

00:10:41.800 --> 00:10:44.320
kind of conditions in your scene.

00:10:46.040 --> 00:10:49.280
But then one I didn't show,
but just think about this.

00:10:49.530 --> 00:10:53.610
You could sample the current
color in the destination,

00:10:53.610 --> 00:10:57.750
read that back, and use the RGB values to
do a lookup and a texture,

00:10:57.750 --> 00:10:58.840
right?

00:10:58.840 --> 00:11:02.170
And then take that and go
further with that value.

00:11:02.180 --> 00:11:07.640
We imagine people could use that,
for example, for color grading in an

00:11:07.640 --> 00:11:09.700
OpenGL app or OpenGL ES.

00:11:09.760 --> 00:11:16.020
You know, going even further,
you could be storing non-color data.

00:11:16.020 --> 00:11:19.380
In the destination.

00:11:19.460 --> 00:11:21.400
And you might be sampling that.

00:11:21.420 --> 00:11:25.420
For example, you might have normals that
are being stored there,

00:11:25.480 --> 00:11:30.250
and you're reading those back and using
that to kind of construct a G buffer.

00:11:30.260 --> 00:11:32.620
There's, you know,
or calculate things like

00:11:32.710 --> 00:11:34.440
ambient occlusion and so on.

00:11:34.750 --> 00:11:37.440
There's a lot of these effects
now that aren't going to require

00:11:37.440 --> 00:11:38.930
an extra pass to come back.

00:11:39.060 --> 00:11:42.120
They can just be directly
done in that first pass.

00:11:42.120 --> 00:11:45.130
Okay, so that is extension number one.

00:11:46.000 --> 00:11:49.270
and it's programmable blending.

00:11:49.720 --> 00:11:50.310
Next.

00:11:50.310 --> 00:11:53.010
This one is a little more advanced.

00:11:53.010 --> 00:11:55.350
But I'm going to go through it.

00:11:55.350 --> 00:12:01.470
And so there's different audiences who
kind of might be interested in this.

00:12:01.550 --> 00:12:03.200
Let's talk about different audiences,
though.

00:12:03.480 --> 00:12:06.000
So, you know,
most games that we see on the

00:12:06.000 --> 00:12:10.050
App Store today are just loading all
of their textures and they're done.

00:12:10.050 --> 00:12:14.270
They either have just only a few textures
or only a few and that fits just fine.

00:12:14.350 --> 00:12:17.990
Or the developer has gone through
a trial and error of like,

00:12:18.060 --> 00:12:19.030
okay, that was too much.

00:12:19.030 --> 00:12:19.940
I'm going to reduce it.

00:12:19.940 --> 00:12:22.550
And they finally get it down
into something that works.

00:12:22.790 --> 00:12:24.240
That's most games.

00:12:24.240 --> 00:12:27.160
This extension is not for you.

00:12:27.260 --> 00:12:32.220
Now, some games are managing
textures fully dynamically.

00:12:32.220 --> 00:12:37.240
They're doing something like maybe
it's a game with different levels

00:12:37.250 --> 00:12:41.390
and they are loading and deleting
games as they -- excuse me.

00:12:41.390 --> 00:12:45.880
Loading and deleting textures as
they go from one level to the next.

00:12:45.880 --> 00:12:48.000
So that's another possibility.

00:12:48.020 --> 00:12:50.740
And so, this extension is not for you.

00:12:50.740 --> 00:12:54.900
Finally, we almost -- we have a
couple of guys in the room.

00:12:54.900 --> 00:12:55.580
Okay.

00:12:55.580 --> 00:12:57.130
Who are left now?

00:12:57.190 --> 00:13:02.840
There's a few games who are -- that
are doing really fully dynamic texture

00:13:02.840 --> 00:13:07.020
management where the concept that
they're adhering to is that they

00:13:07.020 --> 00:13:11.840
kind of keep a texture budget to
a particular size during run time.

00:13:12.150 --> 00:13:14.320
And then perhaps it's a 3D game.

00:13:14.320 --> 00:13:17.420
And as they move around in the scene,
whatever objects they're close to

00:13:17.500 --> 00:13:21.340
or they're the ones that they make
sure those textures are loaded.

00:13:21.340 --> 00:13:25.300
And then as things get further away,
maybe those are the first ones that get

00:13:25.420 --> 00:13:28.200
replaced for something that's closer.

00:13:28.200 --> 00:13:31.580
And they're dynamically loading
and deleting those textures as

00:13:31.620 --> 00:13:33.980
they move around in the scene.

00:13:33.980 --> 00:13:37.170
And the request that folks like that
have had is that they actually want

00:13:37.170 --> 00:13:39.640
to take it even further than that.

00:13:39.640 --> 00:13:43.540
They want to have fine-grained
control over essentially over the

00:13:43.540 --> 00:13:45.480
mipmap levels and everything else.

00:13:45.480 --> 00:13:47.740
They want to do some really clever stuff.

00:13:47.740 --> 00:13:52.380
And so, this extension is all about them.

00:13:52.760 --> 00:13:56.900
So the concept of this is it's
going to be for games that do

00:13:56.900 --> 00:14:00.080
really dynamic texture management.

00:14:00.080 --> 00:14:04.000
We're providing some new extensions
for that that are going to let you

00:14:04.000 --> 00:14:06.460
very quickly create texture storage.

00:14:06.460 --> 00:14:10.060
And once you've created storage,
to be able to copy data very

00:14:10.300 --> 00:14:13.580
quickly between different
elements of that storage.

00:14:13.580 --> 00:14:19.320
And what this enables is what
I call a texture swap algorithm.

00:14:19.410 --> 00:14:23.180
And, you know,
the idea that's going on is that what

00:14:23.240 --> 00:14:27.680
the game might be doing is sort of,
okay, I'm getting closer to some object.

00:14:27.680 --> 00:14:30.060
I have it loaded at a
particular resolution.

00:14:30.060 --> 00:14:34.390
And I kind of wish that I could
load an even higher resolution base

00:14:34.390 --> 00:14:37.040
level for that particular texture.

00:14:37.040 --> 00:14:39.530
And then, meanwhile,
I've gotten further away

00:14:39.530 --> 00:14:41.940
from something else,
so I kind of want to demote

00:14:41.940 --> 00:14:43.560
it to a smaller base level.

00:14:43.580 --> 00:14:47.420
And that's really what this
is going to let people do.

00:14:47.420 --> 00:14:50.000
So there's two extensions
that are involved here,

00:14:50.030 --> 00:14:51.880
texture storage and texture copy.

00:14:51.880 --> 00:14:54.700
So we'll start with texture storage.

00:14:54.710 --> 00:14:56.440
This sets up the memory, essentially.

00:14:56.440 --> 00:14:59.890
So texture storage,
new extension to iOS 6,

00:15:00.070 --> 00:15:03.490
lets you create an
immutable texture object.

00:15:03.590 --> 00:15:06.570
So how it works is that
in essentially one call,

00:15:06.570 --> 00:15:09.370
you can define all of
the texture properties,

00:15:09.440 --> 00:15:14.260
and then after that,
just nothing changes except... except for

00:15:14.340 --> 00:15:18.400
the actual texture contents themselves,
perhaps.

00:15:18.400 --> 00:15:22.740
And so, all of the memory allocation and
all of the completeness check

00:15:22.740 --> 00:15:26.660
that the implementation has to
do can all be done upfront rather

00:15:26.760 --> 00:15:30.840
than kind of waiting for the first
time that you go draw something.

00:15:30.840 --> 00:15:34.560
The way that you -- and then I said
everything except for the texture data.

00:15:34.830 --> 00:15:38.210
It starts out with some
just default data in there.

00:15:38.730 --> 00:15:42.920
But you define the data through
subloads rather than regular

00:15:43.080 --> 00:15:45.090
calls to GLTech image 2D.

00:15:45.090 --> 00:15:49.230
This is supported on all of
our devices that support iOS 6.

00:15:49.230 --> 00:15:51.550
I think I'm going to
show a code sample next.

00:15:51.780 --> 00:15:52.130
Yep.

00:15:52.130 --> 00:15:54.430
So, here is a quick code sample.

00:15:54.430 --> 00:15:58.580
So, at first,
it's the same as you'd be familiar with.

00:15:58.580 --> 00:16:00.620
We gen and bind texture.

00:16:00.620 --> 00:16:01.870
Now here's the new call.

00:16:01.900 --> 00:16:04.170
So,
we're defining and allocating the texture

00:16:04.170 --> 00:16:06.550
storage by calling GLTech storage 2D.

00:16:06.550 --> 00:16:09.200
We're passing in sort of
normal arguments here.

00:16:09.380 --> 00:16:10.620
The target, the number of calls,
the number of calls.

00:16:10.620 --> 00:16:10.620
And then we're going to call the texture.

00:16:10.620 --> 00:16:10.900
And then we're going to call the texture.

00:16:10.900 --> 00:16:11.310
And then we're going to call the texture.

00:16:11.310 --> 00:16:13.140
And then we're going
the number of levels,

00:16:13.340 --> 00:16:15.560
the format, width, and height.

00:16:15.600 --> 00:16:19.120
But now once you call this,
the texture is there, it's ready to go.

00:16:19.250 --> 00:16:23.450
And the way that we load data
into it is to iterate through

00:16:23.600 --> 00:16:28.690
each level of the texture and do
subloads of the data into that.

00:16:29.060 --> 00:16:32.440
So that's kind of part one
of this texture swap idea,

00:16:32.440 --> 00:16:36.340
is just creating essentially temporary
textures that you can swap into.

00:16:36.410 --> 00:16:41.480
The second part of a swap, of course,
is copying from one thing to another.

00:16:41.480 --> 00:16:47.250
So we use this new extension,
copy texture levels, to do that.

00:16:47.690 --> 00:16:52.140
And so what this provides, again,
is a really fast copy of

00:16:52.140 --> 00:16:56.630
the mipmap levels that you
specify between two textures.

00:16:56.640 --> 00:16:59.020
But the thing is,
I said that a little bit --

00:16:59.020 --> 00:17:02.080
the way I said that may have
been a little misleading.

00:17:02.230 --> 00:17:07.150
It's not the levels that you specify,
but it's really that you specify based

00:17:07.190 --> 00:17:12.460
more on the dimensions of the levels
that you are copying back and forth from.

00:17:12.640 --> 00:17:15.860
So, for example,
two different textures might have a

00:17:16.030 --> 00:17:18.420
different number of levels between them.

00:17:18.700 --> 00:17:21.160
And you're saying, okay,
I want to copy level, you know,

00:17:21.270 --> 00:17:23.820
0 through 10 of 1,
and that's going to get us

00:17:23.970 --> 00:17:26.270
from 1 by 1 to 512 by 512.

00:17:26.280 --> 00:17:30.220
And it's going to copy it
into the corresponding levels

00:17:30.220 --> 00:17:32.520
of the destination texture.

00:17:32.520 --> 00:17:34.780
So it's very cool and
actually really powerful.

00:17:34.780 --> 00:17:37.540
And it's going to enable this
texture swap algorithm that

00:17:37.540 --> 00:17:39.000
we've been talking about.

00:17:39.090 --> 00:17:42.200
It only does this copy
between immutable textures,

00:17:42.200 --> 00:17:46.010
meaning between that new
extension that I just showed you.

00:17:46.050 --> 00:17:51.040
And this also supported across
all the devices that run iOS 6.

00:17:51.270 --> 00:17:57.600
Now, so let's go into how this
algorithm would actually work.

00:17:57.650 --> 00:18:00.480
Let's just pretend that
this is your situation.

00:18:00.580 --> 00:18:03.290
You have a texture budget
that you are maintaining.

00:18:03.290 --> 00:18:06.690
And you've decided that, all right,
at any given time,

00:18:06.690 --> 00:18:09.780
I'm going to have these
15 textures loaded.

00:18:09.780 --> 00:18:12.860
All of them are at least 512 by 512.

00:18:12.860 --> 00:18:16.300
But the three things
that are closest to me,

00:18:16.300 --> 00:18:21.080
I'd like to have those have
textures that are 1K by 1K.

00:18:21.200 --> 00:18:25.200
And I'm going to dynamically manage
which is which as I go along.

00:18:25.380 --> 00:18:28.350
Now, behind the scenes,
every single one of these

00:18:28.350 --> 00:18:30.280
boxes is also a mipmap texture.

00:18:30.280 --> 00:18:31.200
Okay?

00:18:31.200 --> 00:18:33.970
So the grand total budget
here would be 32 megabytes,

00:18:33.970 --> 00:18:34.560
roughly.

00:18:34.560 --> 00:18:40.470
And if these were non-mipmap,
then it would be down about 24 megabytes.

00:18:41.090 --> 00:18:46.260
So let's say that we run around our
scene and at some point we decide,

00:18:46.520 --> 00:18:49.300
all right,
the object that has the red texture

00:18:49.300 --> 00:18:52.860
on it is now close enough to me
that I would like to promote it.

00:18:52.980 --> 00:18:55.840
I want it to be represented
with a 1K by 1K texture.

00:18:55.840 --> 00:18:59.600
And the object with the blue one,
it's far enough away,

00:18:59.760 --> 00:19:02.100
that's the one I'm going to replace.

00:19:02.160 --> 00:19:04.720
And so I'm going to do a swap.

00:19:05.240 --> 00:19:08.330
So let me show you the
mipmap levels now for those.

00:19:08.550 --> 00:19:11.740
So here's each texture
plus its mipmap levels.

00:19:11.980 --> 00:19:15.230
And we're going to get
started with this swap now.

00:19:15.300 --> 00:19:18.620
So the first part of a swap is
to create a temporary variable,

00:19:18.630 --> 00:19:19.240
right?

00:19:19.470 --> 00:19:22.180
But here it's a whole temporary texture.

00:19:22.400 --> 00:19:30.980
And so I'm genning and binding and then
calling GLTextStorage2D to create a

00:19:30.980 --> 00:19:30.980
temporary texture to swap levels into.

00:19:31.180 --> 00:19:32.100
All right.

00:19:32.140 --> 00:19:34.360
Now I'm going to copy -- next thing.

00:19:34.450 --> 00:19:37.430
I'm going to copy a bunch of the
blue levels into the temporary ones.

00:19:37.660 --> 00:19:41.600
So I say GLCOPY texture levels.

00:19:41.600 --> 00:19:43.480
The destination is the temporary texture.

00:19:43.590 --> 00:19:45.040
The source is the blue texture.

00:19:45.330 --> 00:19:48.550
I'm going to start at the
blue texture mipmap level 1,

00:19:48.550 --> 00:19:51.080
which is the 512 by 512 one.

00:19:51.170 --> 00:19:55.860
And I'm going to copy
the next 10 levels down.

00:19:55.860 --> 00:19:55.860
So there's the copy.

00:19:56.130 --> 00:19:59.300
All right, next,
I'm going to start copying up now.

00:19:59.400 --> 00:20:01.240
So I'm going to do the
same thing for the red.

00:20:01.360 --> 00:20:04.440
Copy, destination is blue,
source is the red.

00:20:04.600 --> 00:20:09.540
Starting at level 0 for the red,
because that's its 512x512 one,

00:20:09.540 --> 00:20:11.800
10 levels, and they go up.

00:20:12.140 --> 00:20:16.970
Okay, now I've kind of started to swap,
and now the goal of this is to,

00:20:16.970 --> 00:20:20.220
was to promote the red one, right,
to load the new data for the red one.

00:20:20.220 --> 00:20:25.020
So in the big blue spot,
I'm going to bind that texture,

00:20:25.230 --> 00:20:29.690
and then I'm going to
subload big red data into it.

00:20:29.750 --> 00:20:32.490
That's what those two
lines would have done.

00:20:32.820 --> 00:20:34.140
And now I'm done.

00:20:34.260 --> 00:20:38.540
I've done my swap, and I have a choice.

00:20:38.910 --> 00:20:43.280
Sort of algorithmically,
I could delete the temporary variable,

00:20:43.280 --> 00:20:46.000
and I would be entirely, like,
finished with this.

00:20:46.080 --> 00:20:49.700
But it's a lot more likely
that I'm going to keep on using

00:20:49.700 --> 00:20:51.400
it as I go on in my scene.

00:20:51.400 --> 00:20:54.350
I'm going to move around some more,
and then the next time,

00:20:54.350 --> 00:20:55.990
I can just reuse it again.

00:20:55.990 --> 00:20:59.430
So I don't necessarily have to delete it,
but show you the code.

00:20:59.580 --> 00:21:00.530
So there, it's gone.

00:21:00.550 --> 00:21:01.820
Okay.

00:21:01.820 --> 00:21:04.960
So that is a fine-grained texture copy.

00:21:04.990 --> 00:21:08.510
Pretty sophisticated,
but a new feature that

00:21:08.510 --> 00:21:10.760
we're providing in iOS 6.

00:21:13.050 --> 00:21:15.060
All right,
now let's bring it back down to

00:21:15.090 --> 00:21:19.400
something that's applicable to everybody,
fast VBO updates.

00:21:19.420 --> 00:21:24.730
So the reason why I say that it's
applicable to everybody is because

00:21:24.990 --> 00:21:28.740
really vertex buffer objects and
using them is absolutely essential.

00:21:28.740 --> 00:21:34.630
VBOs are the fundamental method
of defining geometry and rendering

00:21:34.640 --> 00:21:37.240
with OpenGL and OpenGL ES.

00:21:37.240 --> 00:21:40.900
You know, obviously,
this is where you store your vertices,

00:21:40.900 --> 00:21:44.260
how you set up normals,
texture coordinates, colors, so on.

00:21:44.260 --> 00:21:48.260
But the reason why I say it's so
fundamental is because really this

00:21:48.260 --> 00:21:50.000
is the high-performance technique.

00:21:50.090 --> 00:21:58.590
The buffer object API essentially
controls access to the data itself.

00:21:58.700 --> 00:22:00.570
And so if you're not
using buffer objects,

00:22:00.570 --> 00:22:03.000
like if you're just using
regular vertex arrays,

00:22:03.000 --> 00:22:06.240
the implementation has
to copy the entire array.

00:22:06.240 --> 00:22:06.320
Right?

00:22:07.240 --> 00:22:08.510
So the reason why I say it's so
fundamental is because really vertex

00:22:08.550 --> 00:22:09.260
buffer objects can be so much faster.

00:22:09.290 --> 00:22:10.470
And so that's why I say that, you know,
in the context of the VBO,

00:22:10.470 --> 00:22:11.680
we can manage the memory essentially
over to the GPU every frame

00:22:11.680 --> 00:22:12.590
because you manage that memory.

00:22:12.600 --> 00:22:15.330
And we don't necessarily know
what you might have changed

00:22:15.330 --> 00:22:16.720
from one frame to the next.

00:22:16.720 --> 00:22:19.520
But with the VBO, we manage the memory.

00:22:19.520 --> 00:22:23.670
And you only ask to make changes
and then goes on from there.

00:22:23.700 --> 00:22:27.020
And so that's why vertex buffer
objects can be so much faster.

00:22:27.020 --> 00:22:30.800
They're even applicable to 2D games
that are just drawing sprites.

00:22:30.800 --> 00:22:33.250
And I'll get back to
that in just a second.

00:22:33.260 --> 00:22:36.940
And vertex buffer objects
are supported everywhere.

00:22:37.240 --> 00:22:37.400
Okay.

00:22:37.400 --> 00:22:42.100
All of our devices
across both OS X and iOS.

00:22:42.100 --> 00:22:44.630
And it's worth mentioning,
over on the OS X side,

00:22:44.630 --> 00:22:47.470
with the core profile,
it's actually required that you

00:22:47.470 --> 00:22:49.370
use vertex buffer objects there.

00:22:51.150 --> 00:22:54.980
But okay, so, you know,
usually people think about vertex

00:22:55.010 --> 00:22:59.260
buffer objects and setting that up as
a container for your static geometry.

00:22:59.260 --> 00:23:04.570
But it's also very much advised that you
use this for dynamic geometry as well,

00:23:04.570 --> 00:23:07.090
and there's an API for doing that.

00:23:07.190 --> 00:23:09.340
So let me just kind of show
you the typical example here.

00:23:09.340 --> 00:23:13.080
First, we bind the buffer
that we want to modify.

00:23:13.080 --> 00:23:15.750
We call map buffer,
and that's going to hand

00:23:15.750 --> 00:23:18.480
us back a pointer to it,
and now it's memory,

00:23:18.480 --> 00:23:21.080
and we can start to make
modifications to it.

00:23:21.100 --> 00:23:25.710
So here, mem copy, or, you know,
anything else, an array, dereference,

00:23:25.720 --> 00:23:29.680
whatever you want to get into
that memory and make some changes.

00:23:29.680 --> 00:23:34.810
And then when you're done, we call unmap,
and that gets rid of our pointer,

00:23:34.810 --> 00:23:38.680
and now the implementation
knows that changes are done,

00:23:38.680 --> 00:23:41.110
and it can go on with its own work.

00:23:41.220 --> 00:23:44.650
All right, so that's typically how
you do a VBO update.

00:23:44.650 --> 00:23:47.400
But we've added something
to it now in iOS 6,

00:23:47.440 --> 00:23:50.450
because there's two
basic issues with this.

00:23:51.110 --> 00:23:55.420
One is that actually a lot of the time
when you're doing dynamic VBO updates,

00:23:55.420 --> 00:24:00.220
you're sort of doing modify, draw,
and then coming back around to your loop.

00:24:00.310 --> 00:24:03.420
Modify, draw, modify, draw, you know,
it's just this pretty tight loop.

00:24:03.690 --> 00:24:06.600
And you might actually get
in a situation where if we

00:24:06.600 --> 00:24:10.560
didn't block when you call map,
you could get in a situation

00:24:10.580 --> 00:24:15.050
where you're making modifications
before we're done drawing it.

00:24:15.800 --> 00:24:20.680
And so to prevent that,
the CPU ends up waiting

00:24:20.680 --> 00:24:21.080
for the data to get in.

00:24:21.100 --> 00:24:21.940
And so that's one of the
things that we're trying to do.

00:24:21.940 --> 00:24:24.190
And then the other thing is that we're
trying to do is we're trying to do a draw

00:24:24.260 --> 00:24:26.830
to finish before the map hands you back
the pointer to make modifications with.

00:24:26.840 --> 00:24:28.200
So that's one.

00:24:28.200 --> 00:24:31.110
It's blocking,
or potentially a blocking operation.

00:24:31.120 --> 00:24:37.160
The second is a little more subtle,
and it's that when you call unmap,

00:24:37.160 --> 00:24:40.740
we have to clear the CPU memory caches.

00:24:40.780 --> 00:24:44.440
Or, excuse me,
we have to flush them to make sure

00:24:44.470 --> 00:24:49.760
that whatever changes you made
actually become visible to the GPU.

00:24:50.000 --> 00:24:51.960
Because it could just
be sitting in cache.

00:24:51.980 --> 00:24:53.380
Okay?

00:24:53.380 --> 00:24:55.060
But so those two issues exist.

00:24:55.160 --> 00:24:58.990
And really, fundamentally,
that's what two new extensions

00:24:59.000 --> 00:25:01.230
are going to take care of for you.

00:25:01.240 --> 00:25:06.460
So you can do dynamic VBO updates,
but have it be this kind of perfect case.

00:25:06.460 --> 00:25:09.670
So in iOS 6,
we're adding these two new extensions,

00:25:09.830 --> 00:25:11.720
map buffer range and Apple sync.

00:25:11.780 --> 00:25:16.530
So the point of map buffer range,
this is very similar to an extension

00:25:16.530 --> 00:25:19.360
that we have in OpenGL on the desktop.

00:25:20.110 --> 00:25:24.410
It's going to give you explicit,
let you control explicit subranges and

00:25:24.580 --> 00:25:27.250
control the flushing of those subranges.

00:25:27.340 --> 00:25:31.660
So you will specify the
subrange that's been modified.

00:25:31.660 --> 00:25:34.520
You identify basically the
data that you've touched.

00:25:34.640 --> 00:25:37.680
And then you say flush just that.

00:25:37.740 --> 00:25:38.860
Okay?

00:25:38.860 --> 00:25:42.460
And really,
kind of what this does is allow

00:25:42.860 --> 00:25:48.760
you to have a case where maybe the
implementation is still drawing

00:25:48.760 --> 00:25:49.540
something that's towards the end.

00:25:49.540 --> 00:25:49.920
Okay?

00:25:49.960 --> 00:25:51.180
And you're at the end of your VBO array.

00:25:51.180 --> 00:25:53.900
And you are making
modifications at the start.

00:25:53.900 --> 00:25:58.640
And you're very carefully managing
the synchronization between those.

00:25:58.640 --> 00:26:01.660
Now, that's with map buffer range.

00:26:01.700 --> 00:26:04.240
And then the second extension,
Apple sync,

00:26:04.300 --> 00:26:06.760
is how you manage that synchronization.

00:26:06.780 --> 00:26:10.740
It provides you with a sync object
that basically it's a fence that you

00:26:10.880 --> 00:26:13.290
can insert into the command pipeline.

00:26:13.300 --> 00:26:17.290
And it will signal when it's
reached the end of the pipeline

00:26:17.290 --> 00:26:19.540
and been executed by the GPU.

00:26:19.960 --> 00:26:23.710
And so implicitly, then,
you can know that anything that was in

00:26:23.770 --> 00:26:27.980
the command pipeline before that has
also been through the pipeline now.

00:26:28.330 --> 00:26:31.460
And make decisions based on that.

00:26:31.600 --> 00:26:36.900
So these two extensions are supported
on all the devices that support iOS 6.

00:26:36.900 --> 00:26:39.060
And let's take a look.

00:26:39.260 --> 00:26:40.670
So here's the first one.

00:26:40.910 --> 00:26:41.720
Map buffer range.

00:26:41.740 --> 00:26:44.880
Essentially, here's the simple case
with map buffer range.

00:26:44.950 --> 00:26:47.190
And then I'll show you
the two of them together,

00:26:47.190 --> 00:26:49.520
map buffer range and sync,
in just a moment.

00:26:49.960 --> 00:26:53.760
So we're binding our VBO to
make modifications to it.

00:26:53.820 --> 00:26:57.880
Here we're getting back
our pointer into the array.

00:26:57.880 --> 00:26:59.820
But you see the arguments
here are a little different.

00:26:59.820 --> 00:27:03.240
I'm saying, okay,
here's the offset and the length of the

00:27:03.320 --> 00:27:05.820
spot in the array that I want to modify.

00:27:05.820 --> 00:27:10.580
And then I'm telling the implementation,
I will flush, I will explicitly tell you

00:27:10.580 --> 00:27:12.180
when to flush this back.

00:27:14.300 --> 00:27:17.650
Now here,
I have the data now once I get --

00:27:17.850 --> 00:27:22.110
once I return from map buffer range,
and I can start making modifications.

00:27:22.130 --> 00:27:24.200
So mem copy there.

00:27:24.200 --> 00:27:27.440
And then down here at the bottom,
I flush -- I'm done.

00:27:27.440 --> 00:27:34.580
And so now I flush explicitly
the part back that I've modified,

00:27:34.580 --> 00:27:37.810
specifying, you know,
potentially a new offset and

00:27:37.810 --> 00:27:37.810
length and then call unmap.

00:27:38.040 --> 00:27:40.100
So that's kind of the simple case.

00:27:40.100 --> 00:27:42.820
You've just made a modification to a VBO.

00:27:42.940 --> 00:27:45.620
But what if you want to do something
a little more sophisticated

00:27:45.620 --> 00:27:46.770
with the synchronization?

00:27:46.950 --> 00:27:50.280
Here is exactly the same code,
just with a space in it,

00:27:50.280 --> 00:27:52.840
so I can fill it in with some things.

00:27:52.980 --> 00:27:56.330
Let's start out by looking at
the call to map buffer range.

00:27:56.510 --> 00:27:59.210
What I want to do first is
to tell map buffer range,

00:27:59.300 --> 00:28:00.470
hey, don't block.

00:28:00.470 --> 00:28:03.640
Even if you still think you
might be drawing that VBO,

00:28:03.730 --> 00:28:07.270
I will handle the synchronization myself.

00:28:07.310 --> 00:28:11.060
So I'm going to add a new flag,
geomap unsynchronized

00:28:11.140 --> 00:28:13.020
bit that signals that,
hey,

00:28:13.020 --> 00:28:15.820
I'm taking care of the synchronization.

00:28:15.820 --> 00:28:19.000
And now here's the code that's
taking care of the synchronization.

00:28:19.070 --> 00:28:22.000
A little bit before I do the
modification and then a little

00:28:22.050 --> 00:28:24.240
bit after I do the modification,
right?

00:28:24.240 --> 00:28:29.000
So the part that comes before
is that I'm waiting for the

00:28:29.170 --> 00:28:31.540
fence that I'm setting below.

00:28:31.540 --> 00:28:32.920
So just forward reference that.

00:28:33.000 --> 00:28:33.750
It's there.

00:28:33.840 --> 00:28:35.740
Just remember it's there.

00:28:35.840 --> 00:28:39.100
And this might be the new sync point.

00:28:39.200 --> 00:28:41.310
If down below,
if the fence that I set down there

00:28:41.310 --> 00:28:44.980
still hasn't finished when I come
back around the top of this loop,

00:28:44.980 --> 00:28:47.970
then this will be the spot where I block.

00:28:48.160 --> 00:28:48.460
Okay.

00:28:48.620 --> 00:28:51.300
And let's look at the part at the bottom.

00:28:51.380 --> 00:28:55.880
So the part at the bottom,
the draw this VBO, that stays the same.

00:28:55.940 --> 00:29:00.440
But immediately after I draw it,
I'm going to put another command into

00:29:00.540 --> 00:29:02.620
the command stream that sets the fence.

00:29:02.620 --> 00:29:04.910
Essentially is a synchronization object.

00:29:04.920 --> 00:29:07.460
And remember, you know,
it's a deep pipeline.

00:29:07.460 --> 00:29:12.110
So it might take a little bit of time for
that VBO and the sync object right behind

00:29:12.110 --> 00:29:14.300
it to both get through the pipeline.

00:29:14.370 --> 00:29:17.870
But by then, I'll hopefully have had time
to come around to the top.

00:29:17.940 --> 00:29:20.130
And maybe I'll have done some other work.

00:29:20.220 --> 00:29:22.440
And so when I get to
the client wait sync,

00:29:22.440 --> 00:29:26.120
the first one there that you see,
hopefully it won't block.

00:29:26.120 --> 00:29:27.720
I'll already be done with that drawing.

00:29:29.100 --> 00:36:22.500
[Transcript missing]

00:36:23.060 --> 00:36:25.860
So the purpose of the
GLK view is to give you,

00:36:26.040 --> 00:36:29.850
basically,
just an OpenGL ES-compatible view to use.

00:36:29.850 --> 00:36:33.640
So it's using all of the
normal view mechanics,

00:36:33.640 --> 00:36:35.760
but it knows about OpenGL surfaces.

00:36:35.800 --> 00:36:41.240
So it gives you some very easy just
properties to set up your render buffers.

00:36:41.290 --> 00:36:45.190
If you've been with us since the
original days of the iOS SDK,

00:36:45.190 --> 00:36:48.630
you know that that used to
be a very manual process.

00:36:48.630 --> 00:36:51.560
And now, with this, it's just one line,
for example.

00:36:52.400 --> 00:36:55.330
It also gives you some really
straightforward ways of

00:36:55.830 --> 00:36:57.400
implementing your draw methods.

00:36:57.570 --> 00:37:02.520
Either you can just subclass
GLK view and override draw rect,

00:37:02.590 --> 00:37:09.930
or it also has a delegate that can
be called GLK view draw in rect.

00:37:10.050 --> 00:37:12.200
And that'll be called each frame.

00:37:12.200 --> 00:37:13.640
Okay?

00:37:13.640 --> 00:37:17.990
Now, going hand-in-hand with
this is the view controller.

00:37:18.000 --> 00:37:19.100
Okay?

00:37:19.400 --> 00:39:36.300
[Transcript missing]

00:39:37.680 --> 00:39:41.760
Okay, so that was the second part.

00:39:41.830 --> 00:39:45.360
The third part of
GL Kit is a texture loader.

00:39:45.360 --> 00:39:49.210
And the point here is that, you know,
most OpenGL and OpenGL ES based

00:39:49.210 --> 00:39:50.850
apps are loading textures.

00:39:50.950 --> 00:39:53.620
There's all kinds of
different ways to do it,

00:39:53.620 --> 00:39:56.210
and some are more efficient than others.

00:39:56.210 --> 00:40:02.260
We wanted to provide just a really easy
way for you guys to get textures loaded.

00:40:02.910 --> 00:40:05.730
We support, you know,
the usual suspects as

00:40:05.860 --> 00:40:09.560
far as file formats,
ping, JPEG, TIFF, et cetera.

00:40:09.560 --> 00:40:12.660
On iOS, we also support PVRTC.

00:40:12.690 --> 00:40:15.060
And it's very, very flexible.

00:40:15.060 --> 00:40:20.860
So you can load from a file or a URL to
a file or an NSData that contains a file

00:40:21.020 --> 00:40:24.250
or other data types like CG image rev.

00:40:24.290 --> 00:40:29.000
2D and cube map texture
targets are supported.

00:40:29.000 --> 00:40:32.140
And then maybe its biggest...

00:40:32.910 --> 00:40:37.560
subtitle kind of feature is
that it supports either loading

00:40:37.560 --> 00:40:40.270
the texture synchronously,
which is the way that many

00:40:40.650 --> 00:40:45.840
applications are doing it now,
or it can load the texture asynchronously

00:40:45.840 --> 00:40:50.360
and give you back control of the thread
while the texture is being loaded.

00:40:50.360 --> 00:40:54.540
There's a lot of you guys who are
taking a long time to get to your

00:40:54.540 --> 00:40:59.960
main menus because you're loading
textures during that time synchronously.

00:41:00.190 --> 00:41:04.450
And what you could do instead is
to just synchronously load only

00:41:04.450 --> 00:41:08.460
the textures that you need in order
to bring up that menu and then

00:41:08.750 --> 00:41:10.960
asynchronously load everything else.

00:41:11.080 --> 00:41:14.490
And hopefully, while everything else is
being asynchronously loaded,

00:41:14.580 --> 00:41:18.210
you know, hopefully by the time the
user's finger hits the screen,

00:41:18.210 --> 00:41:21.290
you have asynchronously got
everything else taken care of to

00:41:21.440 --> 00:41:23.190
get started on your first level.

00:41:23.190 --> 00:41:25.580
But so, you know,
think about ways that you

00:41:25.670 --> 00:41:27.410
can kind of move things,
work away from the screen and

00:41:27.410 --> 00:41:28.260
move things away from the screen.

00:41:28.260 --> 00:41:29.500
So, you know,
you can start with the main thread

00:41:29.500 --> 00:41:30.890
before you bring your application up.

00:41:31.000 --> 00:41:34.800
And it'll

00:41:36.360 --> 00:41:38.280
Now, a couple more things
in the texture loader,

00:41:38.280 --> 00:41:39.990
some options that make it convenient.

00:41:40.000 --> 00:41:41.800
It can generate mipmaps for you.

00:41:41.800 --> 00:41:48.900
It can flip the texture if necessary,
and it can pre-multiply

00:41:48.900 --> 00:41:49.960
the alpha if necessary.

00:41:49.960 --> 00:41:53.600
Okay, that's number three in GLKit.

00:41:53.900 --> 00:41:56.570
Part four, my favorite,
is the math library.

00:41:56.590 --> 00:42:01.980
So this is just a huge math library of
a lot of different routines that are

00:42:01.980 --> 00:42:05.380
really useful for 2D and 3D graphics.

00:42:05.380 --> 00:42:08.530
And so, 175 functions,
we support all different

00:42:08.630 --> 00:42:12.100
kind of vectors and a lot of
different operations on vectors,

00:42:12.100 --> 00:42:16.560
different operations on matrices,
both 3x3 and 4x4,

00:42:16.560 --> 00:42:20.390
and all the typical operations
on quaternions as well,

00:42:20.500 --> 00:42:24.120
if you've moved over to a
quaternion-based movement system.

00:42:24.120 --> 00:42:28.030
The entire implementation
is really high performance.

00:42:28.090 --> 00:42:34.790
And it's C-based, which is neat,
because reducing function, you know,

00:42:34.900 --> 00:42:35.360
avoiding function-based
movement is really important.

00:42:35.400 --> 00:42:37.150
So, if you have a function
call overhead and so on,

00:42:37.150 --> 00:42:38.460
well, I'll say it differently.

00:42:38.460 --> 00:42:42.460
The implementation is C-based,
and it's inline in the header file.

00:42:42.460 --> 00:42:46.440
And so, that means if you have
multiple operations that come

00:42:46.560 --> 00:42:49.910
one right after the other,
the compiler may be able

00:42:50.050 --> 00:42:54.320
to optimize those and avoid
some extra function overhead.

00:42:54.320 --> 00:42:57.360
But the reason why it's really so fast,
on iOS,

00:42:57.360 --> 00:43:02.690
we provide you with an implementation
that's scalar that runs in the simulator.

00:43:02.700 --> 00:43:05.340
But when you're running on a device,
it's not.

00:43:05.340 --> 00:43:05.360
So, that's one of the
reasons why it's so fast.

00:43:05.380 --> 00:43:10.270
It's using the neon instructions
of the CPU to just be blazing,

00:43:10.270 --> 00:43:11.650
blazing fast.

00:43:11.660 --> 00:43:16.910
Same thing,
same analogy goes over onto OS X as well.

00:43:16.940 --> 00:43:21.750
The implementation there is optimized
with the Intel SSE instruction set.

00:43:21.760 --> 00:43:24.780
And so, it's able to be very,
very fast there, too.

00:43:24.780 --> 00:43:28.380
Now, all of that is just about
the math operations.

00:43:28.380 --> 00:43:32.230
You know, think about things like
dot product or rotate or,

00:43:32.230 --> 00:43:33.820
you know, et cetera.

00:43:33.820 --> 00:43:39.210
There's also... There's also a matrix
stack library that's provided in this,

00:43:39.340 --> 00:43:40.650
in GLK math as well.

00:43:40.680 --> 00:43:44.480
And that ends up being really
useful for moving code that

00:43:44.520 --> 00:43:48.370
used to be doing GL push matrix,
GL pop matrix, and so on,

00:43:48.370 --> 00:43:53.550
over to GLKit and onto
the modern pipeline.

00:43:53.560 --> 00:43:58.280
So, those are the four pieces of GLKit.

00:43:58.280 --> 00:44:01.320
I've really... I've only
scratched the surface here.

00:44:01.320 --> 00:44:03.240
But if you haven't heard about
it yet and you'd like to find

00:44:03.240 --> 00:44:05.310
out more information about it,
I'd love to hear from you.

00:44:05.320 --> 00:44:28.020
So, that's GLKit.

00:44:29.740 --> 00:44:34.480
Final part of the talk,
I'd like to discuss the new Retina

00:44:34.510 --> 00:44:37.660
displays on the new MacBook Pros.

00:44:37.810 --> 00:44:41.020
So, you know, now we have devices,
of course, you know,

00:44:41.020 --> 00:44:43.460
that are supporting Retina displays.

00:44:43.460 --> 00:44:47.700
You see them,
that the iPhone has a Retina display.

00:44:47.700 --> 00:44:52.020
There's a Retina display on the new iPad,
and of course now on the MacBook Pro.

00:44:52.020 --> 00:44:54.220
Just gorgeous.

00:44:54.440 --> 00:44:58.440
And so we've -- I want to talk
about sort of how this works

00:44:58.440 --> 00:45:01.320
more from the coding perspective.

00:45:01.320 --> 00:45:08.130
So maybe the first observation to
make is that both on iOS and on OS X,

00:45:08.130 --> 00:45:10.680
it's a very, very similar approach.

00:45:10.910 --> 00:45:16.990
This is the approach on iOS kind
of broken down into stages here.

00:45:17.300 --> 00:45:20.930
There's going to be a scale factor,
which either will be set for you,

00:45:20.930 --> 00:45:24.080
for example, 2.0,
or you may set it yourself.

00:45:24.370 --> 00:45:27.270
Then based on that scale factor,
you will be allocating

00:45:27.270 --> 00:45:30.450
your color buffers,
your depth buffer, and so on,

00:45:30.450 --> 00:45:31.720
and setting up your viewport.

00:45:31.720 --> 00:45:34.280
And then you render into those buffers,
right?

00:45:34.280 --> 00:45:40.790
Now, on iOS, if you aren't scaling,
then great, we're done.

00:45:40.800 --> 00:45:44.340
If you are scaling,
then core animation will actually

00:45:44.340 --> 00:45:46.610
take care of the scaling for you.

00:45:47.200 --> 00:45:48.050
That needs to happen.

00:45:48.060 --> 00:45:50.450
And then, you know,
you do some performance tuning

00:45:50.580 --> 00:45:53.120
to make sure that now you're
driving a lot more pixels,

00:45:53.120 --> 00:45:56.550
and you perhaps tune your
fragment shaders and so on.

00:45:56.620 --> 00:45:57.760
Okay?

00:45:57.760 --> 00:45:58.840
So that's iOS.

00:45:58.840 --> 00:46:03.220
You know, I forgot to mention,
I meant to say this in the beginning,

00:46:03.220 --> 00:46:07.240
existing applications
that do nothing also,

00:46:07.240 --> 00:46:09.040
of course, work.

00:46:09.170 --> 00:46:13.030
So this is, you know,
an existing application that does not

00:46:13.130 --> 00:46:15.880
take advantage of the retina display.

00:46:15.880 --> 00:46:16.960
The system will scale.

00:46:17.200 --> 00:46:21.160
It will scale that application
to the size it's supposed to be

00:46:21.410 --> 00:46:23.050
and all the views to the size.

00:46:23.230 --> 00:46:26.560
Now, this, what I'm showing you on slide
is if you are deciding to take

00:46:26.560 --> 00:46:29.290
advantage of the retina display,
how that works.

00:46:29.440 --> 00:46:32.530
The same thing is true on OS X as well.

00:46:32.540 --> 00:46:35.620
If you do nothing,
your existing applications

00:46:35.710 --> 00:46:39.310
are going to continue to be
presented at the same size.

00:46:39.400 --> 00:46:43.720
But now, if you are going to take
advantage of the retina display,

00:46:43.720 --> 00:46:45.490
then here's how it works.

00:46:45.640 --> 00:46:47.180
Really, each of the steps here.

00:46:47.200 --> 00:46:48.170
Are very, very similar.

00:46:48.180 --> 00:46:51.200
You're going to enable
retina support on the Mac.

00:46:51.260 --> 00:46:53.440
You're going to allocate
your color buffers,

00:46:53.440 --> 00:46:56.130
your depth buffers, and so on,
and set up your viewports.

00:46:56.140 --> 00:46:58.070
But then there's a fork in the road.

00:46:58.100 --> 00:47:03.010
The fork depends on are you drawing
at the full native resolution,

00:47:03.010 --> 00:47:04.920
at retina resolution?

00:47:05.000 --> 00:47:07.720
If so,
you'll go down the left-hand side here.

00:47:07.720 --> 00:47:09.520
You just render, and you're done.

00:47:09.620 --> 00:47:10.200
Right?

00:47:10.200 --> 00:47:16.360
But if you are intending to scale,
then you go down the right-hand side.

00:47:16.550 --> 00:47:17.180
What you will do.

00:47:17.180 --> 00:47:23.300
Is render into a smaller
than retina resolution FBO.

00:47:23.300 --> 00:47:27.060
And then explicitly do a blit
that will scale it up to into

00:47:27.060 --> 00:47:29.350
the full-size backing buffer.

00:47:29.360 --> 00:47:30.680
Okay?

00:47:30.680 --> 00:47:32.900
So that's how you make your way through.

00:47:32.920 --> 00:47:35.530
And in both cases, of course,
take a look at performance,

00:47:35.530 --> 00:47:36.300
and we'll see.

00:47:38.260 --> 00:47:41.640
So we've covered iOS plenty in the past.

00:47:42.030 --> 00:47:47.100
Today I want to cover the specifics
about how it works on OS X.

00:47:47.100 --> 00:47:52.120
So on OS X, here's that first step where
we are enabling retina support.

00:47:52.120 --> 00:47:55.980
You do this within your
NSOpenGL view subclass.

00:47:56.020 --> 00:47:59.320
And just basically there's a
new method on NSOpenGL view.

00:47:59.320 --> 00:48:02.570
It's set wants best
resolution OpenGL surface.

00:48:02.620 --> 00:48:03.960
You set that to yes.

00:48:03.960 --> 00:48:09.520
And now you are saying to that view, ah,
you know, view,

00:48:09.520 --> 00:48:13.330
you think you are in points at, you know,
this many points,

00:48:13.330 --> 00:48:17.380
but really underlying that,
we want you to be providing us

00:48:17.380 --> 00:48:20.350
more information about pixels,
right?

00:48:20.590 --> 00:48:26.080
So then here, once you have opted in,
here is your draw rect

00:48:26.080 --> 00:48:28.880
method for NSOpenGL view.

00:48:28.880 --> 00:48:33.470
So the first thing you want to get,
you want to find out from the view is,

00:48:33.470 --> 00:48:36.320
well, really, what resolution am I at?

00:48:36.590 --> 00:48:38.940
Because a lot of other
things know OpenGL sort of

00:48:38.940 --> 00:48:40.790
depend on pixel resolution.

00:48:40.830 --> 00:48:43.900
Or, you know, on pixel dimensions,
I should say.

00:48:43.900 --> 00:48:48.600
So there's a new method on views,
which is convert rect to backing.

00:48:48.600 --> 00:48:51.730
We'll pass in the bounds
of the NSOpenGL view,

00:48:51.730 --> 00:48:54.630
and it's going to give
us back a new bounds,

00:48:54.630 --> 00:48:57.040
which is in pixel dimensions.

00:48:57.040 --> 00:48:58.420
Okay?

00:48:58.420 --> 00:49:00.290
Now, we use those dimensions.

00:49:00.290 --> 00:49:04.260
I just, I'm extracting some very,
you know, some values out of this.

00:49:04.340 --> 00:49:08.060
And those are the dimensions that
we pass in for calls like GLV.

00:49:08.060 --> 00:49:09.320
Okay?

00:49:09.320 --> 00:49:13.230
The actual backing pixel width and
the actual backing pixel height.

00:49:14.720 --> 00:49:17.800
Now, and then you go on,
you draw something.

00:49:17.980 --> 00:49:22.150
Now, as you're drawing, you know,
the drawing should basically

00:49:22.260 --> 00:49:26.130
function as before,
but just be aware that there are several

00:49:26.130 --> 00:49:31.130
other calls in OpenGL that have to --
that are defined in pixel dimensions.

00:49:31.130 --> 00:49:34.240
You need to check through
your code for those.

00:49:34.240 --> 00:49:37.730
I mentioned viewport, also scissor,
read pixels,

00:49:37.730 --> 00:49:41.480
line width is in pixel dimensions,
render buffer storage

00:49:41.630 --> 00:49:44.580
is in pixel dimensions,
and so on.

00:49:44.910 --> 00:49:48.580
And then also, of course, well,
there's a reason why you're

00:49:48.760 --> 00:49:50.280
on the retina display.

00:49:50.280 --> 00:49:53.410
You want to also up res
things like your -- you know,

00:49:53.570 --> 00:49:57.930
use higher resolution assets so
everything also looks more crisp.

00:49:57.940 --> 00:49:58.460
Okay.

00:49:58.460 --> 00:50:01.370
So,
calls like GLTechImage2D make sure you

00:50:01.370 --> 00:50:04.480
load in your higher resolution images.

00:50:04.480 --> 00:50:05.110
Okay.

00:50:05.110 --> 00:50:09.190
So,
that's the -- essentially the draw part.

00:50:09.190 --> 00:50:14.130
Now, as I said,
if you are rendering at -- if your

00:50:14.420 --> 00:50:20.560
decision was I'm just going to render
at the native retina resolution,

00:50:20.560 --> 00:50:23.900
then you're done on the previous slide.

00:50:23.900 --> 00:50:28.080
If you've decided I'm going to
actually render to a smaller than

00:50:28.080 --> 00:50:34.800
native resolution surface and then
scale that to the native resolution,

00:50:34.800 --> 00:50:36.860
then this is what you would need to do.

00:50:36.860 --> 00:50:40.000
You would have to be rendering
into an FBO and then blit that

00:50:40.110 --> 00:50:42.120
FBO to the backing surface.

00:50:42.120 --> 00:50:46.160
So,
the idea here is you're finished drawing

00:50:46.820 --> 00:50:51.610
and you're going to essentially bind that
FBO for reading and then bind the back

00:50:51.610 --> 00:50:53.940
buffer for drawing and then do a blit.

00:50:53.940 --> 00:50:57.190
So, the first two calls here
are binding the read source.

00:50:57.190 --> 00:51:01.860
You're sourcing from the
first attachment of an FBO.

00:51:01.860 --> 00:51:06.720
These next two calls are taking care
of the draw part of the equation.

00:51:06.720 --> 00:51:11.500
So, you are binding -- you're setting
the draw buffer to the back buffer.

00:51:11.710 --> 00:51:12.120
Right?

00:51:12.120 --> 00:51:15.870
And now here is where
you actually do the blit.

00:51:15.900 --> 00:51:18.100
So,
this is doing kind of a copy blit from

00:51:18.100 --> 00:51:23.780
that read source into the write source,
specifying the dimensions of both.

00:51:23.780 --> 00:51:26.120
And here I'm saying that
I want linear scaling.

00:51:26.120 --> 00:51:30.360
You can also specify nearest
scaling if that's what you prefer.

00:51:30.360 --> 00:51:34.180
And then you can go on from
there and flush buffer and so on.

00:51:34.180 --> 00:51:36.280
That's the end of your frame.

00:51:36.600 --> 00:51:37.290
Okay?

00:51:37.290 --> 00:51:43.150
So, that is how you can support Retina
displays just as far as the code

00:51:43.150 --> 00:51:47.090
and a few things to -- a few
decisions to make along the way.

00:51:47.090 --> 00:51:49.550
There's one more piece,
and it's that tuning

00:51:49.650 --> 00:51:51.450
performance part of it.

00:51:51.500 --> 00:51:54.580
So, you know, you're drawing more pixels.

00:51:54.680 --> 00:51:59.580
Now, most of the apps out there are
just going to be able to -- to

00:51:59.730 --> 00:52:03.210
draw four times as many pixels,
and their performance is

00:52:03.210 --> 00:52:04.350
still going to be fine.

00:52:04.350 --> 00:52:07.670
That's actually, you know,
among more sophisticated game developers,

00:52:07.670 --> 00:52:09.760
maybe not true for you,
but most of the apps out there,

00:52:09.860 --> 00:52:11.520
it's definitely true.

00:52:11.520 --> 00:52:14.980
So, the first thing that you should
try for your game is to -- or

00:52:14.980 --> 00:52:20.410
any app is to just try the native
resolution and see how you do.

00:52:20.540 --> 00:52:22.330
And, you know,
optimize your fragment shaders,

00:52:22.370 --> 00:52:24.920
see if you can tune your performance,
because, of course,

00:52:24.920 --> 00:52:27.690
you're drawing more pixels now.

00:52:27.910 --> 00:52:31.580
If that's not going to work,
if you've decided, okay,

00:52:31.580 --> 00:52:36.260
I need to do something more special here,
there's a couple of

00:52:36.260 --> 00:52:37.610
different approaches to take.

00:52:37.700 --> 00:52:38.870
You could do an experiment.

00:52:38.910 --> 00:52:43.050
You could render at the
original sort of resolution,

00:52:43.120 --> 00:52:48.250
but turn on anti-aliasing and see
how it looks and see if that visual

00:52:48.250 --> 00:52:50.910
quality is good enough for you.

00:52:52.900 --> 00:52:57.490
So, the third option here,
which is really to just kind of iterate.

00:52:57.670 --> 00:53:01.600
Try different fractional
values between 1.0 and 2.0,

00:53:01.600 --> 00:53:07.240
you know, between the two resolutions,
and modify your, you know,

00:53:07.270 --> 00:53:10.170
make optimizations to your fragment
shaders and your rendering as you go,

00:53:10.170 --> 00:53:14.070
and try to find essentially a happy
medium where you're pleased with the

00:53:14.150 --> 00:53:18.850
performance and you're pleased with the
display resolution that you're using.

00:53:20.390 --> 00:53:20.930
Okay?

00:53:20.930 --> 00:53:27.230
Now, so there are a lot more topics to
go through with retina displays that

00:53:27.230 --> 00:53:33.440
are maybe specialized to particular
audiences or particular cases.

00:53:33.440 --> 00:53:38.750
For example, if you have already have an
anti-aliased FBO that you need to scale,

00:53:38.750 --> 00:53:41.200
there's more discussion to have.

00:53:41.390 --> 00:53:46.080
If you are handling multiple displays
and potentially you have a display which

00:53:46.160 --> 00:53:50.280
is retina and one which is non-retina,
how do you handle that?

00:53:50.300 --> 00:53:54.250
How do you handle resolution
changes and so on?

00:53:54.400 --> 00:53:55.760
We're going to have another talk.

00:53:55.880 --> 00:54:00.750
It's the advanced high-resolutions talk
that's going to be on Friday morning.

00:54:00.750 --> 00:54:03.630
So I'd recommend you go to that,
especially if you're going

00:54:03.630 --> 00:54:04.980
to be supporting this.

00:54:05.000 --> 00:54:07.880
There's also a sample
called GL Fullscreen,

00:54:07.880 --> 00:54:11.530
which shows you the best
practices for fullscreen apps,

00:54:11.530 --> 00:54:14.660
and we're working on
that for retina as well.

00:54:14.660 --> 00:54:17.940
But something you can start with today,
actually,

00:54:17.940 --> 00:54:20.200
with the existing systems you have.

00:54:20.340 --> 00:54:21.990
Is the Quartz Debug app.

00:54:22.030 --> 00:54:26.840
So if you download Quartz Debug,
it's up on our developer website.

00:54:26.840 --> 00:54:29.250
It'll end up in
applications graphics tools.

00:54:29.470 --> 00:54:32.340
And then there's a checkbox
in there that you can do,

00:54:32.340 --> 00:54:35.540
which is shown here,
enable high DPI display modes.

00:54:35.600 --> 00:54:38.150
If you check that,
then it'll give you a few more display

00:54:38.150 --> 00:54:41.210
modes that you can then experiment
with with your existing apps and

00:54:41.210 --> 00:54:43.000
kind of test their functionality.

00:54:43.000 --> 00:54:45.670
And, you know,
maybe just let me give you one

00:54:45.670 --> 00:54:47.900
more thought on retina displays.

00:54:47.910 --> 00:54:49.980
Something that we saw on iOS.

00:54:50.300 --> 00:54:53.020
Was, of course, you know,
there were a few apps that were

00:54:53.020 --> 00:54:56.800
right out the gate very quickly
with the retina display on iOS.

00:54:56.800 --> 00:55:02.130
And those early movers had an advantage,
of course, but it was very quick.

00:55:02.370 --> 00:55:08.550
The transition was very fast where users
began to expect that the applications

00:55:08.550 --> 00:55:13.040
they ran on their retina-enabled phone,
in that case,

00:55:13.040 --> 00:55:15.880
would support retina graphics.

00:55:16.000 --> 00:55:20.120
And so your users who go and
buy one of the new MacBook Pros.

00:55:20.300 --> 00:55:23.470
Will very, very quickly be in that
same situation as well.

00:55:23.550 --> 00:55:27.240
I bet where they will come to
expect that the applications start

00:55:27.620 --> 00:55:29.820
getting updates for retina graphics.

00:55:30.040 --> 00:55:31.180
So don't wait.

00:55:31.470 --> 00:55:32.940
Just go for it.

00:55:33.040 --> 00:55:34.500
Okay.

00:55:34.500 --> 00:55:36.210
So that is supporting retina graphics.

00:55:36.290 --> 00:55:38.640
I want to bring Chris back up to wrap up.

00:55:38.720 --> 00:55:39.600
Thanks, Alan.

00:55:39.600 --> 00:55:42.220
So, yeah.

00:55:42.220 --> 00:55:45.800
That was a pretty good overview of some
of the new features that we have for you.

00:55:45.800 --> 00:55:50.200
And so, for instance,
like Apple shader frame buffer fetch.

00:55:50.300 --> 00:55:55.210
Allowing the programmable blending
and enabling things like efficient

00:55:55.610 --> 00:56:00.300
color grading and doing things a
little bit more efficiently with that.

00:56:00.500 --> 00:56:04.520
Also with the texture storage and the
copy texture levels and making sure that

00:56:04.520 --> 00:56:09.310
you're taking the most advantage out
of your limited memory that you have in

00:56:09.310 --> 00:56:12.290
order to get high resolution textures.

00:56:12.300 --> 00:56:19.080
Also the vertex buffer objects
and sync with map buffer range.

00:56:19.080 --> 00:56:20.080
And being able to update the texture.

00:56:20.200 --> 00:56:23.040
Update your vertex buffer
data as quickly as possible.

00:56:23.040 --> 00:56:25.640
And then geo kit.

00:56:25.750 --> 00:56:30.680
Hopefully you guys can start using
that to transition your applications

00:56:30.680 --> 00:56:33.300
to OpenGeo ES2 and core profile.

00:56:33.300 --> 00:56:38.460
And be able to take advantage of
the programmability that is exposed

00:56:38.460 --> 00:56:41.260
by the newer modern OpenGeo APIs.

00:56:41.260 --> 00:56:45.330
And finally, we hope you download the,
as Alan was saying,

00:56:45.360 --> 00:56:47.700
there's the Quartz debug tool.

00:56:47.700 --> 00:56:49.860
Go to the downloads and
search for graphics.

00:56:49.860 --> 00:56:50.630
Graphics tools.

00:56:50.720 --> 00:56:53.460
And it will be a damage that
you can download that will

00:56:53.460 --> 00:56:54.840
have Quartz debug on it.

00:56:54.990 --> 00:56:56.260
Enable high DPI mode.

00:56:56.300 --> 00:57:00.220
And you don't need to have a
MacBook Pro with Retina display

00:57:00.220 --> 00:57:02.580
to start developing on it today.

00:57:02.580 --> 00:57:03.920
So try that out.

00:57:03.980 --> 00:57:07.980
So with that, a couple more resources.

00:57:07.980 --> 00:57:10.500
Alan already had
mentioned during his talk.

00:57:10.600 --> 00:57:17.820
The tuning OpenGeo ES games goes a little
bit into 2D sprite based applications.

00:57:17.820 --> 00:57:19.430
How to really geek the most out of.

00:57:19.860 --> 00:57:20.720
That performance.

00:57:20.740 --> 00:57:24.970
And then harnessing geo kit and
OpenGeo ES will apply to the

00:57:25.340 --> 00:57:28.160
desktop with Mountain Lion as well.

00:57:28.280 --> 00:57:31.530
So if you're not familiar with geo kit,
recommend you check that out.

00:57:31.670 --> 00:57:34.360
And then finally, of course,
we said we're going to be updating

00:57:34.360 --> 00:57:38.340
the geo full screen sample code
to show you how to best take

00:57:38.340 --> 00:57:39.750
advantage of Retina displays.

00:57:39.760 --> 00:57:44.290
Do some of that scaling
that we were talking about.

00:57:44.940 --> 00:57:50.990
So, some related sessions we have right
after this talk is actually the

00:57:50.990 --> 00:57:52.580
OpenGL ES tools and techniques.

00:57:52.650 --> 00:57:53.900
So stay here.

00:57:53.900 --> 00:57:58.080
It's right here in a few minutes where
they'll be showing the state-of-the-art

00:57:58.080 --> 00:58:01.920
tools that they have for debugging
your OpenGL ES applications.

00:58:02.710 --> 00:58:06.620
Also, tomorrow there's an OpenCL talk,
and then on Friday,

00:58:06.620 --> 00:58:10.860
they're going to be giving a talk
on more of the advanced topics

00:58:10.860 --> 00:58:15.470
related to taking advantage of
a retina display on a Macintosh,

00:58:15.470 --> 00:58:17.780
like dealing with multiple displays,
for instance.
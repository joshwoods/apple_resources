WEBVTT

00:00:10.400 --> 00:00:11.670
Welcome, everybody.

00:00:11.800 --> 00:00:13.170
Welcome to What's New in Cocoa.

00:00:13.460 --> 00:00:14.440
My name is Ali Ozer.

00:00:14.440 --> 00:00:18.610
I'm the director of
Cocoa frameworks at Apple.

00:00:20.690 --> 00:00:22.720
So today we're going to talk
about what's new in Cocoa.

00:00:22.840 --> 00:00:26.350
We're going to talk about changes in
AppKit and Foundation frameworks and

00:00:26.380 --> 00:00:28.080
some related areas in Mountain Lion.

00:00:28.080 --> 00:00:30.460
And we're also going to give
pointers to other talks,

00:00:30.510 --> 00:00:32.660
because there are many other talks
that go into a lot of depth about

00:00:32.660 --> 00:00:34.000
what we're going to talk about.

00:00:34.070 --> 00:00:35.150
And also pointers to labs.

00:00:35.270 --> 00:00:37.550
We have labs throughout the week.

00:00:37.660 --> 00:00:41.130
The topics we're going to cover-- first,
iCloud with a focus on

00:00:41.130 --> 00:00:42.760
NS document handling.

00:00:42.760 --> 00:00:45.260
Then we're going to talk
about high resolution gestures

00:00:45.380 --> 00:00:46.750
and layer-backed views.

00:00:47.040 --> 00:00:48.520
Notification center.

00:00:48.670 --> 00:00:51.500
Some new APIs we've added
in Cocoa to support XPC.

00:00:51.940 --> 00:00:54.990
Some exciting changes in Objective-C,
and a bunch of other topics.

00:00:55.010 --> 00:00:58.120
As I said, there's a lot to cover.

00:00:58.260 --> 00:01:01.810
So with that, let's dive into iCloud.

00:01:02.780 --> 00:01:05.220
Now, the things I want to talk
about here are just focused

00:01:05.360 --> 00:01:07.000
mostly on NS Document support.

00:01:07.000 --> 00:01:10.360
I'm also going to talk about autosave,
which we introduced in Lion.

00:01:10.540 --> 00:01:13.600
I'm also going to talk about a few
new changes made in File Manager.

00:01:13.710 --> 00:01:16.390
But before I start that,
I want to do a quick demo.

00:01:16.530 --> 00:01:19.600
So here we have a machine with
a user signed into iCloud.

00:01:19.600 --> 00:01:21.280
I'm going to launch TextEdit.

00:01:21.390 --> 00:01:24.800
As you know,
TextEdit is an NS Document-based app.

00:01:24.930 --> 00:01:29.000
And when you first launch it,
you get your new iCloud open panel.

00:01:29.170 --> 00:01:32.140
Right now there are no documents,
so this is what you get by default

00:01:32.140 --> 00:01:33.340
when you have no documents.

00:01:33.400 --> 00:01:37.600
Note that this open panel can
also show your local file system.

00:01:37.600 --> 00:01:40.730
By clicking up here,
you get your traditional open panel

00:01:40.730 --> 00:01:43.140
looking into your local file systems.

00:01:43.140 --> 00:01:47.590
You can change the view modes and so
on just through these buttons here.

00:01:48.050 --> 00:01:49.290
There's a new document button here.

00:01:49.320 --> 00:01:51.020
I'll go ahead and press it.

00:01:51.020 --> 00:01:52.520
And now you've got a new document.

00:01:52.570 --> 00:01:55.800
Now note that I can still
bring up the open panel.

00:01:56.140 --> 00:01:57.150
and it's actually non-modal.

00:01:57.150 --> 00:02:00.030
I can interact with my document
while I'm interacting with the

00:02:00.030 --> 00:02:04.020
Open Panel as well because it will
enable you to manipulate your document

00:02:04.110 --> 00:02:06.920
directly from within the app without
having to bring up a modal panel.

00:02:06.920 --> 00:02:07.460
Okay.

00:02:07.460 --> 00:02:10.940
So let's go ahead and type
some stuff in my document.

00:02:10.960 --> 00:02:13.650
I'm going to literally type some stuff.

00:02:13.760 --> 00:02:14.730
Now look here.

00:02:14.730 --> 00:02:17.540
I typed some stuff into
my untitled document,

00:02:17.550 --> 00:02:21.570
and within just a few seconds,
it actually got saved automatically,

00:02:21.810 --> 00:02:24.520
and it got put into iCloud,
and within a few more seconds

00:02:24.520 --> 00:02:27.840
or however long it takes,
it will appear on your other machines

00:02:27.840 --> 00:02:29.840
where you're signed into iCloud.

00:02:30.010 --> 00:02:34.130
So we are saving untitled documents
now visibly because we want them to

00:02:34.160 --> 00:02:35.580
be available on all your machines.

00:02:35.580 --> 00:02:37.910
You don't want to be in a
situation where you're at work,

00:02:38.020 --> 00:02:40.720
you're working on a new document,
new ideas, then you forget to save,

00:02:40.770 --> 00:02:42.840
you go home,
and the document isn't there.

00:02:42.920 --> 00:02:46.850
We want the documents to
be available at all times.

00:02:47.260 --> 00:02:48.360
Now, let's see.

00:02:48.360 --> 00:02:49.950
I want to show you a few other things.

00:02:49.960 --> 00:02:52.170
We made some changes to the file menu.

00:02:52.720 --> 00:02:56.070
There are now new items for renaming
documents and moving documents.

00:02:56.140 --> 00:02:57.640
I'll show these in a second.

00:02:57.680 --> 00:03:01.170
We've also brought back Save As as an
alternate to the duplicate menu item

00:03:01.270 --> 00:03:04.470
for those of you who missed it in Lion.

00:03:07.280 --> 00:03:10.900
The title bar menu, which is available on
NS document-based apps,

00:03:11.020 --> 00:03:14.170
also has similar functionality, rename,
move to, et cetera.

00:03:14.290 --> 00:03:18.590
There's also a richer revert submenu,
which actually gives you access

00:03:18.690 --> 00:03:23.180
to some interesting versions you
might want to directly revert to.

00:03:23.260 --> 00:03:25.310
Now I'm going to use
some of these menu items.

00:03:25.310 --> 00:03:27.160
Let's, for instance, use rename.

00:03:27.160 --> 00:03:29.730
If you can see up there,
the title bar now turned -- you can

00:03:29.750 --> 00:03:31.500
rename directly in the title bar.

00:03:31.570 --> 00:03:34.620
I have renamed my document, renamed here.

00:03:34.710 --> 00:03:37.320
I will also go ahead
and move it from here,

00:03:37.320 --> 00:03:40.000
and I will choose to move it to desktop.

00:03:40.110 --> 00:03:42.880
And the document moves out
of iCloud onto my desktop.

00:03:42.940 --> 00:03:46.300
I can, again, move it back from here,
or I can just simply drag it

00:03:46.300 --> 00:03:48.100
from here into the open panel.

00:03:48.180 --> 00:03:52.140
So the open panel does have these
richer document manipulations directly.

00:03:52.140 --> 00:03:56.270
It allows richer manipulation of
documents from within the app without

00:03:56.940 --> 00:03:59.320
having to go out to the finder.

00:03:59.470 --> 00:03:59.830
Okay.

00:03:59.830 --> 00:04:03.650
So the last thing I want to show you
is some of the support we've added

00:04:03.650 --> 00:04:07.900
in this document for handling with
iCloud error conditions and some

00:04:08.120 --> 00:04:10.200
other things you might encounter.

00:04:10.200 --> 00:04:11.790
And I'm going to show just one of them.

00:04:11.890 --> 00:04:15.000
And I'm going to go
ahead and turn off Wi-Fi.

00:04:15.000 --> 00:04:16.590
Normally not a good
thing to do in a demo.

00:04:16.640 --> 00:04:20.350
I'm going to come ahead -- come into
my document here and type more stuff.

00:04:20.350 --> 00:04:23.210
And when I do that,
you'll notice that I get this

00:04:23.370 --> 00:04:26.390
gentle popover telling me
that iCloud is not reachable.

00:04:26.700 --> 00:04:28.040
Now my document is still being saved.

00:04:28.040 --> 00:04:29.200
It's being saved locally.

00:04:29.200 --> 00:04:31.900
It's just I'm getting warned
that the document is not

00:04:31.900 --> 00:04:33.500
going to my other machines.

00:04:33.630 --> 00:04:36.160
Now, this popover is truly gentle.

00:04:36.250 --> 00:04:38.400
I can still continue typing.

00:04:38.420 --> 00:04:39.570
And it will dismiss itself.

00:04:39.570 --> 00:04:42.250
However, it's just sort of there,
you know, reminding me.

00:04:42.250 --> 00:04:45.600
And if I bring up the title bar menu,
I can still see the warning here until

00:04:45.600 --> 00:04:48.120
the error corrects itself because,
let's say,

00:04:48.120 --> 00:04:52.680
the shuttle bus gets out of the
tunnel and I can access iCloud again.

00:04:52.680 --> 00:04:55.460
So this is sort of a non-modal
alert situation that you might

00:04:55.510 --> 00:04:57.000
get in other cases as well.

00:04:57.070 --> 00:05:01.540
You can imagine, you know,
network is not always predictable.

00:05:01.540 --> 00:05:03.270
So with that,
let's go back to our slides.

00:05:03.320 --> 00:05:03.520
So let's go back to our slides.

00:05:04.670 --> 00:05:07.280
So I showed you the iCloud open panel.

00:05:07.280 --> 00:05:10.230
It's a nice, clean look into your files.

00:05:10.540 --> 00:05:12.110
And you also still have access to,
of course,

00:05:12.120 --> 00:05:16.110
all your local documents through
using the more traditional view.

00:05:16.560 --> 00:05:22.180
The Lion file menu looks like this,
and we've added two new items,

00:05:22.180 --> 00:05:24.100
Rename and Move To.

00:05:24.100 --> 00:05:27.890
And we've made these available
on your title bar menu as well,

00:05:27.890 --> 00:05:30.300
which you can just get by
clicking on the title bar there,

00:05:30.300 --> 00:05:31.200
Rename, Move To.

00:05:31.200 --> 00:05:32.940
And of course,
you have a richer Revert To menu,

00:05:32.940 --> 00:05:33.560
as I showed.

00:05:34.100 --> 00:05:37.820
This is a bigger picture of that
non-modal alert you might get.

00:05:37.990 --> 00:05:41.000
One thing I didn't show you during
the demo is our conflict resolution.

00:05:41.020 --> 00:05:44.190
If you edit the same document
on two different machines and

00:05:44.190 --> 00:05:47.700
somehow do create a conflict,
you will get a panel like this.

00:05:47.800 --> 00:05:50.660
You can choose to keep one of the
documents or both of the documents

00:05:50.660 --> 00:05:52.180
and maybe deal with it later.

00:05:52.180 --> 00:05:54.340
So it's fairly straightforward,
and this is, again,

00:05:54.360 --> 00:05:55.480
built into an S document.

00:05:55.480 --> 00:05:59.070
So, you know, you're looking at all these
features and wondering how much

00:05:59.110 --> 00:06:00.650
new code do you need to write.

00:06:00.700 --> 00:06:04.870
Of course,
when I ask a question like this on

00:06:04.870 --> 00:06:07.310
stage and it's a Cocoa conference,
you know that the answer

00:06:07.400 --> 00:06:08.930
isn't going to be 1,000.

00:06:08.930 --> 00:06:11.230
It's not going to be 100
lines of code either.

00:06:11.230 --> 00:06:13.060
It's not going to be 10 lines of code.

00:06:13.060 --> 00:06:14.670
It's not going to be one line of code.

00:06:14.670 --> 00:06:16.130
In this case, it's really free.

00:06:16.130 --> 00:06:17.650
It's zero lines of code.

00:06:17.660 --> 00:06:20.890
If you have an S document-based app,
that's autosave enabled,

00:06:20.900 --> 00:06:23.850
and you've adopted the iCloud
containers entitlement.

00:06:23.850 --> 00:06:26.970
So if you've already done this,
your app will magically start

00:06:26.970 --> 00:06:30.230
working with the iCloud like
I showed you in Mountain Lion.

00:06:32.290 --> 00:06:36.020
Now let me give you a quick
recap of autosave because I just

00:06:36.130 --> 00:06:37.760
mentioned that autosave was

00:06:38.710 --> 00:06:41.980
One of the big, of course,
benefits of autosave is that it

00:06:41.980 --> 00:06:43.790
eliminates the need for Command-S.

00:06:43.890 --> 00:06:47.980
Users no longer have to hit
Command-S to rename their --

00:06:48.080 --> 00:06:49.280
originally save their document.

00:06:49.370 --> 00:06:52.080
They don't have to hit
Command-S on an ongoing basis to

00:06:52.080 --> 00:06:54.700
continue saving that document.

00:06:54.700 --> 00:06:57.460
You know,
it's -- the document -- the model is that

00:06:57.550 --> 00:07:01.740
the document on the screen is exactly
the same as document that's on disk.

00:07:01.820 --> 00:07:05.380
Another benefit of autosave
is that we can now quit apps,

00:07:05.440 --> 00:07:08.180
restart the system,
apply software updates

00:07:08.210 --> 00:07:12.080
without much hassle,
because the system can now, at any point,

00:07:12.080 --> 00:07:14.820
quit your app,
saving your changes beforehand

00:07:14.920 --> 00:07:18.180
without having to ask you,
do you want to save your changes?

00:07:18.180 --> 00:07:20.220
So this is another benefit of autosave.

00:07:20.420 --> 00:07:23.840
And with iCloud,
we now have a third benefit to autosave,

00:07:23.840 --> 00:07:29.390
and that's that autosave greatly
reduces the chance of conflicts.

00:07:29.450 --> 00:07:34.410
I mean, if you can imagine a user using a
machine somewhere with a manual saving,

00:07:34.460 --> 00:07:34.830
it's going to be a lot easier
to save the changes and they

00:07:34.830 --> 00:07:37.540
don't hit save for a few hours,
then they leave that machine,

00:07:37.570 --> 00:07:39.370
go elsewhere and work
on the same document.

00:07:39.370 --> 00:07:42.040
That's just going to create conflicts,
and having to deal with

00:07:42.040 --> 00:07:44.800
conflicts is really not,
you know, a good user experience.

00:07:45.050 --> 00:07:47.310
But by autosaving constantly -- and,
you know,

00:07:47.450 --> 00:07:51.060
that's the model -- we really do
reduce the chance of conflicts greatly.

00:07:54.300 --> 00:07:56.160
So please,
if you have a document-based app,

00:07:56.270 --> 00:07:57.040
adopt autosave.

00:07:57.040 --> 00:07:58.660
And even if you don't
have a document-based app,

00:07:58.690 --> 00:08:01.330
autosave is a great model for
the Macintosh user experience,

00:08:01.330 --> 00:08:02.640
of course, moving forward.

00:08:02.640 --> 00:08:05.470
So how much work is it to adopt autosave?

00:08:05.480 --> 00:08:07.600
Well, it turns out it's a lot more
work than adopting iCloud,

00:08:07.600 --> 00:08:09.940
and by that I mean it's one
line of code you have to write,

00:08:10.030 --> 00:08:10.500
not zero.

00:08:10.500 --> 00:08:12.860
You override this method and return yes.

00:08:14.150 --> 00:08:15.860
There are a few other considerations.

00:08:16.010 --> 00:08:20.680
If you put up your own UIs, custom UIs,
or if you touch the files

00:08:21.120 --> 00:08:23.460
behind NS documents back,
you need to ensure

00:08:23.460 --> 00:08:26.250
serialization of those accesses.

00:08:26.340 --> 00:08:29.770
You need to save more efficiently
if your document format is large,

00:08:29.770 --> 00:08:32.440
and you might need to take
versions into account.

00:08:32.440 --> 00:08:35.030
Although versions are automatic,
there are some things you can do

00:08:35.030 --> 00:08:36.410
to make the experience better.

00:08:36.420 --> 00:08:39.420
And I will give you a pointer to
another talk later in the week where

00:08:39.420 --> 00:08:41.020
we'll cover these in more depth.

00:08:41.120 --> 00:08:43.580
Now, I also mentioned NS File Manager.

00:08:43.720 --> 00:08:47.110
We made two API additions
to File Manager to make

00:08:47.110 --> 00:08:49.380
working with iCloud easier.

00:08:49.380 --> 00:08:52.590
Now, these are methods you likely
won't need to use if you're

00:08:52.590 --> 00:08:55.600
an NS document-based app,
because we really do everything for

00:08:55.600 --> 00:08:57.060
you in an NS document-based app.

00:08:57.160 --> 00:08:58.880
However,
if you're not an NS document-based,

00:08:58.890 --> 00:09:00.670
these are methods you
might want to look at.

00:09:00.700 --> 00:09:03.700
There's a quick way to check
the current iCloud user now.

00:09:03.700 --> 00:09:05.040
This is pretty fast.

00:09:05.040 --> 00:09:06.480
You can call it from the main thread.

00:09:06.480 --> 00:09:09.310
It returns an opaque
object that you can copy,

00:09:09.330 --> 00:09:12.040
you can code, Ubiquiti identity token.

00:09:12.040 --> 00:09:13.500
This will return nil.

00:09:13.620 --> 00:09:15.580
If the user is not logged into iCloud.

00:09:15.580 --> 00:09:19.190
You can also hear about changes
to the current iCloud user by

00:09:19.310 --> 00:09:20.960
listening for this notification.

00:09:20.960 --> 00:09:24.980
So with these, if you need to deal with
iCloud at a lower level,

00:09:25.290 --> 00:09:26.990
these are good APIs to consider.

00:09:27.000 --> 00:09:31.230
Okay, so with that,
let's switch to high resolution.

00:09:31.360 --> 00:09:36.490
And I'm saying this time it's for real,
because some of you may know that

00:09:36.530 --> 00:09:39.400
we've actually been talking about
high resolution for a while now.

00:09:39.400 --> 00:09:41.580
And to show that,
I want to get on our high

00:09:41.590 --> 00:09:43.220
resolution time machine.

00:09:43.440 --> 00:09:46.990
Now, I don't literally mean time machine,
the backup mechanism we have.

00:09:47.010 --> 00:09:48.320
I mean a literal time machine.

00:09:48.320 --> 00:09:50.170
I don't really mean a
literal time machine,

00:09:50.170 --> 00:09:51.930
because we don't have such a thing yet.

00:09:51.950 --> 00:09:56.050
So I do mean just a little
browser through past WWDC.

00:09:56.170 --> 00:09:59.050
So I'm going to put up some slides,
some with quaint fonts.

00:09:59.180 --> 00:10:02.600
And the first one comes from 2002,
where we apparently put this

00:10:02.600 --> 00:10:05.270
slide at the last bullet item
telling you that NS image is a

00:10:05.270 --> 00:10:08.320
high-level resolution-dependent
abstraction of images.

00:10:08.320 --> 00:10:10.280
As you know,
resolution-dependence is what

00:10:10.280 --> 00:10:11.920
makes high resolution possible.

00:10:11.920 --> 00:10:13.420
And we're telling you about this.

00:10:13.420 --> 00:10:14.460
And we're telling you
about this 10 years ago.

00:10:14.460 --> 00:10:20.350
And then fast forward two years, 2004,
we told you in big font,

00:10:20.350 --> 00:10:23.270
one point is not equal to one pixel.

00:10:26.200 --> 00:10:28.660
Also in 2004,
we gave you this panel that lets you

00:10:28.660 --> 00:10:33.520
actually run at higher resolutions
to test your high-resolution apps.

00:10:34.250 --> 00:10:38.160
In 2005, we put up this slide,
Stuff You Should Not Be Doing.

00:10:38.160 --> 00:10:39.380
It's all about 64-bit.

00:10:39.530 --> 00:10:40.500
Somehow we snuck in there.

00:10:40.500 --> 00:10:42.710
Don't assume one pixel is one point.

00:10:42.750 --> 00:10:44.300
Again, the same message.

00:10:44.330 --> 00:10:47.700
In 2006, we told you,
use vector art or provide 1

00:10:47.700 --> 00:10:49.770
and 4x bitmap representations.

00:10:49.770 --> 00:10:52.050
Back then, we were recommending 4x.

00:10:52.050 --> 00:10:53.530
We are not these days.

00:10:54.560 --> 00:10:57.590
In 2007,
we put this gorgeous rendering of Aqua.

00:10:57.590 --> 00:10:59.970
It looks super,
except we didn't quite get the

00:10:59.970 --> 00:11:01.930
window title corner there right.

00:11:01.960 --> 00:11:03.060
There's a little pixelated.

00:11:03.070 --> 00:11:04.880
I guess that's why we
didn't ship back then.

00:11:04.880 --> 00:11:09.440
Also in 2007,
we told you to be ready by 2008.

00:11:12.360 --> 00:11:14.500
2008, we were quiet.

00:11:14.500 --> 00:11:17.540
2009, we were quiet.

00:11:17.580 --> 00:11:20.980
In 2010, of course,
we introduced the iPhone 4 with

00:11:21.010 --> 00:11:25.180
the gorgeous retina display,
a revolutionary device.

00:11:25.180 --> 00:11:26.950
And last year at WWDC,
we did talk to you about

00:11:26.950 --> 00:11:30.390
resolution dependence,
again, in the context of Mac OS X.

00:11:30.390 --> 00:11:34.020
We talked about the new
core screen scaling,

00:11:34.060 --> 00:11:35.950
and we also said back to the Mac.

00:11:36.080 --> 00:11:39.060
We explicitly said back to
the Mac last year at WWDC.

00:11:39.180 --> 00:11:40.600
This is an actual slide.

00:11:40.690 --> 00:11:43.000
And, of course, earlier this year,
the gorgeous new iPad

00:11:43.060 --> 00:11:45.420
with the retina display,
and as most of you

00:11:45.420 --> 00:11:48.240
probably heard yesterday,
we introduced the new

00:11:48.240 --> 00:11:49.800
retina display MacBook Pro.

00:11:50.070 --> 00:11:53.780
So anyway, it's been a long path,
but we're finally here.

00:11:53.780 --> 00:11:59.060
And, yeah, so let me just talk to you
about how we do high resolution.

00:11:59.060 --> 00:12:04.080
High resolution on OS X is -- uses
an integral to X scale factor,

00:12:04.080 --> 00:12:07.780
so it's a simplifying
assumption like we do on iOS.

00:12:07.810 --> 00:12:10.470
By default, existing apps do run at 2X.

00:12:10.670 --> 00:12:13.430
So existing Cocoa apps,
even one you shipped last

00:12:13.440 --> 00:12:15.740
year or the year before,
will run at 2X.

00:12:15.800 --> 00:12:22.140
It will have crisp text, crisp pads,
crisp PDFs by default for the most part.

00:12:22.140 --> 00:12:25.320
The only thing that you might need
to do is provide 2X bitmap artwork,

00:12:25.480 --> 00:12:27.810
because artwork is clearly 1X, of course.

00:12:27.950 --> 00:12:30.620
It will be scaled up,
so you will get not as

00:12:30.620 --> 00:12:32.660
crisp as possible artwork.

00:12:32.800 --> 00:12:35.190
However, though,
most applications should work well,

00:12:35.320 --> 00:12:37.860
and many elements should
work -- should look crisp.

00:12:37.860 --> 00:12:41.460
We do want you to, of course,
take advantage of the retina

00:12:41.460 --> 00:12:45.560
display as quickly as possible
by providing 2X artwork.

00:12:45.700 --> 00:12:47.920
There's a low resolution
mode where apps run at 1X.

00:12:48.020 --> 00:12:50.270
This is for maximal compatibility.

00:12:50.270 --> 00:12:52.560
This is magnified to 2X on screen.

00:12:52.560 --> 00:12:57.010
It's the default for Carbon applications
and also for some Cocoa applications,

00:12:57.030 --> 00:12:58.370
which we know have trouble.

00:12:58.560 --> 00:13:00.920
And users can also select this if,
for instance,

00:13:00.920 --> 00:13:03.980
an app they're trying to use on the
retina display isn't behaving or maybe

00:13:03.980 --> 00:13:06.260
it has a plug-in that's not behaving.

00:13:06.260 --> 00:13:06.260
They can actually bring
up the app and say,

00:13:06.260 --> 00:13:08.620
"Hey, I'm going to use this." They can
actually bring up the info panel,

00:13:08.620 --> 00:13:10.420
and you see a checkbox
in the bottom there,

00:13:10.420 --> 00:13:13.410
sort of analogous to the 64,
32-bit checkbox we have,

00:13:13.470 --> 00:13:16.020
and they can click
open in low resolution.

00:13:16.090 --> 00:13:20.850
So if an app seems to have troubles,
this is a one-user way to fix it.

00:13:22.540 --> 00:13:27.970
Now, high resolution on OS X has
some things to deal with.

00:13:28.080 --> 00:13:29.600
For instance,
a user might actually move a

00:13:29.620 --> 00:13:33.560
window from a retina display to
a 1X display on the same device.

00:13:33.650 --> 00:13:38.310
And that requires rebuilding the window,
maybe redrawing the content so

00:13:38.310 --> 00:13:39.960
it looks optimal on that display.

00:13:39.960 --> 00:13:42.540
A lot of AppKit classes
have automatic behaviors.

00:13:42.540 --> 00:13:43.880
I already talked about NSImage.

00:13:43.880 --> 00:13:46.030
It has support for
multiple representations,

00:13:46.100 --> 00:13:48.010
and it can choose
between them on the fly,

00:13:48.130 --> 00:13:50.740
depending on what kind of
window it's drawing into.

00:13:51.590 --> 00:13:54.250
NSView has automatic
scaling of layer backing.

00:13:54.250 --> 00:14:02.050
If you told NSView to be layer backed,
it will automatically do the right thing.

00:14:02.290 --> 00:14:05.270
NSTextView has support for
fractional advances by default.

00:14:05.450 --> 00:14:09.580
If your app is linked against 10.8,
we use fractional spaces,

00:14:09.580 --> 00:14:13.430
which gives you much more
gorgeous text on retina displays.

00:14:13.520 --> 00:14:17.010
And NSColor has support for patterns,
where most of the time you

00:14:17.010 --> 00:14:20.480
don't have to do anything to
get correct pattern behaviors.

00:14:20.580 --> 00:14:21.970
Same for shadow with shadow behaviors.

00:14:22.030 --> 00:14:23.140
It's all automatic.

00:14:23.240 --> 00:14:26.740
And AutoLayout also helps in
creating Nib files that are

00:14:26.740 --> 00:14:29.570
definitely resolution independent.

00:14:30.220 --> 00:14:33.030
Now, one API I do want to talk
about is block-based NSImage.

00:14:33.270 --> 00:14:38.480
This replaces most uses of the
lock focus method in NSImage,

00:14:38.490 --> 00:14:40.570
which is a popular method.

00:14:40.670 --> 00:14:43.700
Lock focus draws in a single
bitmap representation.

00:14:43.700 --> 00:14:45.700
It's not appropriate
for different contexts.

00:14:45.840 --> 00:14:48.830
It will capture NSImage
in 1X or maybe 2X,

00:14:48.830 --> 00:14:51.090
but it will not change dynamically.

00:14:51.700 --> 00:14:55.920
This new method in Mountain Lion,
ImageWithSize flipped drawing handler,

00:14:55.930 --> 00:14:59.300
it takes a block that will be
called to recreate the image.

00:14:59.300 --> 00:15:04.400
Let me give you a code snippet.

00:15:04.400 --> 00:15:04.400
In Lion, here's what you might do.

00:15:05.060 --> 00:15:07.140
Create an image, lock focus.

00:15:07.440 --> 00:15:10.080
And let's say you go
ahead and draw a red oval,

00:15:10.080 --> 00:15:10.860
and unlock focus.

00:15:10.860 --> 00:15:14.640
Now you've created an image at a certain
size with a certain color profile,

00:15:14.640 --> 00:15:15.380
and so on.

00:15:15.410 --> 00:15:17.390
The mountain line equivalent
would be like this,

00:15:17.390 --> 00:15:20.240
where you create your image
using this new method,

00:15:20.240 --> 00:15:24.100
and you provide a block which
does the appropriate drawing.

00:15:24.120 --> 00:15:28.260
We will call this block whenever needed,
but we will not call it all the time.

00:15:28.260 --> 00:15:30.020
We will actually cache the results.

00:15:30.050 --> 00:15:31.890
For instance,
if your window moves from one screen to

00:15:31.930 --> 00:15:36.420
the other or the color profile changes,
et cetera, this might get called.

00:15:39.150 --> 00:15:41.240
Now, high resolution,
you can actually enable 2X

00:15:41.330 --> 00:15:42.540
modes on your Mac right now.

00:15:42.540 --> 00:15:44.910
I know all of you have
ordered the new machines,

00:15:44.910 --> 00:15:46.700
but you don't have to
wait for the delivery.

00:15:46.700 --> 00:15:48.340
You can actually do this today.

00:15:48.340 --> 00:15:51.130
Download the graphics
tools for Xcode package.

00:15:51.130 --> 00:15:52.800
Open Quartz debug.

00:15:52.800 --> 00:15:57.250
Choose UI resolution from the menu
bar and enable high display modes.

00:15:57.440 --> 00:15:59.610
There's a checkbox,
which you can just go ahead and check.

00:15:59.630 --> 00:16:01.970
Once you've done that,
in system preferences,

00:16:01.970 --> 00:16:03.690
you get all these great new modes.

00:16:03.740 --> 00:16:07.420
For instance, on a 27-inch Apple display,
you'll see 1280 by 720,

00:16:07.420 --> 00:16:09.080
but it's the high DPI mode.

00:16:09.100 --> 00:16:10.550
We're 4 pixels make up a point.

00:16:10.550 --> 00:16:12.530
So you can actually test
your apps right now.

00:16:12.540 --> 00:16:14.980
Okay, so let's move on to gestures.

00:16:14.980 --> 00:16:17.710
As you know,
we've been adding a lot of great

00:16:17.810 --> 00:16:20.810
gesture support to the system and
also to AppKit over the years.

00:16:20.810 --> 00:16:22.640
In the Mountain Lion, we've done more.

00:16:22.640 --> 00:16:25.600
First,
we have some automatic behavior changes.

00:16:25.600 --> 00:16:29.770
These are changes that you will
get without having to do anything.

00:16:29.780 --> 00:16:31.950
One is accelerated scrolling.

00:16:31.950 --> 00:16:36.000
If you actually do quick scroll
gesture three times in a row,

00:16:36.000 --> 00:16:38.020
the acceleration curve ramps up.

00:16:38.500 --> 00:16:40.470
And that allows you,
by continuing to scroll,

00:16:40.570 --> 00:16:45.210
to get to the bottom or top of a long
document much more quickly than before.

00:16:45.750 --> 00:16:48.390
There is new overlay look
-- overlay scroller look and

00:16:48.390 --> 00:16:50.000
behaviors in Mountain Lion.

00:16:50.000 --> 00:16:52.990
For instance, if you put two fingers
down on your trackpad,

00:16:53.090 --> 00:16:54.880
the scroller becomes visible now.

00:16:54.890 --> 00:16:55.900
It appears.

00:16:55.930 --> 00:16:58.150
That lets you sort of get a sense
for where you are in the document

00:16:58.150 --> 00:16:59.460
and how big your document is.

00:16:59.460 --> 00:17:02.770
And if you roll over a visible scroller,
it will expand now,

00:17:02.770 --> 00:17:04.510
allowing you to get a better grip on it.

00:17:04.510 --> 00:17:07.400
This is, again,
all automatic within a scroll view.

00:17:07.490 --> 00:17:09.820
And also, smooth scrolling option,
which used to be an

00:17:09.820 --> 00:17:14.170
option system preference,
is now on by default all the time.

00:17:14.550 --> 00:17:16.780
Now,
some behaviors you might choose to adopt.

00:17:16.840 --> 00:17:18.440
Magnification.

00:17:18.440 --> 00:17:21.960
As you know, magnification is achieved
by pinching in and out.

00:17:22.180 --> 00:17:24.880
And the scroll view now has
support for it out of the box.

00:17:24.990 --> 00:17:26.970
You call allows magnification, yes.

00:17:26.980 --> 00:17:30.100
And then you can set the
magnification factor.

00:17:30.100 --> 00:17:31.010
You can set other parameters.

00:17:31.140 --> 00:17:32.660
There are also some convenience methods.

00:17:32.660 --> 00:17:36.920
For instance,
you can magnify to fit a certain rect.

00:17:36.930 --> 00:17:41.570
Just call this to just magnify a
certain rect within your scroll view.

00:17:41.570 --> 00:17:41.570
So fairly easy to use.

00:17:42.400 --> 00:17:45.140
So, at this point,
let me just do a little detour and

00:17:45.260 --> 00:17:49.560
talk just a bit about animation and one
of the ways we do animation in Cocoa,

00:17:49.600 --> 00:17:53.840
and that's the protocol,
animatable property container protocol.

00:17:53.840 --> 00:17:56.020
It has a bunch of methods,
but one of the methods

00:17:56.020 --> 00:17:57.350
is this animator method.

00:17:57.360 --> 00:18:03.290
The animator method returns a proxy,
and this proxy acts like the object,

00:18:03.370 --> 00:18:06.930
except that it animates
most property sets,

00:18:06.950 --> 00:18:11.090
property changes,
or other methods sent to it.

00:18:11.760 --> 00:18:15.110
For instance,
NSView conforms to this protocol.

00:18:15.110 --> 00:18:16.880
That means it has the animator method.

00:18:16.880 --> 00:18:21.430
A bunch of other classes do as well,
such as NSWindow and NSLayout constraint.

00:18:21.650 --> 00:18:26.340
Now, if you told a scroll view,
set magnification 2.0,

00:18:26.340 --> 00:18:27.280
that happens immediately.

00:18:27.370 --> 00:18:28.280
There's no animation.

00:18:28.280 --> 00:18:31.620
The scroll view will
simply magnify to 2.0.

00:18:31.620 --> 00:18:34.570
But if you did want to magnify
in an animated fashion,

00:18:34.570 --> 00:18:36.400
you can talk to the animator.

00:18:36.400 --> 00:18:39.860
So simply, my scroll view animator,
set magnification 2.0.

00:18:40.320 --> 00:18:42.680
Similarly,
you can send one of the other methods,

00:18:42.770 --> 00:18:45.480
magnify to FitRect, again,
to the animator.

00:18:45.480 --> 00:18:54.520
And many other classes work this way.

00:18:54.520 --> 00:18:54.520
If you want to animate,
which is often appropriate

00:18:54.520 --> 00:18:54.520
when simulating a user action,
this is what you might want to do.

00:18:55.280 --> 00:18:57.200
OK, so back to ScrollView.

00:18:57.210 --> 00:19:00.370
Smart magnification is something
new we've added to NSScrollView.

00:19:00.590 --> 00:19:04.630
This is a feature that
first appeared in Safari.

00:19:04.740 --> 00:19:07.440
This is two-finger double
tap to automatically zoom

00:19:07.440 --> 00:19:09.790
into areas of interest.

00:19:10.310 --> 00:19:14.720
scroll view has default behavior
where if it's at 100%, it will magnify

00:19:14.720 --> 00:19:21.290
to 150%. If it is at anything other
than 100%, it will go back to 100%.

00:19:21.710 --> 00:19:24.820
will support this out of the box,
where it will smart

00:19:24.970 --> 00:19:28.550
magnify image attachments,
it will smart magnify tables,

00:19:28.550 --> 00:19:32.640
it will actually dive into tables
as you continue to smart magnify.

00:19:32.640 --> 00:19:36.280
And you can also customize this
in your own view subclasses.

00:19:36.320 --> 00:19:38.320
You can either listen to
event or respond to method,

00:19:38.320 --> 00:19:42.040
or you can override this convenient
method for smart magnification at point

00:19:42.280 --> 00:19:47.510
in rect and return the rect of interest
that the system should magnify to.

00:19:48.510 --> 00:19:49.240
Quick look.

00:19:49.360 --> 00:19:50.460
This is three-finger tap.

00:19:50.580 --> 00:19:52.880
It used to be three-finger
double tap in Lion.

00:19:53.180 --> 00:19:56.880
This, for instance, brings up in Lion,
it brings up the lookup panel,

00:19:56.880 --> 00:19:59.340
dictionary or thesaurus lookup,
for instance.

00:19:59.810 --> 00:20:05.290
There are new responder methods you
can listen to and take custom action.

00:20:06.680 --> 00:20:10.040
This is implemented by TextView as
well to actually do a quick look on

00:20:10.040 --> 00:20:12.500
attachments that may be in the TextView.

00:20:12.590 --> 00:20:15.090
And by default,
if you don't respond to this,

00:20:15.110 --> 00:20:19.460
NS application still does a
dictionary lookup like it did in Lion.

00:20:21.760 --> 00:20:24.580
And the last thing I want to talk about
in this section is NSPageController.

00:20:24.580 --> 00:20:27.650
NSPageController is a new class,
and it's for efficient

00:20:27.820 --> 00:20:29.540
swipe navigation of views.

00:20:29.620 --> 00:20:31.590
And when I say efficient,
that is really one of

00:20:31.590 --> 00:20:32.860
its primary goals here.

00:20:32.860 --> 00:20:39.090
NSPageController really tries to keep
the user experience very responsive.

00:20:39.380 --> 00:20:42.590
So it's going to be doing
asynchronous caching of your content,

00:20:42.680 --> 00:20:45.290
and just doing a lot of things in
the background to make sure the

00:20:45.290 --> 00:20:47.050
user experience remains fluid.

00:20:47.140 --> 00:20:50.170
It's got three transition styles.

00:20:51.200 --> 00:20:52.700
And these are all things
you've seen in the system.

00:20:52.700 --> 00:20:54.200
The first style is history.

00:20:54.200 --> 00:20:56.660
This is something like
you might see in Safari,

00:20:56.660 --> 00:20:59.730
where the model is new pages are
coming in from the right side,

00:20:59.730 --> 00:21:01.780
and it's appropriate for
something like Safari,

00:21:01.890 --> 00:21:04.970
where the user is just choosing
new pages to move forward to.

00:21:05.080 --> 00:21:07.100
Here's how it looks.

00:21:07.100 --> 00:21:08.430
Pages are coming in from the right side.

00:21:08.590 --> 00:21:10.060
And, of course,
the user can still push them out

00:21:10.060 --> 00:21:11.800
of the way if they want to go back.

00:21:11.980 --> 00:21:15.500
The book style is appropriate for books,
PDFs, or even pictures.

00:21:15.500 --> 00:21:18.490
Here the model is you have a pile
of things in front of you already,

00:21:18.490 --> 00:21:22.120
and you're pushing pushing them
out of the way towards the left.

00:21:22.120 --> 00:21:24.150
Here's what that looks like.

00:21:26.000 --> 00:21:28.030
So again,
it's appropriate for a book or photos,

00:21:28.090 --> 00:21:30.700
and this was preview just
with a pile of photos.

00:21:30.800 --> 00:21:33.640
And finally, the strip style,
where your views are

00:21:33.640 --> 00:21:34.930
just laid side by side.

00:21:35.030 --> 00:21:37.810
This is something like you
see with full screen spaces,

00:21:37.910 --> 00:21:41.230
where you're just moving them
left to right and just choosing

00:21:41.230 --> 00:21:42.270
which one you want to go to.

00:21:42.290 --> 00:21:43.840
So pretty straightforward.

00:21:43.900 --> 00:21:49.000
Page controller model is that
it manages an array of content,

00:21:49.260 --> 00:21:50.660
arranged objects.

00:21:50.660 --> 00:21:53.710
This is appropriate
for like the book mode,

00:21:53.710 --> 00:21:57.340
where you already know what you have,
and there's a selected index

00:21:57.340 --> 00:21:59.300
pointing into this array.

00:21:59.710 --> 00:22:02.890
Or you can create content from
navigation history by using this method,

00:22:02.900 --> 00:22:04.580
navigate forward to object.

00:22:04.630 --> 00:22:07.660
This adds new objects to the history,
and as you go back,

00:22:07.660 --> 00:22:10.070
it will also remove them from history.

00:22:10.350 --> 00:22:12.920
Now, again,
earlier I talked about animation.

00:22:13.070 --> 00:22:15.000
You can, for instance,
tell the page controller's

00:22:15.000 --> 00:22:18.350
animator to set selected index
or to navigate forward to object,

00:22:18.350 --> 00:22:20.550
and it will animate instead
of doing it immediately.

00:22:20.670 --> 00:22:23.220
Always something good,
something to keep in mind there.

00:22:23.420 --> 00:22:26.510
Okay,
let's move on to layer-backed views.

00:22:26.560 --> 00:22:28.520
Just a quick recap.

00:22:29.450 --> 00:22:33.200
We added this feature for
layer-backed views in 10.5.

00:22:33.200 --> 00:22:35.560
You make a view layer-backed
by calling setOnceLayer,

00:22:35.560 --> 00:22:38.940
or you can actually enable a
checkbox interface builder.

00:22:38.980 --> 00:22:43.400
This creates a core animation backing
store for the view and all its subviews.

00:22:43.400 --> 00:22:45.810
This gives you smoother animations.

00:22:46.070 --> 00:22:47.720
It also gives you better responsiveness.

00:22:47.720 --> 00:22:51.580
However, fundamentally,
drawRect is still called as before

00:22:51.710 --> 00:22:54.720
whenever that layer needs to be updated.

00:22:54.780 --> 00:22:58.320
Think of the layer as bitmap
that corresponds to your view,

00:22:58.320 --> 00:23:02.010
and we call drawRect to update it
whenever it needs to be updated.

00:23:02.020 --> 00:23:05.850
In 10.7, we added this property,
layerContentsRedrawPolicy,

00:23:06.010 --> 00:23:09.010
with which you can control
how often drawRect is called.

00:23:09.010 --> 00:23:12.800
It's really a great idea to look at this
and set it to the right value that's

00:23:12.800 --> 00:23:14.960
appropriate for what you're doing.

00:23:15.880 --> 00:23:19.840
In 10.8, we're adding new APIs to update
layer contents declaratively.

00:23:20.050 --> 00:23:24.010
If in your NSView subclass
you override this method,

00:23:24.100 --> 00:23:31.860
once updateLayer and return yes,
instead of drawRect,

00:23:31.860 --> 00:23:31.860
we will actually call this
new method called updateLayer.

00:23:34.520 --> 00:23:39.270
and this allows animations to
work better on background threads.

00:23:39.540 --> 00:23:41.740
We don't actually have to call
the main thread anymore as

00:23:41.790 --> 00:23:43.400
much to cause you to do things.

00:23:43.510 --> 00:23:47.330
And it also enables memory savings
if you declare that you're actually

00:23:47.330 --> 00:23:51.350
sharing various image resources or
other resources between your layers.

00:23:51.350 --> 00:23:54.280
So each layer does not actually
have to have its own bitmap,

00:23:54.320 --> 00:23:56.900
which might be possible in some cases.

00:23:57.050 --> 00:23:57.980
Here's how you would use this.

00:23:58.140 --> 00:23:59.630
Here's traditional draw rect.

00:23:59.630 --> 00:24:04.800
You set the red color and you just fill
the rect and fill the contents with red.

00:24:04.800 --> 00:24:07.520
With the update layer approach,
you simply go ahead and set the

00:24:07.520 --> 00:24:10.060
background color of the layer to red.

00:24:10.120 --> 00:24:13.080
NSColor.red.cgColor.

00:24:13.080 --> 00:24:16.510
If you had image, for instance,
and NSImage, you wanted something

00:24:16.610 --> 00:24:18.870
faster than just a red box,
you can do that by setting

00:24:18.980 --> 00:24:21.340
the contents to an NSImage.

00:24:21.340 --> 00:24:25.060
And one high-resolution tip here,
if this NSImage has 1x and

00:24:25.370 --> 00:24:28.880
2x representations in it,
we will do that.

00:24:28.880 --> 00:24:31.440
Do all the work to make sure
the right representation is used

00:24:31.880 --> 00:24:36.790
wherever that layer might be hosted,
1x or 2x window.

00:24:37.170 --> 00:24:40.380
Those of you looking at this and
who dealt with core animation might

00:24:40.390 --> 00:24:45.470
notice this new construct here,
NSColor.redcolor.cgColor.

00:24:45.470 --> 00:24:47.780
If you're that challenged
like me sometimes,

00:24:47.780 --> 00:24:50.600
this is also NSColor.redcolor.cgColor.

00:24:50.610 --> 00:24:53.140
We have added a new method to NSColor.

00:24:53.140 --> 00:24:53.960
It's CGColor.

00:24:53.960 --> 00:24:58.210
It returns a CGColor.

00:24:58.210 --> 00:24:58.210
If you've dealt with core animation --

00:24:58.930 --> 00:25:01.780
That's something that should
have been there for a while ago,

00:25:01.780 --> 00:25:02.760
but finally it's there.

00:25:02.940 --> 00:25:08.490
You can also go the other way,
color with CG color.

00:25:08.490 --> 00:25:08.490
So both ways.

00:25:09.420 --> 00:25:11.350
There are many other improvements
with layer-backed views.

00:25:11.540 --> 00:25:14.140
For instance,
there's improved subpixel anti-aliasing

00:25:14.140 --> 00:25:16.330
handling with layer-backed text.

00:25:16.330 --> 00:25:19.740
It used to be you had
to call some CG APIs,

00:25:19.990 --> 00:25:25.000
and now we do it for you,
and it's much better most of the time.

00:25:25.000 --> 00:25:28.010
A better management of flippantness,
where there's an agreement between

00:25:28.100 --> 00:25:29.810
the flippantness of layers and views.

00:25:29.820 --> 00:25:32.740
We support nested animations and much,
much more.

00:25:33.440 --> 00:25:35.590
Okay, Notification Center.

00:25:35.590 --> 00:25:37.440
You saw Notification Center yesterday.

00:25:37.490 --> 00:25:42.550
It's our new notification feature
in Mountain Lion that appears on

00:25:42.550 --> 00:25:45.780
the right side of your screen,
and it looks like this.

00:25:45.860 --> 00:25:49.280
The API for it is called
NSUserNotificationCenter,

00:25:49.280 --> 00:25:53.760
and first of all, just a clarification,
this is not to be confused with

00:25:53.840 --> 00:25:58.070
NSNotification or CFNotification
or CFUserNotification.

00:25:58.080 --> 00:26:00.150
We really like the word notification.

00:26:00.150 --> 00:26:01.980
It's fun to say, notification.

00:26:01.980 --> 00:26:03.420
So we decided to use it.

00:26:03.420 --> 00:26:07.500
Again, in more APIs,
but NSUserNotification is a brand new

00:26:07.500 --> 00:26:10.220
API to this new Notification Center.

00:26:12.260 --> 00:26:14.750
NSUserNotification instances,
as you can imagine,

00:26:14.750 --> 00:26:16.220
represent notifications.

00:26:16.220 --> 00:26:20.460
You can set properties such as title
and informative text and so on.

00:26:20.510 --> 00:26:24.340
And the NSUserNotificationCenter
class is a singleton which allows

00:26:24.340 --> 00:26:25.930
management of notifications.

00:26:25.960 --> 00:26:27.200
You can schedule notifications.

00:26:27.200 --> 00:26:29.720
You can actually go through the
list and trim them and so on.

00:26:30.120 --> 00:26:32.630
It also has a delegate which
will get called whenever the user

00:26:32.730 --> 00:26:34.350
interacts with your notification.

00:26:34.420 --> 00:26:37.260
And, in fact,
your app may be relaunched if necessary,

00:26:37.260 --> 00:26:40.530
if it's not running and the user
clicks on a notification of yours

00:26:40.660 --> 00:26:41.760
and your response is needed.

00:26:41.760 --> 00:26:43.090
needed.

00:26:43.230 --> 00:26:46.860
Let me show you a usage example,
a fairly straightforward one.

00:26:46.960 --> 00:26:48.900
You want to post a notification now.

00:26:49.000 --> 00:26:50.900
You create a notification.

00:26:51.010 --> 00:26:54.350
You set a friendly greeting note,
that title, hello.

00:26:54.500 --> 00:26:57.260
And then you deliver the notification,
and this is immediate.

00:26:57.360 --> 00:26:59.600
Let me show you a delayed notification.

00:26:59.730 --> 00:27:03.320
This is a notification
we posted in 30 seconds.

00:27:03.400 --> 00:27:16.600
[Transcript missing]

00:27:18.000 --> 00:27:19.600
The way I'm going,
you might sense something

00:27:19.660 --> 00:27:20.520
murky is coming up.

00:27:20.620 --> 00:27:23.340
Let's say you want to schedule a
notification at the same time next day.

00:27:23.340 --> 00:27:25.640
So I want to schedule a
notification at noon tomorrow.

00:27:25.640 --> 00:27:26.360
Right now it's noon.

00:27:26.360 --> 00:27:27.640
I want to do it at noon tomorrow.

00:27:27.930 --> 00:27:29.150
Here's what you think you want to do.

00:27:29.420 --> 00:27:33.400
24 hours a day, 60 minutes, an hour,
60 seconds a minute.

00:27:33.400 --> 00:27:33.860
There you go.

00:27:33.860 --> 00:27:35.660
That looks good.

00:27:35.790 --> 00:27:37.530
But some days have 23 hours.

00:27:37.610 --> 00:27:39.230
Some days have 24 hours.

00:27:39.230 --> 00:27:42.540
In some other exotic locales,
maybe things are even different.

00:27:42.670 --> 00:27:44.300
So this is not good.

00:27:44.300 --> 00:27:46.710
If you want a schedule
notification for an absolute

00:27:46.710 --> 00:27:49.900
time rather than a relative time,
like 30 seconds from now,

00:27:50.010 --> 00:27:52.460
you really have to get your
date computation right.

00:27:52.560 --> 00:27:54.760
Now,
I'm not going to tell you all about this.

00:27:54.900 --> 00:27:57.910
However, you need to take care of
how you set absolute dates.

00:27:58.020 --> 00:28:00.640
And we had a whole talk
about this topic last year.

00:28:00.920 --> 00:28:04.770
You can actually go to
developer.apple.com/videos and listen

00:28:04.870 --> 00:28:09.390
to the -- or watch the Performing
Calendar Calculations presentation.

00:28:09.400 --> 00:28:14.150
It really goes into good
depth on this topic.

00:28:15.750 --> 00:28:19.450
A few other notes about user notification
is that notifications are presented

00:28:19.520 --> 00:28:22.850
only if your app is not frontmost.

00:28:23.000 --> 00:28:25.690
That's because if your app is frontmost,
we assume your app is actually

00:28:25.770 --> 00:28:29.420
going to be doing something to
tell the user that something's up.

00:28:29.420 --> 00:28:31.970
Users control how notifications
are ultimately presented.

00:28:32.070 --> 00:28:34.480
The user might choose not
to see your notifications.

00:28:34.570 --> 00:28:37.910
For instance, during a presentation,
notifications aren't popping up,

00:28:37.910 --> 00:28:39.860
you know,
showing you all the mail I'm getting

00:28:39.860 --> 00:28:41.260
while I'm trying to talk here.

00:28:41.350 --> 00:28:44.080
So notifications may be disabled
and you can't control this.

00:28:44.080 --> 00:28:47.940
You just post them and the user
gets to see them however they wish.

00:28:47.960 --> 00:28:50.810
The guidelines for notifications is
that they should be used sparingly.

00:28:50.810 --> 00:28:53.590
Don't put up a notification every time,
you know, whoa, this happened,

00:28:53.590 --> 00:28:55.380
that happened, ooh, ooh.

00:28:55.450 --> 00:28:57.420
And consider cleaning up.

00:28:57.470 --> 00:28:59.470
Now,
the system will do some cleanup for you.

00:28:59.470 --> 00:29:01.320
It will only show a certain
amount of notifications.

00:29:01.320 --> 00:29:04.010
But if your notifications are such
that when a second one is posted,

00:29:04.160 --> 00:29:06.720
the first one is really meaningless,
you can actually go and

00:29:06.720 --> 00:29:07.930
delete that first one.

00:29:07.930 --> 00:29:10.530
And so it won't appear in
the user notification list,

00:29:10.530 --> 00:29:10.640
for instance.

00:29:13.320 --> 00:29:17.890
Okay, now let's switch gears
and talk about XPC and the

00:29:17.930 --> 00:29:21.840
Cocoa APIs we've added for XPC.

00:29:21.840 --> 00:29:25.290
We introduced XPC last
year as a part of Lion.

00:29:25.580 --> 00:29:27.380
It's a new inter-process
communication mechanism,

00:29:27.380 --> 00:29:30.660
and Cocoa XBC is the
Cocoa-level APIs for this.

00:29:30.770 --> 00:29:33.560
Now, one reason we're interested in
an inter-process communication

00:29:33.610 --> 00:29:41.380
mechanism is that in today's
sandbox application world and so on,

00:29:41.540 --> 00:29:45.200
we really want applications and
various helper processes to run

00:29:45.200 --> 00:29:48.540
with as minimal privileges as
they need to get their job done.

00:29:48.720 --> 00:29:52.390
And we want to sort of separate processes
to these different islands of privilege.

00:29:52.510 --> 00:29:55.030
So, for instance,
one process that has both full access

00:29:55.030 --> 00:29:58.420
to the network and full access to the
file system and full access to your tax

00:29:58.420 --> 00:30:00.380
records is probably not a good thing.

00:30:00.520 --> 00:30:02.780
So we separate them
into separate processes.

00:30:02.890 --> 00:30:06.170
And one way to get them to work together
is through inter-process communication.

00:30:06.300 --> 00:30:08.600
And that's one of the things
that XBC does for you.

00:30:08.600 --> 00:30:11.500
It really makes it easy
to do that sort of thing.

00:30:11.610 --> 00:30:15.100
And we're now introducing Cocoa APIs for
this to make it even easier.

00:30:15.340 --> 00:30:16.700
Ali Ozer: Now,
we do have some -- I'm sorry.

00:30:16.700 --> 00:30:18.500
We do have some inter-process
communication mechanisms.

00:30:18.500 --> 00:30:21.800
In Cocoa already, for instance,
distributed objects.

00:30:22.050 --> 00:30:23.500
Why are we doing this?

00:30:23.660 --> 00:30:25.770
Well, this new API is secure.

00:30:25.900 --> 00:30:27.460
It's more secure than
distributed objects,

00:30:27.550 --> 00:30:28.700
and we'll see why.

00:30:28.740 --> 00:30:31.700
It's robust,
more robust than distributed objects,

00:30:31.810 --> 00:30:36.600
because it's got a strong sense
for error handling and so on,

00:30:36.600 --> 00:30:38.710
while distributed objects
relied on exceptions,

00:30:38.790 --> 00:30:42.900
which is not a good thing to do when
you're dealing with a relatively

00:30:42.970 --> 00:30:46.130
unpredictable resource like the network.

00:30:46.330 --> 00:30:47.760
Cocoa XPC is asynchronous.

00:30:47.830 --> 00:30:51.760
All messages are one way,
while DO was actually not one way,

00:30:51.760 --> 00:30:54.720
and that meant that your
application could again hang

00:30:54.720 --> 00:30:56.430
waiting for the other side.

00:30:56.660 --> 00:30:59.380
And one other thing about
Cocoa XPC is that it's Cocoa.

00:30:59.400 --> 00:31:02.400
Now, distributed objects was
certainly Cocoa-level APIs.

00:31:02.540 --> 00:31:06.500
However, XPC, Mach messaging, sockets,
et cetera, these other technologies,

00:31:06.500 --> 00:31:09.320
which are also available,
they are not Cocoa,

00:31:09.320 --> 00:31:13.150
and they require converting of
objects down to these lower layers,

00:31:13.160 --> 00:31:14.950
what we call impedance mismatch.

00:31:15.020 --> 00:31:16.740
You know, you want to send a
string across the wire,

00:31:16.740 --> 00:31:20.840
you have to convert it to a lower-level
representation before you send it across.

00:31:20.950 --> 00:31:25.810
Cocoa XPC has the advantage that we
remove that impedance mismatch problem.

00:31:25.890 --> 00:31:28.960
There are three major
classes in this subsystem.

00:31:29.010 --> 00:31:32.930
NSXPC connection represents a connection,
and it holds the object that

00:31:32.980 --> 00:31:36.690
your process is exporting,
and it holds a proxy to the

00:31:36.690 --> 00:31:38.800
remote object from the other side.

00:31:38.800 --> 00:31:40.750
It also holds the API for these.

00:31:40.750 --> 00:31:42.590
It also holds error handlers.

00:31:43.420 --> 00:31:48.840
NSXPC listener is a class you would
instantiate in a server or in a service.

00:31:48.900 --> 00:31:51.820
It listens for new connections
and talks to the delegate.

00:31:51.820 --> 00:31:57.400
NSXPC interface defines the
APIs the objects respond to.

00:31:57.400 --> 00:31:59.970
As you might imagine,
we really want to define the

00:31:59.970 --> 00:32:03.850
APIs between these processes clearly
and concisely so that it's very clear

00:32:03.850 --> 00:32:07.140
what the communication paths are,
and we're not opening up

00:32:07.140 --> 00:32:10.500
any more possible means of
communication than necessary.

00:32:10.500 --> 00:32:13.400
To define interfaces, we use, of course,
the NSXPC listener.

00:32:13.400 --> 00:32:17.500
We have a great tool at our disposal,
App Protocol, and that's what we use.

00:32:17.500 --> 00:32:20.220
This is the
Objective-C protocol mechanism.

00:32:20.220 --> 00:32:25.100
Let me show you how you might create
a simple protocol using Cocoa XPC.

00:32:25.100 --> 00:32:28.230
Let's say we have a server
which compresses things.

00:32:28.280 --> 00:32:33.830
Let's say you just want to give
it the ability to compress files.

00:32:35.500 --> 00:32:36.200
Here's the method you might create.

00:32:36.220 --> 00:32:39.460
Now,
I said that these APIs are asynchronous,

00:32:39.570 --> 00:32:40.690
so there's no return value.

00:32:40.740 --> 00:32:43.240
So this one just says go compress
the contents of this URL.

00:32:43.240 --> 00:32:44.390
And that's good.

00:32:44.390 --> 00:32:46.170
I guess I won't hear about it.

00:32:46.320 --> 00:32:48.420
So it's a reasonable method,
but it's really not very good from

00:32:48.420 --> 00:32:50.380
a user experience point of view,
because we have no idea

00:32:50.380 --> 00:32:52.020
whether it succeeded or not.

00:32:52.020 --> 00:32:55.000
If you want to get results back,
you can't just put a bool return

00:32:55.000 --> 00:32:57.500
or an unnecessary return directly,
because those would make

00:32:57.500 --> 00:32:58.700
the method asynchronous.

00:32:58.830 --> 00:33:02.630
But we have added the ability to
sort of provide reply blocks that

00:33:02.630 --> 00:33:05.260
will be called when the job is done.

00:33:05.310 --> 00:33:07.650
And that version of this
method would look like this.

00:33:07.820 --> 00:33:11.610
You can say compress data,
here's some data, and come get back to me

00:33:11.610 --> 00:33:13.410
with the compressed data.

00:33:15.010 --> 00:33:17.120
Here's how you might use this.

00:33:17.180 --> 00:33:18.280
I get my compressor.

00:33:18.280 --> 00:33:20.980
This is the remote object
proxy for my connection.

00:33:21.040 --> 00:33:23.940
And I tell the compressor
to compress the data.

00:33:24.010 --> 00:33:26.300
And here's the reply block
I want to get called.

00:33:26.360 --> 00:33:28.960
And the reply block will write
that compressed data out.

00:33:28.960 --> 00:33:31.220
And this will happen in my process.

00:33:31.340 --> 00:33:35.880
So that block that's highlighted
right now executes asynchronously.

00:33:36.010 --> 00:33:38.000
So this method quickly returns.

00:33:38.210 --> 00:33:39.320
Execution continues.

00:33:39.370 --> 00:33:42.030
And at some later time,
your block will be called

00:33:42.080 --> 00:33:43.950
to complete the job.

00:33:46.480 --> 00:33:49.740
Secure coding is a new facility
we're adding as a part of Cocoa XPC.

00:33:49.880 --> 00:33:52.410
It's a new protocol,
and this protocol allows

00:33:52.410 --> 00:33:56.770
objects to declare that they
respond to new decoding methods.

00:33:56.820 --> 00:33:59.180
Now, these are the NS coding methods.

00:33:59.260 --> 00:34:01.240
You might be familiar with them.

00:34:01.240 --> 00:34:03.370
For instance, decode object for key.

00:34:03.370 --> 00:34:08.800
A method such as this fetches the object
identified by key from the archive,

00:34:08.800 --> 00:34:11.800
and it executes its init with
coder methods or other methods

00:34:11.940 --> 00:34:13.500
for decoding the object.

00:34:14.100 --> 00:34:17.750
The problem there is it's executing code,
and by the time you're deciding

00:34:17.750 --> 00:34:20.570
I really don't want this object
or this was some foreign object,

00:34:20.570 --> 00:34:23.280
it might be too late because
some code got executed.

00:34:23.280 --> 00:34:26.740
An example is you might be expecting
a string out of your archive,

00:34:26.740 --> 00:34:30.360
but somehow some object that already
happens to be your process executes,

00:34:30.460 --> 00:34:33.780
and maybe the archive is filled
with some set of bytes that causes

00:34:33.780 --> 00:34:35.340
that object to do bad things.

00:34:35.340 --> 00:34:38.230
The new methods we're adding
allow you to specify exactly

00:34:38.310 --> 00:34:40.870
what class you're expecting,
and if that class isn't

00:34:40.870 --> 00:34:43.790
what's encountered,
the reading of the archive aborts.

00:34:43.980 --> 00:34:45.950
So you say decode object of class.

00:34:45.950 --> 00:34:50.280
You can also specify a set of classes
if that object might be one of several,

00:34:50.330 --> 00:34:53.120
or you can say, you know,
I just want a propertyless class,

00:34:53.120 --> 00:34:56.020
which is one of our seven
propertyless classes like string,

00:34:56.020 --> 00:34:57.350
array, dictionary.

00:34:57.360 --> 00:34:59.980
Okay,
so let's now move on to Objective-C,

00:34:59.980 --> 00:35:02.280
and you saw some of these yesterday.

00:35:02.280 --> 00:35:05.820
Some great new features,
mostly around new syntax that makes code

00:35:06.010 --> 00:35:08.480
a lot less verbose and easier to write.

00:35:08.480 --> 00:35:12.980
There's new syntax for NSNumbers at 42.

00:35:12.980 --> 00:35:16.200
This is equivalent to the code that
we used to create for the integer 42.

00:35:16.340 --> 00:35:20.500
At yes is equivalent to creating
an NSNumber object from a Boolean.

00:35:20.630 --> 00:35:23.930
You can also do expressions in there.

00:35:23.960 --> 00:35:24.860
At open paren, 40 plus 2.

00:35:24.990 --> 00:35:26.720
More interestingly,
this can be used to actually

00:35:26.810 --> 00:35:29.770
put an enum value in there,
and that's some enum value with an at

00:35:29.770 --> 00:35:32.100
paren that creates an NSNumber with that.

00:35:32.220 --> 00:35:35.120
You can also do this with
NSStrings from C strings.

00:35:35.180 --> 00:35:37.710
And we already have, of course,
a facility for creating

00:35:38.200 --> 00:35:39.200
constant NSStrings.

00:35:39.200 --> 00:35:41.560
We've had that for a while,
but this now allows you

00:35:41.570 --> 00:35:43.940
to do it directly from,
say, a function call.

00:35:43.950 --> 00:35:46.890
Now, one thing to watch here, though,
that the return value of that

00:35:46.890 --> 00:35:51.310
function should be UTF-8 or ASCII,
which is a subset of UTF-8,

00:35:51.490 --> 00:35:54.860
and make sure it doesn't return null,
because otherwise that results

00:35:54.910 --> 00:35:57.590
in a runtime exception.

00:35:58.580 --> 00:36:01.330
We have syntax for creating
NSArrays at open bracket.

00:36:01.450 --> 00:36:03.060
Again, just list your objects.

00:36:03.150 --> 00:36:07.020
We have syntax for creating
NSDictionary's at open brace,

00:36:07.020 --> 00:36:09.500
key, colon, object, and so on.

00:36:09.770 --> 00:36:12.720
We also have syntax for
accessing those elements,

00:36:12.730 --> 00:36:15.280
array sub one, array sub n, et cetera.

00:36:15.360 --> 00:36:19.870
And also for dictionaries,
dictionary sub your key.

00:36:20.100 --> 00:36:22.370
Now,
this syntax for accessing elements out of

00:36:22.410 --> 00:36:25.670
collections is actually available to you,
because there are two methods you

00:36:25.720 --> 00:36:28.880
can override in your own collections,
and you can implement this bracket

00:36:28.880 --> 00:36:31.040
syntax for your own objects as well.

00:36:31.140 --> 00:36:32.800
The first one is called
index subscripting.

00:36:32.800 --> 00:36:35.000
The second one is called
keyed subscripting.

00:36:41.450 --> 00:36:44.020
As you know, ARC,
automatic reference counting,

00:36:44.120 --> 00:36:47.710
relies on naming conventions
and also relies on names,

00:36:47.710 --> 00:36:52.140
method names, and so on,
to be named properly to decide how

00:36:52.140 --> 00:36:55.150
it does automatic retain and release.

00:36:55.250 --> 00:36:59.440
But sometimes you have a block
of code or some misnamed API that

00:36:59.440 --> 00:37:01.320
doesn't quite follow the guidelines.

00:37:01.360 --> 00:37:04.720
We've added further abilities to
declare nonstandard behaviors,

00:37:04.720 --> 00:37:07.560
and these are exposed
with macros in Foundation.

00:37:07.620 --> 00:37:09.920
For instance,
if a method releases its argument,

00:37:09.920 --> 00:37:12.490
which is not something
we say you should do,

00:37:12.580 --> 00:37:15.110
but some methods,
including I think at least

00:37:15.220 --> 00:37:18.150
one in Foundation does it,
so NS releases argument.

00:37:18.270 --> 00:37:19.940
And we have a bunch of other
things like this that you can

00:37:19.940 --> 00:37:22.390
actually decorate your methods with,
and some of these actually apply

00:37:22.430 --> 00:37:26.020
to IVARs if you want to carry
that behavior onto an IVAR.

00:37:26.140 --> 00:37:29.080
So these are good things to look at
as you're converting your code to ARC.

00:37:29.080 --> 00:37:31.240
I mean, ideally, of course,
we'd like you to rename your methods

00:37:31.240 --> 00:37:33.700
and make sure they're named properly,
but sometimes that's not

00:37:33.810 --> 00:37:34.920
very easily possible.

00:37:34.920 --> 00:37:38.850
There are a number of other
great features in Objective-C,

00:37:38.850 --> 00:37:40.500
automatic properties and multi-synthesis.

00:37:40.580 --> 00:37:42.290
You don't have to write
at synthesize anymore.

00:37:42.490 --> 00:37:48.210
There is enums with fixed underlying
types that helps us make our APIs better.

00:37:48.210 --> 00:37:48.210
And

00:37:48.370 --> 00:37:49.650
Garbage collection is gone.

00:37:49.890 --> 00:37:54.200
We believe that automatic reference
counting is really the way forward there.

00:37:54.280 --> 00:37:57.310
Now let's talk about some
of the remaining topics.

00:37:57.310 --> 00:38:02.260
As I said, we have a lot of stuff and
now with a little less depth.

00:38:02.390 --> 00:38:03.910
One of them is NS sharing service.

00:38:03.960 --> 00:38:08.180
This is the new feature we
introduced yesterday in the keynote.

00:38:08.220 --> 00:38:14.260
This allows your application to -- just
allows users to share things easily

00:38:14.260 --> 00:38:16.410
with a uniform UI from various apps.

00:38:16.660 --> 00:38:19.770
For instance, in Safari,
I can go click that button up there

00:38:19.870 --> 00:38:23.360
and I can say Twitter and up comes
a Twitter sheet right inside Safari.

00:38:23.360 --> 00:38:27.850
Very direct, very easy,
very straightforward and a nice UI.

00:38:28.560 --> 00:38:32.860
This enables sharing of text, files,
media, and really any other document

00:38:32.950 --> 00:38:34.250
format or whatever you want.

00:38:34.250 --> 00:38:37.480
It allows customization
of the picker itself,

00:38:37.600 --> 00:38:40.650
so you can actually add items to that
picker or remove items from that picker

00:38:40.650 --> 00:38:42.650
if it's appropriate for your application.

00:38:42.650 --> 00:38:45.720
You can also customize the
UI for invoking the picker.

00:38:45.720 --> 00:38:46.870
You don't have to use a button.

00:38:46.950 --> 00:38:48.790
You can use a menu or you
can use something else that's

00:38:48.860 --> 00:38:50.380
appropriate for your application.

00:38:50.390 --> 00:38:53.030
You can use a totally different
custom look and so on,

00:38:53.100 --> 00:38:54.710
so that's totally up to you.

00:38:55.580 --> 00:38:59.260
The application sandbox, as you know,
application sandbox is a very

00:38:59.260 --> 00:39:02.860
important part of developing
applications for the Macintosh.

00:39:02.860 --> 00:39:07.620
We've added two new features,
and these are actually part of Lion SU,

00:39:07.620 --> 00:39:10.900
and of course they're also in 10.8.

00:39:10.940 --> 00:39:13.210
One is support for related items.

00:39:13.210 --> 00:39:18.070
These are files and folders that need
to be accessed with a user document.

00:39:18.070 --> 00:39:20.270
The user chooses a
document in the open panel,

00:39:20.340 --> 00:39:23.190
but you want to give access to
the application for some other

00:39:23.190 --> 00:39:25.120
items that are related to it,
but you don't want the

00:39:25.120 --> 00:39:25.560
user to have to access it.

00:39:25.580 --> 00:39:28.120
The user doesn't have to necessarily
go and one by one pick those.

00:39:28.220 --> 00:39:30.010
For instance,
sometimes media folders sit next to

00:39:30.030 --> 00:39:32.470
the presentations that they're with.

00:39:32.560 --> 00:39:34.920
Another example is text edit.

00:39:34.930 --> 00:39:37.050
Text edit edits RTF files.

00:39:37.560 --> 00:39:39.620
However,
if the user drags an image into it,

00:39:39.620 --> 00:39:42.240
the file becomes RTFD and
its name changes.

00:39:42.240 --> 00:39:43.720
You want that to be automatic.

00:39:43.720 --> 00:39:45.810
You don't want the user
to have to go open,

00:39:45.900 --> 00:39:48.970
run the save panel again, for instance,
just for that.

00:39:49.020 --> 00:39:51.300
So that's this support.

00:39:51.300 --> 00:39:53.720
The other one is security
scoped bookmarks.

00:39:53.720 --> 00:39:55.560
These are persistent
access to your application.

00:39:55.580 --> 00:39:57.110
You want that to be able to access
the user-chosen files and folders.

00:39:57.120 --> 00:40:01.820
Let's say your application allows the
user to specify a downloads folder.

00:40:01.820 --> 00:40:06.800
You want that access to persist even
if the application is quit or even

00:40:06.960 --> 00:40:09.820
if the system is rebooted and so on.

00:40:09.860 --> 00:40:11.480
So that's what you'd use this for.

00:40:11.480 --> 00:40:14.580
Auto Layout,
great technology that we added in Lion,

00:40:14.580 --> 00:40:18.040
and we've added a few more
features now in Mountain Lion.

00:40:18.040 --> 00:40:20.340
One is support for text field wrapping.

00:40:20.340 --> 00:40:23.000
Previously,
text fields just wanted to lay

00:40:23.130 --> 00:40:25.560
themselves out as if they're one line.

00:40:25.580 --> 00:40:27.840
If you wanted to wrap,
you had to write some code.

00:40:27.840 --> 00:40:29.380
You no longer have to.

00:40:29.380 --> 00:40:31.650
You can actually specify
the preferred width,

00:40:31.740 --> 00:40:34.200
and the text field will
wrap when it gets to that.

00:40:37.700 --> 00:40:43.200
There is improved support
for NS split view.

00:40:43.200 --> 00:40:45.600
We now respect subview constraints.

00:40:45.600 --> 00:40:47.610
And also,
you can specify different holding

00:40:47.710 --> 00:40:51.090
priorities for the different subviews,
such that as the split view

00:40:51.090 --> 00:40:54.510
is collapsing or expanding,
the different subviews will behave

00:40:54.510 --> 00:40:56.360
more appropriately to their content.

00:40:56.360 --> 00:41:00.310
You can actually specify
individual holding priorities.

00:41:00.730 --> 00:41:02.940
There's automatic localization now.

00:41:03.020 --> 00:41:06.620
As you know, most of the time when
you specify constraints,

00:41:06.750 --> 00:41:10.140
they allow controls to resize
and reposition based on content.

00:41:10.170 --> 00:41:13.310
And this content could
be localized titles,

00:41:13.310 --> 00:41:16.040
for instance,
for the buttons or other content.

00:41:16.170 --> 00:41:18.920
And leading trailing support
enables right-to-left languages,

00:41:18.920 --> 00:41:25.230
so your whole interface can actually flip
to give you a right-to-left interface.

00:41:25.800 --> 00:43:24.000
[Transcript missing]

00:43:24.430 --> 00:43:26.360
And let's say your application
deals in gigabytes.

00:43:26.360 --> 00:43:28.820
It doesn't bother,
concern itself with anything

00:43:28.820 --> 00:43:30.040
smaller than a gigabyte.

00:43:30.170 --> 00:43:34.930
Well, it might just choose to use
gigabyte-type units and above only,

00:43:34.930 --> 00:43:35.700
for instance.

00:43:35.700 --> 00:43:37.600
And you get this kind of output.

00:43:37.720 --> 00:43:39.960
Let's say you have 42
kilobytes and change.

00:43:39.960 --> 00:43:41.600
This is what you get by default.

00:43:41.600 --> 00:43:43.500
This is what Finder gives by default.

00:43:43.620 --> 00:43:46.000
Now, you can choose to get
just the number part.

00:43:46.100 --> 00:43:47.600
Let's say you're putting
them in separate UIs.

00:43:47.600 --> 00:43:49.740
Or you can get the unit parts separately.

00:43:49.840 --> 00:43:51.580
Or if you want,
you can get both that short

00:43:51.580 --> 00:43:54.770
version and the exact byte count,
which is something that, for instance,

00:43:54.870 --> 00:43:59.100
this utility might do to give you an
exact byte count of how big the disk is.

00:43:59.220 --> 00:44:01.080
And let's say you have a
number in the gigabytes.

00:44:01.190 --> 00:44:04.550
By default,
you'll get two decimal points, 12.35,

00:44:04.550 --> 00:44:06.780
which is, again, what Finder does.

00:44:07.100 --> 00:44:10.250
: If you show it as megabytes,
you get one decimal point.

00:44:10.250 --> 00:44:13.360
If you show it as kilobytes,
you get no decimal points.

00:44:13.360 --> 00:44:17.390
So pretty good behaviors, reasonable,
fairly good user experience.

00:44:17.480 --> 00:44:21.020
Let's say you're running in French,
you get this output where your

00:44:21.030 --> 00:44:24.670
commas for thousands of operators
have been replaced by spaces.

00:44:24.670 --> 00:44:28.690
And let's say you're running in
Arabic with Saudi Arabian localization,

00:44:28.690 --> 00:44:31.790
you'll actually get this,
where not only you're getting

00:44:31.790 --> 00:44:34.100
right-to-left rendering,
you're also getting actual

00:44:34.100 --> 00:44:34.100
Arabic digits in this case.

00:44:36.800 --> 00:44:39.300
NSString has support for
localized number formatting.

00:44:39.300 --> 00:44:41.320
Now, it's always had this,
but it was pretty weak.

00:44:41.390 --> 00:44:43.610
It just localized your decimal point.

00:44:43.690 --> 00:44:47.960
Now, it's methods like this,
localized string format or

00:44:47.960 --> 00:44:49.050
init with format locale.

00:44:49.340 --> 00:44:52.740
These localize your decimal point
but did not go any further than that.

00:44:52.800 --> 00:44:56.300
You have to use NSNumber formatter
if you want to get richer

00:44:56.300 --> 00:44:58.160
localization of numbers.

00:44:58.270 --> 00:45:02.400
But now, NSString will actually localize
thousand separators and digits as well,

00:45:02.400 --> 00:45:04.500
sort of like we saw with
byte count formatter.

00:45:04.630 --> 00:45:06.490
But because of compatibility
considerations,

00:45:06.530 --> 00:45:09.110
we only do this for apps
linked against 10.8.

00:45:09.210 --> 00:45:12.190
So as you relink your
app with the 10.8 SDK,

00:45:12.230 --> 00:45:15.870
this is one of the things that
you should consider and maybe look

00:45:15.900 --> 00:45:17.990
over your uses of these methods.

00:45:20.860 --> 00:45:25.200
Automatic reference counting
brought zeroing weak support,

00:45:25.260 --> 00:45:28.360
which means objects,
when they're released,

00:45:28.420 --> 00:45:31.890
pointers that point to it can be
zeroed out rather than left dangling,

00:45:31.900 --> 00:45:34.550
meaning they're not pointing
at the least objects.

00:45:34.620 --> 00:45:38.240
And this support is--we've added this
support to our three collection classes,

00:45:38.280 --> 00:45:40.900
MapTable, HashTable, and PointerArray.

00:45:40.940 --> 00:45:44.990
I'm just going to show you how
this works with a code snippet.

00:45:45.130 --> 00:45:47.370
So you go ahead and create an object,
and then let's say you go

00:45:47.370 --> 00:45:48.860
ahead and create a map table.

00:45:48.860 --> 00:45:51.800
Now this API here,
Strong to Weak Objects Map Table,

00:45:51.800 --> 00:45:53.600
is a new API we've added in 10.8.

00:45:53.600 --> 00:45:58.100
It specifies that you're creating
a map table whose keys are strong,

00:45:58.100 --> 00:46:00.090
but the objects are zeroing weak.

00:46:00.100 --> 00:46:03.800
And then we go ahead and
put the object in the table,

00:46:04.060 --> 00:46:07.490
and at some later time,
the object is released.

00:46:08.670 --> 00:46:11.830
If you ask the table for that object,
you'll get back null.

00:46:12.060 --> 00:46:14.990
So actually the reference in
the table has been cleared out.

00:46:15.100 --> 00:46:16.600
So this is pretty cool.

00:46:16.600 --> 00:46:22.390
The zeroing Wix port is pretty useful
and should make for more robust programs.

00:46:22.520 --> 00:46:25.100
Now note that this actually works
under manual reference counting.

00:46:25.100 --> 00:46:27.040
Actually I called
object release up there.

00:46:27.220 --> 00:46:29.700
So this is not just limited to
automatic reference counting.

00:46:29.700 --> 00:46:32.660
It also works under
manual reference counting.

00:46:36.880 --> 00:46:39.900
One other collection topic I want to
touch upon is shared key dictionary.

00:46:39.900 --> 00:46:42.890
This is a new API that lets you
create fast remutable dictionaries

00:46:42.950 --> 00:46:45.820
when you know the set of keys
you're going to put in them.

00:46:45.820 --> 00:46:47.790
There's only two APIs for this.

00:46:47.790 --> 00:46:52.140
The first one lets you supply those
keys and get back an opaque object,

00:46:52.140 --> 00:46:54.130
which is the shared key set.

00:46:54.360 --> 00:46:56.760
And using that shared key set,
you can now go ahead and create

00:46:56.760 --> 00:46:58.920
instances of an insurmutable dictionary.

00:46:58.920 --> 00:47:01.480
Here's how you might use it.

00:47:01.640 --> 00:47:04.130
First, create your shared key set with,
for instance,

00:47:04.200 --> 00:47:08.470
the three keys color font underline,
and then create your dictionary.

00:47:08.650 --> 00:47:11.440
Now you can use the same key set
to create multiple dictionaries.

00:47:11.440 --> 00:47:14.540
In fact, that's one of the things that
gives you a performance benefit

00:47:14.540 --> 00:47:16.240
for using this mechanism.

00:47:16.340 --> 00:47:20.120
The performance benefits are that, one,
we use minimal perfect hashing,

00:47:20.120 --> 00:47:23.540
so we eliminate collisions,
which makes for faster lookups.

00:47:23.650 --> 00:47:26.530
And two, if you create many dictionaries
with the same key set,

00:47:26.660 --> 00:47:30.390
there's actually going to be memory
savings because we no longer have to

00:47:30.400 --> 00:47:32.440
save the keys in every dictionary.

00:47:32.440 --> 00:47:34.550
So this will result in
increased memory savings.

00:47:34.560 --> 00:47:35.990
savings.

00:47:36.360 --> 00:47:37.540
This class is flexible.

00:47:37.540 --> 00:47:40.700
It allows for keys that are
not in the original key set.

00:47:40.780 --> 00:47:45.620
However, of course, the more you do this,
the decrease, some of the performance

00:47:45.620 --> 00:47:48.600
benefits will decrease,
because now you're using other keys that

00:47:48.600 --> 00:47:50.240
we didn't account for at the beginning.

00:47:50.390 --> 00:47:52.490
However, it will work.

00:47:53.700 --> 00:47:57.980
So the last topic I'm going to talk about
here is the behavior change in Resume.

00:47:58.070 --> 00:48:02.100
Now, as you know, as you might know,
Resume is the facility that

00:48:02.230 --> 00:48:05.600
recreates your state after
you log out and log back in.

00:48:05.600 --> 00:48:10.020
Now,
one thing we've changed is that on login,

00:48:10.030 --> 00:48:14.710
apps that were hidden at logout
time are partially relaunched.

00:48:16.600 --> 00:48:20.500
We launched them enough to make
them look like they're launched.

00:48:20.670 --> 00:48:22.300
However, they're not really running.

00:48:22.520 --> 00:48:25.000
So what do I mean here?

00:48:25.000 --> 00:48:27.990
Here is a snapshot of a
system right after a login.

00:48:28.290 --> 00:48:30.850
Now you'll notice that TextEdit,
Photo Booth, et cetera,

00:48:30.850 --> 00:48:32.880
they have their little
dock lights on them.

00:48:32.880 --> 00:48:35.750
And in fact, if I hit Command-Tab,
you'll notice that those applications

00:48:35.750 --> 00:48:38.300
are also in Command-Tab list.

00:48:38.470 --> 00:48:41.040
However, take a look at Activity Monitor.

00:48:41.050 --> 00:48:45.140
It shows that these applications
at the top have used zero CPU time,

00:48:45.140 --> 00:48:49.760
are using 24 kilobytes of memory,
and have one thread.

00:48:49.870 --> 00:48:53.270
The last time any app ran like this on
a Mac was for the original Macintosh.

00:48:53.320 --> 00:48:55.700
So these are pretty tiny apps here.

00:48:55.780 --> 00:48:57.750
So what's really happened is
we've launched them enough

00:48:58.490 --> 00:49:02.150
to get us all the benefits of
looking like they're launched,

00:49:02.150 --> 00:49:04.920
but they're really not really launched.

00:49:04.950 --> 00:49:06.510
So if the user goes and
interacts with these apps,

00:49:06.510 --> 00:49:08.410
clicks on them,
chooses them in the Command-Tab,

00:49:08.410 --> 00:49:10.240
et cetera,
the app will be fully relaunched,

00:49:10.240 --> 00:49:11.660
and it will act just like normal.

00:49:11.660 --> 00:49:15.980
So there's really no difference
in the user experience here.

00:49:16.080 --> 00:49:18.310
Now, one thing you might want to note
here is that sometimes some apps

00:49:18.310 --> 00:49:20.970
might want to be relaunched on
login if they are hidden because

00:49:20.970 --> 00:49:22.750
they're doing some background work.

00:49:22.900 --> 00:49:27.660
For instance, Mail is fetching messages,
and one way it can do that -- of course,

00:49:27.740 --> 00:49:29.840
in some cases,
you might be able to use a background

00:49:29.840 --> 00:49:32.420
daemon to do this or maybe get
notifications for this sort of stuff.

00:49:32.420 --> 00:49:34.810
But in some cases,
the app maybe needs to be

00:49:34.820 --> 00:49:35.840
launched to do the work.

00:49:36.010 --> 00:49:38.600
We have a facility to allow this.

00:49:38.650 --> 00:49:41.480
So what if your app does
need to be relaunched?

00:49:41.480 --> 00:49:45.660
Well, an app will be relaunched on login
if it opts into auto-termination,

00:49:45.660 --> 00:49:50.030
which you do by putting this key,
"Sports automatic termination,"

00:49:50.160 --> 00:49:51.800
in your Info.plist.

00:49:51.800 --> 00:49:54.100
Now, once you've done this,
you can now call "enable automatic

00:49:54.100 --> 00:49:57.630
termination," "disable automatic
termination," and these nest as a way to

00:49:57.780 --> 00:50:00.100
disable and enable automatic termination.

00:50:00.100 --> 00:50:03.160
For instance, if you're doing something
that should continue or that

00:50:03.160 --> 00:50:07.040
shouldn't be interrupted,
that's what you would do.

00:50:07.040 --> 00:50:09.640
So if you happen to be not
auto-terminable at the time,

00:50:09.640 --> 00:50:13.590
meaning you've called "disable
automatic termination," you would be

00:50:13.740 --> 00:50:16.120
relaunched even though you're hidden.

00:50:16.440 --> 00:50:19.370
So that's one way you're a
signal to the system that I am

00:50:19.370 --> 00:50:21.210
doing something important.

00:50:21.330 --> 00:50:23.400
Even if I'm hidden, do relaunch me.

00:50:23.400 --> 00:50:25.640
Now, you can imagine something like mail.

00:50:25.640 --> 00:50:29.620
If it wasn't showing unread
counts in its dock icon because

00:50:29.620 --> 00:50:33.360
the user didn't choose it,
mail wouldn't have a reason to do this.

00:50:33.360 --> 00:50:36.380
But if the user is doing that,
maybe mail would call this.

00:50:36.380 --> 00:50:37.520
So you could actually
call this dynamically,

00:50:37.540 --> 00:50:41.120
depending on whether you're
doing something important or not.

00:50:41.120 --> 00:50:41.120
So don't -- you know, don't do that.

00:50:41.120 --> 00:50:42.640
Don't blindly call this.

00:50:42.790 --> 00:50:45.520
Just actually see what's appropriate.

00:50:45.540 --> 00:50:47.810
But we really want you to
adopt auto-termination.

00:50:48.050 --> 00:50:50.010
This is a facility we added in Lion.

00:50:50.060 --> 00:50:52.640
It's useful for not only this,
but a lot of other things.

00:50:52.640 --> 00:50:55.310
With auto-termination,
we can actually have the system

00:50:55.350 --> 00:50:59.240
control your process's lifecycle
independently of your app lifecycle,

00:50:59.310 --> 00:51:02.060
which gives the system a lot
more leverage in adjusting

00:51:02.060 --> 00:51:03.740
the system's performance.

00:51:03.760 --> 00:51:06.420
And if you want to hear more
about auto-termination or resume,

00:51:06.420 --> 00:51:09.180
we do have a talk from last year,
developer.app.com/videos,

00:51:09.190 --> 00:51:13.010
"Resume an Automatic
Termination." nation in Lyon.

00:51:13.800 --> 00:53:03.000
[Transcript missing]

00:53:04.020 --> 00:53:06.090
So in summary,
there is a ton of new user and

00:53:06.090 --> 00:53:08.750
developer features in Mountain Lion,
and we'd really like you to

00:53:08.830 --> 00:53:10.990
look over this list and adopt
the ones that make sense.

00:53:11.120 --> 00:53:14.090
Some are actually very little work,
and the others are just few lines,

00:53:14.090 --> 00:53:16.160
and it'll make your
applications much better.

00:53:16.160 --> 00:53:21.270
We have our documentation,
our release notes, AppKit and Foundation,

00:53:21.270 --> 00:53:22.600
and our header files.

00:53:22.600 --> 00:53:26.120
You can just look for occurrence
of 10.8 to see what's new.

00:53:26.120 --> 00:53:27.820
If you want to browse
through the header files,

00:53:27.820 --> 00:53:29.120
this is one quick thing to look at.

00:53:29.520 --> 00:53:31.700
And here is where you
go for more information.

00:53:31.700 --> 00:53:34.470
You can email Jake and our
documentation and dev forums.

00:53:34.470 --> 00:53:35.580
So thank you.
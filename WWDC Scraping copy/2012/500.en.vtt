WEBVTT

00:00:12.310 --> 00:00:13.200
Thank you very much.

00:00:13.220 --> 00:00:17.710
Welcome to day number two at
Worldwide Developers Conference 2012,

00:00:17.710 --> 00:00:20.490
and we're here to talk about games.

00:00:20.710 --> 00:00:24.210
So, as we talked about yesterday,
some amazing announcements as far as the

00:00:24.300 --> 00:00:28.040
scope and the breadth of the application
that all of you have developed.

00:00:28.070 --> 00:00:30.730
650,000 applications we have.

00:00:30.730 --> 00:00:32.320
Many of them are games.

00:00:33.500 --> 00:00:48.830
And we talked yesterday in the platforms
kickoff about both of our platforms,

00:00:48.830 --> 00:00:53.430
iOS, OS X.

00:00:53.430 --> 00:00:53.430
We're trying to build a great set
of game technologies that spans

00:00:53.430 --> 00:00:53.430
both of those platforms that gives
you the best set of technologies

00:00:53.430 --> 00:00:53.430
and tools to build great games.

00:00:53.770 --> 00:00:57.500
So from a game technology standpoint,
we have an amazing array of technologies.

00:00:57.500 --> 00:01:02.320
We have everything from OpenGL and
OpenGL ES to AV Foundation,

00:01:02.360 --> 00:01:04.190
Core Image.

00:01:04.220 --> 00:01:06.010
We have great graphics tools.

00:01:06.010 --> 00:01:10.660
We provide you great hardware,
Retina Display, A5X Processor,

00:01:10.660 --> 00:01:12.790
now Ivory Bridge in our Macs.

00:01:13.000 --> 00:01:14.290
Fantastic array of technologies.

00:01:14.380 --> 00:01:18.370
For the games kickoff,
we're going to focus on five of these.

00:01:18.370 --> 00:01:23.120
We're going to focus on Game Center,
Retina Display, graphics tools, AirPlay,

00:01:23.120 --> 00:01:24.380
and Core Image.

00:01:24.380 --> 00:01:29.380
And what I want to do is I want to
change some paradigms in your thinking,

00:01:29.590 --> 00:01:32.260
change the way you may approach
some of these technologies,

00:01:32.480 --> 00:01:35.380
and give you an overview of
where we have some new features.

00:01:35.500 --> 00:01:38.380
There are sessions all week that go
into depth in these technologies.

00:01:38.380 --> 00:01:41.370
So let's jump right in
with the Game Center.

00:01:43.610 --> 00:01:48.530
We talked about yesterday 130
million Game Center players.

00:01:48.810 --> 00:01:50.610
That's just an amazing number of players.

00:01:50.840 --> 00:01:55.120
And what's even more amazing
is 5 billion scores per week.

00:01:55.450 --> 00:01:57.260
That's playing your applications.

00:01:57.300 --> 00:01:59.630
One of the key things about
Game Center is it makes

00:01:59.630 --> 00:02:01.120
your games more accessible.

00:02:01.240 --> 00:02:03.690
It makes them sticky,
makes you be able to find them,

00:02:03.690 --> 00:02:05.110
makes you play together.

00:02:05.140 --> 00:02:09.100
And I had a developer come up to
me after the Kickoff yesterday,

00:02:09.110 --> 00:02:11.460
and they said they had
a single-player game,

00:02:11.460 --> 00:02:14.040
and they realized that
really the single-player game

00:02:14.040 --> 00:02:14.950
is really like an island.

00:02:14.960 --> 00:02:17.070
It is alone,
and they already started working

00:02:17.070 --> 00:02:18.530
on integrating Game Center.

00:02:18.530 --> 00:02:21.930
So really, if you're in the minority
and you have not integrated

00:02:21.930 --> 00:02:25.000
Game Center into your games,
now is the time to do that.

00:02:26.780 --> 00:02:32.130
So Game Center, as we announced,
is available on iOS and OS X for the Mac.

00:02:32.180 --> 00:02:37.100
We also announced yesterday that
we have a new Game Center with

00:02:37.100 --> 00:02:37.990
a bunch of new features.

00:02:37.990 --> 00:02:42.780
That new Game Center will be available
on iOS 6 and for OS X this fall.

00:02:42.780 --> 00:02:46.140
So you'll have the same
Game Center across the platform

00:02:46.140 --> 00:02:47.730
to work for your games.

00:02:49.410 --> 00:02:51.940
So if you're new to Game Center,
let's do a little bit of

00:02:51.940 --> 00:02:55.420
an overview as far as what
pieces we have in Game Center.

00:02:55.420 --> 00:02:58.420
So first, we have the Game Center app.

00:02:58.420 --> 00:03:01.350
And the Game Center app is
kind of the hub for the player.

00:03:01.350 --> 00:03:04.250
So it'll allow players
to find their friends,

00:03:04.470 --> 00:03:08.750
find games, inspect the challenges,
and see the leaderboard,

00:03:08.750 --> 00:03:14.690
see where they rank in the gaming
world as far as the Game Center app.

00:03:15.810 --> 00:03:20.190
The game kit is your API for Game Center.

00:03:20.200 --> 00:03:25.550
It also includes some API for some
of the in-game multiplayer invites,

00:03:25.620 --> 00:03:28.460
and it includes a wide array of API.

00:03:28.460 --> 00:03:32.320
The interesting thing about this is
when we brought the game kit to the Mac,

00:03:32.320 --> 00:03:35.160
we took a conscious effort
to make sure that it's almost

00:03:35.160 --> 00:03:37.230
identical between iOS and the Mac.

00:03:37.310 --> 00:03:40.140
We don't want you having to rewrite
code or put a bunch of if-defs

00:03:40.370 --> 00:03:43.620
around code blocks because we change
the behavior in a very small way.

00:03:43.950 --> 00:03:46.540
So there's very few differences
between the game kit

00:03:46.540 --> 00:03:50.890
framework on iOS and the Mac,
making it super easy to adopt.

00:03:51.350 --> 00:03:54.030
and finally we have the
Game Center services which

00:03:54.030 --> 00:03:57.270
provide the cloud support,
provide the leaderboards,

00:03:57.270 --> 00:04:01.300
achievement uploading,
provide the multiplayer invites,

00:04:01.480 --> 00:04:03.560
all the back end of Game Center.

00:04:03.660 --> 00:04:07.550
So that's kind of the
overview of the pieces.

00:04:08.410 --> 00:04:13.740
The things it provides are friends,
leaderboards, achievements, multiplayer,

00:04:13.740 --> 00:04:17.260
real-time and turn-based, voice chat,
and discovery.

00:04:17.260 --> 00:04:20.360
And again, let's reiterate on
discovery a little bit.

00:04:20.730 --> 00:04:25.330
What we want to do is we want to provide
services that make it easy to find

00:04:25.460 --> 00:04:27.480
your game so you can differentiate.

00:04:27.600 --> 00:04:30.540
If you have a unique game,
it doesn't get hidden in amongst

00:04:30.690 --> 00:04:32.360
the many other games out there.

00:04:32.420 --> 00:04:34.890
You can define your game,
you can have players attracted to it,

00:04:34.980 --> 00:04:37.950
they can tell their friends,
they can link to it,

00:04:37.960 --> 00:04:39.820
those kind of things,
and they can get players into

00:04:39.910 --> 00:04:41.900
your game so you can sell games
and you can be successful.

00:04:41.980 --> 00:04:43.340
So that's the idea with Game Center.

00:04:43.340 --> 00:04:44.570
We want to make you successful.

00:04:46.320 --> 00:04:47.710
Let's talk about some
of the new features.

00:04:47.720 --> 00:04:49.280
Those are the features we had previously.

00:04:49.280 --> 00:04:50.430
We've introduced some new features.

00:04:50.440 --> 00:04:53.100
I want to walk you through
kind of the basics of them.

00:04:53.100 --> 00:04:55.640
And later on this week,
we'll talk about the code you

00:04:55.920 --> 00:04:58.470
have to write and things you
have to do specifically for

00:04:58.790 --> 00:05:00.250
some of these new features.

00:05:00.250 --> 00:05:03.700
And many of them are built right in,
such as sharing scores and achievements.

00:05:03.700 --> 00:05:06.330
So a player can simply have
a great achievement here.

00:05:06.330 --> 00:05:11.320
He's crazy good at Jetpack Joyride,
and he can decide he wants to share it.

00:05:11.480 --> 00:05:14.260
We have the activity
sheet come up in iOS.

00:05:14.260 --> 00:05:16.170
He will say he wants to share it.

00:05:16.200 --> 00:05:17.960
He will say he wants to share it on
Facebook to let the world know how

00:05:17.960 --> 00:05:19.280
good you are in Jetpack Joyride.

00:05:19.280 --> 00:05:22.430
And it goes up to the
Facebook page to post that,

00:05:22.520 --> 00:05:25.980
and it appears on the
Facebook wall of the player.

00:05:25.980 --> 00:05:26.540
Great.

00:05:26.660 --> 00:05:29.240
So this is a,
this again breaks down that small

00:05:29.270 --> 00:05:32.820
circle around your game and lets
other people know about kind

00:05:32.840 --> 00:05:34.860
of advertising for your game.

00:05:36.660 --> 00:05:37.920
Let's talk about liking games.

00:05:38.100 --> 00:05:38.540
Super simple.

00:05:38.560 --> 00:05:41.200
In Game Center now,
we have the Like icon.

00:05:41.200 --> 00:05:44.500
You can simply -- it's right there,
and you can simply press it.

00:05:44.510 --> 00:05:47.460
Likes the game,
and what it does is it actually puts a

00:05:47.580 --> 00:05:52.100
post on the player's wall about the game,
and the key here is it gives a direct

00:05:52.250 --> 00:05:54.780
link back to the App Store for your game.

00:05:54.880 --> 00:05:57.700
So if you have a -- if
you adopt Game Center,

00:05:57.760 --> 00:06:00.700
new in iOS and will be
coming to the Mac also,

00:06:00.700 --> 00:06:03.050
you can like games,
and that can give an outside world

00:06:03.060 --> 00:06:05.460
the link back into your game.

00:06:05.880 --> 00:06:06.740
Local multiplayer.

00:06:07.120 --> 00:06:08.610
Local multiplayer is pretty cool.

00:06:08.610 --> 00:06:10.800
So you have a bunch of people
who've gathered at the conference.

00:06:10.800 --> 00:06:13.800
You may not all be friends
on Game Center right now,

00:06:13.800 --> 00:06:16.120
but you're sitting next to each
other in one of the conference areas,

00:06:16.120 --> 00:06:17.800
and you actually want
to play a game together.

00:06:17.800 --> 00:06:21.790
What we can do is you can
go to local multiplayer,

00:06:22.090 --> 00:06:26.400
and you get in here and you click
nearby and we fill that in with

00:06:26.400 --> 00:06:27.450
the people who are close to you.

00:06:27.460 --> 00:06:30.380
So it's ad hoc,
you don't need to be on a Wi-Fi network,

00:06:30.560 --> 00:06:33.680
easy for kids to set up,
you may have your child go over

00:06:33.680 --> 00:06:36.360
to someone else's house and they
want to play with their friends

00:06:36.360 --> 00:06:38.230
and they don't have to get on
the Wi-Fi and do all that stuff,

00:06:38.290 --> 00:06:40.710
they can simply do local multiplayer
and play with their friends.

00:06:40.720 --> 00:06:42.720
So that's local multiplayer.

00:06:42.720 --> 00:06:43.920
And challenges.

00:06:43.920 --> 00:06:45.060
We love challenges.

00:06:45.170 --> 00:06:48.720
Challenges are cool because
you've designed this fantastic,

00:06:49.000 --> 00:06:54.080
brilliant puzzle game that's
a great single-person game,

00:06:54.080 --> 00:06:56.700
a lot of replayability,
but it doesn't connect to other people.

00:06:56.700 --> 00:07:00.110
Well, challenges makes that single-player
game a multiplayer game.

00:07:00.360 --> 00:07:03.940
Someone can be going back and forth on
your puzzles with their friends saying,

00:07:03.940 --> 00:07:07.860
hey, I finished this in 35 seconds,
beat that kind of thing.

00:07:07.860 --> 00:07:09.360
So we can go back and
forth with challenges.

00:07:09.360 --> 00:07:10.360
So how does it mechanize?

00:07:10.470 --> 00:07:13.600
So you've made an achievement here in
Temple Run and you want to challenge

00:07:13.600 --> 00:07:15.400
your friends for that achievement.

00:07:15.400 --> 00:07:17.380
So you simply,
in the same kind of place where

00:07:17.380 --> 00:07:20.930
you're inspecting your achievements,
you simply hit challenge friends.

00:07:20.960 --> 00:07:24.340
It comes up with a text
box there you fill in.

00:07:24.340 --> 00:07:26.200
Can you beat this score?

00:07:28.180 --> 00:07:31.800
You send it over,
your friend gets the challenge.

00:07:31.800 --> 00:07:35.400
It comes up in their challenges tab,
which is new for the new

00:07:35.410 --> 00:07:37.040
Game Center in iOS 6.

00:07:37.040 --> 00:07:39.020
They click on it,
and what they can see is they

00:07:39.020 --> 00:07:41.490
can see who challenged them,
what the challenge is,

00:07:41.490 --> 00:07:44.500
and they can either play now or they
can kind of whip out and decline

00:07:44.500 --> 00:07:46.080
the challenge if they decide to.

00:07:46.080 --> 00:07:49.270
But, of course, you want to play,
and they didn't know how good

00:07:49.270 --> 00:07:50.940
of a Temple Run player you are.

00:07:50.940 --> 00:07:52.160
They thought they would easily beat you.

00:07:52.160 --> 00:07:53.080
In this case, they didn't.

00:07:53.520 --> 00:07:55.620
You were easily able to
beat their challenge,

00:07:55.620 --> 00:07:58.440
and what you wanted to do was
send back a score challenge.

00:07:58.440 --> 00:08:02.320
So, in this case,
you've collected 1523 coins,

00:08:02.320 --> 00:08:05.200
a good amount there,
and you want to send it back to them.

00:08:05.200 --> 00:08:07.200
You can send back a score challenge.

00:08:07.200 --> 00:08:09.660
What's interesting about score
challenges also is you have

00:08:09.730 --> 00:08:11.160
this kind of auto-challenge.

00:08:11.210 --> 00:08:13.690
Once it's sent back to them,
if they beat the challenge,

00:08:13.690 --> 00:08:15.200
it'll auto-challenge them back.

00:08:15.200 --> 00:08:18.200
So you can go back and forth
trying to one-up each other.

00:08:18.200 --> 00:08:20.090
Again, replayability for your games.

00:08:20.380 --> 00:08:23.200
Makes them sticky,
reminds people your games are there.

00:08:23.200 --> 00:08:25.770
One of your players may not have
played your game and not have

00:08:25.770 --> 00:08:30.160
bought any in-app purchases,
and some of their friends challenge them.

00:08:30.210 --> 00:08:32.150
So they pick the game back
up and they play it again.

00:08:32.260 --> 00:08:36.200
So we're trying to add that replayability
for you guys for your games.

00:08:36.200 --> 00:08:41.370
So challenge goes back,
right back at you.

00:08:42.800 --> 00:08:43.800
And there you go.

00:08:43.800 --> 00:08:44.800
So that's challenges.

00:08:44.800 --> 00:08:46.620
Turns that single-player
gaming experience,

00:08:46.620 --> 00:08:50.370
that fantastic one that you've built,
into a great multiplayer experience

00:08:50.400 --> 00:08:53.100
and keeps people engaged in your game.

00:08:56.360 --> 00:08:59.860
So let's do a demo of a great
implementation of challenges.

00:08:59.910 --> 00:09:04.600
I want to bring up Halfbrick, Adam Wood,
and Joe Gaatling to show we've kind of

00:09:04.600 --> 00:09:10.820
challenged them to see what they could
do with challenges on Jetpack Joyride.

00:09:17.500 --> 00:09:20.160
We've been playing with
Challengers for a few days now,

00:09:20.160 --> 00:09:23.780
and we really wanted to see how we
could integrate this into our game.

00:09:23.920 --> 00:09:27.520
So as you saw earlier,
Challengers work completely

00:09:27.580 --> 00:09:30.310
from Game Center,
but it's also possible to integrate

00:09:30.390 --> 00:09:31.790
them into the game as well.

00:09:31.910 --> 00:09:34.200
So we've been playing around
with it for a little bit,

00:09:34.400 --> 00:09:36.430
and we've come up with some
stuff that's pretty cool,

00:09:36.430 --> 00:09:39.000
and we'd like to share it with you.

00:09:40.710 --> 00:09:44.320
I sent Adam here a
challenge earlier today,

00:09:44.320 --> 00:09:46.770
and now in front of all of you,
we're going to see whether or not

00:09:46.790 --> 00:09:48.000
he can actually beat my score.

00:09:48.080 --> 00:09:50.850
So I sent him 974 meters.

00:09:50.940 --> 00:09:54.010
So let's take it away
and see if you can do it.

00:09:55.400 --> 00:09:57.440
Okay, now,
if you've played Jetpack before,

00:09:57.440 --> 00:09:59.420
the first thing you're going
to notice is that there's an

00:09:59.420 --> 00:10:00.400
extra character on the screen.

00:10:00.400 --> 00:10:02.280
This is actually me.

00:10:02.280 --> 00:10:05.620
When I sent the challenge,
I also sent along with it a ghost so

00:10:05.620 --> 00:10:07.700
that Adam has someone to race against.

00:10:07.780 --> 00:10:10.180
So the way this works is
that when I was playing,

00:10:10.180 --> 00:10:12.880
the game recorded every
movement that I made and every

00:10:12.880 --> 00:10:14.540
obstacle that was generated.

00:10:14.540 --> 00:10:16.920
At the end of the game,
we uploaded this to a server.

00:10:16.920 --> 00:10:19.880
Now,
when you send a score to Game Center,

00:10:19.880 --> 00:10:24.710
there is a 64-bit context variable
that's associated with it.

00:10:24.950 --> 00:10:27.390
And we're using that context
to store a key so that we can

00:10:27.430 --> 00:10:30.050
retrieve this ghost and level
information from our own servers.

00:10:30.060 --> 00:10:33.680
So when I send the challenge to Adam,
that score and the associated

00:10:33.680 --> 00:10:35.060
context goes with it.

00:10:35.060 --> 00:10:39.400
And that's how he's able to download
the exact same level and all my

00:10:39.400 --> 00:10:41.680
recorded ghost data onto his own device.

00:10:41.680 --> 00:10:44.210
So even though he's still
just trying to get my score,

00:10:44.210 --> 00:10:46.870
we've added an extra character
for him to run again.

00:10:46.920 --> 00:10:52.290
So it's turned this asynchronous
challenge mode into what really

00:10:52.290 --> 00:10:55.920
feels like an exciting and
engaging head-to-head match.

00:10:55.920 --> 00:10:59.390
So I'm pretty confident that he's not
going to be able to beat my score,

00:10:59.390 --> 00:11:01.440
but let's just see how this plays out.

00:11:01.440 --> 00:11:05.480
All right, okay, well,
Adam always was slightly better

00:11:05.480 --> 00:11:07.780
at this -- at me than this game.

00:11:08.740 --> 00:11:10.300
I think he's going easy on me.

00:11:10.390 --> 00:11:14.030
Now, as was mentioned earlier,
this challenge is now going to

00:11:14.030 --> 00:11:15.450
be sent back to me automatically.

00:11:15.460 --> 00:11:17.660
So we're going to have this
backwards and forwards going.

00:11:17.660 --> 00:11:20.240
But if he wants,
he can forward this challenge

00:11:20.250 --> 00:11:21.680
on to some of his other friends.

00:11:21.680 --> 00:11:25.320
So here you can see he can click
to bring up a friend selection,

00:11:25.320 --> 00:11:28.260
selects one or more friends,
and clicks send.

00:11:28.260 --> 00:11:31.870
And now that challenge and the ghost
data and the level he was playing is

00:11:31.870 --> 00:11:33.820
going to be sent on to his friends.

00:11:33.820 --> 00:11:37.040
And that's how you can use
challenges to turn a single-player

00:11:37.040 --> 00:11:38.680
game into an engaging game.

00:11:38.700 --> 00:11:41.040
head-to-head style experience.

00:11:41.060 --> 00:11:43.000
Thank you.

00:11:46.800 --> 00:15:04.200
[Transcript missing]

00:15:06.930 --> 00:15:09.740
So we also have a great
streamlined multiplayer UI.

00:15:09.790 --> 00:15:12.850
This is fantastic where you have,
in this case,

00:15:12.850 --> 00:15:15.360
you can get two to four players,
you can control, you can remove a player,

00:15:15.360 --> 00:15:17.490
you can add a player,
you can fill in some players with your

00:15:17.490 --> 00:15:20.670
friends if you want to play with friends,
but one of your friends isn't available,

00:15:20.670 --> 00:15:21.970
so maybe you do an auto-invite.

00:15:21.970 --> 00:15:24.740
Really easy to control it,
it's great pictures,

00:15:24.860 --> 00:15:29.040
so it's a new streamlined multiplayer
UI in the new Game Center on iOS 6.

00:15:30.970 --> 00:15:32.900
And also we have multiplayer rematch.

00:15:32.940 --> 00:15:36.290
Multiplayer rematch allows you to
programmatically record that rematch

00:15:36.660 --> 00:15:39.560
and record that match and re-invite
those players to another match.

00:15:39.640 --> 00:15:42.400
It really helps out if you're doing
an auto-match and you kind of say,

00:15:42.400 --> 00:15:44.580
"Hey, that was a great game.

00:15:44.580 --> 00:15:46.550
Let's play again." You don't
have to find the same players.

00:15:46.660 --> 00:15:47.700
You don't have to remember who they are.

00:15:47.700 --> 00:15:51.760
You can do the auto-match and
pick up those auto-match players.

00:15:52.040 --> 00:15:57.390
So another great thing
we've added to Game Center,

00:15:57.390 --> 00:15:57.390
the new Game Center.

00:15:57.870 --> 00:15:59.340
So those are kind of the social aspects.

00:15:59.340 --> 00:16:01.680
We've also added things like
improved authentication,

00:16:01.680 --> 00:16:04.700
which cleans up the
authentication flow for you guys.

00:16:04.700 --> 00:16:06.200
We've added a unified interface.

00:16:06.200 --> 00:16:08.930
When we do add new features,
you don't have to recode your

00:16:08.930 --> 00:16:12.180
game for a real interface that
can be adopted automatically.

00:16:12.180 --> 00:16:15.310
Turn timeouts, as I mentioned,
one of the things that was requested

00:16:15.310 --> 00:16:17.910
from a turn-based game folks
is that you have three or four

00:16:17.920 --> 00:16:22.840
players playing a game that does not
require everyone to be there for,

00:16:22.840 --> 00:16:24.800
and one player decides I'm
losing so I'm not going to play,

00:16:24.800 --> 00:16:25.740
and they halt the game.

00:16:25.740 --> 00:16:27.880
So turn timeouts,
you can set that as a developer.

00:16:27.970 --> 00:16:30.630
It's initially set at two weeks,
but you can bring it into whatever

00:16:30.880 --> 00:16:33.860
your turn makes sense for you
guys and keeps your games flowing.

00:16:33.860 --> 00:16:37.110
Programmatic invites,
you can do invites within your game,

00:16:37.170 --> 00:16:38.300
so it really is nice.

00:16:38.460 --> 00:16:41.860
It keeps you inside of that game like we
saw with challenges with Jetpack Joyride.

00:16:42.180 --> 00:16:44.180
It keeps people inside the game itself.

00:16:44.180 --> 00:16:45.770
We have host election.

00:16:45.770 --> 00:16:49.660
We do an automatic job of finding
the best host for your game,

00:16:49.720 --> 00:16:54.170
so that's fantastic because we allow,
we do the hard work for you,

00:16:54.180 --> 00:16:55.900
figure out who the best
host is for the game.

00:16:55.940 --> 00:16:59.880
And turn match data saving,
it sounds like you're kind of like, well,

00:16:59.880 --> 00:17:02.700
what's that mean,
how does that fit together?

00:17:02.700 --> 00:17:06.430
Well, let's say you have a game that has
multiple moves in a turn that you're

00:17:06.530 --> 00:17:09.940
playing some kind of a strategy
game that you move multiple pieces.

00:17:09.940 --> 00:17:09.940
But one turn, usually in your right hand,
you're going to have a game that has

00:17:09.940 --> 00:17:09.940
multiple moves in a turn that you're
playing some kind of a strategy

00:17:09.940 --> 00:17:09.940
game that you move multiple pieces.

00:17:09.940 --> 00:17:09.940
But one turn, usually in your right hand,
you're going to have a game that has

00:17:09.940 --> 00:17:09.940
multiple moves in a turn that you're
playing some kind of a strategy game

00:17:09.940 --> 00:17:09.940
that you're moving multiple pieces.

00:17:10.020 --> 00:17:14.110
but one turn usually right now is
that you only see the final results.

00:17:14.230 --> 00:17:18.990
Well turn match data saving allows you
guys to show those those turns to all

00:17:18.990 --> 00:17:23.680
the other players playing the game so you
can do that with turn match data saving.

00:17:25.090 --> 00:17:25.900
So that's Game Center.

00:17:26.090 --> 00:17:30.180
It provides the backbone for
your social gaming network.

00:17:30.730 --> 00:17:31.860
Most of you are already on it.

00:17:31.860 --> 00:17:34.380
The few of you who aren't on it,
now it's time to adopt it.

00:17:34.380 --> 00:17:38.620
Hopefully we've given you some great new
features that can even make your gaming

00:17:38.620 --> 00:17:43.560
experience for your players even better
and attract more players to your game.

00:17:45.680 --> 00:17:46.590
So let's talk about AirPlay.

00:17:46.800 --> 00:17:48.450
We talked again about it yesterday.

00:17:48.670 --> 00:17:50.570
Kind of want to go through
some of the basics.

00:17:50.670 --> 00:17:53.230
We talked about what it can
be used for streaming audio,

00:17:53.380 --> 00:17:55.800
streaming video, mirror display,
second display.

00:17:55.800 --> 00:17:57.480
We want to focus on that
second display piece.

00:17:57.480 --> 00:18:01.400
So of course you can mirror
to a TV with your iPad.

00:18:01.820 --> 00:18:05.930
Mac OS X Mountain Lion,
you can now mirror to a TV on your Mac,

00:18:05.930 --> 00:18:09.040
and you can do second
display on iOS devices.

00:18:09.040 --> 00:18:13.000
The great thing about second display is
the paradigms it adds for your games.

00:18:13.000 --> 00:18:15.490
We talked about an action
game where you're looking up,

00:18:15.490 --> 00:18:17.540
you can put content
on the second display,

00:18:17.540 --> 00:18:22.030
and that allows players to concentrate
on the big display and have their kind

00:18:22.030 --> 00:18:24.680
of radar panel or their simple controls.

00:18:24.680 --> 00:18:29.190
Note here that what Sky Gamblers did
was they put really simple controls that

00:18:29.190 --> 00:18:33.520
were cleverly placed for your thumbs,
and give you basic information

00:18:33.520 --> 00:18:34.960
on the second display.

00:18:34.960 --> 00:18:37.260
They didn't try and overload
you with too many controls here.

00:18:37.260 --> 00:18:40.800
So this is a good idea,
a good paradigm to think about.

00:18:40.960 --> 00:18:42.910
When you slow things down,
talk about the shared experience,

00:18:43.020 --> 00:18:44.800
you have a game where you're
passing an iPad around.

00:18:44.800 --> 00:18:47.800
In this case, we're using the full
multi-touch interface.

00:18:47.800 --> 00:18:49.150
Because the person
who's playing the game,

00:18:49.150 --> 00:18:50.800
they're actually drawing,
looking at the iPad.

00:18:50.800 --> 00:18:55.510
The people who are playing with them,
sharing that experience,

00:18:55.580 --> 00:18:57.790
are looking at the TV in this case.

00:18:57.980 --> 00:19:00.380
Family Game Night,
everyone in this case has a device.

00:19:00.440 --> 00:19:01.740
You're sharing the board.

00:19:01.740 --> 00:19:03.830
Think about this as
your classic board game.

00:19:03.830 --> 00:19:05.340
So you have a classic kind of board game.

00:19:05.340 --> 00:19:08.970
Everyone has their units, their tiles,
their cards, or whatever,

00:19:09.080 --> 00:19:10.830
and that's on their own device.

00:19:10.860 --> 00:19:15.320
You could even, in this case,
since you're doing multiplayer and

00:19:15.350 --> 00:19:20.620
the device is a single AirPlay device,
you can do, it could be a Mac down here,

00:19:20.620 --> 00:19:22.730
it could be any iPads down here.

00:19:23.040 --> 00:19:26.310
The devices at the end to share the
multiplayer can be any set of devices.

00:19:27.960 --> 00:19:30.130
and finally,
a good example from Real Racing,

00:19:30.300 --> 00:19:33.780
4-up racing action, divide the screen,
you have a big screen,

00:19:33.780 --> 00:19:36.350
use that real estate,
divide it into four quadrants,

00:19:36.360 --> 00:19:39.160
everyone has their controllers,
and you see that you have a

00:19:39.160 --> 00:19:41.020
heads-up display on the iPad there.

00:19:41.020 --> 00:19:44.420
So let's talk more about,
that's what we talked about yesterday,

00:19:44.420 --> 00:19:46.670
let's talk a little bit
more about setting this up.

00:19:46.980 --> 00:19:48.840
There's been some great
adoption of second display,

00:19:48.890 --> 00:19:51.940
but we think there's probably more
great adoption out there also.

00:19:51.940 --> 00:19:53.780
So it's really, really simple.

00:19:53.780 --> 00:19:57.540
And the nice thing here is
that we talked about AirPlay,

00:19:57.680 --> 00:20:00.700
but second display on iOS also
refers to plugging in displays.

00:20:00.700 --> 00:20:06.620
So if you implement it once for AirPlay,
you've gotten plug-in displays also.

00:20:06.620 --> 00:20:09.990
So if you plug in via an
HDMI connector to the dock port,

00:20:10.000 --> 00:20:12.850
the 30-pin,
then you get both of those are

00:20:12.850 --> 00:20:15.240
exactly the same code to support.

00:20:15.240 --> 00:20:17.170
So set up at launch,
configure to display,

00:20:17.170 --> 00:20:19.080
let's handle the rotation correctly.

00:20:19.080 --> 00:20:22.450
Every now and then we see examples
of games where... you rotate it

00:20:22.460 --> 00:20:25.260
and the TV image turns upside down,
we'll talk about handling that.

00:20:25.260 --> 00:20:28.580
And a little bit about
design considerations.

00:20:28.660 --> 00:20:30.640
This is really straightforward.

00:20:30.700 --> 00:20:33.710
So when your app finishes launching,
you want to actually make sure you set up

00:20:33.710 --> 00:20:35.370
the screens for whatever screens exist.

00:20:35.500 --> 00:20:39.000
You also want to make sure
that you do two notifications.

00:20:39.000 --> 00:20:41.690
One is to correctly handle
extreme connections,

00:20:41.690 --> 00:20:43.740
and also disconnects.

00:20:44.100 --> 00:20:46.940
Because you don't know what the
user's kind of set of actions are.

00:20:46.940 --> 00:20:49.380
They could launch your game and say,
"Hey, I want to plug into the TV."

00:20:49.380 --> 00:20:51.640
When they plug in at that point,
you're going to get the connection,

00:20:51.670 --> 00:20:52.780
the connection to the TV,
and the disconnect notification

00:20:52.780 --> 00:20:53.540
after your game started.

00:20:53.610 --> 00:20:54.980
So make sure you handle those correctly.

00:20:55.020 --> 00:20:57.440
If they said they didn't
want to be playing on TV,

00:20:57.440 --> 00:20:59.920
they want to hop on the subway,
head to work, they want,

00:20:59.920 --> 00:21:02.210
but they're playing the long game,
they just disconnect and you should

00:21:02.210 --> 00:21:04.410
handle that gracefully and correctly.

00:21:05.720 --> 00:21:09.030
So we configure the second display,
pretty straightforward.

00:21:09.030 --> 00:21:13.150
If your screen counts greater than one,
you have a second display.

00:21:13.560 --> 00:21:15.540
We're going to get the screen
and we create a new window.

00:21:15.600 --> 00:21:17.700
Basically the screen size,
we introspect that,

00:21:17.760 --> 00:21:20.660
grab the size out of it,
create the window.

00:21:20.860 --> 00:21:23.100
We then want to create a view
controller for it as you would expect

00:21:23.100 --> 00:21:24.300
that you do for your main display.

00:21:24.300 --> 00:21:26.810
You do the same thing
for your second display.

00:21:27.640 --> 00:21:31.870
and finally, super straightforward,
you create, you turn on,

00:21:31.880 --> 00:21:35.560
you unhide the window or
instead make sure it's visible.

00:21:37.900 --> 00:21:38.960
So handling rotation.

00:21:39.020 --> 00:21:41.600
This is pretty straightforward,
but there's a little nuance here.

00:21:41.600 --> 00:21:44.700
This is kind of like your,
this should be the default method,

00:21:44.700 --> 00:21:46.630
but it's going to be the default
method that you write in your code.

00:21:46.640 --> 00:21:49.270
So override the default method with this.

00:21:49.270 --> 00:21:52.400
The idea here is for an iPad,
you want to handle all rotations.

00:21:52.400 --> 00:21:54.230
So no matter which way
someone turns an iPad,

00:21:54.300 --> 00:21:54.960
you do that.

00:21:55.150 --> 00:21:57.140
But for a phone,
you want to make sure that we,

00:21:57.140 --> 00:22:00.090
from our HI guidelines,
they don't turn the phone upside down,

00:22:00.320 --> 00:22:02.240
and they should not have that rotation.

00:22:02.280 --> 00:22:05.160
So the phone has three rotations
effectively that are viable,

00:22:05.160 --> 00:22:07.780
which is straight up, normal, each side.

00:22:07.800 --> 00:22:10.470
And then upside down is not,
we don't use the upside down one.

00:22:10.470 --> 00:22:14.860
This means that we'll rotate
the image in the system.

00:22:14.860 --> 00:22:18.270
We'll use a, you know,
our core animation layers,

00:22:18.350 --> 00:22:20.780
we'll rotate it correctly for you.

00:22:20.780 --> 00:22:23.790
So we put it out to both heads
that you're talking to now

00:22:23.790 --> 00:22:25.630
with the correct rotation.

00:22:25.630 --> 00:22:27.530
We do this because if
you do it in OpenGL,

00:22:27.530 --> 00:22:29.990
for example, and say, hey,
my device got rotated,

00:22:29.990 --> 00:22:32.360
I'm just going to change my
matrices and I'm going to

00:22:32.360 --> 00:22:35.320
rotate it when I do my OpenGL,
what happens is you'll rotate your

00:22:35.320 --> 00:22:37.780
device to match the player's angle,
and you'll rotate your device

00:22:37.780 --> 00:22:37.780
to match the player's angle.

00:22:37.800 --> 00:22:39.720
And your TV will turn upside down.

00:22:39.720 --> 00:22:42.160
So you really want to make
sure you do it this way rather

00:22:42.160 --> 00:22:43.440
than doing it in the OpenGL.

00:22:43.440 --> 00:22:44.680
So this is the correct
way to handle rotation.

00:22:46.560 --> 00:22:48.840
And then we talked about many
of these ideas with design,

00:22:48.840 --> 00:22:50.360
like where is the user looking?

00:22:50.360 --> 00:22:50.920
Are they looking up?

00:22:50.980 --> 00:22:51.740
Are they looking down?

00:22:51.740 --> 00:22:55.040
What kind of -- how do they control
the game and what should be displayed

00:22:55.040 --> 00:22:56.500
on the device and on the TV?

00:22:56.500 --> 00:22:59.430
And the last one is something
I want to carry through to the

00:22:59.510 --> 00:23:03.740
end of the talk is about updates,
about performance of your application.

00:23:03.740 --> 00:23:05.680
There's a lot of things
that you can do to adjust

00:23:06.170 --> 00:23:07.740
performance of your application.

00:23:07.740 --> 00:23:09.960
We don't have to get back to
the old paradigm of scaling

00:23:10.030 --> 00:23:11.700
everything down to make it perform.

00:23:11.790 --> 00:23:13.670
There's different ways
you can adjust this.

00:23:13.740 --> 00:23:17.670
And so when you're using second display,
it may not be appropriate to run both

00:23:17.670 --> 00:23:21.530
at full resolution or it may not be
appropriate to update both at 60 hertz.

00:23:22.030 --> 00:23:24.850
Maybe your kind of your heads-up
display that's your controller

00:23:24.850 --> 00:23:27.740
is doing great getting the
gyro input at a high frequency,

00:23:27.740 --> 00:23:31.740
but you don't really need to update
that at more than 20 hertz or 30 hertz.

00:23:31.740 --> 00:23:35.740
So you can limit the amount of
information going to the second display

00:23:35.740 --> 00:23:41.920
while concentrating the majority
of your performance on the big screen.

00:23:43.300 --> 00:23:46.200
So what that boils down to is
kind of two basic breakdowns.

00:23:46.200 --> 00:23:47.760
You have the action game
where everyone's looking up,

00:23:47.830 --> 00:23:50.920
simple controls on the
device in front of you,

00:23:50.920 --> 00:23:53.340
and then you have the other
game where people are mainly

00:23:53.350 --> 00:23:56.260
doing input via the device,
and the eyeballs for the person

00:23:56.350 --> 00:23:57.910
holding the device is down.

00:23:57.920 --> 00:23:59.270
So that's second display.

00:23:59.270 --> 00:24:01.870
We'd love to see some of the
things you can do with it.

00:24:01.870 --> 00:24:05.910
We think games are great when they,
and users really react to that.

00:24:06.110 --> 00:24:09.070
You plug it in or you do an
AirPlay mirror and the device does

00:24:09.070 --> 00:24:13.040
exactly what they expect it to and
it enhances the gaming experience.

00:24:13.370 --> 00:24:15.040
using second display.

00:24:15.270 --> 00:24:17.110
So that's AirPlay.

00:24:18.180 --> 00:24:20.100
Next, let's talk about Core Image.

00:24:20.270 --> 00:24:24.340
So Core Image is a fantastic
technology for image manipulation

00:24:24.720 --> 00:24:29.700
that's across both iOS and OS X.

00:24:29.700 --> 00:24:32.580
And most of you think of Core Image,
you think of this kind of thing.

00:24:32.580 --> 00:24:37.740
If you're familiar with Core Image,
you think it's a photo manipulation API.

00:24:38.100 --> 00:24:40.670
So Core Image is the backbone
of iPhoto and Aperture,

00:24:40.670 --> 00:24:42.100
but it's more than that.

00:24:42.100 --> 00:24:47.330
It provides pixel-level effects
and optimized pixel-level effects,

00:24:47.330 --> 00:24:51.780
and it can provide a chain of
them and optimizes that chain.

00:24:51.780 --> 00:24:54.470
So what you have here is you have
someone who wanted to take an

00:24:54.610 --> 00:24:57.860
image and put an artistic effect,
which in this case is a sepia filter.

00:24:57.930 --> 00:25:00.300
They did a hue shift,
and then they did a contrast on

00:25:00.320 --> 00:25:02.260
that to get the effect they wanted.

00:25:02.260 --> 00:25:05.500
Well, how can you apply that to games?

00:25:05.520 --> 00:25:08.080
If we think about it,
if you look at the game,

00:25:08.080 --> 00:25:08.080
you can see that there's a lot
of different ways to play games.

00:25:08.100 --> 00:25:12.470
So if you look at movies and you look
at games through the last few years,

00:25:12.570 --> 00:25:14.210
games can be more and more cinematic.

00:25:14.320 --> 00:25:18.960
And this allows you a really good
hook into that cinematic solution.

00:25:18.960 --> 00:25:21.200
So if you look at a movie,
let's go back a little ways,

00:25:21.200 --> 00:25:21.840
look at The Matrix.

00:25:21.840 --> 00:25:23.010
The Matrix was color graded.

00:25:23.040 --> 00:25:25.400
When you're in The Matrix,
everything kind of had

00:25:25.400 --> 00:25:26.640
this green tinge to it.

00:25:26.640 --> 00:25:29.300
It got that uncomfortable
feeling for the viewer.

00:25:29.320 --> 00:25:31.760
And the real world didn't have that.

00:25:31.810 --> 00:25:33.000
You can do the same thing in your game.

00:25:33.000 --> 00:25:36.480
If you have two areas of play,
or if you have someone who's,

00:25:36.790 --> 00:25:38.060
when you're damaged,
or you want to make the player,

00:25:38.060 --> 00:25:38.060
you can do that.

00:25:38.060 --> 00:25:40.060
You can do things that are, you know,
uneasy.

00:25:40.060 --> 00:25:43.630
You can do things at an image level
to do that post-processing effect

00:25:43.720 --> 00:25:45.060
on your game to add play value.

00:25:45.060 --> 00:25:47.320
You see some of the high-budget
games are doing this.

00:25:47.430 --> 00:25:50.440
Well, with Core Image,
you can bring that to both OS X and

00:25:50.730 --> 00:25:53.060
to the mobile space for iOS.

00:25:53.060 --> 00:25:56.510
And you can do the same level of
color grading and post-processing

00:25:56.510 --> 00:25:58.060
effects with Core Image.

00:25:58.060 --> 00:26:00.810
So let's look at an example.

00:26:01.810 --> 00:26:02.720
So we have Mr.

00:26:02.720 --> 00:26:05.280
Big Sword here,
and you want to do a glow effect.

00:26:05.410 --> 00:26:09.220
You could do this in OpenGL using shells,
or you can make some additional textures,

00:26:09.220 --> 00:26:13.320
or some things with dot product,
but instead, let's just take that sprite

00:26:13.320 --> 00:26:15.110
and do a glow effect.

00:26:15.130 --> 00:26:18.610
If you're really sneaky about it,
you can control the alpha correctly,

00:26:18.610 --> 00:26:21.700
so you can do that on a sprite basis,
and you can stamp the

00:26:21.980 --> 00:26:25.180
sprite down on your 2D game,
for example,

00:26:25.180 --> 00:26:28.720
and have that Core Image effect come up.

00:26:28.810 --> 00:26:33.020
And this is so you render into a texture,
and then you apply this.

00:26:33.070 --> 00:26:35.540
Another example is,
you've rendered this great scene.

00:26:35.540 --> 00:26:37.580
We use this,
I think we saw this last year.

00:26:37.580 --> 00:26:42.850
This is this great kind of dungeon scene,
and you have this, you want foreboding.

00:26:42.860 --> 00:26:46.640
You want this to be darker and
kind of narrow the user's vision.

00:26:46.640 --> 00:26:49.260
Well, you can easily do that
with a vignette effect.

00:26:49.260 --> 00:26:51.460
So what you did,
you did a post-process on it,

00:26:51.460 --> 00:26:54.320
you applied the vignette effect,
filter we already have,

00:26:54.330 --> 00:26:56.860
and you bring it down in,
you focus the user.

00:26:56.860 --> 00:26:59.730
In this case,
maybe you have a some sort of surprise or

00:26:59.780 --> 00:27:01.340
a creature coming out from that hallway.

00:27:01.350 --> 00:27:04.700
It didn't really want to make it just
the baked-in lighting to your scene.

00:27:04.700 --> 00:27:08.690
You wanted to make it more closed in.

00:27:08.810 --> 00:27:11.610
Another example is a sprite-based game.

00:27:11.690 --> 00:27:14.490
In this case, you have kind of your
standard sprite-based shooter,

00:27:14.490 --> 00:27:17.390
and you wanted to do something,
either maybe the player gets damaged

00:27:17.460 --> 00:27:20.340
and it's a little harder to play,
or there's a screen transition.

00:27:20.340 --> 00:27:24.120
You can simply use a blur effect here,
and it's a full-screen blur

00:27:24.120 --> 00:27:25.840
effect using Core Image.

00:27:25.870 --> 00:27:29.780
And the important thing here is you don't
have to write a full library to do this.

00:27:29.870 --> 00:27:32.520
We give you a library to do it,
we give you optimized effects,

00:27:32.530 --> 00:27:34.080
and you can chain them together
in a million different ways.

00:27:34.130 --> 00:27:35.460
They're like building blocks.

00:27:35.570 --> 00:27:39.090
And while one block could be interesting,
you put a lot of blocks together,

00:27:39.090 --> 00:27:41.470
and it gets really interesting.

00:27:42.680 --> 00:27:43.400
Here's another example.

00:27:43.400 --> 00:27:46.320
We took that same scene,
but that was great.

00:27:46.320 --> 00:27:49.300
So after you escaped the corridor
and you got around the corner,

00:27:49.300 --> 00:27:51.870
you realized it was a control room,
and the control room had monitors

00:27:51.870 --> 00:27:53.360
throughout this haunted mansion.

00:27:53.360 --> 00:27:56.510
And so you wanted to do something
to indicate to the user that it

00:27:56.510 --> 00:27:58.500
really was a TV screen or a monitor.

00:27:58.500 --> 00:28:02.320
So you can use Core Image and
you get this kind of contrasty,

00:28:02.320 --> 00:28:06.390
noisy monitor kind of effect,
and that gives players that idea

00:28:06.390 --> 00:28:10.430
that it's different than just
them looking at it normally.

00:28:10.620 --> 00:28:12.670
And again,
this is to enhance that production value,

00:28:12.670 --> 00:28:14.560
make the players really
attracted to your game.

00:28:14.620 --> 00:28:16.620
So how does this work?

00:28:16.620 --> 00:28:20.250
Well, what you do is, for OpenGL,
you render to an FBO,

00:28:20.260 --> 00:28:23.110
render to a texture,
and use that as an input to Core Image.

00:28:23.120 --> 00:28:24.620
All of this can stay on the GPU.

00:28:24.620 --> 00:28:26.150
You don't have to come
back to the CPU to do it.

00:28:26.230 --> 00:28:27.700
So it can all stay accelerated.

00:28:28.020 --> 00:28:29.300
Core Image is fully accelerated.

00:28:29.410 --> 00:28:31.670
It can come across,
and then you use the results

00:28:31.670 --> 00:28:34.030
of that to draw to your screen.

00:28:34.120 --> 00:28:39.270
You can also replace the word "screen"
with "sprite." So for example,

00:28:39.270 --> 00:28:41.640
if you were rendering a very
complicated sprite using 3D,

00:28:41.640 --> 00:28:43.700
you could render the sprite,
you could apply a

00:28:43.770 --> 00:28:46.970
Core Image effect like the glow,
and then you could render to a

00:28:46.980 --> 00:28:50.510
sprite which then you use later as an
OpenGL texture back into your scene.

00:28:50.640 --> 00:28:55.140
One thing to think about here is
the update rate for your effects.

00:28:55.140 --> 00:28:57.980
Not every effect needs
to be updated at 60 Hz.

00:28:58.140 --> 00:29:01.640
For sprites, maybe you can either
process them statically,

00:29:01.640 --> 00:29:03.140
or if you have something
that's very dynamic,

00:29:03.140 --> 00:29:06.140
you update them at the rate
that that sprite would update.

00:29:06.140 --> 00:29:08.140
So you don't need to do
everything at the frame rate.

00:29:08.140 --> 00:29:10.080
You can do things at a
rate for the effect itself.

00:29:10.230 --> 00:29:12.140
So this saves you some processing power.

00:29:12.140 --> 00:29:16.100
And keep that in mind when
you're using Core Image.

00:29:16.340 --> 00:29:18.840
An example of the film
grain example we showed.

00:29:18.840 --> 00:29:21.130
In this case,
you have a couple of Core Image effects.

00:29:21.130 --> 00:29:23.390
You have noise generators
to generate some noise.

00:29:23.390 --> 00:29:24.660
You have a minimum filter.

00:29:24.660 --> 00:29:27.590
The image coming in the side is
combined with the first set of

00:29:27.700 --> 00:29:30.430
noise that's blended together,
and then you can blend

00:29:30.470 --> 00:29:32.100
another filter together.

00:29:32.100 --> 00:29:34.400
The idea here is that you have
multiple blends you can do.

00:29:34.400 --> 00:29:37.070
You can blend things in different orders,
different pieces.

00:29:37.070 --> 00:29:41.800
So you can combine a long filter chain
and make a very compelling example.

00:29:42.580 --> 00:29:46.520
So, speaking of compelling examples,
I'd like to bring up Jacques to talk

00:29:46.520 --> 00:29:51.290
about a little example he put together in
a few days using Core Image and showing

00:29:51.370 --> 00:29:53.750
how it can add to your gaming experience.

00:29:53.830 --> 00:29:54.740
Jacques.

00:29:55.230 --> 00:29:56.870
Thank you.

00:29:59.890 --> 00:30:00.650
Hi there, I'm Jacques.

00:30:00.800 --> 00:30:05.280
As Geoff just told you,
I'd like to show you an example of a

00:30:05.300 --> 00:30:07.590
little application I was toying with.

00:30:07.670 --> 00:30:13.270
Now, Core Image is a great API for you to
modify your effects that you've made.

00:30:13.440 --> 00:30:20.200
So here I have this simple kind of gloomy
forest where I want this sense of depth.

00:30:20.240 --> 00:30:22.260
I've created this with
just flat graphics.

00:30:22.310 --> 00:30:24.760
This is procedurally generated terrain.

00:30:24.820 --> 00:30:28.660
I've hand-painted a couple of
tree trunks and some branches.

00:30:28.740 --> 00:30:33.660
And I'm conveying the idea,
but that's about it.

00:30:33.850 --> 00:30:38.310
So I can use Core Image here
to help me out to convey what

00:30:38.310 --> 00:30:40.000
I'm really after a bit better.

00:30:40.110 --> 00:30:44.210
So the first problem here is
there's no sense of fog here.

00:30:44.280 --> 00:30:47.350
And what I'm really
after is a ground fog,

00:30:47.350 --> 00:30:47.350
so...

00:30:47.550 --> 00:30:53.080
I'm going to turn on a filter
here to just apply a little bit

00:30:53.080 --> 00:30:56.730
of noise and a linear gradient.

00:30:56.830 --> 00:31:02.960
And you can see how I have this
moving fog that's sort of stuck in the

00:31:03.530 --> 00:31:05.160
little valleys between the different--

00:31:05.300 --> 00:31:39.100
[Transcript missing]

00:31:39.380 --> 00:31:42.200
So I'd like to add some more
visual effects on top of this.

00:31:42.200 --> 00:31:47.540
And, you know, a dark, dim forest,
you know, it needs fireflies.

00:31:47.650 --> 00:31:53.240
So fireflies, I could have drawn these,
but really, since I'm using Core Image,

00:31:53.300 --> 00:31:56.900
I've got all these amazing tools,
I just had a point,

00:31:56.950 --> 00:32:01.200
and I applied bloom to that
to get this sort of glow.

00:32:01.260 --> 00:32:04.570
And it's tiny, so I can do this really,
really quickly.

00:32:04.700 --> 00:32:07.800
And you see how I've got
this little ambiance going.

00:32:07.800 --> 00:32:11.500
Okay, so I'm going to go over to more
full-screen effects now to,

00:32:11.570 --> 00:32:14.100
you know,
make this feel a bit more immersive.

00:32:14.120 --> 00:32:16.900
So it doesn't quite feel old enough.

00:32:16.900 --> 00:32:20.800
Not like you're at an old
cinema and it's black and white.

00:32:20.800 --> 00:32:22.800
That's kind of what I'm after.

00:32:22.800 --> 00:32:27.800
I'm going to apply a vignette and
a camera tracking error to it,

00:32:27.800 --> 00:32:29.800
and also a varying light bulb.

00:32:29.800 --> 00:32:33.390
So you can see how it's kind of a
film that's lit with an incandescent

00:32:33.440 --> 00:32:38.100
light bulb that's being projected,
and it's feeling pretty grungy right now.

00:32:38.100 --> 00:32:41.040
And these are some simple things
that you can do with some fairly

00:32:41.040 --> 00:32:42.910
simple Core Image filter chains.

00:32:43.180 --> 00:32:46.100
And you can see that I'm
all doing this in real time.

00:32:46.100 --> 00:32:49.000
And it's about picking what to do when.

00:32:49.160 --> 00:32:51.100
And then, of course,
because this is Core Image,

00:32:51.110 --> 00:32:54.100
I can pick another crazy
filter if I want to.

00:32:54.100 --> 00:32:57.100
So why not just distort the whole world?

00:32:57.100 --> 00:32:59.100
And I can just play with it.

00:32:59.120 --> 00:33:01.600
And this is just a few lines.

00:33:01.600 --> 00:33:07.440
So that's some of the fun things
things you can do with Core Image.

00:33:07.440 --> 00:33:07.440
Thank you.

00:33:11.300 --> 00:33:14.840
So as you saw, Jacques used a number of
Core Image filters to make

00:33:14.840 --> 00:33:16.280
some great cinematic effects.

00:33:16.280 --> 00:33:20.120
And what's interesting is first
this was done in a few days.

00:33:20.120 --> 00:33:24.930
It was done with very little art and did
a great job of conveying the idea that

00:33:24.930 --> 00:33:29.320
he wanted with some layering of these
simple effects on top of each other.

00:33:29.320 --> 00:33:32.050
And it would be, if you,
the alternative would have been

00:33:32.050 --> 00:33:35.360
either to build your own kind of
image processing kind of library,

00:33:35.360 --> 00:33:38.940
which is probably,
you don't want to do that.

00:33:38.940 --> 00:33:41.840
You want to use the tools that,
as Jacques said, you're given.

00:33:41.840 --> 00:33:43.790
And so using Core Image for that,
probably not a good

00:33:43.790 --> 00:33:44.880
choice to build your own.

00:33:44.880 --> 00:33:47.600
Or you could have done some,
a lot of effects in OpenGL.

00:33:47.600 --> 00:33:50.240
You could have done a lot of
post-processing effects yourself.

00:33:50.240 --> 00:33:53.650
And that, some of these effects really
are in the image space.

00:33:53.650 --> 00:33:56.790
And you should realize that
they're in the image space.

00:33:56.860 --> 00:33:59.080
So render your scene
like you want it to be.

00:33:59.080 --> 00:34:02.700
Whether it's a sprite-based
thing like a side scroller like

00:34:02.700 --> 00:34:06.820
Jacques has with Parallax or
whether it's a full 3D application.

00:34:07.140 --> 00:34:10.310
And then you can use Core Image to
apply those kind of effects

00:34:10.310 --> 00:34:11.460
on top of it in real time.

00:34:11.460 --> 00:34:15.940
These are kind of a list of some
of the filters that are available.

00:34:15.940 --> 00:34:18.740
And these are available on iOS and OS X.

00:34:18.740 --> 00:34:22.510
And an interesting note,
a trivia about that demo,

00:34:22.510 --> 00:34:26.200
that actually only used
six of these filter effects

00:34:26.200 --> 00:34:28.840
combined in different manners.

00:34:28.840 --> 00:34:33.000
So you can see that there's a lot,
almost infinite possibilities

00:34:33.100 --> 00:34:35.080
for you folks with your game.

00:34:35.080 --> 00:34:40.600
And we can't wait to see what kind
of things you can do with Core Image.

00:34:41.160 --> 00:34:42.300
So that's Core Image.

00:34:42.380 --> 00:34:45.940
Core Image is available for OS X,
available for iOS.

00:34:45.940 --> 00:34:50.500
It's a great use in post-processing,
using your rendering pipeline.

00:34:50.500 --> 00:34:53.980
Normally you would think about
it just used as kind of a

00:34:53.990 --> 00:34:56.820
photograph processing environment.

00:34:56.820 --> 00:34:59.640
We do use it on the iPhone
also for the auto-enhance,

00:34:59.770 --> 00:35:03.050
but it also can be used in real
time as a great thing to add depth,

00:35:03.050 --> 00:35:06.140
add complexity,
add visual presence to your game.

00:35:06.140 --> 00:35:07.310
Core Image.

00:35:09.300 --> 00:35:15.530
Yesterday, we announced the new
MacBook Pro with Retina display.

00:35:15.800 --> 00:35:17.840
It's a brilliant, brilliant screen.

00:35:17.840 --> 00:35:20.080
I hope all of you had a chance
to look at the ones out there.

00:35:20.080 --> 00:35:26.170
It is just absolutely stunning and
amazing to get that level of clarity.

00:35:26.180 --> 00:35:29.130
And we want to talk about kind of
using that in the game paradigm.

00:35:29.130 --> 00:35:34.010
So we now have Retina
displays across the products,

00:35:34.010 --> 00:35:36.970
across all of our platforms.

00:35:37.420 --> 00:35:41.480
and you can achieve
this level of fidelity.

00:35:41.480 --> 00:35:45.520
And actually,
this looks fantastic up here,

00:35:45.610 --> 00:35:49.940
but realize that this is
not the full actual pixel.

00:35:49.940 --> 00:35:53.540
We had to actually scale this down
significantly to get it onto the slide.

00:35:53.540 --> 00:35:55.450
So actually,
it looks even more clear when

00:35:55.780 --> 00:35:58.840
you're playing a game like
Diablo 3 with the retina display.

00:35:58.840 --> 00:36:03.340
So when you're developing for OS X,
keep in mind retina displays,

00:36:03.340 --> 00:36:06.080
even when you're developing for iOS,
keep in mind you have retina displays

00:36:06.080 --> 00:36:08.140
to really utilize that full fidelity.

00:36:08.140 --> 00:36:08.960
So how do you do that?

00:36:09.040 --> 00:36:10.840
Well, we've talked about iOS previously.

00:36:10.840 --> 00:36:12.560
Let's review for the Mac.

00:36:12.630 --> 00:36:15.190
We've done a lot of work
in the OS to help you out.

00:36:15.300 --> 00:36:18.640
So first thing is you have to
make sure your artwork matches

00:36:18.640 --> 00:36:20.540
the resolution for the display.

00:36:20.540 --> 00:36:25.690
This would be reminders that was
not updated for retina display,

00:36:25.690 --> 00:36:27.750
had pixelated artwork.

00:36:27.840 --> 00:36:27.840
And when you update it,
it's not going to be the same

00:36:27.840 --> 00:36:27.840
resolution as the display.

00:36:27.840 --> 00:36:27.840
So you have to make sure that
you're not using the same

00:36:27.840 --> 00:36:27.840
resolution for the display.

00:36:27.840 --> 00:36:27.840
So if you're using the same
resolution for the display,

00:36:27.840 --> 00:36:27.840
you're not using the same
resolution for the display.

00:36:27.840 --> 00:36:27.840
So if you're using the same
resolution for the display,

00:36:27.840 --> 00:36:27.840
you're not using the same
resolution for the display.

00:36:27.870 --> 00:36:30.620
And when you update it,
it looks brilliant.

00:36:30.800 --> 00:36:32.300
We take care of a lot of this for you.

00:36:32.300 --> 00:36:35.680
Anything up there that's a system font,
we're going to do that for you.

00:36:35.750 --> 00:36:39.020
Anything up there that's
the system controls,

00:36:39.290 --> 00:36:42.440
we also will-- that artwork
is already in high res,

00:36:42.510 --> 00:36:43.880
already up res-ed for you.

00:36:44.090 --> 00:36:44.780
That's not a problem.

00:36:44.780 --> 00:36:47.340
So the only thing you have to
do is supply the pieces that are

00:36:47.340 --> 00:36:48.640
actually in your application.

00:36:48.640 --> 00:36:51.010
I supply the artwork
for those for that step.

00:36:51.140 --> 00:36:54.640
The second out of these four steps
is opt into high resolution OpenGL.

00:36:54.730 --> 00:36:56.950
So you said you want
best resolution OpenGL,

00:36:57.280 --> 00:37:02.240
and also as a second step,
make sure that you convert the bounds to

00:37:02.300 --> 00:37:04.980
pixels and provide that in GL viewport.

00:37:04.980 --> 00:37:07.260
And you see this convert rec to backing.

00:37:07.400 --> 00:37:08.400
And that is a routine.

00:37:08.400 --> 00:37:10.310
There's a family of those routines.

00:37:10.410 --> 00:37:13.190
And it's really important to understand
those and use those properly.

00:37:13.490 --> 00:37:16.900
Because in this case, the GL viewport,
of course, OpenGL pixel based.

00:37:17.060 --> 00:37:18.920
GL viewport takes your pixels.

00:37:19.240 --> 00:37:21.490
And the self-balance is in points.

00:37:21.630 --> 00:37:22.800
So you do that conversion.

00:37:22.900 --> 00:37:23.840
It gets the right thing.

00:37:23.840 --> 00:37:25.820
You have a viewport that
spans the entire screen.

00:37:27.750 --> 00:37:29.690
Eliminate deprecated API.

00:37:29.690 --> 00:37:31.820
If you're using Quick Draw, move away.

00:37:31.830 --> 00:37:32.630
Move off of it.

00:37:32.640 --> 00:37:34.090
NS MovieView, great.

00:37:34.090 --> 00:37:38.370
A number of years ago, right now,
it does not understand how to

00:37:38.370 --> 00:37:40.440
do high-resolution graphics.

00:37:40.520 --> 00:37:42.880
Quick Draw does not
understand retina displays.

00:37:42.880 --> 00:37:45.140
So get off of these deprecated APIs.

00:37:45.140 --> 00:37:48.080
And I'm not talking about APIs that
you're guessing at being deprecated.

00:37:48.080 --> 00:37:50.380
I'm talking about the ones that
actually are marked deprecated.

00:37:50.380 --> 00:37:54.820
So you should be able to tell in
the latest SDKs the deprecated API.

00:37:55.020 --> 00:37:56.510
Move on to the modern equivalents.

00:37:56.580 --> 00:37:58.200
Many times, we'll point you to a new API.

00:37:58.200 --> 00:38:00.670
Move to those, and you'll be doing great.

00:38:00.700 --> 00:38:05.360
And finally, as I alluded to,
do correct use of pixels and points.

00:38:05.360 --> 00:38:08.420
For example, in this case,
you get the size of the image in pixels.

00:38:08.420 --> 00:38:13.250
You want to actually pass it
to the initCG image in points.

00:38:13.260 --> 00:38:15.800
So what we need to do is you need
to convert size from backing.

00:38:15.800 --> 00:38:18.460
In other words, conversion routines,
that family of conversion routines.

00:38:18.460 --> 00:38:22.040
So realize when you have to
convert points and pixels.

00:38:22.440 --> 00:38:24.580
And if you notice,
the sizes in points and size

00:38:24.670 --> 00:38:26.340
came out of CG image in pixels.

00:38:26.340 --> 00:38:29.120
So understand what your routines take
in and what your routines put out.

00:38:29.140 --> 00:38:31.340
Straightforward,
just make sure you get that math right.

00:38:31.340 --> 00:38:33.910
It should be fairly clear when you don't.

00:38:33.930 --> 00:38:35.530
You'll get either fuzzy images,
or you'll get things that

00:38:35.540 --> 00:38:36.310
aren't the right size.

00:38:36.320 --> 00:38:39.200
You'll get quarter-sized
images of pieces.

00:38:39.200 --> 00:38:41.570
So it should be fairly clear as
you walk through your application.

00:38:43.280 --> 00:38:50.150
So that's talking about retina displays
from a standpoint of the mechanics of it.

00:38:50.550 --> 00:38:53.480
But as I spoke of before,
one thing we wanted to talk

00:38:53.480 --> 00:38:57.500
about is moving to the future of
the graphics and display pipes

00:38:57.500 --> 00:38:59.020
and how to think about this.

00:38:59.110 --> 00:39:03.580
So a number of years ago, we had CRTs,
and it was fairly easy

00:39:03.580 --> 00:39:06.340
to scale performance,
especially when you're drawing with

00:39:06.350 --> 00:39:10.660
a CPU and your CPU has a limited
ability to fill pixels and minimally

00:39:10.670 --> 00:39:15.530
accelerated graphics card that you
provide the user with a switch that

00:39:15.530 --> 00:39:18.410
would allow them to pick resolutions.

00:39:18.420 --> 00:39:22.450
I remember my, what game was it?

00:39:22.590 --> 00:39:26.800
It was a very old Bungie game that
I had a friend who was great at it.

00:39:26.860 --> 00:39:29.000
And he played the game in
literally like a one-time game.

00:39:29.020 --> 00:39:31.860
And he had a one-inch by one-inch
window to get the frame rate out of it.

00:39:31.880 --> 00:39:36.330
That shouldn't be something today that
we're letting users trying to figure out.

00:39:36.340 --> 00:39:39.060
A user should not be going, well,
how big do I need to make my

00:39:39.060 --> 00:39:40.860
screen to play this game properly?

00:39:40.860 --> 00:39:44.910
You have enough facilities with
the APIs we give you to render

00:39:44.910 --> 00:39:48.440
the game at a reasonable size,
understand what the frame rate is,

00:39:48.440 --> 00:39:50.960
scale that to different
performance and different machines,

00:39:50.970 --> 00:39:51.980
and fill the screen.

00:39:51.980 --> 00:39:54.770
So leave the screen as native resolution.

00:39:54.780 --> 00:39:58.980
Render the screen at an
appropriate resolution.

00:39:59.020 --> 00:40:00.340
To get the performance you need.

00:40:00.340 --> 00:40:01.340
You have a few choices here.

00:40:01.340 --> 00:40:03.620
First,
if you can render at retina resolution,

00:40:03.620 --> 00:40:04.860
fantastic, do it.

00:40:04.920 --> 00:40:07.720
Go to full retina resolution,
whatever the platform you're on,

00:40:07.720 --> 00:40:10.010
render it at that
brilliantly sharp resolution.

00:40:10.020 --> 00:40:12.420
Give the player pixel
for pixel in your game.

00:40:12.420 --> 00:40:15.460
If you can't though,
you can always decide to render to

00:40:15.520 --> 00:40:17.340
a smaller buffer in the background.

00:40:17.430 --> 00:40:20.190
So you render to a smaller buffer and
that scales to the screen and will

00:40:20.200 --> 00:40:22.020
scale the fit with bilinear scaling.

00:40:22.020 --> 00:40:25.620
And it turns out that in many cases,
if you're rendering above,

00:40:25.620 --> 00:40:28.120
somewhere between that quarter
size and the full size retina,

00:40:28.120 --> 00:40:28.850
there's a sweet spot.

00:40:29.000 --> 00:40:29.760
There's a good spot for you.

00:40:29.820 --> 00:40:32.460
Where effectively you're doing
much less pixel processing,

00:40:32.460 --> 00:40:36.750
but the output looks very similar,
very close to that native retina.

00:40:36.760 --> 00:40:38.940
Not quite the same,
but it's very close and the

00:40:38.940 --> 00:40:40.450
trade off for you is really good.

00:40:40.710 --> 00:40:44.090
So again, if you're pixel bound,
your GPU cannot drive the number

00:40:44.090 --> 00:40:47.580
of pixels you have on your screen,
you want to scale that resolution,

00:40:47.580 --> 00:40:50.730
reduce the number of pixels,
and then you'll be able

00:40:50.730 --> 00:40:52.000
to up that frame rate.

00:40:52.220 --> 00:40:56.480
A good test for this is if you scale
your backing store to be smaller

00:40:57.000 --> 00:40:58.650
and your frame rate doesn't change.

00:40:58.870 --> 00:41:01.680
That probably means, probably means,
unless you've done some

00:41:01.680 --> 00:41:05.040
strange things in your code,
but probably means you're not pixel

00:41:05.040 --> 00:41:08.320
bound and that something else in your
application is limiting the frame rate.

00:41:08.480 --> 00:41:10.230
So that's something you should test
before you start playing around

00:41:10.400 --> 00:41:12.420
with scaling and assuming that it's
going to do something in your app.

00:41:12.420 --> 00:41:14.950
Make sure you're actually pixel bound.

00:41:15.230 --> 00:41:18.800
And finally, as we talked about,
there's this post processing paradigm.

00:41:19.100 --> 00:41:22.690
Make your game have a lot of
visual value for the user.

00:41:22.940 --> 00:41:24.520
So in this case, render to texture.

00:41:24.520 --> 00:41:26.780
You render to a texture,
you can decide what size that is,

00:41:26.970 --> 00:41:28.720
and then you add a
filter onto the texture.

00:41:28.720 --> 00:41:31.160
You can add a filter onto
the back of that and put that

00:41:31.160 --> 00:41:32.710
out to the final resolution.

00:41:32.720 --> 00:41:34.720
You can do a lot of
different things there.

00:41:34.720 --> 00:41:36.710
You want to optimize your app
for great user experience.

00:41:36.720 --> 00:41:38.470
You don't want to have the user,
the person effectively

00:41:38.470 --> 00:41:40.720
administrating the system trying
to figure out what resolution.

00:41:40.720 --> 00:41:44.720
You don't want to come up in 1024 by 768,
because that's what

00:41:44.720 --> 00:41:44.720
you've done for 12 years.

00:41:44.720 --> 00:41:48.710
You want to come up using the
full resolution available,

00:41:48.710 --> 00:41:50.780
make your game brilliant,
make them love your game,

00:41:50.780 --> 00:41:52.830
so when the new player picks it up,
the first thing they see is

00:41:52.830 --> 00:41:54.720
something that just looks awesome.

00:41:54.720 --> 00:41:58.620
It's not, oh, choose a resolution.

00:41:58.620 --> 00:41:59.850
I don't know what resolution I got,
so I'll just pick one,

00:41:59.850 --> 00:42:00.490
and they may get stuck there.

00:42:00.630 --> 00:42:02.610
So think about that
from a user experience.

00:42:02.620 --> 00:42:06.620
Leave the display in native mode,
render your content to the right size,

00:42:06.620 --> 00:42:08.620
and your users will be
much happier for it,

00:42:08.620 --> 00:42:10.620
and they'll have a great,
great experience.

00:42:10.620 --> 00:42:12.520
So that was Retina Display.

00:42:14.190 --> 00:42:16.340
So the final thing I want to
talk about is graphics tools.

00:42:16.340 --> 00:42:18.090
We talked about being pixel bound.

00:42:18.140 --> 00:42:21.270
The previous discussion of dev
tools showed some of the graphics

00:42:21.450 --> 00:42:23.940
tools and showed some of the
great tools we have for OpenGL ES.

00:42:23.940 --> 00:42:25.980
We have three fantastic tools.

00:42:25.980 --> 00:42:28.240
We introduced them last year
and we continue to improve them.

00:42:28.240 --> 00:42:30.880
We have the
OpenGL ES Performance Detective.

00:42:30.880 --> 00:42:34.680
That gives you that high-level,
really quick view, very actionable,

00:42:34.680 --> 00:42:37.240
what you can do to improve
the performance of your

00:42:37.240 --> 00:42:39.140
graphics in your application.

00:42:40.040 --> 00:42:43.660
The second tool we provide is the
OpenGL ES Analyzer instrument.

00:42:43.670 --> 00:42:47.370
This hooks into instruments and
gives you that under-the-covers,

00:42:47.370 --> 00:42:51.780
in-depth look at what the GPU is doing,
exactly what's happening on the system,

00:42:51.780 --> 00:42:55.080
and so you can figure out
where your bottlenecks are.

00:42:55.080 --> 00:42:58.060
This is that really,
let's pull the covers off, look inside,

00:42:58.120 --> 00:42:59.440
and see what's going on.

00:43:01.660 --> 00:43:03.060
and the OpenGL ES Debugger.

00:43:03.100 --> 00:43:04.730
The ES Debugger is brilliant.

00:43:04.730 --> 00:43:06.800
It's an absolutely brilliant tool.

00:43:06.800 --> 00:43:11.140
It allows you to introspect
a frame of your application.

00:43:11.140 --> 00:43:13.590
It allows you to tear it apart,
look down to the minutest

00:43:13.720 --> 00:43:16.400
detail of OpenGL state,
what exactly the commands

00:43:16.400 --> 00:43:19.020
that are being issued,
exactly how all the objects

00:43:19.020 --> 00:43:22.280
in your scene are being drawn,
and allows you to really,

00:43:22.280 --> 00:43:27.570
really kind of dissect your graphics
and understand where your problems are,

00:43:27.580 --> 00:43:28.900
where your performance issues are.

00:43:29.240 --> 00:43:32.180
And now we've added some things to
it that it really also works as a

00:43:32.180 --> 00:43:35.620
great development tool to you to
work as you develop your shaders

00:43:35.620 --> 00:43:36.760
and modify your applications.

00:43:36.760 --> 00:43:41.540
And all these are built
into the Xcode environment.

00:43:41.540 --> 00:43:43.160
Let's talk about some new things.

00:43:43.220 --> 00:43:46.110
Like I alluded to, shaders.

00:43:46.180 --> 00:43:48.280
Shader edit and continue.

00:43:48.280 --> 00:43:50.000
Fantastic feature.

00:43:50.000 --> 00:43:51.940
So you have a shader that's doing
something in your application

00:43:52.000 --> 00:43:52.970
and you want to change it.

00:43:52.980 --> 00:43:53.820
You want to modify it.

00:43:53.820 --> 00:43:55.400
You want to change the color blending.

00:43:55.400 --> 00:43:57.900
You want to change how
much contrast is in there.

00:43:57.980 --> 00:44:01.700
You want to change how it handles the
vertices or how it handles fragments.

00:44:01.700 --> 00:44:04.980
You can do that inside of the debugger.

00:44:05.000 --> 00:44:08.340
So you don't have to come out,
rewrite it, recompile, rerun.

00:44:08.340 --> 00:44:09.620
Write it, recompile, rerun.

00:44:09.620 --> 00:44:10.310
We've all done that.

00:44:10.530 --> 00:44:12.820
It's not a great way to debug.

00:44:12.820 --> 00:44:13.460
This is great.

00:44:13.460 --> 00:44:14.050
You can fix it.

00:44:14.220 --> 00:44:14.890
You can change it.

00:44:14.900 --> 00:44:16.320
You can fix problems, edit, and continue.

00:44:23.110 --> 00:44:25.240
We have an integrated OpenGL ES expert.

00:44:25.240 --> 00:44:28.650
In this case, you have this expert panel,
and I'll show this in

00:44:28.740 --> 00:44:29.960
action in a little bit.

00:44:29.970 --> 00:44:32.450
And it really looks
after your application.

00:44:32.470 --> 00:44:36.740
It's kind of the nanny
behind you that says,

00:44:36.810 --> 00:44:38.680
hey, by the way, look at that.

00:44:38.710 --> 00:44:40.060
You have a redundant call.

00:44:40.060 --> 00:44:42.570
You've called GL viewport
with the same coordinates.

00:44:42.580 --> 00:44:44.060
So you're wasting your time.

00:44:44.060 --> 00:44:46.130
And this is good for
redundant state changes.

00:44:46.130 --> 00:44:47.360
It's good for GL errors.

00:44:47.360 --> 00:44:51.220
It's good for a lot of the
common mistakes in OpenGL.

00:44:51.220 --> 00:44:53.950
And every time you run your application,
you can bring it up.

00:44:53.950 --> 00:44:56.070
It's right there to
maintain your application,

00:44:56.100 --> 00:44:57.080
make sure it's really clean.

00:44:59.120 --> 00:45:01.100
We have save and load captured frames.

00:45:01.100 --> 00:45:04.760
In this case, you find a frame,
you find a problem in your,

00:45:04.760 --> 00:45:06.310
you have an artist or
something like that,

00:45:06.310 --> 00:45:09.060
you have someone who's doing some of
the scripting and they find a problem,

00:45:09.060 --> 00:45:12.010
they can use the X code,
they can run the frame to the problem,

00:45:12.010 --> 00:45:15.340
they can stop and capture it,
and then they can capture that frame

00:45:15.340 --> 00:45:19.040
and send it off to their OpenGL expert
to debug exactly what's going on.

00:45:19.040 --> 00:45:22.260
This is a fantastic debugging tool,
especially with more than one person,

00:45:22.280 --> 00:45:24.840
or if you don't have time right now,
you saw a problem,

00:45:24.840 --> 00:45:28.240
you wanted to capture the frame,
you capture it, let's look at it later,

00:45:28.240 --> 00:45:30.600
let's fix it a little bit later,
so you can do that.

00:45:30.600 --> 00:45:33.500
It's great for save and
load captured frames.

00:45:35.230 --> 00:45:36.390
Integrated Performance Detective.

00:45:36.390 --> 00:45:39.480
As I talked about, the DevTools section,
we have this Integrated

00:45:39.530 --> 00:45:40.760
Performance Detective right in there.

00:45:40.760 --> 00:45:43.920
It gives you that high-level view of
what's going on with your application,

00:45:44.010 --> 00:45:47.180
very actionable items,
and it's now integrated right into Xcode.

00:45:47.180 --> 00:45:48.890
And we put a ton of time into that.

00:45:48.910 --> 00:45:51.610
And of course, the tools are faster,
they're more accurate,

00:45:51.610 --> 00:45:53.080
and they give you more detail.

00:45:53.080 --> 00:45:56.480
The team has done a fantastic
job building brilliant tools,

00:45:56.480 --> 00:46:00.350
and so let's take a look at the tools
and see what we can do with them.

00:46:02.020 --> 00:46:06.900
This is a project we created to show
off some graphics technologies here.

00:46:08.300 --> 00:46:12.900
Let's hide that out of the
way and we'll close that one.

00:46:12.970 --> 00:46:17.000
So we have our application and
we're going to just run the app.

00:46:17.000 --> 00:46:20.710
We're going to compile here
and we have our laptop.

00:46:20.800 --> 00:46:23.580
We're all good, or not laptop, our iPad.

00:46:23.580 --> 00:46:27.690
And we're going to switch to
the iPad and see what we get.

00:46:31.310 --> 00:46:36.360
So we have this fantastic simulation
of this temple with some lights.

00:46:36.430 --> 00:46:39.220
And it looks great,
but I do notice in this

00:46:39.310 --> 00:46:40.540
that something is missing.

00:46:40.540 --> 00:46:43.440
The lights inside, you can see they're
reflecting on the surfaces,

00:46:43.440 --> 00:46:45.400
but there's nothing casting the light.

00:46:45.520 --> 00:46:47.820
So we've modified this,
we've played with it,

00:46:47.820 --> 00:46:49.360
and we don't really know what's going on.

00:46:49.620 --> 00:46:52.160
So let's jump into the debugger
and actually try and figure

00:46:52.160 --> 00:46:53.890
out what the problem is.

00:46:53.970 --> 00:46:56.410
We're going to go back
to the primary here.

00:46:56.930 --> 00:47:00.100
We see this little
camera icon right here.

00:47:00.100 --> 00:47:01.740
So we're going to hit that camera icon.

00:47:01.740 --> 00:47:04.180
And what it's doing,
if you look at the top,

00:47:04.240 --> 00:47:07.190
it's capturing OpenGL ES frame
is what it says right up here

00:47:07.190 --> 00:47:08.880
at the very top of the screen.

00:47:08.880 --> 00:47:12.820
And so we're going to
let it capture the frame.

00:47:12.820 --> 00:47:14.910
It paused the application.

00:47:15.070 --> 00:47:18.930
It grabs all the OpenGL calls
and puts them into this kind

00:47:18.930 --> 00:47:21.260
of introspection area here.

00:47:21.260 --> 00:47:24.010
And so let's take a little tour of
this so you can see all the pieces.

00:47:24.080 --> 00:47:26.260
Some of this is hard to
read at this resolution.

00:47:26.900 --> 00:47:30.090
So I'm going to talk through
what some of the areas are.

00:47:30.090 --> 00:47:32.100
On the side over here,
it says light prepass.

00:47:32.100 --> 00:47:35.380
It has that frames per second meter
that the dev tools folks talked about.

00:47:35.380 --> 00:47:36.800
You have your rendering commands.

00:47:36.800 --> 00:47:40.080
If you notice,
this says like GL push group marker.

00:47:40.420 --> 00:47:43.260
This is GL enable, GL enable,
GL blend funk.

00:47:43.300 --> 00:47:45.350
So these are all the OpenGL commands.

00:47:45.360 --> 00:47:49.670
Every single OpenGL commands with
the parameters that were passed

00:47:49.670 --> 00:47:51.720
into it to render this frame.

00:47:51.720 --> 00:47:55.790
So you can completely introspect
exactly how the single frame was built.

00:47:56.900 --> 00:48:00.630
You have at the bottom down here,
the bottom area, you have a GL context.

00:48:00.760 --> 00:48:03.510
So if I look at GL viewport,
it gives me the information

00:48:03.510 --> 00:48:04.610
in the GL viewport.

00:48:04.750 --> 00:48:06.880
It gives me the active texture unit.

00:48:06.880 --> 00:48:09.800
All the things that you would expect
in OpenGL state is portrayed here.

00:48:09.800 --> 00:48:11.840
So when you stop it,
you can say what was my state?

00:48:11.840 --> 00:48:13.140
Did I have blending turned on?

00:48:13.140 --> 00:48:14.910
Where were the texture units set?

00:48:14.920 --> 00:48:18.330
And finally, over in this section,
you have the GL objects.

00:48:18.420 --> 00:48:24.670
And so these GL objects are the active
objects right now for the frame.

00:48:24.680 --> 00:48:24.740
So that's the main thing.

00:48:25.050 --> 00:48:26.760
Another interesting thing to
look at is the GL objects.

00:48:26.790 --> 00:48:26.880
And so these GL objects are the active
objects right now for the frame.

00:48:26.900 --> 00:48:29.560
So this is the final frame of the scene.

00:48:29.560 --> 00:48:30.280
That's okay.

00:48:30.280 --> 00:48:31.480
I mean,
that tells you what it looks like.

00:48:31.650 --> 00:48:33.750
But let's say you wanted to
look at an earlier kind of point

00:48:33.760 --> 00:48:34.940
as you put the scene together.

00:48:34.940 --> 00:48:36.040
So we're going to go back to here.

00:48:36.040 --> 00:48:39.600
And what you see here
is on the right side,

00:48:39.600 --> 00:48:41.400
you see a partially rendered frame.

00:48:41.400 --> 00:48:42.580
You see a depth buffer.

00:48:42.580 --> 00:48:44.260
And then you see an empty stencil buffer.

00:48:44.340 --> 00:48:46.170
Let's go way back in time, so to speak.

00:48:46.330 --> 00:48:48.980
And you can see how the frame
is actually being rendered here.

00:48:48.980 --> 00:48:52.490
We're actually rendering
the temple itself.

00:48:52.950 --> 00:48:56.660
And I can hide the wireframe.

00:48:56.780 --> 00:48:59.450
And you can see that's the actual temple.

00:49:00.100 --> 00:49:02.860
If we move forward a little bit,
you can see even more.

00:49:02.860 --> 00:49:05.720
We'll hide the wireframe here,
and you can see we've rendered

00:49:05.720 --> 00:49:09.980
the tree in the temple for
the part of the lighting pass.

00:49:10.060 --> 00:49:11.920
So what was our problem
we were looking at?

00:49:11.960 --> 00:49:14.680
The problem we were looking
at is as you see this frame,

00:49:14.770 --> 00:49:17.810
you see lighting on the structure
but no lights casting it.

00:49:17.860 --> 00:49:22.100
So we're going to use the
integrated issue detective,

00:49:22.100 --> 00:49:24.720
and of course we have tooltips.

00:49:24.840 --> 00:49:26.880
The issue navigator here,
we'll click on it.

00:49:27.340 --> 00:49:30.300
And if you look on the issue navigator,
what we see here is there's

00:49:30.300 --> 00:49:31.510
two errors called out.

00:49:31.540 --> 00:49:34.560
And it turns out that our debugging
tools will call GL error on

00:49:34.720 --> 00:49:37.760
the end of every call of yours,
and will capture those errors for you so

00:49:37.760 --> 00:49:39.560
you can actually see what the errors are.

00:49:39.560 --> 00:49:42.170
Let's click on an error
and see what it says.

00:49:42.200 --> 00:49:45.430
So what it's saying here
is for this GL depth thunk,

00:49:45.450 --> 00:49:48.920
an enumerated argument
with unacceptable value.

00:49:48.920 --> 00:49:51.620
Well, I know that GL depth thunk
can't take a GL false,

00:49:51.650 --> 00:49:54.290
so maybe I should change that,
but I don't think that's

00:49:54.340 --> 00:49:55.580
what they intended.

00:49:55.580 --> 00:49:58.720
I think they actually intended
to... to put depth mask in here

00:49:58.810 --> 00:50:00.720
because depth mask can take false.

00:50:00.720 --> 00:50:02.720
So we'll put depth mask.

00:50:02.720 --> 00:50:05.900
And this other one down here,
the second one, has the same problem.

00:50:05.900 --> 00:50:07.930
We'll put depth mask.

00:50:09.590 --> 00:50:13.660
And let's stop the program,
let's run it again.

00:50:13.660 --> 00:50:15.800
And we can switch back
to the iPad as it builds.

00:50:15.930 --> 00:50:17.920
So we built, we succeeded,
it looks pretty good.

00:50:17.920 --> 00:50:21.400
And we'll see if we actually
get the lights as we expected.

00:50:23.240 --> 00:50:24.130
Perfect.

00:50:24.150 --> 00:50:27.670
So that was using the debugger
to find a GL error in your

00:50:27.670 --> 00:50:29.630
application that may have,
as you coded it up or

00:50:29.630 --> 00:50:31.530
as you're changing code,
you may have missed it.

00:50:31.680 --> 00:50:33.720
It now shows the full
simulation with the lights.

00:50:33.800 --> 00:50:35.290
The simulation's beautiful.

00:50:35.290 --> 00:50:37.350
They did a great job
with this image effect,

00:50:37.350 --> 00:50:38.580
this lighting effect.

00:50:41.100 --> 00:50:43.100
So, game technologies.

00:50:43.180 --> 00:50:47.880
We have sessions all week on all kinds
of different game technologies from media

00:50:47.880 --> 00:50:50.060
to graphics to tools to Game Center.

00:50:50.060 --> 00:50:52.720
Look on your schedule,
go to those technologies.

00:50:52.720 --> 00:50:54.000
Thank you very much.

00:50:54.000 --> 00:50:55.600
Have a great conference.
WEBVTT

00:00:10.710 --> 00:00:11.600
Good afternoon.

00:00:11.640 --> 00:00:15.190
Welcome to session 226,
Core Text and Fonts.

00:00:15.290 --> 00:00:16.150
My name is Ned Holbrook.

00:00:16.240 --> 00:00:18.590
I'll be your tour guide
for this afternoon.

00:00:18.720 --> 00:00:20.760
We've got quite a few
things to speak about,

00:00:20.970 --> 00:00:22.500
so let's get started.

00:00:22.500 --> 00:00:26.560
So we're going to be discussing a
number of things this afternoon.

00:00:26.560 --> 00:00:29.870
First of all,
we're going to be discussing new

00:00:29.880 --> 00:00:34.420
features provided by Core Text in
Mountain Lion and iOS 6.

00:00:35.020 --> 00:00:38.570
The two big ones are a new
API for accessing line bounds,

00:00:38.570 --> 00:00:42.270
and we're going to be
discussing baseline alignment.

00:00:42.750 --> 00:00:46.170
We're also going to be touching on
a number of individual techniques.

00:00:46.350 --> 00:00:49.280
We'll be giving a quick
overview of vertical text.

00:00:49.350 --> 00:00:51.930
We'll be talking about
a number of font topics.

00:00:52.040 --> 00:00:54.940
And along the way,
we'll also be mentioning some

00:00:54.940 --> 00:00:59.210
advice for you to keep in mind
while working with Core Text in

00:00:59.300 --> 00:01:02.090
order to avoid any common pitfalls.

00:01:03.500 --> 00:02:52.800
[Transcript missing]

00:02:53.190 --> 00:02:59.150
I'd like to call your attention
especially to UIKit as in iOS 6,

00:02:59.150 --> 00:03:04.490
UIKit now offers some really great
support for attributed strings.

00:03:04.620 --> 00:03:08.860
So the reason I call this out is
because there might be some people

00:03:08.860 --> 00:03:12.740
in this room who are looking at
Core Text because previously there

00:03:12.740 --> 00:03:18.070
was no real UIKit level mechanism
for dealing with attributed strings.

00:03:18.100 --> 00:03:22.040
And so we're really delighted
to have that available in iOS 6.

00:03:22.150 --> 00:03:24.500
And so if you're here
just because of that,

00:03:24.630 --> 00:03:29.100
then I encourage you to check out the
UIKit sessions on attributed strings.

00:03:29.100 --> 00:03:32.390
There was one just now that
you can catch on video later,

00:03:32.390 --> 00:03:33.100
I'm sure.

00:03:33.100 --> 00:03:35.900
And there will be another
advanced session tomorrow,

00:03:35.900 --> 00:03:38.100
so you can check your schedule for that.

00:03:38.100 --> 00:03:42.210
And of course,
Core Text is the heart of complex

00:03:42.210 --> 00:03:45.000
text layout on WebKit as well.

00:03:45.100 --> 00:03:47.100
So this talk assumes that we're
going to be talking about the

00:03:47.100 --> 00:03:47.100
core text of complex text layout.

00:03:47.100 --> 00:03:50.030
This talk assumes that you
have used Core Text before.

00:03:50.140 --> 00:03:52.060
We're going to be talking
specifically about Core Text.

00:03:52.100 --> 00:03:56.050
But again, if you're not comfortable
dealing with it directly,

00:03:56.080 --> 00:03:59.100
then please talk to our
hair level framework.

00:03:59.590 --> 00:04:04.590
Core Text has been available in
OS X since Leopard and iOS 3.2.

00:04:04.710 --> 00:04:07.310
Basically what that means is that
if you're targeting any sort of

00:04:07.430 --> 00:04:10.980
modern platform at this point,
Core Text will be there.

00:04:11.090 --> 00:04:13.730
Core Text itself is a
top-level framework on iOS,

00:04:13.810 --> 00:04:16.600
meaning it lives in
system library frameworks,

00:04:16.600 --> 00:04:18.530
and that's where you link to it.

00:04:18.660 --> 00:04:20.600
And also on Mountain Lion.

00:04:20.690 --> 00:04:25.100
So previous to Mountain Lion,
Core Text was a part of the application

00:04:25.100 --> 00:04:27.720
services umbrella framework,
which meant that in

00:04:27.720 --> 00:04:31.090
order to use Core Text,
you had to link to application services.

00:04:31.190 --> 00:04:35.240
But as I mentioned on Mountain Lion,
it is now also a top-level framework.

00:04:35.530 --> 00:04:38.600
So your existing code will
continue to function just fine,

00:04:38.740 --> 00:04:41.350
but for new OS X projects,
we encourage you to go ahead

00:04:41.350 --> 00:04:45.890
and link to Core Text directly
in system library frameworks.

00:04:48.150 --> 00:04:52.910
I'd be remiss if I didn't point out
that atsui and ATS for text layout

00:04:52.950 --> 00:04:57.590
and font management on OS X are
still incredibly deprecated.

00:04:57.740 --> 00:05:02.570
So if you have any legacy code that is
still using either of these frameworks,

00:05:02.710 --> 00:05:07.160
now is definitely the time
to plan your exit strategy.

00:05:07.350 --> 00:05:10.910
And so in particular,
some ATS functionality has

00:05:10.910 --> 00:05:14.700
only relatively recently
been moved into Core Text.

00:05:14.830 --> 00:05:19.100
So if you were kind of on the
edge there with making the move,

00:05:19.200 --> 00:05:21.400
we think everything is
in place for you now.

00:05:21.400 --> 00:05:24.100
So if you have any questions
about making that transition,

00:05:24.100 --> 00:05:30.080
please come see us at our lab tomorrow,
and we'd be glad to help you with that.

00:05:31.800 --> 00:05:35.550
So the text nerd in me is very
excited to be able to talk

00:05:35.610 --> 00:05:38.990
about some of our new features.

00:05:41.510 --> 00:05:47.740
So this first slide is one
of a number on line bounds.

00:05:47.890 --> 00:05:53.440
So when I say line bounds,
so of course Core Text takes an

00:05:53.440 --> 00:06:00.350
attributed string as input and gives
you a line with positioned glyphs and

00:06:00.350 --> 00:06:01.760
all the relevant style information.

00:06:01.760 --> 00:06:06.370
And when I say line bounds,
I mean the measurements

00:06:06.370 --> 00:06:11.300
that pertain to that CT line
object as it's been laid out.

00:06:11.440 --> 00:06:15.360
So these are the measurements
or metrics we sometimes call

00:06:15.360 --> 00:06:16.800
them for that laid out line.

00:06:16.800 --> 00:06:21.320
What I've done in this slide
is I've taken the results

00:06:21.320 --> 00:06:26.800
of calling an existing API,
CT line get typographic bounds,

00:06:26.800 --> 00:06:31.730
on this attributed string where I've
set this text using the Heffler text.

00:06:31.740 --> 00:06:34.190
text font.

00:06:34.530 --> 00:06:48.470
: And what I've done is I've
constructed a bit of a diagram

00:06:48.470 --> 00:06:48.470
showing what those values represent.

00:06:48.470 --> 00:06:48.470
And so, of course,
the width of this rectangle would

00:06:48.470 --> 00:06:48.470
be the width as returned by the API.

00:06:48.470 --> 00:06:48.470
The

00:06:49.190 --> 00:06:53.100
In the lower left, near the lower left,
there's sort of an orange blob

00:06:53.100 --> 00:06:55.600
which indicates the line origin.

00:06:55.600 --> 00:07:00.650
That's kind of a reference point for all
the measurements in this particular line.

00:07:00.750 --> 00:07:03.710
And then for this slide,
I've also indicated the

00:07:03.830 --> 00:07:06.110
baseline on which the text sits.

00:07:06.200 --> 00:07:10.230
So basically it's y equals
zero across the line there.

00:07:10.340 --> 00:07:13.830
And so of course the amount of
the box below the baseline is

00:07:13.830 --> 00:07:18.940
the descent and the amount above
would be the ascent of the line.

00:07:19.020 --> 00:07:22.740
And one thing to note about this
particular example is that the

00:07:22.790 --> 00:07:26.690
way the font is constructed,
you'll note that there's

00:07:26.780 --> 00:07:28.880
not quite enough room here.

00:07:29.040 --> 00:07:33.290
So this is kind of a way that
some older fonts were constructed,

00:07:33.330 --> 00:07:39.740
but imagine if this line had an
accent above the capital letter here,

00:07:39.800 --> 00:07:42.260
or one of these other
letters with a sender.

00:07:42.360 --> 00:07:46.060
And there would be no room
for it in the line bounds.

00:07:46.270 --> 00:07:50.880
And so I call this out because
internally what Cortex has done

00:07:50.880 --> 00:07:54.890
in the past when you're filling
a frame using CTFramesetter,

00:07:55.280 --> 00:08:00.250
Core Text has applied an adjustment
factor in order to pad out the lines to

00:08:00.310 --> 00:08:04.000
give space for those accented capital
letters because they're incredibly

00:08:04.000 --> 00:08:07.200
common in other Latin-based languages.

00:08:07.290 --> 00:08:09.190
So not English,
you probably wouldn't see many,

00:08:09.190 --> 00:08:11.200
but for other languages
you certainly would.

00:08:11.200 --> 00:08:14.240
And so we need to provide that
room so that the text won't

00:08:14.330 --> 00:08:18.300
regularly be falling outside of
the frame that you've supplied.

00:08:19.950 --> 00:08:23.880
So now, instead,
I'd like to call a new API.

00:08:23.880 --> 00:08:26.240
This is available in
Mountain Lion and iOS 6,

00:08:26.250 --> 00:08:29.010
ctline-get-bounds-with-options.

00:08:29.490 --> 00:08:32.440
So right now I'm calling this
particular API with no options,

00:08:32.440 --> 00:08:34.240
that's the zero.

00:08:34.290 --> 00:08:36.760
I'll be touching on some
options in just a moment.

00:08:36.810 --> 00:08:42.410
But the one thing that I hope you'll note
is that compared to the previous results,

00:08:42.410 --> 00:08:44.200
there's two things.

00:08:44.200 --> 00:08:46.500
One is that the result you
can't see on the slide,

00:08:46.500 --> 00:08:50.610
but it is actually returned as simply
a CG rectangle or CG rect since it's

00:08:50.610 --> 00:08:53.860
generally a lot easier to deal with
a single value being returned from

00:08:53.940 --> 00:08:58.960
a function than a number of output
parameters as with the older function.

00:08:59.240 --> 00:09:03.730
And also the default result of this,
calling this new API,

00:09:03.740 --> 00:09:07.440
includes that adjustment that we
had previously applied internally

00:09:07.970 --> 00:09:11.670
that you could sort of deduce by,
you know, reverse engineering where the

00:09:11.670 --> 00:09:12.600
line ended up in the frame.

00:09:12.600 --> 00:09:15.600
But now you can simply
access that directly.

00:09:15.600 --> 00:09:19.720
And so if you needed to match that
computation for whatever reason,

00:09:19.820 --> 00:09:22.970
then it's available to
you through this new API.

00:09:23.310 --> 00:09:26.880
As I advance to the next few slides,
I want to call your attention in

00:09:26.880 --> 00:09:33.000
particular to the left and right
sides of this rectangle on screen.

00:09:33.150 --> 00:09:37.160
Because I'm going to start passing some
different options to this API and it's

00:09:37.160 --> 00:09:40.230
going to have an effect on either side.

00:09:40.400 --> 00:09:47.510
So let's go ahead and advance now
as I invoke "Use Optical Bounds".

00:09:47.820 --> 00:09:51.770
So this is a very slight difference here,
but you may have noticed that

00:09:51.870 --> 00:09:55.800
the edges of the box have been
pulled in a little bit here.

00:09:55.930 --> 00:09:58.790
What's going on here is that
optical bounds are very closely

00:09:58.800 --> 00:10:02.940
related to the typographic bounds,
the regular measurement of the line,

00:10:03.010 --> 00:10:10.440
but in this case the font designer has
specified that the way that the font

00:10:10.440 --> 00:10:14.840
is likely to be perceived by our eyes
means that they don't line up exactly

00:10:14.840 --> 00:10:17.540
with just the glyph measurements.

00:10:17.660 --> 00:10:21.350
And so the optical bounds in this
case have been designed to pull in

00:10:21.840 --> 00:10:27.400
on either of these curly quotes here,
because the way our eyes see rounded

00:10:27.400 --> 00:10:30.180
shapes is a bit different than
the way we see straight lines,

00:10:30.180 --> 00:10:33.840
and so the font designer has
compensated for that by providing

00:10:33.840 --> 00:10:35.820
this information in the font.

00:10:37.430 --> 00:10:41.490
The next option we're going to see is
going to be a very much more obvious

00:10:41.490 --> 00:10:46.190
change as we use hanging punctuation.

00:10:46.660 --> 00:10:47.960
So this is an option.

00:10:47.960 --> 00:10:51.740
It's sometimes seen
in some typeset pages.

00:10:51.740 --> 00:10:55.600
Gutenberg did some of it,
but it kind of fell to the wayside.

00:10:55.600 --> 00:10:57.660
Well,
computers can make this a lot easier.

00:10:57.670 --> 00:11:02.960
Hanging punctuation is the process of
letting the insignificant punctuation

00:11:02.960 --> 00:11:08.600
in a line hang off of either
margin in a frame or on a page.

00:11:08.600 --> 00:11:12.420
So of course this requires knowing
that that can possibly happen and

00:11:12.420 --> 00:11:16.600
so not simply clipping the text to
the immediate bounds of the frame.

00:11:16.600 --> 00:11:22.570
But this is certainly a
pretty interesting example.

00:11:22.600 --> 00:11:29.600
One thing I would note is that of course
not every glyph can hang off either side.

00:11:29.600 --> 00:11:31.760
Some of them are limited
to just the right or left,

00:11:31.820 --> 00:11:32.600
for instance.

00:11:32.830 --> 00:11:35.600
And this information
can come from the font.

00:11:35.600 --> 00:11:38.600
The AAT prop table has a "can hang" bit.

00:11:38.650 --> 00:11:42.670
That the font designer can set indicating
that they want a particular glyph

00:11:42.670 --> 00:11:44.600
to hang on one side or the other.

00:11:44.600 --> 00:11:50.770
But in the absence of that information,
since that's not super common yet,

00:11:50.860 --> 00:11:54.830
you can... Core Text also has a list
of characters that are appropriate

00:11:54.930 --> 00:11:59.550
for hanging on the correct sides
for standard Roman typography.

00:11:59.600 --> 00:12:03.600
So that's something you can play
with even without a particular font.

00:12:03.760 --> 00:12:08.600
The last example I'm going to show you
how you can combine these two options.

00:12:08.600 --> 00:12:12.730
Another subtle thing here,
but watch on the left side

00:12:12.730 --> 00:12:15.040
of this box as I advance.

00:12:15.270 --> 00:12:17.570
And you'll see there the
effect of applying both hanging

00:12:17.640 --> 00:12:20.160
punctuation and optical bounds.

00:12:20.290 --> 00:12:25.090
What's happened here is that the
font designer has set the cap

00:12:25.090 --> 00:12:28.900
J so that of course it's snug up
against that curly quote there,

00:12:28.900 --> 00:12:33.270
but the font designer also decided
that when set against the left margin,

00:12:33.270 --> 00:12:36.720
that cap J should get a little
bit of extra space so that the

00:12:36.780 --> 00:12:40.040
tail isn't hanging completely
out as it would otherwise.

00:12:40.190 --> 00:12:44.510
So that's an example of how
options can be combined.

00:12:46.180 --> 00:12:51.540
Another variant of calling this
API is to use glyph path bounds.

00:12:51.710 --> 00:12:55.770
So previous to the availability
of CTLineGetBounds with options

00:12:56.330 --> 00:13:00.140
and still available is an
API called CTLineGetImageBounds.

00:13:00.200 --> 00:13:04.450
But it was a bit of a misnomer
in that it was doing exactly

00:13:04.460 --> 00:13:08.740
what this option is doing,
which is simply computing the

00:13:08.860 --> 00:13:14.140
minimum bounding rectangle of all
of the glyph paths in the line.

00:13:14.270 --> 00:13:19.140
And it was also pretty
difficult to actually use.

00:13:19.140 --> 00:13:22.180
If you've tried to use it,
it's rather cumbersome.

00:13:22.180 --> 00:13:25.180
So we wanted to make it
available through this new API.

00:13:25.180 --> 00:13:27.180
It's a lot simpler to use.

00:13:27.190 --> 00:13:30.640
But I also wanted to call out
the fact that these glyph path

00:13:30.640 --> 00:13:35.180
bounds are not generally relevant
when dealing with typography.

00:13:35.220 --> 00:13:39.460
Since, as you can imagine,
it depends greatly on what the

00:13:39.460 --> 00:13:42.180
particular glyphs in a line are.

00:13:42.180 --> 00:13:44.510
So you wouldn't want to use
these glyph path bounds when

00:13:44.970 --> 00:13:46.990
determining how to set two lines,
one after the other,

00:13:47.050 --> 00:13:48.160
on top of each other.

00:13:48.180 --> 00:13:51.220
Because if one of the lines
didn't have any descenders,

00:13:51.220 --> 00:13:54.390
for instance, which can happen,
then of course you wouldn't see

00:13:54.390 --> 00:13:56.180
anything below the baseline whatsoever.

00:13:56.180 --> 00:14:03.180
So this value is more appropriate
for input to some other process.

00:14:03.180 --> 00:14:05.880
Maybe you're implementing a drawing
application and need to know

00:14:06.200 --> 00:14:08.180
the coverage of the glyph paths.

00:14:08.180 --> 00:14:09.350
Or maybe the glyph paths themselves
are part of a graphical composition

00:14:09.410 --> 00:14:10.220
that you're using in your application.

00:14:10.220 --> 00:14:16.210
Or document handling.

00:14:16.270 --> 00:14:20.220
But this is available as
another option for the new API.

00:14:21.850 --> 00:14:23.800
It's all fine and good.

00:14:23.830 --> 00:14:26.760
I mean, information is good,
but another way to make use of

00:14:26.760 --> 00:14:29.820
this is to actually apply it,
and you can do that automatically

00:14:30.320 --> 00:14:35.030
using a new paragraph style specifier,
which is used by CTFramesetter to affect

00:14:35.050 --> 00:14:37.490
the line edges during frame filling.

00:14:37.890 --> 00:14:41.240
So, for instance,
if you specified the option

00:14:41.300 --> 00:14:45.800
for using hang punctuation and
set that on a paragraph style,

00:14:45.800 --> 00:14:49.960
CTFramesetter would automatically
hang that punctuation and vary the

00:14:49.970 --> 00:14:55.970
line lengths appropriately to make
that effect possible very easily.

00:14:58.390 --> 00:15:00.640
The other big feature that we
wanted to call your attention

00:15:00.640 --> 00:15:02.910
to is baseline alignment.

00:15:03.020 --> 00:15:05.800
This is kind of a case
of back to the future.

00:15:05.910 --> 00:15:07.800
This technology has
been around for a while,

00:15:07.800 --> 00:15:09.640
but it's been a bit neglected.

00:15:09.790 --> 00:15:13.520
But as we expand our
global coverage in Apple,

00:15:13.550 --> 00:15:18.760
one of the things that we learned is
that the naive way of doing things

00:15:18.860 --> 00:15:24.460
wasn't sufficient when dealing with
mixed scripts or writing systems.

00:15:24.460 --> 00:15:28.300
Because some of them have
very different typographic

00:15:28.300 --> 00:15:31.200
conventions relative to Roman text.

00:15:31.310 --> 00:15:35.310
So I wanted to give you some examples
of how this is actually useful

00:15:35.310 --> 00:15:37.460
or why it might be interesting.

00:15:37.550 --> 00:15:42.060
Certainly it's interesting to us and you
might have some ideas as to how to put

00:15:42.200 --> 00:15:44.620
it to use in your application as well.

00:15:44.770 --> 00:15:50.920
So in this example we have "Hello World!"
but "world" is set in Han characters,

00:15:50.920 --> 00:15:54.460
so if you speak Chinese, for instance,
it might make sense.

00:15:54.460 --> 00:15:57.810
I did a rough translation there.

00:15:58.330 --> 00:16:03.500
This is the layout that you would
currently get from Core Text or

00:16:03.500 --> 00:16:05.200
any higher level framework.

00:16:05.220 --> 00:16:06.200
It looks okay.

00:16:06.200 --> 00:16:09.340
What I've done is I've
set that string in Myriad,

00:16:09.340 --> 00:16:12.490
but of course since Myriad the
font doesn't contain either

00:16:12.490 --> 00:16:16.200
of those Han characters,
we have font fallback occurring here.

00:16:16.200 --> 00:16:20.200
So this is a different font
that has the Han characters.

00:16:20.320 --> 00:16:20.880
And it looks okay.

00:16:20.880 --> 00:16:22.420
Everything is set on
this blue baseline here,

00:16:22.520 --> 00:16:24.190
which I'm going to call
the natural baseline.

00:16:24.210 --> 00:16:29.750
This is just placing
each glyph origin at y=0.

00:16:30.020 --> 00:16:35.640
But a native speaker of Chinese perhaps
might note that their baseline

00:16:35.810 --> 00:16:40.330
actually should sit a bit lower
than the standard Roman baseline.

00:16:40.450 --> 00:16:44.800
And so by enabling baseline alignment
here to let those Han characters

00:16:44.800 --> 00:16:49.300
sit on the ideographic baseline,
a native speaker would feel that

00:16:49.350 --> 00:16:51.860
this is a much better appearance.

00:16:51.980 --> 00:16:55.590
Now this is a bit of a subtle example,
and so I wanted another example that

00:16:55.590 --> 00:16:58.040
would make things a bit more obvious.

00:16:58.190 --> 00:17:02.500
So here's another "Hello
World," this part in Hindi.

00:17:02.650 --> 00:17:09.490
And so what's interesting about
the Devanagari script is that it

00:17:09.550 --> 00:17:12.580
actually operates on a different
notion of a baseline completely.

00:17:12.580 --> 00:17:14.880
It uses what's called a hanging baseline.

00:17:15.000 --> 00:17:19.640
And so rather than natively
setting on top of a baseline,

00:17:19.640 --> 00:17:24.050
such as this natural baseline here,
you'll see that there's a crossbar

00:17:24.460 --> 00:17:26.180
from which the letters hang.

00:17:26.180 --> 00:17:30.460
And so a native speaker would
expect that when you change

00:17:30.460 --> 00:17:33.960
the point size of that text,
that it would actually,

00:17:33.960 --> 00:17:36.830
if you made it larger,
it would actually extend down

00:17:36.950 --> 00:17:39.670
from that hanging baseline,
rather than sitting higher

00:17:39.670 --> 00:17:44.370
up as we're used to,
or we English speakers are used to.

00:17:44.480 --> 00:17:48.490
And so I'm going to increase
the point size by quite a

00:17:48.550 --> 00:17:52.570
bit to emphasize the effect,
but this is actually the

00:17:52.750 --> 00:17:55.380
expected behavior for a script
that uses a hanging baseline.

00:17:55.380 --> 00:17:55.380
And so a native speaker would
expect that when you change

00:17:55.380 --> 00:17:55.420
the point size of that text,
that it would actually,

00:17:55.420 --> 00:17:55.500
if you made it larger,
it would actually extend down

00:17:55.500 --> 00:17:55.610
from that hanging baseline,
rather than sitting higher

00:17:55.610 --> 00:17:55.880
up as we're used to,
or English speakers are used to.

00:17:55.880 --> 00:17:56.420
And so a native speaker would
expect that when you change

00:17:56.420 --> 00:17:56.780
the point size of that text,
that it would actually extend

00:17:56.780 --> 00:17:56.780
down from that hanging baseline,
rather than sitting higher

00:17:56.780 --> 00:17:56.880
up as we're used to,
or English speakers are used to,

00:17:56.880 --> 00:17:56.880
or English speakers are used to,
or even if you're using

00:17:56.880 --> 00:17:57.020
a natural baseline,
that it would actually extend

00:17:57.020 --> 00:17:57.190
down from that hanging baseline.

00:17:57.350 --> 00:18:01.330
So you'll see here that even
though the line itself still has

00:18:01.470 --> 00:18:08.060
the expected natural baseline,
the larger point size of that

00:18:08.490 --> 00:18:12.530
Devanagari text causes it to hang down.

00:18:13.510 --> 00:18:15.940
So that's great,
but maybe you're not localizing your

00:18:15.940 --> 00:18:20.010
application into a language that
requires this type of special treatment.

00:18:20.220 --> 00:18:24.260
The other neat thing about baseline
alignment is that you can use it for some

00:18:24.370 --> 00:18:26.720
more fun effects maybe or something else.

00:18:26.740 --> 00:18:30.150
We'll find out what you
all can come up with.

00:18:30.230 --> 00:18:32.460
In this particular example,
I'm just going to implement some

00:18:32.520 --> 00:18:35.330
simple drop caps like you might see
at the beginning of a children's

00:18:35.340 --> 00:18:41.000
storybook or maybe a magazine that you
read uses an effect similar to this.

00:18:41.060 --> 00:18:44.510
But this example I'm going to
make use of that hanging baseline

00:18:44.510 --> 00:18:47.280
from the previous example,
but I'm just going to apply it

00:18:47.280 --> 00:18:49.900
manually to these capital letters.

00:18:49.970 --> 00:18:55.240
And so in this case I can override
the baseline for the Roman glyphs

00:18:55.330 --> 00:19:00.050
here and set them on the hanging
baseline as I change their size.

00:19:00.200 --> 00:19:03.570
So how do you actually do this?

00:19:03.570 --> 00:19:03.570
Well,

00:19:03.790 --> 00:19:07.710
Each font has multiple baselines.

00:19:07.830 --> 00:19:12.350
A baseline is essentially a
vertical offset relative to that

00:19:12.530 --> 00:19:15.140
natural baseline I was showing you.

00:19:15.290 --> 00:19:18.560
And there are a number of them
that I've shown you already.

00:19:18.710 --> 00:19:21.250
The Roman,
which in most fonts corresponds

00:19:21.250 --> 00:19:22.560
to the natural baseline.

00:19:22.560 --> 00:19:27.950
Ideographic, hanging in there,
a couple of others for certain purposes.

00:19:28.300 --> 00:19:33.560
Each glyph in a font has associated
with it a default baseline.

00:19:33.560 --> 00:19:37.980
One of those types of baselines is
appropriate for each glyph by default.

00:19:38.160 --> 00:19:43.460
Either the font can specify that or
we'll use the character range in which

00:19:43.770 --> 00:19:48.100
that character comes from to determine
what the baseline should be by default.

00:19:48.230 --> 00:19:52.590
And then the process of alignment is
simply taking two adjacent runs of text,

00:19:52.590 --> 00:19:54.840
either with different fonts
or different attributes.

00:19:54.960 --> 00:19:58.430
One of them is going to be a reference,
that is, it's going to stay put,

00:19:58.540 --> 00:20:01.900
and the other one is going to move
up or down so that we can pick the

00:20:01.900 --> 00:20:06.880
same type of baseline from each
of those runs and match them up.

00:20:06.880 --> 00:20:10.560
So that's what baseline
alignment is going to be doing.

00:20:11.320 --> 00:20:13.740
: We do this by specifying
those alignment parameters

00:20:13.740 --> 00:20:15.660
using string attributes.

00:20:15.840 --> 00:20:19.530
The most important one is the reference,
which is specified using the

00:20:19.530 --> 00:20:21.490
reference info attribute.

00:20:21.620 --> 00:20:24.200
And this is what activates
baseline alignment.

00:20:24.300 --> 00:20:28.170
By default, it's disabled because, A,
we don't want to be affecting the

00:20:28.290 --> 00:20:32.200
layout of text that you previously
expected to see in a certain way,

00:20:32.200 --> 00:20:35.200
and also because, well, it would be rude.

00:20:35.400 --> 00:20:39.200
So you need to specify that in some way.

00:20:39.200 --> 00:20:46.930
And then some options are to also give
some special definition to the baselines

00:20:46.930 --> 00:20:51.200
being moved and also overriding which
particular baseline in the set of

00:20:51.200 --> 00:20:53.170
baselines is going to be aligned.

00:20:53.450 --> 00:20:56.510
Otherwise,
we'll use the default baseline.

00:20:59.600 --> 00:21:04.340
So this is what it looks
like in its simplest form.

00:21:04.360 --> 00:21:09.360
This is how I implemented both
of the Hello World examples.

00:21:09.360 --> 00:21:13.000
What I've done is I have a
mutable attributed string.

00:21:13.030 --> 00:21:16.110
I'm adding my reference info to it,
and that's a dictionary containing

00:21:16.110 --> 00:21:19.050
various keys and values,
but the important one in this

00:21:19.050 --> 00:21:20.920
case is the reference font.

00:21:20.920 --> 00:21:25.740
This says -- this defines the set of
baselines relative to which I'm going

00:21:25.740 --> 00:21:28.640
to move anything that might need moving.

00:21:28.640 --> 00:21:32.550
So this will be applied
to any fallback fonts,

00:21:32.550 --> 00:21:35.670
for instance,
and we can also use it in the

00:21:35.860 --> 00:21:39.840
case of the point size changes.

00:21:39.840 --> 00:21:42.220
So since a CT font has
an inherent point size,

00:21:42.340 --> 00:21:46.020
of course, in the Hindi example when
we changed the point size,

00:21:46.020 --> 00:21:48.210
the reference font remained unchanged.

00:21:48.210 --> 00:21:50.820
I didn't change that
in that example at all,

00:21:50.820 --> 00:21:53.160
and so it used the hanging baseline.

00:21:53.280 --> 00:21:55.690
from the original point size.

00:21:58.900 --> 00:24:25.800
[Transcript missing]

00:24:25.980 --> 00:24:30.830
And as I mentioned previously about using
the highest level framework possible,

00:24:30.940 --> 00:24:33.900
you may be doing this all
from the App Kit level.

00:24:33.900 --> 00:24:38.110
And so App Kit also added
NS Font Collection in Lion and,

00:24:38.130 --> 00:24:40.900
of course, that's toll-free bridge
with CT Font Collection.

00:24:40.900 --> 00:24:46.260
So instances of either class can be
used interchangeably with either API,

00:24:46.540 --> 00:24:48.900
either Core Texts or App Kits.

00:24:48.900 --> 00:24:51.900
And it remains the preferred
way to enumerate fonts.

00:24:51.900 --> 00:24:54.610
So if your application needs to
get a list of fonts available

00:24:54.690 --> 00:24:57.750
to it while it's running,
then CT Font Collection is the most

00:24:57.750 --> 00:25:00.900
efficient way to access that information.

00:25:04.910 --> 00:25:10.590
Another feature pertains
to typographic features.

00:25:10.790 --> 00:25:16.410
So Core Text supports two font formats,
both AAT, Apple Advanced Typography,

00:25:16.410 --> 00:25:17.720
and OpenType.

00:25:17.890 --> 00:25:22.200
And both of these font
formats have what are called

00:25:22.480 --> 00:25:24.390
typographic or layout features.

00:25:24.610 --> 00:25:29.840
They're special rules essentially
in the font that change the layout.

00:25:29.960 --> 00:25:32.900
So a simple example would be
a ligature where two glyphs

00:25:33.040 --> 00:25:37.940
appearing next to each other would
get combined into a ligated glyph.

00:25:38.030 --> 00:25:44.480
But there are lots of other typographic
features that fonts might offer.

00:25:44.480 --> 00:25:44.480
And

00:25:44.910 --> 00:25:53.500
Since Core Text API is modeled
after the AAT font specification,

00:25:53.610 --> 00:25:58.410
there were some OpenType features
that weren't easily accessible.

00:25:58.510 --> 00:26:04.290
That is that you couldn't
activate those features in code.

00:26:04.300 --> 00:26:12.500
[Transcript missing]

00:26:12.810 --> 00:26:21.700
So the way things were is that if you saw
an AAT feature specified in our header,

00:26:21.700 --> 00:26:27.470
SFNTLayoutTypes.h,
and it had a natural correspondence,

00:26:27.550 --> 00:26:29.460
a natural equivalence
with an OpenType feature,

00:26:29.460 --> 00:26:33.800
then activating,
requesting that AAT feature for an

00:26:33.800 --> 00:26:35.890
OpenType font would do the right thing.

00:26:35.940 --> 00:26:39.500
But there were quite a few
OpenType features that didn't have

00:26:39.500 --> 00:26:43.940
a natural correspondence with an
existing AAT feature specification.

00:26:43.940 --> 00:26:47.810
And so what we've done in
Mountain Lion and iOS 6 is

00:26:47.810 --> 00:26:51.690
we've added new features,
new AAT features that naturally

00:26:51.750 --> 00:26:54.360
correspond to one of these
OpenType features that was

00:26:54.450 --> 00:26:55.920
previously inaccessible.

00:26:55.940 --> 00:26:59.670
So in this example,
I'm enabling Petite Caps,

00:26:59.710 --> 00:27:03.740
which is under the PCAP lookup
in an OpenType font.

00:27:04.120 --> 00:27:05.940
And so we've added this new feature.

00:27:05.940 --> 00:27:11.150
And so we've added this new AAT feature
in order to activate the OpenType

00:27:11.150 --> 00:27:13.940
layout for this particular font.

00:27:13.940 --> 00:27:17.870
And this is something we'll
be revisiting in the future.

00:27:17.940 --> 00:27:22.940
We may add a new API for direct access,
but in the meantime,

00:27:22.940 --> 00:27:28.080
this should get you going with nearly
all of the commonly requested OpenType

00:27:28.180 --> 00:27:31.860
features to enable in your fonts.

00:27:33.740 --> 00:27:39.030
And on a bit of trivia,
I would note that as of OS X Lion,

00:27:39.030 --> 00:27:43.140
AppKit added NSWritingDirection
for specifying bidirectional

00:27:43.140 --> 00:27:45.040
embedding or overrides.

00:27:45.160 --> 00:27:48.040
And I'm not going to go into it now,
but suffice it to say that

00:27:48.040 --> 00:27:51.290
it's now implemented at the
Core Text level as well,

00:27:51.290 --> 00:27:54.790
which makes near as much
no difference on OS X,

00:27:54.800 --> 00:27:58.860
but of course it means that now this
feature is available on iOS as well.

00:27:58.860 --> 00:28:03.770
So if you have been making use of that,
now you can do so on iOS.

00:28:05.310 --> 00:28:08.520
Okay, well,
we got the easy stuff out of the way,

00:28:08.520 --> 00:28:09.200
right?

00:28:09.260 --> 00:28:13.620
No, this next section is not so
much advanced topics as it is

00:28:14.140 --> 00:28:15.670
perhaps a bit of a grab bag.

00:28:15.880 --> 00:28:22.890
We hear a number of questions
from developers repeatedly,

00:28:22.910 --> 00:28:26.810
and so we thought that we'd address
some of these common questions that

00:28:26.810 --> 00:28:32.760
seem to come up as we talk to you,
and we also want to call out some new

00:28:32.760 --> 00:28:35.160
tidbits that you might be interested in.

00:28:35.200 --> 00:28:36.360
Amen.

00:28:38.000 --> 00:28:43.430
The first is vertical text.

00:28:43.430 --> 00:28:48.000
Perhaps the trickiest thing with vertical
text is just figuring out where to start.

00:28:48.150 --> 00:28:52.640
And so I'm not going to delve
a lot into vertical text,

00:28:52.830 --> 00:28:56.180
but I would like to give just
a quick overview of what that

00:28:56.400 --> 00:28:58.600
means from a layout perspective.

00:29:01.660 --> 00:29:06.060
So there are two steps in
enabling vertical text.

00:29:06.060 --> 00:29:09.100
One is getting the right layout,
that is selecting the proper

00:29:09.160 --> 00:29:10.840
glyphs for vertical layout.

00:29:10.880 --> 00:29:13.940
And the other is getting the
line to go in the right place.

00:29:14.100 --> 00:29:17.490
So naturally instead of
sitting horizontally across

00:29:17.490 --> 00:29:21.100
a frame or page or whatever,
it needs to go vertically.

00:29:21.320 --> 00:29:28.030
Well, the good news is those two steps
are pretty much unrelated other

00:29:28.030 --> 00:29:31.670
than in the way that they're used.

00:29:31.670 --> 00:29:31.670
And so we can demonstrate what

00:29:32.320 --> 00:29:37.790
it means to enable vertical text by
following those two steps in action.

00:29:37.910 --> 00:29:41.400
The first thing we're going to do
is enable those vertical glyphs,

00:29:41.500 --> 00:29:44.600
or activate vertical
layout for this line.

00:29:44.650 --> 00:29:48.510
We're going to do that by setting a
string attribute to a Boolean value

00:29:48.510 --> 00:29:52.570
of "yes." Essentially what that does
from the line's perspective -- the line

00:29:52.600 --> 00:29:56.830
doesn't really care what it's doing here,
but if you look at it in

00:29:56.830 --> 00:30:00.130
a horizontal perspective,
it kind of looks like all the glyphs

00:30:00.270 --> 00:30:01.760
are just lying on their sides.

00:30:01.850 --> 00:30:03.920
Now,
all of these glyphs are simply rotated,

00:30:03.920 --> 00:30:06.980
but in some cases,
they might require slightly

00:30:07.000 --> 00:30:09.020
different glyph forms,
or they might get different

00:30:09.100 --> 00:30:11.620
metrics or whatever,
but for this simple example,

00:30:11.620 --> 00:30:14.820
I'm just going to show
them being rotated.

00:30:15.070 --> 00:30:19.200
So that's great, but of course it's
still not very legible,

00:30:19.200 --> 00:30:21.710
and so what we need to do
next is we simply just need to

00:30:21.750 --> 00:30:24.700
rotate that line into place.

00:30:24.820 --> 00:30:27.540
And so you'll note that
these are somewhat unrelated,

00:30:27.540 --> 00:30:31.660
but they're both necessary for
actually making use of vertical text.

00:30:31.780 --> 00:30:37.840
So it's pretty easy to do that,
but it's also not, because there's a lot

00:30:37.840 --> 00:30:39.270
of rotation involved.

00:30:39.410 --> 00:30:42.050
Some things go one way and
other things go the other.

00:30:42.210 --> 00:30:46.800
And the way that our graphic system is
based makes it fairly complicated to keep

00:30:46.860 --> 00:30:51.100
track of all these various transforms
that are in flight at one time.

00:30:51.260 --> 00:30:54.820
And so use a higher level framework.

00:30:54.930 --> 00:30:58.560
If possible,
you should check out NSTextView on OS X.

00:30:58.560 --> 00:31:02.200
It has really great support
for vertical writing.

00:31:02.300 --> 00:31:04.980
And so we'd urge you to go
that route if at all possible.

00:31:04.980 --> 00:31:07.710
You'll get all the benefits
of NSTextView besides.

00:31:07.830 --> 00:31:13.630
If you can't or don't want to do that,
then CTFramesetter has an option

00:31:13.630 --> 00:31:16.940
that you can set when creating a
frame that will do the rotation

00:31:16.940 --> 00:31:21.640
for you and take into account the
proper bounds for vertical writing.

00:31:21.800 --> 00:31:25.650
And then of course the vertical
glyphs are simply just enabled

00:31:25.650 --> 00:31:27.600
by the string attribute.

00:31:27.880 --> 00:31:29.820
But if you're not using one of those,
like I said,

00:31:29.920 --> 00:31:33.300
it's surprisingly complicated,
and so I would urge you to

00:31:33.340 --> 00:31:36.600
come talk to us during our lab
or grab us some other time,

00:31:36.600 --> 00:31:41.300
and we can talk about what it
means and get you going on that.

00:31:44.170 --> 00:31:46.530
Font names.

00:31:46.530 --> 00:31:49.810
So, fonts have lots of names.

00:31:50.040 --> 00:31:52.990
Most fonts have a lot more names
than I can show on this slide,

00:31:52.990 --> 00:31:53.360
in fact.

00:31:53.500 --> 00:31:56.000
If you're curious,
you can take a look at what you

00:31:56.000 --> 00:32:00.560
can find in FontBook on OS X,
where you'll see a lot of,

00:32:00.650 --> 00:32:04.500
most if not all of the
names in a particular font.

00:32:04.630 --> 00:32:07.550
But in this case,
I wanted to use a particular

00:32:07.550 --> 00:32:10.110
example of Times New Roman Italic.

00:32:12.300 --> 00:32:17.240
The first name on this
slide is the most important.

00:32:17.360 --> 00:32:19.490
It's called the Postscript Name.

00:32:19.670 --> 00:32:22.990
We use it internally as
a sort of identifier or,

00:32:23.060 --> 00:32:30.090
you know, a unique token for each font
that is installed on the system.

00:32:30.250 --> 00:32:33.640
So what's special about this name is,
well, for one,

00:32:33.640 --> 00:32:35.940
certain characters are illegal in it.

00:32:36.080 --> 00:32:38.990
That's simply a specification thing,
so you'll know if there's no spaces,

00:32:39.040 --> 00:32:43.040
that's a good giveaway that
it's a PostScript name.

00:32:43.040 --> 00:32:46.340
But also, crucially, it's not localized.

00:32:46.340 --> 00:32:51.670
Most, if not all,
other font names can be localized.

00:32:51.900 --> 00:32:57.550
So Times New Roman might not be
Times New Roman in every language.

00:32:58.270 --> 00:33:03.720
Another thing to note is that although
it looks like the full or display name,

00:33:03.730 --> 00:33:10.680
depending on the terminology, is unique,
you'll note that these other two names,

00:33:10.680 --> 00:33:14.510
the family and style names,
those are almost definitely not unique.

00:33:14.580 --> 00:33:16.780
In particular,
the family name is probably shared

00:33:16.780 --> 00:33:20.150
among other fonts in the same family,
so Times New Roman Bold, for instance,

00:33:20.160 --> 00:33:21.770
would have the same family name.

00:33:22.340 --> 00:33:25.300
And likewise,
the style name is probably that

00:33:25.520 --> 00:33:29.120
same thing for lots and lots
of other fonts on the system.

00:33:30.510 --> 00:33:31.800
And why does this matter?

00:33:31.800 --> 00:33:35.960
Well, there's a function that I'm
almost positive that you know of,

00:33:35.960 --> 00:33:39.480
having used Core Text,
called ctfontcreateWithName.

00:33:40.040 --> 00:33:45.900
And this function was designed to
accept just the PostScript name.

00:33:45.990 --> 00:33:49.700
But we made the decision a while ago
in order to be a bit more generous

00:33:49.700 --> 00:33:52.490
and accept any of these names.

00:33:52.630 --> 00:33:56.390
But the problem is that on a
more constrained environment,

00:33:56.400 --> 00:34:01.080
like you would find on an iOS device,
this can be quite costly to actually

00:34:01.470 --> 00:34:05.200
provide a reasonable result for
anything other than the PostScript name.

00:34:05.350 --> 00:34:09.790
So as I mentioned, you have the case of
localized names to deal with.

00:34:09.910 --> 00:34:14.270
You could also specify the family name,
in which case we try to

00:34:14.270 --> 00:34:15.300
do something consistent.

00:34:15.300 --> 00:34:19.860
We try to consistently give you
the standard weight of that family.

00:34:20.120 --> 00:34:21.860
But that of course means we
need to figure out what all of

00:34:21.860 --> 00:34:23.100
the members of that family are.

00:34:23.110 --> 00:34:25.700
There's a lot of
processing that's going on.

00:34:25.850 --> 00:34:30.940
And so we've got a number of scenarios
brought to us by developers where

00:34:30.940 --> 00:34:35.100
they've been simply creating a font and
things kind of just grind to a halt.

00:34:35.100 --> 00:34:38.840
and that's because we
were trying to be nice.

00:34:39.280 --> 00:34:45.470
We're going to stop being so lenient.

00:34:46.170 --> 00:34:53.710
So in a future release of OS X and iOS,
we are going to

00:34:53.900 --> 00:35:07.100
[Transcript missing]

00:35:07.600 --> 00:35:14.220
So rest assured this behavior is going
to remain in its current state for

00:35:14.220 --> 00:35:19.870
any of your applications until they
are linked against that future OS.

00:35:19.890 --> 00:35:23.860
But now is a good time to start
updating your code to make sure

00:35:23.860 --> 00:35:28.800
you're supplying the right kind of
name to CT Font Create With Name.

00:35:28.800 --> 00:35:32.190
So what we've done in iOS
X is we've added some logging.

00:35:32.250 --> 00:35:37.190
In this case,
someone has inadvertently specified

00:35:37.460 --> 00:35:40.820
I don't know, it's probably the family
name for Noya Helvetica,

00:35:40.870 --> 00:35:43.490
when in fact the PostScript name
obviously is going to

00:35:43.700 --> 00:35:45.800
not have a space for one.

00:35:45.970 --> 00:35:51.360
But the developer in this case can
set a breakpoint on this function

00:35:51.560 --> 00:35:55.440
in the second log statement,
and they can check the backtrace

00:35:55.440 --> 00:35:59.350
and see what code is responsible
for using the wrong name.

00:36:00.260 --> 00:36:06.750
So you might be asking yourself, well,
what am I supposed to do if I want

00:36:06.890 --> 00:36:08.780
to use one of those other names?

00:36:08.870 --> 00:36:11.250
Well,
we've always had a way of doing that.

00:36:11.490 --> 00:36:15.920
It's just that it wasn't really
needed because you could just

00:36:15.920 --> 00:36:16.900
do it the easy way instead.

00:36:16.900 --> 00:36:20.200
But basically what you would
want to do in that case,

00:36:20.260 --> 00:36:25.090
maybe you have a document format that
specifies a different type of name.

00:36:25.090 --> 00:36:28.690
Or maybe you're even getting data
from the Internet where you can't

00:36:28.690 --> 00:36:32.050
really know in advance that it's going
to be a postscript name necessarily.

00:36:32.100 --> 00:36:35.340
And so in this case what you
can do is you can use a font

00:36:35.350 --> 00:36:37.470
descriptor as a sort of a query.

00:36:37.550 --> 00:36:44.100
In this case the attributes specify
a family name of Times New Roman.

00:36:44.360 --> 00:36:51.060
And by using that particular attribute
when creating matching font descriptors,

00:36:51.060 --> 00:36:55.570
then you're telling Core Text that
it's only to consult family names

00:36:55.670 --> 00:36:59.360
that it knows about in order to
find an appropriate font or fonts.

00:36:59.530 --> 00:37:02.270
And there are other attributes for,
for instance,

00:37:02.270 --> 00:37:06.270
the display name and the style name,
and you can use those as appropriate.

00:37:06.410 --> 00:37:11.160
So basically by signaling your intent,
by telling us exactly which name you're

00:37:11.200 --> 00:37:16.020
trying to find a matching font for,
we can do a much better job

00:37:16.390 --> 00:37:18.900
of not grinding to a halt.

00:37:19.040 --> 00:37:23.380
Font fallback, some would say,
is a crucial component to Unicode

00:37:23.380 --> 00:37:27.550
Text Layout because up until recently
it's been impossible to construct a

00:37:27.590 --> 00:37:29.700
single font that covers all of Unicode.

00:37:29.710 --> 00:37:32.960
And besides,
doing so would be prohibitively

00:37:32.960 --> 00:37:35.140
costly and time consuming.

00:37:35.290 --> 00:37:39.150
So basically,
Unicode wants you to be able to specify

00:37:39.160 --> 00:37:46.860
any character in the standard and it's
entirely unlikely that you're going

00:37:46.860 --> 00:37:51.400
to try to adjust the font for every
particular character in that string.

00:37:51.400 --> 00:37:55.000
And so it's very important to
be able to rely on having a

00:37:55.000 --> 00:37:57.220
fallback mechanism in place.

00:37:57.240 --> 00:38:00.950
And so our default mechanism for
that we call the system cascade,

00:38:00.950 --> 00:38:06.220
which is a list of fonts that will
consult if the specified font is

00:38:06.220 --> 00:38:06.220
not the one that you're looking for.

00:38:06.300 --> 00:38:09.680
And so our default mechanism for that
is that the specified font does not

00:38:09.680 --> 00:38:13.700
cover one or more of the characters in
the string that you've asked to layout.

00:38:14.370 --> 00:38:17.330
But in some cases,
developers have asked for a way to modify

00:38:17.330 --> 00:38:19.840
the behavior of the system cascade.

00:38:19.940 --> 00:38:23.480
Well,
the mechanism we've had in place for

00:38:23.820 --> 00:38:29.030
-- since the beginning of Core Text is
to use this attribute to specify the

00:38:29.180 --> 00:38:33.960
cascade list or user cascade list as
opposed to the system cascade list.

00:38:34.050 --> 00:38:39.790
And what that is is a list of fonts
that you can specify as an attribute

00:38:39.790 --> 00:38:46.100
to either a font or a font descriptor,
and we will consult those in order

00:38:46.100 --> 00:38:49.170
whenever we need to search for fallback.

00:38:49.290 --> 00:38:52.140
Prior to consulting the system cascade.

00:38:52.170 --> 00:38:56.940
So one thing you could also do with
this mechanism like this is to find

00:38:56.940 --> 00:39:03.080
out when you want to -- some developers
have asked us that they don't want

00:39:03.090 --> 00:39:05.040
to consult the system cascade at all.

00:39:05.040 --> 00:39:07.880
They just want to use their own
fallback fonts and they want to

00:39:07.880 --> 00:39:11.440
be able to detect when they've run
out of those fonts effectively.

00:39:11.440 --> 00:39:15.520
And so all you need is a font that
covers every character in Unicode.

00:39:15.530 --> 00:39:19.080
Probably isn't going to be able
to do anything useful with that,

00:39:19.190 --> 00:39:23.130
but it at least claims to support every
character in Unicode and both of our

00:39:23.540 --> 00:39:26.180
platforms have a font with that property.

00:39:26.240 --> 00:39:27.190
It's called Last Resort.

00:39:27.290 --> 00:39:30.480
And so if you specify that,
it will act as a terminator in

00:39:30.480 --> 00:39:32.550
the user fallback cascade list.

00:39:32.550 --> 00:39:36.180
And so you can detect that that's
occurred by checking the run

00:39:36.200 --> 00:39:42.510
attributes on the line and see
that that has been the case.

00:39:43.450 --> 00:39:46.280
Now, I did say that up until recently
you couldn't construct a font

00:39:46.280 --> 00:39:48.200
that covered all of Unicode.

00:39:48.250 --> 00:39:52.790
Well, Mountain Lion adds support
for a new ISO IEC standard

00:39:53.260 --> 00:39:56.240
for composite font references.

00:39:56.340 --> 00:40:00.880
And this is an XML standard or
XML specification that allows you to

00:40:00.890 --> 00:40:05.640
define a single font as being built
up of multiple component fonts.

00:40:05.710 --> 00:40:13.480
And there's a lot of attributes and
fine tuning that you can do on that.

00:40:13.480 --> 00:40:13.490
So if you have very,
very specific fallback functionality

00:40:13.490 --> 00:40:18.190
to be implemented on Mountain Lion,
you could check out the composite

00:40:18.190 --> 00:40:22.180
font DTD on the Mountain Lion install.

00:40:26.670 --> 00:40:31.560
A lot of you are embedding fonts
in your application bundle,

00:40:31.560 --> 00:40:38.500
most likely by sticking an OpenType
or TrueType font in your app bundle,

00:40:38.500 --> 00:40:41.880
maybe in the resources
directory or somewhere else.

00:40:42.000 --> 00:40:47.870
But some of you have noted that you've
talked to font vendors and the vendor

00:40:48.230 --> 00:40:52.600
has a licensing requirement that says
that they don't want you doing that.

00:40:52.600 --> 00:40:56.410
They don't want you to be able to just
put a font file in your bundle where

00:40:56.430 --> 00:41:00.400
someone could come along and just
snoop it and find it and take it out.

00:41:00.540 --> 00:41:04.900
And so I wanted to note that you
don't need fonts to be in their

00:41:04.900 --> 00:41:09.920
own files in order to activate
them for use in your application.

00:41:14.030 --> 00:41:15.200
Thank you.

00:41:15.290 --> 00:41:18.290
This has always been the case,
but we've added a lot

00:41:18.290 --> 00:41:21.490
of the permutations,
and so you should have a lot of

00:41:21.600 --> 00:41:23.240
flexibility in being able to do that now.

00:41:23.240 --> 00:41:31.210
So one example would be maybe you
want to take the font data and compile

00:41:31.210 --> 00:41:32.640
it into your application somehow.

00:41:32.640 --> 00:41:35.760
Or maybe you want to take a bunch of
font files and you want to splice them

00:41:35.830 --> 00:41:40.300
together into a single big file that
doesn't look like a font file on its own,

00:41:40.300 --> 00:41:46.730
but you know how to extract the
individual font pieces out of that.

00:41:46.970 --> 00:41:49.300
There's a number of ways to do this.

00:41:49.300 --> 00:41:52.440
Once you have found the data
for the font that you want to

00:41:52.840 --> 00:41:57.060
activate in your application,
one way to do it on Mountain Lion or

00:41:57.060 --> 00:42:00.800
iOS is to create a graphics font,
we call it,

00:42:00.800 --> 00:42:04.160
or a CG font ref with that data.

00:42:04.160 --> 00:42:07.580
And then in this particular example,
I'm going to register that

00:42:07.580 --> 00:42:11.070
graphics font using CT font
manager register graphics font.

00:42:11.110 --> 00:42:14.000
And by registering it,
what that does is it means that

00:42:14.000 --> 00:42:17.620
I can go ahead and access that
font using any of its names.

00:42:17.700 --> 00:42:20.880
So for instance,
if I could use CT font create with

00:42:20.880 --> 00:42:24.960
name using the PostScript name of
that particular font that I had

00:42:24.960 --> 00:42:27.270
registered and access it that way.

00:42:27.780 --> 00:42:29.800
Alternatively,
I could create a CT font directly

00:42:29.930 --> 00:42:33.310
from that graphics font using
CT font create with graphics font.

00:42:33.370 --> 00:42:37.020
And then on Lion or higher,
there's another option that

00:42:37.020 --> 00:42:41.220
you have which is to create a
font descriptor from that data.

00:42:41.380 --> 00:42:44.890
That's another way of doing this.

00:42:44.900 --> 00:42:50.400
It's a bit interesting
because by doing that,

00:42:50.420 --> 00:42:54.400
you make the font not
available via its names.

00:42:54.560 --> 00:42:58.560
You need to have that font descriptor on
hand in order to create a font from it.

00:42:58.560 --> 00:43:02.560
Same as if you had created a
CT font from the graphics font.

00:43:02.630 --> 00:43:06.660
So that way,
if you for some reason wanted to

00:43:06.660 --> 00:43:10.760
know exactly what part of your
code was making use of that font,

00:43:10.760 --> 00:43:13.180
then you'd have to hand
around this font descriptor,

00:43:13.180 --> 00:43:16.710
a reference to it, in order to be able to
create a font from it.

00:43:16.800 --> 00:43:23.300
: We do have some sample code which
we have posted for WWDC which has

00:43:23.300 --> 00:43:28.080
an application that demonstrates
one technique for doing this.

00:43:28.140 --> 00:43:31.550
It demonstrates having some
fonts that are bundled up,

00:43:31.610 --> 00:43:34.540
not in their own files,
but bundled up in an application,

00:43:34.540 --> 00:43:37.980
showing you how to activate that,
one way to activate it anyway,

00:43:38.160 --> 00:43:41.700
and also demonstrates using those
fonts in a user cascade list.

00:43:41.700 --> 00:43:44.370
So you can see both of
these last two slides,

00:43:44.680 --> 00:43:47.480
there's a code sample available
to you that you can pull

00:43:47.480 --> 00:43:48.820
down and take a look at.

00:43:48.820 --> 00:43:50.580
So emoji.

00:43:52.900 --> 00:43:59.040
Emoji are these great little graphics,
these images that are text,

00:43:59.150 --> 00:44:01.900
but they're also colorful and exciting.

00:44:01.900 --> 00:44:05.150
And people have really,
really gotten into emoji.

00:44:05.270 --> 00:44:08.950
Since they first appeared on iOS
and then were adapted to be part

00:44:08.950 --> 00:44:14.860
of the Unicode specification,
we've seen incredible adoption of these.

00:44:14.860 --> 00:44:19.220
I'm sure you've sent or received
a few of these guys yourself

00:44:19.440 --> 00:44:21.350
and many others besides.

00:44:21.360 --> 00:44:27.290
So, but there are a few notes to be
made when dealing with emoji.

00:44:28.060 --> 00:44:32.030
One is that we've ended up with
sort of a case of emoji soup.

00:44:32.090 --> 00:44:37.340
The problem that many people ran into
when first trying to make use of emoji,

00:44:37.340 --> 00:44:40.930
whether as a developer or as a user,
is that many of these emoji

00:44:40.930 --> 00:44:44.420
characters had been unified,
as they were called,

00:44:44.450 --> 00:44:46.990
with existing Unicode characters.

00:44:47.100 --> 00:44:50.740
So in this particular example,
if I had a document or a message

00:44:50.740 --> 00:44:53.910
or something where I sent it
to some other platform and

00:44:54.030 --> 00:44:59.000
opened it up and read it there,
I couldn't be guaranteed whether

00:44:59.000 --> 00:45:02.350
I would see the text representation,
the sort of black and white

00:45:02.430 --> 00:45:06.260
pictograph there on top,
or the emoji representation,

00:45:06.260 --> 00:45:12.950
which in Lion and iOS 5 was
a completely different glyph.

00:45:13.040 --> 00:45:15.740
So we have tweaked some things
to make some of these problematic

00:45:15.740 --> 00:45:17.000
glyphs more accessible.

00:45:17.000 --> 00:45:17.560
So we've done some of these
things to make some of these

00:45:17.560 --> 00:45:19.830
glyphs less problematic,
but there are still cases where you

00:45:19.830 --> 00:45:24.400
may need to programmatically identify
which particular representation of one

00:45:24.400 --> 00:45:27.770
of these unified characters you need.

00:45:28.180 --> 00:45:35.770
And so the solution specified by Unicode
is to define variation sequences.

00:45:36.660 --> 00:45:41.420
So these are essentially character
tags that you can apply that

00:45:41.580 --> 00:45:46.600
indicate that one of these particular
representations is to be preferred.

00:45:46.740 --> 00:45:51.950
And so if you simply sent
that heart character,

00:45:52.040 --> 00:45:55.750
you wouldn't be guaranteed
any particular appearance.

00:45:55.870 --> 00:46:00.500
In particular,
due to historical constraints,

00:46:00.600 --> 00:46:03.560
some platforms prefer
the text representation,

00:46:03.560 --> 00:46:08.000
some prefer the emoji-style presentation.

00:46:08.110 --> 00:46:11.700
But using a variation sequence
for this particular character,

00:46:11.780 --> 00:46:15.650
the middle example,
I've specified the text

00:46:15.770 --> 00:46:17.930
variation selector,
and so if possible,

00:46:18.040 --> 00:46:20.960
the system will give me
the text representation.

00:46:21.070 --> 00:46:25.200
And of course, the last example there is
the emoji-style presentation.

00:46:25.280 --> 00:46:32.210
And so... you can control that
using those variation sequences.

00:46:32.230 --> 00:46:36.680
And these are supported on
both Mountain Lion and iOS 6.

00:46:36.780 --> 00:46:42.690
In particular, some cases,
maybe your user interface

00:46:42.780 --> 00:46:47.620
designer had used a glyph as
part of a user interface element,

00:46:47.640 --> 00:46:51.020
and all of a sudden things
blew up when things changed due

00:46:51.020 --> 00:46:53.420
to the Unicode specification.

00:46:53.620 --> 00:46:57.330
And so in this case,
you can specify exactly what you need.

00:46:57.580 --> 00:47:01.840
When it comes to drawing color glyphs,
well, there's actually a -- you know,

00:47:01.840 --> 00:47:05.500
the font has to be different
in order to carry this color

00:47:05.500 --> 00:47:06.560
information around with it.

00:47:06.560 --> 00:47:14.960
And so simply using the lowest level
function in order to draw glyphs

00:47:14.960 --> 00:47:18.830
from that font is not going to work.

00:47:18.930 --> 00:47:22.050
But so basically, again,
it comes down to a case of using

00:47:22.050 --> 00:47:23.930
the highest level framework.

00:47:24.010 --> 00:47:26.730
If you're simply drawing
a string using AppKit,

00:47:26.740 --> 00:47:30.020
UIKit, whatever,
everything will work just fine.

00:47:30.140 --> 00:47:32.960
If you're using one of the
standard CT drawing functions,

00:47:32.960 --> 00:47:37.010
CT frame draw, line draw, run draw,
again, that will work just fine.

00:47:37.020 --> 00:47:43.110
You'll end up with the standard glyphs
or the color glyphs as necessary.

00:47:43.230 --> 00:47:48.220
But if you are drawing directly
into a CG context yourself,

00:47:48.340 --> 00:47:50.960
the solution is to use
CT font draw glyphs.

00:47:51.100 --> 00:47:52.240
You can use this on any font.

00:47:52.340 --> 00:47:53.940
It doesn't have to be a font with color.

00:47:53.960 --> 00:47:54.960
It's just a font that you can
use to show glyphs at positions.

00:47:54.960 --> 00:47:57.760
And so if you're drawing a color glyph,
this will do the right thing

00:47:57.760 --> 00:48:00.350
whether or not it's a black and
white glyph or a color glyph.

00:48:00.450 --> 00:48:01.220
So simply use that.

00:48:01.280 --> 00:48:06.180
It's analogous to that CG context
show glyphs at positions function.

00:48:06.430 --> 00:48:08.920
And you'll get the correct behavior.

00:48:11.010 --> 00:48:17.240
You might also have instances where
your font is displaying text using

00:48:17.240 --> 00:48:20.210
some fancy graphical treatment.

00:48:20.210 --> 00:48:25.650
And that treatment may not work properly
in the presence of color glyphs.

00:48:25.760 --> 00:48:30.940
And so if you need to identify
that a glyph itself has color data,

00:48:30.940 --> 00:48:35.840
you can do so by consulting
the CT font symbolic traits.

00:48:35.950 --> 00:48:40.470
And if a font supports color glyphs,
then you can check for an individual

00:48:40.470 --> 00:48:44.380
glyph whether or not it has an outline,
and the absence of an outline

00:48:44.380 --> 00:48:47.760
would signify a color glyph.

00:48:48.280 --> 00:48:55.570
So speaking of drawing into a CG context,
another question that comes up is, well,

00:48:55.660 --> 00:49:01.640
how do I have control over the
drawing parameters for that context?

00:49:01.780 --> 00:49:04.750
So as I mentioned,
Core Text was designed to

00:49:04.750 --> 00:49:06.860
be easily interoperable,
you know,

00:49:06.860 --> 00:49:12.870
directly accessible for use with
CG context drawing if necessary.

00:49:13.200 --> 00:49:17.660
So one instance might be you
have some sort of fancy display

00:49:17.760 --> 00:49:22.960
where you need to stroke the
glyphs with different parameters.

00:49:23.010 --> 00:49:27.820
You might do it once in one stroke width
and then again with another stroke width.

00:49:27.940 --> 00:49:30.650
But you want to reuse those glyphs,
that layout,

00:49:30.740 --> 00:49:33.220
between both those drawing operations.

00:49:33.320 --> 00:49:35.740
And you say, well, gee,
I don't want to have to specify a

00:49:35.740 --> 00:49:39.000
different string attribute and then
get a new line and draw it all.

00:49:39.000 --> 00:49:41.500
Well, that's not necessary.

00:49:41.660 --> 00:49:46.220
So the goal here is that Core Text should
only set what it needs to.

00:49:46.350 --> 00:49:49.740
And it should respect
what was otherwise set.

00:49:49.870 --> 00:49:51.920
So let me explain what that means.

00:49:52.040 --> 00:49:56.780
So most string attributes correspond
to a particular drawing parameter.

00:49:56.880 --> 00:50:01.280
That is,
there's a stroke width string attribute.

00:50:01.360 --> 00:50:06.210
And if you've specified that,
it should take precedence over

00:50:06.220 --> 00:50:10.580
whatever was set in that CG context
that you're going to draw into.

00:50:10.700 --> 00:50:14.820
But if it's absent,
and since it's defined as being unset,

00:50:14.820 --> 00:50:17.800
it doesn't affect the drawing
parameter for the stroke width,

00:50:17.920 --> 00:50:23.120
then you should be able to specify that
directly as a context drawing parameter.

00:50:23.210 --> 00:50:25.440
And then make sure that that
attribute isn't present in the

00:50:25.440 --> 00:50:26.850
string that you're laying out.

00:50:26.980 --> 00:50:29.660
And so that way you can
set it to your first value,

00:50:29.720 --> 00:50:31.040
draw the string,
and then set it to the next

00:50:31.070 --> 00:50:31.980
value and draw the string.

00:50:31.980 --> 00:50:35.570
And Core Text will respect that because,
of course, it's just drawing through

00:50:35.570 --> 00:50:36.760
Core Graphics itself.

00:50:36.850 --> 00:50:40.600
But that way you have very
fine-grained control over what

00:50:40.600 --> 00:50:42.850
is getting set in that context.

00:50:42.860 --> 00:50:46.860
One exception to the rule, of course,
is the foreground color.

00:50:46.870 --> 00:50:52.350
As was mentioned in the
Attributed Strings introduction

00:50:52.380 --> 00:50:55.950
just previous to this session,
that attribute has a

00:50:55.950 --> 00:50:58.130
default value of black.

00:50:58.560 --> 00:51:04.500
And so if you want to modify the
foreground color between drawing a line,

00:51:04.500 --> 00:51:07.780
then of course you'll need
to specify foreground color

00:51:07.790 --> 00:51:09.780
from context attribute name.

00:51:09.810 --> 00:51:12.800
It takes a Boolean,
and when that's set to true,

00:51:12.830 --> 00:51:16.800
Core Text will not touch that
drawing parameter either.

00:51:17.190 --> 00:51:19.800
Finally, one more oldie but goodie.

00:51:20.020 --> 00:51:22.770
Core Text will not synthesize
missing font styles.

00:51:22.800 --> 00:51:27.790
And by missing, I mean you might expect,
coming from other platforms

00:51:27.900 --> 00:51:31.260
or older technologies,
that you can simply request a

00:51:31.270 --> 00:51:35.800
bold font and get a bold version
of whatever font you're using.

00:51:35.800 --> 00:51:39.930
Well, Core Text has always taken the
approach that it should prefer the

00:51:39.930 --> 00:51:42.740
information given to it by the font.

00:51:42.740 --> 00:51:44.720
If the designer hasn't gone
to the trouble of drawing

00:51:44.720 --> 00:51:47.800
a bold version of the font,
then Core Text is not going

00:51:47.800 --> 00:51:53.180
to take it upon itself to try
to make the plain weight bold.

00:51:53.300 --> 00:51:58.480
There are some developers who need
to be able to bold arbitrary fonts.

00:51:58.620 --> 00:52:03.100
Perhaps they have some document format
that requires that they indicate

00:52:03.100 --> 00:52:06.040
a bold font or some other reason.

00:52:06.230 --> 00:52:12.340
You can certainly implement your own
synthetic styles in your application,

00:52:12.480 --> 00:52:16.540
but this is something that Core Text is
still not going to ever do.

00:52:16.730 --> 00:52:20.180
One approach for instance for
synthesizing an italic would be to

00:52:20.210 --> 00:52:24.820
simply skew the font matrix and that
would give you a slanted appearance,

00:52:24.820 --> 00:52:27.440
not a true italic appearance,
but that might be one way.

00:52:27.540 --> 00:52:31.440
For bolding,
there's really no one panacea.

00:52:31.440 --> 00:52:33.200
There's no one great way of doing that.

00:52:33.340 --> 00:52:35.880
So of course if you need
any more information,

00:52:36.280 --> 00:52:40.570
there are a number of nice links here
to Jake Behrens who is the evangelist.

00:52:40.660 --> 00:52:44.850
He can help you locate information if
you're having a hard time with that.

00:52:44.970 --> 00:52:47.770
Otherwise, of course,
there's the standard documentation,

00:52:47.770 --> 00:52:49.670
interface guidelines.

00:52:49.770 --> 00:52:54.250
Developer Forum is a very,
very helpful resource for finding

00:52:54.400 --> 00:52:58.570
out from your peer developers how
to make use of this technology more

00:52:58.580 --> 00:53:01.800
effectively and also Apple engineers.

00:53:02.290 --> 00:53:06.060
Again, very,
very interesting stuff given in the

00:53:06.070 --> 00:53:09.300
UI kit sessions on Attributed Strings.

00:53:09.300 --> 00:53:12.240
You will have already missed
the introduction to Attributed

00:53:12.240 --> 00:53:15.430
Strings session as it's passed now,
but you'll be able to

00:53:15.440 --> 00:53:17.720
catch it on tape delay,
I'm sure.

00:53:17.720 --> 00:53:21.080
Also the advanced Attributed
Strings session is going on

00:53:21.080 --> 00:53:24.720
tomorrow morning at 10:15,
so I urge you to check that out.

00:53:24.720 --> 00:53:28.160
There's going to be some really
neat stuff discussed there.

00:53:28.160 --> 00:53:29.840
And with that,
I'd say thank you very much and have

00:53:29.840 --> 00:53:31.160
a wonderful rest of the conference.
WEBVTT

00:00:11.020 --> 00:00:12.500
Good morning.

00:00:12.600 --> 00:00:16.340
I'm Ian Baird, label engineer for UIKit.

00:00:16.370 --> 00:00:20.980
And today I'm going to talk to you
about advanced attributed strings

00:00:20.980 --> 00:00:26.810
for iOS or how to achieve desktop
class effects on a mobile device.

00:00:26.810 --> 00:00:29.900
Let's get started.

00:00:30.410 --> 00:00:33.000
Today we're going to
talk about three things.

00:00:33.150 --> 00:00:36.340
The first one is advanced attributes.

00:00:36.380 --> 00:00:40.910
If you attended yesterday's introduction
to attributed strings for iOS talk,

00:00:41.090 --> 00:00:44.180
you learned about some
of the basic attributes.

00:00:44.750 --> 00:00:47.040
and today we're going to talk about more,
of course.

00:00:47.250 --> 00:00:51.240
Next, we're going to talk about how to
employ some of those attributes along

00:00:51.240 --> 00:00:56.470
with attributed strings to achieve
awesome text effects for your app.

00:00:59.320 --> 00:01:03.740
And then we're going to talk a little bit
about the Extended String Drawing API,

00:01:03.740 --> 00:01:07.470
or more specifically,
NSStringDrawingContext and

00:01:07.570 --> 00:01:09.950
NSStringDrawingOptions.

00:01:10.420 --> 00:01:12.590
So, let's get started.

00:01:12.650 --> 00:01:15.050
Advanced Attributes.

00:01:15.310 --> 00:01:17.410
Yesterday,
Aki talked about some of the common

00:01:17.470 --> 00:01:20.600
attributes you would use when
customizing an attributed string.

00:01:21.470 --> 00:01:26.300
I believe the first attribute he
talked about was NSFontAttributeName.

00:01:26.400 --> 00:01:28.840
As you can see,
we've changed our example text

00:01:28.890 --> 00:01:33.290
from using the system default font,
which in this case was Helvetica Noia,

00:01:33.400 --> 00:01:37.910
to Heffler text using
the NSFontAttributeName.

00:01:38.510 --> 00:01:43.090
also talked about how you could customize
the color that we rendered the text in

00:01:43.090 --> 00:01:46.780
using NS foreground color attribute name.

00:01:47.390 --> 00:01:50.140
We talked about NS paragraph
style attribute name and

00:01:50.140 --> 00:01:51.100
some of the properties.

00:01:51.250 --> 00:01:54.200
I'll call out a couple right now.

00:01:54.310 --> 00:01:57.730
The first one we talked about was...

00:01:58.180 --> 00:02:01.830
The alignment property,
which allows you to affect the alignment

00:02:02.270 --> 00:02:03.980
that we use to render the text.

00:02:04.140 --> 00:02:08.970
In this case, we've gone from center
aligned to left aligned.

00:02:09.830 --> 00:02:12.390
Next,
we talked about the line break mode,

00:02:12.390 --> 00:02:17.340
which allows you to affect
truncation and word wrapping.

00:02:17.340 --> 00:02:20.840
We have allowed the text to
word wrap in this case using

00:02:21.130 --> 00:02:23.880
NS paragraph style line break mode.

00:02:23.880 --> 00:02:27.840
So let's dive in.

00:02:30.500 --> 00:02:35.070
The first advanced attribute I want
to talk to you about today is,

00:02:35.260 --> 00:02:37.600
in my opinion, one of the coolest.

00:02:37.710 --> 00:02:42.560
It allows you to apply an outline to
the glyphs we use to strike your text.

00:02:42.690 --> 00:02:45.910
So let's talk a bit about
NSStrokeColorAttributeName

00:02:46.090 --> 00:02:49.500
and its partner,
NSStrokeWithAttributeName.

00:02:49.600 --> 00:02:55.230
You can use them to achieve really
cool effects in your app like this.

00:02:55.670 --> 00:03:01.050
This was done by setting NS foreground
color attribute name to yellow,

00:03:01.050 --> 00:03:03.080
which filled the glyphs
with a yellow color,

00:03:03.310 --> 00:03:07.630
while setting NS stroke color
attribute name to black.

00:03:08.240 --> 00:03:13.800
Now, there are a few points to remember
about NSStroke with attribute name.

00:03:13.800 --> 00:03:15.810
We're going to go through them.

00:03:17.140 --> 00:03:21.040
If you supply a positive width,
you're only going to get

00:03:21.040 --> 00:03:22.920
an outline on your glyph.

00:03:25.590 --> 00:03:29.720
If you supply a negative width,
we're going to stroke

00:03:29.720 --> 00:03:31.830
and fill your glyph.

00:03:32.800 --> 00:03:36.520
And if you don't supply a value,
if you leave it nil,

00:03:36.610 --> 00:03:38.510
you're only going to get a filled glyph.

00:03:38.630 --> 00:03:41.720
We're not actually going
to outline the glyph.

00:03:43.540 --> 00:03:46.950
Another really cool attribute
that I'd like to talk to you about

00:03:46.950 --> 00:03:49.060
today is NSShadowAttributeName.

00:03:49.400 --> 00:03:51.810
This is also new in iOS 6.

00:03:52.020 --> 00:03:55.940
It allows you to do cool things
like apply a drop shadow to

00:03:55.940 --> 00:03:57.260
some or all of your text.

00:03:57.260 --> 00:03:59.540
You can see what this has
done to the text here.

00:03:59.540 --> 00:04:04.050
It makes it appear to lift off the page,
which is really, really cool.

00:04:04.170 --> 00:04:06.200
So how did we do this?

00:04:06.320 --> 00:04:11.140
Well,
we brought over NSShadow from Mac OS.

00:04:11.920 --> 00:04:14.680
If you've ever used an
eyeshadow on Mac OS,

00:04:14.680 --> 00:04:17.900
you know that it can
participate in drawing,

00:04:17.900 --> 00:04:21.030
and you can set it on a graphics
context to set up a shadow.

00:04:21.280 --> 00:04:23.720
This is not the case on iOS.

00:04:23.830 --> 00:04:26.230
iOS uses a declarative model.

00:04:26.350 --> 00:04:29.700
So it's only used with
attributed strings.

00:04:29.870 --> 00:04:31.210
We set up the shadow for you.

00:04:31.290 --> 00:04:33.190
We interpret the value.

00:04:33.230 --> 00:04:35.870
So it's only a value class on iOS.

00:04:35.980 --> 00:04:39.790
But there are some really cool
customizations you can do.

00:04:39.890 --> 00:04:42.190
The first one being the shadow color.

00:04:42.350 --> 00:04:46.350
You can change the color we
use to render the shadow.

00:04:48.850 --> 00:04:54.100
Next, you can change the shadow offset by
supplying a CG size to the shadow offset

00:04:54.220 --> 00:04:57.500
property of the NSShadow instance.

00:04:58.050 --> 00:05:00.660
And finally,
you can change the shadow blur radius.

00:05:00.930 --> 00:05:04.350
Notice we've supplied a larger
value to shadow blur radius,

00:05:04.350 --> 00:05:07.590
which has caused the
shadow to appear to soften.

00:05:09.000 --> 00:05:12.790
Now, I know this is a big one for me
and the designers in the crowd.

00:05:13.100 --> 00:05:17.700
In iOS 6,
we now support proper text kerning.

00:05:22.240 --> 00:05:25.620
I know we did it before in Cortex,
but now we've brought it up to the

00:05:25.620 --> 00:05:28.130
level of UIKit and attributed string.

00:05:28.410 --> 00:05:31.600
This is done with NSKern attribute name.

00:05:31.830 --> 00:05:35.940
As you can see here in our example,
we have changed our run

00:05:35.950 --> 00:05:37.580
of text to TwinVauses.

00:05:37.910 --> 00:05:40.870
And the reason we've done this is
because it highlights a problem that

00:05:40.930 --> 00:05:42.810
you can currently see in the system.

00:05:42.940 --> 00:05:46.540
Notice that the words "twin" and
"vauses" appear to have split

00:05:46.540 --> 00:05:48.550
off their beginning characters.

00:05:48.700 --> 00:05:52.640
The word "t" does not appear to be
attached to "twin" and "v" does not

00:05:52.670 --> 00:05:58.380
appear to be attached to "vauses." Well,
we can fix this by turning

00:05:59.020 --> 00:06:02.290
on auto-kerning like this.

00:06:02.410 --> 00:06:05.070
Notice the "t" and the "w"

00:06:08.010 --> 00:06:13.500
have properly hugged together,
and we fixed the issue of an improper

00:06:13.500 --> 00:06:16.950
distribution of horizontal space.

00:06:17.980 --> 00:06:20.720
So let's talk a bit more about
some of the values you can

00:06:20.720 --> 00:06:23.720
supply to NSCurrentAttributeName.

00:06:24.300 --> 00:06:28.800
Now, it's important to remember that
kerning will vary from font to font.

00:06:28.940 --> 00:06:32.920
For example,
Heffler text may define kerning pairs

00:06:33.170 --> 00:06:36.670
which are not present in Helvetic Innoi.

00:06:37.650 --> 00:06:44.020
You can enable auto-kerning by not
supplying a value or using null.

00:06:44.940 --> 00:06:49.480
You can disable kerning by supplying the
zero value to NSKern attribute name if

00:06:49.670 --> 00:06:54.390
you need to turn it off for some reason,
such as to match WebKit rendering.

00:06:55.020 --> 00:06:59.420
and any other value is going
to adjust the kerning by the

00:06:59.420 --> 00:07:02.130
specified number of points.

00:07:02.500 --> 00:07:07.500
In our example,
we've set up an auto-kerned run of text,

00:07:07.500 --> 00:07:08.810
the big red dog.

00:07:09.370 --> 00:07:13.650
Let's see what happens when
we supply a positive value.

00:07:13.810 --> 00:07:16.410
Notice that the text has loosened.

00:07:16.790 --> 00:07:18.540
Let's tighten it up.

00:07:18.630 --> 00:07:21.730
We use a negative value
to tighten the text.

00:07:21.840 --> 00:07:24.570
That's NS Kern attribute name.

00:07:25.610 --> 00:07:30.650
Another really cool attribute we have
in iOS 6 makes its way to us from

00:07:30.790 --> 00:07:33.200
the world of classical typography.

00:07:33.320 --> 00:07:38.040
In the type case,
you may have had one or more glyphs

00:07:38.120 --> 00:07:45.100
stacked together that when looked at
did not appear to be naturally balanced.

00:07:45.150 --> 00:07:46.770
For example, FI.

00:07:46.780 --> 00:07:52.140
Now in iOS 6,
you can turn on default ligatures and

00:07:52.160 --> 00:07:58.360
will start to substitute these two
glyphs with their ligature glyphs.

00:07:58.560 --> 00:08:03.660
For example, FI is substituted by
the FI ligature glyph.

00:08:03.950 --> 00:08:10.610
We have FF, FL,
now we're getting cool here, FFI.

00:08:11.020 --> 00:08:14.290
and for what I like to term
the flying buttress effect,

00:08:14.290 --> 00:08:17.240
we have the FFL ligature.

00:08:17.430 --> 00:08:18.960
Cool, huh?

00:08:21.030 --> 00:08:23.670
So I've talked a bit about
some of the beautiful,

00:08:23.670 --> 00:08:27.490
very designy sort of attributes,
and now I want to talk about one that

00:08:27.490 --> 00:08:32.000
I consider to be a bit more utilitarian,
NSBackgroundColorAttributeName.

00:08:32.000 --> 00:08:34.870
You may think it's redundant
since you can specify the

00:08:34.870 --> 00:08:39.310
background color of a label,
you could always use a UI rect fill

00:08:39.480 --> 00:08:42.600
to color the bounds of this app.

00:08:42.600 --> 00:08:43.800
But that's not the case.

00:08:43.800 --> 00:08:46.300
Imagine if you want to
achieve a selection effect.

00:08:46.300 --> 00:08:50.100
You want to get the color to
wrap very closely to the text.

00:08:50.130 --> 00:08:53.920
Well, one way we could achieve this is
to supply a light blue color to

00:08:53.920 --> 00:08:58.890
NSBackgroundColorAttributeName,
which will very nicely highlight

00:08:58.890 --> 00:09:01.020
along the lines of text.

00:09:06.780 --> 00:09:11.870
Sometimes it is advantageous to be able
to underline all or some of your text,

00:09:11.880 --> 00:09:16.550
and you're going to use NS_style
attribute name to achieve this.

00:09:19.300 --> 00:09:26.460
Next, another somewhat useful -- I hate
to call anything somewhat useful,

00:09:26.460 --> 00:09:31.560
but it's good to have it when you need
it sort of attribute in your grab bag of

00:09:31.630 --> 00:09:35.060
tools is NSStrikeThruStyleAttributeName.

00:09:35.060 --> 00:09:40.230
Pretend I have a friend named Kyle,
and we're talking about his dog here,

00:09:40.230 --> 00:09:41.160
Landis.

00:09:41.160 --> 00:09:44.970
And this dog is incredibly lazy,
but I've offended him by putting

00:09:45.090 --> 00:09:47.060
this out here in front of all of you.

00:09:47.060 --> 00:09:51.060
And I want to show him that I have
redacted this text from the document.

00:09:51.210 --> 00:09:55.730
Well, I would achieve this using
NSStrikeThruStyleAttributeName.

00:09:55.870 --> 00:09:58.010
Notice how the text is redacted.

00:09:58.320 --> 00:10:03.620
We used NSForegroundColorAttributeName
to also turn this little run of text red.

00:10:03.780 --> 00:10:06.140
So now he's not mad at me.

00:10:08.930 --> 00:10:12.370
So Aki talked yesterday
about NS paragraph style and

00:10:12.370 --> 00:10:13.580
a bunch of the properties.

00:10:13.840 --> 00:10:17.890
The first one that I want to talk to
you about today are some properties that

00:10:17.890 --> 00:10:20.700
allow you to control the line height.

00:10:22.910 --> 00:10:25.140
I'm going to start by talking
about the minimum line height

00:10:25.250 --> 00:10:27.210
and maximum line height property.

00:10:27.330 --> 00:10:29.840
The reason I'm talking about
them at the same time is they're

00:10:29.840 --> 00:10:32.300
usually set to the same value.

00:10:32.860 --> 00:10:35.550
What they're going to control
is they're actually going to

00:10:35.610 --> 00:10:40.800
control the line fragment height
that we use to render your text.

00:10:40.970 --> 00:10:42.800
And this is going to move the baseline.

00:10:42.800 --> 00:10:46.240
We're actually going to adjust
the ascender proportionally

00:10:46.240 --> 00:10:47.800
to the value that you give us.

00:10:47.800 --> 00:10:50.270
So we're going to move your text.

00:10:50.930 --> 00:10:57.260
And you can see an example of where we've
used this in iOS 6 in the Stocks app.

00:10:57.310 --> 00:10:59.740
Notice that these cells
are not very tall,

00:10:59.740 --> 00:11:03.170
and it would be difficult if we used
the natural line height of the font

00:11:03.450 --> 00:11:06.300
to fit all of the text in the cell.

00:11:06.390 --> 00:11:11.260
So the Stocks team set up minimum
line height and maximum line height

00:11:11.390 --> 00:11:14.810
to a value that was less than the
natural line height of the font,

00:11:14.910 --> 00:11:17.200
achieving this effect.

00:11:18.620 --> 00:11:20.570
The next value I want
to talk to you about,

00:11:20.570 --> 00:11:23.410
or the next property,
is another one that comes to us really

00:11:23.410 --> 00:11:26.660
from the world of classical typography,
which is why you can see

00:11:26.660 --> 00:11:27.940
a type case next to it.

00:11:28.050 --> 00:11:31.970
And it controls the gap between lines.

00:11:32.500 --> 00:11:34.400
is a professor at the
University of Michigan.

00:11:34.400 --> 00:11:37.300
He's been working on a new
project called Line Spacing.

00:11:37.300 --> 00:11:39.710
The reason I talk about
classical typography,

00:11:39.710 --> 00:11:42.040
again,
is you have to remember there used to be

00:11:42.060 --> 00:11:45.850
thin strips of lead that would separate
the rows of glyphs in the type case,

00:11:45.850 --> 00:11:48.810
and this was called leading,
also known as line spacing.

00:11:48.870 --> 00:11:51.650
So when you're interacting
with your developer and she

00:11:51.650 --> 00:11:55.200
starts going on about leading,
you now know what you need to adjust.

00:11:55.200 --> 00:11:57.490
Now,
since we are in the world of computers,

00:11:57.490 --> 00:11:59.800
we can actually have
negative line spacing,

00:11:59.800 --> 00:12:00.230
which will cause the lines to overlap.

00:12:01.780 --> 00:12:07.460
and this value is going to be included
in your line fragment heights.

00:12:07.560 --> 00:12:09.620
So, let's see how it works.

00:12:09.720 --> 00:12:14.020
We're going to supply a
value of 30 to line spacing,

00:12:14.040 --> 00:12:17.880
which is going to give 30
points of vertical distance

00:12:17.880 --> 00:12:19.810
between these two lines.

00:12:21.790 --> 00:12:25.490
Talking more about spacing,
you can also affect interparagraph

00:12:25.490 --> 00:12:28.760
spacing by setting a value
on paragraph spacing.

00:12:28.950 --> 00:12:33.200
So you can see in this case,
we've added 30 points of distance

00:12:33.200 --> 00:12:35.650
between the two paragraphs.

00:12:38.180 --> 00:12:42.000
If you want to affect the amount of
space which precedes the paragraph,

00:12:42.020 --> 00:12:44.220
you can set up paragraph spacing before.

00:12:44.500 --> 00:12:48.910
Again, in our example,
we've given it a value of 30.

00:12:50.960 --> 00:12:53.630
If you want left and
right margin control,

00:12:53.780 --> 00:12:56.760
you can use the head and
tail indent properties.

00:12:56.920 --> 00:12:59.600
We'll talk about head
indent a little bit.

00:12:59.900 --> 00:13:04.600
You can see again we've set up a left
margin of 30 by changing the head

00:13:04.600 --> 00:13:07.670
and end value of the paragraph style.

00:13:08.110 --> 00:13:14.260
And you can change the right margin
by supplying a value to tail and end.

00:13:14.400 --> 00:13:18.830
In this case, it's negative because we're
telling it how many points to

00:13:18.830 --> 00:13:21.470
come away from the right margin.

00:13:23.410 --> 00:13:27.850
So, Aki talked yesterday a bit about the
Reminders group and some of the stuff

00:13:27.950 --> 00:13:32.070
that they did to achieve some of the text
effects in the Reminders application.

00:13:32.220 --> 00:13:35.720
If you've used Reminders on iOS 6,
you'll notice that there's

00:13:35.720 --> 00:13:38.860
a priority glyph often on
the first line of the text.

00:13:38.990 --> 00:13:42.260
The way they achieved this effect,
the way they were able to knock

00:13:42.260 --> 00:13:46.440
over that first line of text was
by customizing the first line head

00:13:46.440 --> 00:13:49.950
indent property of NSParagraphStyle.

00:13:52.870 --> 00:13:54.390
Let's talk a bit about hyphenation.

00:13:54.640 --> 00:14:00.620
You can control hyphenation by
customizing the hyphenation factor

00:14:00.690 --> 00:14:04.190
property of NS paragraph style.

00:14:07.050 --> 00:14:10.410
You can see here in our example,
it's been disabled and we've

00:14:10.500 --> 00:14:12.000
supplied a value of zero.

00:14:12.070 --> 00:14:13.310
This is the default.

00:14:13.560 --> 00:14:19.140
And you can see in our text,
we have a very, very tight bounding box,

00:14:19.220 --> 00:14:24.240
which has caused the layout to become,
unfortunately, unbalanced vertically.

00:14:24.350 --> 00:14:29.470
So if we supply the value 1,
you'll notice we now break

00:14:29.620 --> 00:14:31.810
lengthwise using a hyphen.

00:14:31.900 --> 00:14:36.010
This appears to be more
vertically balanced in this case.

00:14:37.680 --> 00:14:40.230
So all of these things are very cool,
and you may be asking,

00:14:40.300 --> 00:14:42.230
how do I use these guys in my app?

00:14:42.330 --> 00:14:44.260
Well, we talked about that a
little bit yesterday.

00:14:44.450 --> 00:14:47.600
The whole UI label is
the nexus of power talk.

00:14:47.730 --> 00:14:49.600
And that really hasn't changed.

00:14:49.720 --> 00:14:52.870
As you can see here,
we have a table view cell with a label,

00:14:53.000 --> 00:14:56.540
and this is only one label which
bears an attributed string.

00:14:56.600 --> 00:15:00.100
The attributed string is
specifying a bold font for the

00:15:00.300 --> 00:15:04.030
word "Appleseed." In the past,
this would have taken two labels

00:15:04.060 --> 00:15:07.670
to achieve or some custom drawing,
and it would have been really

00:15:07.670 --> 00:15:11.960
difficult to get the spacing between
the N and capital A glyphs correct.

00:15:13.530 --> 00:15:19.730
UI Text Field also takes an
attributed string now in the

00:15:19.730 --> 00:15:19.730
Attributed Text property.

00:15:20.120 --> 00:15:25.240
and even UI TextView takes an attributed
string in the attributed text property

00:15:25.590 --> 00:15:31.170
and allows users to interact with the
attributes and customize them themselves.

00:15:36.840 --> 00:15:46.240
UI Button can render
an attributed string.

00:15:46.240 --> 00:15:49.620
And as you saw yesterday,
Pickerview Caliente has been

00:15:49.620 --> 00:15:49.620
enhanced to show attributed strings.

00:15:50.670 --> 00:15:56.100
There are a few caveats to remember when
using attributed strings with UIKit.

00:15:56.210 --> 00:15:59.200
And Aki talked about
default values yesterday.

00:15:59.200 --> 00:16:02.920
UIKit will supply different
default values when you're using

00:16:03.020 --> 00:16:06.660
attributed strings with label,
for example.

00:16:07.020 --> 00:16:12.710
We're going to specify where you
don't specify an NS font attribute

00:16:13.080 --> 00:16:18.520
name with using UI font system
default font size and using the

00:16:18.670 --> 00:16:21.620
default font size for the widget.

00:16:21.730 --> 00:16:27.690
In this case, in iOS 6,
UI label will specify 17 points.

00:16:29.260 --> 00:16:31.980
We're also going to specify
NS foreground color attribute

00:16:32.040 --> 00:16:34.950
name where you do not specify one,
and we're going to

00:16:34.950 --> 00:16:36.550
supply the black color.

00:16:37.410 --> 00:16:39.800
We're also going to turn off kerning.

00:16:39.820 --> 00:16:42.110
The rest of the text system
does not use kerning.

00:16:42.110 --> 00:16:43.700
The rest of the system
does not use kerning.

00:16:43.700 --> 00:16:45.400
WebKit does not use kerning.

00:16:45.480 --> 00:16:48.900
So you should really only use it
in cases where you have like a

00:16:48.900 --> 00:16:53.230
designer spec that says you need to
adjust the kerning for your labels.

00:16:53.860 --> 00:16:57.280
We're also going to turn off ligatures,
again,

00:16:57.410 --> 00:17:02.370
in the aim of achieving system-wide
text rendering consistency.

00:17:02.880 --> 00:17:04.930
So let me show you how
all this stuff is used.

00:17:05.130 --> 00:17:08.270
You may have seen this table
view very quickly yesterday

00:17:08.670 --> 00:17:10.400
during our introductory talk.

00:17:10.440 --> 00:17:13.530
I want to show you how we put it
together today and what customizations

00:17:13.530 --> 00:17:15.570
we made to achieve these effects.

00:17:15.740 --> 00:17:19.300
First off,
I'll show you the fancy header.

00:17:19.350 --> 00:17:24.800
You'll notice that we've achieved this
effect by supplying an NS attributed

00:17:24.800 --> 00:17:29.380
string instance to the attributed
text property of the text label of

00:17:29.380 --> 00:17:32.780
UI table view header footer view,
which is new in iOS 6.

00:17:32.780 --> 00:17:33.960
Thanks.

00:17:34.670 --> 00:17:38.840
We've also given this a gray drop shadow,
which makes the text appear

00:17:38.840 --> 00:17:43.170
to sort of pop off of the
grouped table view background.

00:17:43.900 --> 00:17:48.830
Next, you'll notice Twyla Brown's name
would be inappropriately kerned if

00:17:48.830 --> 00:17:51.890
we had just let the system render it.

00:17:51.990 --> 00:17:57.530
So we've adjusted NSKernAttributeName
by supplying the value null there.

00:17:57.530 --> 00:18:02.990
And notice the T and
W glyphs are nicely kerned.

00:18:07.440 --> 00:18:10.620
Next, in Susie Griffin's name,
you'll notice we have that

00:18:10.630 --> 00:18:14.530
beautiful FFI ligature,
and we've done this by enabling

00:18:14.530 --> 00:18:17.570
ligatures in our attributed string.

00:18:19.130 --> 00:18:25.790
Continuing on, Aki talked yesterday about
the basic NSStringDrawing API,

00:18:25.800 --> 00:18:30.240
the simple methods draw in rect,
draw at point, and size.

00:18:30.380 --> 00:18:34.770
Today we're going to talk about the
extended drawing and sizing methods,

00:18:34.770 --> 00:18:37.810
draw with rect,
and bounding rect with size.

00:18:38.830 --> 00:18:42.270
The extended NSStringDrawing
API is important because it gives

00:18:42.270 --> 00:18:47.500
you additional drawing and sizing
capabilities over the simple APIs.

00:18:47.620 --> 00:18:51.580
You can specify baseline versus
line fragment origin layouts,

00:18:51.580 --> 00:18:54.040
and we're going to talk
more about that later.

00:18:54.140 --> 00:18:58.690
And you can also give us a constraining
size by specifying a width and a

00:18:58.690 --> 00:19:01.480
height in the rect that you pass to us.

00:19:01.820 --> 00:19:05.130
So, let's dive right into
NSStringDrawing options.

00:19:05.290 --> 00:19:08.540
If you've ever worked with
NSStringDrawing on the Mac,

00:19:08.570 --> 00:19:09.840
you may know a few of these already.

00:19:09.840 --> 00:19:13.930
I'll tell you about the ones that we
brought over from the Mac to iOS 6.

00:19:14.000 --> 00:19:15.740
I have a few supported values.

00:19:15.850 --> 00:19:21.280
The first one is NSStringDrawing
uses line fragment origin.

00:19:21.740 --> 00:19:26.400
We also support NSStringDrawing,
Truncate's last visible line.

00:19:26.540 --> 00:19:28.740
And NSStringDrawing uses font-letting.

00:19:28.820 --> 00:19:30.590
We're not going to talk
much about that today,

00:19:30.890 --> 00:19:33.430
but I'm told by my
colleagues that it's very,

00:19:33.540 --> 00:19:37.020
very useful when dealing
with Asian fonts.

00:19:39.100 --> 00:19:43.760
You can specify multiple options
because these guys are bit masks.

00:19:43.760 --> 00:19:47.150
So, for example,
if I want to truncate the last visible

00:19:47.510 --> 00:19:52.880
line and use the line fragment origin,
I can just or together and a string

00:19:53.160 --> 00:20:01.080
drawing truncates last visible line and a
string drawing uses line fragment origin

00:20:01.080 --> 00:20:03.120
and supply that as the options parameter
in my extended string drawing method.

00:20:03.700 --> 00:20:07.760
So, let's talk a bit about
line fragment origin.

00:20:07.870 --> 00:20:12.140
So, the origin of the rect is going to
determine where rendering begins,

00:20:12.220 --> 00:20:14.670
where we're going to start the pen.

00:20:16.400 --> 00:20:19.120
So in Draw with Rect,
we're going to take the

00:20:19.120 --> 00:20:22.070
Rect origin attribute,
which is a CG point,

00:20:22.200 --> 00:20:23.790
and start from there.

00:20:23.870 --> 00:20:27.530
But we're going to interpret it
differently based on the flags that you

00:20:27.530 --> 00:20:29.540
pass in Anna's string drawing options.

00:20:29.670 --> 00:20:33.890
For example, we're going to talk about
baseline rendering first.

00:20:34.430 --> 00:20:36.590
This is when the origin
is at the baseline.

00:20:36.600 --> 00:20:40.080
You see we have this nice run of text,
and we're taking the origin that

00:20:40.080 --> 00:20:43.800
you gave us and considering it to
be at the beginning of the baseline.

00:20:43.930 --> 00:20:48.300
This is the default mode for
the extended string drawing API.

00:20:48.470 --> 00:20:51.830
And it's usually used with
a single line of text.

00:20:52.710 --> 00:20:56.900
and in this case,
NSStringDrawing uses line fragment

00:20:56.980 --> 00:20:59.500
origin is not going to be set.

00:21:00.700 --> 00:21:02.720
Let's talk about when you do set it,
though.

00:21:02.820 --> 00:21:05.120
You can see we have a
couple of lines of text,

00:21:05.150 --> 00:21:08.720
a couple of line fragments,
and our origin now is going

00:21:08.720 --> 00:21:13.520
to be considered to be at the
upper left of the line fragment.

00:21:16.330 --> 00:21:19.100
This is the default
mode for the simple API.

00:21:19.240 --> 00:21:22.380
So if you're using the extended
API and you want to make it

00:21:22.380 --> 00:21:27.060
behave like the simple API,
you will set this bit.

00:21:27.060 --> 00:21:31.270
And this is usually used
with multiple lines of text.

00:21:33.740 --> 00:21:36.700
Now, I want to talk about
controlling truncation.

00:21:36.710 --> 00:21:41.020
As you can see here,
we have an overly long run of text

00:21:41.100 --> 00:21:45.180
that we're attempting to cram into
the bounds of our app's main view.

00:21:45.320 --> 00:21:50.470
We can fix this by supplying
the NSStringDrawing Truncate's

00:21:50.470 --> 00:21:55.240
last visible line option,
which will do this.

00:21:55.320 --> 00:21:56.730
Simple.

00:21:57.650 --> 00:22:01.040
Next, I'd like to talk about
something new in iOS 6,

00:22:01.040 --> 00:22:04.670
which personally as a text
geek I find rather exciting.

00:22:04.780 --> 00:22:07.090
It's the NSStringDrawingContext.

00:22:07.260 --> 00:22:09.960
Again, if you've used these
things on the Mac before,

00:22:09.960 --> 00:22:13.040
if you've used NSStringDrawing
and attributed strings,

00:22:13.200 --> 00:22:16.460
you may have run across
things like LayoutManager.

00:22:16.530 --> 00:22:20.610
Well, we don't have LayoutManager
right now on iOS 6,

00:22:20.770 --> 00:22:23.260
but this is a great analog for it.

00:22:23.380 --> 00:22:26.990
It allows you to specify more
options about how you'd like the

00:22:26.990 --> 00:22:31.120
text system to lay out your text,
and it can communicate back to you

00:22:31.150 --> 00:22:33.480
what we actually did to lay it out.

00:22:33.580 --> 00:22:37.270
So, let's talk about a few of
the properties on this.

00:22:37.980 --> 00:22:40.260
First, I'd like to talk about
minimum scale factor.

00:22:40.490 --> 00:22:45.940
It tells the text system exactly how
small it can scale all of the fonts

00:22:46.410 --> 00:22:50.490
in your attributed string before it
begins to truncate when it's trying

00:22:50.490 --> 00:22:53.380
to fit it into the bounding box,
the constraint.

00:22:54.210 --> 00:22:56.910
Next,
we have the minimum tracking adjustment,

00:22:56.910 --> 00:23:00.530
which tells us exactly how small
we can make all of the tracking,

00:23:00.670 --> 00:23:02.930
basically all of the spacing
between your characters,

00:23:02.960 --> 00:23:05.940
again before we're going
to begin to truncate.

00:23:06.050 --> 00:23:09.580
You don't have to use label
to achieve these effects.

00:23:12.970 --> 00:23:15.160
Now I want to talk about
the read-only properties.

00:23:15.290 --> 00:23:19.100
This is the way that the text system
can communicate with you and tell

00:23:19.100 --> 00:23:21.790
you what it did to render your text.

00:23:22.420 --> 00:23:24.440
First, there's the actual scale factor.

00:23:24.680 --> 00:23:27.750
You give us a minimum scale factor,
we give you back the actual

00:23:27.750 --> 00:23:32.520
scale factor that we supplied
when we were scaling your fonts.

00:23:32.630 --> 00:23:36.250
We will tell you the actual
tracking adjustment we used.

00:23:36.860 --> 00:23:42.540
And I would say, maybe most importantly,
we'll tell you the total bounds

00:23:42.740 --> 00:23:45.530
that were used to render your text.

00:23:46.150 --> 00:23:48.700
So, how is this stuff useful?

00:23:48.730 --> 00:23:54.160
Well, the scale factor information can
be used to achieve consistent font,

00:23:54.460 --> 00:23:57.200
label, sizes, and tracking.

00:23:57.290 --> 00:24:03.350
Example here, we have three names:
Johannes, Jacob Appleseed, Twyla Brown,

00:24:03.350 --> 00:24:05.000
and Susie Griffin.

00:24:05.070 --> 00:24:09.060
Twyla and Susie have very short names,
which easily fit in the balance of

00:24:09.060 --> 00:24:11.160
the label that have been supplied.

00:24:11.300 --> 00:24:14.850
However, Johannes' name,
while it is a great name,

00:24:14.910 --> 00:24:18.940
and I love the name Johannes,
is unfortunately very,

00:24:19.070 --> 00:24:24.200
very long and does not easily fit
within the bounds of the given label.

00:24:24.210 --> 00:24:26.210
So, what has the text system done?

00:24:26.490 --> 00:24:31.370
The text system has shrunk the fonts
to 80% of their original size and

00:24:31.370 --> 00:24:33.200
used that to render Johannes' name.

00:24:33.200 --> 00:24:34.390
Now, this is fine.

00:24:34.610 --> 00:24:35.680
Everything fits.

00:24:35.800 --> 00:24:38.700
But now the font sizes are inconsistent.

00:24:38.890 --> 00:24:43.660
Let's take that scale factor of 80%
and apply it to the rest of the text.

00:24:43.850 --> 00:24:48.030
Since we know what scale factor was used,
we can do this to the other strings,

00:24:48.150 --> 00:24:52.490
and then we can achieve this
consistent look to our table view.

00:24:57.620 --> 00:25:03.510
So you can see we have a screenshot
from iOS 6's YouTube app.

00:25:04.340 --> 00:25:07.740
And I'm going to use this to
talk about one pass layout.

00:25:07.740 --> 00:25:10.690
So this is actually
done in our YouTube app.

00:25:11.020 --> 00:25:15.200
You can see we have four keyframes,
four descriptions,

00:25:15.360 --> 00:25:20.340
four dates that the movies were uploaded,
a number of views,

00:25:20.420 --> 00:25:23.150
and because we're Apple,
most importantly, a rating.

00:25:23.340 --> 00:25:25.300
How would we lay all of this out?

00:25:25.420 --> 00:25:28.440
In the past, well,
you know how big the keyframes are,

00:25:28.440 --> 00:25:32.970
but you don't have upfront knowledge
of how big these strings will be.

00:25:33.110 --> 00:25:36.490
So you'd probably render the keyframes,
do a bunch of sizing passes

00:25:36.510 --> 00:25:40.240
over all of the text,
and then actually draw the text.

00:25:40.460 --> 00:25:43.830
You can do this in one pass now
on iOS 6 using the total balance

00:25:43.830 --> 00:25:49.290
property of NSStringDrawingContext,
and let me show you how this would work.

00:25:49.870 --> 00:25:52.300
So, as I said,
we know the size of the keyframe,

00:25:52.300 --> 00:25:53.900
so we can start from there.

00:25:53.900 --> 00:25:57.600
We know the maximum vertical extent.

00:25:58.400 --> 00:26:01.110
And we can render the runtime.

00:26:01.250 --> 00:26:05.510
Now that we know about how big of an
area we have to render the description,

00:26:05.580 --> 00:26:07.140
we can render that.

00:26:07.300 --> 00:26:12.860
And then we can move the Y coordinate
again to supply the origin for

00:26:12.860 --> 00:26:15.320
the date that it was uploaded.

00:26:16.130 --> 00:26:18.810
Then, we can render the number of views.

00:26:18.810 --> 00:26:24.540
And now that we know just about how
big the entire cell is going to be,

00:26:24.730 --> 00:26:28.220
we can drop in the rating.

00:26:29.900 --> 00:26:33.970
We know the bounds of the entire cell,
and we can rinse and repeat

00:26:33.970 --> 00:26:35.320
for the rest of the UI.

00:26:35.710 --> 00:26:36.930
That's one pass layout.

00:26:37.120 --> 00:26:40.110
You can do it on iOS 6 with
the total bounds property

00:26:40.410 --> 00:26:42.980
of NSStringDrawingContext.

00:26:44.680 --> 00:26:48.050
Next, I'd like to tell you about
the concurrency considerations

00:26:48.270 --> 00:26:50.610
of NSString drawing.

00:26:50.980 --> 00:26:55.040
First, you'll be happy to know,
and as string drawing calls,

00:26:55.060 --> 00:26:56.430
are thread safe.

00:27:03.100 --> 00:27:08.800
However,
NSStringDrawingContext instances are not.

00:27:08.800 --> 00:27:11.340
Don't share these between queues, please.

00:27:11.390 --> 00:27:16.130
There could be really interesting
object subgraphs hiding behind an

00:27:16.130 --> 00:27:21.110
NSStringDrawingContext which may
not necessarily be thread safe.

00:27:24.310 --> 00:27:29.290
Now, to show you how to use all of this
cool new technology in your app,

00:27:29.290 --> 00:27:30.500
we've prepared a demo.

00:27:30.630 --> 00:27:33.760
And I'd like to introduce my colleague,
Johannes Fortmann,

00:27:33.760 --> 00:27:35.910
who's going to show it to you.

00:27:42.160 --> 00:27:43.440
Thanks, Ian.

00:27:43.530 --> 00:27:46.240
Hi, I'm Johannes Fortmann
from the Yoike team.

00:27:46.240 --> 00:27:49.800
And if you've been to
the intro talk yesterday,

00:27:49.800 --> 00:27:52.130
you already know our little demo app.

00:27:52.280 --> 00:27:57.150
For those of you who haven't been here,
it's an app which renders

00:27:57.150 --> 00:27:59.680
pages from various plays.

00:27:59.680 --> 00:28:03.990
And you can select a page and,
for example,

00:28:04.000 --> 00:28:08.000
learn the text on the bus if you're
an actor or just marvel at the

00:28:08.000 --> 00:28:10.740
typography and the beautiful writing.

00:28:10.860 --> 00:28:13.570
I'm just going to run this app.

00:28:13.570 --> 00:28:17.690
And this is the state we
got this in yesterday.

00:28:17.730 --> 00:28:21.170
What we did here,
we have a collection view to

00:28:21.470 --> 00:28:24.500
actually show a selection of pages.

00:28:24.630 --> 00:28:30.670
And what we did was we switched this
label here to use the attributed

00:28:30.670 --> 00:28:33.720
rendering and added a bold font.

00:28:33.720 --> 00:28:40.800
And zooming out,
we switched the text rendering.

00:28:40.860 --> 00:28:47.600
And we're going to use the
attribute rendering to use beautiful

00:28:47.600 --> 00:28:50.600
ligatures like the waffles here.

00:28:52.400 --> 00:28:55.460
I don't think he actually says that.

00:28:55.460 --> 00:28:59.810
Well, let's go back to this
overview slide here.

00:29:00.460 --> 00:29:07.600
And well, you notice this label is while
much more beautiful than it was

00:29:07.600 --> 00:29:10.700
yesterday before we started,
it's still kind of

00:29:10.700 --> 00:29:12.350
lying flat on the page.

00:29:12.350 --> 00:29:17.450
So I want to add a shadow to make
this stand out a little more.

00:29:17.450 --> 00:29:21.020
And to do that,
I'm going to Xcode and opening

00:29:21.020 --> 00:29:23.540
my page preview cell here.

00:29:23.670 --> 00:29:27.540
This is where we are
formatting our label.

00:29:27.540 --> 00:29:31.680
We are creating an attributed
string with a red color.

00:29:31.680 --> 00:29:38.780
We are looking for the range of our
scene name and setting a bold font.

00:29:38.840 --> 00:29:44.230
And then we're finally
setting the attributed title.

00:29:44.440 --> 00:29:50.180
To actually set the shadow here,
what we need to do is create one of

00:29:50.330 --> 00:29:53.160
these NSShadowValueClass objects.

00:29:53.160 --> 00:29:58.650
Now, value class means that we are
only using this to actually

00:29:58.650 --> 00:30:05.390
store values like the offset,
the blur radius, or the shadow color.

00:30:06.220 --> 00:30:11.240
So what we need to do here is
actually create our shadow object,

00:30:11.280 --> 00:30:14.300
set the parameters we want to set.

00:30:14.300 --> 00:30:19.360
In my case, I want to set an offset,
and I want to set the blur radius,

00:30:19.370 --> 00:30:21.500
change that from the default.

00:30:21.610 --> 00:30:24.900
I'm not changing the shadow color.

00:30:24.940 --> 00:30:31.570
That's the default of 50% gray,
and I kind of like that color.

00:30:32.090 --> 00:30:38.120
The final step I have to do is actually
change my attributes dictionary

00:30:38.770 --> 00:30:41.300
to have this shadow color set.

00:30:41.300 --> 00:30:46.910
So I'm going to remove this
and replace it by an attributes

00:30:46.980 --> 00:30:51.700
dictionary with now two keys,
the red color, foreground color,

00:30:51.700 --> 00:30:54.040
and the shadow attribute.

00:30:54.130 --> 00:30:56.120
Let's see how that looks.

00:31:00.000 --> 00:31:07.440
We see that we now have a really,
really beautiful shadow here.

00:31:07.440 --> 00:31:09.080
That looks nice.

00:31:09.130 --> 00:31:11.190
And tasteful.

00:31:14.650 --> 00:31:15.430
All right.

00:31:15.600 --> 00:31:18.600
Let's go back to this rendering here.

00:31:18.620 --> 00:31:22.240
Now, if you were in the intro session,
you might still remember

00:31:22.240 --> 00:31:24.000
how this rendering works.

00:31:24.020 --> 00:31:28.190
We are doing -- we have
our page representation,

00:31:28.190 --> 00:31:31.560
which contains several paragraphs.

00:31:31.690 --> 00:31:36.860
And we are rendering this paragraph
by paragraph going through the list.

00:31:36.900 --> 00:31:42.310
And after each paragraph,
we add up the Y height of the

00:31:42.310 --> 00:31:46.560
paragraph to advance our page cursor.

00:31:46.570 --> 00:31:50.590
And for that,
we had to do an unfortunate sizing step.

00:31:50.760 --> 00:31:57.820
We got the paragraph size and added
it to our remaining page rect.

00:31:57.820 --> 00:32:03.750
Now, as Ian just told you,
we can actually use the -- in a

00:32:03.790 --> 00:32:09.140
string drawing context to find out
-- -- find out the total bounds

00:32:09.150 --> 00:32:11.180
of the paragraph we just rendered.

00:32:11.220 --> 00:32:16.260
So we don't have to do the sizing step,
which is very nice,

00:32:16.320 --> 00:32:19.330
because that way we don't
actually have to size this,

00:32:19.490 --> 00:32:24.310
throw away the layout information,
and then render it and recreate

00:32:24.390 --> 00:32:26.140
the layout information.

00:32:26.270 --> 00:32:30.060
So let's move this to
use the actual sizing.

00:32:30.070 --> 00:32:34.330
And keep in mind how this looks,
because we want to compare afterwards,

00:32:34.330 --> 00:32:35.110
of course.

00:32:35.360 --> 00:32:38.700
To go to the rendering code,
we open the page view,

00:32:38.750 --> 00:32:42.720
and there we have a render
page with size method.

00:32:43.410 --> 00:32:44.760
And this is where we do the drawing.

00:32:44.760 --> 00:32:48.440
You can see the sizing step
here and the drawing step here.

00:32:48.540 --> 00:32:54.490
Instead, we want to create the context
that we are using to render,

00:32:54.490 --> 00:33:01.760
which will be filled in by the
rendering step to contain the size.

00:33:01.880 --> 00:33:04.580
So I'm creating the context here.

00:33:04.930 --> 00:33:10.280
And then all that is left for me
to do is do the actual rendering.

00:33:10.280 --> 00:33:13.530
So I can remove this.

00:33:14.060 --> 00:33:16.860
and call my rendering method.

00:33:16.880 --> 00:33:22.480
Now, you see we're using the line
fragment origin parameter here.

00:33:22.490 --> 00:33:28.020
That is because our rendering
is going to start at the current

00:33:28.110 --> 00:33:30.280
cursor position downwards.

00:33:30.280 --> 00:33:34.980
We don't want to render from our
current cursor position upwards

00:33:34.980 --> 00:33:39.730
like having a baseline and having
the glyphs balanced on that.

00:33:39.770 --> 00:33:44.040
But rather we want to render
down from the current position.

00:33:44.040 --> 00:33:46.840
So we have to use this
line fragment origin.

00:33:48.260 --> 00:33:52.390
And of course, afterwards,
we have to still stow

00:33:52.400 --> 00:33:54.750
away our paragraph size.

00:33:54.750 --> 00:33:57.810
And let's have a look at how that looks.

00:33:57.870 --> 00:34:00.360
I hope it still looks the same.

00:34:00.380 --> 00:34:01.900
And it actually does.

00:34:01.900 --> 00:34:03.810
That is very nice.

00:34:04.550 --> 00:34:07.380
Now,
we've also talked about other attributes

00:34:07.380 --> 00:34:09.990
like the background selection color.

00:34:10.050 --> 00:34:14.190
And to demonstrate that,
I have put in a neat feature here.

00:34:15.040 --> 00:34:18.320
I'm going to show you here.

00:34:18.430 --> 00:34:20.610
I'm doing a long tap on this.

00:34:20.690 --> 00:34:26.230
And you see there's a
little copy pop over here.

00:34:26.280 --> 00:34:30.980
I've actually put in a hit testing method
which tests against these paragraphs.

00:34:31.100 --> 00:34:35.610
And we can select one
and actually copy it.

00:34:35.970 --> 00:34:38.500
But we don't see a selection.

00:34:38.500 --> 00:34:44.900
So let's use the background color
attribute to display the selection.

00:34:45.910 --> 00:34:50.800
To do that,
I'm going to switch to the page class,

00:34:51.130 --> 00:34:55.140
that is my model class,
which contains the paragraphs and the

00:34:55.140 --> 00:34:58.270
code to format the attributed string.

00:34:58.700 --> 00:35:00.700
Let me switch there.

00:35:00.730 --> 00:35:03.600
And we have a method,
attributed string for paragraph,

00:35:03.600 --> 00:35:05.800
which we'll use here.

00:35:08.120 --> 00:35:12.710
Now, I already have written the
code to actually propagate

00:35:12.770 --> 00:35:17.560
the paragraph selection index
down into this page class.

00:35:17.560 --> 00:35:21.010
So the only thing I need to do is
actually check if the index of the

00:35:21.100 --> 00:35:25.510
paragraph I'm currently rendering,
that's the index of this

00:35:25.590 --> 00:35:31.960
paragraph in my paragraphs array,
is equal to the selected paragraph.

00:35:31.960 --> 00:35:38.280
And in that case,
I have to format this paragraph properly.

00:35:38.280 --> 00:35:41.020
So I'll set the background color.

00:35:41.110 --> 00:35:44.760
And because I'm setting a
light blue background color,

00:35:44.800 --> 00:35:48.490
I also have to set the
foreground color to match that,

00:35:48.580 --> 00:35:50.860
to have proper contrast here.

00:35:50.860 --> 00:35:54.120
So I'm also setting the foreground color.

00:35:54.130 --> 00:35:56.120
Let's see how that looks.

00:36:02.060 --> 00:36:06.510
And now if I select one of these,
you can actually see

00:36:06.510 --> 00:36:07.990
which one I'm selecting.

00:36:08.000 --> 00:36:11.840
And I can go here and select another one.

00:36:11.940 --> 00:36:15.660
And now I know which paragraph I copied.

00:36:15.780 --> 00:36:23.160
And you notice how this nicely follows
the actual extents of the text here.

00:36:23.210 --> 00:36:29.190
Specifically, we see that it doesn't
go over at the end.

00:36:29.510 --> 00:36:30.400
All right.

00:36:30.400 --> 00:36:35.240
Now, looking back at this slide,
this page,

00:36:35.350 --> 00:36:41.710
we notice that this text seems kind
of -- still seems kind of unbalanced.

00:36:41.870 --> 00:36:47.330
That is because our line spacing is,
I think, a bit off.

00:36:47.330 --> 00:36:50.390
I don't know what I did there.

00:36:50.390 --> 00:36:50.390
But

00:36:51.200 --> 00:36:56.340
What we might want to do is adjust
the line spacing here for legibility.

00:36:56.450 --> 00:36:58.760
You might also want
to use this if you're,

00:36:58.860 --> 00:37:02.820
for example,
printing something to a PDF or so and

00:37:03.490 --> 00:37:07.090
want to leave space for commands or...

00:37:07.380 --> 00:37:12.220
Well, this case,
improving legibility is a very good idea,

00:37:12.220 --> 00:37:12.840
too.

00:37:12.840 --> 00:37:19.270
And I've already put in a slider so I can
actually adjust the line spacing here

00:37:19.270 --> 00:37:22.110
to see how that would actually look.

00:37:22.220 --> 00:37:25.240
But this slider is still nonfunctional.

00:37:25.240 --> 00:37:29.430
That's because while I have hooked
that up and propagated my value

00:37:29.440 --> 00:37:35.220
down to my paragraph already,
I don't actually adjust the line spacing.

00:37:35.220 --> 00:37:37.180
So let's do that.

00:37:39.200 --> 00:37:43.100
We're going to do this one.

00:37:43.100 --> 00:37:48.870
Now we have to actually do
something clever here because as

00:37:49.080 --> 00:37:53.500
you remember from the last session,
we are actually using different

00:37:53.500 --> 00:37:55.030
paragraph styles here.

00:37:55.030 --> 00:37:58.380
The line spacing is a property
on the paragraph style.

00:37:58.380 --> 00:38:03.170
And we are already using
the paragraph style for our

00:38:03.170 --> 00:38:06.330
stage directions to create a

00:38:06.540 --> 00:38:10.120
We've moved them to center alignment.

00:38:10.120 --> 00:38:14.620
Our text, on the other hand,
is using the default paragraph

00:38:14.620 --> 00:38:18.800
style with a left alignment,
and we haven't changed that.

00:38:18.910 --> 00:38:24.910
Now, having these two different paragraph
styles means that we can't just

00:38:25.470 --> 00:38:29.270
smash over a new paragraph style
with the correct line spacing,

00:38:29.280 --> 00:38:33.000
minimum and maximum line spacing,
over all of this,

00:38:33.000 --> 00:38:36.600
because that would override
our text alignment.

00:38:36.600 --> 00:38:38.700
That would be very unfortunate.

00:38:38.700 --> 00:38:44.160
So what we have to do is enumerate
the line spacings and modify them.

00:38:44.160 --> 00:38:47.920
So I'm going to do an enumeration here.

00:38:47.950 --> 00:38:51.970
I'm enumerating the paragraph
style attribute in the whole

00:38:52.040 --> 00:38:55.000
range of the text using a block.

00:38:55.000 --> 00:39:00.840
And this block gets as its parameters
the current value of the paragraph style,

00:39:00.870 --> 00:39:02.980
the range, and a stop point.

00:39:03.020 --> 00:39:05.930
And I'm going to do a pointer if
I want to stop this prematurely.

00:39:06.010 --> 00:39:08.000
We're not going to do that.

00:39:08.000 --> 00:39:11.900
Now, for the default,
we will actually be getting

00:39:11.900 --> 00:39:14.150
a value of nil here.

00:39:14.300 --> 00:39:18.500
That is because we haven't
actually set a paragraph style.

00:39:18.540 --> 00:39:21.240
That means that we have to
take that into consideration.

00:39:21.330 --> 00:39:23.730
And I'm going to do that, actually.

00:39:23.840 --> 00:39:28.600
So what I'm doing here is I look
if we actually have a value,

00:39:28.600 --> 00:39:33.000
in which case we want to do
a mutable copy of this value

00:39:33.000 --> 00:39:35.000
to be able to mutate it.

00:39:35.060 --> 00:39:37.420
And if we don't have a value,
I want to use a new

00:39:37.420 --> 00:39:40.000
mutable paragraph style.

00:39:40.000 --> 00:39:43.610
Of course.

00:39:45.150 --> 00:39:51.900
The only thing that's left for me to do
is to set my minimum and maximum line

00:39:51.900 --> 00:39:59.050
spacing on this paragraph style and then
apply it back to my attributed string.

00:39:59.820 --> 00:40:01.230
That is it.

00:40:01.250 --> 00:40:05.050
Let's see how that works and
if we can figure out a better

00:40:05.060 --> 00:40:07.570
value for our line spacing.

00:40:09.440 --> 00:40:17.850
and now our slider adjusts our line
spacing so we can see the value of

00:40:17.850 --> 00:40:21.710
31 seems to be pretty good here.

00:40:29.330 --> 00:40:33.280
Let's have a look at this
overview page here for a minute.

00:40:33.280 --> 00:40:37.420
We are currently rendering these pages

00:40:38.060 --> 00:40:42.460
Loading them from disk and then
immediately rendering them.

00:40:42.460 --> 00:40:44.600
And that's pretty quick.

00:40:44.600 --> 00:40:46.740
It's certainly fast enough for this demo.

00:40:46.740 --> 00:40:49.580
And it's actually -- the text
rendering system is very fast.

00:40:49.740 --> 00:40:52.000
So there aren't any problems here.

00:40:52.150 --> 00:40:56.460
But you might imagine situations
where the text you want to render

00:40:56.780 --> 00:40:58.780
is coming from the network.

00:40:58.780 --> 00:41:03.780
It might be a whole lot of tweets,
for example, that you get from Twitter.

00:41:03.830 --> 00:41:07.000
And those might be coming
in one after the other.

00:41:07.250 --> 00:41:12.040
And for making your app really
responsive and awesome so

00:41:12.140 --> 00:41:15.880
your customers will love it,
you want to --

00:41:16.420 --> 00:41:21.860
Offload this loading from the
network to a background queue.

00:41:21.860 --> 00:41:25.290
If you've seen the concurrency
in iOS talk yesterday,

00:41:25.450 --> 00:41:27.780
you already know how to do that properly.

00:41:27.980 --> 00:41:31.760
And as Ian told you,
the rendering here is

00:41:31.940 --> 00:41:33.370
actually thread safe.

00:41:33.490 --> 00:41:40.290
So apart from just loading these
tweets or whatever you are rendering

00:41:40.400 --> 00:41:43.320
from the network in the background,
you can also render

00:41:43.320 --> 00:41:44.460
them in the background.

00:41:44.460 --> 00:41:48.920
And I want to move our rendering
code to the background queue

00:41:49.110 --> 00:41:51.880
now to show you how that goes.

00:41:52.280 --> 00:41:59.880
Our rendering code for this overview
lives in the page preview cell.

00:41:59.880 --> 00:41:59.880
And I'm going to pull that up.

00:42:00.610 --> 00:42:03.920
This is actually here
the whole rendering code.

00:42:04.000 --> 00:42:09.250
I'm going to emphasize
this so you can see it.

00:42:09.370 --> 00:42:15.090
And what we're doing here is
we're rendering the page preview.

00:42:15.350 --> 00:42:21.500
and setting it on our
current preview cell.

00:42:21.520 --> 00:42:26.450
Now, parts of this are able to
be moved in the background,

00:42:26.560 --> 00:42:28.060
specifically the rendering.

00:42:28.100 --> 00:42:29.860
Parts of this aren't.

00:42:29.860 --> 00:42:34.460
We cannot interact with UIKit controls,
with view instances from

00:42:34.460 --> 00:42:35.430
the background queue.

00:42:35.470 --> 00:42:39.450
That would be fatal and
a very bad idea to do.

00:42:39.610 --> 00:42:45.570
So what we have to do is first dispatch
this rendering to the background.

00:42:46.160 --> 00:42:50.920
So I'm going to dispatch
this on dispatch queue.

00:42:51.350 --> 00:42:55.340
You could also, of course,
use an NS operation queue for this.

00:42:55.750 --> 00:43:01.000
And now if we look at this render call,
you'll notice we're calling

00:43:01.000 --> 00:43:02.860
this on the page view.

00:43:02.860 --> 00:43:04.250
So this is a class method.

00:43:04.270 --> 00:43:08.600
We're not interacting with any page
view instance because that would be an

00:43:08.700 --> 00:43:12.880
interaction with the UIKit control and,
as I said, not a good idea.

00:43:13.060 --> 00:43:17.830
But we're still sizing this up
by calling this getter here.

00:43:17.880 --> 00:43:19.320
We're getting the frame size.

00:43:19.440 --> 00:43:22.290
We cannot do that in the background,
but luckily that's also

00:43:22.290 --> 00:43:23.530
a very fast operation.

00:43:23.620 --> 00:43:28.160
So we can just do that here
in the foreground before

00:43:28.160 --> 00:43:31.150
we dispatch asynchronously.

00:43:31.300 --> 00:43:36.630
Now that we have this page size,
we want to render in the background.

00:43:36.930 --> 00:43:40.680
And then we want to set this,
but that again is an interaction

00:43:40.680 --> 00:43:43.240
with UIKit proper with a view.

00:43:43.720 --> 00:43:47.460
And so we have to dispatch
that to the foreground queue,

00:43:47.500 --> 00:43:48.900
the main queue.

00:43:49.020 --> 00:43:51.940
So I'm dispatching
this to the main queue.

00:43:51.980 --> 00:43:54.690
And there I'm setting my image.

00:43:55.320 --> 00:44:01.540
These can go now because we actually
have accomplished our to-do.

00:44:01.680 --> 00:44:05.240
So let's look at how that looks.

00:44:06.420 --> 00:44:09.710
And as you can see here, well,
you can see nothing because

00:44:09.950 --> 00:44:12.440
this was already fast.

00:44:12.480 --> 00:44:15.190
It wouldn't have been a good
demo if I hadn't made it fast

00:44:15.250 --> 00:44:17.860
enough to be actually responsive.

00:44:17.980 --> 00:44:21.720
So to show you how this might look
if we actually have a long-running

00:44:21.790 --> 00:44:27.000
operation like a lengthy computation
or fetch from the network,

00:44:27.070 --> 00:44:31.350
I'm going to just put in a
method call here that does some

00:44:31.400 --> 00:44:33.880
work that takes really long.

00:44:34.920 --> 00:44:41.270
And after I do that,
you can see these renderings

00:44:41.640 --> 00:44:46.500
fade in one after the other,
rendered on the background,

00:44:46.520 --> 00:44:49.680
and our app is still responsive.

00:44:55.500 --> 00:45:04.300
[Transcript missing]

00:45:05.340 --> 00:45:10.930
Now, you've seen how to use the advanced
text rendering attributes to

00:45:10.930 --> 00:45:17.690
convey things like the emphasis
we used for the selection,

00:45:17.860 --> 00:45:19.640
but also to beautify your app.

00:45:19.640 --> 00:45:24.520
We've used the shadow to
make our label stand out.

00:45:25.620 --> 00:45:30.250
You've seen how to use the paragraph
style advanced attributes like

00:45:30.250 --> 00:45:33.990
minimum and maximum line height
to make your text more legible.

00:45:34.000 --> 00:45:37.590
In this case,
we've spaced out our lines to make

00:45:37.790 --> 00:45:42.650
the page on the whole look more
balanced and to be able to quickly

00:45:42.650 --> 00:45:45.850
distinguish between these lines.

00:45:46.520 --> 00:45:51.180
And you've seen how to move
things to the background queue.

00:45:51.180 --> 00:45:54.330
Now in moving this to
the background queue,

00:45:54.390 --> 00:45:59.870
we've only used text rendering
system and UI image to actually

00:45:59.870 --> 00:46:03.770
pass the rendered stuff back.

00:46:04.720 --> 00:46:08.200
And let me emphasize this again.

00:46:08.310 --> 00:46:12.690
You should not manipulate UI elements
from the background queue.

00:46:12.700 --> 00:46:15.260
That is a really, really bad idea.

00:46:15.390 --> 00:46:19.530
You should render in the background,
and after you've done your rendering,

00:46:19.800 --> 00:46:27.640
pass the rendered image back to the
main queue and set your image there.

00:46:27.760 --> 00:46:32.630
And with that,
I'd like to give back to Ian.

00:46:32.630 --> 00:46:32.630
Thanks.

00:46:37.640 --> 00:46:41.260
Thank you, Johannes.

00:46:41.400 --> 00:46:44.020
We've talked about a lot of things today.

00:46:45.720 --> 00:46:48.320
First, we talked about some of
the advanced attributes.

00:46:48.410 --> 00:46:52.360
We talked about how to apply
outlines or strokes to your text.

00:46:52.440 --> 00:46:54.380
We talked about drop shadows.

00:46:54.450 --> 00:46:57.600
We talked about kerning
and ligature adjustments.

00:46:57.650 --> 00:47:00.950
And we talked about some of
the cool things you can do with

00:47:01.050 --> 00:47:04.480
NS paragraph style customizations.

00:47:04.690 --> 00:47:08.110
Then we talked about how to use
these text effects in your app.

00:47:08.300 --> 00:47:10.620
We talked about customizing
table view headers.

00:47:10.730 --> 00:47:13.850
We talked about customizing
table view cells.

00:47:16.510 --> 00:47:19.780
And then we talked about the
extended string drawing API.

00:47:19.990 --> 00:47:23.490
We introduced you to the notion
of NSStringDrawingContext,

00:47:23.520 --> 00:47:28.200
which is new in iOS 6 and
exclusive currently to iOS 6.

00:47:28.320 --> 00:47:31.820
And we also talked about
NSStringDrawingOptions.

00:47:32.680 --> 00:47:36.810
If you still need more information,
you can talk to our evangelist,

00:47:36.810 --> 00:47:41.050
Jake Behrens,
or go look at the UIKit framework

00:47:41.130 --> 00:47:42.940
documentation online.

00:47:43.120 --> 00:47:46.240
Finally, if you haven't been to the
Apple Developer Forums,

00:47:46.280 --> 00:47:48.940
I would urge you to go
there today and sign up.

00:47:49.070 --> 00:47:51.940
You can give and receive
peer-to-peer support,

00:47:52.100 --> 00:47:55.650
as well as interact with
employees like myself,

00:47:55.800 --> 00:47:58.240
Johannes, and Aki.

00:47:58.350 --> 00:48:00.240
There are some related sessions.

00:48:00.240 --> 00:48:03.250
We have our Introduction to
Attributed Strings for iOS talk.

00:48:03.320 --> 00:48:05.620
If you missed that,
I urge you to watch that.

00:48:05.700 --> 00:48:10.900
Aki's going to show you how to create,
modify, and replace attributes

00:48:11.000 --> 00:48:14.430
in attributed strings,
as well as draw them to the screen

00:48:14.430 --> 00:48:17.740
using the simple NSStringDrawing API.

00:48:17.830 --> 00:48:21.570
There was a great Core Text and Fonts
session yesterday that you should

00:48:21.570 --> 00:48:25.940
definitely catch if you're interested
in knowing more about Core Text.

00:48:26.030 --> 00:48:27.890
And then there was the Keyboard
Input and Output session.

00:48:27.940 --> 00:48:27.940
There was a Keyboard Input and Output
session yesterday that you should

00:48:27.940 --> 00:48:27.940
definitely catch if you're interested
in knowing more about Core Text.

00:48:27.940 --> 00:48:32.020
input in iOS talk which will tell
you more about how to interact

00:48:32.130 --> 00:48:36.540
with UI text field and UI text view
with respect to attributed strings.
WEBVTT

00:00:10.550 --> 00:00:13.180
Welcome to the debugging
session for LLDB.

00:00:13.180 --> 00:00:17.410
Looks like we have a good crowd.

00:00:17.820 --> 00:00:19.660
I'm Greg Clayton,
one of the architects of LLDB.

00:00:19.660 --> 00:00:23.530
Now, before we get started with a lot of
the great content that we have today,

00:00:23.660 --> 00:00:26.500
I just want to kind of take a look at
what's happened over the past year,

00:00:26.620 --> 00:00:28.610
because it's been a big
year for LLDB itself.

00:00:29.980 --> 00:00:33.500
Last year at WWDC,
we introduced an Xcode seed that

00:00:33.530 --> 00:00:37.890
had LLDB as an available debugger,
so it's just one of your choices.

00:00:37.890 --> 00:00:43.770
Later on in the year, in December,
we released Xcode 4.3,

00:00:43.980 --> 00:00:47.870
in which LLDB became
the default debugger.

00:00:48.140 --> 00:00:52.120
And this year, we've got a great seed for
you guys with Xcode 4.5.

00:00:52.120 --> 00:00:55.490
And LLDB, again, is the default debugger,
but we've made a lot of

00:00:55.580 --> 00:00:57.190
improvements for you guys.

00:00:57.200 --> 00:01:02.340
So just to highlight some of the things
that you can watch for is we've got

00:01:02.340 --> 00:01:05.780
much improved Objective-C debugging
support for you guys.

00:01:05.780 --> 00:01:10.180
We've got property syntax built into
the expression parser so that you

00:01:10.180 --> 00:01:14.300
can actually use your backed and your
unbacked properties in your expressions.

00:01:15.160 --> 00:01:18.250
And we also will find the one true
definition of your class so that when

00:01:18.410 --> 00:01:22.520
you're debugging and if you happen
to use the nameless category where

00:01:22.520 --> 00:01:25.380
you hide some instance variables in
your main definition of your class,

00:01:25.380 --> 00:01:27.750
we'll actually try and dig
up that definition as much

00:01:27.980 --> 00:01:29.560
as possible while debugging.

00:01:31.290 --> 00:01:34.130
We've done some great stuff with
some of the new data formatters.

00:01:34.420 --> 00:01:36.540
We've got some data formatters
that are actually built into

00:01:36.540 --> 00:01:38.520
the core of LLDB itself.

00:01:38.800 --> 00:01:41.300
Now, that helps us display
your Objective-C types,

00:01:41.350 --> 00:01:45.960
like your NSStrings and your NSArrays and
other Objective-C collection classes,

00:01:46.020 --> 00:01:50.560
as well as your C++,
standard template library, collections,

00:01:50.640 --> 00:01:52.250
and data types.

00:01:55.800 --> 00:02:00.420
One of the other great things that we've
done with the Objective-C data formatters

00:02:00.810 --> 00:02:04.520
is we've actually made them so 80% of
the time where we actually used to have

00:02:04.640 --> 00:02:08.230
to run code to show you your data types,
we don't actually have to run code.

00:02:08.230 --> 00:02:15.040
What that means for you is your data
will be available more of the time,

00:02:15.040 --> 00:02:19.860
your summaries and the
contents of your arrays.

00:02:19.860 --> 00:02:21.420
We now added Watchpoint support
for desktop and for iOS.

00:02:21.670 --> 00:02:25.110
And we've got an improved
Python interface where we've exposed

00:02:25.150 --> 00:02:29.300
much more of the API that's built into
the debugger itself so you can get access

00:02:29.300 --> 00:02:31.120
to it through some Python scripting.

00:02:31.290 --> 00:02:35.800
And we'll talk about
that as the talk goes on.

00:02:36.420 --> 00:02:38.300
Today we're going to go
through a couple things.

00:02:38.300 --> 00:02:42.140
We're going to introduce you into
LLDB and talk about the hows and

00:02:42.140 --> 00:02:45.300
the whys and why we decided to write
the debugger in the first place.

00:02:45.300 --> 00:02:49.540
And we'll move on to getting more
in-depth with LLDB and going through

00:02:49.540 --> 00:02:52.560
some of the command interpreter,
going through some of the

00:02:52.690 --> 00:02:55.890
terminology that's involved,
and then go through a debug session

00:02:55.890 --> 00:02:58.630
where we'll stop along the way
and take a look at how LLDB can

00:02:58.640 --> 00:03:00.500
help us out when we're debugging.

00:03:02.100 --> 00:03:05.250
And then we'll use LLDB to do
a couple of different things

00:03:05.430 --> 00:03:08.800
that are not debugging-related,
but there's a lot of great features

00:03:08.800 --> 00:03:11.960
inside of a debugger that you
should be able to take advantage of,

00:03:11.960 --> 00:03:14.280
and we'll go through
a few examples there.

00:03:14.400 --> 00:03:16.240
And then we'll wrap things up.

00:03:16.390 --> 00:03:19.340
So let's get started.

00:03:19.650 --> 00:03:23.200
Well, before we get into LLDB,
we want to talk a little bit

00:03:23.200 --> 00:03:25.460
about why we decided to create
LLDB in the first place.

00:03:25.460 --> 00:03:28.240
And what it came down to is
we really wanted a better

00:03:28.320 --> 00:03:30.320
debugger to give to you guys.

00:03:30.380 --> 00:03:33.340
Now, you might ask,
what was wrong with our

00:03:33.340 --> 00:03:35.090
existing technology?

00:03:35.100 --> 00:03:38.860
We kind of took a look at where we wanted
to be over the next couple of years,

00:03:38.880 --> 00:03:41.600
and we thought about the things that
we want to do with multi-threaded

00:03:41.600 --> 00:03:44.980
debugging and a lot of different things
that we wanted to add support for.

00:03:45.220 --> 00:03:49.250
And we just came up with the fact that
the architecture inside of GDB wasn't

00:03:49.250 --> 00:03:50.870
correct for where we wanted to be.

00:03:50.880 --> 00:03:57.080
Now, one of the issues that we had
was how debug information was

00:03:57.270 --> 00:03:58.200
parsed as you're debugging.

00:03:58.200 --> 00:04:01.780
And GDB parses information
in large chunks.

00:04:01.780 --> 00:04:05.600
And the best analogy I can offer
is if debug information is a book,

00:04:05.700 --> 00:04:09.360
GDB likes to ingest debug
information a chapter at a time.

00:04:09.380 --> 00:04:11.280
And we thought we could do better.

00:04:11.280 --> 00:04:14.880
Also, there was never an API.

00:04:15.220 --> 00:04:17.110
There was never an API that
was vended from GDB itself.

00:04:17.200 --> 00:04:20.780
And we have a lot of tools where
people will actually launch

00:04:20.860 --> 00:04:23.540
GDB from the command line,
feed text into it,

00:04:23.640 --> 00:04:27.540
and get text back out in order to
use it as if it did have an API.

00:04:29.950 --> 00:04:31.860
Now,
another issue that we had was a lot of

00:04:31.870 --> 00:04:35.700
information inside the debugger itself
was contained in global variables that

00:04:35.700 --> 00:04:37.700
were kind of strewn across the code.

00:04:37.850 --> 00:04:40.120
And that made it really
difficult for us to,

00:04:40.120 --> 00:04:43.440
say, put all those things together
inside of one structure that would

00:04:43.440 --> 00:04:48.610
represent maybe your debugging target
or your process or your threads.

00:04:50.500 --> 00:05:29.400
[Transcript missing]

00:05:29.990 --> 00:05:32.250
With the expression parser,
one of the things that

00:05:32.250 --> 00:05:35.100
happens is as time goes on,
the compiler adds new features.

00:05:35.100 --> 00:05:38.160
It adds new languages,
new runtime support,

00:05:38.160 --> 00:05:41.960
and the expression parsers
tend to lag behind.

00:05:41.980 --> 00:05:45.460
And you're always playing catch-up with
the debugger when you're not actually,

00:05:45.460 --> 00:05:49.140
when you have an expression parser that
is just built into the debugger itself.

00:05:49.360 --> 00:05:53.420
And it made it hard for us to add even
simple things like Objective-C property

00:05:53.420 --> 00:05:55.780
support into the expression parser.

00:05:56.310 --> 00:05:59.260
There's a lot of languages that
are supported inside of the

00:05:59.320 --> 00:06:03.150
expression parser because GDB's
been around for quite a few years.

00:06:03.200 --> 00:06:06.990
And again, adding something as simple as
Objective-C property support proved to

00:06:07.080 --> 00:06:09.170
be a lot harder than it should have been.

00:06:09.180 --> 00:06:12.850
So we wanted to go design a new debugger,
and we wanted to keep a lot

00:06:12.850 --> 00:06:14.720
of different things in mind.

00:06:14.760 --> 00:06:17.060
Now, of course,
we wanted something that performed

00:06:17.170 --> 00:06:18.520
great and did well on memory.

00:06:18.520 --> 00:06:21.230
But really,
we wanted to be able to customize our

00:06:21.440 --> 00:06:25.740
debug sessions so that you guys can see
your data exactly how you want to see it.

00:06:26.020 --> 00:06:26.520
So we wanted to do a lot
of things that are really,

00:06:26.520 --> 00:06:27.020
really easy to do while debugging.

00:06:27.020 --> 00:06:30.540
We also wanted to integrate with a
compiler because the compiler guys,

00:06:30.660 --> 00:06:35.480
we'd much rather have the LLVM and Clang
folk do the great work that they're doing

00:06:35.520 --> 00:06:37.210
and take advantage of what they're doing.

00:06:37.240 --> 00:06:40.430
And then we also wanted to
modernize our architecture.

00:06:40.460 --> 00:06:43.560
So we're going to concentrate
on a few things here today,

00:06:43.600 --> 00:06:46.380
and we're just going to talk
about the customization,

00:06:46.540 --> 00:06:50.730
the compiler integration,
and the architecture itself.

00:06:52.020 --> 00:06:55.430
So one of the great things that
you can do with LLDB that we added

00:06:55.430 --> 00:06:59.140
for this year was we added a lot
of ways to display your data.

00:06:59.140 --> 00:07:02.920
You can override the formats for given
types so that you don't always have to

00:07:02.920 --> 00:07:05.240
right-click and set the format manually.

00:07:05.240 --> 00:07:07.620
You can create summaries
for your data types,

00:07:07.780 --> 00:07:11.230
much like you could in Xcode,
but we actually built this into the

00:07:11.230 --> 00:07:15.670
core of LLDB itself so that the command
line users aren't left out in the cold.

00:07:16.920 --> 00:07:19.480
And also,
synthetic instance variables allows

00:07:19.480 --> 00:07:23.310
us to take opaque collection classes,
like, say, an NSArray or a standard

00:07:23.330 --> 00:07:26.250
template library vector,
and actually create a new set of

00:07:26.260 --> 00:07:29.720
objects that appear underneath the
data type so that you can view your

00:07:29.780 --> 00:07:31.590
data the way that you want to see it.

00:07:33.190 --> 00:07:37.790
We have a lot of great ways for you guys
to customize your command interface.

00:07:37.920 --> 00:07:40.400
If you're a GDB user and we forgot
one of your favorite commands,

00:07:40.400 --> 00:07:42.200
you can easily add aliases.

00:07:42.200 --> 00:07:44.740
If you're coming from a different
debugger and you're used to

00:07:44.740 --> 00:07:47.640
typing in certain commands,
we wanted to make sure that

00:07:47.720 --> 00:07:49.610
it was very customizable.

00:08:01.090 --> 00:08:01.090
We also have a lot of different
ways for you to customize

00:08:01.090 --> 00:08:01.090
the prompts that show up.

00:08:01.090 --> 00:08:01.090
And the prompts appear when
you display your threads or

00:08:01.090 --> 00:08:01.090
when you display your frames.

00:08:01.090 --> 00:08:01.090
And we've got great ways to
customize all those things.

00:08:01.390 --> 00:08:05.060
Now, when integrating with a compiler,
I just want to ask the question,

00:08:05.060 --> 00:08:07.670
why do we actually want to
integrate with the compiler itself?

00:08:07.880 --> 00:08:09.760
And to answer that,
we should look at what

00:08:09.850 --> 00:08:11.170
debuggers typically do.

00:08:11.180 --> 00:08:16.080
Typically, a debugger will make up its
own homegrown type system.

00:08:16.080 --> 00:08:21.740
And the debug information is actually
parsed into this internal representation.

00:08:21.740 --> 00:08:24.760
On top of that,
an expression parser is built that

00:08:24.760 --> 00:08:27.190
actually uses these internal types.

00:08:27.640 --> 00:08:30.830
Now, the type system that the debuggers
make up is not the same type

00:08:30.830 --> 00:08:32.600
system that the compiler would use.

00:08:32.600 --> 00:08:34.840
So there's often
shortcuts that are taken,

00:08:34.840 --> 00:08:38.490
and there's often different, you know,
issues that arise as you're

00:08:38.490 --> 00:08:40.930
adding support for new
languages when you have these,

00:08:40.930 --> 00:08:43.120
you know, homegrown data structures.

00:08:43.140 --> 00:08:47.660
And the expression parsers are
always striving for a compiler level

00:08:47.710 --> 00:08:52.320
of accuracy to make up for this,
and they never quite attain that.

00:08:52.360 --> 00:08:56.000
So the expression parsers we
talked about needs to be updated.

00:08:56.000 --> 00:08:57.620
As the compilers get updated and added,
they're going to be updated.

00:08:57.620 --> 00:08:58.130
So we're going to have
to write new features.

00:08:58.140 --> 00:09:02.510
And how hard can it be to write
a good C++ expression parser?

00:09:04.960 --> 00:09:08.410
So we prefer to let the
compiler guys do their job,

00:09:08.640 --> 00:09:12.840
and we just took a full copy of Clang
and built it right into LDB itself.

00:09:12.840 --> 00:09:17.050
Now that gives us-- allows us to take
the debug information and actually

00:09:17.080 --> 00:09:21.090
just translate it into the actual data
types that the compiler would use,

00:09:21.090 --> 00:09:23.710
just as if it were compiling your code.

00:09:23.940 --> 00:09:25.960
So now we didn't make
up our own type system,

00:09:25.960 --> 00:09:30.030
but we have a type system that
fully represents all the detail

00:09:30.040 --> 00:09:31.960
that's contained in your code.

00:09:31.980 --> 00:09:36.550
And it allows us to just use the
compiler as our expression parser.

00:09:36.650 --> 00:09:40.350
Now we attain what all the other
debuggers are striving for,

00:09:40.550 --> 00:09:45.530
trying to attain compiler level of
accuracy when evaluating expressions.

00:09:45.980 --> 00:09:48.940
We also get the complete language
support full of every single feature

00:09:48.940 --> 00:09:51.320
that's built into the compiler itself.

00:09:51.690 --> 00:09:54.000
We get the same errors that
you're used to from the command

00:09:54.000 --> 00:09:56.140
line and from within Xcode.

00:09:56.190 --> 00:09:59.020
And we get the compiler
features for free.

00:09:59.130 --> 00:10:02.420
Most notably recently,
we've added Objective-C literal

00:10:02.580 --> 00:10:05.930
support and C++11,
including Lambda support.

00:10:06.040 --> 00:10:09.500
So we're able to take advantage of this
really quickly because we just used

00:10:09.500 --> 00:10:12.900
the code that is the compiler itself.

00:10:14.410 --> 00:10:17.650
So if we talk about architecture,
one of the things we wanted to start

00:10:17.650 --> 00:10:20.900
over with and make sure that we
had a clean object-oriented design,

00:10:20.900 --> 00:10:24.700
that enables us to encapsulate
the different objects that make

00:10:24.700 --> 00:10:29.010
up your debug session into,
say, a process or into a thread object.

00:10:29.520 --> 00:10:31.850
And we don't run into the same
issues that we ran into where

00:10:31.900 --> 00:10:36.190
we had globals that were trying
to maintain some program state.

00:10:36.210 --> 00:10:39.460
And by encapsulating it,
it allows us to do a lot better job

00:10:39.460 --> 00:10:43.060
of running multiple architectures
within the same debugger,

00:10:43.470 --> 00:10:47.700
having multiple debug sessions going
on inside the same debugger as well.

00:10:47.910 --> 00:10:51.530
We have a plugin interface that
allows us to quickly adapt to new file

00:10:51.530 --> 00:10:55.340
formats and debug information formats,
and there's a whole bunch of other

00:10:55.430 --> 00:10:58.460
plugins that are actually built
into the debugger itself that cover

00:10:58.840 --> 00:11:03.400
languages and runtimes and a lot
of different features that make

00:11:03.400 --> 00:11:10.390
LLDB able to adapt to the changing
languages and the changing future of

00:11:10.390 --> 00:11:10.390
the code that you'll be dealing with.

00:11:11.660 --> 00:11:16.580
And we wanted to design a debugger that
meets today's debugging requirements.

00:11:17.320 --> 00:11:18.760
The biggest issue that
we are running into now,

00:11:18.760 --> 00:11:21.820
as you well know,
we have more and more threads

00:11:21.820 --> 00:11:23.000
in our debug sessions.

00:11:23.020 --> 00:11:27.020
So we wanted to make sure in these
objects that we've made to represent

00:11:27.020 --> 00:11:32.000
your debug sessions that we do a
great job at multi-threaded debugging.

00:11:32.000 --> 00:11:35.210
We also stay in sync with the compiler,
so we're never lagging

00:11:35.220 --> 00:11:37.000
behind and playing catch-up.

00:11:37.000 --> 00:11:39.490
LLDB is a framework,
and that allows us to

00:11:39.490 --> 00:11:40.880
actually vend an API.

00:11:41.000 --> 00:11:44.210
That means that people can take advantage
of some of the great features that

00:11:44.220 --> 00:11:46.000
are built into the debugger itself.

00:11:46.000 --> 00:11:49.690
It also allows us to make this
entire API available to you through

00:11:49.870 --> 00:11:52.000
a Python scripting interface.

00:11:52.180 --> 00:11:55.820
Now, this is available both internally
inside of LLDB from the embedded

00:11:55.850 --> 00:12:00.880
script interpreter and also externally,
so that you can load up Python and

00:12:00.980 --> 00:12:02.950
actually script a debug session.

00:12:04.530 --> 00:12:08.040
So that was a quick introduction
into why we decided to write LLDB.

00:12:08.050 --> 00:12:12.100
Let's get a little more in-depth
into LLDB and discover some things.

00:12:12.100 --> 00:12:14.670
So we're going to get started
and introduce you to some

00:12:14.680 --> 00:12:16.380
of the LLDB commands first.

00:12:16.520 --> 00:12:18.740
And in that section,
we'll learn about some of the

00:12:18.810 --> 00:12:21.780
terminology that's involved and
some of the objects that are the

00:12:21.780 --> 00:12:23.100
key players inside of the debugger.

00:12:23.100 --> 00:12:26.900
And we'll move on to showing you how you
can customize your commands in case we

00:12:26.900 --> 00:12:28.980
have forgotten a shortcut that you need.

00:12:29.100 --> 00:12:32.300
We'll talk about some of the things
that go into launching your program,

00:12:32.300 --> 00:12:36.150
and then we'll get into a debug
session where we'll explore and

00:12:36.310 --> 00:12:39.100
we'll stop along the way and use
some of the features of LLDB.

00:12:39.100 --> 00:12:42.790
So if we get started here,
let's start by running

00:12:42.790 --> 00:12:45.100
LLDB from the command line.

00:12:45.310 --> 00:12:49.080
The XCRUN command allows us to run
a binary that's contained inside

00:12:49.080 --> 00:12:52.690
the Xcode application bundle,
and it will also load the correct

00:12:52.780 --> 00:12:56.100
application depending on which
Xcode you may have selected.

00:12:56.100 --> 00:12:57.860
So here we launch LLDB.

00:12:58.100 --> 00:13:01.850
We create a debug session
using the file command.

00:13:02.100 --> 00:13:04.100
Set a breakpoint at main.

00:13:04.140 --> 00:13:06.090
Let's go ahead and run.

00:13:06.100 --> 00:13:08.100
Do some backtraces and some stepping.

00:13:08.300 --> 00:13:09.810
Display some data.

00:13:10.100 --> 00:13:13.100
Do a little bit more stepping,
and then quit.

00:13:13.190 --> 00:13:15.870
Now, if anyone's used GDB before
from the command line,

00:13:15.950 --> 00:13:19.100
you're probably going to
recognize a lot of these commands.

00:13:19.100 --> 00:13:22.980
And they're actually aliases into the
actual LLDB commands that back them.

00:13:23.100 --> 00:13:26.480
We wanted to make sure that the
people that had been debugging for

00:13:26.500 --> 00:13:27.100
a long time felt right at home.

00:13:27.200 --> 00:13:31.460
When running LLDB from the command line,
as well as from within the

00:13:31.460 --> 00:13:33.100
debugger console in Xcode.

00:13:33.100 --> 00:13:35.880
Now, that's not how these commands
are actually represented

00:13:35.880 --> 00:13:36.880
inside of LLDB itself.

00:13:37.100 --> 00:13:40.100
If we take a look at these
same commands in LLDB,

00:13:40.200 --> 00:13:43.850
we would tell a target that we would
like to create a new debug session

00:13:44.200 --> 00:13:46.100
using the executable ADAT out.

00:13:46.100 --> 00:13:49.200
Then we would set a breakpoint,
and we would specify an option that

00:13:49.230 --> 00:13:51.060
we're setting a breakpoint by name.

00:13:51.100 --> 00:13:55.120
We would tell the process to launch,
and we would tell the thread

00:13:55.120 --> 00:13:56.070
to backtrace and step.

00:13:56.150 --> 00:14:00.200
We'd run an expression,
and do a little bit more stepping,

00:14:00.200 --> 00:14:00.900
and quit.

00:14:01.100 --> 00:14:05.540
Now, with the command interpreter,
we wanted to fix a couple of

00:14:05.620 --> 00:14:08.100
things that we ran into with GDB.

00:14:08.120 --> 00:14:12.100
With GDB, we had a very inconsistent
command syntax.

00:14:12.100 --> 00:14:15.100
From command to command,
you really didn't know what to expect.

00:14:15.290 --> 00:14:17.100
Some commands were single characters.

00:14:17.240 --> 00:14:19.010
Some commands were multiple characters.

00:14:19.310 --> 00:14:22.080
Some commands were multi-word commands.

00:14:22.320 --> 00:14:25.070
Others had options, long options,
short options.

00:14:25.100 --> 00:14:28.100
There was a different parser
for every different command.

00:14:28.100 --> 00:14:32.020
And there was a lot of different hidden
shortcuts inside of these commands.

00:14:32.390 --> 00:14:36.100
And that's one of the
things we wanted to avoid.

00:14:38.080 --> 00:14:40.440
There was a lot of argument overloading
that went on inside of commands.

00:14:40.440 --> 00:14:44.200
For example, GB's breakpoint command
could take a file colon line,

00:14:44.310 --> 00:14:47.870
it could take the name of a function,
it could take an address,

00:14:47.870 --> 00:14:50.240
but only if you put a
star in front of it.

00:14:50.240 --> 00:14:52.690
And there's a lot of different
things that might not make sense

00:14:52.770 --> 00:14:56.800
to users that are coming at
it with a fresh pair of eyes.

00:14:56.800 --> 00:14:59.200
With LLDB's command interpreter,
we wanted to make sure that we had

00:14:59.250 --> 00:15:02.430
a very consistent command syntax,
so no matter what command you typed,

00:15:02.430 --> 00:15:04.620
you knew exactly what to expect.

00:15:04.620 --> 00:15:07.800
We use options instead of
overloading the arguments.

00:15:07.800 --> 00:15:10.740
And that helps us target
the auto-completion a

00:15:10.740 --> 00:15:12.210
little more efficiently.

00:15:12.320 --> 00:15:15.200
Instead of -- with the break command,
if you hit tab after typing

00:15:15.310 --> 00:15:18.210
the break command in GDB,
we'd have to auto-complete

00:15:18.210 --> 00:15:20.280
every file and line,
every function and a whole

00:15:20.280 --> 00:15:21.530
lot of different things.

00:15:21.660 --> 00:15:23.960
And by using options,
we can actually show you the

00:15:23.960 --> 00:15:26.900
data that you're actually looking
for a lot more efficiently.

00:15:27.030 --> 00:15:29.660
We also wanted to make
commands more discoverable.

00:15:29.700 --> 00:15:32.530
And in the upcoming terminology slides,
we'll see how we can discover

00:15:32.650 --> 00:15:34.040
what different commands can do.

00:15:34.120 --> 00:15:38.160
Greg Clayton And the documentation
for the commands is actually built

00:15:38.270 --> 00:15:40.840
right into the debugger itself.

00:15:40.840 --> 00:15:43.580
So if we take a look at
the command syntax in LLDB,

00:15:43.580 --> 00:15:46.980
we tend to stick to a noun-verb paradigm.

00:15:47.330 --> 00:15:51.280
Target create, break point set,
process launch.

00:15:51.280 --> 00:15:55.700
And after that, we add on the standard
Unix style options.

00:15:55.720 --> 00:15:58.900
And then we add on our
arguments that come after this.

00:15:58.920 --> 00:16:02.570
We use the same command interpreter
to parse all of your expressions --

00:16:02.570 --> 00:16:04.060
or to parse all of your commands.

00:16:04.250 --> 00:16:06.700
You're going to know exactly
what to expect when you come in.

00:16:07.730 --> 00:16:11.850
We actually also use a very common
Unix library to parse up our options

00:16:12.070 --> 00:16:16.260
so that you can actually intermingle
your arguments and your options.

00:16:16.280 --> 00:16:19.350
If you take a look at the first command,
we can actually put one

00:16:19.360 --> 00:16:20.940
of the arguments first.

00:16:20.940 --> 00:16:24.490
So if you're used to debugging
from -- or if you're used to

00:16:24.490 --> 00:16:27.750
running commands from the shell,
you'll be right at home when

00:16:27.840 --> 00:16:29.500
running commands in LLDB.

00:16:29.500 --> 00:16:32.320
Now, the other thing that we could do
in GDB is you could shorten down

00:16:32.320 --> 00:16:36.520
your commands by only typing in the
fewest number of characters that

00:16:36.540 --> 00:16:40.180
you had to in order to uniquely
identify the command itself.

00:16:40.200 --> 00:16:42.060
We've implemented that as well.

00:16:42.170 --> 00:16:45.110
And for every long Unix
style option that we have,

00:16:45.110 --> 00:16:47.560
we have a short Unix style counterpart.

00:16:47.660 --> 00:16:53.050
So you'll know exactly what to
expect when typing in commands.

00:16:53.400 --> 00:16:55.820
So we've learned about some
of the commands and we've seen

00:16:55.820 --> 00:16:58.950
some terminologies so far,
but I want to introduce you to some

00:16:58.980 --> 00:17:01.700
of the key components that you'll
be using when debugging in LLDB.

00:17:01.700 --> 00:17:04.150
To get started, a target.

00:17:04.230 --> 00:17:07.370
A target is something that
represents your debug session.

00:17:07.380 --> 00:17:11.240
It contains your breakpoints and
it contains all the information

00:17:11.240 --> 00:17:13.140
that persists between runs.

00:17:13.140 --> 00:17:18.890
Now, file A.out is an alias
to target create A.out.

00:17:18.950 --> 00:17:22.480
That allows us to create a new
target that we want to debug.

00:17:22.820 --> 00:17:26.240
If we want to discover the various things
that we can actually do with the target,

00:17:26.240 --> 00:17:29.420
you can type target followed
by space and hit the tab key,

00:17:29.420 --> 00:17:32.440
and we'll actually autocomplete
all the various things that you

00:17:32.500 --> 00:17:33.510
can actually do with the target.

00:17:33.520 --> 00:17:36.160
You can see that there's a lot of
different things that you can do.

00:17:36.160 --> 00:17:38.690
You can create, you can delete,
you can list, and you can see the

00:17:38.690 --> 00:17:39.900
modules inside of a target.

00:17:39.900 --> 00:17:43.510
To drive home the fact that
a target actually represents

00:17:43.510 --> 00:17:47.450
a standalone debug session,
let's go ahead and create a target

00:17:47.560 --> 00:17:51.610
using a very simple executable,
set a breakpoint inside of it,

00:17:52.340 --> 00:17:53.210
and run that target.

00:17:53.930 --> 00:17:58.670
Now, what happens when we create another
target and set a breakpoint at

00:17:58.670 --> 00:18:00.830
a different function and run it?

00:18:01.040 --> 00:18:03.850
Well,
we actually have two simultaneous debug

00:18:03.850 --> 00:18:05.610
sessions going on at the same time.

00:18:05.740 --> 00:18:09.010
This will allow you to debug your
client and server applications

00:18:09.040 --> 00:18:10.240
inside the same binary.

00:18:10.370 --> 00:18:13.110
Using the target list command,
you can see a list of the current

00:18:13.240 --> 00:18:14.870
targets that you actually have running.

00:18:14.940 --> 00:18:16.440
They maintain their own state.

00:18:16.440 --> 00:18:17.980
They know if they're running or stopped.

00:18:18.250 --> 00:18:19.630
They have their own breakpoints.

00:18:19.640 --> 00:18:24.360
You can switch between the different
targets using the target select command,

00:18:24.360 --> 00:18:26.290
and you can switch back.

00:18:26.980 --> 00:18:30.350
Another benefit of actually
running two debug sessions in the

00:18:30.390 --> 00:18:32.420
same binary is memory footprint.

00:18:32.420 --> 00:18:35.710
If we take a look at debugging
these two programs in,

00:18:35.760 --> 00:18:38.760
say, GDB,
each of these boxes would represent a

00:18:38.760 --> 00:18:40.300
chunk of memory that would be taken up.

00:18:40.370 --> 00:18:43.940
By debugging two of the applications
in the same binary itself,

00:18:43.940 --> 00:18:47.640
we can actually share the resources in
between the different debugging targets.

00:18:47.730 --> 00:18:51.990
Now, this will come in handy if you have
large applications or a large client

00:18:52.040 --> 00:18:54.950
and server where you're sharing a
lot of infrastructure underneath

00:18:54.950 --> 00:18:56.880
that has a lot of debug information.

00:18:56.900 --> 00:18:58.190
Thank you.

00:18:58.520 --> 00:19:01.860
If we get back to terminology,
let's talk about a process.

00:19:01.940 --> 00:19:04.530
When you type the run command
followed by some arguments,

00:19:04.650 --> 00:19:07.250
it's actually equivalent to
typing process launch and

00:19:07.260 --> 00:19:08.480
specifying some arguments.

00:19:08.480 --> 00:19:11.860
Now, you might notice the dash
dash that appears here.

00:19:11.860 --> 00:19:15.540
And the dash dash is actually
something that terminates the options

00:19:15.670 --> 00:19:17.870
to the process launch command itself.

00:19:18.500 --> 00:19:22.000
Because some of the arguments that you
might want to pass on to your program

00:19:22.000 --> 00:19:25.580
might look like options themselves
and might get confused with options

00:19:25.580 --> 00:19:29.400
and cause the process launch to get
some arguments it wasn't expecting.

00:19:31.100 --> 00:19:33.730
So if we take a look at what
we can do with a process,

00:19:33.730 --> 00:19:37.120
we can type process and hit the
tab key again to discover all

00:19:37.120 --> 00:19:39.360
the variety of different things
that we can do with a process.

00:19:39.360 --> 00:19:42.800
We'll show you some of the more
common things that you'll do.

00:19:42.800 --> 00:19:46.240
If you want to attach to
a process by process ID,

00:19:46.240 --> 00:19:49.590
you can use the process attach
with the dash dash PID option.

00:19:49.600 --> 00:19:51.840
You can attach to a process by name.

00:19:51.840 --> 00:19:54.330
You can create a target first.

00:19:54.340 --> 00:19:56.170
And if you create a target,
we already know the name

00:19:56.170 --> 00:19:58.120
of the executable that
you're going to attach to.

00:19:58.120 --> 00:20:00.100
So you can just type process attach.

00:20:01.000 --> 00:20:05.560
As well, you might not have control over
how your program gets launched.

00:20:05.560 --> 00:20:09.020
And one of the features that
we added was the process attach

00:20:09.020 --> 00:20:10.720
with the wait for option.

00:20:10.760 --> 00:20:15.050
Basically, it'll wait around and pull the
operating system and watch for the next

00:20:15.050 --> 00:20:16.750
instance of your program to be run.

00:20:18.220 --> 00:20:21.550
Now, there's an inherent race condition
in this where you might miss the

00:20:21.710 --> 00:20:25.440
first couple thousand instructions,
and I used an XPC service here

00:20:25.440 --> 00:20:27.300
to kind of drive that point home.

00:20:27.440 --> 00:20:30.400
Because XPC services kind
of launch very quickly,

00:20:30.720 --> 00:20:32.950
they kind of run through the code,
and they kind of either

00:20:32.950 --> 00:20:34.290
exit or kind of go idle.

00:20:34.420 --> 00:20:36.870
So if you're looking to
attach to an XPC service,

00:20:36.990 --> 00:20:39.810
you might need to put a few delays
inside of your code to make sure that

00:20:39.810 --> 00:20:43.810
you can catch your breakpoints and
make sure that we don't attach to your

00:20:43.810 --> 00:20:46.320
process after your code has gone by.

00:20:46.590 --> 00:20:49.740
To continue your process after this,
you can type process continue.

00:20:49.840 --> 00:20:53.440
We have aliases for the GDB users,
continue and C.

00:20:53.550 --> 00:20:56.990
And to interrupt your process,
you can type control C.

00:20:58.200 --> 00:20:59.300
If we move on into thread,
we can type thread.

00:20:59.460 --> 00:21:02.070
Again, hit tab and discover all the
variety of different things that

00:21:02.070 --> 00:21:03.850
we can do with thread itself.

00:21:03.980 --> 00:21:06.520
Some of the more popular things
that you'll use is thread list

00:21:06.780 --> 00:21:10.040
to list all the threads that are
currently in your current process.

00:21:10.200 --> 00:21:13.860
Also, thread select allows you to
select a thread using the index,

00:21:13.960 --> 00:21:18.560
the unique index that's been given
to your thread as they are created.

00:21:18.630 --> 00:21:20.990
If you want to do a backtrace,
you can type thread backtrace,

00:21:21.120 --> 00:21:24.010
or we do have shortcuts
for the GDB users,

00:21:24.040 --> 00:21:26.730
which is BT, stands for backtrace.

00:21:26.940 --> 00:21:31.430
To backtrace all of your threads,
you can type bt all.

00:21:32.290 --> 00:21:33.900
Now, if we move on to the frame,
same thing.

00:21:33.900 --> 00:21:36.560
We can discover the variety
of different things that we

00:21:36.560 --> 00:21:38.300
can do with the frame itself.

00:21:38.410 --> 00:21:42.160
Basically, frame select is how you switch
between the different frames.

00:21:42.270 --> 00:21:45.900
We've got a shortcut to keep
up with the GDB commands.

00:21:45.900 --> 00:21:49.900
We can also go up or down to select the
frame that appears above or below us.

00:21:51.930 --> 00:21:53.410
And one of the important
things that's different from

00:21:53.410 --> 00:21:56.300
GDB is how you get variables,
your locals and your arguments.

00:21:56.440 --> 00:21:58.930
You ask the frame to
show you its variables.

00:21:59.050 --> 00:22:04.340
This command is equivalent to both the
info locals and the info args commands

00:22:04.350 --> 00:22:07.410
from GDB kind of built into one command.

00:22:07.930 --> 00:22:11.480
The last thing I wanted to talk
about in terminology is modules.

00:22:11.500 --> 00:22:15.560
When you create a debug session,
you might have your main executable

00:22:15.560 --> 00:22:18.230
and you might have one or more shared
libraries that goes along with that.

00:22:18.260 --> 00:22:21.480
When you type target modules list,
you can see a list of all the

00:22:21.560 --> 00:22:23.860
shared libraries that are currently
involved in your debug session.

00:22:23.860 --> 00:22:26.890
This is equivalent to the
GDB's info shared command.

00:22:26.900 --> 00:22:30.660
There's a lot of different things that
you can do with the target modules list.

00:22:30.800 --> 00:22:33.860
With the seed,
you can actually specify an exact file

00:22:33.860 --> 00:22:36.600
if you're only interested in seeing the
details on one of your shared libraries,

00:22:37.110 --> 00:22:39.490
and you can specify that file
by the base name or by the

00:22:39.490 --> 00:22:40.940
full shared library path name.

00:22:40.940 --> 00:22:44.300
You can also dump the symbol
tables or the sections,

00:22:44.300 --> 00:22:47.450
but the ones that you guys will
probably find yourself using is

00:22:47.450 --> 00:22:49.250
the target modules lookup command.

00:22:49.260 --> 00:22:51.530
It says, look up something by address.

00:22:51.540 --> 00:22:54.390
Show me what file and line
and function this comes from.

00:22:54.400 --> 00:22:59.120
Also, to look up a type,
you can type target modules lookup with

00:22:59.160 --> 00:23:00.910
the type option and specify a type name.

00:23:02.620 --> 00:23:04.740
So that kind of wraps up the terminology.

00:23:04.790 --> 00:23:07.730
If you need help on any of the
commands that you discover,

00:23:07.740 --> 00:23:10.100
you can type help followed
by the command name,

00:23:10.100 --> 00:23:14.100
and we'll output a man-page
style section of help.

00:23:14.160 --> 00:23:17.600
Now, if we scroll down,
we can see that we actually

00:23:17.620 --> 00:23:21.200
have an option down here
that's the format option.

00:23:21.200 --> 00:23:24.420
And the format says that it
takes a format option type.

00:23:24.520 --> 00:23:28.980
You can also get help on option types
as well by typing help followed by the

00:23:28.990 --> 00:23:31.630
text that you see in the option values.

00:23:31.640 --> 00:23:34.480
And here we can see that when
you're specifying a format,

00:23:34.480 --> 00:23:37.970
you can specify a whole bunch of
different things so you can see

00:23:37.970 --> 00:23:40.030
the data exactly how you want to.

00:24:00.470 --> 00:24:00.470
If you don't know what
you're looking for,

00:24:00.470 --> 00:24:00.470
but you know it has something
to do with the thread,

00:24:00.470 --> 00:24:00.470
you can use the apropos command.

00:24:00.470 --> 00:24:00.470
Apropos takes one or more keywords.

00:24:00.470 --> 00:24:00.470
Again, it's very similar to GDB.

00:24:00.470 --> 00:24:00.470
And it'll dump out a list
of the different commands

00:24:00.470 --> 00:24:00.470
that you can actually use.

00:24:00.470 --> 00:24:00.470
You can go type help on those commands
to see further what you can do with each

00:24:00.470 --> 00:24:00.470
command after reading the descriptions.

00:24:01.210 --> 00:24:03.580
So that wraps up the terminology.

00:24:03.600 --> 00:24:07.230
Let's look at how we can actually
customize the commands themselves.

00:24:07.430 --> 00:24:09.700
We've got three different
ways to customize commands.

00:24:09.730 --> 00:24:10.900
We've got some simple aliases.

00:24:10.900 --> 00:24:12.970
We've got regular expression commands.

00:24:12.970 --> 00:24:15.750
And we also have a way to
make user-defined commands,

00:24:15.750 --> 00:24:19.600
in case we have missed a command that
you missed in a previous debugger.

00:24:21.290 --> 00:24:22.940
With simple aliases, it's very simple.

00:24:22.950 --> 00:24:24.300
We use the command alias command.

00:24:24.370 --> 00:24:26.850
You specify an alias name,
and you specify one or more things that

00:24:26.850 --> 00:24:28.380
you'd like us to type in its place.

00:24:28.380 --> 00:24:31.950
Here, we're going to remake the
aliases for the up and down,

00:24:31.950 --> 00:24:36.720
which selects the next and previous
frame by creating quick aliases to them.

00:24:37.530 --> 00:24:39.880
We can also use positional
argument inclusion.

00:24:40.160 --> 00:24:44.010
Here, we're going to make an alias for
being able to disassemble a range.

00:24:44.010 --> 00:24:47.150
And we'll make it, you know,
insert the arguments exactly

00:24:47.150 --> 00:24:48.820
where we want them to go.

00:24:49.700 --> 00:24:50.240
Any arguments that we want to make,
we can make them in the same way.

00:24:50.620 --> 00:24:52.530
Any arguments that aren't specified
on the command line or aren't

00:24:52.580 --> 00:24:54.700
positionally included will be
appended onto the end of your alias.

00:25:20.940 --> 00:25:23.900
And we'll also make sure that
we're not using any of the

00:25:23.900 --> 00:25:27.520
same alias for the up and down,
which selects the next and previous

00:25:27.610 --> 00:25:30.180
frame by creating quick aliases to them.

00:25:30.810 --> 00:25:33.550
We're going to create an alias called F,
which is going to do a variety

00:25:33.550 --> 00:25:34.680
of different things for us.

00:25:34.680 --> 00:25:37.080
First off, we're going to specify
a regular expression,

00:25:37.080 --> 00:25:40.460
and if the arguments match
just a number on a line,

00:25:40.460 --> 00:25:43.390
we're going to actually substitute
it into the frame select command.

00:25:43.400 --> 00:25:46.940
If it matches plus or minus
followed by a number on the line,

00:25:46.940 --> 00:25:51.370
we'll substitute it into the frame
select inside the relative option.

00:25:51.390 --> 00:25:53.950
And then anything else,
we'll just pass on to the

00:25:53.950 --> 00:25:55.470
frame variable command.

00:25:55.470 --> 00:25:58.830
So we've just implemented
the argument overloading that

00:25:59.040 --> 00:26:00.680
we're used to from within GDL.

00:26:28.250 --> 00:26:32.600
I see there's some people that
know what a regular expression is.

00:26:32.600 --> 00:26:34.980
So now if we move on to
user-defined commands,

00:26:34.980 --> 00:26:36.500
we have Python built in.

00:26:36.540 --> 00:26:38.660
Make the command with Python.

00:26:38.760 --> 00:26:41.280
So all you have to do is
create a Python module,

00:26:41.310 --> 00:26:44.290
which is just a fancy word for a
Python file that creates a function

00:26:44.350 --> 00:26:46.480
with the following prototype.

00:26:46.680 --> 00:26:51.410
Then we can actually import the module
into LLDB itself and bind it up.

00:26:51.570 --> 00:26:53.730
And to show this,
let's go through a quick example.

00:26:53.830 --> 00:26:58.500
Let's say I cannot live without being
able to list files inside of LLDB itself.

00:26:58.640 --> 00:27:01.100
The ls command,
for those that might not know,

00:27:01.100 --> 00:27:04.560
is a command you run from the
terminal that lists files for you.

00:27:04.590 --> 00:27:06.830
And we're going to take a look
at the file that it takes to

00:27:06.890 --> 00:27:09.070
implement this command in Python.

00:27:09.130 --> 00:27:12.120
First, we mention Python.

00:27:12.160 --> 00:27:15.480
Then we import the LLDB module so
that we can actually use some of the

00:27:15.480 --> 00:27:17.990
debugger objects that are passed into us.

00:27:18.260 --> 00:27:22.040
Then we import a Python module that
allows us to run a shell script or a

00:27:22.040 --> 00:27:24.640
shell command and get the textual output.

00:27:24.820 --> 00:27:26.770
And then we create our function.

00:27:26.900 --> 00:27:30.020
We quickly create a string
that we want to go execute.

00:27:30.020 --> 00:27:32.790
We run it out in the shell
and get the result back.

00:27:32.930 --> 00:27:37.130
And we can put the result right into
the result object that was passed in.

00:27:37.130 --> 00:27:38.240
That simple.

00:27:38.280 --> 00:27:40.840
Now we run LLDB from the command line.

00:27:40.980 --> 00:27:45.440
We type command script import and
specify a path to our Python file.

00:27:45.550 --> 00:27:49.510
And now we need to bind up a new
command to the actual function

00:27:49.510 --> 00:27:51.130
inside of that file itself.

00:27:51.130 --> 00:27:55.000
To do that,
we use the command script add command.

00:27:55.000 --> 00:27:58.250
Now we specify that we want to
bind it to a Python function.

00:27:58.440 --> 00:28:00.700
And we have to give it
the Python module name,

00:28:00.700 --> 00:28:03.680
which is the same as the name
of the file that you used.

00:28:03.680 --> 00:28:06.920
And we also bind it to a
function inside of that module.

00:28:06.920 --> 00:28:09.380
So inside of one Python module,
you can have multiple commands

00:28:09.460 --> 00:28:10.750
that you can actually bind up.

00:28:10.930 --> 00:28:15.090
And then all we do is give it a quick
command name that we want to use.

00:28:15.200 --> 00:28:17.060
In this case, we'll use LS.

00:28:17.060 --> 00:28:19.500
And from here on out,
when you're in the debugger,

00:28:19.500 --> 00:28:21.830
if you type the LS command,
you can see that you've actually

00:28:21.830 --> 00:28:21.960
just added shell scripting.

00:28:21.960 --> 00:28:24.260
And then you can see that you've actually
just added shell script-- you know,

00:28:24.310 --> 00:28:26.790
shell support into your debugger.

00:28:31.330 --> 00:28:33.140
So this is a very simple example.

00:28:33.140 --> 00:28:36.240
And I just wanted to show something quick
so we could see how easy it is to just

00:28:36.250 --> 00:28:39.690
get the command interpreter to come in
and call your Python function itself.

00:28:39.930 --> 00:28:44.400
But we actually have a lot of different
objects that are built into Python.

00:28:44.400 --> 00:28:47.630
The debugger has access to
all of your current targets.

00:28:47.740 --> 00:28:50.400
Each of your targets has
access to the process.

00:28:50.400 --> 00:28:53.750
Your process has access to the
objects that back your threads.

00:28:53.780 --> 00:28:56.060
Your threads have access to your frames,
and your frames have

00:28:56.180 --> 00:28:57.380
access to your variables.

00:28:58.280 --> 00:29:01.440
You have access to everything that's
contained inside the debugger.

00:29:01.480 --> 00:29:05.610
So there's a lot of different uses that
you can do to make commands where you

00:29:05.680 --> 00:29:07.360
can introspect your current process.

00:29:07.440 --> 00:29:11.970
There's global objects that actually
represent the current process

00:29:11.970 --> 00:29:15.580
and the current frame and the
current thread that are selected

00:29:15.580 --> 00:29:17.520
inside the command interpreter.

00:29:17.520 --> 00:29:21.230
And we've got a web page for
you up at ldb.lvm.org in the

00:29:21.230 --> 00:29:23.880
Python reference section down here.

00:29:23.900 --> 00:29:26.850
Highly recommend going
and checking this out.

00:29:27.000 --> 00:29:30.130
It'll explain all of the various
variables that are predefined for you.

00:29:30.140 --> 00:29:32.050
It'll explain how to get help.

00:29:32.210 --> 00:29:35.240
We have a command template that is
kind of a hollowed out version of

00:29:35.240 --> 00:29:37.520
one of these commands that we've
just shown you that has a few

00:29:37.520 --> 00:29:39.140
more bells and whistles built in.

00:29:39.140 --> 00:29:43.320
So there's a lot of great
resources up on the website.

00:29:44.240 --> 00:29:45.840
Now,
we've learned about a lot of commands,

00:29:45.840 --> 00:29:47.990
and you might want to put some
of these commands into your

00:29:47.990 --> 00:29:49.490
debug session every time you run.

00:29:49.500 --> 00:29:53.850
For that, just like GDB,
GDB has an initialization

00:29:53.860 --> 00:29:55.360
file called .gdbnit.

00:29:55.360 --> 00:29:57.920
We made a .ldbnit file as well.

00:29:57.920 --> 00:30:01.140
Now, this is a great place to add any
commands that you want to run

00:30:01.140 --> 00:30:03.060
just after LLDB gets launched.

00:30:03.060 --> 00:30:05.130
And, of course,
there's a lot of different

00:30:05.210 --> 00:30:08.780
things that you can do that
you can put into these files,

00:30:08.820 --> 00:30:12.240
and we'll leave that to you
guys to decide what there is,

00:30:12.390 --> 00:30:16.020
but we're going to talk about some type
formatting commands a little later on.

00:30:16.040 --> 00:30:18.800
This would be a great place
for you guys to put those.

00:30:18.800 --> 00:30:21.500
Now,
there's a little bit more information

00:30:21.500 --> 00:30:26.830
that we need to go through about what
initialization files we'll actually load.

00:30:26.840 --> 00:30:29.400
First and foremost,
when we launch an application,

00:30:29.400 --> 00:30:33.470
we'll look for an application-specific
version of your LLDB.nit file.

00:30:33.480 --> 00:30:38.590
In this case, if we're running Xcode,
we'll look for a .ldbnit-xcode.

00:30:38.600 --> 00:30:41.520
If that file's there,
we'll actually source that file,

00:30:42.060 --> 00:30:44.250
and if it's not there,
we'll actually just look

00:30:44.250 --> 00:30:47.660
for the .ldbnit file itself,
and then your debug session will start.

00:30:47.700 --> 00:30:51.060
With the command line,
we go one step further.

00:30:51.060 --> 00:30:55.080
If we first change directory
into the temporary directory,

00:30:55.080 --> 00:30:57.640
we go create a new debug session.

00:30:57.640 --> 00:30:59.480
What kind of files get loaded?

00:30:59.480 --> 00:31:02.170
Well, first,
we look for the application-specific

00:31:02.180 --> 00:31:07.480
version of the initialization file,
our LLDB.nit-ldb.

00:31:07.480 --> 00:31:10.340
If that file does not exist,
we back up and just load

00:31:10.450 --> 00:31:14.790
the LLDB.nit file itself,
we then load the program that you

00:31:14.920 --> 00:31:17.090
specified on the command line,
and then we actually also

00:31:17.090 --> 00:31:20.000
look in the current working
directory for an LLDB.nit file.

00:31:20.000 --> 00:31:23.740
This allows you to place an LLDB.nit
file in your current working directory,

00:31:23.740 --> 00:31:26.520
wherever you're debugging from,
and it allows you to have a place

00:31:26.520 --> 00:31:29.860
where you can actually set breakpoints
or set up your debug session so

00:31:29.860 --> 00:31:32.490
that you don't have to type in all
the commands every time you run.

00:31:38.200 --> 00:31:40.440
So we're going to go through
just a few things about launching

00:31:40.440 --> 00:31:42.540
programs because there's a few
things that you might not know.

00:31:42.540 --> 00:31:46.960
When we launch programs with arguments,
we can actually specify those

00:31:46.960 --> 00:31:48.630
arguments on the command line itself.

00:31:48.660 --> 00:31:51.180
Here we use XCRUN to run LLDB.

00:31:51.180 --> 00:31:53.920
We're going to launch a
program called PrintArgs.

00:31:53.990 --> 00:31:56.330
Its sole job is to print out
the arguments that were passed

00:31:56.330 --> 00:31:58.510
to the program and then quit.

00:31:58.660 --> 00:32:01.520
So in LLDB, if we type run,
we can see that we didn't

00:32:01.630 --> 00:32:04.270
specify any arguments,
but remembered the actual arguments

00:32:04.370 --> 00:32:05.910
that you specified on the command line.

00:32:07.080 --> 00:32:10.150
If you rerun again,
we'll run with those same arguments.

00:32:10.200 --> 00:32:13.450
But if you specify different arguments,
you can notice that we'll

00:32:13.450 --> 00:32:14.880
actually update the arguments.

00:32:14.920 --> 00:32:17.170
And the next time you run,
we'll remember the last set

00:32:17.170 --> 00:32:18.410
of arguments that you used.

00:32:20.600 --> 00:32:21.720
Setting environment variables.

00:32:21.740 --> 00:32:23.910
There's a right way and a wrong way,
depending on what kind of

00:32:23.930 --> 00:32:25.160
environment variable you're setting.

00:32:25.160 --> 00:32:27.710
A common thing to do is to
go to your shell and set the

00:32:27.710 --> 00:32:29.450
environment variable there.

00:32:29.450 --> 00:32:31.950
Then we go ahead and run the debugger.

00:32:31.950 --> 00:32:34.670
We launch the process,
and we can interrupt it and see that

00:32:34.720 --> 00:32:36.890
the actual environment variable got set.

00:32:37.130 --> 00:32:40.680
But that's a good idea only if
the environment variable only

00:32:40.680 --> 00:32:42.880
affects your current program.

00:32:44.060 --> 00:32:46.250
The malloc stack logging,
as some of you might know,

00:32:46.260 --> 00:32:51.030
enables a very expensive system-wide
feature that tracks every allocation

00:32:51.160 --> 00:32:55.700
and every free and makes a stack
backtrace to it inside of this file.

00:32:55.700 --> 00:32:57.340
So it's a pretty
expensive thing to enable.

00:32:58.010 --> 00:33:00.820
And by setting this environment
variable in our shell,

00:33:00.820 --> 00:33:04.680
we've just actually run LLDB and
XCRUN with that functionality enabled.

00:33:06.630 --> 00:33:09.380
So the way around this is to not set
the environment variable in your shell,

00:33:09.380 --> 00:33:13.490
but just use the process launch
command with the dash dash.

00:33:14.420 --> 00:33:18.440
We can use the short style option and
specify it more than once if we want to

00:33:18.440 --> 00:33:19.940
set more than one environment variable.

00:33:19.940 --> 00:33:23.260
But this is a great way to ensure
that the environment variables

00:33:23.260 --> 00:33:26.740
that you set only get set for the
program that you want to debug.

00:33:29.590 --> 00:33:31.800
Another great feature if we've got
anyone that's doing command line

00:33:31.800 --> 00:33:35.520
debugging is we have the ability to
launch your program in a standalone

00:33:35.520 --> 00:33:38.120
terminal with the --tty option.

00:33:38.160 --> 00:33:42.250
That'll pop open a brand-new window where
your debugger is still in one window

00:33:42.250 --> 00:33:46.280
and your debug session's in another
and allow you to debug your program.

00:33:46.500 --> 00:33:51.020
Now, if you debug VI or Emacs or anything
else that actually mucks with the

00:33:51.020 --> 00:33:54.170
terminal settings by playing with
the echo settings and a lot of other,

00:33:54.220 --> 00:33:59.000
you know, complex things,
this feature will be for you.

00:34:00.480 --> 00:34:04.220
So let's get into a debug session now
where we'll kind of stop along the way

00:34:04.220 --> 00:34:05.910
and see where LLDB can help us out.

00:34:06.130 --> 00:34:09.150
And in this debug session,
we're going to use a very simple class.

00:34:09.260 --> 00:34:12.700
Here we have a pointer array class
that's got two instance variables.

00:34:12.700 --> 00:34:16.950
It's got a pointer to some pointers,
and it also has a size.

00:34:17.040 --> 00:34:20.950
Now, if we start our debug
session in Xcode and run,

00:34:20.950 --> 00:34:22.850
we note that we get an assertion.

00:34:22.900 --> 00:34:27.350
And if we take a look at our code here,
we can see that we actually checked

00:34:27.450 --> 00:34:30.280
if our value of pointers was nil,
and it was nil.

00:34:30.280 --> 00:34:32.710
And so we assume that
the size would be zero,

00:34:32.710 --> 00:34:36.330
but it isn't, and that's why we had the
assertion in our code.

00:34:36.340 --> 00:34:38.350
If we take a look at the
bottom of the screen,

00:34:38.350 --> 00:34:40.420
we see that size is
this very large number.

00:34:40.420 --> 00:34:44.490
Now, this might be a random number we
might have gotten scribbled on

00:34:44.490 --> 00:34:46.660
by some other thing on the stack.

00:34:46.660 --> 00:34:48.360
We might have had some other issues.

00:34:48.360 --> 00:34:52.020
But let's take a look
at this value in hex.

00:34:52.020 --> 00:34:54.370
So if we right-click
on the variable itself,

00:34:54.370 --> 00:34:56.460
we can actually set the value to hex.

00:34:56.460 --> 00:34:59.580
But this might not be what we want to do,
because the size you're

00:34:59.790 --> 00:35:00.370
going to get is nil.

00:35:00.380 --> 00:35:02.470
So we normally going to want to
see that as a decimal number.

00:35:02.530 --> 00:35:04.830
So another way that you can
actually implement this is go

00:35:04.830 --> 00:35:07.580
over into the command line and
use the frame variable command.

00:35:07.730 --> 00:35:09.400
With frame variable,
you're asking the frame to

00:35:09.400 --> 00:35:10.660
show you one of its variables.

00:35:10.790 --> 00:35:13.710
We can specify an alternate format
so that we don't override the

00:35:13.710 --> 00:35:15.780
format permanently on that variable.

00:35:15.850 --> 00:35:17.880
And then we can specify a path.

00:35:17.880 --> 00:35:19.960
And we can see that our
variable contains all Fs.

00:35:19.980 --> 00:35:22.210
Now, for me,
that's a sign that I took zero

00:35:22.210 --> 00:35:24.930
and I probably decremented
it one too many times.

00:35:25.080 --> 00:35:29.830
So if we run our debug session again
and stop before things go wrong,

00:35:29.990 --> 00:35:32.280
we take a look at our
variables and we say,

00:35:32.280 --> 00:35:32.980
"Wait a minute.

00:35:32.980 --> 00:35:36.600
I've got some uint pointer Ts,
which are actually pointers,

00:35:36.600 --> 00:35:39.430
and we're actually seeing
them as decimal." Now,

00:35:39.610 --> 00:35:43.170
one fix for this would be to every
time you stopped in your code

00:35:43.220 --> 00:35:45.470
when you're debugging an Xcode,
right-click on the

00:35:45.470 --> 00:35:46.830
variable and set it to hex.

00:35:46.990 --> 00:35:48.810
Next time you run and
stop somewhere else,

00:35:49.100 --> 00:35:50.880
right-click again, set it to hex.

00:35:50.930 --> 00:35:54.280
You can be right-clicking all day,
or you can actually use one of the

00:35:54.350 --> 00:35:57.850
new features inside of LDB where
we can actually override the format

00:35:58.090 --> 00:35:59.480
permanently for a given type.

00:35:59.580 --> 00:36:03.080
For that,
we use the type format add command.

00:36:03.080 --> 00:36:07.470
We specify a format, and in this case,
hex, and we can give it one or more

00:36:07.470 --> 00:36:09.470
type names to apply it to.

00:36:09.480 --> 00:36:14.850
Now, any time we see a uint pointer T,
an int pointer T, or an off T,

00:36:14.980 --> 00:36:18.100
we can actually view those as hex,
both from the command line

00:36:18.120 --> 00:36:21.450
itself and also back in the UI.

00:36:24.780 --> 00:36:29.510
Now, if we run again and we stop before
we actually try and find our problem,

00:36:29.510 --> 00:36:32.640
we can see our pointer array
down here in the variable view,

00:36:32.640 --> 00:36:34.780
and it's not expanded by default.

00:36:34.780 --> 00:36:37.210
So again, everywhere that you're
going to run and stop,

00:36:37.290 --> 00:36:40.040
you're going to see that your pointer
array is not going to be expanded.

00:36:40.040 --> 00:36:42.550
You're going to have to go expand
it just to see what's inside of it.

00:36:42.640 --> 00:36:44.860
And if we expand it and
take a look inside of it,

00:36:44.860 --> 00:36:47.970
we can see that it actually
doesn't contain that much stuff.

00:36:48.060 --> 00:36:50.400
It wouldn't be that hard to
create a summary for this.

00:36:51.080 --> 00:36:54.360
So we can in LLDB,
using the type summary add command,

00:36:54.360 --> 00:36:58.770
we can specify a summary string
that actually refers to the

00:36:58.770 --> 00:37:02.220
variable itself and to instance
variables inside the variable,

00:37:02.220 --> 00:37:06.720
as well as including some plain text,
and then we can apply it to a type.

00:37:06.800 --> 00:37:10.260
Now, if we view that variable,
we can see that we actually see a

00:37:10.260 --> 00:37:13.900
quick summary both in the command
line and up in Xcode itself.

00:37:14.220 --> 00:37:18.840
Now, the summary string syntax
can contain plain text.

00:37:18.880 --> 00:37:21.060
It can contain references
to your variables.

00:37:21.060 --> 00:37:24.190
And you can optionally override
the format in which that is

00:37:24.250 --> 00:37:26.120
used to display your variable.

00:37:26.140 --> 00:37:29.200
So variable path references are
contained inside of a dollar

00:37:29.270 --> 00:37:32.150
sign and a squiggly bracket,
just to make it unique so that

00:37:32.150 --> 00:37:33.630
you can type in plain text.

00:37:33.720 --> 00:37:37.400
You can optionally specify a
path down inside that variable,

00:37:37.400 --> 00:37:39.830
and you can also override the format.

00:37:39.840 --> 00:37:43.140
The formats are the same formats
that we looked at at the beginning

00:37:43.140 --> 00:37:46.360
when we typed help and we got
help on the option type of format.

00:37:46.380 --> 00:37:49.450
And it just helps to see
some example strings.

00:37:49.480 --> 00:37:50.960
Here's a quick string.

00:37:50.960 --> 00:37:53.450
We've got stuff color coded
so you can see what's what.

00:37:53.910 --> 00:37:58.420
Where we specify some plain text,
natural is equal to the variable.

00:37:58.610 --> 00:38:00.570
And we would insert the
value of the variable in its

00:38:00.580 --> 00:38:01.950
natural format right there.

00:38:02.110 --> 00:38:05.510
Octal is equal to the variable,
and then we actually want to override

00:38:05.520 --> 00:38:07.170
the format for this and show it as octal.

00:38:07.200 --> 00:38:11.020
So we can quickly see that there's
a lot of different ways to customize

00:38:11.150 --> 00:38:14.750
your debug session for your types,
show a nice little succinct

00:38:14.840 --> 00:38:18.620
summary both in the command
line and up in Xcode itself.

00:38:18.680 --> 00:38:19.720
So if we take a look back at our code,
we can see that we've got a lot

00:38:19.740 --> 00:38:20.910
of different ways to customize
your debug session for your types.

00:38:20.950 --> 00:38:23.070
So if we take a look back at our code,
once we've run and we've done this,

00:38:23.150 --> 00:38:25.010
we can see that we've got
a nice little summary.

00:38:25.200 --> 00:38:29.120
We can keep an eye on this summary
as we step along and watch for

00:38:29.120 --> 00:38:33.230
our size to kind of go to that,
you know, incorrect value.

00:38:33.290 --> 00:38:36.970
And we see that as soon
as we step over line 120,

00:38:37.110 --> 00:38:40.580
we've caused our problem to show up,
our size is this invalid value,

00:38:40.860 --> 00:38:44.790
and we should step into the
function call at line 120.

00:38:45.800 --> 00:38:49.130
So we've got a page up on the website,
again, that talks about variable

00:38:49.130 --> 00:38:50.670
formatting down on the left.

00:38:50.670 --> 00:38:53.810
There's a whole bunch of stuff
that we haven't gotten to today,

00:38:53.810 --> 00:38:55.140
just didn't have time.

00:38:55.140 --> 00:38:58.720
We've got ways for you guys to run
Python functions that can actually

00:38:58.720 --> 00:39:00.740
create a new summary string for you.

00:39:00.740 --> 00:39:05.060
So you can use flow control to discover
what kind of type you might want to show.

00:39:05.060 --> 00:39:07.550
You might want to look
at your variable and say,

00:39:07.550 --> 00:39:11.370
if size is greater than, you know,
a million, then print error.

00:39:11.440 --> 00:39:15.580
So you can actually use, you know,
flow control when you're doing this.

00:39:31.470 --> 00:39:33.240
So the other way that we could have
solved this problem is actually

00:39:33.240 --> 00:39:34.500
with the expression parser.

00:39:34.650 --> 00:39:37.600
And we talked about compiler
integration at the start of the talk.

00:39:37.750 --> 00:39:40.540
And really,
that's one of the best things about,

00:39:40.540 --> 00:39:42.060
you know, LLDB itself.

00:39:42.170 --> 00:39:45.100
So it's worth taking a step back and
looking at the different things that

00:39:45.100 --> 00:39:46.790
we can do with an expression parser.

00:40:02.810 --> 00:40:03.220
So for one,
if we run and we stop here in our code,

00:40:03.220 --> 00:40:03.580
and if we're going to
write an expression,

00:40:03.580 --> 00:40:04.080
think of it as if we actually
made a little space right before

00:40:04.080 --> 00:40:04.560
where your program counter
is and inserted a new scope.

00:40:04.560 --> 00:40:05.230
And any expression that you type there
actually appears inside of that scope.

00:40:05.230 --> 00:40:05.800
And that'll become evident in a second.

00:40:06.850 --> 00:40:09.180
For people that might not
know what an expression is,

00:40:09.250 --> 00:40:12.550
it's a statement that you type that gets
evaluated as if it were in your code.

00:40:12.790 --> 00:40:16.800
The result gets displayed and actually
gets saved into a convenience store.

00:40:17.480 --> 00:40:19.620
So if you want to do that,
you can do that with a

00:40:19.620 --> 00:40:20.910
lot of different things.

00:40:21.050 --> 00:40:22.060
You can do arithmetic.

00:40:22.130 --> 00:40:23.130
You can say X plus Y.

00:40:23.130 --> 00:40:24.800
You can make function calls.

00:40:24.800 --> 00:40:26.740
You can do casting.

00:40:26.940 --> 00:40:29.800
And with LLDB, you can do much,
much more.

00:40:30.550 --> 00:40:33.780
So if we get back to our code,
we can do a simple expression like

00:40:33.780 --> 00:40:37.680
this where we just check for the
equality of an item inside of our array.

00:40:37.680 --> 00:40:41.800
But we have a compiler
as our expression parser.

00:40:41.800 --> 00:40:43.790
We're not limited to single statements.

00:40:43.940 --> 00:40:45.800
We can do multiple statements.

00:40:46.400 --> 00:40:48.800
We can actually declare
expression local variables.

00:40:49.060 --> 00:40:53.160
Here we declare a typed expression
local variable whose lifetime is

00:40:53.160 --> 00:40:55.800
good for only the expression itself.

00:40:55.800 --> 00:40:58.800
We made uint pointer ti equals 12.

00:40:58.800 --> 00:41:01.680
And then we used that variable
and added it to something that

00:41:01.680 --> 00:41:03.320
was actually in our program.

00:41:03.570 --> 00:41:07.450
We can actually create expression
global variables that are typed.

00:41:07.620 --> 00:41:10.420
Here we declare a variable,
and if you put a dollar sign at

00:41:10.420 --> 00:41:13.950
the beginning of the variable name,
it will persist for longer than

00:41:13.960 --> 00:41:15.500
just the current expression.

00:41:15.610 --> 00:41:17.690
And it's something that
you got to type yourself.

00:41:17.760 --> 00:41:20.020
It's not the result of
expression that you had to cast.

00:41:20.160 --> 00:41:22.780
You get to explicitly
tell us what type it is.

00:41:22.810 --> 00:41:25.050
Now, we can use that expression
global variable,

00:41:25.230 --> 00:41:26.610
and we can also use flow control.

00:41:26.620 --> 00:41:28.090
You can use an if statement.

00:41:28.090 --> 00:41:30.540
So...

00:41:31.220 --> 00:41:32.650
Now,
one of the things that you might want

00:41:32.650 --> 00:41:36.840
to do when evaluating your expression is
stop while evaluating your expression.

00:41:36.840 --> 00:41:39.340
Here,
if we run the expression command and we

00:41:39.340 --> 00:41:43.670
use one of these fancy options that says
unwind on error and we set that to zero,

00:41:43.670 --> 00:41:45.280
what is that going to do?

00:41:45.280 --> 00:41:47.500
Well,
usually if you run an expression and

00:41:47.500 --> 00:41:50.990
you cause an exception to occur or
if you dereference bad memory or you

00:41:51.120 --> 00:41:54.350
do a lot of other different things,
we'll stop your expression,

00:41:54.450 --> 00:41:57.900
we'll wipe it away from your program
as if it never happened and just

00:41:57.920 --> 00:42:00.200
go on with what you were executing.

00:42:00.200 --> 00:42:03.640
But you might actually want
to stop while you're actually

00:42:03.640 --> 00:42:06.050
inside of this expression to go,
wait a minute,

00:42:06.060 --> 00:42:07.310
why did this expression not work?

00:42:07.310 --> 00:42:10.210
So if you use the unwind on
error and we set that to zero,

00:42:10.290 --> 00:42:12.640
that'll allow us to stop at breakpoints.

00:42:12.680 --> 00:42:15.270
You can stop when you hit an
exception to figure out why

00:42:15.290 --> 00:42:16.780
your expression didn't work.

00:42:16.850 --> 00:42:18.840
You can do a lot of different things.

00:42:20.260 --> 00:42:23.640
Now, to reproduce our problem,
we just had to call the pop function

00:42:23.680 --> 00:42:26.010
a bunch of times in a row until
we actually got our assertion.

00:42:26.010 --> 00:42:29.740
So let's go ahead and use flow control
to use a while loop and say while

00:42:30.110 --> 00:42:33.440
we have a size greater than zero,
keep calling pop and just

00:42:33.440 --> 00:42:35.140
make my problem happen.

00:42:35.140 --> 00:42:37.730
You don't need to go inject
code into your program and rerun

00:42:37.840 --> 00:42:39.300
it to make the problem happen.

00:42:39.300 --> 00:42:42.100
You can just make it happen
in your expression parser.

00:43:08.690 --> 00:43:08.690
This has some great,
you can do some great things with this.

00:43:08.690 --> 00:43:08.690
If you just got done writing a
function and you want to test out the

00:43:08.690 --> 00:43:08.690
boundary conditions of your function
by calling it with a high number,

00:43:08.690 --> 00:43:08.690
a low number,
or a whole set of different parameters,

00:43:08.690 --> 00:43:08.690
you can actually set
breakpoints inside of your code,

00:43:08.690 --> 00:43:08.690
use the unwind on error option and set
it to zero and stop at your breakpoints

00:43:08.690 --> 00:43:08.690
and explore while you're evaluating
your expression without actually

00:43:08.690 --> 00:43:08.690
injecting the code into your program.

00:43:12.970 --> 00:43:14.600
Now, we've got a compiler, right?

00:43:14.710 --> 00:43:16.680
So we can actually define local types.

00:43:16.680 --> 00:43:18.950
Now,
there's a lot of great implications here.

00:43:19.140 --> 00:43:21.790
Some people use, you know,
the expression parser like

00:43:21.790 --> 00:43:23.050
a compiler scratchpad.

00:43:23.090 --> 00:43:26.330
What would happen if I typed this in,
and if I made a zero-sized array,

00:43:26.450 --> 00:43:27.840
how big would that thing be?

00:43:27.840 --> 00:43:30.550
Well, we've got the compiler
answering the question,

00:43:30.580 --> 00:43:33.070
not just a, you know,
kind of a handmade expression

00:43:33.070 --> 00:43:35.820
parser that might not get the
same result as a compiler.

00:43:35.820 --> 00:43:38.410
So you can actually really
trust the results that come

00:43:38.420 --> 00:43:40.930
back from these kind of things.

00:44:04.290 --> 00:44:04.290
Also, if you have an opaque data type and
you're debugging your shared library at,

00:44:04.290 --> 00:44:04.290
say, a client's office,
and you know that this first argument

00:44:04.290 --> 00:44:04.290
to something is actually a simple type
that you can recreate really quickly,

00:44:04.290 --> 00:44:04.290
you can go into your expression,
recreate your type,

00:44:04.290 --> 00:44:04.290
cast one of the current void
star arguments into a type,

00:44:04.290 --> 00:44:04.290
and actually use it in place.

00:44:04.290 --> 00:44:04.290
So...

00:44:04.820 --> 00:44:07.170
One of the other great things that
we can do with this expression,

00:44:07.170 --> 00:44:09.550
because we can have multiple
lines in our expressions,

00:44:09.590 --> 00:44:12.140
or multiple statements,
is we want to be able to probably

00:44:12.250 --> 00:44:15.180
type more than one line when
we're entering expressions.

00:44:15.180 --> 00:44:19.150
Here, if you type the expression command,
but you don't specify an expression,

00:44:19.170 --> 00:44:21.880
you can actually enter
multiple line expression mode,

00:44:21.880 --> 00:44:24.380
where you type as many
things as you want to.

00:44:24.380 --> 00:44:27.000
Here, we'll declare a couple
of local variables.

00:44:27.130 --> 00:44:29.520
We'll use a while loop to
iterate through the arguments

00:44:29.520 --> 00:44:31.200
that were passed to our program.

00:44:31.580 --> 00:44:34.010
We'll print something out,
and the last statement in our

00:44:34.170 --> 00:44:36.800
expression will be the return
value of our expression.

00:44:36.800 --> 00:44:39.250
Here, I want to see how many
arguments there were,

00:44:39.250 --> 00:44:41.290
and I hit enter,
and we see that we actually

00:44:41.290 --> 00:44:43.870
run the code in there,
and we get the result back.

00:44:43.960 --> 00:44:46.630
So, again,
this is a great place to kind of go

00:44:46.710 --> 00:44:50.880
in and possibly call your new function
that you've just gotten done creating

00:44:51.280 --> 00:44:55.050
with your different boundary conditions,
and actually just using more

00:44:55.200 --> 00:44:58.050
than one statement in your
expressions in the debugger.

00:45:00.050 --> 00:45:03.590
One of the other differences that we
have in when evaluating expressions

00:45:03.590 --> 00:45:05.340
is the way that we evaluate them.

00:45:05.340 --> 00:45:09.310
With GDB, it would take an expression,
it would chop it up with its expression

00:45:09.320 --> 00:45:12.520
parser and create a tree that
would get evaluated every time you

00:45:12.520 --> 00:45:14.530
wanted to evaluate this expression.

00:45:14.530 --> 00:45:17.410
It would go grab the value
of 2.2 and the value of Y,

00:45:17.410 --> 00:45:20.320
and in GDB itself,
it would add the two things together,

00:45:20.320 --> 00:45:23.030
and then it would craft up
a function call and actually

00:45:23.060 --> 00:45:24.980
call the function itself.

00:45:26.110 --> 00:45:28.000
With LLDB,
we took a different tact because

00:45:28.000 --> 00:45:29.970
we have the compiler built in.

00:45:29.970 --> 00:45:34.280
We actually use Clang to compile the
expression into an internalized format.

00:45:34.280 --> 00:45:37.780
We run it through a code gen phase,
which actually creates

00:45:37.780 --> 00:45:39.200
code and data for us.

00:45:39.850 --> 00:45:43.350
We take your entire expression,
all of your statements and everything,

00:45:43.400 --> 00:45:45.900
and we download it into
your program and we run it.

00:45:45.900 --> 00:45:49.720
This means that you will get a
very accurate representation of

00:45:49.720 --> 00:45:53.670
how that expression would have ran,
not this evaluating a tree

00:45:53.670 --> 00:45:55.540
and doing each item wrong.

00:45:56.420 --> 00:46:00.540
It also helps ensure that whatever you're
evaluating is evaluated on the bare metal

00:46:00.580 --> 00:46:04.370
that you actually wanted to evaluate on,
not incorrectly possibly adding two

00:46:04.390 --> 00:46:07.750
floating point numbers on the desktop
system when it doesn't match the

00:46:07.750 --> 00:46:10.070
current settings in the debugger itself.

00:46:12.270 --> 00:46:14.260
The other thing that we can
do is we can actually inject

00:46:14.400 --> 00:46:16.740
checks into your expression to
make them safer to evaluate.

00:46:16.740 --> 00:46:19.380
If we take a look at
this expression here,

00:46:19.380 --> 00:46:21.580
we're going to be asked to
evaluate this expression.

00:46:21.600 --> 00:46:26.720
Now, the first item, the item here,
might not be valid.

00:46:26.720 --> 00:46:28.080
It might be uninitialized.

00:46:28.180 --> 00:46:28.910
It could be garbage.

00:46:28.920 --> 00:46:31.600
It could be something else that's
been trounced in your debug session.

00:46:31.600 --> 00:46:35.320
So if we compile up this
expression with Clang,

00:46:35.320 --> 00:46:38.840
we get an internalized compiler format.

00:46:38.840 --> 00:46:41.780
We can actually run a set of
checks over this expression.

00:46:42.370 --> 00:46:45.100
And we notice, hey,
we're dereferencing a pointer here.

00:46:45.100 --> 00:46:48.920
Why don't we go ahead and insert a
call that will check this pointer?

00:46:48.920 --> 00:46:51.780
And when it checks the pointer,
it'll try and read one byte of

00:46:51.780 --> 00:46:53.010
data from where the pointer lives.

00:46:53.080 --> 00:46:55.410
And if that fails,
it'll throw an exception and

00:46:55.580 --> 00:46:58.200
stop before any other bad
things happen to your program.

00:46:58.220 --> 00:47:01.640
Likewise,
we have an Objective-C object here.

00:47:01.640 --> 00:47:03.970
This object could have been on the stack.

00:47:04.080 --> 00:47:05.140
It could be uninitialized.

00:47:05.220 --> 00:47:08.540
It could contain the previous remnants
of a previous object that might be

00:47:08.540 --> 00:47:10.440
somewhat close but not really close.

00:47:10.460 --> 00:47:12.080
So we can actually call.

00:47:12.200 --> 00:47:17.500
It actually changes into a call that
checks the object much more thoroughly

00:47:17.500 --> 00:47:20.480
and actually asks the runtime to
verify that this object is good prior

00:47:20.560 --> 00:47:21.820
to calling it in your expression.

00:47:21.820 --> 00:47:24.920
So then we end up with a much
safer expression that we can

00:47:25.270 --> 00:47:26.770
evaluate in your program.

00:47:29.780 --> 00:47:31.700
So that was the in-depth tour into LLDB.

00:47:31.700 --> 00:47:35.200
Now let's take a look at a
few examples of how we can use

00:47:35.240 --> 00:47:37.100
LLDB in non-debugging scenario.

00:47:37.100 --> 00:47:42.260
And the best thing I can come up with is
how can I do symbolication using LLDB,

00:47:42.260 --> 00:47:43.920
and why would I want to?

00:47:43.920 --> 00:47:46.530
So first off,
we're going to manually symbolicate stuff

00:47:46.530 --> 00:47:49.930
so you guys know how to do it yourselves,
and then we'll actually use a

00:47:49.930 --> 00:47:53.150
module that's built into the
current Xcode 4.5c that you guys

00:47:53.170 --> 00:47:55.740
have received at the conference
to actually do it automagically.

00:47:56.840 --> 00:48:00.040
So the first thing we need when
we're actually going to symbolicate

00:48:00.040 --> 00:48:01.430
something is a crash log.

00:48:01.440 --> 00:48:06.430
Now, you take this crash log,
you open up LLDB, you grab the executable

00:48:06.550 --> 00:48:09.080
from your crash log,
and you specify it as the target,

00:48:09.080 --> 00:48:10.180
you locate it somehow.

00:48:10.180 --> 00:48:13.700
And then if you want to load
any other shared libraries,

00:48:13.700 --> 00:48:16.490
you can use the target modules
add to go locate all the correct

00:48:16.490 --> 00:48:19.500
copies of your shared libraries and
add them into your debug session.

00:48:19.500 --> 00:48:24.320
And after that,
here we actually load up DLD as well,

00:48:24.320 --> 00:48:25.840
just for fun.

00:48:26.840 --> 00:48:29.110
And after that,
we need to take a look at the

00:48:29.110 --> 00:48:32.340
addresses where these actual
shared libraries were loaded when

00:48:32.340 --> 00:48:33.760
your program actually crashed.

00:48:33.840 --> 00:48:36.940
And what these addresses are is
they're actually the address of your

00:48:36.940 --> 00:48:38.660
text segment inside of your program.

00:48:38.840 --> 00:48:42.870
Now, you can take these addresses
and use the target modules load,

00:48:43.250 --> 00:48:46.840
specify each of the files,
and tell us where the text segment lives.

00:48:46.840 --> 00:48:50.740
Now, once you've done this,
you have a debug session that is idly

00:48:50.740 --> 00:48:55.060
sitting there with the shared libraries
loaded at the exact same locations as the

00:48:55.060 --> 00:48:56.840
stack frames that we have in the program.

00:48:56.840 --> 00:49:00.910
So, if we take a look up at the top here,
we might want to take a look at

00:49:01.040 --> 00:49:03.830
what this address means here.

00:49:03.840 --> 00:49:06.840
And if we notice,
if we look up right next to the address,

00:49:06.840 --> 00:49:09.840
we can see that it told us that it
happily crashed in car_trades.h.

00:49:09.900 --> 00:49:13.750
That doesn't really help us figure out
where it actually crashed in our code.

00:49:13.840 --> 00:49:16.810
That just tells it it crashed
in some inline header file.

00:49:16.840 --> 00:49:20.070
So, if we use the target modules
lookup command that we learned

00:49:20.420 --> 00:49:23.130
about at the beginning,
we can look up the

00:49:23.230 --> 00:49:24.840
address and get a result.

00:49:24.850 --> 00:49:26.840
And note that we got three stacks
of shared libraries loaded.

00:49:26.840 --> 00:49:29.840
So, we can actually get the stack
frames back for one single address.

00:49:29.840 --> 00:49:33.450
We will unwind your inline stack
frames all the way back to where it

00:49:33.450 --> 00:49:35.840
actually crashed inside of your code.

00:49:35.840 --> 00:49:39.840
And here we can see that we actually
crashed in main.cpp on line 11.

00:49:40.770 --> 00:49:42.890
Now, there's an automated way to do this.

00:49:42.890 --> 00:49:46.860
We've got a built-in module in
the Xcode 4.5 seed only that

00:49:47.080 --> 00:49:50.400
is called ldb.macosx.crashlog.

00:49:50.440 --> 00:49:53.200
And it kind of uses a lot of the
things that we talked about today.

00:49:53.200 --> 00:49:56.780
When we import this,
we can see that it installs a new command

00:49:56.940 --> 00:50:00.640
line command using the command script
add command that we learned about before.

00:50:00.640 --> 00:50:05.500
We now have a new command at our
disposal that is called crashlog.

00:50:05.820 --> 00:50:09.230
We can type crashlog and
specify a crashlog itself.

00:50:09.460 --> 00:50:12.650
And it'll actually symbolicate
everything for us by looking

00:50:12.650 --> 00:50:16.160
for all the different things,
disassembling around the crash site

00:50:16.160 --> 00:50:19.080
because we've got access to the
disassembler and we can use these

00:50:19.160 --> 00:50:21.080
objects inside of the debugger API.

00:50:21.080 --> 00:50:23.780
And if we take a look at the
end of the stack trace here,

00:50:23.780 --> 00:50:26.240
we can see that we have
actually reconstructed all

00:50:26.300 --> 00:50:27.860
of our inline stack frames.

00:50:35.400 --> 00:50:38.170
So we've got a lot of great modules,
and you might want to customize

00:50:38.170 --> 00:50:41.320
this for your workflow when you
guys get crash logs from either

00:50:41.320 --> 00:50:43.030
Apple or from another service.

00:50:43.040 --> 00:50:47.390
Inside of the Xcode application,
you find the LLDB.framework.

00:50:47.480 --> 00:50:50.610
Inside the LLDB.framework,
we actually have the

00:50:50.730 --> 00:50:52.560
Python package that is LLDB.

00:50:52.560 --> 00:50:55.800
Inside here,
we've got some great examples for you

00:50:55.800 --> 00:51:00.340
for the exact formatters that we use to
format the standard template library.

00:51:00.340 --> 00:51:04.010
So if you have some templatized classes
and you want to be able to view your

00:51:04.010 --> 00:51:08.480
data types just like you're seeing your
standard template library data types,

00:51:08.600 --> 00:51:11.640
take a look at these examples,
see what you can glean from them,

00:51:11.640 --> 00:51:13.660
and modify them for your own projects.

00:51:13.660 --> 00:51:17.390
Likewise,
all of the Objective-C types have ways to

00:51:17.450 --> 00:51:21.860
view their data inside of them as well,
often without running code.

00:51:21.860 --> 00:51:25.250
Some great examples to look at are
contained inside of multiple different

00:51:25.250 --> 00:51:26.880
files inside of this directory.

00:51:28.600 --> 00:51:31.980
Likewise, we've got the symbolication,
which is generic symbolication.

00:51:31.980 --> 00:51:35.140
We've got the crash log module,
which will actually take

00:51:35.140 --> 00:51:38.680
a crash log on MacOSX,
parse it up into Python objects,

00:51:38.750 --> 00:51:43.140
and actually load your program up at
exactly the right address that it needs

00:51:43.170 --> 00:51:45.420
to and do a lot of different things.

00:51:45.420 --> 00:51:48.720
A great example to take in case
you need to modify it to fit

00:51:48.750 --> 00:51:52.750
how you locate your crashed,
you know, how you desymbolicate your

00:51:52.850 --> 00:51:54.810
crash logs once you get them.

00:51:56.200 --> 00:51:58.750
And we also have a couple of
other examples that put together

00:51:58.750 --> 00:52:00.350
things in a lot more complex ways.

00:52:00.370 --> 00:52:02.750
So, again,
I encourage you to take a look inside

00:52:02.850 --> 00:52:06.930
the LLDB module and look for anything
that ends in .py and see what you can do.

00:52:09.730 --> 00:52:12.420
So that brings us to the end of the talk.

00:52:12.460 --> 00:52:15.780
We think we've got a great product
for you guys in the Xcode 4.5 seed.

00:52:15.780 --> 00:52:18.890
We've got some great customization
that you can do for all your

00:52:19.010 --> 00:52:20.800
types and your formatting.

00:52:20.800 --> 00:52:24.170
We have a great story for
multi-threaded debugging where we

00:52:24.180 --> 00:52:25.880
know what every thread is up to.

00:52:25.880 --> 00:52:27.490
We know why each thread stopped.

00:52:27.770 --> 00:52:31.980
We've got compiler integration that
really should make you rethink what

00:52:32.080 --> 00:52:34.040
you can do with your expressions.

00:52:34.230 --> 00:52:37.800
And LLDB is a framework,
which means that it's available,

00:52:37.800 --> 00:52:41.340
you know, for you to use as an API,
and it's also available through

00:52:41.350 --> 00:52:46.700
the Python scripting interface,
both inside and outside of LLDB.

00:52:47.530 --> 00:52:53.540
So we've got some web URLs here in case
anyone wants to go check out the website.

00:52:53.540 --> 00:52:58.660
Really going to ldb.lvm.org will help
you get a lot more information and go a

00:52:58.660 --> 00:53:02.080
lot more in-depth in a lot of the things
that we weren't able to dive into today.

00:53:02.080 --> 00:53:03.400
Thank you.

00:53:03.400 --> 00:53:04.610
Thank you.
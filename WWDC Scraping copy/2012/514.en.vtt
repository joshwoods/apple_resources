WEBVTT

00:00:10.090 --> 00:00:12.400
Good afternoon, everybody,
and welcome to our session on

00:00:12.400 --> 00:00:14.720
OpenGL ES Tools and Techniques.

00:00:14.810 --> 00:00:17.140
I'll be taking you through
the great new tools we have

00:00:17.740 --> 00:00:20.400
for developing games on iOS.

00:00:20.460 --> 00:00:23.640
Now, as you know, iOS is a great platform
for developing games.

00:00:23.740 --> 00:00:25.970
And with OpenGL ES,
you have great technology

00:00:26.140 --> 00:00:27.640
for pairing these games.

00:00:27.760 --> 00:00:30.740
Today, we're going to be talking about
the OpenGL ES tools we give you to

00:00:30.750 --> 00:00:34.180
streamline that and make sure that you're
spending your time developing games,

00:00:34.180 --> 00:00:36.550
not finding issues in your graphics.

00:00:37.760 --> 00:00:38.780
So what we're going to cover today.

00:00:38.820 --> 00:00:42.700
Obviously, we'll talk about what
OpenGL ES tools are available to you,

00:00:42.750 --> 00:00:46.370
why you need these tools,
and what new features are available to

00:00:46.520 --> 00:00:49.540
you within Xcode 4.5 and the iOS 6.0 SDK.

00:00:49.610 --> 00:00:53.100
Finally, we'll talk a little about some
workflows and methods to help you

00:00:53.130 --> 00:00:54.770
get the most from these tools.

00:00:54.780 --> 00:00:59.480
So first, let's kind of talk about what
tools are there for you within the

00:00:59.480 --> 00:01:02.010
shipping SDKs to catch everybody up.

00:01:03.990 --> 00:01:07.240
So the first tool I want to talk
about is the OpenGL ES Frame Debugger.

00:01:07.370 --> 00:01:10.240
Now, this is a great tool that's
built right into Xcode.

00:01:10.250 --> 00:01:12.200
You just launch your app
as you normally would,

00:01:12.640 --> 00:01:15.880
trigger a frame capture,
and then you can start diving straight

00:01:15.880 --> 00:01:17.970
away into your OpenGL ES code.

00:01:19.530 --> 00:01:21.840
Within the debug navigator,
we show you all the

00:01:21.910 --> 00:01:23.640
GL calls from your frame.

00:01:23.640 --> 00:01:27.590
And you can select any of those
calls to instantly see what the

00:01:27.590 --> 00:01:29.700
state of GL is at that point.

00:01:30.100 --> 00:01:33.490
We also provide a debug label,
a debug marker extension, sorry,

00:01:33.560 --> 00:01:36.030
that helps you annotate
your frame itself.

00:01:36.160 --> 00:01:39.590
So you can group using this API calls
into your different rendering

00:01:39.620 --> 00:01:43.540
passes or different objects you're
drawing or however you choose to.

00:01:43.540 --> 00:01:47.710
It's a really powerful API to let
you choose how you want your frame to

00:01:47.800 --> 00:01:50.280
appear within that debug navigator.

00:01:50.760 --> 00:01:53.510
As well as being able to see
all your calls within there,

00:01:53.510 --> 00:01:55.960
you can disclose any of these
calls and we'll show you what the

00:01:56.110 --> 00:01:57.660
CPU call stack was at that point.

00:01:57.700 --> 00:02:01.380
So you can dive straight back
to your CPU code from your

00:02:01.380 --> 00:02:03.440
GL draw calls or state calls.

00:02:03.520 --> 00:02:06.650
Within the main render buffer view,
editor view,

00:02:06.720 --> 00:02:08.780
we show you your frame buffer.

00:02:08.780 --> 00:02:11.230
So we'll show you what the
state of that frame buffer is

00:02:11.270 --> 00:02:12.540
at whatever call you're at.

00:02:12.660 --> 00:02:14.820
Within this,
we'll show you the color buffer,

00:02:14.890 --> 00:02:17.300
desk buffer, stencil buffer,
whatever buffers you

00:02:17.300 --> 00:02:18.590
happen to have enabled.

00:02:19.720 --> 00:02:22.800
We'll also, by default,
highlight the current

00:02:22.910 --> 00:02:24.280
draw call in wireframe.

00:02:24.280 --> 00:02:26.480
So it makes it really easy to
see what you're drawing when

00:02:26.480 --> 00:02:27.860
as you scrub through the frame.

00:02:27.910 --> 00:02:31.960
In the assistant window,
we show you all of your GL objects.

00:02:31.960 --> 00:02:35.880
So you can investigate the
resources you're using.

00:02:35.920 --> 00:02:38.620
By default, we'll show you what the
boundary sources are,

00:02:38.670 --> 00:02:39.260
i.e.

00:02:39.260 --> 00:02:41.640
what are the textures,
programs that you're drawing

00:02:41.640 --> 00:02:43.050
with at that current draw call.

00:02:43.060 --> 00:02:46.680
But there's also options to
filter to view all of the objects.

00:02:46.780 --> 00:02:48.680
So if you think,
I should be drawing with this texture.

00:02:48.750 --> 00:02:49.740
But it's not bound.

00:02:49.740 --> 00:02:50.740
Well, let's dive in and look.

00:02:50.780 --> 00:02:53.240
I can look through all the textures,
see if I actually loaded it or not.

00:02:53.240 --> 00:02:57.190
So I'm going to go ahead and do that.

00:02:57.570 --> 00:03:01.990
As well, you can double-click on any of
these resources and we'll give you

00:03:01.990 --> 00:03:06.800
a detailed view of that object,
be it a texture, a vertex array object,

00:03:06.870 --> 00:03:09.630
and your GLSL code within your programs.

00:03:09.730 --> 00:03:14.900
We'll also have viewers for buffers
and all the other GL objects.

00:03:15.230 --> 00:03:18.870
Similar to the debug marker
extension I mentioned for

00:03:18.870 --> 00:03:22.570
annotating your frame trace,
we also have a GL label

00:03:22.570 --> 00:03:25.270
object marker extension,
which is great for

00:03:25.270 --> 00:03:26.820
labeling your resources.

00:03:26.920 --> 00:03:29.610
It's easy to tell what text
is which from the thumbnails,

00:03:29.780 --> 00:03:32.940
but obviously with your programs,
your vertex array objects,

00:03:33.020 --> 00:03:37.040
you've just got the GL name,
which is an integer, without using this.

00:03:37.080 --> 00:03:39.750
But with this, you can give a text label
for all your resources,

00:03:39.780 --> 00:03:42.760
and you can instantly see, oh,
this is the mesh for drawing a teapot,

00:03:42.910 --> 00:03:45.020
this is the mesh for drawing a cat,
whatever.

00:03:45.020 --> 00:03:48.410
Within the variables view area,
where you should be familiar

00:03:48.410 --> 00:03:51.790
to seeing your CPU variables,
we'll show you your GL state,

00:03:51.840 --> 00:03:54.330
and we'll show you all
your context state,

00:03:54.380 --> 00:03:57.560
your object state,
and the renderer capabilities as well,

00:03:57.560 --> 00:03:59.540
so things like what
GL extensions are available.

00:03:59.540 --> 00:04:03.900
We even summarize the state,
so we'll group related

00:04:03.900 --> 00:04:06.040
state into a category.

00:04:06.190 --> 00:04:09.910
We'll say, for instance, in this example,
depth, so that if you're quickly

00:04:09.950 --> 00:04:13.580
scanning through all your state,
you don't need to individually pick out,

00:04:13.700 --> 00:04:15.710
oh, state depth this, depth that.

00:04:15.840 --> 00:04:17.010
We'll give you it in a single line.

00:04:17.060 --> 00:04:20.350
And as you step through,
we'll highlight what state has

00:04:20.350 --> 00:04:22.470
changed since the last draw call.

00:04:22.500 --> 00:04:24.950
So as you're stepping through,
you can see how you're building

00:04:24.950 --> 00:04:27.620
your state vector up and quickly
spot where you're setting something

00:04:27.620 --> 00:04:28.930
that you weren't intending.

00:04:28.940 --> 00:04:33.300
The next tool I briefly want to cover
is the OpenGL ES analyzer instrument.

00:04:33.300 --> 00:04:36.160
Now, you should all be well
familiar with instruments.

00:04:36.180 --> 00:04:37.900
For all your profiling needs.

00:04:38.000 --> 00:04:42.670
And the analyzer instrument is another
rich instrument within that toolkit,

00:04:42.670 --> 00:04:46.600
giving you graphical representation
of GL performance data.

00:04:46.600 --> 00:04:49.240
And like all the other instruments,
you can use any combination of

00:04:49.250 --> 00:04:51.720
the instruments to solve the
issue you're trying to look.

00:04:51.900 --> 00:04:55.160
So you can have the analyzer
instrument alongside CPU profiling,

00:04:55.160 --> 00:04:57.230
network access, whatever you choose.

00:04:59.340 --> 00:05:01.790
And as you can see here,
we've got all the normal

00:05:01.800 --> 00:05:06.160
great graphs and visualization
options within the instruments.

00:05:09.240 --> 00:05:10.860
Even more interesting, though,
are some of the detailed

00:05:10.860 --> 00:05:11.640
views that we give you.

00:05:11.700 --> 00:05:15.260
So, for instance, within the
OpenGL ES API Statistics window,

00:05:15.260 --> 00:05:17.740
we'll give you a list of
all the GL calls you make,

00:05:17.750 --> 00:05:21.050
how many times you make them,
and how much time you spent inside them.

00:05:21.120 --> 00:05:24.310
This is great for diagnosing if
you're spending a lot of time in

00:05:24.310 --> 00:05:27.720
state calls or in drawing calls,
as you probably more expect.

00:05:27.780 --> 00:05:32.060
And we'll even tell you how much time
you're spending in each one on average,

00:05:32.060 --> 00:05:36.720
so you can check whether certain calls
are taking an inordinate amount of time.

00:05:36.740 --> 00:05:39.690
In this example, for instance,
you can see that generateMipMap

00:05:39.950 --> 00:05:42.280
does take a long time,
but then you should only be calling that

00:05:42.340 --> 00:05:43.920
during your initialized code anyway.

00:05:43.920 --> 00:05:49.860
An even more interesting view within
this window is the OpenGL ES Expert.

00:05:49.860 --> 00:05:54.380
The OpenGL ES Expert is like having
an expert in your Mac for you,

00:05:54.710 --> 00:05:56.680
diagnosing your GL ES app.

00:05:56.680 --> 00:06:00.800
It runs a rich set of heuristics
to detect a plethora of

00:06:00.800 --> 00:06:03.620
GL errors and GL best practices.

00:06:03.620 --> 00:06:06.930
So it'll tell you if
you're passing... You know,

00:06:06.930 --> 00:06:08.070
illegal enums to GL.

00:06:08.080 --> 00:06:10.180
But it'll also tell you if
you're doing things that might

00:06:10.180 --> 00:06:13.980
not be particularly performant,
be it using an inefficient texture

00:06:13.990 --> 00:06:17.980
format or inefficient vertex formats,
or making successive

00:06:17.980 --> 00:06:20.370
redundant state calls,
things like that.

00:06:20.440 --> 00:06:24.200
It's great for giving you a list
of all the things that you can and

00:06:24.200 --> 00:06:26.320
should fix within your GL code.

00:06:26.340 --> 00:06:26.400
Thank you.

00:06:29.660 --> 00:06:32.860
The last tool I want to recap is
the OpenGL ES Performance Detective.

00:06:32.940 --> 00:06:38.740
The Performance Detective is a standalone
app giving you an easy way to do

00:06:38.740 --> 00:06:42.030
quick profiling of your OpenGL ES app.

00:06:42.120 --> 00:06:43.910
To use it, it's very simple.

00:06:43.910 --> 00:06:48.200
Just select the app you want to launch,
and it will launch it on your device.

00:06:48.220 --> 00:06:51.340
And then you want to wait until
the point where the performance

00:06:51.430 --> 00:06:53.100
on your app is not what you want.

00:06:53.180 --> 00:06:55.760
So you probably want to
get through your menu code,

00:06:55.900 --> 00:06:59.100
through the loading of your scene,
and then dive in.

00:06:59.500 --> 00:07:01.510
And, you know, look at the frame rate,
see when it's not running

00:07:01.510 --> 00:07:03.580
as quickly as you want,
and trigger an investigation.

00:07:05.720 --> 00:07:08.280
At that point,
the performance detective takes

00:07:08.280 --> 00:07:11.240
over and captures a frame of
your app's OpenGL ES and all

00:07:11.240 --> 00:07:14.780
the textures that you're using,
all the state, et cetera.

00:07:14.780 --> 00:07:19.310
We'll then replay that frame back
on the device thousands of times,

00:07:19.370 --> 00:07:23.010
each time reconfiguring the graphics
pipeline in a different way.

00:07:23.020 --> 00:07:27.740
This lets us isolate particular
possible bottlenecks.

00:07:27.900 --> 00:07:31.460
It's very similar to the steps an
experienced OpenGL ES developer might

00:07:31.550 --> 00:07:33.530
do over the course of an afternoon.

00:07:34.220 --> 00:07:36.000
But with the
OpenGL ES performance detective,

00:07:36.000 --> 00:07:37.930
it's done for you in
just a couple of minutes.

00:07:39.740 --> 00:07:42.160
Once done,
it'll come back with a report telling

00:07:42.400 --> 00:07:46.600
you what is the predominant performance
bottlenecks in your OpenGL ES code.

00:07:46.690 --> 00:07:48.480
In this example,
it's telling us that we're

00:07:48.480 --> 00:07:51.470
fragment shading bound,
and it's giving us a set of advice

00:07:51.590 --> 00:07:53.600
as to how we could address that.

00:07:53.630 --> 00:07:56.640
But I suspect the real reason
you're here today is to find out

00:07:56.760 --> 00:08:00.730
what's new for OpenGL ES debugging
in Xcode 4.5 and the iOS 6.0 SDK.

00:08:01.200 --> 00:08:04.900
Well, we've got a great list of features,
and let's skip through the list and

00:08:05.070 --> 00:08:07.500
just start by diving into the first one.

00:08:07.700 --> 00:08:09.060
Shader, Edit, and Continue.

00:08:09.060 --> 00:08:12.180
Now, you might have seen a preview
of this during the graphics

00:08:12.310 --> 00:08:13.940
and games kickoff yesterday.

00:08:13.940 --> 00:08:16.200
It's a really, really great feature.

00:08:16.200 --> 00:08:20.230
Now, when you've done a frame capture
within the OpenGL ES frame debugger,

00:08:20.230 --> 00:08:23.330
you can dive straight in and
start editing your GLSL code.

00:08:24.380 --> 00:08:27.850
Then you just hit the Update button,
and we'll send that GLSL code

00:08:27.850 --> 00:08:30.100
back down to the device,
compile it,

00:08:30.100 --> 00:08:32.620
and find out if there's any errors.

00:08:32.620 --> 00:08:35.540
You'll get the errors reported
in line in your GLSL code,

00:08:35.550 --> 00:08:37.850
just like you would do your
CPU code when you compile that.

00:08:38.190 --> 00:08:40.580
Hopefully, though,
you won't get any errors, and instead,

00:08:40.580 --> 00:08:42.960
you'll see the effects of the
shader straight away within

00:08:42.960 --> 00:08:44.340
the main render buffer view.

00:08:45.760 --> 00:08:47.850
Now, obviously,
as you're often doing a sequence

00:08:47.920 --> 00:08:50.470
of changes as you're trying
to tweak performance or tweak

00:08:50.470 --> 00:08:53.710
the effect you're looking for,
so we save all these changes

00:08:53.830 --> 00:08:57.180
to a shader edit log,
which you can find in the log navigator.

00:08:57.180 --> 00:08:58.840
At that point,
you can always scan back to

00:08:59.050 --> 00:09:01.580
find a version that you'd made
partway through when you think,

00:09:01.580 --> 00:09:04.970
oh, I'd really nailed it, and then, oh,
I didn't like those later changes.

00:09:05.000 --> 00:09:08.470
And when you resume your app,
you will see the shaders

00:09:08.470 --> 00:09:12.100
inserted back into your app,
your live running app.

00:09:12.220 --> 00:09:16.760
So you can tweak, resume, tweak, resume,
instantly iterating to get

00:09:16.770 --> 00:09:20.320
the performance and the
shader quality that you want.

00:09:24.560 --> 00:09:26.950
Our second new feature that
we're talking about today is

00:09:26.950 --> 00:09:28.680
the integrated OpenGL ES Expert.

00:09:28.680 --> 00:09:32.000
Now, as I was mentioning with
the OpenGL ES Analyzer,

00:09:32.050 --> 00:09:36.280
the Expert is a fantastic tool for
finding errors in your GL code.

00:09:36.310 --> 00:09:39.920
Well, now you don't need to step out
and jump into instruments to get

00:09:39.990 --> 00:09:41.900
the benefit of this technology.

00:09:41.900 --> 00:09:45.060
We run it for you every time you
catch a frame in the debugger.

00:09:45.930 --> 00:09:49.030
This is great for helping you
catch bugs early and often.

00:09:49.030 --> 00:09:52.000
Hit frame capture,
wait for the capture to complete,

00:09:52.000 --> 00:09:55.930
and any issues that existed will now
appear in Xcode's issue navigator,

00:09:55.930 --> 00:09:59.590
giving you the familiar method of
navigating any issues and letting

00:09:59.600 --> 00:10:01.560
you jump straight to the code.

00:10:01.600 --> 00:10:04.570
There's no need to call
GL get error all the way,

00:10:04.570 --> 00:10:08.470
dot it through your code,
trying to track errors yourself.

00:10:08.470 --> 00:10:12.170
We call that every single
time we capture a GL command.

00:10:12.180 --> 00:10:15.880
So you get the benefit of
us automatically calling GL.

00:10:15.900 --> 00:10:17.500
We can get error every place.

00:10:17.500 --> 00:10:21.040
And, as I mentioned,
because it's in the issue navigator,

00:10:21.040 --> 00:10:25.030
you simply click on the issue and it'll
take you straight to your CPU code where

00:10:25.030 --> 00:10:27.400
you're calling GL in a way you shouldn't.

00:10:27.420 --> 00:10:30.960
In this case, for instance,
we can see that it's calling GL text

00:10:30.960 --> 00:10:33.110
image with some wrong parameters.

00:10:33.120 --> 00:10:37.180
Great way of finding errors quick,
fixing them, and getting back to what you

00:10:37.230 --> 00:10:38.990
were meaning to be working on.

00:10:43.800 --> 00:10:46.690
Our third new feature is
multi-context debugging.

00:10:46.740 --> 00:10:50.410
Now, we've heard from a lot of you that
you're starting to bring the use of

00:10:50.410 --> 00:10:58.990
multiple GL contexts into your apps,
particularly for having a background

00:10:58.990 --> 00:10:58.990
context for streaming in resources,
predominantly textures.

00:10:59.310 --> 00:11:02.350
Well, we've now brought support for
showing you these context switches

00:11:02.680 --> 00:11:04.330
back into the debug navigator.

00:11:04.330 --> 00:11:07.580
So as you see in this example,
we can see the switches of

00:11:07.680 --> 00:11:12.280
context highlighted in between
the commands they're calling.

00:11:12.340 --> 00:11:15.340
It's a great way of quickly
diagnosing multi-context issues

00:11:15.490 --> 00:11:17.220
and threading issues in your code.

00:11:17.260 --> 00:11:20.010
As well as that,
we've extended Eagle Context,

00:11:20.010 --> 00:11:23.400
adding a new debug label property,
which lets you set a text

00:11:23.420 --> 00:11:26.440
label on your context,
similar to how you can already

00:11:26.440 --> 00:11:28.650
set a text label on your thread.

00:11:29.200 --> 00:11:31.300
And if you do that,
we'll pick up that label and use

00:11:31.300 --> 00:11:32.900
that within the debug navigator.

00:11:32.900 --> 00:11:35.090
So you can quickly say, ah,
that's my render context,

00:11:35.090 --> 00:11:36.880
that's my background text you'll edit.

00:11:42.360 --> 00:11:45.190
The fourth new feature we're talking
about is Save and Load Captured Frames.

00:11:45.200 --> 00:11:47.390
This is another one that a lot
of you have been asking us for.

00:11:47.400 --> 00:11:52.000
Now, when you're in the frame debugger,
if you want to save your capture,

00:11:52.000 --> 00:11:53.270
you can quickly do that.

00:11:53.500 --> 00:11:55.140
Save your frame capture
and pick it up later.

00:11:55.140 --> 00:11:57.510
It means that, you know,
if you're in a rush and you don't have

00:11:57.510 --> 00:12:00.530
time to look at this particular issue,
you've got this other thing to look at,

00:12:00.530 --> 00:12:01.630
you save it for later.

00:12:01.640 --> 00:12:04.550
Or you can save it and load
it back on a different device.

00:12:04.980 --> 00:12:07.520
Now, in that case, obviously,
it needs to be a compatible device.

00:12:07.620 --> 00:12:12.050
If the GL extensions aren't available
on the device you're trying to

00:12:12.180 --> 00:12:15.560
replay that were when captured,
it won't work.

00:12:15.660 --> 00:12:19.530
But we'll tell you about that,
and it'll give you a warning to tell you,

00:12:19.530 --> 00:12:21.140
not this device, sorry.

00:12:21.140 --> 00:12:24.040
But at least you can,
with any compatible device,

00:12:24.040 --> 00:12:26.860
load it and start debugging
where you left off.

00:12:26.980 --> 00:12:29.780
You can also, if you choose,
send the captures to somebody else.

00:12:29.880 --> 00:12:33.450
So if you think you've found a
bug and it's not in your code,

00:12:33.480 --> 00:12:36.520
in the code of the graphic,
like the guy in the office next door,

00:12:36.520 --> 00:12:37.100
you can send it to him.

00:12:37.140 --> 00:12:40.270
Or if you think the artists are
using ridiculously big meshes

00:12:40.270 --> 00:12:43.330
for something that's far away,
and you want to send them a frame

00:12:43.330 --> 00:12:45.570
capture to prove it to them,
you can send that.

00:12:50.070 --> 00:12:52.490
Fifth up is performance monitoring.

00:12:52.590 --> 00:12:56.200
Now, with games,
performance is a first-class bug.

00:12:56.310 --> 00:13:00.520
So we've made it easy for you to always
see how quick your app is running.

00:13:00.730 --> 00:13:02.130
You don't need to do
anything to your app.

00:13:02.310 --> 00:13:04.400
You don't need to do anything
to the settings in Xcode.

00:13:04.400 --> 00:13:07.470
Now you get an FPS tray
if you're using OpenGL ES.

00:13:07.480 --> 00:13:11.700
And we'll even highlight in
red if you're running slow.

00:13:11.720 --> 00:13:15.630
And we pick up the frame rate
you're telling CA DisplayLink that

00:13:15.720 --> 00:13:17.220
you're trying to run.

00:13:17.220 --> 00:13:21.970
So if you're running along nicely at
30 and that's what you're aiming for,

00:13:21.970 --> 00:13:23.520
we're not going to tell you that's bad.

00:13:23.560 --> 00:13:24.980
We're not going to show that in red.

00:13:25.060 --> 00:13:25.700
You'll be good.

00:13:26.740 --> 00:13:28.520
Best of all,
if you click on the performance tray,

00:13:28.520 --> 00:13:32.240
we'll show you in the main editor
window some extra GPU utilization

00:13:32.640 --> 00:13:34.440
and frame timing information.

00:13:34.440 --> 00:13:37.410
So in this case,
we can see the sample I captured

00:13:37.410 --> 00:13:41.050
fully maxing out the GPU almost,
95% utilization,

00:13:41.130 --> 00:13:44.590
reflected as well in the fact
that it's taking 32 milliseconds

00:13:44.650 --> 00:13:46.360
to draw each frame on the GPU.

00:13:46.360 --> 00:13:48.820
But we can also see that
we're only actually using 6

00:13:48.820 --> 00:13:50.640
milliseconds per frame on the CPU.

00:13:50.640 --> 00:13:54.990
So we could add some really cool physics
or whatever we chose to at that point.

00:13:55.530 --> 00:13:58.410
On the flip side,
we also know that there's no point

00:13:58.410 --> 00:14:00.300
tuning our CPU at this point.

00:14:00.410 --> 00:14:02.560
It's not going to get us
any performance improvement.

00:14:02.560 --> 00:14:05.630
We really need to start
working on the GPU performance.

00:14:07.380 --> 00:14:10.830
Which leads us into our next new feature,
the integrated

00:14:11.020 --> 00:14:13.520
OpenGL ES Performance Detective.

00:14:13.610 --> 00:14:17.040
We've taken the standalone
OpenGL ES Performance Detective app and

00:14:17.040 --> 00:14:19.340
instead brought it fully into Xcode.

00:14:19.460 --> 00:14:22.340
So now, when you capture a frame
using the frame debugger,

00:14:22.410 --> 00:14:25.410
you just need to press a button
and we'll do all the performance

00:14:25.410 --> 00:14:29.150
work that was performed formally
within the Performance Detective.

00:14:29.580 --> 00:14:32.220
As well as that,
once you've got the performance

00:14:32.320 --> 00:14:36.370
report from the performance detective,
you're now in the debugger with

00:14:36.380 --> 00:14:39.830
the frame for which it's given
you the performance information,

00:14:39.830 --> 00:14:42.540
and you can start diving in and query it,
looking at, oh, you know,

00:14:42.550 --> 00:14:43.960
it says I'm texture-bound.

00:14:43.960 --> 00:14:48.800
Well, yes, this texture is 2K by 2K,
and I'm sampling it in a weird way.

00:14:48.800 --> 00:14:50.550
That's probably the issue.

00:14:50.590 --> 00:14:53.420
Or, hey,
it says I'm fragment shader-bound.

00:14:53.520 --> 00:14:55.030
Let's look at my shaders.

00:14:55.030 --> 00:14:59.000
You're right there where you want to
be once you've got the information.

00:15:01.740 --> 00:15:03.830
Furthermore,
we have this feature we're calling

00:15:03.830 --> 00:15:05.840
OpenGL ES Performance Analysis 2.0.

00:15:05.890 --> 00:15:09.830
We've radically reworked how
the performance analysis engine

00:15:09.830 --> 00:15:13.160
behind the detective works,
and now we can detect many,

00:15:13.160 --> 00:15:14.590
many more bottlenecks.

00:15:15.420 --> 00:15:18.130
A particular error improvement
is now we can detect

00:15:18.360 --> 00:15:20.370
CPU bottlenecks within OpenGL ES.

00:15:20.370 --> 00:15:24.310
So if you're doing things within
your GL commands that are causing

00:15:24.310 --> 00:15:28.650
the driver to spend a lot of time
processing state or uploading textures,

00:15:28.650 --> 00:15:29.880
we'll detect that.

00:15:29.980 --> 00:15:32.390
And we'll tell you, hey,
your state validation

00:15:32.450 --> 00:15:35.040
time is maxing you out,
or you're spending too much

00:15:35.040 --> 00:15:36.620
time uploading textures.

00:15:36.620 --> 00:15:40.720
This should be particularly valuable
for you guys who might be using some

00:15:40.820 --> 00:15:45.350
of these 2D sprite engine middlewares,
which tend to be quite often heavy.

00:15:45.380 --> 00:15:48.500
They use swapping state a lot.

00:15:48.560 --> 00:15:52.190
If it tells you there that your
state validation time bound,

00:15:52.220 --> 00:15:56.140
maybe it's time to start looking
at whether you can sort by state to

00:15:56.140 --> 00:16:00.920
minimize the amount of state changes
and minimize the number of draw calls.

00:16:00.960 --> 00:16:04.360
We'll also, as I said,
detect more GPU bottlenecks.

00:16:04.500 --> 00:16:08.710
And again, we'll detect your target frame
rate from CA DisplayLink to

00:16:08.710 --> 00:16:12.500
tailor the recommendations
the analysis engine gives you.

00:16:12.560 --> 00:16:15.360
We're not going to tell you, hey,
you're bottlenecked by F.

00:16:15.380 --> 00:16:19.390
if you're in fact running
at your target frame rate.

00:16:19.840 --> 00:16:22.780
And another advantage of bringing
the performance analysis into

00:16:23.490 --> 00:16:28.640
Xcode is we can join it up with the
GL expert that we brought into Xcode.

00:16:28.640 --> 00:16:32.490
So now,
if there's commands in your GL stream

00:16:32.900 --> 00:16:37.970
or issues in your GL command usage
that is relevant to the bottlenecks

00:16:37.970 --> 00:16:41.650
that performance analysis finds,
we can tell you about it.

00:16:41.740 --> 00:16:44.190
So if it tells you you're
fragment shader bound,

00:16:44.190 --> 00:16:47.880
we can say, hey, this shader is using
dependent texture reads.

00:16:48.150 --> 00:16:48.850
You might want to look at that.

00:16:48.890 --> 00:16:51.220
This shader is using
diamond outflow control.

00:16:51.220 --> 00:16:52.510
That might be slowing you down.

00:16:52.560 --> 00:16:55.600
You don't have to hunt for
what your issue is now.

00:16:55.770 --> 00:16:57.310
It all joins together.

00:16:59.890 --> 00:17:03.000
And that leads us on to
our eighth new feature,

00:17:03.080 --> 00:17:04.900
find your slow shaders.

00:17:04.940 --> 00:17:08.790
Now, if you're shader-bound,
we'll run a set of additional experiments

00:17:09.230 --> 00:17:12.900
on each of your fragment shaders to
determine which is your slow shader.

00:17:12.940 --> 00:17:17.890
From there, you can jump straight to the
GLSL code for that shader

00:17:17.950 --> 00:17:20.270
just by clicking on the link.

00:17:20.450 --> 00:17:22.200
And from there,
you've got the Shader Edit and

00:17:22.260 --> 00:17:24.320
Continue feature that you already know.

00:17:24.410 --> 00:17:26.680
So you can start tweaking
your performance,

00:17:26.770 --> 00:17:30.350
changing the shader, and seeing how that
affects your performance,

00:17:30.440 --> 00:17:34.790
how it changes your scene instantly.

00:17:35.070 --> 00:17:39.120
At this point, let's skip from talking
and jump to a demo.

00:17:39.120 --> 00:17:40.940
I'll give you a tour of
some of these new features.

00:17:40.960 --> 00:17:44.430
Okay, so our app's just
launching on our device.

00:17:44.490 --> 00:17:45.980
Let's flip to that.

00:17:46.000 --> 00:17:49.880
As you can see here,
I'm showing the light pre-pass demo

00:17:49.880 --> 00:17:53.520
that you might have seen a little
during the games and graphics demo.

00:17:53.520 --> 00:17:58.450
This is a really cool deferred
lighting app with the great sort

00:17:58.510 --> 00:18:04.140
of rotating fairy lights giving
some really cool lighting effects.

00:18:05.130 --> 00:18:10.200
And if I flip back to Xcode and
flip to the debug navigator,

00:18:10.200 --> 00:18:12.750
you'll see here in the...

00:18:13.320 --> 00:18:15.850
in the Debug Navigator
that we have our FPS.

00:18:15.940 --> 00:18:19.540
In this case, I'm running a nice,
smooth 30 frames a second.

00:18:19.670 --> 00:18:22.200
And if I flip to that,
you can see that at this point,

00:18:22.270 --> 00:18:24.960
I'm maxing out the device,
but at 30 frames a second,

00:18:24.960 --> 00:18:26.700
so it's nicely balanced.

00:18:26.820 --> 00:18:28.540
And also see, yeah,
we're hitting 32 milliseconds

00:18:28.540 --> 00:18:33.290
per frame on the GPU and 6
milliseconds per frame on the CPU.

00:18:33.880 --> 00:18:35.530
So at this point,
if we wanted to dive in more,

00:18:35.530 --> 00:18:37.310
we need to take a frame capture.

00:18:37.490 --> 00:18:40.070
So I'll just quickly flip back.

00:18:40.180 --> 00:18:40.500
to the app.

00:18:40.600 --> 00:18:41.980
And there's a couple of ways
I want to show you about how

00:18:41.980 --> 00:18:43.040
you can trigger frame captures.

00:18:43.040 --> 00:18:46.150
One really great way,
particularly if you're wanting

00:18:46.150 --> 00:18:49.620
to trigger at a particular point,
is to add a breakpoint.

00:18:50.300 --> 00:18:52.570
And then if you...

00:18:53.640 --> 00:18:55.910
Option click and edit breakpoint.

00:18:56.040 --> 00:19:00.000
You can set a debug action
to trigger a frame capture.

00:19:00.000 --> 00:19:01.840
And you can even use some
conditional breakpoint there

00:19:01.840 --> 00:19:04.560
if you want to trigger a very,
very specific point.

00:19:04.560 --> 00:19:07.110
This is great if you're wanting
to transition -- you know,

00:19:07.110 --> 00:19:10.720
get a frame capture at a transition
from one scene to another or when

00:19:10.720 --> 00:19:14.120
you're starting some particle
effect or something like that.

00:19:14.120 --> 00:19:16.620
For this part of the demo,
we'll instead use the most simple

00:19:16.620 --> 00:19:20.600
method of just clicking the frame
capture button here on the debug bar.

00:19:23.110 --> 00:19:25.400
So at this point,
we've paused the application,

00:19:25.410 --> 00:19:29.640
and we're pulling down all the
resources from the device and

00:19:29.710 --> 00:19:34.320
recording all of the calls that we
make during the sequence of the frame.

00:19:34.530 --> 00:19:36.960
And then in just a brief second,
you'll see we pop up

00:19:37.070 --> 00:19:38.640
within the frame debugger.

00:19:38.660 --> 00:19:41.250
Now,
the first thing I want to highlight is if

00:19:41.490 --> 00:19:44.730
we look up here in the activity monitor,
it shows us that there's

00:19:44.730 --> 00:19:47.200
a couple of issues,
a couple of errors, in fact.

00:19:47.280 --> 00:19:49.740
Well,
let's take a look at those straight away.

00:19:49.740 --> 00:19:50.830
Errors are bad.

00:19:50.830 --> 00:19:52.130
Let's look at them.

00:19:52.200 --> 00:19:56.510
So now you see in the navigator,
we've switched to the issue navigator,

00:19:56.510 --> 00:19:58.530
and it's listing two GL errors.

00:19:58.640 --> 00:20:01.770
And if I click on that,
it takes me straight to the code.

00:20:02.800 --> 00:20:05.650
And as I showed before, you know,
GL text image 2D and

00:20:05.650 --> 00:20:07.080
some wrong parameters.

00:20:07.080 --> 00:20:09.760
So at this point,
I could just edit the code straight away,

00:20:09.990 --> 00:20:10.900
hit stop, resume.

00:20:10.900 --> 00:20:14.350
But for now,
we'll just keep going with the tour,

00:20:14.350 --> 00:20:17.760
and I'll leave the bugs
for somebody else to fix.

00:20:19.500 --> 00:20:23.760
If I flip back to the debug navigator,
you'll see I can highlight the new

00:20:23.760 --> 00:20:26.720
context markers within the frame trace.

00:20:26.800 --> 00:20:29.620
They're both the render context,
background, texture loader,

00:20:29.720 --> 00:20:31.030
and then switching back
to the render context.

00:20:31.040 --> 00:20:34.230
And it's also highlighting
what thread I'm calling on.

00:20:34.240 --> 00:20:36.960
So in this case,
you can see I'm failing in respect

00:20:36.960 --> 00:20:40.000
to my background texture loader
by doing it on the same main

00:20:40.000 --> 00:20:41.470
thread as the render context.

00:20:42.120 --> 00:20:46.740
A great way for doing the background
texture loading with minimal

00:20:46.870 --> 00:20:51.380
effort is to use a GLKit API for
asynchronous texture loading.

00:20:52.800 --> 00:20:56.460
Now, if I disclose any of these groups,
you can see that within the groups,

00:20:56.460 --> 00:20:57.770
there's more GL calls.

00:20:57.800 --> 00:21:00.590
This is because I've used
the GL push group marker,

00:21:00.590 --> 00:21:03.360
pop group marker API that
I mentioned earlier.

00:21:03.530 --> 00:21:07.810
It's a great way for giving that
semantic detail to your frame trace.

00:21:08.680 --> 00:21:13.060
And as I mentioned before,
if I disclose any of these calls,

00:21:13.070 --> 00:21:17.850
I can jump back to the CPU code
where I made any of the GL calls.

00:21:17.900 --> 00:21:20.970
This is really great for sort of,
you know, you highlight,

00:21:20.980 --> 00:21:23.200
you find your error
using the GL debugger,

00:21:23.490 --> 00:21:26.120
then you can dive straight back
to where that bug is in your

00:21:26.180 --> 00:21:27.970
code and fix it there and then.

00:21:28.160 --> 00:21:33.170
So down here in the variables view area,
we have, as I mentioned earlier,

00:21:33.460 --> 00:21:34.430
the GL state.

00:21:34.440 --> 00:21:39.230
And we can see at this point that
I'm showing the... that the depth

00:21:39.230 --> 00:21:41.410
has been changed since the last call.

00:21:41.420 --> 00:21:43.610
And if I disclose, I can see that,
for instance,

00:21:43.630 --> 00:21:47.620
the thing that has changed since the
last draw call was the depth write mask.

00:21:47.780 --> 00:21:50.810
This highlighting of what's
changed since the last call is

00:21:50.810 --> 00:21:53.850
really great for figuring out,
oh, this should be just the

00:21:53.850 --> 00:21:56.320
same as the last call,
but this one thing's different.

00:21:56.320 --> 00:21:58.030
That could be what's wrong.

00:21:58.040 --> 00:22:03.040
And we do the same status coloring
within the bound GL objects as well.

00:22:03.040 --> 00:22:05.830
So if you disclose, for instance,
the vertex array object,

00:22:05.870 --> 00:22:08.440
I could go in and see
what's changed about my VL.

00:22:08.460 --> 00:22:10.010
And I can see that I've switched to
a different VAO since the last call.

00:22:10.170 --> 00:22:12.470
But in this case,
it's telling me that the real difference

00:22:12.470 --> 00:22:14.100
is I've switched to a different VAO.

00:22:16.410 --> 00:22:19.300
Now, up here in the main render view,
we show, as I mentioned,

00:22:19.300 --> 00:22:21.510
what the current buffers
are at that point.

00:22:21.560 --> 00:22:25.360
And I can toggle between
hiding and showing wireframe.

00:22:27.780 --> 00:22:31.220
But I need to be at a draw call
where I'm drawing something for

00:22:31.220 --> 00:22:33.340
that to have much of an effect.

00:22:33.400 --> 00:22:37.880
Now, if I zoom in,
you can see that as I zoom in,

00:22:37.950 --> 00:22:41.180
both the color and the depth
buffer zoom in in synchronization.

00:22:41.250 --> 00:22:45.740
And if I pan,
both buffers pan in synchronization.

00:22:45.800 --> 00:22:48.720
This means that if you're inspecting
a part of your color buffer,

00:22:48.810 --> 00:22:50.260
trying to figure out
why is this drawn here,

00:22:50.260 --> 00:22:53.760
why is that not drawn there,
you're looking at the same

00:22:53.760 --> 00:22:56.300
part of each buffer in unison.

00:22:57.700 --> 00:23:02.700
I can also just flip to just
show the color buffer as desired.

00:23:04.350 --> 00:23:07.870
Now, over here in the Assistant area,
as I mentioned, we show you the bound

00:23:07.870 --> 00:23:09.140
GL objects by default.

00:23:09.180 --> 00:23:12.620
But you can also flip to all GL objects,
and you can even choose to say

00:23:12.620 --> 00:23:14.030
filter to show me only the programs.

00:23:14.040 --> 00:23:17.600
And as I mentioned before,
it really makes it a lot easier if

00:23:17.600 --> 00:23:22.780
you use a debug label extension to
label your programs as you wish.

00:23:22.920 --> 00:23:28.310
There's a great first step, for instance,
for labeling your textures or just

00:23:28.310 --> 00:23:30.550
label them with the file name.

00:23:30.600 --> 00:23:32.800
But if you want to get smarter,
you can use whatever sort

00:23:32.800 --> 00:23:34.120
of semantic labels you want.

00:23:34.300 --> 00:23:35.330
Thank you.

00:23:35.810 --> 00:23:38.550
Because we're harnessing the power
of the Assistant view within Xcode,

00:23:38.600 --> 00:23:40.780
you can open as many
Assistant windows as you want

00:23:41.240 --> 00:23:42.860
until you run out of screen space.

00:23:43.000 --> 00:23:46.310
But as I'm sure you're all going to be
picking up the new Retina MacBook Pro,

00:23:46.540 --> 00:23:49.450
you're going to have a lot
of screen space to play with.

00:23:50.330 --> 00:23:53.680
Now, a great additional view
we have within this API,

00:23:53.680 --> 00:23:56.750
within the assistants, is the stack view.

00:23:56.760 --> 00:24:02.130
This lets us view the CPU code at
the current draw call and tracks

00:24:02.130 --> 00:24:04.380
automatically as you step through.

00:24:04.380 --> 00:24:10.400
So if I start stepping through
the frame using the step markers,

00:24:10.400 --> 00:24:13.340
you can see the wireframe
showing me where I am,

00:24:13.340 --> 00:24:17.880
and you can see the CPU code
tracking where I am.

00:24:18.880 --> 00:24:21.670
This is great for knowing what
you're doing at any point.

00:24:21.700 --> 00:24:25.570
Anyway, let's close that for now and get
some more screen space back and

00:24:25.650 --> 00:24:27.380
flip back to the bound GL objects.

00:24:29.020 --> 00:24:33.540
If I double-click on the texture view,
I can see the texture in detail.

00:24:33.540 --> 00:24:38.950
And you can see in this case,
I've got a texture with a lot of mipmaps.

00:24:39.000 --> 00:24:42.900
And I can choose to view a
particular level as I wish.

00:24:43.220 --> 00:24:46.410
And as before,
there's zoom and flip and rotate.

00:24:46.490 --> 00:24:49.920
It's really great for flipping
your texture whichever way you

00:24:50.230 --> 00:24:52.110
want to see how it's coming in.

00:24:53.620 --> 00:24:56.800
You can also directly navigate
between resources using the navbar.

00:24:56.800 --> 00:25:00.480
That's a great way to flip quickly
from one resource to another.

00:25:00.480 --> 00:25:03.740
If I flip, for instance, to the VAO,
you can see that we've got a nice,

00:25:03.740 --> 00:25:06.260
simple VAO, in this case,
drawing the fairies with just

00:25:06.620 --> 00:25:07.940
position and color bound.

00:25:09.860 --> 00:25:14.390
The last editor I want to show you in
this section is the Program Editor,

00:25:14.390 --> 00:25:17.090
where we can jump to
either the Fragment Shader,

00:25:17.470 --> 00:25:20.060
or the Vertex Shader.

00:25:20.080 --> 00:25:23.290
Now let's just resize this to give
us a little bit more room as we're

00:25:23.530 --> 00:25:26.190
using the super big presentation font.

00:25:26.440 --> 00:25:29.990
Here you can see that for
this particular draw call,

00:25:30.130 --> 00:25:34.470
I'm using where I'm
drawing the fairy lights.

00:25:34.900 --> 00:25:39.230
If I flip back to the vertex shader view,
I can start editing the shader code.

00:25:39.260 --> 00:25:42.130
And in this case,
because we're drawing point sprites,

00:25:42.230 --> 00:25:45.730
you can see that here we're setting
the point sprite size in GLSL code.

00:25:45.790 --> 00:25:50.650
So I can simply edit that to
make the point sprites 10 times

00:25:50.760 --> 00:25:53.470
the size and update the program.

00:25:53.500 --> 00:25:57.200
Well, here we can see instantly that
I don't really know what I'm doing.

00:25:57.200 --> 00:25:58.970
I've got an error in my GLSL code.

00:25:59.000 --> 00:26:00.610
Well, it's telling me exactly what it is.

00:26:00.690 --> 00:26:02.620
Divide does not operate on int and float.

00:26:03.470 --> 00:26:07.180
So let's fix that by putting a 0,
a double point 0 on the end to make

00:26:07.180 --> 00:26:09.370
it float by float and update again.

00:26:10.970 --> 00:26:15.260
Now, let's flip the wireframe off.

00:26:15.430 --> 00:26:20.180
We can see our scene is instantly
updated with the change from that shader.

00:26:20.260 --> 00:26:22.290
Now, the point sprites are much bigger.

00:26:22.290 --> 00:26:23.920
And I like that effect.

00:26:24.020 --> 00:26:26.190
It's kind of cool,
but I think we want to make

00:26:26.330 --> 00:26:29.390
it a little smaller because
it's a bit too psychedelic.

00:26:29.710 --> 00:26:32.900
So let's flip it down to half
that size and update again.

00:26:32.930 --> 00:26:34.400
That's much nicer.

00:26:34.490 --> 00:26:39.190
Well, now,
if I switch-- if I resume the app,

00:26:39.330 --> 00:26:43.490
And switch back to the iPad,
you can see that those bigger

00:26:43.490 --> 00:26:46.480
fairies are in our live running app.

00:26:46.530 --> 00:26:49.800
Now I could start navigating
through my app as I chose,

00:26:49.890 --> 00:26:52.300
and the effects of those
shader edits are there for me.

00:26:52.350 --> 00:26:55.340
And you can edit as many
different shaders as you

00:26:55.340 --> 00:26:57.300
want from change to change.

00:26:57.300 --> 00:27:00.680
It's really great because now you
don't need to go through that long,

00:27:00.760 --> 00:27:05.660
make an edit, recompile, redeploy, test.

00:27:05.890 --> 00:27:09.150
Redeply, recompile, redeploy,
test thing for shaders.

00:27:09.240 --> 00:27:10.760
You can tweak them quickly in place.

00:27:10.880 --> 00:27:12.350
Really, really quick option.

00:27:12.360 --> 00:27:14.860
So at this point,
I've exhausted the level of

00:27:14.860 --> 00:27:18.080
my manager coding ability,
and it's time to turn things over

00:27:18.080 --> 00:27:21.100
to a real engineer who's going to
take you through fixing some real

00:27:21.100 --> 00:27:24.320
live issues within a version of
Light Prepass that I've broken for him.

00:27:24.360 --> 00:27:27.670
So at this point, I'd like to welcome on
stage Michael Mayers.

00:27:28.300 --> 00:27:32.290
Now that we have taken a tour
of the features of these tools,

00:27:32.370 --> 00:27:36.130
let's go ahead and put them to
good use and crush us some bugs.

00:27:36.260 --> 00:27:40.940
So I'm going to go ahead and
open up the problem project.

00:27:40.940 --> 00:27:43.700
In this case,
we have a hobbled version of

00:27:43.810 --> 00:27:46.820
Light Prepass like we have seen before.

00:27:48.390 --> 00:27:50.540
And let's go ahead and boot her up.

00:27:50.720 --> 00:27:53.540
I am now going to switch
over to the device.

00:27:53.670 --> 00:27:57.740
So, immediately we can see
we have a few issues.

00:27:57.850 --> 00:28:03.910
We see that the light orbs have a strange
blending artifact and the temple's

00:28:04.040 --> 00:28:07.390
geometry is severely lacking in detail.

00:28:07.510 --> 00:28:11.710
We can also see that the frame
rate is a little bit too low.

00:28:12.020 --> 00:28:16.920
So let's go ahead and switch back to the
debugger and initiate a frame capture.

00:28:17.050 --> 00:28:22.220
So I'm going to go ahead and click
the frame capture button down here.

00:28:22.380 --> 00:28:26.080
So right now the debugger is
retrieving the sequence of

00:28:26.160 --> 00:28:31.900
GL commands and set of resources
that compose the captured frame.

00:28:31.990 --> 00:28:37.150
And once that is complete,
we will be shown the frame buffer that

00:28:37.150 --> 00:28:39.730
is bound at the end of that frame.

00:28:41.300 --> 00:28:42.500
So here we see that.

00:28:42.540 --> 00:28:45.400
Let's go ahead and set that to auto.

00:28:45.440 --> 00:28:49.700
We see that we have a depth buffer
bound and it looks just fine and

00:28:49.700 --> 00:28:53.370
the color buffer looks as messed
up as it does on the device.

00:28:53.500 --> 00:28:56.760
So now the question is, what next?

00:28:56.760 --> 00:29:01.000
Well, when in doubt,
head over to the issue navigator,

00:29:01.010 --> 00:29:05.170
which is over here,
and we see a laundry list of issues to

00:29:05.170 --> 00:29:08.110
fix and two of them stand out in red.

00:29:08.130 --> 00:29:10.250
So let's go ahead and fix one of those.

00:29:12.580 --> 00:29:13.240
All right.

00:29:13.410 --> 00:29:19.740
It is telling us that we are passing
an invalid enumeration into glEnable.

00:29:19.840 --> 00:29:23.340
And those of you that have been
around the block with gl before know

00:29:23.340 --> 00:29:26.710
that this should instead be glBlend.

00:29:26.810 --> 00:29:29.130
So let's go ahead and fix that.

00:29:29.880 --> 00:29:32.590
And move on to the next issue.

00:29:32.630 --> 00:29:38.450
So next we will tackle the
temple geometry's missing detail.

00:29:38.530 --> 00:29:43.940
And to do that, I'm going to go back
to the debug navigator.

00:29:45.800 --> 00:29:50.860
I'm also going to bring
up the Assistant view.

00:29:51.000 --> 00:29:56.060
And now we will scrub to the draw call
where the temple's geometry is produced.

00:29:56.180 --> 00:30:00.440
And I'm going to employ a binary
search method when I'm scrubbing.

00:30:00.580 --> 00:30:04.040
So I'm going to go ahead and
scrub to the halfway mark.

00:30:04.150 --> 00:30:07.010
And now the quarter mark.

00:30:07.810 --> 00:30:09.860
Now the eighth mark.

00:30:09.970 --> 00:30:11.640
So we're pretty close.

00:30:11.690 --> 00:30:16.420
Now I'm going to step--there we go.

00:30:16.590 --> 00:30:19.410
So let's go ahead and kill the wireframe.

00:30:20.930 --> 00:30:24.800
And reveal the draw call
in the debug navigator.

00:30:24.800 --> 00:30:28.790
And I'm also going to hide
the depth and stencil.

00:30:29.980 --> 00:30:36.880
So I see that the engineer that
programmed LightPrePass used

00:30:37.010 --> 00:30:42.530
the group marker APIs,
and that is allowing me to

00:30:42.530 --> 00:30:47.000
see that the current draw call
is within the Gbuffer pass.

00:30:47.010 --> 00:30:50.140
And this means we should be
laying down some normals.

00:30:50.140 --> 00:30:53.840
And what I see here does
not look like normals to me.

00:30:53.840 --> 00:30:56.700
It looks more like a
colorized depth image.

00:30:56.770 --> 00:31:00.170
So I want to go to the
Assistant Editor and bring up

00:31:00.170 --> 00:31:02.280
the Currently Bound Resources.

00:31:05.150 --> 00:31:10.910
So I see that we have a normal map bound,
which seems relevant to this normal pass.

00:31:11.080 --> 00:31:15.110
So let's go ahead and open that
up and make sure it's okay.

00:31:15.820 --> 00:31:20.600
So I see that there is plenty of
detail present in these normal maps

00:31:20.600 --> 00:31:23.710
and all the MIT maps are present,
but I don't see any of these details

00:31:23.710 --> 00:31:24.990
present in the render buffer.

00:31:25.200 --> 00:31:31.980
So staying late in the pipeline,
I'm going to switch over to the fragment

00:31:31.980 --> 00:31:35.600
shader and give myself some more room.

00:31:37.040 --> 00:31:42.700
Okay, so nothing immediately stands out,
so I'm going to go old school and use

00:31:42.700 --> 00:31:45.100
some printf style shader debugging.

00:31:45.100 --> 00:31:48.700
And I do this by overwriting
gl_frag_color with a

00:31:48.700 --> 00:31:50.400
variable of interest.

00:31:50.430 --> 00:31:55.000
And right now I'm interested in v_normal,
so let's go ahead and do that.

00:31:55.000 --> 00:31:59.100
And extend it to four dimensions.

00:31:59.130 --> 00:32:02.210
And I will now update the shader.

00:32:04.520 --> 00:32:08.330
So we see in the render buffer view
that it has updated itself to reflect

00:32:08.330 --> 00:32:10.700
the changes we made in the shader.

00:32:10.830 --> 00:32:15.000
But what I see is just an unbiased
version of what we had before.

00:32:15.140 --> 00:32:19.820
So I'm going to move on to the
next variable and update once more.

00:32:20.350 --> 00:32:22.040
And there is no change.

00:32:22.220 --> 00:32:25.100
And this is highly suspicious.

00:32:25.460 --> 00:32:29.570
So I'm going to go ahead and set
the shader back to what it was.

00:32:30.700 --> 00:32:33.640
and collect some more evidence.

00:32:33.750 --> 00:32:37.300
We are going to go to the
VAO view and check out the vertex

00:32:37.300 --> 00:32:39.870
stream feeding the vertex shader.

00:32:41.400 --> 00:32:49.040
So I see that we have one, two, three,
four, five vertex attributes,

00:32:49.120 --> 00:32:50.940
each having three components.

00:32:50.940 --> 00:32:54.850
And if we look a little bit closer,
we see that we have

00:32:54.960 --> 00:32:56.840
the same data in each.

00:32:56.840 --> 00:33:01.710
I see 9-0-5, 9-0-5, 9-0-5.

00:33:01.920 --> 00:33:04.400
Well, this is definitely wrong.

00:33:04.420 --> 00:33:08.280
And to investigate further,
I want to go down to the Variable

00:33:08.280 --> 00:33:11.490
View and open up the same VAO.

00:33:11.800 --> 00:33:16.680
I see that we have an element
buffer bound and five vertex atribs,

00:33:16.750 --> 00:33:18.140
as expected.

00:33:18.220 --> 00:33:21.490
Let's go ahead and open up
two of these vertex atribs.

00:33:22.550 --> 00:33:29.590
So I see that both these ATRIBs have
the same exact setup and this suggests

00:33:29.590 --> 00:33:35.240
that they're sourcing the same data,
which is what we can see elsewhere.

00:33:35.300 --> 00:33:40.160
I can also note that since the stride
is 60 and the buffer binding is 1,

00:33:40.370 --> 00:33:43.870
we are using a VBO,
that these are intended to

00:33:43.870 --> 00:33:46.200
be interleaved vertices.

00:33:46.750 --> 00:33:51.500
So I now have enough information
to see what is wrong.

00:33:51.560 --> 00:33:53.910
It is the vertex-attrib setup.

00:33:54.020 --> 00:33:57.860
So I'm going to go ahead and search
the code for all vertex-attrib setup.

00:33:57.940 --> 00:34:04.900
So I'm going to go to the search
navigator and type in gl vertex-attrib.

00:34:07.580 --> 00:34:11.310
We have several hits,
but the one at the top stands

00:34:11.360 --> 00:34:14.000
out in particular because it
has the name Temple in it.

00:34:14.070 --> 00:34:19.590
So let's go ahead and select that
and give myself some more room.

00:34:22.280 --> 00:34:27.740
Okay, so at first glance,
this GL vertex-attrib

00:34:27.910 --> 00:34:29.990
pointer call looks just fine.

00:34:29.990 --> 00:34:32.630
I'm going to go ahead
and scan around a bit.

00:34:34.470 --> 00:34:36.890
Okay, I have found a problem.

00:34:37.290 --> 00:34:43.440
I see that we are setting the vertex
stride twice but not the vertex offset,

00:34:43.440 --> 00:34:47.300
and this is because of
a copy and paste bug.

00:34:47.360 --> 00:34:50.400
Well, I'm going to go ahead and
fix this copy and paste bug

00:34:50.470 --> 00:34:52.190
with another copy and paste.

00:34:52.820 --> 00:34:56.350
And now that we have fixed two issues,
I think it's time to rerun the

00:34:56.350 --> 00:34:58.290
application and see where we stand.

00:34:58.350 --> 00:35:00.900
I'm going to go ahead and
switch over to the device.

00:35:01.120 --> 00:35:06.740
So, we have cleansed the artifacts,
but the frame rate is

00:35:06.740 --> 00:35:09.010
still running a bit slow.

00:35:09.290 --> 00:35:15.360
So let's go ahead and switch back to the
debugger and start another frame capture.

00:35:15.430 --> 00:35:19.690
So again, the debugger is retrieving the
sequence of commands and set of

00:35:19.690 --> 00:35:21.860
resources that make up the frame.

00:35:21.900 --> 00:35:28.680
And that last bug was a little bit tough,
so this time I think we're going

00:35:28.680 --> 00:35:31.980
to go to the issue navigator.

00:35:34.050 --> 00:35:37.140
and pick off something that stands out.

00:35:37.230 --> 00:35:40.650
So I am liking the logical buffer load.

00:35:40.770 --> 00:35:43.340
I'm going to go ahead and click on that.

00:35:45.550 --> 00:35:51.060
And it is telling us that we are not
clearing a portion of the frame buffer.

00:35:51.330 --> 00:35:56.480
And this means that we are incurring some
additional memory traffic because the

00:35:56.480 --> 00:36:01.400
hardware's tile renderer needs to reload
the previous contents of a given tile.

00:36:01.620 --> 00:36:05.680
If you instead clear that,
it can initialize it

00:36:05.680 --> 00:36:07.900
with a constant value.

00:36:07.940 --> 00:36:11.960
This is happening, of course,
because of another copy and paste bug.

00:36:11.980 --> 00:36:15.820
We are clearing color depth and depth,
not color depth and stencil.

00:36:16.030 --> 00:36:18.260
So let's go ahead and fix that.

00:36:18.280 --> 00:36:21.690
And we will rerun the
application once more.

00:36:21.980 --> 00:36:23.920
Let's switch over to the device.

00:36:23.970 --> 00:36:28.460
Okay, we did not quite get back the frame
rate I was hoping for with that.

00:36:28.510 --> 00:36:35.070
So let's go ahead and switch back to
the debugger and break out the big gun.

00:36:36.220 --> 00:36:40.870
So I am going to go over
to the debug navigator.

00:36:40.870 --> 00:36:45.100
And we see that with the application
running live that the debug navigator

00:36:45.180 --> 00:36:47.730
will have this performance tray,
which is currently

00:36:47.730 --> 00:36:49.230
showing us the frame rate.

00:36:49.500 --> 00:36:53.260
And if I click on that,
we can see a course breakdown of where

00:36:53.420 --> 00:36:56.200
the application is spending its time.

00:36:56.200 --> 00:37:00.780
And down here, we will see the big gun,
the Analyze Performance button.

00:37:00.780 --> 00:37:03.020
So let's go ahead and click on that.

00:37:03.760 --> 00:37:07.080
So like the debugger,
the performance analyzer

00:37:07.080 --> 00:37:10.000
needs to retrieve the frame.

00:37:10.000 --> 00:37:14.820
But once that is complete,
it will run an extensive battery

00:37:14.820 --> 00:37:20.090
of experiments on that frame
repeatedly so that you don't have to.

00:37:20.100 --> 00:37:25.050
And with each iteration,
it will modify the experiment slightly

00:37:25.050 --> 00:37:27.580
to collect another data point.

00:37:27.600 --> 00:37:30.860
Once all those data points
have been collected,

00:37:30.860 --> 00:37:33.600
it will run them through
a series of hereafters.

00:37:33.760 --> 00:37:38.560
modeled after an experienced
graphics developer.

00:37:38.850 --> 00:37:42.940
And that in turn will produce
a list of issues that are

00:37:42.940 --> 00:37:45.090
affecting your performance.

00:37:45.250 --> 00:37:48.900
So let's go ahead and give
the analyzer a second.

00:37:49.040 --> 00:37:51.600
Okay, so we have some results now.

00:37:51.720 --> 00:37:54.810
It is telling us that the
performance is limited by the cost

00:37:54.810 --> 00:37:57.200
of fragment shader processing.

00:37:57.380 --> 00:38:03.230
And this could mean that we have too
many fragments to shade or that the cost

00:38:03.230 --> 00:38:06.150
of each fragment is simply too great.

00:38:07.360 --> 00:38:09.740
Give it one more second.

00:38:09.740 --> 00:38:10.850
Okay.

00:38:11.410 --> 00:38:16.710
The analysis is complete and it's telling
us that we are bound by the fragment

00:38:17.120 --> 00:38:20.540
shader bound to program number three.

00:38:20.570 --> 00:38:26.050
And if I click on that,
we will be taken to the offending shader.

00:38:27.180 --> 00:38:33.200
And I see here that we are using a
software shadow filtering fallback path,

00:38:33.200 --> 00:38:35.950
and we should really be using
hardware since we know that

00:38:35.950 --> 00:38:37.720
this device supports it.

00:38:37.790 --> 00:38:41.470
Now I'd like to make a note that
ideally this is something that should

00:38:41.470 --> 00:38:46.030
be done at startup dynamically based
on some device selection method.

00:38:46.040 --> 00:38:50.960
And if you need help with that,
head on down to the OpenGL ES lab

00:38:50.960 --> 00:38:53.660
and an Apple engineer will
be happy to show you how.

00:38:53.660 --> 00:38:56.660
For now,
let's go ahead and update this program.

00:38:56.660 --> 00:39:01.100
And the performance analyzer
is telling me that the analysis

00:39:01.100 --> 00:39:04.860
it just ran is now invalidated
since we've modified the shader.

00:39:04.860 --> 00:39:10.690
And that to get new analysis,
we should rerun the analyzer.

00:39:10.920 --> 00:39:12.750
But we're not going to do that right now.

00:39:12.860 --> 00:39:16.860
We're just going to go ahead and
continue to see where we stand.

00:39:16.860 --> 00:39:17.860
Okay.

00:39:17.860 --> 00:39:19.860
And we are at 30 frames per second.

00:39:19.860 --> 00:39:21.730
The artifacts have been cleansed.

00:39:21.980 --> 00:39:24.710
And with that, my job is complete.

00:39:24.860 --> 00:39:28.960
So I'm going to go ahead and
hand the torch back to Seth.

00:39:29.760 --> 00:39:32.650
So finally,
just a few workflow recommendations to

00:39:32.650 --> 00:39:35.340
help you get the best out of these tools.

00:39:35.430 --> 00:39:39.290
Firstly,
always have a spare USB cable handy.

00:39:40.790 --> 00:39:44.220
Secondly, the issue navigator,
as we showed you,

00:39:44.310 --> 00:39:46.810
will find all the GL issues for you.

00:39:46.860 --> 00:39:49.640
A plethora of issues,
both errors and warnings.

00:39:49.720 --> 00:39:52.230
Fix them early,
just like you would do compiler

00:39:52.230 --> 00:39:54.060
errors and compiler warnings.

00:39:54.060 --> 00:39:56.350
And remember as well,
any GL errors can leave

00:39:56.350 --> 00:39:57.730
GL in an undefined state.

00:39:57.730 --> 00:40:00.460
So you might think that
you've got great performance,

00:40:00.660 --> 00:40:03.350
but then when you go and fix
the one GL error that's causing

00:40:03.530 --> 00:40:05.940
some rendering artifacts,
you might suddenly be

00:40:06.150 --> 00:40:07.630
running at half the speed.

00:40:08.480 --> 00:40:11.610
So, you know,
it pays to fix your GL issues early.

00:40:11.620 --> 00:40:15.000
Remember to annotate your frame
with the push group marker,

00:40:15.070 --> 00:40:16.520
pop group marker calls.

00:40:16.670 --> 00:40:21.100
It makes it a lot easier to navigate
your frame within the debug navigator.

00:40:21.100 --> 00:40:23.380
Really, you know,
the investment you put in,

00:40:23.380 --> 00:40:25.760
just putting a few simple
annotations in there,

00:40:25.760 --> 00:40:28.100
probably putting whatever
your mesh names are,

00:40:28.170 --> 00:40:30.370
which you probably have
from your scene graph,

00:40:30.470 --> 00:40:33.920
into the debug navigator makes
it so much easier to traverse.

00:40:33.920 --> 00:40:38.380
And similarly, label your resources
with GL label objects.

00:40:38.420 --> 00:40:40.790
Shader edit and continue,
as we talked about earlier,

00:40:40.790 --> 00:40:43.130
is great for letting you
tweak your shaders in place.

00:40:43.220 --> 00:40:46.860
So it's really great for making those
performance versus quality tradeoffs.

00:40:46.980 --> 00:40:50.360
Once you've got the effect
you want looking well,

00:40:50.360 --> 00:40:54.540
you can use it to quickly tweak
precision level or how many taps

00:40:54.540 --> 00:40:59.240
you're taking if you're using
some funky filtering or whatever.

00:40:59.240 --> 00:41:01.850
So, yeah, really useful for letting
you do that in place without

00:41:01.850 --> 00:41:03.320
having to continually rerun.

00:41:03.320 --> 00:41:05.770
And finally,
use the integrated performance

00:41:05.770 --> 00:41:07.810
analysis to find your bottlenecks.

00:41:07.820 --> 00:41:08.370
You know, do that.

00:41:08.470 --> 00:41:10.440
Don't just assume you
know why you're slow.

00:41:10.440 --> 00:41:14.540
There's this great tool built right in
Xcode now that will tell you what your

00:41:14.540 --> 00:41:16.940
GPU or GL performance bottlenecks are.

00:41:16.940 --> 00:41:19.220
And remember to think
about performance early.

00:41:19.240 --> 00:41:22.800
Now, you know, premature optimization
is the root of all evil.

00:41:22.800 --> 00:41:24.960
But on the flip side,
if you're trying to tune

00:41:24.960 --> 00:41:27.950
gameplay in a game and it's
running at 10 frames a second,

00:41:27.960 --> 00:41:30.910
it's really hard to get the
gameplay balance you want.

00:41:30.980 --> 00:41:32.920
So, you know,
tune your performance early.

00:41:34.790 --> 00:41:40.260
For more information on the tools,
ping the technology evangelists.

00:41:40.560 --> 00:41:43.480
Both Alan Schafer and
Mike Djuravich can help you.

00:41:43.630 --> 00:41:45.380
And remember,
the developer forums are a great

00:41:45.780 --> 00:41:47.100
source of information as well.

00:41:47.100 --> 00:41:52.130
So, in summary, great OpenGL ES developer
tools that just got a lot,

00:41:52.220 --> 00:41:54.740
lot better in Xcode 4.5.

00:41:54.790 --> 00:41:57.500
So please harness them
to make great games.

00:41:57.500 --> 00:41:58.390
Thank you.
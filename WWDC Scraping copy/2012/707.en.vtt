WEBVTT

00:00:10.580 --> 00:00:11.660
Good afternoon, ladies and gentlemen.

00:00:11.660 --> 00:00:15.060
Thanks for coming to our
afternoon Bonjour session.

00:00:15.060 --> 00:00:17.680
My name is Stuart Cheshire,
and I'm going to be telling

00:00:17.680 --> 00:00:19.430
you a little bit about Bonjour.

00:00:23.630 --> 00:00:25.940
First, we're going to talk
about user experience,

00:00:25.940 --> 00:00:27.770
which is what Bonjour is all about.

00:00:27.850 --> 00:00:30.620
Fundamentally,
that's why we built this technology,

00:00:30.620 --> 00:00:32.220
is to give a good user experience.

00:00:32.220 --> 00:00:35.570
I'm going to talk a little bit about
the background and the products

00:00:35.710 --> 00:00:37.440
and platforms that use Bonjour.

00:00:37.460 --> 00:00:42.480
I'm going to give you an overview of
the technology that makes it work.

00:00:42.480 --> 00:00:46.160
And then I'm going to give you a
description of the operations that

00:00:46.160 --> 00:00:50.260
you use in your applications to
interact with the Bonjour services.

00:00:50.960 --> 00:00:54.920
We have a demo for you,
and then my colleague, Rory McGuire,

00:00:54.920 --> 00:00:58.080
is going to go into some more
in-depth information about

00:00:58.080 --> 00:01:00.120
specific programming details.

00:01:02.360 --> 00:01:09.230
It's 2012 and we still see applications
that look like this on the App Store,

00:01:09.540 --> 00:01:13.770
where the user has to type in
IP addresses and port numbers and half

00:01:13.930 --> 00:01:16.190
the time they don't know what to type in.

00:01:16.200 --> 00:01:20.840
And I know you guys are in the room
because you know better than this,

00:01:20.840 --> 00:01:22.400
we don't want this.

00:01:22.400 --> 00:01:25.790
We want good user experience
for our customers and for yours.

00:01:25.820 --> 00:01:29.160
Here's an example of
something very simple.

00:01:30.050 --> 00:01:31.580
I want to print an email.

00:01:31.580 --> 00:01:34.380
I tap on the arrow, I tap on print.

00:01:34.380 --> 00:01:36.340
There's the name of the printer.

00:01:36.430 --> 00:01:41.460
No IP addresses, no port numbers,
very easy.

00:01:41.740 --> 00:01:46.140
And of course,
it's not just for iOS devices.

00:01:46.200 --> 00:01:50.840
This is a network camera made by Axis,
one of my favorite network cameras.

00:01:50.840 --> 00:01:54.520
It's got a really good quality lens,
good sensor, good low-light capability.

00:01:54.580 --> 00:01:57.480
And of course, it has Bonjour.

00:01:57.480 --> 00:02:01.470
So you plug the Ethernet cable in.

00:02:01.750 --> 00:02:03.240
I don't know what IP address it has.

00:02:03.240 --> 00:02:04.210
I don't care.

00:02:04.210 --> 00:02:06.280
I look in Safari.

00:02:06.510 --> 00:02:08.040
I look in the Bonjour collection.

00:02:08.040 --> 00:02:11.940
And right there,
I see Access Network Camera.

00:02:11.940 --> 00:02:13.430
I double-click it, and I'm connected.

00:02:13.430 --> 00:02:16.040
I never need to see an IP address.

00:02:16.040 --> 00:02:18.720
I never need to see a port number.

00:02:23.380 --> 00:02:26.270
So, I want to give you a little
bit of a history of how we

00:02:26.270 --> 00:02:28.700
got to here with Bonjour.

00:02:28.700 --> 00:02:34.310
A little over 10 years ago,
we launched Bonjour on Mac OS 10.2,

00:02:34.370 --> 00:02:38.080
and within months,
the printer and scanner vendors

00:02:38.140 --> 00:02:41.930
were on board because they'd
been making AppleTalk printers,

00:02:41.930 --> 00:02:46.240
and they understood the importance of
ease of use their customers demanded it.

00:02:46.920 --> 00:02:52.670
Other Apple products,
like Apple TV and airport base stations,

00:02:52.670 --> 00:02:56.030
use Bonjour for configuration,
for backups,

00:02:56.140 --> 00:02:58.580
for communicating with iTunes.

00:03:02.760 --> 00:03:09.900
Other third-party devices like network
cameras and TiVo DVRs use Bonjour.

00:03:09.900 --> 00:03:13.440
If you guys haven't seen it,
you should check out the TiVo

00:03:13.460 --> 00:03:15.680
remote control app for the iPad.

00:03:15.680 --> 00:03:19.960
It's a wonderful example
of a good user experience.

00:03:36.930 --> 00:03:36.930
Other third-party devices like network
cameras and TiVo DVRs use Bonjour.

00:03:36.930 --> 00:03:36.930
If you guys haven't seen it,
you should check out the TiVo

00:03:36.930 --> 00:03:36.930
remote control app for the iPad.

00:03:36.930 --> 00:03:36.930
It's a wonderful example
of a good user experience.

00:03:37.290 --> 00:03:40.480
The TiVo guys were really creative
and came up with a wonderful

00:03:40.480 --> 00:03:42.600
UI that makes use of that screen.

00:03:42.600 --> 00:03:45.700
But of course, if the user didn't know
what IP address to type in,

00:03:45.700 --> 00:03:49.030
they would fall at the first hurdle,
and they would never get to

00:03:49.030 --> 00:03:52.190
see all this wonderful work
that the TiVo engineers did.

00:03:52.250 --> 00:03:55.580
So Bonjour enables users to
connect seamlessly without

00:03:55.580 --> 00:03:57.560
worrying about IP addresses.

00:03:58.650 --> 00:04:01.970
Of course, when iOS devices shipped
with the first iPhone,

00:04:02.020 --> 00:04:04.260
they had Bonjour from the start.

00:04:04.330 --> 00:04:07.480
And this is not just
about Apple products.

00:04:07.480 --> 00:04:11.620
If you are producing
applications for other platforms,

00:04:11.750 --> 00:04:14.620
then Bonjour is available there too.

00:04:15.380 --> 00:04:18.420
And I mention that because some
of you guys in the room are

00:04:18.420 --> 00:04:20.370
producing applications for iOS.

00:04:20.370 --> 00:04:24.220
Some of you guys are producing
hardware devices and accessories.

00:04:24.940 --> 00:04:29.320
And a question that we get is, Well,
I'm making my accessory,

00:04:29.320 --> 00:04:34.110
and on Apple devices,
I use Bonjour to discover it.

00:04:34.110 --> 00:04:37.360
On other platforms,
do I need to use something different?

00:04:37.360 --> 00:04:38.700
And the answer is no.

00:04:38.700 --> 00:04:41.390
We have Bonjour for you on
those platforms as well.

00:04:43.740 --> 00:04:46.920
We have Safari on Windows with
the same Bonjour collection that

00:04:46.920 --> 00:04:48.340
we have on Safari on the Mac.

00:04:48.440 --> 00:04:52.760
And if you're shipping some
other Windows application,

00:04:52.760 --> 00:04:57.460
you can license the Bonjour for
Windows installer for free.

00:05:00.070 --> 00:05:02.990
To bundle with your installer
for your application.

00:05:03.180 --> 00:05:05.720
This is also available
through the MFI program if

00:05:05.760 --> 00:05:07.690
you're participating in that.

00:05:09.690 --> 00:05:15.380
So I've talked about the things
that Bonjour does for you to

00:05:15.380 --> 00:05:16.800
give a good user experience.

00:05:16.800 --> 00:05:19.710
And now I want to tell you a
little bit about how it does that.

00:05:19.720 --> 00:05:22.520
And there are three very
simple technologies here.

00:05:22.520 --> 00:05:25.420
The first one is addressing.

00:05:25.420 --> 00:05:27.280
Now, we love DHCP.

00:05:27.280 --> 00:05:28.480
DHCP is great.

00:05:28.540 --> 00:05:32.150
You plug your laptop into the
Ethernet or you join a Wi-Fi network

00:05:32.150 --> 00:05:33.900
and you get a DHCP address.

00:05:33.920 --> 00:05:36.450
And we're not competing with that.

00:05:36.520 --> 00:05:40.900
But in the case where there isn't
a DHCP server or it isn't working,

00:05:40.900 --> 00:05:43.540
we don't want all the
devices to just fail.

00:05:43.540 --> 00:05:45.070
So we have a safety net.

00:05:45.080 --> 00:05:47.830
And in the case where
DHCP is not available,

00:05:47.830 --> 00:05:52.300
then the device makes up its own address,
selected randomly,

00:05:52.300 --> 00:05:55.700
in a range that's reserved
by IANA for that purpose,

00:05:55.710 --> 00:05:57.780
and it sends an ARP request.

00:05:57.800 --> 00:06:01.840
And if nobody replies,
then the device concludes, hey,

00:06:01.850 --> 00:06:03.220
this address is not in use.

00:06:03.220 --> 00:06:04.000
I can have it.

00:06:04.040 --> 00:06:08.380
And by that mechanism,
all the devices on the network

00:06:08.380 --> 00:06:10.560
can pick unique addresses.

00:06:10.600 --> 00:06:16.380
And this is great because now
we've got past the first hurdle.

00:06:16.460 --> 00:06:19.200
We have a bunch of devices that
have different IP addresses.

00:06:19.260 --> 00:06:21.330
But it's not a complete solution.

00:06:21.360 --> 00:06:25.330
If you don't know what the address is,
then how are you going to use it?

00:06:25.400 --> 00:06:29.780
So the second step is naming.

00:06:30.130 --> 00:06:33.660
The conventional way of naming
devices on the internet with

00:06:33.790 --> 00:06:36.430
internet software is DNS host names.

00:06:36.430 --> 00:06:40.950
And just like with DHCP, DNS is great.

00:06:41.010 --> 00:06:43.480
And if you run your
own DNS server at home,

00:06:43.480 --> 00:06:46.240
and you know how to
maintain and configure it,

00:06:46.240 --> 00:06:49.410
and you can add your own host
names to your own domain,

00:06:49.410 --> 00:06:52.170
then that's a great way of doing naming.

00:06:52.370 --> 00:06:54.960
But for many of our customers,
they don't run their

00:06:54.960 --> 00:06:57.470
own DNS server at home,
and we still want them to be

00:06:57.500 --> 00:06:59.440
able to refer to devices by name.

00:06:59.440 --> 00:07:03.400
So that's where multicast DNS comes in.

00:07:03.910 --> 00:07:08.080
Same name syntax, same record types,
same packet format,

00:07:08.180 --> 00:07:09.520
a standard unicast DNS.

00:07:09.520 --> 00:07:12.980
But instead of sending it to
a specific configured server,

00:07:12.980 --> 00:07:15.530
it's multicast to every
device on the network.

00:07:15.570 --> 00:07:18.690
And each device is running a
little piece of code called

00:07:18.690 --> 00:07:20.640
the multicast DNS responder.

00:07:20.640 --> 00:07:24.350
And when it sees a query for its name,
it kind of metaphorically

00:07:24.350 --> 00:07:27.060
raises its hand and says,
yes, that's me.

00:07:27.060 --> 00:07:29.980
And it sends back a standard
DNS format response,

00:07:30.040 --> 00:07:32.130
giving its name and its address.

00:07:37.230 --> 00:07:43.190
Same name syntax, same record types,
same packet format,

00:07:43.190 --> 00:07:45.640
a standard unicast DNS.

00:07:45.690 --> 00:07:51.590
But instead of sending it to
a specific configured server,

00:07:51.590 --> 00:07:54.100
it's multicast DNS.

00:07:54.100 --> 00:07:54.100
But instead of sending it to
a specific configured server,

00:07:54.100 --> 00:07:54.100
it's multicast DNS.

00:07:54.550 --> 00:07:58.270
DNS Service Discovery lets
a piece of software say,

00:07:58.270 --> 00:08:01.930
I want to perform this
particular task on the network,

00:08:02.000 --> 00:08:04.570
and I don't know what
hosts provide that service,

00:08:04.570 --> 00:08:06.780
but I know the task I want to perform.

00:08:06.780 --> 00:08:13.890
And it gets back a list of the instances
on the network that can meet its needs.

00:08:14.990 --> 00:08:21.690
If you're writing an application
for iOS or Mac OS X or Windows,

00:08:21.690 --> 00:08:25.640
then link local addressing is handled
for you by the operating system.

00:08:25.640 --> 00:08:29.940
Multicast DNS naming is
handled for you by Bonjour.

00:08:29.940 --> 00:08:35.120
If you're building a hardware device,
then you'll want to do those two things.

00:08:35.480 --> 00:08:37.830
But for most people
developing applications,

00:08:37.980 --> 00:08:42.160
the place you interact with Bonjour is
at the service discovery layer.

00:08:42.290 --> 00:08:45.440
So I want to talk a little
bit more about that now.

00:08:47.010 --> 00:08:50.130
There are three basic API operations.

00:08:50.330 --> 00:08:54.130
The first one is
registering your service.

00:08:54.270 --> 00:08:55.990
Here we have an Apple TV.

00:08:56.150 --> 00:08:58.790
We connect the power cable,
and the first thing it does is

00:08:58.790 --> 00:09:02.230
announce that it provides the
AirPlay service on the network.

00:09:02.290 --> 00:09:06.700
It does that in case there were
clients out there listening for it.

00:09:06.700 --> 00:09:08.780
In this case, there weren't.

00:09:08.780 --> 00:09:11.600
The packet disappears into the ether.

00:09:13.780 --> 00:09:18.270
A common misperception about
Bonjour service discovery is

00:09:18.270 --> 00:09:22.080
that it works like some other
service discovery protocols that

00:09:22.180 --> 00:09:26.490
are continuously broadcasting
their presence on the network.

00:09:27.310 --> 00:09:31.290
Once a minute, twice a minute,
ten times a second, whatever it is,

00:09:31.710 --> 00:09:33.120
continually pounding the network.

00:09:33.190 --> 00:09:37.150
Bonjour would not be sustainable
if it worked like that.

00:09:37.150 --> 00:09:39.800
After this initial announcement,
the device shuts up and

00:09:39.800 --> 00:09:41.110
it just listens quietly.

00:09:41.110 --> 00:09:43.500
Now, suppose you come to visit me.

00:09:43.510 --> 00:09:47.490
You bring your iPad and you say,
I've got this great slideshow

00:09:47.570 --> 00:09:49.620
of photos I'd like to show you.

00:09:49.620 --> 00:09:53.930
And rather than look on the small screen,
I'd like to show you on my big screen.

00:09:55.240 --> 00:09:58.200
You open up,
you get out your iPad and you tap on

00:09:58.290 --> 00:10:02.900
the AirPlay icon and it sends out a
multicast query on the network saying,

00:10:02.910 --> 00:10:05.230
are there any AirPlay services?

00:10:05.230 --> 00:10:08.590
And the Apple TV sends
back a response saying,

00:10:08.590 --> 00:10:10.640
yes, I support AirPlay.

00:10:10.640 --> 00:10:15.300
And Apple TV then appears in
the list of available services.

00:10:15.300 --> 00:10:17.400
That's browsing.

00:10:18.960 --> 00:10:21.260
The next step is resolving.

00:10:21.260 --> 00:10:22.750
And this is a key point.

00:10:22.870 --> 00:10:24.470
We have two separate steps here.

00:10:24.560 --> 00:10:28.560
A lot of service discovery mechanisms
in the past combined these into one.

00:10:28.560 --> 00:10:31.490
And there's a good reason
why they're separate.

00:10:31.540 --> 00:10:36.160
And that is browsing the
network to discover what's there

00:10:36.500 --> 00:10:41.990
is an operation that you do
often relatively infrequently.

00:10:42.000 --> 00:10:45.720
For example,
when you're setting up a printer,

00:10:45.720 --> 00:10:49.320
you may pick your default
printer just once.

00:10:49.340 --> 00:10:50.990
But you may print on it every day.

00:10:50.990 --> 00:10:56.460
And with the dynamic addressing
that I talked about with DHCP,

00:10:56.500 --> 00:10:59.040
with link local addressing,
the address might not be

00:10:59.050 --> 00:11:00.710
the same from day to day.

00:11:00.720 --> 00:11:04.920
So if when I set up my default printer,
I store its IP address,

00:11:04.920 --> 00:11:07.140
then tomorrow it may not work.

00:11:07.140 --> 00:11:10.390
What I want to do is store
its Bonjour service name.

00:11:10.400 --> 00:11:11.980
And then at time of day,
I can set up my default printer.

00:11:12.000 --> 00:11:15.920
And at time of use, every time I print,
I do the resolve operation to say

00:11:16.110 --> 00:11:19.930
what is the current IP address
and port number for this service.

00:11:19.940 --> 00:11:23.300
So in the AirPlay example,
when I tap on Apple TV,

00:11:23.300 --> 00:11:28.180
it sends out a query saying what is
the current right now live information

00:11:28.180 --> 00:11:30.760
for how to connect to this service.

00:11:30.780 --> 00:11:33.260
So those are the three operations.

00:11:33.260 --> 00:11:36.850
And if you follow the advice
Rory will give later about

00:11:36.850 --> 00:11:41.600
some of the higher level APIs,
you don't even need to do the resolve.

00:11:41.600 --> 00:11:41.980
Because if you do, you're going to be
able to do the resolve.

00:11:41.980 --> 00:11:43.430
So it's done automatically for you.

00:11:43.440 --> 00:11:46.040
You have a Bonjour service name.

00:11:46.040 --> 00:11:47.980
And you say give me a connection to this.

00:11:47.980 --> 00:11:51.400
And the resolve and connect are handled
for you automatically at the API layer.

00:11:55.410 --> 00:12:00.440
I talked about the AirPlay service,
and I used that in a kind of

00:12:00.520 --> 00:12:04.410
loose human sense that the
Apple TV provides the AirPlay service,

00:12:04.410 --> 00:12:08.720
but at a protocol level,
we need a really rigorous definition of

00:12:08.720 --> 00:12:11.610
what it means to offer a certain service.

00:12:12.280 --> 00:12:15.190
Every service on the
network is represented by

00:12:15.190 --> 00:12:19.530
a structured instance name,
and this is a three-part name.

00:12:19.640 --> 00:12:23.070
The first part is the
user-visible instance name.

00:12:23.160 --> 00:12:29.490
It's rich text, uppercase, lowercase,
spaces, non-Roman characters,

00:12:29.490 --> 00:12:33.130
anything you can show in Unicode
you can use in the instance name.

00:12:33.300 --> 00:12:37.250
The second part of the
name is the service type.

00:12:37.350 --> 00:12:41.370
In this case, it's IPP,
Internet Printing Protocol.

00:12:41.630 --> 00:12:43.910
And then the final part is the domain.

00:12:44.040 --> 00:12:46.760
In this case, it's local,
which means look this up on the

00:12:46.760 --> 00:12:49.240
local network with multicast DNS.

00:12:49.370 --> 00:12:52.800
With wide area Bonjour,
that could be apple.com

00:12:52.800 --> 00:12:54.500
or any other domain.

00:12:54.500 --> 00:13:00.180
But right now,
I want to talk about the service type.

00:13:01.710 --> 00:13:06.760
Service types are unique strings,
and they identify two things.

00:13:06.760 --> 00:13:11.280
They identify what the service
does and how it does it.

00:13:11.280 --> 00:13:14.390
And I want to go into that
a little bit more because

00:13:14.390 --> 00:13:16.560
that's a very important point.

00:13:16.880 --> 00:13:19.830
What the service does might be, say,
printing.

00:13:20.040 --> 00:13:23.660
From the user's point of view,
I want paper with letters on it.

00:13:23.730 --> 00:13:24.820
I want printing.

00:13:24.820 --> 00:13:27.610
So that's the user's conceptual service.

00:13:27.610 --> 00:13:29.560
But there's LPR printing.

00:13:29.560 --> 00:13:31.260
There's IPP printing.

00:13:31.260 --> 00:13:35.900
There are various proprietary data
stream protocols for doing printing.

00:13:35.900 --> 00:13:38.700
And if I've got a client that
speaks IPP and I've got a

00:13:38.750 --> 00:13:42.450
printer that only speaks LPR,
the fact that they're both printers

00:13:42.520 --> 00:13:46.650
from the human point of view doesn't
help the software communicate.

00:13:46.880 --> 00:13:53.280
So we need to know both what the service
does and also what protocol it uses,

00:13:53.280 --> 00:13:56.510
that it's a protocol that we speak.

00:13:56.520 --> 00:13:59.660
And the same issue applies
kind of in reverse as well,

00:13:59.670 --> 00:14:03.230
that sometimes because things
are the same protocol doesn't

00:14:03.240 --> 00:14:07.280
mean that they're doing the same
logical service on the network.

00:14:07.300 --> 00:14:09.650
And I'll give an example of that.

00:14:09.860 --> 00:14:13.400
iTunes music sharing,
if you look with TCP dump,

00:14:13.400 --> 00:14:15.780
is little more than HTTP GET.

00:14:15.780 --> 00:14:16.860
You want to play a song?

00:14:16.880 --> 00:14:21.350
If you want to play a piece of music,
it will just do an HTTP GET for that

00:14:21.350 --> 00:14:25.470
MP4 file and start playing the music.

00:14:26.330 --> 00:14:31.570
The fact that it's built using HTTP is
a perfectly sound engineering decision.

00:14:31.580 --> 00:14:33.080
That's a good protocol to use.

00:14:33.080 --> 00:14:36.660
That doesn't mean that iTunes is
serving web pages that it would make

00:14:36.660 --> 00:14:40.990
sense for you to look at in Safari,
and it doesn't mean that the average web

00:14:40.990 --> 00:14:43.540
server has music that iTunes can play.

00:14:59.990 --> 00:14:59.990
There's a case where the
on-the-wire protocol is HTTP,

00:14:59.990 --> 00:14:59.990
but the purpose is very different.

00:14:59.990 --> 00:14:59.990
The service type identifies both
what the protocol is and what

00:14:59.990 --> 00:14:59.990
purpose it's being used for.

00:15:00.330 --> 00:15:06.460
These are 15-character strings, US ASCII,
letters, digits, and hyphens,

00:15:06.460 --> 00:15:11.980
and they are managed by IANA,
the Internet Assigned Numbers Authority.

00:15:12.000 --> 00:15:16.280
You can see the list of
service types that are already

00:15:16.410 --> 00:15:18.840
assigned at the URL there.

00:15:18.840 --> 00:15:20.440
You can apply for your own.

00:15:20.440 --> 00:15:21.560
It doesn't cost anything.

00:15:21.560 --> 00:15:22.760
It's very quick and easy.

00:15:23.480 --> 00:15:27.540
And it's really important that you do
this because they manage the unique

00:15:27.590 --> 00:15:31.040
namespace to make sure that there
aren't any accidental conflicts.

00:15:31.040 --> 00:15:37.110
We don't want you to ship an
application that uses DAAP for your

00:15:37.110 --> 00:15:44.340
game because DAAP is the digital
audio access protocol used by iTunes.

00:15:44.340 --> 00:15:46.410
And if you were to
advertise that service,

00:15:46.410 --> 00:15:50.120
your service would appear in iTunes,
which probably wouldn't help because

00:15:50.120 --> 00:15:52.160
they probably don't have any music.

00:15:52.760 --> 00:15:55.260
And your clients would
discover iTunes music sharing.

00:15:55.260 --> 00:15:59.250
So that's why the service
type strings exist,

00:15:59.250 --> 00:16:03.720
and IANA provides this free service to
the community of managing that namespace.

00:16:06.480 --> 00:16:13.360
A question that comes up often is, yeah,
Bonjour looks great, but really,

00:16:13.360 --> 00:16:15.680
we're just going to send
some UDP broadcast packets.

00:16:15.730 --> 00:16:16.960
How hard could it be?

00:16:16.960 --> 00:16:22.120
Well, we thought that as well 12 years
ago when we started working on this,

00:16:22.120 --> 00:16:26.750
and I can tell you some of the
hurdles that you'll have to encounter.

00:16:26.760 --> 00:16:30.480
The first very obvious one is
that networking is not reliable.

00:16:30.610 --> 00:16:31.720
Packets get lost.

00:16:31.780 --> 00:16:33.460
What do you do about that?

00:16:33.560 --> 00:16:34.770
Well, everybody knows the answer.

00:16:34.820 --> 00:16:35.320
You retransmit.

00:16:35.320 --> 00:16:36.620
That's easy.

00:16:36.620 --> 00:16:39.280
But how much do you retransmit?

00:16:39.920 --> 00:16:42.040
How often?

00:16:42.540 --> 00:16:46.040
I'll give you an example of a problem
that used to happen with AppleTalk.

00:16:46.270 --> 00:16:49.090
You send a multicast query
looking for printers,

00:16:49.160 --> 00:16:51.200
and 50 printers respond.

00:16:51.460 --> 00:16:53.560
But because of packet loss,
you retransmit.

00:16:53.690 --> 00:16:57.220
So you send the query again,
and 50 printers respond.

00:16:57.260 --> 00:17:00.440
And you send it again,
and 50 printers respond.

00:17:00.480 --> 00:17:03.940
And UPnP has the same problem.

00:17:04.040 --> 00:17:08.090
To my knowledge,
every other service discovery

00:17:08.150 --> 00:17:11.490
protocol has this efficiency problem.

00:17:11.940 --> 00:17:15.560
Bonjour solves it with something
called known answer lists.

00:17:15.560 --> 00:17:19.560
When I retransmit the query, I say,
"Here are the 50 printers

00:17:19.560 --> 00:17:22.400
I already know about,
so you guys keep quiet.

00:17:22.590 --> 00:17:26.840
Is there anybody else out there that
I missed?" And what that means is that

00:17:26.890 --> 00:17:32.970
after two or three retransmissions,
the query process pretty soon degenerates

00:17:33.050 --> 00:17:36.240
into a single query with no more replies.

00:17:36.240 --> 00:17:39.190
So we put a lot of work into efficiency,
and that's just one example.

00:17:39.720 --> 00:17:47.150
Another issue is you will
notice with Apple applications,

00:17:47.210 --> 00:17:49.260
there's no refresh button.

00:17:49.610 --> 00:17:54.100
When you want to add a printer,
you don't see a flashlight panning

00:17:54.100 --> 00:17:57.050
back and forth for 10 seconds.

00:17:57.700 --> 00:17:58.580
And then it stops.

00:17:58.580 --> 00:18:01.980
And from the moment the list is
being displayed on the screen,

00:18:01.980 --> 00:18:04.170
it's already becoming
stale and out of date.

00:18:04.200 --> 00:18:04.640
No.

00:18:04.640 --> 00:18:08.970
The list is pretty much immediate,
and it stays up to date

00:18:08.970 --> 00:18:10.820
until you dismiss it.

00:18:10.990 --> 00:18:13.210
When new things appear,
they appear in the list.

00:18:13.210 --> 00:18:15.720
When things go away,
they disappear from the list.

00:18:16.520 --> 00:18:20.000
And because we have that live
update in the network view,

00:18:20.000 --> 00:18:24.500
that has got to flow through to all
other aspects of the system as well.

00:18:24.500 --> 00:18:28.440
If I unplug the Ethernet cable,
the services go away.

00:18:28.440 --> 00:18:30.910
If I plug it back in,
they come back again.

00:18:30.910 --> 00:18:33.570
If I turn Wi-Fi off,
the services go away.

00:18:33.580 --> 00:18:37.470
So handling that disconnect
reconnect is something you'll want

00:18:37.470 --> 00:18:39.520
to do for a good user experience.

00:18:39.610 --> 00:18:41.610
Bonjour handles that for you.

00:18:41.610 --> 00:18:45.270
You need to monitor network
configuration changes.

00:18:46.850 --> 00:18:50.570
And I'll give you just one
example of a more subtle issue.

00:18:50.630 --> 00:18:54.300
I can be on a Wi-Fi network
called Linksys,

00:18:54.410 --> 00:18:59.510
and my IP address is 192.168.0.2.

00:18:59.510 --> 00:19:03.020
And I switch to a different
Wi-Fi network called Linksys,

00:19:03.020 --> 00:19:07.970
and my IP address is 192.168.0.2.

00:19:08.240 --> 00:19:11.040
But it's not the same network.

00:19:11.190 --> 00:19:14.750
Detecting that case and actually
correctly flushing the stale

00:19:14.760 --> 00:19:18.250
services and displaying the new
ones is a tricky thing to do.

00:19:18.250 --> 00:19:21.290
One of the things that
Bonjour does for you.

00:19:21.300 --> 00:19:23.840
Along the lines of
disconnecting and reconnecting,

00:19:23.840 --> 00:19:26.450
there's power management,
there's sleep and wake.

00:19:26.520 --> 00:19:31.540
When I put my machine to sleep,
it's no longer reachable on the network.

00:19:31.870 --> 00:19:33.880
Bonjour will send
goodbye packets for you.

00:19:33.880 --> 00:19:37.700
Without your application doing anything,
Bonjour will send goodbye packets.

00:19:38.200 --> 00:19:40.740
Saying,
these services are no longer available.

00:19:40.740 --> 00:19:43.780
When I wake it up,
it will re-announce those services

00:19:43.780 --> 00:19:45.610
are present on the network again.

00:19:45.630 --> 00:19:47.250
Or...

00:19:48.970 --> 00:19:53.080
If you have an Apple TV or
an airport base station or

00:19:53.110 --> 00:19:58.010
time capsule on the network,
that offers a sleep proxy service.

00:19:58.020 --> 00:20:01.850
So when you put your iMac to sleep,
instead of sending goodbye packets,

00:20:01.900 --> 00:20:08.140
it will transfer all your Bonjour records
over to the sleep proxy saying,

00:20:08.140 --> 00:20:11.520
this is me, this is my identity,
this is my role on the network.

00:20:11.570 --> 00:20:14.480
If anybody wants me, wake me up.

00:20:16.460 --> 00:20:19.530
These are all things that you get
when you use the Bonjour APIs,

00:20:19.540 --> 00:20:22.940
which took us a long time to
build and would take you guys

00:20:22.940 --> 00:20:24.240
a long time to replicate.

00:20:26.780 --> 00:20:29.780
So with that,
I want to show you a little demo

00:20:29.780 --> 00:20:36.490
of a new feature in Mountain Lion,
which is...

00:20:37.670 --> 00:20:40.820
AirPlay screen mirroring.

00:20:40.820 --> 00:20:45.050
And here I have my Apple TV.

00:20:46.350 --> 00:20:50.680
And I have an IP router here.

00:20:50.700 --> 00:20:55.510
And I have a couple of
Wi-Fi access points.

00:20:55.980 --> 00:20:59.640
And I have a problem here because
I have two access points with

00:20:59.740 --> 00:21:03.720
two different Wi-Fi networks with
two different subnets and these

00:21:04.230 --> 00:21:06.510
devices are not on the same subnet.

00:21:06.580 --> 00:21:11.500
And normally that would be a problem,
but I would like to invite Bill Hoppin,

00:21:11.500 --> 00:21:15.710
VP of Business Development at Arrowhive,
to come up and explain how we're

00:21:15.840 --> 00:21:17.460
going to solve this problem.

00:21:19.340 --> 00:21:19.940
Thanks a lot, Stuart.

00:21:19.940 --> 00:21:20.520
Thank you, Bill.

00:21:20.520 --> 00:21:21.540
Hi, everybody.

00:21:21.540 --> 00:21:23.570
I'm Bill Hoppin with Arrowhive Networks.

00:21:23.660 --> 00:21:27.480
We make Wi-Fi access points,
and we end up connecting a lot of iOS

00:21:27.480 --> 00:21:29.480
and OS X devices to our access points.

00:21:29.480 --> 00:21:31.610
We're also seeing a
ton of Apple TV getting

00:21:31.610 --> 00:21:35.140
deployed in big businesses,
small businesses, even schools.

00:21:35.140 --> 00:21:37.820
The challenge is the Apple TVs are
typically connected to a

00:21:37.820 --> 00:21:40.830
different part of the network,
a different subnet.

00:21:40.840 --> 00:21:44.480
And so that means when the iPads and
the Macs are connected to the Wi-Fi,

00:21:44.480 --> 00:21:46.480
they don't have access to the Apple TV.

00:21:46.560 --> 00:21:49.180
It's a real bummer because, you know,
you see that Apple TV over there.

00:21:49.180 --> 00:21:51.740
It's the best possible way to
display anything on the planet.

00:21:51.740 --> 00:21:53.160
You can't have access to it.

00:21:53.220 --> 00:21:55.920
So at Arrowhive, we created this thing
called a Bonjour Gateway.

00:21:55.920 --> 00:22:01.520
And what it is is basically a protocol
that selectively makes Bonjour services

00:22:01.520 --> 00:22:04.970
available across the subnets,
more broadly available

00:22:04.970 --> 00:22:06.180
across the deployment.

00:22:06.180 --> 00:22:09.240
And selectively is pretty key because
if you make all these Bonjour services

00:22:09.240 --> 00:22:12.360
available everywhere in the network,
you'd have a Bonjour services

00:22:12.360 --> 00:22:13.620
list about a mile long.

00:22:13.620 --> 00:22:15.280
You'd need a new display
to look at them all.

00:22:15.300 --> 00:22:16.540
You know, we don't want to do that.

00:22:16.540 --> 00:22:17.390
We want to do it selectively.

00:22:17.400 --> 00:22:18.060
So that's what we've done.

00:22:18.060 --> 00:22:21.060
And what it does is it allows
these Macs and iPads to actually

00:22:21.060 --> 00:22:23.520
do the display mirroring,
the mountain line mirroring

00:22:23.640 --> 00:22:24.420
over to the Apple TV.

00:22:24.420 --> 00:22:27.790
We also did it in a way where our
product can plug in any network,

00:22:27.790 --> 00:22:30.530
no matter whose Wi-Fi is there,
no matter what the configuration.

00:22:30.540 --> 00:22:33.840
And as long as one of the Arrowhive
Bonjour-enabled products there will

00:22:33.950 --> 00:22:36.660
go open up this Bonjour Gateway and
allow you to access these

00:22:36.710 --> 00:22:37.990
services across subnets.

00:22:38.060 --> 00:22:39.040
So we think it's really cool.

00:22:39.040 --> 00:22:41.770
We're happy to make it available
to all Apple customers all over

00:22:41.770 --> 00:22:44.630
the planet by making it sort of
plug and play into any network.

00:22:44.680 --> 00:22:46.540
It's beta code that you'll see here.

00:22:46.580 --> 00:22:48.390
It's not going to be here today,
but it's going to be production solid,

00:22:48.450 --> 00:22:49.620
ready to go the end of July.

00:22:49.620 --> 00:22:52.460
So take a look at
arrowhive.com for more details.

00:22:52.460 --> 00:22:53.340
And thanks very much.

00:22:53.360 --> 00:22:54.090
Thank you, Bill.

00:22:54.120 --> 00:22:55.240
Let's give this a try.

00:22:55.240 --> 00:23:01.740
So you'll see my Apple TV here is
on the network Apple plus Arrowhive.

00:23:01.740 --> 00:23:07.260
And my Mac here is on Apple Arrowhive 2.

00:23:07.260 --> 00:23:10.460
You're seeing the Mac not
through the projector here.

00:23:10.460 --> 00:23:13.000
This is through airplane
mirroring with the Apple TV.

00:23:13.000 --> 00:23:14.980
The Apple TV is on.

00:23:16.710 --> 00:23:18.810
The Apple plus Arrowhive network.

00:23:18.890 --> 00:23:20.740
The Mac is on a different subnet.

00:23:20.740 --> 00:23:24.230
Yet they're still discovering each
other and communicating just fine.

00:23:24.240 --> 00:23:28.640
I think a lot of enterprise customers
are going to be very happy with this.

00:23:28.640 --> 00:23:31.390
Thanks for this great addition
to the Bonjour family,

00:23:31.450 --> 00:23:31.860
Bill.

00:23:31.860 --> 00:23:32.300
Thank you.

00:23:32.300 --> 00:23:32.650
Thank you.

00:23:38.750 --> 00:23:41.240
And I'm happy to say
it's not just Error Hive.

00:23:41.280 --> 00:23:46.150
Aruba and Zerus have also announced
similar products that do this.

00:23:46.150 --> 00:23:49.440
So if this is something you need,
I invite you to check out all

00:23:49.440 --> 00:23:51.630
three of these product offerings.

00:23:51.640 --> 00:23:55.050
And with that,
I think we need to add one more

00:23:55.110 --> 00:24:00.040
thing to our list of reasons
not to invent your own protocol.

00:24:00.040 --> 00:24:02.870
With Bonjour,
you get automatic cross-subnet

00:24:02.870 --> 00:24:04.940
proxying with these services.

00:24:05.720 --> 00:24:08.440
And with that,
I'd like to invite Roary McGuire to

00:24:08.530 --> 00:24:14.000
come up on stage and go into some
more details on programming specifics.

00:24:17.180 --> 00:24:18.690
Thank you, Stuart.

00:24:18.800 --> 00:24:23.170
So how do you as developers make
your user experience even better?

00:24:23.260 --> 00:24:25.400
Well, let's go right into it.

00:24:25.530 --> 00:24:30.000
These are the API layers that you'll be
using as developers to utilize Bonjour.

00:24:30.120 --> 00:24:33.580
Your app is over here and it can plug
into three different layers of API.

00:24:33.600 --> 00:24:36.660
You can plug into NSNet services
up at the Cocoa layer.

00:24:36.750 --> 00:24:39.450
You can plug into
CFNet services at the CF layer.

00:24:39.560 --> 00:24:40.840
And if you really want
to get down and dirty,

00:24:40.840 --> 00:24:45.700
you can plug into the DNSSD.h,
the C layer API.

00:24:45.880 --> 00:24:48.540
But instead of just showing
you how to use Bonjour,

00:24:48.540 --> 00:24:51.340
we're also going to go through today
how to actually open up listening

00:24:51.340 --> 00:24:55.030
sockets and how to make sure that your
entire application from temp to stern is

00:24:55.030 --> 00:24:56.470
actually working in terms of networking.

00:24:56.480 --> 00:24:59.790
So in order to do that,
we're also going to talk about

00:24:59.820 --> 00:25:03.860
the layers of the TCP stack,
right, that you can plug into.

00:25:03.860 --> 00:25:07.120
At the Cocoa layer,
we have NSInputStream and NSOutputStream.

00:25:07.120 --> 00:25:09.900
At the CF layer,
we have CFStream and CFSocket.

00:25:09.900 --> 00:25:12.560
And if you want to get down and dirty,
we have the actual BSD layer, right,

00:25:12.580 --> 00:25:13.840
Socket, Bind, and Listen.

00:25:14.490 --> 00:25:17.400
And you'll actually have to use all of
these layers to open up your listener,

00:25:17.400 --> 00:25:19.550
but I'm going to go
through how to do that,

00:25:19.890 --> 00:25:22.260
right, so that you don't have to
figure it all out for yourself.

00:25:23.910 --> 00:25:26.800
So, what's the first thing that
you do on the server side?

00:25:26.840 --> 00:25:29.000
The first thing you're going
to do on the server side is

00:25:29.000 --> 00:25:33.290
actually create your socket,
bind it, and then tell it to listen.

00:25:33.300 --> 00:25:34.790
These are actually the API calls.

00:25:34.800 --> 00:25:36.800
It's called socket, bind, and listen.

00:25:36.920 --> 00:25:40.300
That's going to give you a
BSD layer file descriptor.

00:25:40.300 --> 00:25:41.300
It's an integer.

00:25:41.500 --> 00:25:43.800
Once you get that,
that's a little too dirty.

00:25:43.800 --> 00:25:45.870
It's really down low.

00:25:46.200 --> 00:25:48.600
Wrap it in a CF socket ref.

00:25:48.600 --> 00:25:50.140
This is going to make it
a lot easier to deal with.

00:25:50.140 --> 00:25:51.180
You won't have to call select.

00:25:51.280 --> 00:25:54.520
You can actually use your CF run loop,
which is toll-free bridge

00:25:54.520 --> 00:25:59.980
to your NS run loop,
so that you can actually get

00:25:59.980 --> 00:25:59.980
accept events in your server.

00:26:00.830 --> 00:26:04.170
So then you're going to take --
you're going to use the Bonjour layer

00:26:04.420 --> 00:26:08.040
to actually advertise your service.

00:26:08.140 --> 00:26:11.440
And you're going to make sure that
you call it with the correct port,

00:26:11.730 --> 00:26:11.940
right?

00:26:12.320 --> 00:26:14.000
Your users don't have to type ports.

00:26:14.000 --> 00:26:16.540
Your users don't have
to type IP addresses.

00:26:16.630 --> 00:26:18.460
But when you're developing
your application,

00:26:18.460 --> 00:26:23.050
you have to make sure that you pass
the correct port to Bonjour so that

00:26:23.050 --> 00:26:26.360
it can advertise the correct port so
that your users don't have to type it.

00:26:26.460 --> 00:26:30.330
I'll go into a little more detail when
I get to the code slides about this.

00:26:30.410 --> 00:26:33.300
Once you're done actually
initing that service,

00:26:33.460 --> 00:26:35.680
you're going to want to call publish.

00:26:35.700 --> 00:26:38.370
This is what actually advertises
your service on the network.

00:26:38.440 --> 00:26:41.620
This is what sends those couple of
advertisement packets that you saw a

00:26:41.620 --> 00:26:43.670
little bit earlier in the presentation.

00:26:44.330 --> 00:26:45.860
So what about the client side?

00:26:45.860 --> 00:26:49.540
On the client side,
you're going to want to browse.

00:26:49.540 --> 00:26:51.680
You're going to want to
search for services of a

00:26:51.700 --> 00:26:53.460
particular type in a domain.

00:26:53.460 --> 00:26:57.670
This is the API that you'll
call in NSNet Service Browser.

00:26:58.970 --> 00:27:01.440
You're going to get
callbacks to your delegate,

00:27:01.440 --> 00:27:02.560
did find service.

00:27:02.640 --> 00:27:04.270
Let's say there's three
services on the network.

00:27:04.340 --> 00:27:06.990
Let's say that we're making a mood
ring application and there are

00:27:07.160 --> 00:27:10.530
three servers on the network that
provide this mood ring application,

00:27:10.580 --> 00:27:11.900
this mood ring service.

00:27:11.900 --> 00:27:13.840
You're going to get
three of these callbacks.

00:27:13.840 --> 00:27:17.870
Then you're going to want to let
your user select one of them.

00:27:18.120 --> 00:27:18.900
This is important.

00:27:18.900 --> 00:27:22.900
Like Stuart said, Bonjour separates
browsing from resolving.

00:27:22.900 --> 00:27:25.980
You're actually going to want to
let your user select the service

00:27:26.220 --> 00:27:27.880
instance they want to connect to.

00:27:27.880 --> 00:27:29.860
Don't just connect to all of them.

00:27:30.090 --> 00:27:32.900
Let your user select which
one you want to connect to.

00:27:32.900 --> 00:27:36.260
Now there's some extra APIs in
Bonjour that will allow you to give

00:27:36.260 --> 00:27:39.970
more information about the services
so that you don't have to actually

00:27:39.970 --> 00:27:42.160
connect and get other information.

00:27:42.800 --> 00:27:45.000
So once you've connected,
what do you want to do?

00:27:45.000 --> 00:27:47.100
You actually -- or, sorry,
once your user is selected,

00:27:47.110 --> 00:27:48.700
you want to connect, right?

00:27:48.700 --> 00:27:51.250
And again, like Stuart said,
these APIs are going

00:27:51.250 --> 00:27:52.450
to make it really easy.

00:27:52.460 --> 00:27:55.430
You don't have to separate the
resolve call and the connect call.

00:27:55.510 --> 00:27:57.650
You're going to get the
NS input stream and NS output

00:27:57.660 --> 00:28:00.100
stream from your NSNet service.

00:28:00.190 --> 00:28:01.600
You're going to schedule
them in a run loop,

00:28:01.630 --> 00:28:01.800
right?

00:28:01.870 --> 00:28:03.500
Networking is difficult.

00:28:03.560 --> 00:28:06.400
You're going to want to make sure
that you do things asynchronously.

00:28:06.490 --> 00:28:08.660
Do things asynchronously, right?

00:28:08.790 --> 00:28:10.100
Don't block on the main thread.

00:28:10.100 --> 00:28:12.190
It's not a good idea.

00:28:12.480 --> 00:28:13.280
And then you're going to call it open.

00:28:13.280 --> 00:28:17.800
Open on these things is actually
what both resolves and connects.

00:28:20.280 --> 00:28:21.540
So what about back on the server side?

00:28:21.540 --> 00:28:23.880
What happens when the
client actually connects?

00:28:24.010 --> 00:28:28.060
Well, your CF socket ref object that's
wrapping your file descriptor will

00:28:28.060 --> 00:28:30.060
actually give you an accept callback.

00:28:30.060 --> 00:28:32.440
And I'll actually go over
the accept callbacks.

00:28:32.440 --> 00:28:33.790
You don't have to write your own.

00:28:34.000 --> 00:28:37.810
That is going to actually give you back
an NS input stream and an NS output

00:28:37.810 --> 00:28:40.320
stream on the server side as well.

00:28:40.410 --> 00:28:43.510
Once you have that, they're connected.

00:28:43.630 --> 00:28:44.380
Right?

00:28:44.420 --> 00:28:47.110
Everything you put in the output stream
on the server side gets to the input

00:28:47.170 --> 00:28:50.400
stream on the client side and vice versa.

00:28:51.690 --> 00:28:53.240
So, what about the actual code, right?

00:28:53.240 --> 00:28:54.360
Server side.

00:28:54.680 --> 00:28:57.250
The first thing you want
to do is bind listen,

00:28:57.250 --> 00:28:58.080
right?

00:28:58.080 --> 00:29:00.550
You create the socket up at the top.

00:29:00.820 --> 00:29:03.760
And you bind it and then you listen.

00:29:03.760 --> 00:29:06.530
Note that this is the IPv4 socket.

00:29:06.540 --> 00:29:11.460
You are going to want to pass port
number zero in your sock adder structure.

00:29:11.580 --> 00:29:15.700
This asks the kernel to give
you an arbitrary port number.

00:29:15.700 --> 00:29:17.130
It doesn't matter what
port number you have.

00:29:17.130 --> 00:29:19.200
Bonjour is going to take care
of that for you so your user

00:29:19.200 --> 00:29:20.640
doesn't have to type it in.

00:29:20.640 --> 00:29:23.490
But you have to ask the kernel
to give you an arbitrary one.

00:29:23.870 --> 00:29:25.790
Otherwise if you ask for
the same one every time,

00:29:25.790 --> 00:29:29.420
maybe somebody else asks for that one and
you are not going to be able to get it.

00:29:29.420 --> 00:29:31.820
So just let the kernel give you
whatever it has available and then

00:29:32.080 --> 00:29:33.600
advertise that through Bonjour.

00:29:35.560 --> 00:29:39.500
You're also going to want to
create a separate IPv6 socket.

00:29:39.500 --> 00:29:41.330
And to this one,
you're going to want to specify the port

00:29:41.460 --> 00:29:43.810
number that you got for the IPv4 socket.

00:29:44.010 --> 00:29:47.440
In Bonjour, you can't specify different
port numbers for IPv4 and IPv6,

00:29:47.440 --> 00:29:52.260
so what you do is you tell the kernel,
"Give me the same port number in IPv6."

00:29:54.600 --> 00:30:02.160
So what about hooking up the
IPv4 socket into a CF socket?

00:30:02.160 --> 00:30:07.740
You're going to call CF socket
create with native on the V4 socket.

00:30:09.360 --> 00:30:11.680
And then you're going to call
the same call on the V6 socket,

00:30:11.680 --> 00:30:12.140
right?

00:30:12.140 --> 00:30:16.480
So you'll have two CF socket ref objects,
one for your V4 socket,

00:30:16.630 --> 00:30:18.290
one for your V6 socket.

00:30:18.390 --> 00:30:24.970
But notice you pass the same listening
socket callback to both of those calls.

00:30:25.610 --> 00:30:27.100
And this is what it looks like.

00:30:27.200 --> 00:30:31.730
This is the code to actually get
the accept callback when somebody

00:30:31.730 --> 00:30:36.070
connects to your server and
actually wrap it in NSInputStream,

00:30:36.160 --> 00:30:37.720
NSOutputStream.

00:30:39.710 --> 00:30:44.000
So keep in mind, right,
hopefully all of you are already

00:30:44.000 --> 00:30:46.830
using automatic reference counting
or you're going to be using it soon.

00:30:46.840 --> 00:30:48.850
Automatic reference
counting is really cool.

00:30:48.990 --> 00:30:51.630
But at the CF layer,
when you pass it up to automatic

00:30:51.710 --> 00:30:55.020
reference counting up in the Cocoa layer,
you have to make sure to call

00:30:55.020 --> 00:30:56.620
this CF bridging release,
right,

00:30:56.620 --> 00:31:01.120
to make sure that you tell the compiler,
"I'm passing the retain that I got

00:31:01.410 --> 00:31:05.450
when I created this CF object up
to the Cocoa layer that's going

00:31:05.450 --> 00:31:08.590
to automatically release it when
you're not using it anymore."

00:31:09.940 --> 00:31:13.210
Okay, so what about the actual
Bonjour call and register?

00:31:13.390 --> 00:31:16.200
So, let me go through the parameters
in a little bit more detail here.

00:31:16.270 --> 00:31:20.070
The domain you're going to use
is the empty string domain.

00:31:20.730 --> 00:31:24.520
This instructs the Bonjour system
to use all the domains that

00:31:24.520 --> 00:31:26.240
it has available to it.

00:31:26.290 --> 00:31:28.340
A lot of times you're
only going to have .local,

00:31:28.340 --> 00:31:30.540
which is the multicast
domain over the link local,

00:31:30.540 --> 00:31:32.000
like Stuart was talking about.

00:31:32.120 --> 00:31:36.460
But if your users are using
Back to My Mac or if your IT guys

00:31:36.460 --> 00:31:41.320
have set up Bonjour wide area,
then this will also give you

00:31:41.570 --> 00:31:43.900
potentially those domains,
right?

00:31:44.030 --> 00:31:47.860
So use the empty string domain.

00:31:48.340 --> 00:31:49.450
The next thing is the type.

00:31:49.660 --> 00:31:52.390
This is the unique service identifier
that Stuart was talking about.

00:31:52.460 --> 00:31:55.960
This uniquely identifies what
your service does and the

00:31:55.960 --> 00:31:57.420
protocol it uses to do it.

00:31:57.510 --> 00:32:01.160
In our case of making a mood ring app,
we're going to use mood ring.

00:32:02.100 --> 00:32:03.260
and then the name.

00:32:03.350 --> 00:32:06.440
Again, you're going to want to
use the empty string name.

00:32:06.440 --> 00:32:08.840
This will use the default
name of your system.

00:32:08.840 --> 00:32:12.530
So in the Mac,
it's in the sharing pref pane and on iOS,

00:32:12.530 --> 00:32:14.790
it's the name that you
give the device in,

00:32:14.790 --> 00:32:15.760
say, iTunes.

00:32:15.760 --> 00:32:18.370
Now, you can use a different
name here if you want to,

00:32:18.370 --> 00:32:21.480
and this is full Unicode
character support.

00:32:21.480 --> 00:32:24.780
If you really want to call your
service something in Klingon,

00:32:24.780 --> 00:32:25.480
you can.

00:32:26.710 --> 00:32:28.960
And the port number
here is also important.

00:32:28.990 --> 00:32:31.900
That arbitrary port number that you
got from the kernel is what you're

00:32:31.900 --> 00:32:34.460
going to want to register here
so that your client will actually

00:32:34.460 --> 00:32:36.870
connect to the correct port.

00:32:39.090 --> 00:32:41.100
So what about register callbacks?

00:32:41.160 --> 00:32:43.640
When your service
actually gets registered,

00:32:43.640 --> 00:32:48.150
when it gets down into the
MDNS responder daemon and it

00:32:48.150 --> 00:32:54.030
sends out the advertised packets,
you'll get this did publish callback.

00:32:54.110 --> 00:32:56.290
If you had specified
the empty string domain,

00:32:56.300 --> 00:32:59.250
this is how you're going to find
out what the name actually is so

00:32:59.250 --> 00:33:00.890
you can display it to the user.

00:33:00.920 --> 00:33:04.180
Say, okay, this is the one,
this is Rory's cool mood rig.

00:33:04.190 --> 00:33:05.860
And so on your client,
that's the one you're

00:33:05.860 --> 00:33:06.920
going to want to choose.

00:33:07.300 --> 00:33:10.520
or it's clockback or
something in Klingon.

00:33:10.660 --> 00:33:14.400
You also might get a did not publish.

00:33:14.400 --> 00:33:15.390
Make sure you handle errors.

00:33:15.410 --> 00:33:18.020
Again, networking is not easy.

00:33:18.170 --> 00:33:20.000
You're going to get
errors from time to time.

00:33:20.140 --> 00:33:23.070
You're going to want to make sure
that you handle those correctly.

00:33:23.630 --> 00:33:25.300
So what about the client?

00:33:25.350 --> 00:33:28.060
On the client, you're going to want
to browse for services.

00:33:28.060 --> 00:33:34.480
You don't have to deal with the lower
layers in CF or in the BSD layers.

00:33:34.480 --> 00:33:39.260
You just create one of these
NSNet service browser object,

00:33:39.400 --> 00:33:43.380
and you browse for the
services of your type.

00:33:43.380 --> 00:33:44.930
In this case, we're doing mood ring.

00:33:44.930 --> 00:33:47.130
You don't want to search
for other people's services.

00:33:47.130 --> 00:33:49.650
You want to search for your own
so that when the user selects one,

00:33:49.650 --> 00:33:51.660
they'll actually connect to your service.

00:33:52.700 --> 00:33:55.510
And again, you want to specify the
empty string domain so that,

00:33:55.600 --> 00:33:58.650
say, if you're on the Mac,
you can take advantage of Back to My Mac.

00:34:00.970 --> 00:34:02.670
So what about browse callbacks?

00:34:02.850 --> 00:34:04.900
There's a couple of
different browse callbacks.

00:34:04.900 --> 00:34:07.090
One is did find service.

00:34:07.210 --> 00:34:09.690
You're going to get one of these
for each of the service instances

00:34:09.690 --> 00:34:11.040
that are found on the network.

00:34:11.120 --> 00:34:15.100
Now,
there's a little bit of a UI hint here.

00:34:15.100 --> 00:34:17.510
Because you get one of these
callbacks for each of the

00:34:17.520 --> 00:34:19.770
services that's on the network,
you're going to want to pay

00:34:19.770 --> 00:34:21.160
attention to this more coming flag.

00:34:21.160 --> 00:34:26.970
Essentially, it tells you don't update
your UI until this is false.

00:34:27.060 --> 00:34:30.380
Because you might flutter your UI a bunch
with a bunch of things that come in,

00:34:30.380 --> 00:34:31.930
especially at the beginning.

00:34:34.090 --> 00:34:36.130
Also, we have did remove service.

00:34:36.430 --> 00:34:37.680
Bonjour is dynamic.

00:34:37.770 --> 00:34:40.400
Things are coming and going all the time,
and you're going to get these

00:34:40.400 --> 00:34:41.300
did remove service calls.

00:34:41.300 --> 00:34:45.900
You're going to want to make sure
that you update your UI accordingly,

00:34:46.130 --> 00:34:48.670
and don't forget the more coming flag.

00:34:48.990 --> 00:34:52.050
You're going to want to make sure
that you remove this service from

00:34:52.050 --> 00:34:56.270
your model and then update your
UI when more coming is false.

00:34:57.280 --> 00:34:59.080
So what about resolving and connecting?

00:34:59.190 --> 00:35:00.640
Well, it's actually pretty easy.

00:35:00.640 --> 00:35:03.860
All you do is you ask the service
that the user selected for its

00:35:03.860 --> 00:35:07.440
input stream and its output stream,
schedule them in a run loop, and open.

00:35:07.440 --> 00:35:08.990
It's that simple.

00:35:09.010 --> 00:35:12.280
Now, if you're using the kind of use
case that Stuart was talking about

00:35:12.280 --> 00:35:15.680
earlier with a printer where your
user has selected the service instance

00:35:15.680 --> 00:35:18.560
that it wants to connect to once,
and then you're going to want to

00:35:18.940 --> 00:35:21.510
connect to that in multiple instances
of your application or in multiple

00:35:21.510 --> 00:35:26.390
invocations of your application,
you can construct an NSNetService object

00:35:26.390 --> 00:35:31.250
with a name and a type and a domain,
and then just get the input stream,

00:35:31.270 --> 00:35:34.630
output stream, schedule it in a run loop,
and open.

00:35:36.800 --> 00:35:37.800
Schedule it in a run loop.

00:35:37.880 --> 00:35:38.850
Networking is hard.

00:35:38.860 --> 00:35:39.640
It's asynchronous.

00:35:39.640 --> 00:35:42.570
Don't do stuff on your main run loop.

00:35:42.670 --> 00:35:43.850
Don't do stuff on your main thread.

00:35:46.230 --> 00:35:48.340
So, that's the end of the coding section.

00:35:48.600 --> 00:35:51.330
What about some tips and reminders
to make sure that your users get

00:35:51.330 --> 00:35:53.200
the best experience that they can?

00:35:54.520 --> 00:35:57.360
First is about Bonjour and
iOS multitasking.

00:35:57.360 --> 00:36:01.830
We've done a lot of work to make
sure that multitasking is a great

00:36:01.830 --> 00:36:04.150
experience for our customers.

00:36:04.230 --> 00:36:06.570
Your customers and our customers.

00:36:06.810 --> 00:36:10.890
We've done a lot of things in
terms of making things efficient.

00:36:11.080 --> 00:36:14.010
When an application goes
into the background,

00:36:14.190 --> 00:36:15.770
it may actually get frozen.

00:36:16.150 --> 00:36:17.600
and stop running.

00:36:17.650 --> 00:36:20.400
Your code at some point will stop
running when your application

00:36:20.400 --> 00:36:21.660
goes into the background.

00:36:21.670 --> 00:36:23.860
Before that happens,
you'll get an application

00:36:23.860 --> 00:36:27.720
did inner background call in
your application delegate.

00:36:27.720 --> 00:36:31.280
That doesn't mean that you're
about to stop right now.

00:36:31.280 --> 00:36:34.540
It means that your application
is in the background and it's

00:36:34.540 --> 00:36:36.240
going to stop at some point.

00:36:36.240 --> 00:36:37.710
Now, some of you might know
that you can -- sorry,

00:36:37.760 --> 00:36:40.100
you should stop listening and
registering at this point,

00:36:40.150 --> 00:36:40.610
right?

00:36:40.610 --> 00:36:44.450
If you're listening on a socket,
and if you've registered with Bonjour,

00:36:44.450 --> 00:36:46.440
you're going to want to stop
those operations when you get

00:36:46.440 --> 00:36:47.910
application did inner background.

00:36:48.060 --> 00:36:50.880
And the reason you're going to want to
do that is because you don't actually

00:36:50.880 --> 00:36:53.300
know when your application stops.

00:36:53.300 --> 00:36:57.680
The call that you get that says
your application is going to stop,

00:36:57.700 --> 00:37:02.090
it's actually it may stop,
is application did inner background.

00:37:02.340 --> 00:37:04.650
Once your application stops,
if you're still registered

00:37:04.650 --> 00:37:07.030
with Bonjour and you're
still listening on something,

00:37:07.030 --> 00:37:09.030
your client might try to
connect and it won't be able

00:37:09.030 --> 00:37:10.380
to because your code is stuck.

00:37:10.400 --> 00:37:11.040
It's frozen.

00:37:11.070 --> 00:37:12.850
It's not just in the background running.

00:37:12.850 --> 00:37:14.020
It's in the background.

00:37:14.020 --> 00:37:17.020
background and not running.

00:37:17.400 --> 00:37:19.810
So you might know that you
can request a task completion.

00:37:19.890 --> 00:37:23.390
That really only extends the amount
of time that your application is

00:37:23.530 --> 00:37:25.300
going to keep going before it stops.

00:37:25.300 --> 00:37:29.260
But at some point,
your application is going to stop.

00:37:29.260 --> 00:37:32.660
What happens when your
application is actually stopped?

00:37:32.660 --> 00:37:36.290
Well,
your Bonjour operations may be canceled.

00:37:36.340 --> 00:37:40.800
If you have a browse going or if you have
a registration going because you didn't

00:37:40.800 --> 00:37:45.460
actually stop it when you were told
that you were going in the background,

00:37:45.460 --> 00:37:46.700
they're going to be broken.

00:37:46.700 --> 00:37:49.810
The IPC calls down to the
Bonjour daemon are going to be broken.

00:37:50.280 --> 00:37:51.700
Again, your code is not running.

00:37:51.700 --> 00:37:52.690
You don't know this yet.

00:37:53.180 --> 00:37:53.770
Right?

00:37:54.120 --> 00:37:58.100
This really depends on how long your
application has been in the background.

00:37:58.100 --> 00:38:01.630
If your user, say, hits the home button,
switches to a different application,

00:38:01.690 --> 00:38:04.040
gets something, does something,
comes right back,

00:38:04.040 --> 00:38:07.450
your application may have been running
the entire time in the background.

00:38:07.690 --> 00:38:09.870
And even if it did get
frozen for a little bit,

00:38:09.870 --> 00:38:12.850
your Bonjour operations may
actually still be going.

00:38:12.850 --> 00:38:16.090
The same is true for your connections.

00:38:16.100 --> 00:38:18.650
If you have listening ports,
those listening ports may

00:38:18.650 --> 00:38:20.400
actually have stopped listening.

00:38:20.400 --> 00:38:23.570
The kernel is going to reclaim
resources to save battery power

00:38:23.640 --> 00:38:26.300
and to make user experience better.

00:38:26.320 --> 00:38:29.400
At some point, though,
your code is going to

00:38:29.400 --> 00:38:31.090
start running again.

00:38:31.520 --> 00:38:33.740
and you haven't gotten a callback yet.

00:38:33.870 --> 00:38:37.430
The callback happens some point
after your code starts running,

00:38:37.450 --> 00:38:37.700
right?

00:38:37.700 --> 00:38:40.600
Otherwise you can't get the callback
unless you're actually running.

00:38:40.730 --> 00:38:46.200
So the important thing to take away
here is that you need to handle errors.

00:38:46.230 --> 00:38:46.640
When?

00:38:46.890 --> 00:38:49.240
When do you need to handle errors?

00:38:49.370 --> 00:38:53.300
Starting from the time that you
actually did enter the background.

00:38:53.400 --> 00:38:56.140
You have no idea when your
application is actually going to stop

00:38:56.530 --> 00:38:59.700
running because your notification
was at the beginning here.

00:38:59.830 --> 00:39:03.970
Any time after that is when you want
to deal with the aftermath of canceled

00:39:03.970 --> 00:39:06.800
Bonjour operations and reclaimed sockets.

00:39:06.930 --> 00:39:09.590
This is going to lead to
much better user experience.

00:39:09.710 --> 00:39:13.180
Applications tend to get
this wrong because they don't

00:39:13.250 --> 00:39:17.870
understand that application did
enter background is the call.

00:39:17.980 --> 00:39:21.550
That's what tells you this
is maybe going to happen.

00:39:21.660 --> 00:39:24.250
It might not always happen
depending on how long your

00:39:24.250 --> 00:39:29.310
application was in the background,
but you have to deal with errors.

00:39:29.930 --> 00:39:34.570
So at any time following that callback,
all of your Bonjour operations and

00:39:34.660 --> 00:39:37.400
other networking may become broken.

00:39:37.400 --> 00:39:41.180
Your registrations might be gone,
your discovery may have stopped.

00:39:41.180 --> 00:39:42.120
And a little suggestion.

00:39:42.120 --> 00:39:44.530
If you were browsing,
you had your browse UI up for the

00:39:44.530 --> 00:39:47.650
user to actually select something.

00:39:48.380 --> 00:39:52.300
If the browse was terminated,
then the user had probably

00:39:52.340 --> 00:39:55.900
switched out of your app for
a non-trivial amount of time.

00:39:55.990 --> 00:39:58.190
So at that point,
you might want to actually

00:39:58.190 --> 00:40:02.460
dismiss that browse dialog,
and when the user comes back to your app,

00:40:02.740 --> 00:40:05.570
bring the UI back up again.

00:40:05.880 --> 00:40:09.960
If you hadn't been gone that long,
then keep the browse UI up, right?

00:40:09.960 --> 00:40:12.580
Because maybe they switched
out and switched back again.

00:40:12.930 --> 00:40:16.440
There's a really good tech note,
tech note 2277 on

00:40:16.450 --> 00:40:17.500
networking and multitasking.

00:40:17.500 --> 00:40:19.880
I can't really recommend this one enough.

00:40:19.930 --> 00:40:24.250
It's a really good article on more
of the intricate details about this.

00:40:25.290 --> 00:40:29.370
So what's going to happen
if your browse was canceled?

00:40:29.530 --> 00:40:35.690
You're going to get this did not search
callback from your NSNet service browser.

00:40:37.030 --> 00:40:40.380
Another good tip, asynchronous.

00:40:40.380 --> 00:40:43.340
This one I really, I've talked about it a
couple times already,

00:40:43.340 --> 00:40:45.220
networking is hard.

00:40:45.220 --> 00:40:46.920
Let me give you an example.

00:40:47.010 --> 00:40:50.500
Blocking calls are so bad
you will get jettisoned.

00:40:50.960 --> 00:40:54.560
The DNS timeout on iOS is 30 seconds.

00:40:54.570 --> 00:40:58.640
The watchdog timer that
kills your app is 20 seconds.

00:40:58.640 --> 00:41:01.300
So what happens if you block
your main thread for 30 seconds?

00:41:01.410 --> 00:41:03.300
Well, at 20 seconds, you get jettisoned.

00:41:03.370 --> 00:41:05.790
That's bad user experience.

00:41:05.890 --> 00:41:08.200
Make sure that you use
asynchronous calls.

00:41:09.500 --> 00:41:11.820
The NS APIs,
and especially Grand Central Dispatch,

00:41:11.820 --> 00:41:13.000
are excellent for this.

00:41:13.000 --> 00:41:16.300
There's a session on Friday about
Grand Central Dispatch blocks

00:41:16.320 --> 00:41:17.620
and some other type code.

00:41:17.840 --> 00:41:19.200
It's a great programming model.

00:41:19.200 --> 00:41:20.500
I absolutely love GCD.

00:41:20.500 --> 00:41:22.500
I really think it's the best
thing since sliced bread.

00:41:22.500 --> 00:41:23.260
It's excellent.

00:41:23.260 --> 00:41:28.430
And it's a good way to do networking
because everything is asynchronous.

00:41:28.610 --> 00:41:32.580
Another couple things to talk about
are make sure you use live dynamic UI.

00:41:32.690 --> 00:41:35.370
Again, do we have a flashlight?

00:41:35.510 --> 00:41:35.910
Ten seconds?

00:41:36.020 --> 00:41:36.420
No.

00:41:36.540 --> 00:41:38.140
We don't have a flashlight
for ten seconds.

00:41:38.250 --> 00:41:40.390
You have a live dynamic UI.

00:41:40.690 --> 00:41:42.940
There's no need for a refresh button.

00:41:43.050 --> 00:41:45.500
But make sure you consider
your user experience.

00:41:45.500 --> 00:41:48.700
Make sure that they understand
that this is a live UI.

00:41:48.800 --> 00:41:49.740
Right?

00:41:49.790 --> 00:41:52.780
That's going to be key
for your user experience.

00:41:52.780 --> 00:41:56.590
It is a live UI, so make sure that your
users understand it.

00:41:56.960 --> 00:41:59.060
Also, don't do open-ended browsing.

00:41:59.120 --> 00:42:00.900
Don't keep browsing in the background.

00:42:00.930 --> 00:42:03.330
Don't browse while the user
isn't actively going to select

00:42:03.360 --> 00:42:04.790
one of those service instances.

00:42:04.920 --> 00:42:05.720
There's no need to.

00:42:05.910 --> 00:42:08.900
It puts packets on the network that
don't actually need to be there.

00:42:09.220 --> 00:42:13.900
Also, make sure that you stop
browsing when that UI goes away.

00:42:13.900 --> 00:42:18.520
That actually was a bug in some code that
I found recently where we would destroy

00:42:18.590 --> 00:42:22.900
the NSView object that was showing
this thing and it was still browsing.

00:42:22.990 --> 00:42:26.890
And that wasn't good.

00:42:26.900 --> 00:42:29.340
Make sure that you clean up
your browse when your user

00:42:29.340 --> 00:42:30.810
is no longer seeing that UI.

00:42:31.960 --> 00:42:33.520
This one's very important.

00:42:33.590 --> 00:42:37.890
Resolve and connect only to the
service that your user chooses.

00:42:38.080 --> 00:42:39.800
Don't connect to every service.

00:42:39.800 --> 00:42:42.800
It's better described graphically.

00:42:42.800 --> 00:42:47.940
So you can think of Bonjour services
in a particular type as

00:42:47.940 --> 00:42:49.800
being a table on the network,
right?

00:42:49.910 --> 00:42:53.040
There's a bunch of application
service instances out there for,

00:42:53.060 --> 00:42:55.800
say, your mood ring service
or a printing service.

00:42:55.800 --> 00:42:59.240
When you browse,
you get a little bit of information

00:42:59.630 --> 00:43:01.740
about all of the services,
right?

00:43:01.860 --> 00:43:03.730
The name.

00:43:03.770 --> 00:43:07.610
When you resolve,
you get a lot of information

00:43:07.610 --> 00:43:09.460
about one service.

00:43:09.490 --> 00:43:11.390
Notice that we didn't have
to fill in the whole table.

00:43:11.500 --> 00:43:14.260
If you were to actually
resolve everything you got

00:43:14.310 --> 00:43:16.860
in the browse callback,
you would fill in the whole table.

00:43:16.860 --> 00:43:18.840
That's not efficient on the network,
right?

00:43:18.870 --> 00:43:20.110
It's going to be bad for battery life.

00:43:20.270 --> 00:43:22.770
It's going to be bad for
your user experience.

00:43:24.270 --> 00:43:25.960
So what about saving services you found?

00:43:25.980 --> 00:43:30.500
Again,
if you're using the kind of MO where

00:43:30.570 --> 00:43:35.170
your user's going to select an instance
once and then connect that instance

00:43:35.170 --> 00:43:38.030
multiple times for multiple implications,
what are you going to want to store?

00:43:38.040 --> 00:43:40.800
Well, as Stuart said before,
you're not going to want

00:43:40.800 --> 00:43:42.560
to store the IP address,
right?

00:43:42.560 --> 00:43:44.440
IP addresses can change.

00:43:44.440 --> 00:43:47.190
You're also not going to want to
store the port number because your

00:43:47.290 --> 00:43:50.180
port numbers will change because
hopefully every time your server starts,

00:43:50.250 --> 00:43:52.320
you're asking the kernel for
an arbitrary port number,

00:43:52.320 --> 00:43:53.650
so don't store the port number.

00:43:54.200 --> 00:43:56.520
Don't even save the host name
in the port number because the

00:43:56.520 --> 00:43:58.020
host name can actually change.

00:43:58.020 --> 00:44:01.260
What identifies the service
is the service name,

00:44:01.260 --> 00:44:05.710
type, and domain that Stuart talked
about a little bit earlier.

00:44:05.720 --> 00:44:08.130
So the right way is late binding, right?

00:44:08.130 --> 00:44:12.020
It doesn't matter what the IP address
is until you actually need it.

00:44:12.020 --> 00:44:16.060
It doesn't matter what the port
number is until you actually need it.

00:44:16.200 --> 00:44:18.480
The service is identified by
the three-tuple of the name,

00:44:18.560 --> 00:44:19.180
type, domain.

00:44:19.240 --> 00:44:22.410
That's what you're going to want to save,
and that's what you're going to want to

00:44:22.440 --> 00:44:27.490
put into your... ...NSNetService object
to actually get the NSInputStream,

00:44:27.490 --> 00:44:30.530
OutputStream, put it on your run loop,
and open it.

00:44:33.460 --> 00:44:36.280
So for some more information,
we have a couple of evangelists that

00:44:36.280 --> 00:44:38.860
will be happy to answer your questions.

00:44:39.000 --> 00:44:42.630
There's some good documentation
on the Bonjour developer web page.

00:44:42.640 --> 00:44:44.400
There's a couple of samples out there.

00:44:44.400 --> 00:44:48.620
A new sample since last year's WWDC is
something called Remote Currency.

00:44:48.720 --> 00:44:51.160
It's a great sample to
deal with networking.

00:44:51.160 --> 00:44:54.190
Of course,
there's always the developer forms.

00:44:55.030 --> 00:44:57.190
There's the Networking
Best Practices section,

00:44:57.190 --> 00:44:59.400
which was actually just
before this one in this room.

00:44:59.530 --> 00:45:04.290
So when the sessions come out on podcast,
that's an excellent

00:45:04.290 --> 00:45:06.900
session to go back and see.

00:45:06.920 --> 00:45:11.400
It talks about intricacies of TCP and
how networking works and how networking

00:45:11.420 --> 00:45:14.540
is hard to do and make sure that
you know about the APIs that will

00:45:14.540 --> 00:45:16.300
make your user experience better.

00:45:16.420 --> 00:45:21.060
There's also the GCD session on
Friday in Pacific Heights at 9:00.

00:45:21.200 --> 00:45:22.930
So in summary,

00:45:23.120 --> 00:45:25.660
Networking is hard, right?

00:45:25.770 --> 00:45:28.290
Networking is not easy to do.

00:45:28.390 --> 00:45:30.550
Bonjour makes it easier.

00:45:30.660 --> 00:45:32.350
Your UI should update live.

00:45:32.360 --> 00:45:33.770
You don't need a refresh button.

00:45:33.860 --> 00:45:35.990
You definitely don't need a flashlight.

00:45:36.130 --> 00:45:37.230
Use late binding.

00:45:37.240 --> 00:45:40.600
Your name type domain tuple is what
you want to store if you're going to be

00:45:40.600 --> 00:45:43.390
storing information about the service.

00:45:43.650 --> 00:45:47.450
After receiving application
data in your background,

00:45:47.450 --> 00:45:50.040
expect and handle errors, right?

00:45:50.040 --> 00:45:52.160
And make sure that you
register your service types.

00:45:52.160 --> 00:45:53.160
It's free.

00:45:53.190 --> 00:45:53.760
It's easy.

00:45:53.760 --> 00:45:56.160
It will make sure that you don't
conflict with other people.

00:45:56.160 --> 00:45:58.890
Thank you very much.
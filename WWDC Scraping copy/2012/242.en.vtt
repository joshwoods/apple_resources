WEBVTT

00:00:10.080 --> 00:00:13.240
My name is Morgan Grainger,
and I'm a software engineer on

00:00:13.240 --> 00:00:15.120
the iOS Apps and Frameworks team.

00:00:15.190 --> 00:00:20.140
And I'm delighted to be here to give
you the tools that you can use to create

00:00:20.230 --> 00:00:21.870
better experiences for your users.

00:00:21.960 --> 00:00:25.080
Our goal today is to help you.

00:00:25.190 --> 00:00:28.030
So to do that,
we're going to cover a large

00:00:28.090 --> 00:00:30.360
swath of different topics.

00:00:30.480 --> 00:00:33.920
First of all, we're going to try and give
you the basis that you need to

00:00:34.010 --> 00:00:38.120
understand why memory issues occur
and what you can do about it.

00:00:38.170 --> 00:00:40.360
We're going to talk
about why memory matters.

00:00:40.420 --> 00:00:44.270
Why does it make such a
huge impact on your users?

00:00:44.520 --> 00:00:48.100
Then we're going to get detailed
and kind of show you exactly

00:00:48.100 --> 00:00:49.900
how iOS deals with memory.

00:00:49.970 --> 00:00:52.510
And we're specifically going to
talk about what happens when the

00:00:52.510 --> 00:00:55.310
system runs under memory pressure.

00:00:55.500 --> 00:01:11.000
[Transcript missing]

00:01:11.850 --> 00:01:14.310
So, why is memory such a big deal?

00:01:14.320 --> 00:01:21.020
Memory is such a big deal because our
devices are immersive experiences.

00:01:21.020 --> 00:01:22.860
They create these immersive experiences.

00:01:22.890 --> 00:01:25.620
The user is in your application.

00:01:25.650 --> 00:01:30.280
They're focused on the task that
they're trying to accomplish.

00:01:30.320 --> 00:01:32.710
And in the worst case,
memory problems can manifest

00:01:32.840 --> 00:01:36.560
themselves to your user as crashes.

00:01:36.560 --> 00:01:39.840
And that is pretty much the
worst experience possible.

00:01:39.840 --> 00:01:41.580
It takes the user out
of what they're doing,

00:01:41.630 --> 00:01:44.520
puts them in a whole new context
that they were not expecting,

00:01:44.540 --> 00:01:46.960
and then they have to start again.

00:01:47.170 --> 00:01:52.040
And while that may be the worst case,
users also expect to be able

00:01:52.040 --> 00:01:53.900
to multitask with our devices.

00:01:53.900 --> 00:01:55.780
And if they're switching back
to your application and all you

00:01:55.780 --> 00:01:59.260
have to show them is a loading
spinner because your application

00:01:59.360 --> 00:02:04.010
was terminated in the background,
that's also a very poor user experience.

00:02:04.200 --> 00:02:06.800
Ultimately,
memory matters because it has a

00:02:06.800 --> 00:02:11.100
direct correlation to what your
users see and what they experience.

00:02:11.100 --> 00:02:13.100
And this is a very real problem.

00:02:13.100 --> 00:02:16.100
You see in App Store reviews,
we see this in feedback from customers.

00:02:16.100 --> 00:02:19.480
this is a very common complaint.

00:02:20.070 --> 00:02:23.280
Now, it's tempting to think that
the march of time is going

00:02:23.280 --> 00:02:24.760
to take care of this problem.

00:02:24.810 --> 00:02:27.120
You know,
if you look at the original iPhone or the

00:02:27.120 --> 00:02:31.380
iPhone 3G with its 128 megs of memory,
and you look at what we've

00:02:31.380 --> 00:02:34.520
accomplished over time,
each device has more and more memory.

00:02:34.600 --> 00:02:39.240
And the new iPad actually has a
full gigabyte of memory available.

00:02:39.320 --> 00:02:40.950
And so it's tempting to think, well,
you know, this may have been a

00:02:40.950 --> 00:02:44.960
problem at the beginning,
but now is it such a big deal?

00:02:45.020 --> 00:02:47.560
And the answer is that yes,
it is a big deal.

00:02:47.560 --> 00:02:51.150
This is an iPad 2,
and it's a beautiful device,

00:02:51.150 --> 00:02:52.880
and users did a lot of things with it.

00:02:52.950 --> 00:02:56.120
But now with the new iPad,
you're essentially having to do

00:02:56.120 --> 00:03:00.000
the drawing work of four iPad 2s.

00:03:00.120 --> 00:03:03.080
So users are going to expect
more out of your applications.

00:03:03.150 --> 00:03:06.880
As hardware gets more powerful,
as capabilities become greater,

00:03:06.930 --> 00:03:11.660
users are accordingly going to
expect more out of your applications.

00:03:11.710 --> 00:03:15.640
And the applications that deal with these
constraints most effectively are the ones

00:03:15.640 --> 00:03:17.560
that users are going to love the most.

00:03:17.560 --> 00:03:21.110
So memory matters.

00:03:22.260 --> 00:03:26.000
Next, I'm going to talk about
how memory works on iOS.

00:03:26.340 --> 00:03:30.450
We're going to take you behind the
scenes and talk about exactly what

00:03:30.460 --> 00:03:33.200
happens at a memory level in the system.

00:03:33.200 --> 00:03:36.200
And so I'm going to cover
a lot of things today,

00:03:36.200 --> 00:03:41.200
but what I really hope you come away with
is this idea of what exactly this means.

00:03:41.200 --> 00:03:42.360
This is a low memory log.

00:03:42.360 --> 00:03:44.170
You may have seen it in iTunes Connect.

00:03:44.220 --> 00:03:48.520
And ultimately, these are generated when
your app is terminated in the

00:03:48.530 --> 00:03:50.130
foreground because of low memory.

00:03:50.200 --> 00:03:52.640
So we're going to talk about
what a page is and how you

00:03:52.740 --> 00:03:56.350
can reduce this number here,
this "our pages" number,

00:03:56.350 --> 00:03:59.510
so that your application
stays running longer.

00:03:59.690 --> 00:04:03.390
So there are three main things that
I'm going to cover in this section.

00:04:03.490 --> 00:04:05.310
First of all,
we're going to talk about how memory

00:04:05.310 --> 00:04:08.300
is allocated and managed on iOS.

00:04:08.440 --> 00:04:11.900
Secondly, we're going to talk about what
types of memory use matter.

00:04:11.960 --> 00:04:15.100
It turns out that not all
allocations are created equal,

00:04:15.150 --> 00:04:17.900
and there's a particular distinction
between clean and dirty memory

00:04:18.330 --> 00:04:20.400
that we're going to discuss.

00:04:20.440 --> 00:04:23.060
And then third of all,
we're going to talk about what happens

00:04:23.120 --> 00:04:27.700
when the system runs low on memory
and how it deals with that situation.

00:04:27.870 --> 00:04:28.900
So let's start.

00:04:29.080 --> 00:04:32.200
How is memory allocated
and managed on iOS?

00:04:32.330 --> 00:04:36.700
And to start off at a basic level,
one key thing to note is that

00:04:36.700 --> 00:04:38.730
memory is a per-process thing.

00:04:38.880 --> 00:04:42.200
If you've got a pointer in your process,
in your address space,

00:04:42.340 --> 00:04:46.350
that is different from that same memory
address in a different address space,

00:04:46.370 --> 00:04:48.400
in a different application.

00:04:48.530 --> 00:04:51.530
Memory is a per-application thing.

00:04:51.800 --> 00:04:54.070
Now,
one thing you'll notice is that the range

00:04:54.070 --> 00:04:57.400
of pointer addresses in your process,
in your application,

00:04:57.400 --> 00:04:59.390
is actually quite large.

00:04:59.460 --> 00:05:02.900
A pointer is 32 bits,
and that's actually 4 gigabytes,

00:05:02.960 --> 00:05:05.370
which is a lot of space.

00:05:05.470 --> 00:05:08.850
In fact, that's more space than there is
physical memory available on any

00:05:08.850 --> 00:05:11.400
device that we've ever shipped.

00:05:11.540 --> 00:05:14.400
And the question might be,
how can that be?

00:05:14.400 --> 00:05:16.560
How can we have, you know,
logically make this amount of

00:05:16.640 --> 00:05:20.900
memory available per process
without physically having that much?

00:05:20.900 --> 00:05:22.900
And the answer is virtual memory.

00:05:22.900 --> 00:05:25.090
We take all of the memory
available in the system,

00:05:25.260 --> 00:05:29.530
divide it up into 4 kilobyte chunks,
and then not all of the memory that your

00:05:29.530 --> 00:05:35.100
application can access is actually stored
in physical memory at the same time.

00:05:35.100 --> 00:05:38.100
So let's dive a little deeper into this.

00:05:38.150 --> 00:05:42.010
So this is kind of just a very
simplified view of physical memory

00:05:42.120 --> 00:05:44.100
is divided into 4 kilobyte pages.

00:05:44.100 --> 00:05:47.100
But you're all the way up
at your applications level.

00:05:47.100 --> 00:05:50.100
And what you're doing is
you are allocating objects.

00:05:50.210 --> 00:05:51.100
You're creating new objects.

00:05:51.100 --> 00:05:53.100
You may be calling malloc directly.

00:05:53.100 --> 00:05:56.100
But these are ultimately allocations.

00:05:56.410 --> 00:05:56.800
Now, it would be really interesting
to see if you could do this.

00:05:56.800 --> 00:05:59.330
It would be really expensive
to make a system call into the

00:05:59.330 --> 00:06:02.790
kernel every time you needed,
you know, a few bytes of memory.

00:06:03.010 --> 00:06:07.190
So what happens is that these
allocations end up getting carved

00:06:07.190 --> 00:06:10.800
out of larger chunks of memory
that are allocated as necessary.

00:06:10.910 --> 00:06:13.800
So for example,
when you first start allocating memory,

00:06:13.800 --> 00:06:16.800
the malloc library may
allocate a 1 megabyte chunk,

00:06:16.800 --> 00:06:19.120
and then as you ask for
little bits of memory,

00:06:19.350 --> 00:06:23.720
it'll carve pieces out for those objects.

00:06:24.230 --> 00:06:28.130
So then what happens in the kernel is it
takes these virtual memory objects and

00:06:28.130 --> 00:06:30.240
then it maps them to physical memory.

00:06:30.240 --> 00:06:34.440
It takes the pages that are used and
then as your application needs them,

00:06:34.470 --> 00:06:37.440
it brings them in into physical memory.

00:06:38.000 --> 00:06:40.740
Now, there's one very important
thing to note here.

00:06:40.850 --> 00:06:43.620
As I mentioned,
when you think of your application,

00:06:43.620 --> 00:06:47.120
you think of heap memory,
the things that you're allocating.

00:06:47.240 --> 00:06:50.480
But the reality is that that
is just part of the story,

00:06:50.670 --> 00:06:53.710
just the tip of the iceberg,
as we might say.

00:06:53.910 --> 00:06:58.540
The answer is that there is a
lot there under the surface.

00:06:58.680 --> 00:07:00.620
Question is, what are these other things?

00:07:00.780 --> 00:07:03.940
What is filling up your address
space and using your memory?

00:07:04.040 --> 00:07:06.500
So in addition to this heap
memory that you're familiar with,

00:07:06.650 --> 00:07:09.360
there are also things like the
code for your application and

00:07:09.360 --> 00:07:11.410
the code for frameworks and
libraries that you're linking,

00:07:11.980 --> 00:07:15.770
global variables and statics,
your thread stacks,

00:07:15.900 --> 00:07:19.430
if you have any local variables
or you've got registered data

00:07:19.440 --> 00:07:23.520
that's saved onto the stack,
image data, decompressed image data,

00:07:23.660 --> 00:07:26.000
CA layer backing stores,
the contents of your layers.

00:07:26.140 --> 00:07:28.140
If you're using some sort of database,
there's probably a cache.

00:07:28.140 --> 00:07:32.140
That is in use to speed up accesses.

00:07:32.280 --> 00:07:35.620
And there's actually additional
memory being used outside your

00:07:35.920 --> 00:07:37.990
application in the render server.

00:07:39.200 --> 00:07:44.100
So that's kind of the
basics of memory on iOS.

00:07:44.220 --> 00:07:46.390
So what types of memory
use actually matter?

00:07:46.560 --> 00:07:48.680
And again, this is a distinction
between clean and dirty.

00:07:48.680 --> 00:07:52.080
We're going to keep coming back to that,
so keep that in mind.

00:07:52.650 --> 00:07:56.290
And so I want, just for a second,
for you to put yourself in the

00:07:56.290 --> 00:07:59.020
frame of mind of someone who's
designing a system where you're

00:07:59.030 --> 00:08:03.260
trying to manage a limited resource,
and memory is a limited resource.

00:08:03.350 --> 00:08:06.310
And so when the time comes
when it's running out,

00:08:06.470 --> 00:08:07.700
what do you do?

00:08:07.810 --> 00:08:12.060
How can we reclaim more
memory for our needs?

00:08:12.180 --> 00:08:14.340
So one answer,
and this is a very common answer

00:08:14.340 --> 00:08:16.950
that is used in a lot of systems,
is to take stuff,

00:08:16.950 --> 00:08:19.470
the data that's in memory,
and write it out to disk,

00:08:19.540 --> 00:08:22.340
create a swap file and store it there.

00:08:22.340 --> 00:08:25.910
Because of kind of the characteristics
of our devices and our environment,

00:08:26.100 --> 00:08:28.540
that's actually not what happens on iOS.

00:08:28.630 --> 00:08:32.140
We do not page memory out to disk.

00:08:32.230 --> 00:08:33.220
So we can't do that.

00:08:33.290 --> 00:08:34.900
What can we do?

00:08:34.980 --> 00:08:37.740
Well, we can just throw it away.

00:08:37.870 --> 00:08:39.800
And this is, in fact, what happens.

00:08:39.880 --> 00:08:44.140
We take stuff that is in memory,
and we just dump it.

00:08:44.610 --> 00:08:48.500
So that seems problematic,
because what if that was memory

00:08:48.500 --> 00:08:51.090
that your application needed?

00:08:51.840 --> 00:08:53.540
And sometimes that is the case.

00:08:53.680 --> 00:08:57.340
And if the system has no choice
but to get rid of this memory

00:08:57.340 --> 00:09:00.630
that your application depended on,
its only recourse is to

00:09:00.630 --> 00:09:02.540
terminate your application.

00:09:02.690 --> 00:09:05.710
And obviously,
you don't want that to happen.

00:09:05.900 --> 00:09:07.800
So how can you keep it from happening?

00:09:07.830 --> 00:09:12.540
And the answer is in this distinction
between clean memory and dirty memory.

00:09:12.750 --> 00:09:16.140
Clean memory is memory for
which a copy exists on disk.

00:09:16.200 --> 00:09:18.070
So for example,
the code for your application

00:09:18.420 --> 00:09:21.090
is needed in memory to execute,
but there's an exact copy of

00:09:21.090 --> 00:09:22.180
it already present in disk.

00:09:22.180 --> 00:09:25.180
And so if the system is
running low on memory,

00:09:25.270 --> 00:09:28.540
it can just purge that memory
and then bring it in at a later

00:09:28.540 --> 00:09:30.740
time from disk if it needs it.

00:09:30.830 --> 00:09:33.860
Same thing with the code for
any frameworks that you use.

00:09:33.860 --> 00:09:37.020
If you've got memory mapped files,
same deal.

00:09:37.070 --> 00:09:38.900
So then what's dirty?

00:09:38.900 --> 00:09:41.540
The answer is everything else.

00:09:41.600 --> 00:09:44.980
So if you've got heap allocations,
if you've got, say,

00:09:44.980 --> 00:09:47.820
a JPEG that you're displaying on the
screen and needs to be decompressed,

00:09:47.820 --> 00:09:49.880
that decompressed data is dirty.

00:09:49.880 --> 00:09:53.140
These database caches
are going to be dirty.

00:09:53.250 --> 00:09:57.160
So the answer is that
most things are dirty.

00:09:57.400 --> 00:10:01.400
So this is kind of an abstract concept,
and I wanted to help

00:10:01.450 --> 00:10:03.860
make it more concrete,
so we're gonna play a little game show.

00:10:03.970 --> 00:10:05.260
It's called Clean or Dirty.

00:10:05.300 --> 00:10:08.960
There are no prizes,
but hopefully you can follow along.

00:10:09.490 --> 00:10:13.760
So we've got this code snippet here,
and what I want to do is display

00:10:13.760 --> 00:10:17.500
"Welcome to WWDC" in a UI alert view.

00:10:17.620 --> 00:10:21.400
So what I'm doing is I've got an
NSString that I'm creating dynamically

00:10:21.400 --> 00:10:24.800
via NSString string with UTF-8 string.

00:10:24.800 --> 00:10:28.790
And so what this actually does is it
creates a copy of this constant C string

00:10:28.790 --> 00:10:30.550
and creates the NSString from that.

00:10:30.720 --> 00:10:34.800
And the question is,
is this NSString clean or is it dirty?

00:10:34.820 --> 00:10:36.260
The answer is that it's dirty.

00:10:36.450 --> 00:10:38.900
Because we had to make
a copy of this constant,

00:10:39.000 --> 00:10:41.170
this is an object that we
were allocating on the heap,

00:10:41.170 --> 00:10:43.630
and thus it's going to be dirty.

00:10:44.920 --> 00:10:50.400
So let's modify this example a little
bit and just use a constant NSString.

00:10:50.470 --> 00:10:52.800
Is this going to be clean or dirty?

00:10:52.930 --> 00:10:55.340
Now, one interesting thing about
NSString is that they're actually

00:10:55.510 --> 00:10:59.720
stored in the data segment,
but they're stored in a read-only

00:10:59.720 --> 00:11:01.800
portion of the data segment.

00:11:01.960 --> 00:11:04.550
And so what that means is that
since that data isn't written to,

00:11:04.650 --> 00:11:07.260
there's still a copy of it on disk,
and so this will

00:11:07.260 --> 00:11:09.240
actually end up as clean.

00:11:09.590 --> 00:11:11.820
Let's get a little more complicated.

00:11:11.930 --> 00:11:14.460
So here's a function that is
probably inappropriately named.

00:11:14.460 --> 00:11:17.860
It should probably start with new,
but it's allocating some memory,

00:11:17.950 --> 00:11:21.930
and we're just going to allocate a
10-megabyte buffer directly using malloc.

00:11:22.050 --> 00:11:24.530
Is this memory clean or dirty?

00:11:24.930 --> 00:11:28.080
Now one thought might be, well,
it's an allocation in the heap,

00:11:28.140 --> 00:11:32.630
it's going to be dirty,
but one thing that you may know about

00:11:32.630 --> 00:11:36.590
malloc is that the contents of that
memory upon allocation are undefined,

00:11:36.650 --> 00:11:39.430
and so they don't really
have any specified value.

00:11:39.620 --> 00:11:43.680
So there's no need to keep
undefined values in memory.

00:11:43.680 --> 00:11:46.160
So this memory is actually clean.

00:11:46.320 --> 00:11:49.430
However,
as soon as you go and write to it,

00:11:49.540 --> 00:11:52.780
it becomes dirty, because again,
there's no copy of this present on disk.

00:11:52.840 --> 00:11:55.130
There's nowhere to bring it in from.

00:11:55.720 --> 00:11:57.590
Let's do some image examples.

00:11:57.810 --> 00:12:02.650
So here we've got a UI image that we're
creating from an image in our app bundle.

00:12:02.800 --> 00:12:05.880
That's the WWC 2012 logo.

00:12:05.990 --> 00:12:09.780
And it's kind of important to
note that a few things happen

00:12:09.780 --> 00:12:11.140
when you create a UI image.

00:12:11.240 --> 00:12:14.240
So initially, UI image is just kind of a
thin wrapper around a CG image,

00:12:14.240 --> 00:12:16.860
as you may have heard in
the last presentation.

00:12:16.860 --> 00:12:20.170
And then, so in this case,
we've got a JPEG that's backing it.

00:12:20.400 --> 00:12:22.800
So then at the point where we
go and display it on screen,

00:12:22.880 --> 00:12:27.040
that's actually going to get decompressed
and a bitmap is going to be created.

00:12:27.250 --> 00:12:29.160
So is this clean or dirty?

00:12:29.550 --> 00:12:30.900
Well, there are actually a number
of different parts here,

00:12:30.900 --> 00:12:31.040
right?

00:12:31.040 --> 00:12:33.100
We've got our UI image,
we've got our CG image,

00:12:33.100 --> 00:12:34.230
we've got our bitmap.

00:12:34.330 --> 00:12:37.770
But the answer is that actually
all of those things are dirty.

00:12:37.890 --> 00:12:41.390
We had to decompress
the JPEG into a bitmap,

00:12:41.390 --> 00:12:43.270
and that bitmap itself is
not stored anywhere else.

00:12:43.510 --> 00:12:45.960
So this counts as dirty memory.

00:12:46.540 --> 00:12:48.590
And then just one last image example.

00:12:48.650 --> 00:12:50.210
In this case,
we're actually going to go and take

00:12:50.210 --> 00:12:55.420
a snapshot of a view that's on screen
using UI graphics begin image context

00:12:56.070 --> 00:12:57.640
and then see a layer rendering context.

00:12:57.780 --> 00:13:00.370
We're basically taking a view
and we're going to render

00:13:00.560 --> 00:13:01.970
it into this image context.

00:13:02.020 --> 00:13:03.960
And that's going to create a bitmap.

00:13:04.030 --> 00:13:08.160
And then we're going to go and
create a UI image from that.

00:13:08.200 --> 00:13:09.740
So in this case,
there's no file backing it.

00:13:09.740 --> 00:13:12.540
It's just the bitmap.

00:13:12.620 --> 00:13:14.480
Hopefully at this point,
you can see that this is

00:13:14.480 --> 00:13:15.570
going to be dirty as well.

00:13:15.770 --> 00:13:17.340
None of this existed on disk.

00:13:17.380 --> 00:13:21.120
It's just a snapshot that we
took of something on screen.

00:13:21.690 --> 00:13:23.260
So the bottom line of all this,
and this is something

00:13:23.260 --> 00:13:26.410
that I've already said,
is that most app allocations

00:13:26.410 --> 00:13:27.910
are indeed dirty.

00:13:28.010 --> 00:13:32.220
Most things that you do are
going to result in dirty memory.

00:13:33.090 --> 00:13:37.340
So it's really important to look
at all of your memory usage and

00:13:37.450 --> 00:13:39.500
see where you can reduce it.

00:13:39.630 --> 00:13:41.060
So that was number two.

00:13:41.380 --> 00:13:45.000
Number three is what I think
is a really interesting part,

00:13:45.080 --> 00:13:49.600
which is what actually happens
when the system runs low on memory.

00:13:50.360 --> 00:13:53.300
And we've got our nice little
iTunes-style progress bar here.

00:13:53.430 --> 00:13:56.540
And it's helpful to view the
memory available in the system

00:13:56.540 --> 00:14:01.040
in terms of clean memory,
dirty memory, and free memory.

00:14:01.080 --> 00:14:03.760
And this is actually a pretty
normal state of the system.

00:14:03.840 --> 00:14:05.560
At first glance,
it might be a little concerning

00:14:05.670 --> 00:14:08.460
to see so little free memory,
but there's a large

00:14:08.460 --> 00:14:10.540
amount of clean memory,
and if the system needs more,

00:14:10.540 --> 00:14:15.320
it can just evict some of those clean
pages to use them for something else.

00:14:17.340 --> 00:14:18.370
And one model that we have is free
memory is wasted memory because it's

00:14:18.510 --> 00:14:21.680
possible that those pages might be
needed at some point in the future.

00:14:21.750 --> 00:14:24.980
So there's really no
need to throw them away.

00:14:25.070 --> 00:14:28.300
So let's say we launch your application,
and your application is cutting edge.

00:14:28.330 --> 00:14:31.480
It's doing cool new stuff,
and that takes memory.

00:14:31.630 --> 00:14:36.000
So you're going to allocate some objects,
maybe bring in some images,

00:14:36.000 --> 00:14:40.490
display them on the screen,
and that is going to cause your

00:14:40.490 --> 00:14:42.210
amount of dirty memory to go up.

00:14:42.320 --> 00:14:45.340
And by and large,
the system will indeed evict clean pages.

00:14:45.480 --> 00:14:47.700
in order to make room for that.

00:14:48.100 --> 00:14:50.700
However, if your application
continues to allocate memory,

00:14:50.890 --> 00:14:54.880
eventually the system will
run into memory pressure.

00:14:55.000 --> 00:14:59.510
And the definition of memory pressure
that I'm going to use is that the

00:14:59.780 --> 00:15:04.000
amount of time or the rate at which the
system needs to turn over clean pages,

00:15:04.000 --> 00:15:05.960
you know, it's bringing in a page,
it's using it,

00:15:06.100 --> 00:15:09.130
and then it needs to evict it
again to bring in something else,

00:15:09.160 --> 00:15:11.000
gets faster and faster and faster.

00:15:11.000 --> 00:15:13.000
And that turns into a
performance problem.

00:15:13.000 --> 00:15:16.000
You know, it's kind of a
manifestation of thrashing.

00:15:16.000 --> 00:15:17.960
So at this point,
the system needs to recover

00:15:17.960 --> 00:15:20.980
some memory in order to restore
performance and keep operating.

00:15:21.000 --> 00:15:23.220
And so what it's going to
do is it's going to go and

00:15:23.220 --> 00:15:25.000
terminate some background apps.

00:15:25.000 --> 00:15:27.870
At that point,
all of the dirty memory from those

00:15:27.870 --> 00:15:33.000
background apps is no longer useful,
and so it ends up in the free column.

00:15:33.030 --> 00:15:37.340
And then the rest of it
is primarily your memory.

00:15:37.550 --> 00:15:39.460
And then,
kind of as you go and you continue

00:15:39.460 --> 00:15:42.060
and you bring in more pages,
the system will actually move

00:15:42.060 --> 00:15:44.670
that free memory back into clean.

00:15:44.760 --> 00:15:47.800
And we're kind of back
to a normal state again.

00:15:48.510 --> 00:15:52.440
So when I do this example,
I talked about your app being the

00:15:52.440 --> 00:15:56.740
one in the foreground and we're
terminating other people's applications.

00:15:56.820 --> 00:16:00.600
But your application could just as
easily be in the situation of being

00:16:00.600 --> 00:16:03.240
the one that's about to be terminated.

00:16:03.340 --> 00:16:04.760
So how do you avoid that?

00:16:05.100 --> 00:16:08.740
We have our primary mechanism
for that is in memory warnings.

00:16:08.800 --> 00:16:11.200
And they are a fact of life,
they are going to happen,

00:16:11.200 --> 00:16:15.080
and so the question is,
how will your application respond?

00:16:15.520 --> 00:16:18.920
This is your last chance to preserve
the user's experience before your

00:16:18.920 --> 00:16:21.180
application is potentially terminated.

00:16:21.230 --> 00:16:24.280
And that's a serious event,
and it's something that

00:16:24.610 --> 00:16:27.140
it's vital to respond to.

00:16:27.370 --> 00:16:29.120
So the first thing is to make
sure that your application is

00:16:29.310 --> 00:16:31.340
even in a position to respond.

00:16:31.450 --> 00:16:35.240
So these notifications are delivered
on the main thread of your application.

00:16:35.450 --> 00:16:39.600
So if you're kind of running and you're
doing something on your main thread,

00:16:39.600 --> 00:16:43.440
you're allocating a lot of memory,
you may be blocking your main thread,

00:16:43.440 --> 00:16:45.620
and so these notifications never
actually get through to you,

00:16:45.620 --> 00:16:48.670
and you may never have a
chance to respond to them.

00:16:48.940 --> 00:16:53.080
The other thing is to avoid large,
rapid allocations.

00:16:53.080 --> 00:16:55.600
The system will send
you a memory warning,

00:16:55.680 --> 00:16:58.610
but if you're allocating memory
so quickly that it is forced

00:16:58.760 --> 00:17:01.920
to make a decision before you
have a chance to free memory,

00:17:02.030 --> 00:17:04.520
then it may have no choice to
terminate your application,

00:17:04.630 --> 00:17:06.970
even though you could have freed
some of that memory if you'd

00:17:07.020 --> 00:17:08.820
gotten the notification in time.

00:17:08.930 --> 00:17:12.060
So by allocating memory
gradually instead of all at once,

00:17:12.180 --> 00:17:15.290
you avoid forcing the system's hand.

00:17:15.650 --> 00:17:20.640
So, sorry, one other thing is that if
your application is in the

00:17:21.270 --> 00:17:24.230
background and it is suspended,
it actually won't be resumed in

00:17:24.230 --> 00:17:26.600
order to handle these notifications.

00:17:26.770 --> 00:17:29.930
So if you're in the background,
it's wise to actually release

00:17:30.010 --> 00:17:34.380
non-critical memory in your
application did enter background

00:17:34.380 --> 00:17:37.160
UI application delegate callback.

00:17:38.290 --> 00:17:40.660
So how do you handle these warnings?

00:17:40.690 --> 00:17:43.860
The answer is that you want to free
as much memory as possible without

00:17:44.080 --> 00:17:46.080
sacrificing the user experience.

00:17:46.110 --> 00:17:47.420
And those are at odds.

00:17:47.440 --> 00:17:49.620
And that's going to depend
on your particular use case.

00:17:49.630 --> 00:17:53.490
You need to decide what is acceptable,
what is that trade-off.

00:17:53.970 --> 00:17:57.290
We provide a lot of different
points at which you can receive

00:17:57.290 --> 00:17:58.740
a memory warning and handle it.

00:17:58.880 --> 00:18:01.300
First of all,
there's a notification posted to

00:18:01.310 --> 00:18:03.540
the default notification center.

00:18:03.640 --> 00:18:06.940
UI application did receive
memory warning notification.

00:18:07.040 --> 00:18:10.700
We invoke a method on your
UI application delegate.

00:18:10.800 --> 00:18:14.230
And then each of your view controllers
will also have the did receive memory

00:18:14.240 --> 00:18:16.810
warning method invoked on them.

00:18:17.300 --> 00:18:19.050
Now,
one other mechanism that you may know

00:18:19.050 --> 00:18:24.200
of from past years to release memory
in situations that are no longer needed

00:18:24.200 --> 00:18:26.880
is UIViewControllerViewDidUnload.

00:18:26.970 --> 00:18:30.140
In iOS 6, we're actually no longer
calling this method.

00:18:30.250 --> 00:18:33.450
And the reason is that iOS has
gotten much better about purging

00:18:33.450 --> 00:18:37.260
memory associated with your
views when they're not on screen.

00:18:37.360 --> 00:18:40.140
This was actually a major source of
bugs where applications were freeing

00:18:40.140 --> 00:18:45.660
memory without necessarily getting
rid of all the references to them.

00:18:45.740 --> 00:18:47.300
So there's actually no
need to do this anymore,

00:18:47.300 --> 00:18:49.810
and we think it will
eliminate a lot of bugs.

00:18:50.010 --> 00:18:55.040
But what that does mean is that if
you were using that as a place to

00:18:55.110 --> 00:18:58.840
release memory that otherwise you might
want to release in a memory warning,

00:18:58.930 --> 00:19:01.230
you'll probably need to adjust.

00:19:02.820 --> 00:19:06.550
So,
this is a question we've gotten a lot:

00:19:06.550 --> 00:19:09.100
How much memory can I use?

00:19:09.100 --> 00:19:13.220
And our answer has always been,
first of all, as little as possible,

00:19:13.300 --> 00:19:16.220
but second of all,
you need to test on each device.

00:19:16.360 --> 00:19:18.560
Our devices have
different characteristics,

00:19:18.610 --> 00:19:21.470
and things like the screen resolution,
things like the amount

00:19:21.470 --> 00:19:24.320
of memory available,
are really going to affect

00:19:24.320 --> 00:19:26.500
how much memory is available.

00:19:26.730 --> 00:19:29.420
So on the new iPad,
we have actually set a limit,

00:19:29.420 --> 00:19:32.290
and the limit is 650 megabytes.

00:19:32.730 --> 00:19:35.680
And we did this to provide certainty
to you so that you know that there

00:19:35.700 --> 00:19:38.510
is some amount of memory that is
likely to be available to your

00:19:38.510 --> 00:19:41.240
application and that you can use.

00:19:41.330 --> 00:19:43.760
If you go over this amount,
the system will terminate

00:19:43.760 --> 00:19:44.950
your application.

00:19:45.150 --> 00:19:48.970
However, that doesn't mean that
the 650 megabytes is free,

00:19:48.970 --> 00:19:50.820
and you should just go
ahead and use it right away.

00:19:50.870 --> 00:19:53.220
At that point, there are going to be
effects in the system.

00:19:53.220 --> 00:19:55.430
It's very likely that some of the
user's background applications

00:19:55.800 --> 00:19:58.740
will be terminated to create memory
for your application and so on.

00:19:58.800 --> 00:20:03.270
So this isn't a free amount,
but it is the maximum that you can use.

00:20:04.010 --> 00:20:04.990
All right, that was a lot of stuff.

00:20:05.150 --> 00:20:06.700
I talked a lot.

00:20:06.700 --> 00:20:08.960
But now I want to get really
practical and kind of show you,

00:20:09.380 --> 00:20:12.950
using our tools,
how you can kind of see some of the

00:20:12.950 --> 00:20:14.500
concepts that I've talked about.

00:20:14.630 --> 00:20:16.940
And so for that,
I'm going to show you a little demo.

00:20:17.060 --> 00:20:19.750
So for this demo,
we're going to use our trusty friend,

00:20:19.860 --> 00:20:21.130
the WWC application.

00:20:21.230 --> 00:20:24.760
And just to make it clear,
these are issues that we have inserted in

00:20:24.760 --> 00:20:27.050
order to demonstrate the concepts here.

00:20:27.270 --> 00:20:29.730
Rest assured that the version of
the app that is running on your

00:20:29.770 --> 00:20:33.300
devices has been thoroughly memory
tested and behaves like a champ.

00:20:33.410 --> 00:20:37.780
So the first thing I'm going
to do is I'm actually going to

00:20:37.780 --> 00:20:40.540
run the application on an iPad.

00:20:40.620 --> 00:20:42.540
I've got my iPad over here.

00:20:42.690 --> 00:20:46.540
And I'm using the profile action,
so this will actually launch instruments.

00:20:46.600 --> 00:20:47.740
Just give it a second here.

00:20:47.790 --> 00:20:49.340
And I'm going to use the
allocations instrument,

00:20:49.340 --> 00:20:51.890
which may be familiar to many of you.

00:20:56.000 --> 00:20:56.800
All right.

00:20:56.910 --> 00:20:59.300
So I'm just going to-- I'll be
coming back to the VM Tracker.

00:20:59.300 --> 00:21:01.870
For now, I'm just going to turn on
automatic snapshot because

00:21:01.870 --> 00:21:03.330
it's a snapshot-based tool.

00:21:03.410 --> 00:21:07.640
And so you'll see that we're gradually--
our memory usage is gradually increasing.

00:21:07.750 --> 00:21:11.440
So what I'm going to do on the iPad
is I'm in the photos view here.

00:21:11.520 --> 00:21:14.830
And so I'm just going to go and
start swiping through some photos,

00:21:14.830 --> 00:21:16.730
just so you can see that.

00:21:17.940 --> 00:21:22.440
And so now I'm actually going to
go back to my two instruments here.

00:21:22.500 --> 00:21:26.280
And you can see that, you know,
kind of there are...

00:21:27.170 --> 00:21:30.150
Maybe a few spikes, but in general,
the memory usage is remaining pretty

00:21:30.150 --> 00:21:33.940
flat as I move through these photos here.

00:21:34.110 --> 00:21:35.910
And so if you look at the
allocations instrument alone,

00:21:35.910 --> 00:21:38.450
you might conclude that, OK,
this isn't actually

00:21:38.450 --> 00:21:40.200
using that much memory.

00:21:40.730 --> 00:21:43.500
However,
if you look at the VM tracker here,

00:21:43.540 --> 00:21:47.640
which is an instrument that maybe doesn't
get as much attention as it should,

00:21:47.760 --> 00:21:52.630
it's actually telling a different story.

00:21:52.630 --> 00:21:52.630
So if I just...

00:21:53.800 --> 00:21:55.700
So, if I just kind of look here and drag,
you can see that my

00:21:55.700 --> 00:21:58.200
allocations have kind of,
you know,

00:21:58.220 --> 00:21:59.880
they have really not changed that much.

00:21:59.910 --> 00:22:02.060
In fact,
they were kind of at 7 megabytes and

00:22:02.060 --> 00:22:04.200
they ended up at maybe 5 and a half.

00:22:04.330 --> 00:22:06.560
Just let me zoom in here to show.

00:22:08.610 --> 00:22:10.970
Daniel Delwood:
But my VM tracker that shows my

00:22:10.970 --> 00:22:14.320
dirty memory shows that I went
from 66 megabytes of dirty memory

00:22:14.490 --> 00:22:16.590
and I'm up to 244 megabytes.

00:22:16.590 --> 00:22:17.780
So that's a big difference.

00:22:17.800 --> 00:22:19.200
If you just looked at
the allocations tool,

00:22:19.200 --> 00:22:22.200
you might conclude that things were fine.

00:22:23.870 --> 00:22:26.990
Daniel Delwood: But VM tracker is telling
you a different story.

00:22:27.200 --> 00:22:29.630
It's showing you memory that
is beyond your heap that

00:22:29.630 --> 00:22:31.390
is stored in other regions.

00:22:31.840 --> 00:22:34.160
Now, if you kind of look at
the VM tracker here,

00:22:34.310 --> 00:22:37.200
you can kind of look at
the different regions.

00:22:37.350 --> 00:22:39.110
And again,
it's this dirty amount here that

00:22:39.110 --> 00:22:40.360
we really want to emphasize.

00:22:40.630 --> 00:22:44.170
That's really what's most
important to look at here.

00:22:44.740 --> 00:22:47.080
Now I'm actually going
to go and stop this.

00:22:47.080 --> 00:22:52.530
I'm going to rerun it on the
simulator just to demonstrate

00:22:52.840 --> 00:22:55.460
what happens in this application
when we simulate a memory warning.

00:22:55.460 --> 00:22:58.540
So I'm going to run the
allocations instrument again.

00:22:58.720 --> 00:23:01.620
And our application is launching.

00:23:03.010 --> 00:23:06.500
And I'm going to go to the Photos tab.

00:23:06.540 --> 00:23:10.500
And let me just turn on
my VM tracker here again.

00:23:10.570 --> 00:23:14.930
And I'm going to do the same
thing and swipe through my photos.

00:23:20.430 --> 00:23:22.700
And you'll see essentially
the same effect over time.

00:23:22.730 --> 00:23:24.140
It's only snapshotting
every three seconds,

00:23:24.140 --> 00:23:26.200
so it takes a little
time for it to show up.

00:23:26.230 --> 00:23:32.300
But my allocations are essentially flat,
but my dirty memory is steadily rising.

00:23:32.400 --> 00:23:38.700
Now, what I would hope is that I've
implemented a response to memory warning,

00:23:38.740 --> 00:23:41.100
so that if the system
does run low on memory,

00:23:41.150 --> 00:23:42.240
I can respond.

00:23:42.390 --> 00:23:44.020
And so in the simulator,
you can simulate a memory

00:23:44.020 --> 00:23:45.380
warning under the hardware menu.

00:23:45.500 --> 00:23:49.190
So I'm going to do that.

00:23:50.860 --> 00:23:52.750
Unfortunately, okay,
that did make a difference

00:23:52.750 --> 00:23:53.630
in my dirty memory.

00:23:53.630 --> 00:23:56.870
That's unexpected.

00:23:57.080 --> 00:24:00.930
What I was expecting to see was that
there was very little difference

00:24:01.080 --> 00:24:03.020
in the amount of memory being used.

00:24:03.170 --> 00:24:06.080
So let's examine why that is.

00:24:06.650 --> 00:24:10.900
So the view controller that is
responsible for this is actually

00:24:10.960 --> 00:24:15.680
called the WC Photos View Controller.

00:24:17.620 --> 00:24:20.530
All right, and you can see here that I've
left a to-do for myself saying

00:24:20.540 --> 00:24:22.940
I need to handle a memory warning.

00:24:23.060 --> 00:24:27.660
So what I'm going to do is I'm actually
going to go and very quickly implement

00:24:27.660 --> 00:24:31.900
a handler for these memory warnings.

00:24:31.900 --> 00:24:34.560
And look at that, that's magic.

00:24:34.560 --> 00:24:36.950
And so all I'm going to do is I'm
going to go through my list of photos

00:24:37.300 --> 00:24:42.500
and set the UI image associated
with each of those photos to be nil,

00:24:42.580 --> 00:24:46.640
which, since this is an Arc application,
will cause them to be released.

00:24:46.740 --> 00:24:50.390
So let's profile this again
and then see what happens.

00:25:00.400 --> 00:25:01.240
All right.

00:25:01.240 --> 00:25:04.160
Oh.

00:25:04.160 --> 00:25:09.030
My mistake, so I just need to...

00:25:11.300 --> 00:25:14.500
Run this again here.

00:25:14.500 --> 00:25:17.370
All right, let's just do this fresh.

00:25:19.490 --> 00:25:24.400
So we're going to launch Instruments,
run the allocations tool.

00:25:24.770 --> 00:25:27.400
Again,
I'm just going to turn on VM Tracker.

00:25:27.400 --> 00:25:29.330
Go back to these photos again.

00:25:29.470 --> 00:25:32.390
I'm just going to continue
to swipe through them.

00:25:41.110 --> 00:25:44.090
And you can again see that our dirty
memory is in fact steadily rising,

00:25:44.090 --> 00:25:45.680
so I've gone through them all now.

00:25:45.790 --> 00:25:48.030
And so I'm going to go through
again and simulate a memory warning,

00:25:48.030 --> 00:25:50.180
and let's see what happens this time.

00:25:50.510 --> 00:25:52.900
All right, well,
it got a little lower than before.

00:25:53.010 --> 00:25:58.180
But the point is that that's made a
real difference to my dirty memory,

00:25:58.420 --> 00:26:02.910
even though, as you can see,
the amount of heat memory that

00:26:02.910 --> 00:26:04.560
I'm using actually didn't change.

00:26:04.660 --> 00:26:07.260
So just looking at the allocations
instrument does not give you a

00:26:07.260 --> 00:26:08.640
full picture of what goes on.

00:26:08.740 --> 00:26:11.110
It's a good starting point,
but in terms of seeing the full

00:26:11.110 --> 00:26:13.520
effect of what you're doing in
terms of memory in the system,

00:26:13.530 --> 00:26:15.010
VM Tracker is your friend.

00:26:15.340 --> 00:26:17.590
It's what you want to look at.

00:26:19.840 --> 00:26:23.190
So if you get one thing out of that demo,
one thing, what I'm hoping that

00:26:23.190 --> 00:26:26.550
you'll get out of it,
is to pay attention to dirty memory.

00:26:26.630 --> 00:26:31.080
Dirty memory is the scarce resource
in the system because it leaves the

00:26:31.080 --> 00:26:35.820
system with no other option to reclaim
that but to terminate your application.

00:26:36.330 --> 00:26:39.290
Now, on that same note,
one thing that's very important is to

00:26:39.390 --> 00:26:41.500
avoid usage spikes in your application.

00:26:41.640 --> 00:26:46.300
And so what that means is that because
dirty memory is the most important,

00:26:46.430 --> 00:26:48.520
any time that you have a big
spike where you're using a lot

00:26:48.520 --> 00:26:52.870
of memory even for just a second,
it requires the same actions to be taken

00:26:53.210 --> 00:26:56.600
as would be taken if you were using
that memory for a long period of time.

00:26:56.720 --> 00:26:59.000
Because physical memory is
a resource that's limited,

00:26:59.100 --> 00:27:00.700
those spikes really matter.

00:27:00.700 --> 00:27:03.750
So if you're seeing these big spikes in
instruments and allocations where you're

00:27:03.750 --> 00:27:06.690
going way up and you're going down,
it's important to try

00:27:06.910 --> 00:27:08.870
and smooth those out.

00:27:09.260 --> 00:27:12.190
And one thing that can really help
is if you've kind of got a tight

00:27:12.190 --> 00:27:15.620
loop where you're allocating a lot of
objects that are then auto-released

00:27:16.040 --> 00:27:18.090
is to use auto-release pools.

00:27:18.120 --> 00:27:19.740
I guess at this point,
I will invite up my

00:27:19.770 --> 00:27:22.810
colleague Daniel Delwood,
who is a software engineer

00:27:23.140 --> 00:27:26.200
on the instruments team,
to kind of get really practical

00:27:26.200 --> 00:27:30.530
and show you how you can put these
tools and tricks to use for you.

00:27:38.210 --> 00:27:39.920
Thank you very much, Morgan.

00:27:40.180 --> 00:27:44.220
I want to talk to you about using
tools to really identify the memory

00:27:44.220 --> 00:27:49.340
usage in your application and
what you can do to use it better.

00:27:49.520 --> 00:27:53.800
So, the first thing I want to
talk about is the process.

00:27:53.890 --> 00:27:56.510
As you may have seen this
slide in other talks,

00:27:56.870 --> 00:28:00.900
we really want to emphasize that it's
important to follow a process when

00:28:00.900 --> 00:28:03.060
you're looking for performance issues.

00:28:03.200 --> 00:28:06.320
You need to identify and reproduce the
problem you're trying to solve so that

00:28:06.320 --> 00:28:10.090
then you can profile it with tools,
make some hypotheses,

00:28:10.200 --> 00:28:13.560
and iterate here to understand really
what's going on in your application.

00:28:13.680 --> 00:28:16.410
And then finally,
you can make those changes that will

00:28:16.460 --> 00:28:20.720
hopefully make your application much
better and much more memory efficient.

00:28:20.900 --> 00:28:25.970
So, going back to the idea of an iceberg,
and most of the memory that

00:28:25.970 --> 00:28:30.390
you think of being in the
heap is on top of the iceberg.

00:28:30.510 --> 00:28:32.400
And that's kind of a problem.

00:28:32.410 --> 00:28:36.950
Because, you know,
this memory is not the whole story.

00:28:37.280 --> 00:28:39.240
And so you may think, okay,
what can I do?

00:28:39.240 --> 00:28:42.240
Because there's a lot of
memory under the surface,

00:28:42.240 --> 00:28:45.240
and I really want to get the
most out of my application.

00:28:45.320 --> 00:28:50.330
Well, the good news is that most
dirty memory is in some form

00:28:50.330 --> 00:28:53.240
or fashion related to the heap.

00:28:53.350 --> 00:28:56.240
So this means that, you know,
if you've got a UI image,

00:28:56.240 --> 00:28:59.240
it has those references
to backing stores,

00:28:59.240 --> 00:29:01.740
and if you optimize
your UI image objects,

00:29:01.740 --> 00:29:03.730
you'll do a lot better.

00:29:03.840 --> 00:29:05.660
So let's talk a little
bit more about this.

00:29:05.760 --> 00:29:11.740
What can you do specifically to reduce
your entire application's memory usage?

00:29:11.740 --> 00:29:15.740
Well, first thing is to understand
your view hierarchy.

00:29:15.740 --> 00:29:17.690
And as the other talk
that was just in here,

00:29:17.790 --> 00:29:21.740
the iOS performance graphics
talk was talking about,

00:29:21.760 --> 00:29:24.600
the more pixels you draw,
the more memory you've got to

00:29:24.740 --> 00:29:28.740
use to make those large bitmaps
and show them on the screen.

00:29:28.740 --> 00:29:31.080
And you can really get a lot
of mileage just by doing that.

00:29:31.080 --> 00:29:33.080
And I think that's what we're
going to focus on today.

00:29:33.080 --> 00:29:34.330
And that's just by following
some of those performance

00:29:34.330 --> 00:29:35.080
tips in that graphics talk.

00:29:35.080 --> 00:29:37.080
And I'd like to refer you back to that.

00:29:37.080 --> 00:29:39.080
But what we're going to focus
on today is the second thing,

00:29:39.080 --> 00:29:43.080
and that's avoiding recurring
heap growth in your application.

00:29:43.080 --> 00:29:47.010
And like I said, it doesn't matter if
these objects are small.

00:29:47.440 --> 00:29:53.050
They may be referencing really large
VM regions that are hard to see.

00:29:53.080 --> 00:29:57.080
So what are the top three
that you should look for?

00:29:57.080 --> 00:30:00.420
Well, first of all,
you should look for leaked memory.

00:30:00.420 --> 00:30:03.420
And leaked memory is probably
the easiest to detect.

00:30:03.420 --> 00:30:05.370
We've got great tools for it.

00:30:05.440 --> 00:30:07.410
And it shows you memory
that's inaccessible.

00:30:07.580 --> 00:30:09.400
There's no other references to it.

00:30:09.570 --> 00:30:11.420
And it really just can't be used again.

00:30:11.420 --> 00:30:13.340
So it's completely wasted.

00:30:13.420 --> 00:30:16.230
And so whenever you detect leaked memory,
as I'll show you a little

00:30:16.390 --> 00:30:18.890
bit later in a demo here,
you should do your best

00:30:18.890 --> 00:30:23.410
to get rid of all of it,
especially because it's so easy to find.

00:30:23.420 --> 00:30:26.080
The second thing,
and probably more important,

00:30:26.080 --> 00:30:27.420
is abandoned memory.

00:30:27.480 --> 00:30:29.760
And this is memory that
is not in your memory.

00:30:29.760 --> 00:30:33.750
It's memory that you could reference,
but you never actually use again.

00:30:33.870 --> 00:30:39.760
And so this is memory like caches
that are slightly misimplemented,

00:30:39.760 --> 00:30:42.730
and memory that you allocate
but never go back to.

00:30:42.760 --> 00:30:48.760
And so it's a real, real big problem that
you need to look into.

00:30:48.760 --> 00:30:51.660
The third one, of course,
is those caches that are referenced

00:30:51.670 --> 00:30:54.750
and waiting for your use,
but they're speculative.

00:30:54.760 --> 00:30:59.100
The user may use them,
but they also may not.

00:30:59.100 --> 00:31:03.460
So you need to be very smart about
allocating only the memory that you

00:31:03.460 --> 00:31:06.030
think the user is actually going to use.

00:31:08.820 --> 00:31:11.700
So let's talk about how to detect it.

00:31:11.830 --> 00:31:16.610
Well, the central premise behind this is
that memory use in your application

00:31:16.630 --> 00:31:20.940
shouldn't grow without bound
when you repeat an operation.

00:31:20.940 --> 00:31:22.700
So what do I mean by this?

00:31:22.700 --> 00:31:27.840
Well, for example, say you're pushing and
popping a view controller.

00:31:27.840 --> 00:31:29.900
You push, you pop,
you expect that the memory

00:31:29.900 --> 00:31:32.580
usage when you get back will
be the same as when you left.

00:31:32.580 --> 00:31:34.540
And if you repeat this
over and over again,

00:31:34.540 --> 00:31:37.940
you really don't want to see
your memory usage going up.

00:31:37.980 --> 00:31:41.890
If you're scrolling in a table view,
that's another example of that, where,

00:31:42.140 --> 00:31:45.760
you know, your scrolling goes by,
you see all these rows, and you think,

00:31:45.760 --> 00:31:47.920
okay, well, my memory usage,
it's fine if it goes up.

00:31:48.050 --> 00:31:51.480
But you should really be reusing
those table cells and hopefully

00:31:51.480 --> 00:31:56.440
not using memories you go through
the scroll view multiple times.

00:31:56.440 --> 00:32:00.130
So let's talk about repetition
here and how it actually

00:32:00.130 --> 00:32:01.970
elicits that memory growth.

00:32:02.170 --> 00:32:05.900
Well, say you've got a graph,
and at some point in your application,

00:32:05.900 --> 00:32:06.800
you're going to see a graph that says,
oh, I'm going to use this graph.

00:32:06.900 --> 00:32:07.920
And you're going to see that
the graph is pretty stable.

00:32:07.920 --> 00:32:09.510
Well, this, you can sort of think
of as your baseline,

00:32:09.510 --> 00:32:10.040
right?

00:32:10.040 --> 00:32:13.840
Your application isn't really doing much,
and it's a great starting

00:32:13.840 --> 00:32:15.620
point for your investigations.

00:32:15.750 --> 00:32:17.740
Now,
you're going to perform that operation,

00:32:17.790 --> 00:32:19.380
which is going to bring
it into a new state,

00:32:19.380 --> 00:32:20.980
and perhaps you're using more memory.

00:32:21.170 --> 00:32:23.000
Perhaps you're viewing a photo, right?

00:32:23.000 --> 00:32:26.480
Your application is going to do some
really interesting and cool things.

00:32:26.590 --> 00:32:29.050
But then when you return
to that original state,

00:32:29.050 --> 00:32:32.820
you might expect that it would be the
same memory usage as the baseline.

00:32:32.830 --> 00:32:35.290
Well, of course,
the first time you do this,

00:32:35.450 --> 00:32:38.490
there's a lot of caches to warm up,
and that is really going

00:32:38.490 --> 00:32:40.070
to be your warm-up phase.

00:32:40.080 --> 00:32:42.830
So the first iteration doesn't
give you the information you

00:32:43.010 --> 00:32:44.240
need to solve the problem.

00:32:44.250 --> 00:32:47.650
So that's why you go ahead and repeat it,
let's say five times.

00:32:47.770 --> 00:32:50.360
Once you've repeated it,
then you can take a look at the

00:32:50.360 --> 00:32:53.820
difference between returning to
the original state after the first

00:32:53.820 --> 00:32:59.330
iteration and then returning to the
original state after the last iteration,

00:32:59.330 --> 00:33:01.010
and that is your wasted

00:33:02.370 --> 00:33:05.740
So how can you find that with our tools?

00:33:05.930 --> 00:33:07.780
Well,
the allocations tool is really powerful

00:33:07.890 --> 00:33:15.280
in that it can show you backtraces for
every single heap allocation you make.

00:33:15.320 --> 00:33:18.310
So it tracks all of
your heap allocations,

00:33:18.380 --> 00:33:21.620
including your
Objective-C and C++ objects.

00:33:21.620 --> 00:33:23.360
Now,
for those of you who are C++ developers,

00:33:23.420 --> 00:33:26.430
you may actually need to enable
this option because it's not on by

00:33:26.440 --> 00:33:28.980
default for performance reasons.

00:33:29.830 --> 00:33:33.670
There's also the ability to record
not just the malloc and free events,

00:33:33.860 --> 00:33:35.550
but the retain, release,
and auto-release events,

00:33:35.620 --> 00:33:37.240
which comes in really,
really useful if you're trying

00:33:37.240 --> 00:33:40.740
to track down leaks or other
reference counting issues.

00:33:40.900 --> 00:33:44.190
And finally,
allocations has statistics that it

00:33:44.260 --> 00:33:47.980
provides you by allocation type,
and also you can put this

00:33:47.990 --> 00:33:50.990
information in call trees,
which is really helpful for determining

00:33:51.070 --> 00:33:54.660
the point in your code that's
responsible for all these allocations.

00:33:54.960 --> 00:33:58.370
Finally, there's heap snapshot
technology built in,

00:33:58.380 --> 00:34:03.000
which is the really important part
to find that abandoned memory and

00:34:03.000 --> 00:34:05.860
persistent memory growth over time.

00:34:06.010 --> 00:34:07.520
So let's talk about it.

00:34:07.640 --> 00:34:12.050
Well, taking a practical example of that
pushing and popping a view controller,

00:34:12.200 --> 00:34:15.260
let's say you're getting
your app into a steady state.

00:34:15.400 --> 00:34:19.220
When you launch your application,
it comes up and it's showing your view.

00:34:19.340 --> 00:34:22.780
And then you go ahead and
perform the operation.

00:34:22.900 --> 00:34:26.200
And after each iteration here,
what you're going to do is take

00:34:26.200 --> 00:34:30.660
a snapshot of the heap with
the allocations instrument and

00:34:30.660 --> 00:34:33.970
repeat this multiple times.

00:34:34.090 --> 00:34:37.080
Ideally, once you've done this, you know,
five, ten times,

00:34:37.090 --> 00:34:40.500
it's those middle iterations that
you really want to focus on and

00:34:40.500 --> 00:34:41.950
hope that those go down to zero.

00:34:41.950 --> 00:34:44.520
Because if they do,
then your application is indeed

00:34:44.520 --> 00:34:46.520
well-behaved as you'd expect.

00:34:46.670 --> 00:34:49.920
So let's go ahead and take
a look at this in a demo.

00:34:49.930 --> 00:34:54.820
So I'm going to use the same application,
the

00:34:55.450 --> 00:34:58.140
And I'm going to go ahead and
run this in the simulator.

00:34:58.190 --> 00:35:02.640
Now, luckily for us,
heap allocations work mostly

00:35:03.050 --> 00:35:08.790
like they work on a device,
the same as they are in the simulator.

00:35:08.870 --> 00:35:11.070
And so I'm going to just go
ahead and select the leaks

00:35:11.170 --> 00:35:14.210
template here and profile.

00:35:14.350 --> 00:35:15.800
And my app starts up in the simulator.

00:35:15.800 --> 00:35:18.390
And this is really a
great place to analyze,

00:35:18.690 --> 00:35:21.720
because it's really great
for rapid prototyping,

00:35:21.720 --> 00:35:24.750
doing things over and over again,
and so on.

00:35:25.400 --> 00:35:29.050
So I launch my application,
and I'm going to select

00:35:29.050 --> 00:35:30.920
different views here.

00:35:30.920 --> 00:35:34.880
And you'll notice that Instruments
is recording in the background.

00:35:36.150 --> 00:35:40.550
And what I see is that allocations,
you know, gets to a pretty steady

00:35:40.550 --> 00:35:45.020
point of about four,
five and a half megabytes.

00:35:45.140 --> 00:35:48.450
If I click on my leaks instrument,
you'll notice that it's doing automatic

00:35:48.600 --> 00:35:50.900
snapshotting at 10-second intervals.

00:35:51.020 --> 00:35:54.770
Now, what this is doing is it's really
pausing my app and taking a lot

00:35:55.070 --> 00:36:00.360
of time to look through it and
find memory that's unreferenced.

00:36:00.470 --> 00:36:02.890
In this case, I'm not finding any.

00:36:03.230 --> 00:36:06.580
So I'm going to go to my application,
and I'm going to pick a

00:36:06.610 --> 00:36:07.920
scenario that I want to

00:36:09.400 --> 00:36:13.330
So for this one,
I'm going to show off the filter

00:36:13.330 --> 00:36:15.960
capabilities of the iPad app.

00:36:16.060 --> 00:36:18.300
And I'll bring up the filter field.

00:36:18.420 --> 00:36:22.500
And I can really call anything I want
the baseline for my investigation.

00:36:22.560 --> 00:36:25.940
So I'm going to call this screen
with the filter options open with

00:36:25.940 --> 00:36:28.000
everything selected my baseline.

00:36:28.170 --> 00:36:32.210
So I'll just go over to
instruments and select marqueep.

00:36:32.440 --> 00:36:37.410
And it creates that baseline
snapshot for me at 5.11 megs.

00:36:37.640 --> 00:36:42.860
All right, so why don't I turn these off,
close it, turn it back on.

00:36:42.920 --> 00:36:47.930
Now I've returned to my steady state,
and I'll mark my heap again.

00:36:48.400 --> 00:36:51.160
And I'm just going to repeat
this a couple of times to see

00:36:51.160 --> 00:36:54.310
how my application performs.

00:36:54.870 --> 00:36:59.530
What I'd really expect here is that
I wouldn't have many allocations,

00:36:59.610 --> 00:37:03.740
even though my filter is actually
doing a lot of work for me.

00:37:03.740 --> 00:37:07.150
I'm going to a core database,
looking at values and

00:37:07.150 --> 00:37:08.190
presenting them on the screen.

00:37:10.300 --> 00:37:12.600
So I've done this a few times now.

00:37:12.740 --> 00:37:14.700
And I'll stop my application.

00:37:14.700 --> 00:37:18.130
And you'll notice that for each
one of these in the middle,

00:37:18.130 --> 00:37:22.290
I'm experiencing a heap
growth of about 300K.

00:37:22.770 --> 00:37:25.390
Now, that's kind of interesting.

00:37:25.540 --> 00:37:29.180
If I turn it open,
you'll see a list of the objects that

00:37:29.180 --> 00:37:34.790
were allocated between Heapshot 2
and Heapshot 3 that are objects that,

00:37:35.150 --> 00:37:38.760
you know,
I didn't anticipate being alive.

00:37:39.210 --> 00:37:41.970
I can look through these
and see I've got an array,

00:37:41.970 --> 00:37:45.820
I've got a set, I've got some -- just
general malloc memory.

00:37:45.820 --> 00:37:48.370
But what I want to look for here
in this list are objects that

00:37:48.530 --> 00:37:50.270
hold on to a lot of resources.

00:37:50.270 --> 00:37:53.480
So in this case,
I can see pretty quickly that this

00:37:53.480 --> 00:37:59.100
UI tap gesture recognizer is probably
what I'm going to be looking for,

00:37:59.190 --> 00:38:01.500
because, you know, this is a UI element.

00:38:01.640 --> 00:38:04.150
It's got to have views and
other objects behind it.

00:38:04.470 --> 00:38:06.010
In this case, no views.

00:38:06.170 --> 00:38:08.340
But I can turn this down and
see a list of all the objects.

00:38:08.440 --> 00:38:12.370
I created 816 of these
between the snapshots.

00:38:14.370 --> 00:38:18.460
So if I select one of them and
bring in the extended detail view,

00:38:18.700 --> 00:38:23.000
I'll see a backtrace on the
right of where this came from.

00:38:23.340 --> 00:38:27.910
Now, I'm just going to go ahead and
double click on a black frame in this

00:38:27.910 --> 00:38:30.370
backtrace to jump directly to my code.

00:38:30.380 --> 00:38:35.130
And I'm actually going to show it
in Xcode to make this easier to see.

00:38:38.130 --> 00:38:45.960
So here we are, and we're in a table cell
for row at index path method.

00:38:45.960 --> 00:38:47.360
All right, that's fine.

00:38:47.600 --> 00:38:51.940
It's not uncommon for us to be
allocating a gesture recognizer here.

00:38:52.010 --> 00:38:55.720
But what we're looking for is
why we're allocating so many.

00:38:55.980 --> 00:38:57.350
So let's look for the allocation here.

00:38:57.430 --> 00:39:01.180
Here's our gesture recognizer,
allocating it with target.

00:39:01.240 --> 00:39:03.890
We're also creating a
double tap recognizer.

00:39:04.010 --> 00:39:04.240
Great.

00:39:04.240 --> 00:39:07.160
And then we're adding
it to our session cell.

00:39:07.440 --> 00:39:09.940
Now if we go back and
look at our session cell,

00:39:10.000 --> 00:39:13.530
it comes from-- here we go,
DQ session cell.

00:39:13.800 --> 00:39:15.950
We're doing cell reuse properly.

00:39:16.030 --> 00:39:16.940
That's great.

00:39:17.040 --> 00:39:19.640
And if there's no session cell,
we create a new one.

00:39:19.750 --> 00:39:21.800
Oh, but there's the issue.

00:39:22.180 --> 00:39:27.190
We're actually adding our tap gesture
recognizer even if we reuse the cell.

00:39:27.430 --> 00:39:31.840
Now it's already got one attached,
and we don't need to attach

00:39:31.910 --> 00:39:33.670
one every single time.

00:39:33.800 --> 00:39:35.300
So what I can do is I can
actually just attach this

00:39:36.300 --> 00:39:42.750
and I are going to talk about
the most common mistake we

00:39:42.750 --> 00:39:46.730
make when we create a new tool.

00:39:46.770 --> 00:39:50.360
So I'll just save and profile that again.

00:39:50.490 --> 00:39:52.640
And actually,
to show you a different issue,

00:39:52.720 --> 00:39:55.780
I'm going to remove
this from the simulator.

00:40:14.700 --> 00:40:17.700
does not seem to like me today.

00:40:17.700 --> 00:40:25.130
So I'll build and run my application.

00:40:38.600 --> 00:40:40.210
It launches.

00:40:40.210 --> 00:40:45.210
And this time I'm actually going
to watch it live to see if my

00:40:45.210 --> 00:40:50.540
change has actually made the
gesture recognizer issue go away.

00:40:50.690 --> 00:40:53.960
So the allocations table view here
is actually showing me all of the

00:40:53.960 --> 00:40:55.680
different categories in my app.

00:40:55.820 --> 00:40:58.810
I see strings, malloc blocks,
a bunch of stuff.

00:40:59.070 --> 00:41:03.550
But what I'm interested in in this
case is the gesture recognizer.

00:41:03.550 --> 00:41:03.550
So I can just type in that.

00:41:05.180 --> 00:41:09.120
You'll see that I've
actually created 86 so far,

00:41:09.120 --> 00:41:11.200
or 86 targets so far.

00:41:11.400 --> 00:41:15.400
So let me go to the schedule, pick a day,
and filter.

00:41:18.600 --> 00:41:21.900
And actually,
we'll notice in the background

00:41:21.990 --> 00:41:24.340
that the number isn't going up.

00:41:24.440 --> 00:41:26.850
So this is exactly what I'd hoped for.

00:41:27.900 --> 00:41:31.610
So, all right,
that actually is dealing with the

00:41:31.610 --> 00:41:34.440
issue that I was seeing earlier.

00:41:34.560 --> 00:41:37.740
That was kind of using the tools to
find some persistent memory growth

00:41:37.740 --> 00:41:40.130
using the heap snapshotting technology.

00:41:40.290 --> 00:41:42.380
And it's a very, very powerful tool.

00:41:42.380 --> 00:41:46.330
It's one that I really highly encourage
you to exercise on your application.

00:41:46.400 --> 00:41:49.380
Come up with a set of scenarios,
some things that the

00:41:49.380 --> 00:41:52.270
user will commonly do,
and then repeat them over and over again,

00:41:52.280 --> 00:41:54.630
taking snapshots after each one.

00:41:55.050 --> 00:41:56.790
Now,
let's go on and talk about some tools,

00:41:56.930 --> 00:41:59.560
tips, and tricks,
some ways of getting the most out

00:41:59.630 --> 00:42:04.210
of instruments and to understand
the memory in your application.

00:42:04.980 --> 00:42:08.260
So I'd like to encourage you to
get to know your application.

00:42:08.430 --> 00:42:13.400
And what I mean by this is pay
attention to that list of objects,

00:42:13.500 --> 00:42:16.540
specifically objects
holding onto resources.

00:42:16.630 --> 00:42:20.940
Now, these may be UI images,
view controllers, NS operations,

00:42:20.940 --> 00:42:22.690
a bunch of different things.

00:42:22.860 --> 00:42:25.150
And anything that
really wraps large data,

00:42:25.240 --> 00:42:30.700
because it may be difficult to see
even though the objects are small,

00:42:30.700 --> 00:42:32.920
there may be a lot under the surface.

00:42:32.920 --> 00:42:36.520
And so, you know, for instance,
this could even be an NSData with

00:42:36.520 --> 00:42:38.690
a one megabyte buffer.

00:42:39.020 --> 00:42:41.880
Now, another thing that's important
to track are your objects.

00:42:42.020 --> 00:42:44.660
And these are objects that hopefully,
you know,

00:42:44.660 --> 00:42:46.400
you may have a class name prefix.

00:42:46.400 --> 00:42:49.700
It's really, really easy just to type
that into the search field,

00:42:49.850 --> 00:42:52.070
filter down to your objects,
and validate those

00:42:52.070 --> 00:42:53.540
patterns that you expect.

00:42:53.650 --> 00:42:59.820
If you expect that, you know,
your view controller goes away

00:42:59.820 --> 00:42:59.820
when the user moves away from it,
make sure that's happening.

00:43:00.130 --> 00:43:03.110
And finally, simulate memory warnings
in your application,

00:43:03.110 --> 00:43:06.780
like Morgan showed,
to make sure that you're being a

00:43:07.090 --> 00:43:11.410
good citizen and doing all that
you can to work well on iOS.

00:43:13.720 --> 00:43:16.100
Now,
memory bugs actually are pretty expensive

00:43:16.100 --> 00:43:17.640
when you encounter them in the wild.

00:43:17.750 --> 00:43:19.460
And if your users are
reporting them to you,

00:43:19.460 --> 00:43:21.700
it's going to make you
have to turn another build,

00:43:21.720 --> 00:43:25.180
and it's a very time-consuming
process for you.

00:43:25.180 --> 00:43:28.700
So I'd like to really encourage you
to switch to Arc as the first thing,

00:43:28.820 --> 00:43:31.810
because it's a really,
really powerful technology and allows

00:43:31.810 --> 00:43:36.470
you to stop thinking about retain-release
and allows you to think about the object

00:43:36.470 --> 00:43:40.580
relationships in your application.

00:43:40.690 --> 00:43:44.640
Another powerful technology
is the Xcode Static Analyzer.

00:43:44.680 --> 00:43:48.990
And this tool is great for
finding uninitialized variables,

00:43:48.990 --> 00:43:53.460
tracking down some common programming
mistakes that it's very easy to

00:43:53.460 --> 00:43:56.540
make and sometimes very difficult
and time-consuming to find.

00:43:58.530 --> 00:44:01.340
Finally,
use the leaks instrument and make sure

00:44:01.340 --> 00:44:08.650
you only make one fix at a time because
if your fix is a little bit wrong or

00:44:08.650 --> 00:44:14.300
sometimes there's other code that was
relying on a bug and you just need

00:44:14.300 --> 00:44:19.710
to make sure that you don't introduce
other issues when you fix these leaks.

00:44:20.530 --> 00:44:22.700
Now, when it comes to fixing leaks,
you may say, well,

00:44:22.700 --> 00:44:23.820
I am already running Arc.

00:44:23.900 --> 00:44:25.920
There's not going to be any leaks, right?

00:44:25.970 --> 00:44:28.790
Well, it's not entirely true,
because Arc doesn't solve the

00:44:28.910 --> 00:44:31.160
problem of retained cycles for you.

00:44:31.220 --> 00:44:34.760
Now, you can use the cycles and routes
view in instruments just by

00:44:34.910 --> 00:44:38.340
going to the leaks instrument,
pulling down off the jump bar,

00:44:38.340 --> 00:44:41.120
and selecting cycles and routes.

00:44:41.120 --> 00:44:43.960
And one thing I would really
like to caution you to be

00:44:44.050 --> 00:44:46.150
careful of is block captures.

00:44:46.150 --> 00:44:49.960
Now, blocks are a really,
really powerful technology,

00:44:50.120 --> 00:44:53.680
but they can sometimes lead to
unexpected behavior if you're

00:44:53.740 --> 00:44:55.560
really not anticipating it.

00:44:55.640 --> 00:44:58.470
So, for example, here,
I'm using the really powerful

00:44:58.470 --> 00:45:01.600
block-based NS Notification Center API.

00:45:01.720 --> 00:45:06.920
And if you'll notice here,
I've got my self.document being set

00:45:06.920 --> 00:45:10.380
whenever this notification gets sent.

00:45:10.650 --> 00:45:15.080
Now what the compiler does here is
it actually is going to capture my

00:45:15.150 --> 00:45:17.950
variable strongly and retain it.

00:45:18.040 --> 00:45:25.540
And what this does is mean that if
I have a retain cycle created by this,

00:45:25.640 --> 00:45:28.980
it's just because the compiler is
doing something to be very safe.

00:45:29.090 --> 00:45:32.570
The notification center is going
to have to copy my block to the

00:45:32.600 --> 00:45:36.640
heap from the stack and in doing
so create this capture itself.

00:45:36.890 --> 00:45:39.200
All right, so what if you're not
actually referencing self?

00:45:39.320 --> 00:45:40.840
What if you're just using an I var?

00:45:40.840 --> 00:45:43.120
Well, if you're using an instance
variable like this,

00:45:43.130 --> 00:45:45.160
the compiler is going to
do the exact same thing.

00:45:45.160 --> 00:45:47.650
It's smart enough to know
that you need self around,

00:45:47.960 --> 00:45:51.320
and so it just captures self and
references through the pointer.

00:45:51.890 --> 00:45:54.300
All right, so if this is the cause
of your retain cycles,

00:45:54.300 --> 00:45:55.560
how can you get around it?

00:45:55.700 --> 00:45:56.800
Well, it's pretty easy.

00:45:56.930 --> 00:46:02.350
All you need to do is create a
weak variable to capture self,

00:46:02.350 --> 00:46:06.200
and then use the weak variable
in place of your self or

00:46:06.510 --> 00:46:09.040
even your instance variable.

00:46:09.040 --> 00:46:12.900
And I'd highly encourage you
to use property accessors here.

00:46:13.020 --> 00:46:15.600
Now, one thing to note is that
if you're running Arc,

00:46:15.650 --> 00:46:16.830
weak is sufficient.

00:46:16.830 --> 00:46:19.300
If you're running with
manual retain release,

00:46:19.300 --> 00:46:21.110
you'll also need to
add the block keyword.

00:46:23.220 --> 00:46:25.050
Finally,
there's incorrect retain release,

00:46:25.180 --> 00:46:26.190
which can lead to leaks.

00:46:26.330 --> 00:46:30.260
And this is a very classical problem,
very easy to do under

00:46:30.310 --> 00:46:33.800
manual retain release,
just forgetting to write a release

00:46:34.050 --> 00:46:36.140
or writing an extra retain.

00:46:36.350 --> 00:46:40.610
And it's also possible with
incorrect arc bridging.

00:46:40.710 --> 00:46:42.420
And so you'll need to
be careful about this.

00:46:42.560 --> 00:46:47.350
If you encounter leaks of this type,
just select a single instance,

00:46:47.350 --> 00:46:50.550
hit the focus button,
and go in and take a look at the

00:46:50.600 --> 00:46:52.920
full retain release history for it.

00:46:53.110 --> 00:46:58.470
Now, I'd really encourage you also
to look for the backtraces at

00:46:58.470 --> 00:47:01.380
both the beginning and the end,
because these are most

00:47:01.480 --> 00:47:02.790
likely to be at fault.

00:47:05.200 --> 00:48:48.900
[Transcript missing]

00:48:49.830 --> 00:48:54.230
Now some final tracing tips
to hopefully get the most out

00:48:54.230 --> 00:48:56.640
of your use of instruments.

00:48:56.640 --> 00:48:59.120
Make notes with each trace that you take.

00:48:59.200 --> 00:49:03.090
These can be totally invaluable
later as you send the trace to

00:49:03.090 --> 00:49:05.940
other members of your team or
you're looking back at it from,

00:49:05.990 --> 00:49:07.600
you know, a month later.

00:49:07.600 --> 00:49:11.700
These can be very helpful for knowing
what you were doing at a certain

00:49:11.700 --> 00:49:14.680
time that you see a memory spike.

00:49:14.990 --> 00:49:19.020
And I really highly
encourage you to add these.

00:49:19.020 --> 00:49:21.960
Also, filter specific time intervals.

00:49:21.960 --> 00:49:26.530
Using our range selection buttons,
you can set in and out points,

00:49:26.650 --> 00:49:30.610
or you can also option drag in
the timeline and select just

00:49:30.730 --> 00:49:36.190
ranges to filter down your
detail view to those time ranges.

00:49:36.410 --> 00:49:39.300
And finally, please be conscious of
the snapshot intervals.

00:49:39.410 --> 00:49:42.010
As Morgan showed,
the VM tracker was snapshot-based,

00:49:42.010 --> 00:49:43.640
as well as the leaks instrument.

00:49:43.820 --> 00:49:49.800
And there may be slight pauses when
that happens on your iPad or iPhone.

00:49:49.930 --> 00:49:53.440
And what you'll want to do is just
not worry too much about frame

00:49:53.440 --> 00:49:56.330
drops during these intervals.

00:49:56.700 --> 00:51:03.000
[Transcript missing]
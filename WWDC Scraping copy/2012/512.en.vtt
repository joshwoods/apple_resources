WEBVTT

00:00:10.300 --> 00:02:10.600
[Transcript missing]

00:02:11.100 --> 00:02:14.560
The final thing about subtitles that's
interesting from a production point

00:02:14.560 --> 00:02:19.530
of view is that due to their nature,
they are often added post-production.

00:02:19.590 --> 00:02:23.240
In fact, particular programs are
actually augmented over

00:02:23.250 --> 00:02:25.260
time with subtitle content.

00:02:25.260 --> 00:02:30.720
Subtitle content generally is easier
to produce than alternate audio,

00:02:30.720 --> 00:02:34.940
and so you'll often have it
localized in a much larger range

00:02:34.950 --> 00:02:39.760
of languages and variations,
particularly in some of the really

00:02:39.760 --> 00:02:41.700
multilingual countries in Europe.

00:02:41.700 --> 00:02:45.700
And so we had to take all of these
different considerations into

00:02:45.740 --> 00:02:49.480
account when we designed our subtitle
support for HTTP live streaming.

00:02:49.480 --> 00:02:53.260
And of course, the first thing that we
needed to decide was,

00:02:53.260 --> 00:02:56.760
in what format are we going to
ask you to author your subtitles?

00:02:56.760 --> 00:02:59.860
And that sort of has
some key implications.

00:02:59.860 --> 00:03:04.360
And so we looked over a
number of different formats,

00:03:04.360 --> 00:03:07.760
and what we ended up choosing
was a relatively new,

00:03:08.080 --> 00:03:11.410
and format that has evolved recently.

00:03:11.480 --> 00:03:14.560
It's being,
the work there is being done under

00:03:14.560 --> 00:03:18.310
the offices of the Media Text Tracks
Community Group at W3C.

00:03:18.320 --> 00:03:23.100
And it's called WebVTT,
stands for Web Video Text Tracks.

00:03:23.100 --> 00:03:26.870
And it actually, if you look at it,
it's pretty clear it has

00:03:26.880 --> 00:03:30.020
its origins in an earlier
proprietary format called SubRip.

00:03:30.060 --> 00:03:33.590
And so if any of you are
familiar with the .srt subtitles,

00:03:33.630 --> 00:03:37.130
WebVTT will look immediately
very familiar to you.

00:03:38.080 --> 00:03:42.230
From our point of view,
one of the things that was really

00:03:42.400 --> 00:03:49.760
appealing about the WebVTT format is it
combines an extremely simple text format.

00:03:49.760 --> 00:03:53.160
You've got these very simple
text-based files that carry Unicode,

00:03:53.160 --> 00:03:56.120
so it's completely internationalizable.

00:03:56.120 --> 00:03:59.930
But at the same time,
the simplicity carries a great

00:03:59.960 --> 00:04:04.300
deal of expressibility with it in
the layout and control you have.

00:04:04.420 --> 00:04:07.960
And so we thought it was a
really good match for HTTP,

00:04:08.080 --> 00:04:10.080
and it's a really good match
for HTTP live streaming.

00:04:10.150 --> 00:04:13.900
The specification is available
publicly on the W3C website,

00:04:13.900 --> 00:04:16.080
w3.org.

00:04:16.080 --> 00:04:19.790
And I guess the easiest way
to sort of introduce you to

00:04:19.790 --> 00:04:21.080
WebVTT is to show you an example.

00:04:21.080 --> 00:04:26.980
And so here we have an example
of a complete WebVTT file.

00:04:27.080 --> 00:04:32.170
It starts,
it always starts with the text WebVTT,

00:04:32.170 --> 00:04:33.970
so you can sniff the file,
you can find out what

00:04:34.000 --> 00:04:35.080
you're dealing with.

00:04:35.290 --> 00:04:38.080
And then it's kind of
like an HTTP response.

00:04:38.080 --> 00:04:41.420
You've got the kind of the WebVTT thing,
and then you have an optional

00:04:41.420 --> 00:04:44.080
header fields following that,
and then a double line feed,

00:04:44.080 --> 00:04:46.950
and it takes you then
to the payload content.

00:04:47.080 --> 00:04:51.080
The payload in WebVTT is
just a series of queues.

00:04:51.080 --> 00:04:53.080
And queues are extremely simple things.

00:04:53.080 --> 00:04:55.790
I've got two up here as an example.

00:04:56.300 --> 00:05:01.770
The first thing you see is a time span,
and that indicates when the subtitle

00:05:01.770 --> 00:05:06.080
is intended to appear on screen and
when it's intended to disappear.

00:05:06.110 --> 00:05:08.080
And then following that,
you just have the subtitle text.

00:05:08.080 --> 00:05:11.080
So you have two subtitles here.

00:05:11.080 --> 00:05:15.880
The first shows up at 11 seconds in,
"Let's play a game," then it fades out,

00:05:16.080 --> 00:05:18.760
and a couple of seconds later,
it's followed by, "You know,

00:05:18.770 --> 00:05:24.620
I don't like games." So looking at this,
it's pretty clear that these

00:05:24.620 --> 00:05:26.080
are really easy to author.

00:05:26.080 --> 00:05:28.080
You could sit down with
your favorite movie,

00:05:28.080 --> 00:05:31.310
stop watching a VI, and type, type, type,
type, type,

00:05:31.310 --> 00:05:34.080
and you could generate a two-hour
text file of all the subtitles.

00:05:34.080 --> 00:05:37.080
And so you can say, "Okay, well,
that's great, but I have this stream.

00:05:37.110 --> 00:05:40.440
How do I get this stream to
play the subtitles?" And so

00:05:40.650 --> 00:05:41.960
that's where we come in.

00:05:44.420 --> 00:05:48.810
We look at subtitle media,
.VTT file in this case,

00:05:48.810 --> 00:05:52.590
just like we do any other kind of media.

00:05:52.590 --> 00:05:57.360
And so in HLS, just as we would take your
transport stream containing your

00:05:57.360 --> 00:06:00.300
audio and your video and you break
it up into a series of segments,

00:06:00.420 --> 00:06:04.900
you do the same thing with your
VTT file containing all your subtitles.

00:06:05.010 --> 00:06:10.600
You break it up into a series of
segments and each segment is a

00:06:10.650 --> 00:06:12.390
complete standalone WebVTT file.

00:06:12.980 --> 00:06:16.640
You take all of these segments,
you throw them up on your web server,

00:06:16.640 --> 00:06:20.830
and you give each one a URL and you
collect the URLs into a playlist file,

00:06:20.960 --> 00:06:25.090
into an M3O8 file,
and that's your subtitle playlist.

00:06:25.190 --> 00:06:31.440
Now, of course, HTTP live streaming,
one thing I want to point out here is

00:06:31.440 --> 00:06:36.290
that the most common case for a subtitle
playlist is just a static playlist.

00:06:36.390 --> 00:06:39.870
You've got your two R2 subtitles,
endless tag at the end,

00:06:39.870 --> 00:06:41.200
playlist type VOD.

00:06:41.300 --> 00:06:45.490
But there's nothing to prevent you
from subtitling live content as well.

00:06:45.580 --> 00:06:49.960
And so you could have a M3O8
playlist that has four subtitle

00:06:49.960 --> 00:06:53.380
segments and then 10 seconds later
you'll get another subtitle segment

00:06:53.430 --> 00:06:55.240
and another subtitle segment.

00:06:55.340 --> 00:06:58.190
And in fact, if you're subtitling a
continuous broadcast,

00:06:58.280 --> 00:07:01.480
such as a 24-hour news station,
you'll see segments roll

00:07:01.480 --> 00:07:02.640
off the top as well.

00:07:02.770 --> 00:07:07.260
And so subtitles integrate
completely into the live workflow

00:07:07.600 --> 00:07:10.300
of HTTP live streaming as well.

00:07:10.590 --> 00:07:14.150
That's fine if all you want
to do is play subtitles,

00:07:14.160 --> 00:07:16.440
but of course the interesting
thing is to integrate subtitles

00:07:16.530 --> 00:07:18.200
with the rest of the presentation.

00:07:18.280 --> 00:07:23.260
And so the mechanism for that is the
same mechanism that we introduced in

00:07:23.600 --> 00:07:27.090
iOS 5 to carry alternate audio content.

00:07:27.160 --> 00:07:33.840
It's the media tag and we just have,
we've reused the mechanism for subtitles.

00:07:33.910 --> 00:07:39.300
And for those of you who may be a little
rusty or haven't used the media tag,

00:07:39.300 --> 00:07:42.880
Let me quickly go over how that looks.

00:07:43.350 --> 00:07:48.270
I have a diagram here and it has
four what we call variants or the

00:07:48.270 --> 00:07:50.200
same content at different bit rates.

00:07:50.330 --> 00:07:52.300
We've got an audio only variant.

00:07:52.300 --> 00:07:55.300
We've got a 400 kilobit, 800 kilobit,
1500 kilobit.

00:07:55.430 --> 00:07:59.640
And over here on the right,
we've got individual audio

00:07:59.760 --> 00:08:04.970
playlists that have the same audio
content but in different languages.

00:08:05.080 --> 00:08:09.650
And so these are playlists
that contain .ac files.

00:08:09.910 --> 00:08:14.340
And with the media tag,
you can associate that set

00:08:14.340 --> 00:08:19.460
of audio options with all the
different video bit rates.

00:08:19.850 --> 00:08:22.550
And at runtime,
you can configure it to say, okay,

00:08:22.550 --> 00:08:25.300
now I'd like to hear the German audio,
please.

00:08:25.420 --> 00:08:27.740
So for subtitles,
we did the exact same thing

00:08:27.740 --> 00:08:29.500
using the exact same syntax.

00:08:29.630 --> 00:08:33.290
We have alongside our
group of audio alternates,

00:08:33.290 --> 00:08:35.800
we have subtitle alternates.

00:08:35.910 --> 00:08:38.580
So we could have English subtitles,
German subtitles.

00:08:38.690 --> 00:08:41.800
You might have Slovakian
subtitles or Portuguese.

00:08:41.800 --> 00:08:45.000
You might have commentary subtitles.

00:08:45.160 --> 00:08:50.800
And using the same APIs at runtime,
you can discover these subtitles exist,

00:08:50.950 --> 00:08:55.420
choose the ones you want to see,
and set them on the playback item

00:08:55.420 --> 00:08:57.530
and they all start appearing.

00:08:58.180 --> 00:08:59.450
That's a little bit abstract perhaps.

00:08:59.520 --> 00:09:03.930
And so what I'd like to do is quickly
run through an example of actually

00:09:03.930 --> 00:09:08.120
authoring some WebVTT subtitles
and putting them into a playlist

00:09:08.240 --> 00:09:10.220
so you can see how that works.

00:09:10.340 --> 00:09:13.760
So let's start with a couple
of subtitle segments here.

00:09:13.780 --> 00:09:16.780
I've got -- I've called them
segment zero and segment one.

00:09:16.860 --> 00:09:20.900
The first segment is the first
30 seconds of subtitle content.

00:09:20.970 --> 00:09:22.870
Didn't have a lot of
room on the slide here,

00:09:22.870 --> 00:09:25.340
and so there's not a lot of
subtitles in each segment,

00:09:25.340 --> 00:09:26.300
but bear with me.

00:09:26.520 --> 00:09:31.210
So two segments from zero to 30,
30 to 60.

00:09:31.390 --> 00:09:34.610
What we're going to do is, you know,
save these as perhaps

00:09:34.750 --> 00:09:38.020
as individual files,
and we're going to take them and

00:09:38.020 --> 00:09:40.530
put them up on our web server.

00:09:40.650 --> 00:09:44.000
And each one gets a different URL,
and then what we do is we

00:09:44.000 --> 00:09:46.240
build our playlist around them.

00:09:46.300 --> 00:09:49.970
And so this is an utterly
conventional playlist.

00:09:50.050 --> 00:09:51.690
Got a target duration,
it's got a version,

00:09:51.690 --> 00:09:53.700
it's got a sequence number,
a playlist type.

00:09:53.770 --> 00:09:57.950
The only difference is, is that the URLs,
the URL is going to point to

00:09:57.950 --> 00:10:00.520
.VTT files instead of .ts files.

00:10:00.580 --> 00:10:02.980
And so once you've got this
subtitle playlist -- and again,

00:10:02.980 --> 00:10:07.230
you can have multiple subtitle playlists
for all the different languages or types

00:10:07.330 --> 00:10:09.960
of subtitle tracks you'd like to author.

00:10:10.080 --> 00:10:14.610
You take the subtitle playlists
and you put them into the master

00:10:14.640 --> 00:10:17.020
playlist and -- using media tags.

00:10:17.110 --> 00:10:20.690
And so in this example,
that subtitle playlist we just authored

00:10:20.760 --> 00:10:26.220
that contained the English subtitles
appears in the first media tag.

00:10:26.220 --> 00:10:28.220
It's the subtitle group.

00:10:28.220 --> 00:10:30.220
We've labeled it as English.

00:10:30.220 --> 00:10:33.790
And it's got a language tag of English.

00:10:34.140 --> 00:10:35.760
It's actually part of a group.

00:10:35.830 --> 00:10:39.450
There's a second media tag as well,
and that's indicating that

00:10:39.790 --> 00:10:42.160
there's another set of subtitles
that are authored in simplified

00:10:42.160 --> 00:10:45.630
Chinese in Unicode in the text.

00:10:45.730 --> 00:10:51.150
And it's -- I'll point out again
that when you're naming these,

00:10:51.150 --> 00:10:56.150
you want to name them in the
native script of the language

00:10:56.150 --> 00:10:57.340
so that the native speakers can
actually -- read them and recognize

00:10:57.430 --> 00:10:59.260
them as being in their language.

00:10:59.270 --> 00:11:00.030
So you do that.

00:11:00.190 --> 00:11:02.920
You create your group of
subtitle media options.

00:11:03.060 --> 00:11:06.290
And then in each of your variants,
in each of your different bit rates,

00:11:06.400 --> 00:11:10.210
you have a subtitles attribute
and you just indicate the subtitle

00:11:10.210 --> 00:11:15.110
group that defines which set of
subtitles are the appropriate set

00:11:15.200 --> 00:11:17.610
of choices for that alternate.

00:11:18.100 --> 00:11:19.680
So we went over that pretty quickly.

00:11:19.680 --> 00:11:22.960
There's a couple of things I'd
like to go back and talk about

00:11:22.970 --> 00:11:24.620
in a little bit more detail.

00:11:24.740 --> 00:11:28.200
The first is I've kind of skipped
over this timestamp map tag you see

00:11:28.530 --> 00:11:30.040
at the beginning of the WebVTT file.

00:11:30.040 --> 00:11:31.820
What's that about?

00:11:33.220 --> 00:11:37.260
Well,
the WebVTT folks quite reasonably decided

00:11:37.260 --> 00:11:41.920
when they were building their format
that they would indicate time in sort

00:11:41.920 --> 00:11:45.140
of the conventional format of hours,
minutes, seconds, you know,

00:11:45.140 --> 00:11:46.100
decimal number of seconds.

00:11:46.190 --> 00:11:47.750
And that's totally reasonable choice.

00:11:47.780 --> 00:11:51.880
Of course, in the media space,
that's not how we indicate our --

00:11:51.900 --> 00:11:55.460
that's not how we timestamp our content.

00:11:55.840 --> 00:12:00.020
In HTTP live streaming,
our content is timestamped with 33-bit

00:12:00.400 --> 00:12:04.210
MPEG transport stream PES timestamps.

00:12:04.320 --> 00:12:09.950
And so this tag allows you to
kind of line up the WebVTT hours,

00:12:09.950 --> 00:12:16.940
minutes, seconds timeline with the
MPEG-2 33-bit 90K based,

00:12:16.940 --> 00:12:17.600
you know, time stamp.

00:12:17.600 --> 00:12:22.340
So that you know what
corresponds to what.

00:12:22.350 --> 00:12:24.930
And in this case,
we have an example here that says

00:12:25.010 --> 00:12:30.890
that when you see 000 in WebVTT,
that corresponds to 900,000,

00:12:30.890 --> 00:12:33.840
which is a fairly common
starting time for the beginning

00:12:33.840 --> 00:12:37.800
of a static transport stream.

00:12:38.360 --> 00:12:41.800
An important thing to note here
is that you don't necessarily

00:12:41.800 --> 00:12:45.900
need to change this tag every time
you have a new WebVTT segment.

00:12:45.900 --> 00:12:49.590
All it's doing is indicating a
synchronization point between the

00:12:49.600 --> 00:12:52.590
two different timelines so that
we can map from one to the other,

00:12:52.620 --> 00:12:56.750
which means that you might have
segment one or the following segment,

00:12:56.750 --> 00:12:59.580
which covers from 30 to 60 seconds.

00:12:59.580 --> 00:13:04.660
It might not have 0, 0, 0 in its range of
covered subtitle content,

00:13:04.660 --> 00:13:08.810
but there's a continuous flow of time,
and so we don't have to change the tag.

00:13:08.820 --> 00:13:14.160
The only time that you need to
update the timestamp map tag is A,

00:13:14.160 --> 00:13:17.540
when we're going across a discontinuity
and the clocks are restarting.

00:13:17.540 --> 00:13:20.570
So if you've got your content and
then you've got a discontinuity

00:13:20.570 --> 00:13:24.140
on some ad content where the
MPEG timestamps are restarting and

00:13:24.140 --> 00:13:27.810
the WebVTT content is restarting,
because you should probably be

00:13:27.810 --> 00:13:29.600
subtitling your ads as well.

00:13:29.600 --> 00:13:33.720
You'll have a discontinuity in
the following WebVTT segments,

00:13:33.720 --> 00:13:38.030
you'll just want to update that
timestamp map so that we can update

00:13:38.030 --> 00:13:40.100
our internal bookkeeping of that.

00:13:40.240 --> 00:13:46.610
And the other place where we'd like you
to update the timestamp map tag is in the

00:13:46.710 --> 00:13:52.130
segment following any 33-bit rollover,
because MPEG has this 90K clock,

00:13:52.260 --> 00:13:56.520
it's ticking along at 90K per second,
and it's a 33-bit number,

00:13:56.520 --> 00:13:57.560
eventually it rolls over.

00:13:57.660 --> 00:13:59.940
It takes about a day,
and so a lot of you would

00:13:59.940 --> 00:14:03.390
never even see that,
but if it does happen in your content,

00:14:03.790 --> 00:14:07.320
following that in the next VTT segment,
We'd just like to see an update

00:14:07.320 --> 00:14:10.290
of that so we can resynchronize.

00:14:11.100 --> 00:16:58.000
[Transcript missing]

00:16:58.390 --> 00:17:03.100
And that means we're going to go
back to the server every so often.

00:17:03.390 --> 00:17:06.660
Then the subtitle target duration,
this is just totally following

00:17:06.660 --> 00:17:09.410
the rules of the spec,
the subtitle target duration must be

00:17:09.410 --> 00:17:13.630
the same as the target durations of the
audio and the video and whatever else.

00:17:13.780 --> 00:17:19.750
So it means that every 10 seconds
we're going to go back to the server,

00:17:19.900 --> 00:17:22.550
we expect to see new video,
we expect to see new audio,

00:17:22.550 --> 00:17:22.550
we also expect to see
new target durations.

00:17:22.700 --> 00:17:24.710
For on-demand for
static playlist content,

00:17:24.710 --> 00:17:30.540
we actually relaxed this rule a little
bit because we recognize that in reality,

00:17:30.870 --> 00:17:35.400
subtitle data is extremely
compact and kind of sparse.

00:17:35.460 --> 00:17:36.490
There's not a whole lot of it.

00:17:36.880 --> 00:17:43.300
And so asking someone to create a tiny
little file for every 10 seconds of

00:17:43.300 --> 00:17:46.900
content didn't seem to be necessary.

00:17:46.900 --> 00:17:51.020
And so we've relaxed the
constraint in the case of on-demand

00:17:51.020 --> 00:17:53.300
of static playlist content.

00:17:53.300 --> 00:17:56.850
You can have a larger target duration,
so you can have bigger

00:17:57.160 --> 00:17:58.680
chunks of subtitle data.

00:17:58.680 --> 00:18:00.560
We do still ask you to segment it.

00:18:00.560 --> 00:18:03.090
We ask you to segment
it to a reasonable size.

00:18:03.090 --> 00:18:06.460
We're suggesting anywhere
between one and five minutes.

00:18:06.530 --> 00:18:09.550
And the reason we do this is
because for efficiency of access,

00:18:09.640 --> 00:18:12.350
again, if we seek into the
middle of a presentation,

00:18:12.380 --> 00:18:16.880
we don't want to have to chew through 30
minutes of subtitle data we don't need.

00:18:16.900 --> 00:18:19.450
Before we find the one
we actually want to load.

00:18:20.070 --> 00:18:25.170
And so your segments can be bigger
for on-demand for static content,

00:18:25.170 --> 00:18:28.000
but they should still be reasonable.

00:18:28.510 --> 00:18:32.700
And so those are the segmenting rules.

00:18:32.700 --> 00:18:36.200
This is pretty much all you
need to auth your content.

00:18:36.290 --> 00:18:40.410
As I mentioned, of course,
normally in the usual case of subtitles,

00:18:40.410 --> 00:18:42.310
the user has to turn them on.

00:18:42.310 --> 00:18:44.200
And so how does that work?

00:18:45.390 --> 00:18:47.920
In the case of non-forced subtitles,
which is the standard case,

00:18:47.920 --> 00:18:50.780
we'll talk about forced
subtitles in a second,

00:18:50.810 --> 00:18:56.020
the set of available subtitles
appears in the asset and particularly

00:18:56.020 --> 00:18:58.820
appears as a media selection group.

00:18:58.820 --> 00:19:01.860
And so because assets can
be loaded asynchronously,

00:19:01.860 --> 00:19:05.490
the first thing you need to do before
looking for your subtitles is to ensure

00:19:05.490 --> 00:19:09.040
that the following property is available.

00:19:09.120 --> 00:19:14.010
Asset.availableMediaCharacteristics.media
Selection.assets.

00:19:14.030 --> 00:19:14.090
It's big and long.

00:19:14.110 --> 00:19:15.160
Make sure that's available.

00:19:15.160 --> 00:19:19.460
At that point, you can ask the asset for
its media selection group for

00:19:19.560 --> 00:19:21.020
the legible characteristic.

00:19:21.070 --> 00:19:24.340
And in HTTP live streaming,
that will get you all the subtitles.

00:19:24.340 --> 00:19:26.280
It'll get you an entire set of subtitles.

00:19:26.380 --> 00:19:28.580
It may get you, "I've got some English.

00:19:28.580 --> 00:19:29.720
I've got some German.

00:19:29.720 --> 00:19:34.040
I've got some English commentary."
It may get you an entire set.

00:19:34.040 --> 00:19:39.410
And so the next step typically is you
want to select from amongst the set.

00:19:39.410 --> 00:19:42.380
And you may invoke the
user's help when you do this.

00:19:42.380 --> 00:19:47.470
You want to select amongst the set that's
available in the stream for presentation.

00:19:47.480 --> 00:19:52.940
We have a set of powerful filtering
APIs in AV Media Selection Group.

00:19:52.940 --> 00:19:55.540
One of the most convenient
ones perhaps is to say,

00:19:55.540 --> 00:19:59.430
"Take the set and filter and
sort it according to my preferred

00:19:59.430 --> 00:20:02.710
languages." And you can get the
set of preferred languages ordered

00:20:02.710 --> 00:20:04.780
by preference from NSLocale.

00:20:04.820 --> 00:20:07.220
And so that will give you an array.

00:20:07.220 --> 00:20:12.310
And once you've chosen the particular
subtitle alternate you'd like to display,

00:20:12.310 --> 00:20:14.880
you just tell the player item.

00:20:14.880 --> 00:20:17.420
So you select this media option
from this selection group.

00:20:17.540 --> 00:20:21.270
And at that point,
the next time we see sub C,

00:20:21.430 --> 00:20:28.910
as we resume playback,
we will start displaying those subtitles.

00:20:30.130 --> 00:20:33.280
So that, in a nutshell,
is what you need to do.

00:20:33.320 --> 00:20:35.560
Let's quickly run over it.

00:20:35.560 --> 00:20:39.510
You've got to take your text and
take your movie and subtitle it.

00:20:39.540 --> 00:20:42.450
So VI, stopwatch, blah, blah, blah.

00:20:42.480 --> 00:20:43.510
Got a big VTT file.

00:20:43.780 --> 00:20:47.230
You've got to segment it into
a bunch of different chunks.

00:20:47.240 --> 00:20:49.140
You've got to put those
chunks up on a web server,

00:20:49.300 --> 00:20:52.420
create a playlist, a subtitle playlist
that has a list of URLs,

00:20:52.420 --> 00:20:56.780
and then you've got to put the subtitle
playlist into your master playlist using

00:20:57.100 --> 00:21:01.720
the media tag to indicate that it's one
of the eligible subtitles for that media.

00:21:01.960 --> 00:21:05.690
Then, at runtime, you have to look at the
asset and you've got to say,

00:21:05.800 --> 00:21:07.720
"Oh,
I've got English subtitles," and you've

00:21:07.720 --> 00:21:09.400
got to tell the player I didn't play it.

00:21:09.400 --> 00:21:11.460
At this point, you're there.

00:21:11.460 --> 00:21:15.590
You've got 70,
80% of anything anyone would

00:21:15.590 --> 00:21:17.100
want to know about subtitles.

00:21:17.260 --> 00:21:18.960
Now, that was so easy and it was so fast.

00:21:18.960 --> 00:21:21.410
I've actually got some time to
tell you about some of the other

00:21:21.510 --> 00:21:23.030
interesting things you can do.

00:21:23.170 --> 00:21:25.900
So let's look at that a little bit.

00:21:26.950 --> 00:21:31.160
I mentioned forced and
non-forced subtitles earlier.

00:21:31.210 --> 00:21:33.400
I'd like to talk about that a little bit.

00:21:33.400 --> 00:21:36.050
The case of forced subtitles
where you're throwing up a

00:21:36.050 --> 00:21:38.780
subtitle in front of someone even
if they haven't asked for it.

00:21:38.930 --> 00:21:41.250
You would ask, "Well,
why would you do that?" Well,

00:21:41.260 --> 00:21:42.350
there's a few different reasons.

00:21:42.350 --> 00:21:43.700
Your lawyers may have told you that,
"Yeah,

00:21:43.700 --> 00:21:47.530
we'd really like to show a localized
legal notice whenever someone watches

00:21:47.640 --> 00:21:54.130
this particular segment of video." A more
common use for forced subtitles is that

00:21:54.360 --> 00:21:58.030
you may have a character in your movie
or what have you who's speaking in a

00:21:58.030 --> 00:22:02.040
language that he understands but the
audience is not expected to understand.

00:22:02.230 --> 00:22:03.960
And so he may be speaking Swahili.

00:22:03.960 --> 00:22:06.740
You may want to force a subtitle
to come up at the bottom that

00:22:06.760 --> 00:22:10.730
translates what he's saying
in English for the rest of the

00:22:10.940 --> 00:22:16.050
An interesting point about non-forced
subtitles and forced subtitles is

00:22:16.050 --> 00:22:21.010
that we're only going to display
a single subtitle track at a time.

00:22:21.010 --> 00:22:24.590
And the consequence of that is that
if you have a situation where you

00:22:24.590 --> 00:22:28.310
have some forced subtitles and then
you go off and you author a set

00:22:28.310 --> 00:22:31.550
of regular subtitles that has all
the dialogue and everything in it,

00:22:31.760 --> 00:22:35.320
you've got to make sure to include
all the forced subtitle content in

00:22:35.580 --> 00:22:40.770
the non-forced subtitle playlist so
that the user doesn't miss anything.

00:22:40.800 --> 00:22:42.270
of that.

00:22:43.300 --> 00:24:18.400
[Transcript missing]

00:24:18.530 --> 00:24:20.580
If you author or when you
author these subtitles,

00:24:20.580 --> 00:24:24.370
because we encourage you to,
these subtitles,

00:24:24.370 --> 00:24:27.690
just by way of introduction,
in addition to having the

00:24:27.690 --> 00:24:30.420
regular dialogue that people
are speaking on screen,

00:24:30.420 --> 00:24:32.690
also include things like sound effects.

00:24:32.780 --> 00:24:37.220
And so if in the movie a gunshot
happens off screen and it's important

00:24:37.220 --> 00:24:40.540
for the viewer to know about it in
order to understand what's going on,

00:24:40.670 --> 00:24:43.650
then an SDH subtitle
will come up and go bang,

00:24:43.660 --> 00:24:45.970
you know,
and it'll indicate that there's,

00:24:45.970 --> 00:24:48.900
you know,
what's happened to someone who's deaf.

00:24:48.960 --> 00:24:51.550
And so if you author
these subtitle tracks,

00:24:51.550 --> 00:24:54.920
we ask that you tag them with
these two characteristics,

00:24:55.020 --> 00:24:58.630
public.accessibility.transcribes
spoken dialogue and

00:24:58.630 --> 00:25:02.300
public.accessibility.describes
music and sound.

00:25:02.370 --> 00:25:02.760
And so if you author these subtitles,
you can get details about

00:25:02.760 --> 00:25:02.760
how you're going to use them.

00:25:02.920 --> 00:25:06.560
And that way, if you or we,
we can look at the set of subtitles

00:25:06.720 --> 00:25:11.530
and we can know specifically the
semantic intent of that particular set.

00:25:13.290 --> 00:25:16.360
I'll show you an example here of this.

00:25:16.360 --> 00:25:19.310
One of the things I wanted to
mention was that it's conventional

00:25:19.310 --> 00:25:22.610
when doing SDH subtitles that
they're actually rendered in a

00:25:22.610 --> 00:25:24.200
non-default position in the screen.

00:25:24.200 --> 00:25:27.200
Normally by default we render
subtitles at the bottom of the screen.

00:25:27.200 --> 00:25:32.200
To distinguish SDH from regular dialogue,
they're often rendered at the top.

00:25:32.370 --> 00:25:34.630
And that actually brings
up another important point

00:25:34.720 --> 00:25:38.270
about authoring subtitles,
which is it's often useful or necessary

00:25:38.270 --> 00:25:40.020
to move subtitles out of the way.

00:25:40.200 --> 00:25:43.510
We have an example screenshot
here of Phil who's talking about

00:25:43.510 --> 00:25:45.200
some random thing or other.

00:25:45.200 --> 00:25:49.200
And had we put that subtitle
in the default position,

00:25:49.200 --> 00:25:54.200
it would have actually covered the text
that's burned in as part of the video.

00:25:54.200 --> 00:25:56.200
And so we had to move it out of the way.

00:25:56.200 --> 00:26:00.190
WebVTT gives you a pretty
good range of capabilities,

00:26:00.190 --> 00:26:01.200
a pretty flexible set of tools
for web and web streaming.

00:26:01.200 --> 00:26:03.440
And so we have a set of
tools for controlling the

00:26:03.440 --> 00:26:05.200
positioning of the subtitles.

00:26:05.200 --> 00:26:09.630
The first and most perhaps easiest to
use is you can simply put a line break

00:26:09.630 --> 00:26:14.200
in your subtitle text and that will
be broken the same way on the screen.

00:26:14.200 --> 00:26:17.150
Beyond that,
the queue can have a number of

00:26:17.150 --> 00:26:20.200
positioning directives attached to it.

00:26:20.200 --> 00:26:23.040
And in this case we have the
line directive which controls the

00:26:23.050 --> 00:26:27.080
vertical positioning and we have
the align directive which controls,

00:26:27.340 --> 00:26:32.140
at least in left to right text,
it tells us that we want to begin

00:26:32.140 --> 00:26:36.180
the text at the left edge of the
screen or the display surface.

00:26:36.290 --> 00:26:39.190
There's a whole range of these and
they give you pretty good control.

00:26:39.200 --> 00:26:43.180
And so that's how you do that.

00:26:43.690 --> 00:26:46.660
The next thing that's interesting
in subtitles typically is you want

00:26:46.660 --> 00:26:48.430
to actually style your subtitles.

00:26:48.440 --> 00:26:51.010
I mean what we have is great,
but you might want to sort

00:26:51.010 --> 00:26:52.590
of jazz it up a little bit.

00:26:52.700 --> 00:26:55.800
WebVTT provides a small
number of built-in styles,

00:26:55.800 --> 00:26:58.560
bold, italic, underline essentially.

00:26:58.620 --> 00:27:00.600
And if you've ever done
any HTML authoring,

00:27:00.600 --> 00:27:06.600
then this will be very familiar
and very easy for you to adopt.

00:27:06.600 --> 00:27:15.470
And you can see in our default
rendering how that looks.

00:27:15.470 --> 00:27:15.470
We have Johnny saying he's emboldened
and he's emphasized in bold and italic.

00:27:16.100 --> 00:27:18.950
If you want to go beyond
this limited range,

00:27:18.990 --> 00:27:22.050
I mean, let's say you want to change this
font size or you want to make it a

00:27:22.130 --> 00:27:25.340
different color or maybe you want
to pick a different font completely,

00:27:25.460 --> 00:27:27.040
you can do that too.

00:27:27.140 --> 00:27:31.790
And doing that requires a little
bit of authoring and a little

00:27:31.890 --> 00:27:34.490
bit of programmatic control.

00:27:35.500 --> 00:27:41.530
WebVTT actually borrowed a
bunch of the CSS class syntax,

00:27:41.560 --> 00:27:44.500
a bunch of the class syntax from CSS.

00:27:44.590 --> 00:27:48.820
And what this means effectively
is that you can take some of your

00:27:48.920 --> 00:27:54.630
subtitle text and you can tag it with
what are called CSS class selectors.

00:27:54.760 --> 00:27:59.410
And so in our example here,
the word breakthrough in Phil's

00:27:59.540 --> 00:28:04.710
subtitle has been tagged with the
class that has a selector .huge.

00:28:05.410 --> 00:28:09.580
So that tells us that some kind of
styling needs to be applied to that text.

00:28:09.640 --> 00:28:14.700
What controls what it is precisely
is called a text style rule.

00:28:14.890 --> 00:28:18.740
In a web context,
this information might come from

00:28:18.740 --> 00:28:20.900
a CSS cascading style sheet.

00:28:21.350 --> 00:28:26.100
In HTTP live streaming,
it's provided by you programmatically.

00:28:26.230 --> 00:28:31.080
So a text style rule is
essentially a set of markup rules,

00:28:31.160 --> 00:28:35.000
text markup rules,
and associated text selector.

00:28:35.060 --> 00:28:38.790
And so in this example here,
we're creating a text style

00:28:38.790 --> 00:28:41.900
rule that changes the relative
font size of the text.

00:28:41.950 --> 00:28:45.000
And we've associated
with the selector.huge.

00:28:45.060 --> 00:28:48.470
Once we've set up our styles,
we set it on the player item,

00:28:48.470 --> 00:28:50.460
the text style rule's property.

00:28:50.490 --> 00:28:55.230
And from that point on, during playback,
those styles will be applied to any

00:28:55.350 --> 00:28:58.890
text which has that text selector.

00:28:59.850 --> 00:29:03.970
One of the more widely used
kind of styling that happens in

00:29:03.970 --> 00:29:06.400
subtitles is per-voice styling.

00:29:06.400 --> 00:29:09.650
This is fairly common in situations
where you have multiple characters

00:29:09.740 --> 00:29:13.360
and they're talking at once and it
can be -- in order to help the viewer

00:29:13.710 --> 00:29:17.520
keep straight who's saying what,
you'd like to actually tag each

00:29:17.520 --> 00:29:19.720
voice with a particular style.

00:29:19.720 --> 00:29:24.260
And so WebVTT provided a
special syntax for this,

00:29:24.270 --> 00:29:26.080
which is V space voice name.

00:29:26.080 --> 00:29:30.180
And so you can tag all the comments by
-- from one character with one voice

00:29:30.180 --> 00:29:33.620
and all the comments from a different
character with a different voice.

00:29:33.620 --> 00:29:36.980
And then, again, programmatically,
you can set the style

00:29:36.980 --> 00:29:38.840
for that voice selector.

00:29:38.960 --> 00:29:41.440
And in this case,
what I've done is I've said

00:29:41.790 --> 00:29:44.970
that Johnny should be light
blue and Phil should be red.

00:29:45.160 --> 00:29:48.180
And so you can see the result
here at the bottom of the screen.

00:29:48.180 --> 00:29:49.460
Johnny says so capable.

00:29:49.460 --> 00:29:52.460
Phil says the iPhone was a revolution.

00:29:54.180 --> 00:29:57.110
The last thing I'd like to talk about
when it comes to WebVTT styling is

00:29:57.200 --> 00:30:01.560
kind of a fun little thing where
you can actually animate the styles.

00:30:01.660 --> 00:30:06.480
And how this is implemented is
that you can see here we have

00:30:06.480 --> 00:30:08.380
an example queue that says,
"My heart cries for

00:30:08.510 --> 00:30:10.940
you." It's five words,
five seconds long.

00:30:11.010 --> 00:30:14.960
But it actually has timestamps
interspersed throughout the queue itself.

00:30:15.020 --> 00:30:18.220
And what this has effectively
done is it has divided the queue

00:30:18.520 --> 00:30:20.860
into a series of five time ranges.

00:30:20.940 --> 00:30:24.370
That means that while the queue
is up for that five seconds,

00:30:24.370 --> 00:30:28.870
the rendering system knows that,
let's say, in a time between 12

00:30:28.950 --> 00:30:33.510
seconds and 13 seconds,
that the first two words are in the past

00:30:33.770 --> 00:30:37.290
and the last two words are in the future.

00:30:38.190 --> 00:30:41.260
WebVTT defines special
styles for past and future,

00:30:41.260 --> 00:30:42.940
and so you can set up
a special appearance.

00:30:42.980 --> 00:30:47.120
And if you do this and you have
this kind of animated text,

00:30:47.350 --> 00:30:50.910
as we render the text,
as a part of the queue

00:30:50.910 --> 00:30:54.800
moves into the past,
it will be given the past style,

00:30:54.800 --> 00:30:57.880
and as while it's in the future,
it will be given the future style.

00:30:57.950 --> 00:31:00.340
I don't have a good screenshot for this.

00:31:00.340 --> 00:31:02.980
The easiest way is actually
to demo it for you.

00:31:02.980 --> 00:31:05.280
And so what I'd like to do
now is bring up Bill May,

00:31:05.280 --> 00:31:10.970
who implemented a bunch of this subtitle
stuff to help me show you subtitles

00:31:10.970 --> 00:31:14.500
in WebVTT and HTTP live streaming.

00:31:14.500 --> 00:31:16.420
So if we could switch to the demo iPad.

00:31:16.420 --> 00:31:21.070
So what I'd like to show you first
is just some regular subtitles.

00:31:21.080 --> 00:31:23.530
We have our favorite clip
of Phil and John here,

00:31:23.530 --> 00:31:25.020
so let's run that guy.

00:31:25.020 --> 00:31:26.820
You know, it's true.

00:31:26.820 --> 00:31:31.350
When something exceeds your
ability to understand how it works,

00:31:31.370 --> 00:31:33.540
it sort of becomes magical.

00:31:33.540 --> 00:31:35.610
So Johnny is speaking in English.

00:31:35.610 --> 00:31:35.620
Subtitles in English.

00:31:35.620 --> 00:31:39.860
Kind of shows the point,
but not as exciting.

00:31:39.950 --> 00:31:43.590
As I said, however, though,
you can have multiple subtitles

00:31:43.590 --> 00:31:45.260
associated with a particular stream.

00:31:45.260 --> 00:31:48.400
And so I'm going to ask Bill to
pop up the options box here.

00:31:48.400 --> 00:31:51.500
You can see in our case that we've
rendered two sets of subtitles,

00:31:51.500 --> 00:31:53.240
one's in English and one's in Chinese.

00:31:53.240 --> 00:31:56.110
So let's choose the Chinese version.

00:31:56.330 --> 00:31:58.690
and kind of caught Phil at
a bad moment there.

00:31:58.700 --> 00:32:03.620
Come on, Phil, you can do it.

00:32:03.970 --> 00:32:06.380
So many amazing technologies,
all the applications,

00:32:06.430 --> 00:32:07.720
the multi-touch user interface.

00:32:07.720 --> 00:32:11.820
Okay, but anyway, now Phil,
speaking in English, subtitle in Chinese.

00:32:11.820 --> 00:32:14.140
I think it makes Phil look
more sophisticated.

00:32:14.140 --> 00:32:14.840
I don't know.

00:32:14.840 --> 00:32:15.620
It's just me.

00:32:15.620 --> 00:32:21.120
So those are sort of our simple
default rendering subtitles.

00:32:21.120 --> 00:32:23.770
What I'd like to do now
is show you another clip,

00:32:23.840 --> 00:32:26.880
and this clip has some kid soccer,
and what makes it interesting is that

00:32:26.930 --> 00:32:31.060
in addition to sort of regular dialogue,
it also has some sounds

00:32:31.060 --> 00:32:33.140
and some music in it.

00:32:33.620 --> 00:32:34.910
And so let's see how that can look.

00:32:35.000 --> 00:32:36.640
So let's start playing it.

00:32:36.640 --> 00:32:40.300
And what you can see here is if you
look at the bottom of the screen,

00:32:40.300 --> 00:32:44.080
you see what the kids are saying,
and if you look at the top of the screen,

00:32:44.080 --> 00:32:50.240
there is some SDH dialogue,
like kids cheering or what have you.

00:32:50.260 --> 00:32:56.180
Now, what I mentioned before was that in
addition to placing the SDH subtitles,

00:32:56.180 --> 00:32:57.760
the sound effects,
at the top of the screen,

00:32:57.760 --> 00:33:00.180
it's also pretty conventional
to give them a different style,

00:33:00.180 --> 00:33:03.340
again, so they can stand out a little
bit more from the regular dialogue

00:33:03.340 --> 00:33:08.700
and so Bill can take a look
at the text style rules there,

00:33:08.700 --> 00:33:10.880
and you can see that we've
got the default style rules,

00:33:10.950 --> 00:33:12.280
we've also got the fancy rules.

00:33:12.280 --> 00:33:15.100
So let's choose fancy and
play a little bit more.

00:33:15.100 --> 00:33:19.720
And now what you'll see is that when we
have some of the sound effects coming up,

00:33:19.770 --> 00:33:22.290
like the kids laughing,
then that actually has

00:33:22.290 --> 00:33:25.360
dynamically changed from being
white to default to yellow.

00:33:25.360 --> 00:33:30.040
So let's go again.

00:33:30.800 --> 00:34:38.900
[Transcript missing]

00:34:39.300 --> 00:34:46.290
So, let's talk about some additional
stuff that we have for you in iOS 6.

00:34:46.430 --> 00:34:50.360
The first thing I want to mention
is that you remember last year

00:34:50.360 --> 00:34:55.940
when we were talking about iOS 5,
we introduced fast forward and rewind

00:34:56.040 --> 00:34:59.060
playback using iframe playlists.

00:34:59.060 --> 00:35:03.460
We didn't quite get to the point in sort
of the mad stampede to get iOS 5 shipped.

00:35:03.460 --> 00:35:06.360
We didn't hook that up in
MPMoviePlayerController.

00:35:06.360 --> 00:35:09.130
So people who are using
MPMoviePlayerController and want to play

00:35:09.220 --> 00:35:10.830
their content were kind of left out.

00:35:10.840 --> 00:35:15.000
So we've gone and we've
redressed that in iOS 6.

00:35:15.100 --> 00:35:17.300
So now you can see here using
MPMoviePlayerController,

00:35:17.300 --> 00:35:19.940
you can go into fast forward
mode and then go back into

00:35:19.940 --> 00:35:21.510
your normal playback mode.

00:35:21.550 --> 00:35:26.840
And so all you need is an iframe
playlist and now it's there for you now.

00:35:27.330 --> 00:35:32.180
The next thing I'd like to talk about
is actually kind of a favorite of mine.

00:35:32.180 --> 00:35:38.170
And this is glitch-free switching
between different audio encodings.

00:35:38.410 --> 00:35:42.460
You might remember that ever since
the beginning of HTTP live streaming,

00:35:42.550 --> 00:35:46.910
we've always told you, you can have your
variable bit rate video,

00:35:46.910 --> 00:35:47.540
right?

00:35:47.540 --> 00:35:50.940
You can have your video at your 12
different bit rates or whatever.

00:35:51.110 --> 00:35:54.310
But you should keep the same
audio encoding across all the

00:35:54.550 --> 00:35:56.300
different bit rates of video.

00:35:56.300 --> 00:36:01.630
And the reason we told you this, frankly,
is because it's just hard.

00:36:01.820 --> 00:36:06.490
It's just difficult to transition
from one audio encoding to

00:36:06.600 --> 00:36:08.280
a different audio encoding.

00:36:08.300 --> 00:36:11.390
During playback,
without producing something audible,

00:36:11.390 --> 00:36:14.460
without producing a glitch or
a pop or a gap in the audio.

00:36:14.460 --> 00:36:19.190
And we don't want our content to
look like that or to sound like that.

00:36:19.250 --> 00:36:22.040
And we didn't want to inflict
that on any of you either.

00:36:22.040 --> 00:36:26.290
So, fair enough.

00:36:26.290 --> 00:36:26.290
But, of course, we're

00:36:26.510 --> 00:36:28.920
The implication of this,
and someone reminded me of

00:36:28.920 --> 00:36:33.040
this in the lab just yesterday,
was that, okay, I'm an app developer.

00:36:33.040 --> 00:36:35.240
I want my app approved over 3G.

00:36:35.240 --> 00:36:38.720
So Apple's telling me that I need
a 64 kilobit audio only stream,

00:36:38.720 --> 00:36:41.540
not necessarily only,
but a 64 kilobit stream to meet

00:36:41.600 --> 00:36:43.570
the 3G approval requirements.

00:36:43.630 --> 00:36:47.550
So my audio can't be any
higher than 64 kilobits.

00:36:47.550 --> 00:36:49.320
Okay, that's fine.

00:36:49.320 --> 00:36:54.800
But I also have a 5 megabit 720p stream,
gorgeous video.

00:36:54.800 --> 00:37:00.020
You're telling me that I've got
to use the same not so great 64

00:37:00.020 --> 00:37:05.200
kilobit audio in my beautiful,
gorgeous 720p video?

00:37:05.280 --> 00:37:08.410
And so the wailing of the
gnashing of teeth and et cetera,

00:37:08.410 --> 00:37:09.270
et cetera.

00:37:09.270 --> 00:37:09.270
So, I'm

00:37:09.900 --> 00:37:14.100
We went back and we looked at
this in iOS 6 and it is difficult.

00:37:14.180 --> 00:37:17.090
It is tricky, but it's not impossible.

00:37:17.280 --> 00:37:20.540
We went in,
we fixed a bunch of edge cases,

00:37:20.540 --> 00:37:23.730
we sat down with our audio guys,
we put our heads together,

00:37:23.820 --> 00:37:27.010
and we made it work.

00:37:27.490 --> 00:37:31.440
You do have to have timestamps
that are perfectly in sync between

00:37:31.440 --> 00:37:34.260
your different audio encodings
for this to work perfectly,

00:37:34.340 --> 00:37:40.490
including getting the right timestamps on
the priming packets if you're using AAC.

00:37:40.980 --> 00:37:45.900
But if you do, it sounds, muah,
it's great.

00:37:46.030 --> 00:37:48.400
And I'm gonna actually
play a little bit for you.

00:37:48.500 --> 00:37:50.880
So let's start with,
we pulled out some audio here.

00:37:50.880 --> 00:37:52.560
We encoded a fairly high bit rate.

00:37:52.780 --> 00:37:55.810
So fairly good quality audio encoding.

00:38:00.190 --> 00:38:06.310
And then we took the same audio clip and
we just compressed the heck out of it.

00:38:06.460 --> 00:38:09.180
And so I'm going to play it for you now.

00:38:12.700 --> 00:38:15.260
Actually doesn't sound that bad.

00:38:15.260 --> 00:38:19.060
And it's not, really,
for given how much it's been compressed.

00:38:19.060 --> 00:38:22.270
But what's hard to tell,
unless you're doing a

00:38:22.270 --> 00:38:24.880
side-to-side comparison,
is that a consequence of that

00:38:25.060 --> 00:38:28.690
compression is that all the high
frequencies have been cut off.

00:38:28.760 --> 00:38:31.080
And this is actually really
important because this is a fugue

00:38:31.080 --> 00:38:33.920
and there's some interesting stuff
going on in those high registers.

00:38:34.400 --> 00:38:38.280
And so what I'm going to show you
next is a transition that we actually

00:38:38.430 --> 00:38:43.090
recorded yesterday of the stream player
switching up from that low quality I just

00:38:43.240 --> 00:38:44.990
played from you to the high quality.

00:38:45.120 --> 00:38:47.970
And if you listen carefully,
you can hear where it switches

00:38:47.970 --> 00:38:51.070
and it's just like suddenly all
the high frequencies come back.

00:38:51.210 --> 00:38:55.190
And so let's listen.

00:39:03.700 --> 00:39:04.290
Didn't quite get it.

00:39:04.400 --> 00:39:05.760
It sounded pretty good, doesn't it?

00:39:05.870 --> 00:39:06.800
Let's listen to it once more.

00:39:06.800 --> 00:39:15.510
I heard it,
but I've heard this clip like,

00:39:15.530 --> 00:39:17.340
I don't know, 30 times before.

00:39:17.340 --> 00:39:19.320
But that was a switch.

00:39:19.370 --> 00:39:21.620
It happened about halfway through,
and we went from the low

00:39:21.620 --> 00:39:22.790
quality to the high quality.

00:39:22.790 --> 00:39:25.010
If you come by in the lab
later with a set of headphones,

00:39:25.010 --> 00:39:26.250
I can actually play it for you.

00:39:26.410 --> 00:39:29.900
But the important takeaway
was that it sounded perfect.

00:39:29.900 --> 00:39:33.560
There was no audible gap
or discontinuity there.

00:39:33.560 --> 00:39:37.130
We just seamlessly transitioned
from one audio to the other.

00:39:37.270 --> 00:39:40.230
And so we're hoping that this
gives you more flexibility

00:39:40.340 --> 00:39:41.740
when you author your streams.

00:39:43.330 --> 00:39:46.480
Next is another audio feature,
and that's AC3.

00:39:46.570 --> 00:39:52.320
AC3 is also known as Dolby Digital's
5.1 multi-channel surround sound.

00:39:52.440 --> 00:39:59.810
And we don't do a lot of surround
sound on iPhones and iPads because,

00:39:59.990 --> 00:40:03.120
you know,
when you take 5.1 multi-channel sound,

00:40:03.120 --> 00:40:05.810
you decode it,
then you remix it into mono and

00:40:05.810 --> 00:40:09.540
you put it out the back speaker,
you're kind of losing some

00:40:09.540 --> 00:40:11.670
of the richness there.

00:40:11.830 --> 00:40:14.900
That changes, however,
if said device is hooked up

00:40:14.900 --> 00:40:18.970
to an actual audio system
that has a 5.1 speaker setup.

00:40:19.110 --> 00:40:22.040
It can make the experience
much more rich in that case.

00:40:22.160 --> 00:40:25.500
And so there's a couple of
different ways that can happen,

00:40:25.500 --> 00:40:25.880
of course.

00:40:25.960 --> 00:40:29.450
One is you can go buy our $50 little
HDMI connector and you can plug

00:40:29.450 --> 00:40:34.490
it in and hook it up to your audio
receiver or your TV with 5.1 surround.

00:40:34.750 --> 00:40:36.680
Another way,
which is probably more common,

00:40:36.910 --> 00:40:40.260
is your content can be airplayed
to an Apple TV that's connected

00:40:40.260 --> 00:40:41.700
to someone's home theater system.

00:40:41.700 --> 00:40:45.270
And in that case,
it would be really nice to provide

00:40:45.540 --> 00:40:48.990
them with 5.1 multi-channel surround.

00:40:49.200 --> 00:40:51.730
So you can do that.

00:40:51.920 --> 00:40:56.880
Having said it, you don't know ahead of
time whether said device,

00:40:57.030 --> 00:40:59.800
said user has his 5.1
system set up and turned on,

00:40:59.800 --> 00:41:00.650
what have you.

00:41:00.880 --> 00:41:05.670
And so if you're going to provide AC3,
you need to still provide the

00:41:05.670 --> 00:41:08.400
same content also encoded for AC3.

00:41:08.400 --> 00:41:11.700
So that way,
if we're hooked up to a 5.1 system,

00:41:11.700 --> 00:41:11.700
we're going to be able to do that.

00:41:11.700 --> 00:41:14.810
If we're hooked up to a 5.1 system,
we'll detect it and we'll

00:41:14.860 --> 00:41:16.700
automatically choose your AC3.

00:41:16.700 --> 00:41:21.940
If not, we'll choose the AC and
we'll play as we always have.

00:41:21.940 --> 00:41:26.140
This selection is made once when
you start playing back your item.

00:41:26.140 --> 00:41:32.380
And it really is a once --
it's an all or nothing deal.

00:41:32.380 --> 00:41:36.370
And that means that if we choose AC3,
we're only going to switch

00:41:36.500 --> 00:41:38.500
between the AC3 variants.

00:41:38.500 --> 00:41:41.700
We're not going to switch back
and forth between AC3 and AC.

00:41:41.740 --> 00:41:45.030
All your content must be
AC3 within that variant,

00:41:45.030 --> 00:41:48.850
which means your main content
and your ads both have to be AC3.

00:41:48.910 --> 00:41:53.950
The reason for this is because the
process of switching between PCM output

00:41:54.200 --> 00:41:58.150
and AC3 on today's hardware is ugly.

00:41:58.500 --> 00:42:02.660
It takes like three to
five seconds to happen.

00:42:02.720 --> 00:42:06.050
It is often accompanied by some
ugly and disturbing clunks and

00:42:06.050 --> 00:42:08.160
clonks from your audio equipment.

00:42:08.200 --> 00:42:11.450
And so we're not going
to switch back and forth.

00:42:12.000 --> 00:42:15.690
You can provide AC3, but if you do,
all or nothing,

00:42:15.710 --> 00:42:18.970
you've got to have AC3 for all your
different bit rates or all the ones

00:42:18.970 --> 00:42:23.600
you choose to expose for AC3 and
all the content within that variant.

00:42:24.250 --> 00:42:28.100
How you do it is you simply add
another variant to your playlist file.

00:42:28.100 --> 00:42:32.520
You indicate in the codex attribute
that it's AC3 and that tells us,

00:42:32.640 --> 00:42:34.680
ah, this stream has AC3.

00:42:34.680 --> 00:42:37.740
I should go check to see if
we're connected to AC3 and

00:42:37.820 --> 00:42:39.420
throw that switch if so.

00:42:39.420 --> 00:42:43.790
For the simplicity here,
these two variants have just been,

00:42:43.900 --> 00:42:48.360
I've taken, the video is,
I've muxed in AC3 in one instance,

00:42:48.360 --> 00:42:51.440
I've muxed in AAC in the other instance.

00:42:51.440 --> 00:42:52.280
You can do it that way.

00:42:52.280 --> 00:42:53.540
That's the easiest way to do it.

00:42:54.080 --> 00:42:57.510
You can also take your AAC and put
it into an audio only playlist,

00:42:57.860 --> 00:43:00.280
take your AC3,
put it into a separate audio only

00:43:00.610 --> 00:43:04.620
playlist and use the media tag so you
don't have to duplicate your video.

00:43:04.620 --> 00:43:06.780
That's probably the more
efficient way to go.

00:43:06.820 --> 00:43:09.900
But those are how you put
things together to get AAC.

00:43:09.910 --> 00:43:14.020
And for premium content,
I know that there is a fair amount of

00:43:14.020 --> 00:43:18.960
demand amongst the more discriminating
users for this and so we hope that

00:43:18.960 --> 00:43:22.010
this will help you satisfy that demand.

00:43:22.510 --> 00:43:26.400
In terms of other tweaks
that we've done for iOS 6,

00:43:26.450 --> 00:43:30.850
we spent some time working
on our algorithms that decide

00:43:31.040 --> 00:43:33.120
when to switch bit rates.

00:43:33.210 --> 00:43:36.920
And specifically we had two focus areas.

00:43:37.050 --> 00:43:41.870
The first was how we switch up
and where we decide to switch up.

00:43:41.970 --> 00:43:47.390
And the focus of that was to detect
when the network connection has

00:43:47.390 --> 00:43:49.990
a relatively stable bandwidth,
which is to say the bandwidth

00:43:49.990 --> 00:43:53.310
the network is delivering is not
fluctuating crazily like this.

00:43:53.510 --> 00:43:58.920
If it's more steady, if it's more stable,
then we will actually choose

00:43:58.980 --> 00:44:03.170
a bit rate that is higher,
closer to that theoretical

00:44:03.170 --> 00:44:07.040
ceiling of what the network can
deliver than we would previously

00:44:07.420 --> 00:44:08.970
in earlier versions of iOS.

00:44:09.090 --> 00:44:13.240
We call this reducing
the bandwidth cushion.

00:44:13.390 --> 00:44:16.800
Correspondingly,
if you're on a very kind of highly

00:44:17.300 --> 00:44:18.880
fluctuating network and you're on
a very highly fluctuating network,

00:44:18.880 --> 00:44:21.660
and then sort of 3G comes to mind,
we may not switch up

00:44:21.660 --> 00:44:24.520
quite as optimistically,
because we're going to be a little bit

00:44:24.600 --> 00:44:28.020
more conservative because we realize
that the network is incredibly variable.

00:44:28.020 --> 00:44:30.700
And even though it might be fast now,
it might not be fast

00:44:30.700 --> 00:44:32.000
two seconds from now.

00:44:32.050 --> 00:44:36.120
And if we decide to switch up,
then we might subsequently stall.

00:44:36.160 --> 00:44:39.570
That actually takes us into
the second area of focus,

00:44:39.570 --> 00:44:42.200
which was the switch down algorithm.

00:44:42.220 --> 00:44:46.270
And what we focused on there was
to try to identify points at which

00:44:46.550 --> 00:44:50.880
bandwidth is dropping rapidly,
more quickly than we have previously,

00:44:50.880 --> 00:44:54.560
and switch to a lower bit rate so
that we actually transition to a

00:44:54.560 --> 00:45:00.100
lower quality prior to the stall,
and we don't stall as a consequence.

00:45:00.200 --> 00:45:05.010
And so both of these are not
really -- they're not really

00:45:05.010 --> 00:45:06.390
exposed to you as developers.

00:45:06.510 --> 00:45:11.340
We do expect you to see, in general,
better switching behavior in iOS 6.

00:45:11.340 --> 00:45:13.080
So we'd like you,
when you install the seed,

00:45:13.080 --> 00:45:14.640
you test your apps,
you test your streams,

00:45:14.740 --> 00:45:17.190
to be kind of on the lookout for this.

00:45:17.270 --> 00:45:18.680
In general,
it should sort of be a little bit

00:45:18.680 --> 00:45:18.680
faster than we have previously,
and we're not going

00:45:18.680 --> 00:45:18.680
to be able to do that.

00:45:18.760 --> 00:45:25.790
So we're hoping that this
will lead to better quality

00:45:25.790 --> 00:45:29.880
for users and fewer stalls.

00:45:30.780 --> 00:45:33.830
Of course, at some point,
you're always going to stall, right?

00:45:33.870 --> 00:45:35.700
There's some circumstances where
you're just going to stall.

00:45:35.700 --> 00:45:38.740
The network just can't keep up
with what you're trying to deliver.

00:45:38.740 --> 00:45:41.650
And so we've added a new
API in iOS 6 as well,

00:45:41.650 --> 00:45:46.880
and this is an explicit notification
of playback data starvation.

00:45:46.880 --> 00:45:50.500
The reason we added this was
because we had some folks who

00:45:50.650 --> 00:45:55.080
were trying to do some quality of
service monitoring on their streams,

00:45:55.220 --> 00:45:58.350
and they wanted to know
when stalls occurred.

00:45:59.020 --> 00:46:03.060
The problem is that on iOS 5,
what a stall looks like to someone who's

00:46:03.060 --> 00:46:07.330
watching playback happen through their
AV player item is that the player item

00:46:07.330 --> 00:46:10.130
transitions from the playing state into
the buffering state for a little bit,

00:46:10.210 --> 00:46:11.700
then it transitions back
into the playing state.

00:46:11.720 --> 00:46:15.310
The problem is that that transition,
that a data starvation stall

00:46:15.380 --> 00:46:18.660
is not the only thing that
can trigger that transition.

00:46:18.660 --> 00:46:20.930
We will go through that
transition when you seek.

00:46:21.020 --> 00:46:26.420
We'll go through that transition when you
choose a different subtitle alternate.

00:46:27.140 --> 00:46:30.020
And there's a few other things that cause
us to go through that transition as well.

00:46:30.020 --> 00:46:32.600
They're not strictly about, "Oh,
I couldn't keep up because the

00:46:32.600 --> 00:46:35.510
network was too slow." And so
to help disambiguate that,

00:46:35.510 --> 00:46:39.250
we have a new notification that is
sent explicitly when we had to pause

00:46:39.320 --> 00:46:42.740
playback and rebuffer because the
network just wasn't fast enough.

00:46:43.160 --> 00:46:47.690
Possibly we had to switch
down at the same time.

00:46:48.540 --> 00:46:51.080
Speaking of quality
of service monitoring,

00:46:51.080 --> 00:46:52.900
we do encourage you to do so.

00:46:52.900 --> 00:46:56.010
We do encourage you to look at
the quality of service you're

00:46:56.010 --> 00:46:59.950
getting on your client devices and
validate your assumptions that your

00:46:59.950 --> 00:47:03.100
set of bit rates and everything
else is what you're expecting.

00:47:03.100 --> 00:47:06.230
And when you do this,
the access log and the

00:47:06.230 --> 00:47:08.500
error log are your friends.

00:47:08.500 --> 00:47:10.600
If you haven't looked at the
access log and the error log,

00:47:10.600 --> 00:47:13.100
they were introduced in
iOS 5 or 4.2 or something.

00:47:13.100 --> 00:47:16.370
And the access log is every
now and then through playback,

00:47:16.370 --> 00:47:19.370
we log some interesting
events like when we switch bit

00:47:19.450 --> 00:47:22.090
rates or when we see a stall,
a few other different things.

00:47:22.210 --> 00:47:27.100
And so it's kind of a ticker tape of what
happened during the -- during playback.

00:47:27.100 --> 00:47:31.730
When we run into hard errors like
when we get HTTP 404s on various

00:47:31.730 --> 00:47:35.040
parts of the -- on the playlist
or various parts of the playlist,

00:47:35.220 --> 00:47:37.100
those are put into the error log.

00:47:37.100 --> 00:47:41.090
So the access log and the error
log are even better in iOS 6.

00:47:41.100 --> 00:47:44.250
We've added some new fields to the
access log including the playback type,

00:47:44.250 --> 00:47:46.100
whether you're live, VOD, et cetera.

00:47:46.100 --> 00:47:48.720
We've added a lot more information
about the bandwidth we're

00:47:48.720 --> 00:47:52.320
observing from the network,
so the min, the max, standard deviation,

00:47:52.320 --> 00:47:56.100
and also what we saw at the point
where we decided we wanted to switch.

00:47:56.100 --> 00:48:01.040
And then we've also added some things
you can kind of keep an eye out for.

00:48:01.140 --> 00:48:03.240
For instance,
we have the number of segments

00:48:03.330 --> 00:48:06.100
that actually took longer
to download than real time.

00:48:06.100 --> 00:48:08.100
We had a 10-second segment,
took us 12 seconds to download.

00:48:08.100 --> 00:48:10.100
It's always a red flag.

00:48:10.100 --> 00:48:13.580
And the number of segments that
we downloaded over cellular,

00:48:13.580 --> 00:48:16.560
which can be interesting,
particularly in these -- this

00:48:16.860 --> 00:48:18.760
day and age of metered billing.

00:48:19.020 --> 00:48:22.500
And additionally,
we've enhanced what we put into the error

00:48:22.500 --> 00:48:23.800
log so there's more detail there now.

00:48:23.800 --> 00:48:25.740
If you're getting any
kind of playback error,

00:48:25.740 --> 00:48:29.240
particularly unexplained playback error,
the error log is the first place

00:48:29.270 --> 00:48:33.000
you should go and it may help
you understand why things failed.

00:48:35.330 --> 00:48:37.720
Speaking of the access
log and the error log,

00:48:37.860 --> 00:48:41.660
you no longer have to pull the
logs or use your special ESP powers

00:48:41.750 --> 00:48:44.190
to figure out when we've added
something new to those logs.

00:48:44.240 --> 00:48:48.130
In iOS 6,
we now have notifications you can listen

00:48:48.240 --> 00:48:52.440
to and we will fire those notifications
whenever a new entry is added to the log.

00:48:52.440 --> 00:48:56.250
And so you can keep an eye on those.

00:48:57.100 --> 00:49:03.900
[Transcript missing]

00:49:04.920 --> 00:49:07.090
Next, new API.

00:49:07.100 --> 00:49:13.820
This API is around making your
life easier when you're providing

00:49:14.110 --> 00:49:18.530
content for application defined URLs.

00:49:18.530 --> 00:49:22.500
And for those whom this is a new thing,
let me briefly explain.

00:49:22.990 --> 00:49:26.980
When you tell us to play a playlist
file or go get an encryption

00:49:26.980 --> 00:49:32.120
key or something like that,
those are specified as URLs.

00:49:32.120 --> 00:49:34.780
And in the normal course of affairs,
those are HTTP colon slash URL.

00:49:34.800 --> 00:49:37.670
And we go off and we load
them from network and we get

00:49:37.740 --> 00:49:39.390
the information that way.

00:49:39.410 --> 00:49:42.100
HTTPS often in the case
of encryption keys.

00:49:42.100 --> 00:49:43.920
But you have an alternative.

00:49:43.920 --> 00:49:46.900
And that is you can make
up your own URL scheme,

00:49:47.080 --> 00:49:49.400
you know, ABC colon slash slash.

00:49:49.400 --> 00:49:52.690
And you can give that to us
and say my playlist is at

00:49:52.690 --> 00:49:55.090
ABC colon slash slash playlist.

00:49:55.190 --> 00:49:56.560
Or what have you.

00:49:56.560 --> 00:50:00.250
And if you do that,
that tells us we have to go back

00:50:00.250 --> 00:50:03.080
and ask you for what the content is.

00:50:04.410 --> 00:50:05.980
Roger Pantoos There's a couple
of good reasons to do this.

00:50:05.980 --> 00:50:08.130
For playlist files,
this gives you the ability to

00:50:08.230 --> 00:50:09.920
customize your playlist files.

00:50:10.060 --> 00:50:12.320
For instance,
if you wanted to specify some ad

00:50:12.330 --> 00:50:15.630
content that was dynamically identified,
you wanted to sort of

00:50:15.630 --> 00:50:17.180
pick your ads at run time.

00:50:17.180 --> 00:50:21.850
Roger Pantoos And for encryption keys,
often you've already built a secure

00:50:21.940 --> 00:50:27.070
pipeline for delivering the encryption
keys from the cloud down to your client.

00:50:27.090 --> 00:50:31.820
And rather than have been then set up
an entirely new server infrastructure

00:50:31.820 --> 00:50:35.280
to sort of field our HTTPS requests,
you may want to smuggle it down to

00:50:35.280 --> 00:50:39.460
your application sideband and simply
hand it over to us when we need it.

00:50:39.650 --> 00:50:42.740
And so when you do that,
you can specify your keys

00:50:42.740 --> 00:50:44.510
using your custom URLs.

00:50:45.190 --> 00:50:49.340
The problem is in iOS 5,
in order to get this to work,

00:50:49.340 --> 00:50:52.660
you had to implement a global,
what's called an NSURL protocol.

00:50:52.660 --> 00:50:55.630
And it was global,
so the state was divorced from all your

00:50:55.690 --> 00:50:57.860
different objects in your application.

00:50:57.860 --> 00:51:01.090
And it was a little complicated and
it was a little tricky to get right.

00:51:01.100 --> 00:51:04.860
So in iOS 6, we've introduced a new API.

00:51:04.860 --> 00:51:09.110
There's a new object called
an asset resource loader.

00:51:09.120 --> 00:51:10.700
And an asset has one of these things.

00:51:10.700 --> 00:51:15.070
And this object mediates the access
to these kind of problematical URLs.

00:51:15.100 --> 00:51:19.870
And so what you can do is you can set,
your application can set

00:51:19.870 --> 00:51:22.360
a delegate on this object,
on the resource loader.

00:51:22.360 --> 00:51:25.170
And when it does,
when it comes time for us to load

00:51:25.280 --> 00:51:29.920
one of these URLs we don't recognize,
we will package that up in a request

00:51:29.920 --> 00:51:33.920
that includes the URL and the byte range,
if we're asking for a byte range.

00:51:33.950 --> 00:51:38.700
And we'll say, hey delegate,
this resource loader needs to load a URL.

00:51:38.700 --> 00:51:40.010
Should we wait for you to load it?

00:51:40.180 --> 00:51:40.730
Load us for it.

00:51:40.950 --> 00:51:42.000
Load it for us.

00:51:42.120 --> 00:51:43.920
So what you should do is you
should look at a request,

00:51:43.920 --> 00:51:47.320
look at the URL and see if it's your
ABC colon slash slash that you've

00:51:47.320 --> 00:51:48.450
decided you want to load for us.

00:51:48.500 --> 00:51:50.520
If it is, you should return yes.

00:51:50.620 --> 00:51:53.670
At that point, we will sit back,
we will twiddle our thumbs and you

00:51:53.700 --> 00:51:56.760
go off and you rummage around and you
come up with the content for that URL.

00:51:56.820 --> 00:51:59.700
Once you've got it,
you just tell the resource loader,

00:51:59.700 --> 00:52:02.820
here it is, you can finish your loading,
I've got this response.

00:52:02.820 --> 00:52:06.120
And then we'll go off on our merry
way and we'll continue playing.

00:52:06.870 --> 00:52:08.610
So,

00:52:08.860 --> 00:52:10.600
This is an extremely
straightforward process.

00:52:10.600 --> 00:52:13.340
It's much easier in NSURL protocol.

00:52:13.340 --> 00:52:16.180
You can tie it in to the rest
of your object framework.

00:52:16.180 --> 00:52:21.230
We hope this makes it easier to supply
your own content to us dynamically,

00:52:21.230 --> 00:52:25.910
your own playlists and keys dynamically,
and maybe it'll help you clean up

00:52:25.910 --> 00:52:26.880
your code a little bit as well.

00:52:28.960 --> 00:52:34.440
The last thing I want to talk about
today was sample level stream encryption.

00:52:34.450 --> 00:52:37.340
What we're doing here is we're
giving you an alternative

00:52:37.340 --> 00:52:39.930
way to encrypt your content.

00:52:40.940 --> 00:52:44.460
As you know, since the beginning,
we've had a provision

00:52:44.460 --> 00:52:46.720
for encrypting content,
and it was simply once

00:52:46.720 --> 00:52:49.240
you've got all your segments,
you take each segment file and

00:52:49.240 --> 00:52:50.280
you just encrypt the entire thing.

00:52:50.280 --> 00:52:52.260
And this has the benefit of simplicity.

00:52:52.260 --> 00:52:55.750
It's extremely easy to author,
and we do like it.

00:52:55.860 --> 00:52:57.500
But it has some downsides as well.

00:52:57.500 --> 00:53:02.180
One of the downsides is that
everything gets encrypted.

00:53:02.180 --> 00:53:04.510
All the structural
information in the file,

00:53:04.510 --> 00:53:07.180
all the padding,
of which in TS there can be a lot,

00:53:07.200 --> 00:53:09.250
and that means we have
to decrypt everything.

00:53:09.340 --> 00:53:12.160
Even though you don't have to decrypt
everything to protect your content,

00:53:12.160 --> 00:53:13.450
you only have to protect the samples.

00:53:13.460 --> 00:53:17.130
And so the fact that we have
to decrypt all this extra stuff

00:53:17.200 --> 00:53:21.120
on the device means more CPU,
which means worse battery.

00:53:21.120 --> 00:53:22.680
It's not an ideal situation.

00:53:22.680 --> 00:53:26.400
The other thing about just going
off and encrypting everything is you

00:53:26.400 --> 00:53:30.410
want your files to remain in their
encrypted state as much as possible.

00:53:30.440 --> 00:53:32.080
That's the most secure thing.

00:53:32.080 --> 00:53:35.180
And so you don't want to
have to decrypt your files.

00:53:35.220 --> 00:53:37.230
But while they're in
this encrypted state,

00:53:37.350 --> 00:53:41.520
when the entire file is encrypted,
any tools that you may be running

00:53:41.520 --> 00:53:45.920
that do things like segmentation or
validation or anything like that,

00:53:45.940 --> 00:53:49.300
those files are totally opaque
in their encrypted state.

00:53:49.300 --> 00:53:52.830
And so to do anything with them,
you have to decrypt them first.

00:53:52.900 --> 00:53:54.400
And so that's not an ideal thing either.

00:53:55.970 --> 00:53:59.410
So we're providing a new
alternative in iOS 6.

00:53:59.410 --> 00:54:04.240
And what we've done is we've defined
a format where only the elementary

00:54:04.240 --> 00:54:05.800
audio and video streams are encrypted.

00:54:05.860 --> 00:54:08.540
And that's basically media
engineer talk for just the samples.

00:54:08.540 --> 00:54:12.930
And so we just encrypt the samples
and then they're packetized and

00:54:12.930 --> 00:54:18.020
they're put into your standard .ts
files and AAC files in a regular way.

00:54:18.020 --> 00:54:21.250
And you end up with what looks pretty
much like a vanilla transport stream

00:54:21.250 --> 00:54:24.080
or a vanilla MPEG audio stream,
audio elementary stream.

00:54:24.480 --> 00:54:26.590
The difference, of course,
is if you look at the samples,

00:54:26.590 --> 00:54:29.200
they look like, you know,
they look like random crap.

00:54:29.200 --> 00:54:32.660
And so to help you not
get into trouble there,

00:54:32.780 --> 00:54:37.350
we have defined new stream
types for the encrypted variants

00:54:37.350 --> 00:54:39.710
in the transport streams.

00:54:39.720 --> 00:54:42.330
And, of course,
when the samples are encrypted,

00:54:42.330 --> 00:54:45.050
you can no longer sniff the
samples to detect what kind

00:54:45.110 --> 00:54:46.870
of codec you're going to need.

00:54:46.900 --> 00:54:50.940
And so we've also made a provision
for carrying the codec information for

00:54:50.950 --> 00:54:53.160
the audio setup in a new descriptor.

00:54:53.160 --> 00:54:55.120
So that's carried into clear.

00:54:55.120 --> 00:54:57.620
So you can just take a look
at that and you'll know,

00:54:57.620 --> 00:55:00.970
you know, and you can tell that
you'll need 128 kilobit AAC,

00:55:00.970 --> 00:55:02.740
44.1, what have you.

00:55:02.770 --> 00:55:06.720
To indicate to us that your
files are in this new format,

00:55:06.720 --> 00:55:11.790
you just have to use the new method
value that we'd find in the key tag.

00:55:11.870 --> 00:55:16.690
It's sample-aes instead
of the old aes128.

00:55:17.030 --> 00:55:20.240
Of course, to use it,
you need to be able to author them.

00:55:20.240 --> 00:55:24.940
And so we will be providing you
with the format details of this.

00:55:24.940 --> 00:55:30.340
We'll do it eventually, of course,
in a spec update of the internet draft.

00:55:30.340 --> 00:55:34.360
If you are authoring,
if you're responsible for an authoring

00:55:34.360 --> 00:55:38.470
tool yourself and you'd like to
know about the format earlier,

00:55:38.480 --> 00:55:42.500
contact us offline and we'll get
you set up with format details

00:55:42.500 --> 00:55:45.280
ahead of the public release so
you can get a head start on that.

00:55:45.780 --> 00:55:50.830
So that's it for iOS 6
for HTTP live streaming.

00:55:50.870 --> 00:55:53.320
What I like to say in summary
is now we've got subtitles.

00:55:53.420 --> 00:55:54.340
They're really easy to add.

00:55:54.340 --> 00:55:55.200
They're really easy to author.

00:55:55.200 --> 00:55:57.580
Go off, check them out.

00:55:57.800 --> 00:55:58.900
Come to us.

00:55:59.080 --> 00:56:00.980
Give us your feedback if you
have any on those subtitles.

00:56:01.640 --> 00:56:04.400
We have made significant
changes to the player engine.

00:56:04.400 --> 00:56:05.440
We've made some improvements.

00:56:05.440 --> 00:56:08.200
We've made some additions to the API.

00:56:08.200 --> 00:56:12.240
So install the seed, test your apps,
test your streams.

00:56:12.240 --> 00:56:15.360
Let us know if you see problems
and we'll see what we can do about

00:56:15.360 --> 00:56:17.440
addressing them before iOS 6 ships.

00:56:17.440 --> 00:56:21.640
And finally, if your app does AirPlay,
then all of these changes and

00:56:21.640 --> 00:56:25.340
improvements have been carried
over to Apple TV as well.

00:56:25.340 --> 00:56:28.000
If your app does AirPlay,
go off and buy an Apple TV.

00:56:28.000 --> 00:56:29.060
They're $99.

00:56:29.060 --> 00:56:31.590
Install a WWDC seed on it.

00:56:31.620 --> 00:56:32.980
Test out AirPlay.

00:56:32.980 --> 00:56:34.650
It should work better.

00:56:34.650 --> 00:56:36.920
We'd like to know if it doesn't.

00:56:37.040 --> 00:56:40.300
I'm hoping that I've given you
more than enough information,

00:56:40.300 --> 00:56:41.690
more than you could
ever want in this talk,

00:56:41.810 --> 00:56:42.500
of course.

00:56:42.540 --> 00:56:43.860
There's a possibility I haven't.

00:56:44.320 --> 00:56:47.730
And so if not,
the first place you should look

00:56:47.730 --> 00:56:53.040
is our fantastic resources page on
developer.apple.com/resources/http-stream

00:56:53.040 --> 00:56:53.480
ing.

00:56:53.600 --> 00:56:55.900
That has specification information.

00:56:55.900 --> 00:56:56.800
It has sample codes.

00:56:56.800 --> 00:56:59.740
It has best practices, tech notes,
videos, et cetera, et cetera.

00:56:59.860 --> 00:57:00.460
Check that out.

00:57:00.520 --> 00:57:02.500
It will probably answer your question.

00:57:02.500 --> 00:57:05.490
I've got the WebVTT link
on here one more time.

00:57:05.580 --> 00:57:06.990
Eric Verschen is our evangelist.

00:57:07.000 --> 00:57:08.000
He loves answering our questions.

00:57:08.000 --> 00:57:11.500
But Eric also hangs
out on the ADC forums,

00:57:11.500 --> 00:57:13.460
and so do a lot of other smart people.

00:57:13.500 --> 00:57:15.680
And if you have a problem,
there's a good chance someone

00:57:15.680 --> 00:57:17.000
else has also had that problem.

00:57:17.000 --> 00:57:18.990
In fact,
they might already have the answer.

00:57:19.150 --> 00:57:21.490
So take a look at the forums.

00:57:21.630 --> 00:57:22.800
Search for your problem.

00:57:23.010 --> 00:57:25.050
If you can't find it, post a question.

00:57:25.050 --> 00:57:28.390
There are smart people on the
forums who can help you answer it.

00:57:29.050 --> 00:57:30.150
I mentioned Eric's talk.

00:57:30.250 --> 00:57:31.000
That was yesterday.

00:57:31.000 --> 00:57:36.440
So if you haven't seen it,
I urge you to take a look at it in replay

00:57:36.440 --> 00:57:38.060
once we have those sessions come up.

00:57:38.200 --> 00:57:39.000
Again, thank you very much.
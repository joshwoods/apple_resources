WEBVTT

00:00:11.170 --> 00:00:13.160
Good afternoon.

00:00:13.160 --> 00:00:14.100
My name's Adam Swift.

00:00:14.270 --> 00:00:16.750
I'm a senior software engineer
in the Core Data team,

00:00:16.750 --> 00:00:22.680
and I'd like to welcome you for the
Using iCloud with Core Data session.

00:00:24.440 --> 00:00:28.860
In this session,
you will learn how to take what's

00:00:28.930 --> 00:00:34.490
really a relatively simple set of
APIs to build a robust and well-behaving

00:00:34.640 --> 00:00:37.770
iCloud Core Data application.

00:00:37.980 --> 00:00:40.890
We're going to take you through
the steps necessary to go from an

00:00:40.940 --> 00:00:43.650
idea to a fully functional app.

00:00:45.970 --> 00:00:52.360
And we're going to give you sample code
to help illustrate-- You're welcome.

00:00:56.400 --> 00:00:59.640
We're going to give you sample
code to help illustrate the

00:00:59.640 --> 00:01:02.670
strategies and the points that we're
making throughout this session.

00:01:02.830 --> 00:01:06.880
And in fact, we're going to try and tie
in as much as possible the

00:01:06.880 --> 00:01:10.950
sample code into the session,
and that will be made available to you

00:01:10.950 --> 00:01:13.600
through the conference attendee site.

00:01:13.600 --> 00:01:16.320
If you look up the session,
you should find a link

00:01:16.320 --> 00:01:17.830
to the sample code there.

00:01:18.110 --> 00:01:19.800
Alternatively,
you can also look it up by name.

00:01:19.800 --> 00:01:22.800
It's the shared Core Data sample.

00:01:22.800 --> 00:01:25.350
So you shouldn't have to write down
any of the code samples you see on

00:01:25.380 --> 00:01:27.500
stage throughout this presentation.

00:01:27.530 --> 00:01:31.630
They'll all be available to you
with references into that sample

00:01:31.990 --> 00:01:33.960
code that you can download.

00:01:36.140 --> 00:01:39.340
So before we get into
using Core Data in iCloud,

00:01:39.340 --> 00:01:44.320
I wanted to take a minute to ask for a
little bit of audience participation.

00:01:44.370 --> 00:01:48.970
We were curious to try and understand
how many of you think or would

00:01:49.030 --> 00:01:54.430
describe yourselves as an experienced
Core Data user at this point?

00:01:55.310 --> 00:01:56.110
That's pretty good.

00:01:56.540 --> 00:01:56.860
Okay.

00:01:56.860 --> 00:02:01.020
And how many of you would describe
yourselves as only having looked at

00:02:01.020 --> 00:02:04.920
Core Data or maybe are considering
using it in a new application?

00:02:05.630 --> 00:02:06.430
Okay.

00:02:06.560 --> 00:02:06.760
All right.

00:02:06.760 --> 00:02:09.730
Well, I wanted to just quickly,
before we get into using

00:02:09.730 --> 00:02:12.540
Core Data with iCloud,
talk about the technologies

00:02:12.540 --> 00:02:14.200
that we're discussing today.

00:02:14.360 --> 00:02:17.850
And Core Data is an application
technology that helps you

00:02:17.850 --> 00:02:20.240
manage your application data.

00:02:20.390 --> 00:02:25.470
So in the context of this session,
the data that we're talking about

00:02:25.520 --> 00:02:28.160
is stored in an SQLite database.

00:02:28.260 --> 00:02:33.140
And in the terminology of Core Data,
we call that a persistent store.

00:02:33.380 --> 00:02:36.110
When you pull data from that
database using Core Data,

00:02:36.170 --> 00:02:39.300
we talk about those
records as managed objects,

00:02:39.350 --> 00:02:41.940
and you work with them in
a managed object context.

00:02:42.080 --> 00:02:44.830
When you've made your changes
in the application's managed

00:02:44.830 --> 00:02:48.120
object context and saved them,
Core Data takes care of putting

00:02:48.130 --> 00:02:53.390
those records back into the
persistent store or database.

00:02:53.950 --> 00:02:57.360
Now, what do you get when you take
Core Data and you add iCloud?

00:02:57.430 --> 00:03:01.140
Well, it means instead of your data
just living on the file system

00:03:01.210 --> 00:03:04.420
in a Deskulite database,
that data is made available

00:03:04.420 --> 00:03:07.230
through iCloud to all the
iCloud connected devices.

00:03:07.240 --> 00:03:11.600
So changes you make on your iPhone
and save are available on an iMac,

00:03:11.650 --> 00:03:17.000
and changes on the iMac are then
made available to the iPhone as well.

00:03:18.350 --> 00:03:21.340
And the specific features that
you get with Core Data and

00:03:21.340 --> 00:03:24.640
iCloud are significant.

00:03:24.640 --> 00:03:29.200
The big one that I want to call out
here is per record conflict resolution.

00:03:29.420 --> 00:03:33.130
And what that means is that if you
make changes between one device

00:03:33.130 --> 00:03:37.300
and another on a single record,
Core Data does the work to reconcile

00:03:37.300 --> 00:03:40.520
what changes belong at the end,
merging those changes

00:03:40.520 --> 00:03:42.380
together to be consistent.

00:03:42.780 --> 00:03:45.140
And I'm going to illustrate what
that means a little bit here.

00:03:45.140 --> 00:03:51.320
So we've got a record here,
John Doe and John@apple.com

00:03:51.320 --> 00:03:53.510
is the person data.

00:03:54.490 --> 00:03:57.790
And then on an iPhone,
I may go ahead and change

00:03:57.790 --> 00:03:59.550
the first name to Johnny.

00:04:00.110 --> 00:04:03.850
And then later I may go ahead
and change the last name,

00:04:03.850 --> 00:04:06.130
strangely, to Appleseed.

00:04:06.370 --> 00:04:08.360
Meanwhile, on my iMac,
which doesn't have its

00:04:08.360 --> 00:04:12.090
Ethernet connection right now,
I go ahead and change the email address

00:04:12.090 --> 00:04:15.740
for John Doe to johnny@apple.com.

00:04:15.930 --> 00:04:18.960
Well, when all these devices are able to
connect up on the network again,

00:04:19.220 --> 00:04:24.110
that record will be reconciled with
those changes automatically by Core Data,

00:04:24.160 --> 00:04:29.040
using the information from iCloud,
without any extra work from you.

00:04:30.620 --> 00:04:35.460
Some other features you get with iCloud
and Core Data is Core Data does a lot

00:04:35.460 --> 00:04:40.540
of work to only transfer the smallest
amount of data necessary to iCloud,

00:04:40.540 --> 00:04:43.930
minimizing the amount of network
bandwidth when you make a change.

00:04:43.960 --> 00:04:47.130
It doesn't upload all of the data
that you're storing in your database,

00:04:47.140 --> 00:04:48.630
just the parts that changed.

00:04:48.660 --> 00:04:53.200
And those changes are asynchronously
imported in the background on your

00:04:53.430 --> 00:04:55.850
other iCloud-connected devices.

00:04:56.400 --> 00:04:59.160
So you don't have to do any
work to import those changes.

00:04:59.160 --> 00:05:02.030
We take care of it for you,
merging in the per-record

00:05:02.030 --> 00:05:03.340
conflict resolutions.

00:05:03.340 --> 00:05:06.920
And last but not least,
we also support lightweight

00:05:06.920 --> 00:05:09.300
schema migration with iCloud.

00:05:09.300 --> 00:05:12.560
So that means if you've got one
device running an older version of

00:05:12.560 --> 00:05:15.380
your app that's connected to iCloud,
and a newer device,

00:05:15.410 --> 00:05:18.170
or another device connected to
a newer version of your app,

00:05:18.390 --> 00:05:21.590
with a new schema, those changes,
because they're based on

00:05:21.680 --> 00:05:25.940
different schema data models,
they can't be combined at that time.

00:05:26.310 --> 00:05:29.130
But when all the devices are
upgraded to a consistent version,

00:05:29.130 --> 00:05:33.210
we will then migrate the
changes that live in iCloud to

00:05:33.550 --> 00:05:36.280
bring all that data together,
so those changes won't be lost

00:05:36.280 --> 00:05:38.250
even through that schema migration.

00:05:41.270 --> 00:05:44.100
And to use Core Data with iCloud,
you need the standard sets

00:05:44.200 --> 00:05:47.950
of tools you need to develop
an application using iCloud.

00:05:48.100 --> 00:05:52.450
Xcode and the iOS or OSÂ X SDKs.

00:05:52.580 --> 00:05:55.230
And then you can use the
Core Data project template

00:05:55.260 --> 00:05:58.430
or start with the sample code
that we're providing you today.

00:05:58.540 --> 00:06:03.400
And then you want to enable the
iCloud entitlements for your project.

00:06:03.620 --> 00:06:06.360
You also need to sign up through
the provisioning portal to get

00:06:06.360 --> 00:06:10.140
an app ID registered for iCloud,
and get a provisioning profile

00:06:10.140 --> 00:06:13.800
for any devices you want
to run your application on.

00:06:15.230 --> 00:06:17.400
All right, with that,
I'd like to get into talking

00:06:17.400 --> 00:06:20.160
about using iCloud with Core Data.

00:06:20.350 --> 00:06:23.540
And we've broken this up
into three main focus areas.

00:06:23.670 --> 00:06:27.060
The first is your application design,
designing your application to work

00:06:27.170 --> 00:06:28.980
well with iCloud and Core Data.

00:06:29.380 --> 00:06:32.640
The second is the application
launch experience.

00:06:32.740 --> 00:06:34.500
And then last,
I'm going to turn it over to Nick,

00:06:34.500 --> 00:06:37.200
who's going to talk about
working with your application

00:06:37.200 --> 00:06:39.770
in the application lifecycle.

00:06:41.390 --> 00:06:45.680
So let's start off with
the application design.

00:06:45.830 --> 00:06:48.170
And when we're talking
about application design,

00:06:48.270 --> 00:06:52.470
especially keeping in mind iCloud,
you want to think about what

00:06:52.620 --> 00:06:54.670
your users' expectations are.

00:06:54.910 --> 00:06:56.260
Users love iCloud.

00:06:56.260 --> 00:06:59.440
It means they can work with their
data on their iMac and then go

00:06:59.440 --> 00:07:02.630
on the road with their iPhone,
and that same data is available to them,

00:07:02.630 --> 00:07:08.110
and they can continue to work with it,
and then it'll be available back on

00:07:08.110 --> 00:07:08.110
their Mac when they get home again.

00:07:08.280 --> 00:07:10.830
So your users kind of want
to have all that data shared

00:07:10.830 --> 00:07:13.510
through iCloud available to them.

00:07:13.760 --> 00:07:17.640
But you also want to consider some of the
practical issues of what kind of network

00:07:17.820 --> 00:07:19.470
you're going to be connecting over.

00:07:19.640 --> 00:07:21.560
What if your user isn't
signed into iCloud,

00:07:21.670 --> 00:07:24.860
or what if they switch to
a different iCloud account?

00:07:24.950 --> 00:07:26.910
And also,
just how much data are you really

00:07:26.910 --> 00:07:28.440
going to accumulate in iCloud?

00:07:28.630 --> 00:07:34.170
And you don't want to overrun that
and lead to a bad user experience.

00:07:35.340 --> 00:07:40.660
So we want to talk about how to
divide up your data so that the data

00:07:40.660 --> 00:07:43.730
that's important to be available to
your users across all their devices

00:07:44.370 --> 00:07:45.860
is made available through iCloud.

00:07:45.860 --> 00:07:50.090
But maybe some of that data
can be derived or recalculated.

00:07:50.120 --> 00:07:54.200
Or maybe it's changing with such a
high frequency that you don't want

00:07:54.530 --> 00:07:58.480
to clog up the network connection
with lots of changes all the time

00:07:58.480 --> 00:08:00.720
that really aren't preserved.

00:08:01.550 --> 00:08:06.670
So the general approach that we would
suggest is using one iCloud enabled

00:08:06.670 --> 00:08:10.700
store for data that can be shared,
and then using a local store for

00:08:10.730 --> 00:08:14.180
data that can be recalculated
or just belongs on the device

00:08:14.180 --> 00:08:16.280
because of the nature of that data.

00:08:22.100 --> 00:08:25.140
So I've talked about putting
your data into iCloud,

00:08:25.140 --> 00:08:27.000
but what does that really mean?

00:08:27.000 --> 00:08:29.990
What am I talking about there?

00:08:31.000 --> 00:08:33.140
Not your persistent store file.

00:08:33.270 --> 00:08:36.340
The problem is,
the persistent store file in

00:08:36.340 --> 00:08:38.200
this case is an SQLite database.

00:08:38.320 --> 00:08:42.360
And SQLite uses fine-grained file
system controls to control access

00:08:42.740 --> 00:08:45.790
so that it maintains internal
consistency with your data.

00:08:45.910 --> 00:08:48.310
It does a very good job of
making sure that it doesn't get

00:08:48.310 --> 00:08:49.800
corrupted and things like that.

00:08:50.130 --> 00:08:56.490
But this is not the type of file system
access that iCloud is designed to handle.

00:08:56.800 --> 00:09:01.130
Core Data uses a strategy of
transferring the incremental changes,

00:09:01.130 --> 00:09:05.000
or something we'll also
refer to as transaction logs,

00:09:05.110 --> 00:09:09.750
to iCloud that represent the
data in your persistent store.

00:09:14.200 --> 00:09:17.460
So you can also think about
your persistent store file,

00:09:17.460 --> 00:09:21.200
when it is enabled for iCloud,
as a cache that represents the

00:09:21.200 --> 00:09:22.970
data that's being stored in iCloud.

00:09:23.120 --> 00:09:25.440
You're going to access your data
through the persistent store file.

00:09:25.440 --> 00:09:28.120
You don't access the
data in iCloud directly.

00:09:28.230 --> 00:09:30.960
And one of the nice features of
that is that at any point in time,

00:09:30.960 --> 00:09:34.940
you can recreate that persistent
store file from the data

00:09:34.940 --> 00:09:36.860
that's available in iCloud.

00:09:36.940 --> 00:09:40.720
And I'll refer to that
later in another section.

00:09:41.900 --> 00:09:47.700
So what about the case where you want
to enable iCloud for one of your stores,

00:09:47.740 --> 00:09:52.290
but the user hasn't signed
in or signed up for iCloud?

00:09:52.390 --> 00:09:55.030
Well, in that case,
we're going to talk about

00:09:55.030 --> 00:09:56.700
this as a fallback store.

00:09:56.770 --> 00:09:59.800
When your user hasn't signed
up for an iCloud account,

00:09:59.880 --> 00:10:03.500
you want to still be able to provide
a seamless app experience so your

00:10:03.500 --> 00:10:09.540
user can develop or can work with
data and utilize your application,

00:10:09.610 --> 00:10:14.170
but that data won't be uploaded
or transferred to iCloud until

00:10:14.170 --> 00:10:17.000
they sign up for an account
or sign into their account.

00:10:17.080 --> 00:10:24.100
We call this a fallback store because
it's slightly different than the

00:10:24.100 --> 00:10:28.680
local store that's designed for data
that just belongs on your device.

00:10:28.860 --> 00:10:32.680
The fallback store is really representing
data you want to put into iCloud,

00:10:32.830 --> 00:10:36.190
but the user hasn't made
iCloud available to you yet.

00:10:37.260 --> 00:10:39.560
This is sort of the same position
you'll be in if you have an existing

00:10:39.650 --> 00:10:44.300
application that utilizes Core Data,
but does not yet utilize iCloud.

00:10:44.680 --> 00:10:47.530
Your users may have developed
a significant body of

00:10:47.530 --> 00:10:50.750
data in this application,
but since your application hadn't

00:10:50.750 --> 00:10:55.340
enabled access to iCloud on the device,
you'll probably want to make

00:10:55.340 --> 00:10:58.370
that data available to iCloud,
and that's where it's

00:10:58.370 --> 00:10:59.640
the common experience.

00:10:59.690 --> 00:11:02.700
At some point in time,
when the user signs into iCloud or when

00:11:02.700 --> 00:11:06.760
your app makes iCloud available to them,
you want to move that store data

00:11:06.910 --> 00:11:09.260
to the iCloud-enabled store.

00:11:11.800 --> 00:11:14.140
So for the case of the
iCloud-enabled store,

00:11:14.140 --> 00:11:17.070
when your user has signed into iCloud,

00:11:17.510 --> 00:11:21.200
You need to choose a place
where that persistent store file

00:11:21.200 --> 00:11:23.560
will live on the file system.

00:11:23.670 --> 00:11:27.930
And that's a decision you need
to make for your application,

00:11:27.930 --> 00:11:31.540
based on the access needs
of your application.

00:11:31.640 --> 00:11:35.330
Do you want to make that
data only accessible when the

00:11:35.330 --> 00:11:37.160
user is signed into iCloud?

00:11:37.260 --> 00:11:41.080
Or do you want to let the user
access that data even after

00:11:41.110 --> 00:11:45.360
they've signed out of iCloud,
but only in a read-only manner?

00:11:48.600 --> 00:11:52.200
So if it's the case that you only
want to let the user access the data

00:11:52.200 --> 00:11:57.780
when they're signed into iCloud,
then what we would recommend is put

00:11:57.860 --> 00:12:00.400
the store in the iCloud container.

00:12:00.550 --> 00:12:01.940
But wait, you're going to say.

00:12:02.000 --> 00:12:03.340
You just told me two slides ago.

00:12:03.340 --> 00:12:04.340
I should never do that.

00:12:04.440 --> 00:12:06.360
It'll destroy the world.

00:12:06.550 --> 00:12:12.560
Well, this is a special case where
if you create a folder called,

00:12:12.630 --> 00:12:16.750
say, myfolder.nosync,
something with .nosync in the name,

00:12:16.750 --> 00:12:20.150
in the iCloud container,
that's a special rule that means

00:12:20.150 --> 00:12:24.430
that that folder and its contents
will not be transferred to iCloud.

00:12:25.340 --> 00:12:27.860
So why would you want to do this?

00:12:27.960 --> 00:12:33.740
Well, it makes it easy to make sure that
your store file is only going to be

00:12:33.740 --> 00:12:39.340
associated with the data that you've
stored in iCloud for that store file.

00:12:40.190 --> 00:12:43.670
If the user switches accounts,
the container is removed and

00:12:43.670 --> 00:12:45.450
the store file goes with it.

00:12:45.560 --> 00:12:48.400
Remember, you can always rebuild the
store file from the Cloud data,

00:12:48.520 --> 00:12:49.630
so the data isn't lost.

00:12:49.900 --> 00:12:53.060
You just need to repopulate
it after that switch.

00:12:53.160 --> 00:12:56.150
And the main feature of this,
as far as we're concerned,

00:12:56.500 --> 00:12:57.690
is that it's simple.

00:12:57.830 --> 00:13:02.000
You're guaranteed that the
persistent store file that you have,

00:13:02.010 --> 00:13:05.240
that you're working with for that data,
for that user's iCloud account,

00:13:05.340 --> 00:13:09.200
will only be accessible when they're
signed into that iCloud account.

00:13:09.550 --> 00:13:13.310
You don't need to worry about mixing
up your persistent store file with

00:13:13.340 --> 00:13:19.010
a different iCloud account's data
that's been created from a store.

00:13:20.670 --> 00:13:24.350
So the alternative, though,
is to put the persistent store

00:13:24.470 --> 00:13:27.220
file in the application sandbox.

00:13:27.620 --> 00:13:32.310
You're still going to
write your data to iCloud,

00:13:32.510 --> 00:13:35.930
But it means that even if the
user is signed out of iCloud,

00:13:36.240 --> 00:13:38.860
that persistent store file
will survive account changes,

00:13:38.960 --> 00:13:41.990
like sign outs or switching
to a different account.

00:13:42.160 --> 00:13:47.870
But what it does is it shifts some burden
to you to make sure that you only make

00:13:47.880 --> 00:13:53.280
any access in terms of changes to that
persistent store file when you're able

00:13:53.300 --> 00:13:57.290
to connect to that same iCloud container.

00:13:58.350 --> 00:14:02.870
You can still use that persistent
store file in a read-only manner by

00:14:02.960 --> 00:14:07.860
using the NSReadOnlyPersistentStore
option to access that data in a

00:14:07.860 --> 00:14:11.200
read-only manner if they're signed out
or signed into a different account.

00:14:11.480 --> 00:14:17.200
And you can even move that data into a
fallback store if they're signed out,

00:14:17.200 --> 00:14:20.400
where you can then work
with the data locally.

00:14:26.000 --> 00:14:29.370
So I've talked about a couple different
scenarios with persistent stores,

00:14:29.380 --> 00:14:32.290
and I think I mentioned it before, but

00:14:32.770 --> 00:14:37.940
The focus here is,
going back to where I started,

00:14:38.080 --> 00:14:41.470
talking about what data do you want
to store locally on the device that

00:14:41.470 --> 00:14:46.560
really only belongs on the device,
and what store do you want to put into

00:14:46.560 --> 00:14:48.860
iCloud so it's available across devices?

00:14:48.860 --> 00:14:50.840
How do you want to partition this data?

00:14:50.840 --> 00:14:54.600
Well, you need to do it by assigning
one store to be local and one

00:14:54.930 --> 00:14:56.760
store to be iCloud enabled.

00:14:56.760 --> 00:15:00.130
You can have more than one,
but fundamentally,

00:15:00.140 --> 00:15:04.630
it's per store you make this decision.

00:15:05.090 --> 00:15:09.240
And there's a couple different ways
to achieve that division of data.

00:15:09.240 --> 00:15:12.620
One is you could use different
models and different coordinators,

00:15:12.690 --> 00:15:16.340
but the other one that we're going to
talk about for a minute here is to use

00:15:16.340 --> 00:15:19.520
different data model configurations.

00:15:20.490 --> 00:15:22.700
So what is a data model configuration?

00:15:22.730 --> 00:15:25.520
Well, it gives you a way to carve
out a subset of the entities

00:15:25.570 --> 00:15:28.820
in your data model and say,
I want to work with those entities

00:15:29.200 --> 00:15:32.530
in my iCloud enabled store,
and I want to work with these

00:15:32.880 --> 00:15:34.980
entities in my local data store.

00:15:35.130 --> 00:15:39.350
So it's a convenient way to be able
to work with a single data model

00:15:39.350 --> 00:15:44.280
that combines all of these entities,
but identify certain entities for

00:15:44.280 --> 00:15:46.700
use with one store versus another.

00:15:47.990 --> 00:15:50.890
One of the big benefits
here is that you can then,

00:15:50.890 --> 00:15:56.390
with a single managed object context,
access data from both of those store

00:15:56.390 --> 00:16:00.900
files using different configurations
and bring them into the same context.

00:16:00.910 --> 00:16:04.560
And then when your user interface
decides it's time to save,

00:16:04.560 --> 00:16:07.780
we'll save out those records
to the appropriate store

00:16:07.780 --> 00:16:11.890
according to the configuration
that they're associated with.

00:16:13.060 --> 00:16:15.500
So how do you create a configuration?

00:16:15.530 --> 00:16:19.000
You do it in the Xcode
data modeling tool.

00:16:19.000 --> 00:16:21.310
And you can see here,
here's the data model

00:16:21.310 --> 00:16:22.660
from the sample code.

00:16:22.860 --> 00:16:28.320
And I've created two entities,
a person and a state location.

00:16:28.320 --> 00:16:30.480
So in this case,
I want the person entity to

00:16:30.480 --> 00:16:31.960
be shared across devices.

00:16:31.960 --> 00:16:35.050
I wanted that to go into
my iCloud enabled store.

00:16:35.100 --> 00:16:37.520
But the state location,
we're actually just going to

00:16:37.520 --> 00:16:42.140
bundle the 50 states as read-only
data with our application.

00:16:42.140 --> 00:16:44.050
So that's going to stay
in the local store.

00:16:44.070 --> 00:16:47.040
There's no reason to
share that through iCloud.

00:16:47.640 --> 00:16:50.150
So how do I create a configuration?

00:16:50.160 --> 00:16:54.280
I use this pull-down menu
here to add a configuration.

00:16:55.250 --> 00:16:58.940
And then I name my one
configuration Cloud-- not clown,

00:16:59.120 --> 00:17:03.060
Cloud Config,
and I put my person entity into that.

00:17:03.340 --> 00:17:07.130
Then I create a second
configuration called Local Config,

00:17:07.130 --> 00:17:10.650
and I put my state
location into that one.

00:17:11.230 --> 00:17:13.860
Then to actually create
these stores in code,

00:17:13.860 --> 00:17:18.760
I use the addPersistentStore method
on my persistent store coordinator,

00:17:18.760 --> 00:17:23.890
and specify the cloud
configuration for my cloud store,

00:17:24.000 --> 00:17:28.440
and specify the local
configuration for the local store.

00:17:30.690 --> 00:17:34.060
So in summary,
the focus on application design should

00:17:34.090 --> 00:17:38.610
be on what do your users expect to be
able to work with across their devices?

00:17:38.680 --> 00:17:44.610
What data belongs in iCloud versus
what data belongs in the local store?

00:17:45.070 --> 00:17:50.120
Think about where that data should go,
considering the limitations of

00:17:50.120 --> 00:17:53.880
maybe a limited network at times,
or users who haven't signed into iCloud,

00:17:54.020 --> 00:17:57.140
or may switch accounts
for different reasons.

00:17:57.220 --> 00:18:00.160
And last,
think about the trade-offs between

00:18:00.160 --> 00:18:04.560
simplicity and additional functionality
in terms of where you put your

00:18:04.560 --> 00:18:07.590
iCloud-enabled store on the file system.

00:18:10.640 --> 00:18:13.130
All right,
now I'd like to switch gears and

00:18:13.210 --> 00:18:16.480
talk about application launch.

00:18:17.190 --> 00:18:19.900
An application launch
seems like a simple thing,

00:18:19.980 --> 00:18:22.600
not a lot of complexity to it.

00:18:22.600 --> 00:18:25.590
But you need to consider that there may
be a lot of different scenarios under

00:18:25.590 --> 00:18:27.820
which your application is launched.

00:18:27.880 --> 00:18:32.350
This may be the first launch from a new
user of your application on a device,

00:18:32.500 --> 00:18:36.290
and you may want to seed some data
into your iCloud enabled store.

00:18:36.290 --> 00:18:39.930
Or maybe it's a new device,
but your user has been using

00:18:39.930 --> 00:18:43.900
your application for a long
time on another device,

00:18:43.900 --> 00:18:47.110
so there's a lot of existing data that
you want to make sure is presented to the

00:18:47.110 --> 00:18:48.800
user when they launch your application.

00:18:50.990 --> 00:18:54.200
So the goals here are you want
to get to a full usable user

00:18:54.200 --> 00:18:58.160
interface for your application,
and you want to evaluate the status

00:18:58.360 --> 00:19:01.100
of what's going on at launch time.

00:19:01.170 --> 00:19:02.290
Is everything ready to go?

00:19:02.450 --> 00:19:05.140
Is all the data present on the file
system already and all you need

00:19:05.190 --> 00:19:06.800
to do is present it to the user?

00:19:06.850 --> 00:19:09.390
Or is this the first launch
and you need to seed?

00:19:09.510 --> 00:19:12.760
Or has this user not signed into
iCloud and now you need to fall back

00:19:12.900 --> 00:19:18.160
to keeping your iCloud enabled data in
a fallback store until they do sign in?

00:19:18.570 --> 00:19:20.660
And throughout all of this,
you want to make sure your

00:19:20.660 --> 00:19:23.790
application stays responsive,
so your user interface isn't

00:19:23.790 --> 00:19:28.410
waiting while you're figuring out
the results of these questions.

00:19:29.320 --> 00:19:31.600
So let's walk through the launch steps.

00:19:31.660 --> 00:19:33.460
User launches your app.

00:19:33.530 --> 00:19:36.960
You present an initial UI to your user.

00:19:37.040 --> 00:19:39.370
And then you need to make that decision.

00:19:39.500 --> 00:19:41.920
Check the iCloud status.

00:19:41.990 --> 00:19:43.500
Is the user signed in?

00:19:43.570 --> 00:19:45.920
If they are, then you want to kick
off a background queue.

00:19:46.080 --> 00:19:51.190
So you do this work in the background
to add your iCloud-enabled store,

00:19:51.500 --> 00:19:55.760
maybe seed some data,
and then when everything's ready to go,

00:19:55.840 --> 00:20:02.540
notify your user interface that this
data's ready to be displayed to the user.

00:20:02.920 --> 00:20:06.290
On the other hand,
what if the user is not signed in?

00:20:06.300 --> 00:20:09.440
What if there isn't an
iCloud account available?

00:20:09.560 --> 00:20:11.740
Well, again, in this case,
we're going to want to kick off a

00:20:11.810 --> 00:20:14.700
background queue to do this work,
because we don't know how

00:20:14.700 --> 00:20:15.990
much work we have to do yet.

00:20:16.220 --> 00:20:18.310
We'll want to add a fallback store,
maybe.

00:20:18.420 --> 00:20:21.320
We might want to do some
work on that fallback store.

00:20:21.450 --> 00:20:24.090
And again,
when we're done doing all that setup,

00:20:24.200 --> 00:20:27.160
notify the user interface
that it's time to refresh.

00:20:27.240 --> 00:20:29.480
All that data is available now.

00:20:30.300 --> 00:20:32.790
So, now I'd like to walk you
through the code that's involved

00:20:32.870 --> 00:20:35.000
in evaluating those steps.

00:20:35.120 --> 00:20:37.170
And you can see in the top
corner of the screen here,

00:20:37.170 --> 00:20:41.470
we've got a little bookmark that
indicates this code is taken

00:20:41.550 --> 00:20:45.040
from the sample code that's
been made available to you.

00:20:45.550 --> 00:20:50.770
And kind of like a pointer to the
method where that code appears.

00:20:51.540 --> 00:20:54.940
So in this one,
we're going to check the iCloud status.

00:20:55.030 --> 00:20:59.580
We want to find out if our
iCloud user is signed in.

00:21:02.120 --> 00:21:04.500
This can be done very quickly.

00:21:04.500 --> 00:21:08.000
And so this method is a new
piece of API available to

00:21:08.100 --> 00:21:09.640
you through NS File Manager.

00:21:09.640 --> 00:21:12.060
It's the Ubiquity Identity Token.

00:21:12.200 --> 00:21:14.140
And you can call it
right on the main thread.

00:21:14.270 --> 00:21:17.150
It's designed to give you
a result very quickly.

00:21:17.360 --> 00:21:22.890
And you'll get back an opaque
value that you can compare between

00:21:22.890 --> 00:21:25.930
application launches by archiving it.

00:21:26.100 --> 00:21:28.650
or within the application,
you can check to see,

00:21:28.650 --> 00:21:31.340
is it equal to the value you had before?

00:21:31.460 --> 00:21:35.000
Maybe if your user suspended the app,
switched iCloud's accounts and went back,

00:21:35.130 --> 00:21:37.390
it may have changed.

00:21:37.630 --> 00:21:40.300
And if that value comes back as nil,
then you know your user

00:21:40.300 --> 00:21:42.810
is not signed into iCloud.

00:21:44.110 --> 00:21:47.740
So the next step is we want
to add our persistent stores.

00:21:47.850 --> 00:21:51.170
And like I was saying before,
we want to do that on a background queue.

00:21:51.420 --> 00:21:55.140
And so I wanted to show you,
these are the dispatch APIs you can use,

00:21:55.200 --> 00:21:57.760
and they're, again,
available in the sample code,

00:21:57.870 --> 00:22:00.770
to kick off a background
queue to asynchronously

00:22:00.770 --> 00:22:02.750
load the persistent stores.

00:22:05.230 --> 00:22:09.100
Now, there's a number of pieces of work
that are happening in loading the

00:22:09.100 --> 00:22:11.190
asynchronous loading persistent stores.

00:22:11.200 --> 00:22:13.740
We deal with some other cases,
and Nick's going to detail

00:22:13.740 --> 00:22:15.700
some of those for you later.

00:22:15.830 --> 00:22:18.450
But right now,
I just wanted to focus on the steps

00:22:18.450 --> 00:22:20.850
involved in loading the iCloud store.

00:22:20.970 --> 00:22:25.320
And this walks you through the main
APIs that interact with iCloud here.

00:22:25.850 --> 00:22:30.290
First, now we want to use the file
manager API to get the URL to

00:22:30.290 --> 00:22:33.140
access the iCloud container.

00:22:33.140 --> 00:22:36.700
And the reason why we want to execute
this on the asynchronous call,

00:22:36.700 --> 00:22:40.320
on the background queue,
is because if this is the first

00:22:40.320 --> 00:22:44.310
time your user has accessed
iCloud through your application,

00:22:44.310 --> 00:22:47.070
or accessed iCloud
through any application,

00:22:47.070 --> 00:22:50.710
there might be some file system
setup that needs to happen,

00:22:50.820 --> 00:22:56.220
and it might take longer than you want
your user to wait on the main thread.

00:22:56.720 --> 00:22:59.160
So first thing we do is we get that URL.

00:22:59.210 --> 00:23:02.610
The next step is we want to
get the iCloud store URL.

00:23:02.610 --> 00:23:05.780
And this is actually a method
that we've provided and

00:23:05.780 --> 00:23:08.480
implemented in the sample code.

00:23:08.760 --> 00:23:14.200
And what this will do is we decided
to follow the code path of providing

00:23:14.200 --> 00:23:19.650
access to the persistent store
file when the user signed out.

00:23:19.830 --> 00:23:24.960
So we're storing the persistent
store file in the app sandbox.

00:23:24.960 --> 00:23:30.000
And so what this method is doing is
it's creating a path that's uniquely

00:23:30.000 --> 00:23:34.790
constructed based on the iCloud
user who is signed in currently.

00:23:34.790 --> 00:23:39.960
So that's the way we make sure that
one iCloud account is associated with

00:23:39.960 --> 00:23:42.860
one store file with iCloud enabled.

00:23:42.860 --> 00:23:44.630
And you can look that up.

00:23:44.800 --> 00:23:49.080
The next steps are we then want to
set the options to enable iCloud

00:23:49.200 --> 00:23:51.200
for our persistent store file.

00:23:51.200 --> 00:23:53.320
And those are the persistent store,
ubiquitous content name key.

00:23:53.320 --> 00:23:53.890
And then we want to set the
options to enable iCloud for

00:23:53.890 --> 00:23:54.290
our persistent store file.

00:23:54.320 --> 00:23:54.320
And those are the persistent store,
ubiquitous content name key,

00:23:54.320 --> 00:23:54.320
because iCloud is a very
powerful tool for iCloud.

00:23:54.320 --> 00:23:54.320
And then we want to set the
options to enable iCloud for

00:23:54.320 --> 00:23:54.320
our persistent store file.

00:23:54.320 --> 00:23:54.320
And those are the persistent store,
ubiquitous content name key,

00:23:54.320 --> 00:23:54.320
because iCloud is a very
powerful tool for iCloud.

00:23:54.320 --> 00:23:54.320
And then we want to set the
options to enable iCloud for

00:23:54.320 --> 00:23:54.320
our persistent store file.

00:23:54.990 --> 00:23:55.530
And then we want to set the
options to enable iCloud for

00:23:55.530 --> 00:23:55.960
our persistent store file.

00:23:55.960 --> 00:23:58.220
And because we're only working with
one iCloud enabled store at a time,

00:23:58.220 --> 00:24:01.810
we just name this the iCloud store.

00:24:01.920 --> 00:24:07.480
That is what's identifying the
name of the ubiquitous content

00:24:07.480 --> 00:24:09.360
that we're putting into iCloud.

00:24:10.450 --> 00:24:15.140
Then the next piece is the persistent
store ubiquitous content URL key.

00:24:15.320 --> 00:24:19.090
And what this does is this provides
Core Data the path that it should

00:24:19.090 --> 00:24:23.220
use to store those transaction
logs or the incremental changes

00:24:23.240 --> 00:24:25.040
that we're putting into iCloud.

00:24:25.200 --> 00:24:29.250
And the way we've constructed
the iCloud data URL is by taking

00:24:29.250 --> 00:24:34.230
that ubiquity URL and tacking
on iCloud data on top of it.

00:24:35.860 --> 00:24:39.090
Then we pass those options to
our call to add persistent store,

00:24:39.120 --> 00:24:42.200
and you can see we're using
the Cloud Config here again.

00:24:42.440 --> 00:24:43.700
And away we go.

00:24:43.700 --> 00:24:46.190
Our coordinator should add the store.

00:24:47.790 --> 00:24:49.920
So the next step,
and this is actually implemented in the

00:24:49.920 --> 00:24:53.560
asynchronous load persistent stores,
is if we're successful at

00:24:53.560 --> 00:24:57.010
loading the iCloud store,
then we want to check,

00:24:57.130 --> 00:24:59.820
do we need to seed any data
into that iCloud store?

00:24:59.820 --> 00:25:02.400
So I wanted to call that out
because you'll be able to check

00:25:02.550 --> 00:25:05.320
up on that in the sample code,
and Nick will talk a little bit

00:25:05.390 --> 00:25:07.120
more about seeding your store.

00:25:07.120 --> 00:25:11.630
But this is the time in that asynchronous
load persistent stores where you might

00:25:11.630 --> 00:25:15.780
want to do any other follow-up work
based on adding that iCloud store.

00:25:16.360 --> 00:25:18.560
So again,
you're not holding up your user interface

00:25:18.560 --> 00:25:20.780
while you're setting up the data.

00:25:22.620 --> 00:25:27.960
And the last step here is we want
our user interface to respond now

00:25:27.960 --> 00:25:29.430
that the new data is available.

00:25:29.610 --> 00:25:35.070
And so we do that by listening for a
notification on our root view controller.

00:25:35.600 --> 00:25:39.360
And this uses a notification
that Core Data generates for you,

00:25:39.360 --> 00:25:42.130
and that is the persistent
store coordinator stores

00:25:42.130 --> 00:25:44.000
did change notification.

00:25:44.150 --> 00:25:47.820
And that's an indication that
there's been a change to the stores,

00:25:47.890 --> 00:25:52.060
and it's a good time to refresh because
there might be more data available.

00:25:53.730 --> 00:25:56.360
And at that point,
we're able to present our full UI,

00:25:56.510 --> 00:25:59.100
our application is launched,
and our user is able to work

00:25:59.100 --> 00:26:01.210
with their full data set.

00:26:03.290 --> 00:26:04.900
And with that,
I'm going to turn it over to

00:26:04.900 --> 00:26:10.430
Nick Gillette to talk about how to
implement to your application lifecycle.

00:26:16.900 --> 00:26:18.820
I'm Nick Gillette,
I'm a software engineer

00:26:18.820 --> 00:26:21.260
on the Core Data team,
and I'm going to talk to you today

00:26:21.260 --> 00:26:24.800
about the application lifecycle,
which is really all the events that

00:26:24.800 --> 00:26:28.590
your application will encounter
and have to deal with when it's

00:26:28.590 --> 00:26:30.550
using iCloud and Core Data.

00:26:30.580 --> 00:26:34.560
We'll talk about things like seeding,
integrating changes when they

00:26:34.560 --> 00:26:38.080
come in from over the wire,
responding to user events,

00:26:38.080 --> 00:26:42.050
and we'll also go over a few
performance and debugging tips.

00:26:42.480 --> 00:26:45.300
First, I'd like to start, though,
by talking about our sample

00:26:45.300 --> 00:26:47.730
application that we're going to ship.

00:26:48.260 --> 00:26:51.720
So as Adam mentioned,
this application is available to you

00:26:51.820 --> 00:26:54.340
today from the developer website.

00:26:54.340 --> 00:26:56.880
And I've created a single class
here which encapsulates all

00:26:56.880 --> 00:26:59.900
of our Core Data and iCloud
functionality that you can use in

00:26:59.900 --> 00:27:01.700
your applications if you desire.

00:27:01.740 --> 00:27:04.600
You should be aware that
it's built with Arc,

00:27:04.600 --> 00:27:07.530
so if you're using your manual
retain and release application,

00:27:07.580 --> 00:27:11.490
it's going to leak like crazy.

00:27:11.880 --> 00:27:13.780
You can see that we
have two targets here,

00:27:13.920 --> 00:27:15.500
well, two projects really.

00:27:15.590 --> 00:27:17.930
This is a shared workspace
for this application,

00:27:17.930 --> 00:27:21.760
and it has a MacÂ OSÂ X target and
an iOS target that you can use to

00:27:21.820 --> 00:27:26.830
create an application that shares data
between your Mac and your iOS device.

00:27:26.900 --> 00:27:29.540
The Core Data Controller is our
central point of contact for

00:27:29.540 --> 00:27:31.640
all the Core Data related stuff.

00:27:31.750 --> 00:27:35.500
And the app delegate has been
decreased in functionality from

00:27:35.500 --> 00:27:37.340
the standard Core Data template.

00:27:37.430 --> 00:27:39.900
It no longer has a
persistent store coordinator,

00:27:39.900 --> 00:27:44.270
and its only responsibility is to
initialize the Core Data Controller.

00:27:44.660 --> 00:27:47.840
Inside the Core Data controller,
you'll find all the necessary

00:27:47.840 --> 00:27:50.690
variables and things you'll
need to work with iCloud,

00:27:50.760 --> 00:27:52.810
including the persistent
store coordinator,

00:27:52.930 --> 00:27:56.470
a manage object context for
working on the main thread,

00:27:56.570 --> 00:28:00.810
a few internal concurrency items,
and an implementation

00:28:00.850 --> 00:28:02.050
of NS file presenter.

00:28:02.210 --> 00:28:05.900
You'll also find our three persistent
stores that Adam spoke about,

00:28:05.900 --> 00:28:09.860
the iCloud store, the fallback store,
and the local store that holds the

00:28:09.920 --> 00:28:12.360
50 state data for our application.

00:28:12.430 --> 00:28:16.460
Our application is pretty simple in
terms of the managed object model.

00:28:18.250 --> 00:28:21.940
As Adam mentioned,
we have a person and a state location.

00:28:22.110 --> 00:28:25.770
There's also a metadata entry for those
of you that wish to sync some metadata

00:28:25.780 --> 00:28:28.740
with your application over iCloud.

00:28:28.910 --> 00:28:32.690
You can also see the two
configurations that Adam spoke about.

00:28:33.140 --> 00:28:37.080
Now I'll go back to the slides
and we'll talk about seeding.

00:28:37.190 --> 00:28:38.720
So what is seeding?

00:28:38.830 --> 00:28:42.520
Seeding, as we think of it,
is the process of injecting the data

00:28:42.520 --> 00:28:44.890
store with some initial data set.

00:28:45.030 --> 00:28:48.240
This usually means transferring
data to the iCloud store from

00:28:48.240 --> 00:28:50.600
some local persistent store file.

00:28:50.750 --> 00:28:54.780
However, you can take it to mean whatever
way you manage to inject the iCloud

00:28:54.780 --> 00:28:56.940
store with your initial data set.

00:28:57.010 --> 00:29:00.290
Normally when you seed the data store,
you'll already have an iCloud

00:29:00.290 --> 00:29:02.950
store in the coordinator,
which you added with the persistent

00:29:03.420 --> 00:29:07.560
store options for Ubiquiti,
the content name and the URL key.

00:29:07.720 --> 00:29:11.060
You can add another store to the
coordinator by calling add persistent

00:29:11.060 --> 00:29:14.770
store and use the NS read only
persistent store option to tell

00:29:14.770 --> 00:29:19.800
the manage object context which store
you wish to insert entities into.

00:29:20.130 --> 00:29:24.170
This has the added benefit of also
making sure you don't accidentally

00:29:24.170 --> 00:29:25.960
duplicate all your seed data.

00:29:29.150 --> 00:29:32.890
Next, you'll need to actually migrate
the objects into the store.

00:29:33.090 --> 00:29:36.510
And to do this, we must be very careful
about memory pressure.

00:29:36.510 --> 00:29:40.900
So we can use a batch size on the fetch
request to ensure that we don't keep

00:29:40.900 --> 00:29:43.300
too many objects in memory at once.

00:29:43.980 --> 00:29:47.570
When you migrate the actual objects,
you can add them to the store,

00:29:47.570 --> 00:29:51.250
and then call
NSManageObjectContextSave and reset for

00:29:51.250 --> 00:29:56.500
each batch size to free up the memory
consumed by the inserted objects as well.

00:29:58.230 --> 00:30:01.100
Finally,
you want to mark the seed complete.

00:30:01.210 --> 00:30:04.930
And this is important so that no other
devices try and reseed the iCloud

00:30:04.930 --> 00:30:07.690
store with your initial data set.

00:30:10.270 --> 00:30:12.960
After you've finished,
you should clean up.

00:30:13.010 --> 00:30:14.760
In most cases,
you'll be able to delete the

00:30:14.760 --> 00:30:18.350
seed store from the device,
freeing up a little bit of

00:30:18.350 --> 00:30:20.280
disk space for your user.

00:30:20.300 --> 00:30:22.800
So let's walk through the seeding code.

00:30:25.760 --> 00:30:30.220
So in the Core Data controller,
we've broken out an area

00:30:30.630 --> 00:30:34.780
called application lifecycle
that deals with seeding.

00:30:34.890 --> 00:30:37.670
And you can see in here that
we've got two main methods.

00:30:37.790 --> 00:30:40.830
One is used for adding
a person to the store,

00:30:40.970 --> 00:30:43.150
and the other is the main seeding method.

00:30:43.290 --> 00:30:46.250
This is called from a few different
places in the application that

00:30:46.250 --> 00:30:47.940
I'll talk about in a minute.

00:30:48.050 --> 00:30:52.280
Basically what we do in this application
is we set up a separate persistent

00:30:52.280 --> 00:30:54.360
store coordinator for the seed.

00:30:54.440 --> 00:30:57.700
Now, you might be saying, wait a minute,
you just told me that you could use

00:30:57.700 --> 00:31:00.060
the same persistent store coordinator.

00:31:00.170 --> 00:31:04.800
And this is true,
except if you have a very large data set.

00:31:04.960 --> 00:31:08.600
When you have a very large data set,
you have to call manage object

00:31:08.670 --> 00:31:12.800
context reset to free up memory
consumed by the inserted objects.

00:31:12.940 --> 00:31:17.170
Unfortunately, when you do this,
any references to those objects that

00:31:17.170 --> 00:31:21.140
are contained in the fetched results
array are going to be invalidated.

00:31:21.250 --> 00:31:24.930
And you'll no longer be able to use
the results of that fetch request.

00:31:25.050 --> 00:31:31.800
This is inconvenient for the purposes
of inserting data over a large set.

00:31:31.900 --> 00:31:35.620
So in the sample application,
we create a separate persistent

00:31:35.620 --> 00:31:38.620
store coordinator which
points to our seed store.

00:31:38.680 --> 00:31:43.080
It's still mounted read only so that
we don't accidentally insert data.

00:31:43.690 --> 00:31:47.040
And then we create a managed object
context that we use specifically

00:31:47.040 --> 00:31:49.600
for fetching the seed objects.

00:31:49.660 --> 00:31:54.150
This is where the fetched results array
will automatically do our memory for us.

00:31:54.340 --> 00:31:58.350
It will maintain one batch of
objects in memory at a time,

00:31:58.350 --> 00:32:00.960
and then free out the
rest of the objects.

00:32:01.360 --> 00:32:03.540
We create a separate
managed object context,

00:32:03.730 --> 00:32:05.790
which contains the iCloud store.

00:32:05.880 --> 00:32:09.050
And this managed object context
points to our application's

00:32:09.050 --> 00:32:13.340
persistent store coordinator,
where the iCloud store will be.

00:32:13.410 --> 00:32:17.240
We then iterate over every
person in the seed store.

00:32:17.330 --> 00:32:20.000
And for each batch,
we call managed object context

00:32:20.170 --> 00:32:23.590
save to write the changes to disk,
and reset to free up the

00:32:23.590 --> 00:32:26.220
memory consumed by the objects.

00:32:32.450 --> 00:32:35.580
Finally,
if there are still changes left over,

00:32:35.580 --> 00:32:37.600
maybe we had a number of
objects in the store that didn't

00:32:37.630 --> 00:32:41.990
correspond cleanly to a batch,
we do one last save.

00:32:42.080 --> 00:32:45.150
But where does all this
actually get called from?

00:32:45.230 --> 00:32:48.380
Adam mentioned a little bit
of application logic that we

00:32:48.380 --> 00:32:51.590
had in load persistent stores.

00:32:52.740 --> 00:32:57.550
And this method is responsible for
loading all the persistent stores that

00:32:57.570 --> 00:33:00.000
are going to be used for our application.

00:33:00.120 --> 00:33:04.170
It takes responsibility for piping
this call back to a background queue

00:33:04.340 --> 00:33:07.000
so that we don't impact our UI.

00:33:07.100 --> 00:33:10.800
In async load persistent stores,
we go through and first load

00:33:10.800 --> 00:33:14.500
the local persistent store that
contains the 50 states information.

00:33:14.620 --> 00:33:16.910
This should be very fast.

00:33:17.210 --> 00:33:20.830
Next, if iCloud is available,
we load the iCloud store,

00:33:21.120 --> 00:33:24.410
which may take a while,
if it's the first time that you're

00:33:24.410 --> 00:33:25.700
adding it to the coordinator.

00:33:25.770 --> 00:33:29.440
For subsequent launches,
this will also be very fast.

00:33:29.530 --> 00:33:32.410
And if necessary,
we seed the iCloud store.

00:33:32.540 --> 00:33:35.140
Traditionally,
your application should have a little

00:33:35.320 --> 00:33:37.010
bit more complicated check for this.

00:33:37.210 --> 00:33:40.940
However, we wanted to make it as easy to
use as possible in the sample app,

00:33:41.040 --> 00:33:44.200
and so we've included a simple
pound-defined macro that you can turn

00:33:44.200 --> 00:33:46.480
on and off to see seeding happen.

00:33:46.590 --> 00:33:49.840
This is also a good way to profile it.

00:33:49.900 --> 00:33:54.600
After we've seeded, we dedupe,
which I'll talk about in a little bit.

00:33:56.190 --> 00:34:01.070
If iCloud isn't available, however,
then we fall back to the fallback store.

00:34:01.160 --> 00:34:03.710
And this is that persistent
store that Adam spoke about,

00:34:03.710 --> 00:34:07.660
which temporarily holds data
that we want to put in iCloud.

00:34:07.850 --> 00:34:11.730
And this is a great way to give your
user a seamless experience when they're

00:34:11.730 --> 00:34:14.060
using iCloud and when they're not.

00:34:14.120 --> 00:34:17.570
This is something that we automatically
detect in the sample application

00:34:17.640 --> 00:34:19.600
and switch between as needed.

00:34:19.670 --> 00:34:22.950
So if you sign out of the iCloud account
and you're using the sample application,

00:34:23.120 --> 00:34:26.440
we'll automatically load
the fallback store for you.

00:34:26.500 --> 00:34:30.280
As you can see, we also have some seeding
logic in the fallback store,

00:34:30.280 --> 00:34:34.030
if you want to see that
happen on a local device.

00:34:34.140 --> 00:34:37.760
So let's move on and talk
about integrating changes.

00:34:39.980 --> 00:34:45.300
In a traditional Core Data application,
when you call NSManageObjectContext save,

00:34:45.300 --> 00:34:49.470
you can use NSManageObjectContext
didSave notification to merge

00:34:49.470 --> 00:34:52.120
those changes with other contexts.

00:34:52.610 --> 00:34:56.490
With iCloud,
we created NS Persistent Store did import

00:34:56.500 --> 00:35:01.020
ubiquitous content changes notification,
and they had to make the

00:35:01.020 --> 00:35:02.990
slides bigger because of it.

00:35:04.590 --> 00:35:06.650
This is how we communicate
to your application that

00:35:06.810 --> 00:35:08.170
things changed in the cloud.

00:35:08.260 --> 00:35:11.550
More importantly,
it's how your application will

00:35:11.550 --> 00:35:15.300
respond and integrate those changes
into its own managed object context.

00:35:15.460 --> 00:35:18.980
But you need to be aware that
unlike NSManageObjectContext

00:35:18.980 --> 00:35:22.840
did save notification,
NSPersistentStore did import ubiquitous

00:35:22.840 --> 00:35:27.230
content changes notification,
has managed object IDs,

00:35:27.260 --> 00:35:29.290
not NSManageObjects.

00:35:29.290 --> 00:35:34.340
So if you have any application level
logic that does merging for you,

00:35:34.420 --> 00:35:37.770
you'll need to update it or at least
make it aware that it's dealing with

00:35:37.770 --> 00:35:41.230
object IDs instead of managed objects.

00:35:41.230 --> 00:35:41.230
Adam Swift

00:35:42.750 --> 00:35:45.700
Now let's talk a little bit about
a scenario that some applications

00:35:45.700 --> 00:35:50.690
will encounter who wish to keep a
consistent data set for their users.

00:35:50.780 --> 00:35:53.560
Let's say that I have an iMac
that I've never used before.

00:35:53.650 --> 00:35:56.400
It's brand new,
and I want to import all my

00:35:56.400 --> 00:35:58.740
contact records into this machine.

00:35:58.830 --> 00:36:01.910
So eventually,
it creates a record for my mom.

00:36:02.130 --> 00:36:05.730
But as Adam ran into earlier,
my iMac doesn't have

00:36:05.730 --> 00:36:07.440
an internet connection.

00:36:07.550 --> 00:36:11.120
Maybe Comcast is having a bad day,
or my router melted.

00:36:11.230 --> 00:36:14.010
And so I create the
same record on my phone.

00:36:14.100 --> 00:36:16.610
My phone,
with its persistent data connection,

00:36:16.710 --> 00:36:19.810
transfers that record into iCloud.

00:36:20.180 --> 00:36:24.440
Later, my Mac comes online and
transfers its record.

00:36:24.520 --> 00:36:27.980
It also downloads the
record from my phone.

00:36:28.060 --> 00:36:31.930
And likewise, my phone downloads the
record from my iMac.

00:36:32.870 --> 00:36:36.840
From our standpoint,
you created two records in the database.

00:36:36.990 --> 00:36:41.400
From the user's standpoint, though,
this doesn't quite look right.

00:36:41.880 --> 00:36:44.040
How do you deal with this?

00:36:44.040 --> 00:36:46.560
We call this unicking,
and not in the traditional

00:36:46.560 --> 00:36:50.020
database sense of unicking,
but in the sense that the user is

00:36:50.020 --> 00:36:54.290
expecting to see a consistent data set,
unique by some value.

00:36:54.440 --> 00:36:56.690
For our sample application,
we've chosen to unique

00:36:56.690 --> 00:36:58.200
based on the email address.

00:36:58.350 --> 00:37:00.610
And if we were traditional
database developers,

00:37:00.610 --> 00:37:04.050
we could use this query to find
out all the duplicate email

00:37:04.050 --> 00:37:07.910
addresses in the database and
how many times they occurred.

00:37:08.010 --> 00:37:09.400
How do we do this with Core Data?

00:37:09.400 --> 00:37:15.570
Well, we know that the table we want is a
list of email addresses and the number

00:37:15.570 --> 00:37:18.150
of times they're in the database.

00:37:18.490 --> 00:37:25.310
And we can use NS Expression to get the
count of email addresses in the database.

00:37:26.320 --> 00:37:29.560
We can also create a fetch
request that will return to us

00:37:29.700 --> 00:37:32.380
the email addresses and the count.

00:37:32.470 --> 00:37:35.360
You might be wondering how,
since the count isn't a

00:37:35.360 --> 00:37:39.440
property on any managed object.

00:37:39.440 --> 00:37:39.440
Well,

00:37:39.570 --> 00:37:42.340
That's where the dictionary
result type comes in.

00:37:42.410 --> 00:37:46.970
NSDictionary result type is a
powerful construct in Core Data that

00:37:46.970 --> 00:37:51.700
allows us to create a simulation of
arbitrary columns in the database.

00:37:51.770 --> 00:37:55.430
They're returned to
us as key value pairs.

00:37:56.580 --> 00:38:00.670
So when we execute this fetch request,
we'll see this SQL come

00:38:00.700 --> 00:38:02.650
out in the console.

00:38:02.700 --> 00:38:04.500
If you'll notice,
it looks remarkably similar

00:38:04.600 --> 00:38:06.670
to our original query.

00:38:07.330 --> 00:38:11.200
And this is what we'll see if we
print out the results in the debugger.

00:38:11.230 --> 00:38:13.530
You'll notice that it's an array,
just like a normal fetch

00:38:13.580 --> 00:38:14.720
request would return.

00:38:14.920 --> 00:38:18.220
However, instead of manage objects,
there's a dictionary with account

00:38:18.840 --> 00:38:21.760
and an email address in each entry.

00:38:22.580 --> 00:38:26.630
Finally, you'll have to fetch out
all the duplicate objects.

00:38:26.880 --> 00:38:30.550
To do this, you can use an in-predicate
and gather the array of values

00:38:30.690 --> 00:38:33.310
from the previous result.

00:38:33.690 --> 00:38:36.960
You can sort by email address
to make unicking easy,

00:38:36.960 --> 00:38:39.550
and then execute the fetch request.

00:38:40.510 --> 00:38:45.000
Finally, the most important step,
you'll have to elect a winning record.

00:38:45.040 --> 00:38:47.700
Now, you might be thinking this
is actually the easy step,

00:38:47.760 --> 00:38:50.190
but only if you get it right.

00:38:52.140 --> 00:38:55.540
The problem you can run into is that,
let's say that you unique

00:38:55.540 --> 00:38:59.640
the records based on,
say, who inserted them.

00:38:59.700 --> 00:39:02.680
So the iMac will always say, well,
I want to keep my record,

00:39:02.910 --> 00:39:04.500
and it will delete the
one from the iPhone.

00:39:04.500 --> 00:39:07.110
And the iPhone will say,
I want to keep my record,

00:39:07.120 --> 00:39:09.410
and it will delete the one from the iMac.

00:39:09.470 --> 00:39:12.840
The net result of that
conflicting merge is that there's

00:39:12.840 --> 00:39:15.830
no data left in the store,
which is definitely not

00:39:15.880 --> 00:39:17.610
what your user expected.

00:39:35.860 --> 00:39:35.870
We recommend that you use a record UUID,
such as NSUUID,

00:39:35.870 --> 00:39:35.870
to create a string UUID or a timestamp.

00:39:35.870 --> 00:39:35.870
If your application requires it,
you can also do multi-field

00:39:35.870 --> 00:39:35.870
unicking by hashing a number of
fields into an integer constant

00:39:35.870 --> 00:39:35.870
that you store on your entity.

00:39:37.120 --> 00:39:40.620
Finally, you should use a batch
fetch request for this.

00:39:40.730 --> 00:39:43.560
Even if your data set is small,
it's possible that there

00:39:43.560 --> 00:39:45.290
could be a lot of unique data.

00:39:45.410 --> 00:39:49.290
You can never really be quite certain
with any of your peers whether or

00:39:49.290 --> 00:39:53.510
not they've created duplicates that
will be transferred to other devices.

00:39:55.100 --> 00:39:59.100
So let's talk about the Uniquing code.

00:39:59.190 --> 00:40:02.670
So here in the sample application,
we've created a section

00:40:02.670 --> 00:40:07.790
specifically for Uniquing,
and it has one method called dedupe.

00:40:08.870 --> 00:40:12.550
Ddupe is called in the application
whenever a seed happens.

00:40:12.630 --> 00:40:14.540
We don't call it on the merge.

00:40:14.600 --> 00:40:17.300
We don't call it when we
traditionally merge changes from

00:40:17.300 --> 00:40:20.700
iCloud because we assume that we
haven't created any duplicates,

00:40:20.840 --> 00:40:24.300
which knowing users is not
necessarily a safe assumption.

00:40:24.420 --> 00:40:28.570
So in your code, you may want to call
it after every merge.

00:40:29.890 --> 00:40:33.010
The first thing that we do is we
create a special managed object

00:40:33.040 --> 00:40:36.160
context to be used by this operation.

00:40:36.260 --> 00:40:39.800
This is so that we don't burden
any of the other contexts,

00:40:39.800 --> 00:40:43.870
such as the main thread context,
with this operation.

00:40:44.700 --> 00:40:48.360
And then we create our fetch request
with an appropriate batch size.

00:40:48.500 --> 00:40:50.460
For us, it's 1,000 in the application.

00:40:50.460 --> 00:40:53.540
However, depending on the size of the
entities in your data model,

00:40:53.740 --> 00:40:55.790
this may vary.

00:40:56.210 --> 00:40:58.140
Next, we create our count expression.

00:40:58.250 --> 00:41:01.850
And one thing I left off the slides
is the NSExpression description

00:41:01.850 --> 00:41:06.220
instance that we need to tell
Core Data a little bit of information

00:41:06.220 --> 00:41:08.290
about the count's function.

00:41:08.390 --> 00:41:10.940
We give it a name,
which is the key that will be referenced

00:41:11.060 --> 00:41:12.840
in the dictionary that's returned.

00:41:12.980 --> 00:41:14.430
We give it the expression.

00:41:14.530 --> 00:41:18.490
And we tell it what type of
data it can expect as a result.

00:41:19.240 --> 00:41:22.980
Next, we fetch the attribute description
for the email address and use

00:41:22.980 --> 00:41:25.240
that on properties to fetch.

00:41:25.350 --> 00:41:29.400
For properties to group by,
we simply set the email attribute.

00:41:29.440 --> 00:41:31.480
And then, of course,
the dictionary result type,

00:41:31.480 --> 00:41:32.860
one of the most important parts.

00:41:32.940 --> 00:41:36.520
After we fetch the count dictionaries,
we can enumerate them,

00:41:36.520 --> 00:41:39.520
and for any dictionary with
a value greater than one,

00:41:39.520 --> 00:41:42.640
we pull the email address
out and add it to an array.

00:41:43.300 --> 00:41:47.290
That array then becomes the
target value of our in predicate,

00:41:47.290 --> 00:41:51.870
which is used with an email address
sort descriptor to get out the array

00:41:51.870 --> 00:41:54.270
of all the possible duplicates.

00:41:54.730 --> 00:41:57.290
And finally,
we have a simple merge algorithm,

00:41:57.290 --> 00:42:00.900
which just sorts the UUIDs
and elects one of them.

00:42:01.020 --> 00:42:03.080
Now, of course,
your application may have something

00:42:03.150 --> 00:42:07.970
that's more complicated than this,
but for us, a UUID was sufficient.

00:42:08.940 --> 00:42:12.790
Finally,
there's the usual saving and manage

00:42:12.790 --> 00:42:16.880
object context cleanup for every batch.

00:42:16.890 --> 00:42:18.880
So that's Uniquing.

00:42:20.930 --> 00:42:22.130
User events.

00:42:22.150 --> 00:42:25.060
So what do I mean by user events?

00:42:25.210 --> 00:42:27.500
Well,
throughout your application's life cycle,

00:42:27.510 --> 00:42:32.800
there are various events that it can
encounter that are initiated by the user.

00:42:32.940 --> 00:42:36.420
We focused on the deletion from
documents and data where the user has

00:42:36.460 --> 00:42:40.300
chosen to prune your application's
data from their iCloud account.

00:42:40.300 --> 00:42:43.760
They'll receive a pop-up asking
them to do this anytime they run

00:42:43.770 --> 00:42:47.130
out of quota space in iCloud,
and they can either buy more

00:42:47.130 --> 00:42:52.260
or they can go through and wipe
out your application's data.

00:42:52.260 --> 00:42:54.010
When this happens,

00:42:54.730 --> 00:43:00.320
All of the files that exist in the
container will be deleted and become

00:43:00.320 --> 00:43:03.010
inaccessible to your application.

00:43:03.780 --> 00:43:05.860
So what can you do about this?

00:43:05.910 --> 00:43:09.890
Well, there's no existing API today
to help you with this problem.

00:43:09.970 --> 00:43:13.240
So we recommend that you use
an NS file presenter to point

00:43:13.280 --> 00:43:15.640
to a file inside the container.

00:43:15.680 --> 00:43:18.470
You can keep it in a no
sync or in a sync directory,

00:43:18.560 --> 00:43:21.300
depending on how you
expect to deal with it.

00:43:21.360 --> 00:43:23.890
If you're keeping the store
file inside the container,

00:43:24.140 --> 00:43:27.170
this is a great thing to have
as your presented item URL.

00:43:27.170 --> 00:43:30.390
The reason for this is that
iCloud will come through and prune

00:43:30.570 --> 00:43:33.540
all the files in the container,
notifying you that the store

00:43:33.540 --> 00:43:33.680
file is in the container.

00:43:33.700 --> 00:43:35.950
file has been deleted.

00:43:38.030 --> 00:43:41.550
This is very similar to what
happens when the account changes.

00:43:41.670 --> 00:43:46.100
Luckily, NS File Manager has some API to
help you with this situation.

00:43:46.230 --> 00:43:49.940
There's the Ubiquity Identity Token
method that Adam mentioned earlier,

00:43:50.050 --> 00:43:52.690
which you can use in
application did become active,

00:43:52.690 --> 00:43:56.060
or wherever else in your application
you feel it may serve you best,

00:43:56.150 --> 00:44:01.360
to detect that the iCloud account is not
the same as the one that you had before.

00:44:01.490 --> 00:44:05.000
There's also a new notification
called NS Ubiquity Identity

00:44:05.000 --> 00:44:08.660
Did Change Notification that you
can subscribe to and you'll receive

00:44:08.660 --> 00:44:12.010
when the device's account changes.

00:44:15.730 --> 00:44:20.580
Responding to the iCloud
account change is fairly simple.

00:44:20.690 --> 00:44:23.610
For our sample application,
all we need to do is remove the

00:44:23.620 --> 00:44:26.760
iCloud store from the persistent
store coordinator and call

00:44:26.760 --> 00:44:29.010
load persistent stores again.

00:44:29.010 --> 00:44:32.130
However,
this would be a great place to add the

00:44:32.130 --> 00:44:36.330
store to your coordinator as a read-only
store if you wish your user to be able

00:44:36.330 --> 00:44:39.050
to still see the data that's in it.

00:44:39.930 --> 00:44:42.240
So let's walk through that code.

00:44:42.240 --> 00:44:45.180
So here we have a method
called iCloud available,

00:44:45.250 --> 00:44:48.530
which simply checks to see if
we've stored a Ubiquiti token.

00:44:48.630 --> 00:44:51.760
And application resumed,
which is where we actually check

00:44:51.870 --> 00:44:53.820
to see if the token changed.

00:44:53.930 --> 00:44:57.320
If it did,
we call iCloud account changed.

00:44:57.410 --> 00:44:59.200
Now,
because this is the same method that we

00:44:59.200 --> 00:45:03.230
use when we respond to the notification,
it will take a notification argument,

00:45:03.440 --> 00:45:07.190
but we usually pass nil when
we detect the change manually.

00:45:07.360 --> 00:45:09.800
And there we call drop stores.

00:45:09.810 --> 00:45:11.940
And drop stores is pretty simple.

00:45:11.940 --> 00:45:15.300
It just removes whichever store we
have mounted from our coordinator,

00:45:15.300 --> 00:45:18.910
whether it be the iCloud
store or the fallback store.

00:45:19.110 --> 00:45:22.910
The reason for this is that we'll
reexamine what we need to do with those

00:45:22.910 --> 00:45:25.280
two stores in load persistent stores.

00:45:27.950 --> 00:45:32.930
Next, we call load persistent stores,
and we fall back into that loop where

00:45:32.960 --> 00:45:36.410
we check what we need to do with
the various stores on the system,

00:45:36.640 --> 00:45:41.830
whether or not we can use iCloud,
whether or not we've had the

00:45:41.830 --> 00:45:47.700
fallback store before and need
to seed it into the iCloud store,

00:45:47.700 --> 00:45:47.700
or if we need to seed the fallback
store with some initial data set.

00:45:52.660 --> 00:45:55.580
From the application standpoint,
you'll notice that the app

00:45:55.720 --> 00:45:59.980
delegate has very little to do
when the actual account changes.

00:46:00.920 --> 00:46:03.930
In Did Become Active,
we simply just call application

00:46:03.930 --> 00:46:07.140
resumed and have the controller
check for us to see whether or

00:46:07.140 --> 00:46:09.340
not any action needs to be taken.

00:46:11.870 --> 00:46:18.180
Finally, I'd like to talk a little bit
about performance and debugging.

00:46:18.180 --> 00:46:21.020
One thing you should always remember
when working with iCloud is that every

00:46:21.020 --> 00:46:25.740
time you call NSManageObjectContextSave,
you'll actually generate

00:46:25.740 --> 00:46:27.240
two pieces of I/O.

00:46:27.240 --> 00:46:30.770
One is the right to the persistent store,
and the other is a log

00:46:30.820 --> 00:46:32.640
that goes out to iCloud.

00:46:32.640 --> 00:46:36.120
So you should be careful to coalesce
changes as appropriate and avoid

00:46:36.120 --> 00:46:41.080
storing things like raw sensor data
that can come out at a high frequency.

00:46:41.110 --> 00:46:45.050
For example, your application could
receive Core Location updates

00:46:45.050 --> 00:46:46.720
at a rate of 60 hertz.

00:46:46.720 --> 00:46:49.760
If the location hasn't changed,
there's little value to writing

00:46:49.760 --> 00:46:51.920
this data into the store.

00:46:51.920 --> 00:46:55.170
And as such, you may find that your user
may not benefit from this

00:46:55.170 --> 00:46:58.000
data being synced over iCloud.

00:46:59.360 --> 00:47:02.480
You also need to be very
aware of memory pressure.

00:47:02.590 --> 00:47:06.610
Because of the integration with iCloud,
your application will consume slightly

00:47:06.610 --> 00:47:11.070
more memory than normal due to us
merging changes in in the background.

00:47:11.200 --> 00:47:14.670
And this is important because your
user will expect the application to

00:47:14.670 --> 00:47:19.690
remain responsive and usable while
we're doing this work for them.

00:47:19.790 --> 00:47:24.670
So you should be careful to use batched
fetch requests whenever possible,

00:47:24.970 --> 00:47:30.740
and call NSManageObjectContextSave or
reset as aggressively as you

00:47:30.780 --> 00:47:33.730
can to free up unneeded memory.

00:47:34.630 --> 00:47:38.500
Finally, when things don't quite
work out as you expected,

00:47:38.530 --> 00:47:41.130
remember that Macs are greedy peers.

00:47:41.210 --> 00:47:43.610
They will try and download as
much information about your

00:47:43.610 --> 00:47:47.000
iCloud account as they can,
as long as you've run at least

00:47:47.000 --> 00:47:49.140
one iCloud-enabled application.

00:47:49.240 --> 00:47:51.820
On MacÂ OSÂ X Mountain Lion,
you can use TextEdit,

00:47:51.990 --> 00:47:54.180
which ships with the system.

00:47:55.480 --> 00:47:59.010
When it comes time to remove data,
the best way to do this is with

00:47:59.060 --> 00:48:02.990
a coordinated write to delete
every file inside the container.

00:48:03.090 --> 00:48:06.410
This will take a little bit of
time to sync to all your different

00:48:06.410 --> 00:48:10.100
devices if you have a lot of files,
so you should be patient and make

00:48:10.100 --> 00:48:14.150
sure that all the files you expect to
be deleted have been before you begin

00:48:14.250 --> 00:48:16.580
working with the container again.

00:48:16.860 --> 00:48:20.760
Finally, help us out and file great bugs.

00:48:20.790 --> 00:48:24.190
I've been reading a lot of your bug
reports over the last six months,

00:48:24.190 --> 00:48:27.450
and I can tell you that there's a
few things that make it a lot easier

00:48:27.450 --> 00:48:29.590
for us to tell what's going on.

00:48:29.790 --> 00:48:32.970
First, if you can,
please include a sample application that

00:48:33.040 --> 00:48:35.080
demonstrates the issue you're seeing.

00:48:35.150 --> 00:48:40.790
If not, a verbose description of how
you get the problem to reproduce

00:48:41.200 --> 00:48:43.650
helps us out tremendously.

00:48:43.990 --> 00:48:47.660
If you can include the container,
we would love for you to do so.

00:48:47.790 --> 00:48:51.380
This gives us an accurate record
of everything that's happened with

00:48:51.380 --> 00:48:55.490
our integration and your account
over the history of your devices.

00:48:55.640 --> 00:48:59.180
However, you should be aware that we
can't guarantee confidentiality

00:48:59.180 --> 00:49:00.290
with this information.

00:49:00.440 --> 00:49:03.520
So if it's sensitive,
you should prune it or generate the

00:49:03.830 --> 00:49:07.360
problem with a sample application
and attach that container.

00:49:08.730 --> 00:49:11.140
Finally,
the most important thing you can do for

00:49:11.140 --> 00:49:13.300
us is attach our debug console logs.

00:49:13.300 --> 00:49:17.920
You can pass this argument,
com.apple.cordata.ubiquity.loglevel,

00:49:17.920 --> 00:49:21.140
to your application as a launch
argument or set it as a user

00:49:21.140 --> 00:49:23.450
default with the appropriate number.

00:49:23.450 --> 00:49:27.130
We like level three logs,
but I have to admit they are very verbose

00:49:27.130 --> 00:49:31.210
and will cause a lot of console spew,
which is great for me when I'm trying

00:49:31.250 --> 00:49:34.450
to figure out what's gone wrong,
but might be a little hard

00:49:34.510 --> 00:49:36.890
to sift through all of them.

00:49:36.900 --> 00:49:36.990
Thanks for watching.

00:49:37.060 --> 00:49:37.080
Bye.

00:49:37.120 --> 00:49:37.140
Bye.

00:49:37.320 --> 00:49:37.380
Bye.

00:49:37.500 --> 00:49:37.540
Bye.

00:49:37.600 --> 00:49:37.620
Bye.

00:49:37.860 --> 00:49:37.870
Bye.

00:49:37.940 --> 00:49:37.960
Bye.

00:49:37.980 --> 00:49:38.000
Bye.

00:49:38.060 --> 00:49:38.080
Bye.

00:49:38.100 --> 00:49:38.110
Bye.

00:49:38.230 --> 00:49:38.240
Bye.

00:49:38.380 --> 00:49:38.840
on your own.

00:49:41.860 --> 00:49:44.700
So now I'd like to take you through a
few of the debugging functions we've

00:49:44.700 --> 00:49:47.280
included in the sample application.

00:49:47.380 --> 00:49:50.560
So we've included a couple of
simple debugging functions that

00:49:50.560 --> 00:49:52.720
you can use with your application.

00:49:52.870 --> 00:49:55.900
One is to delete the container.

00:49:55.930 --> 00:49:58.150
And this simply goes over
to the Core Data controller

00:49:58.320 --> 00:50:00.670
and calls nuke and pave.

00:50:01.660 --> 00:50:03.430
appropriately named.

00:50:03.620 --> 00:50:06.870
The second is to copy the
contents of the container to

00:50:06.890 --> 00:50:09.140
your application's local sandbox.

00:50:09.180 --> 00:50:12.760
Now, this isn't that important on
a Mac device because you have

00:50:12.820 --> 00:50:14.400
access to the entire disk.

00:50:14.590 --> 00:50:18.470
However, on an iOS device,
this will copy all the contents

00:50:18.470 --> 00:50:22.860
from your application's iCloud
container into the sandbox where

00:50:22.960 --> 00:50:25.600
you can download them through Xcode.

00:50:25.660 --> 00:50:29.220
And that is the best way to
attach them to us in a bug.

00:50:29.220 --> 00:50:31.230
But what do these methods do?

00:50:32.850 --> 00:50:36.740
Under debugging helpers,
see Nuke and Pave,

00:50:36.900 --> 00:50:40.390
and async Nuke and Pave,
which is where the work is really done.

00:50:40.480 --> 00:50:43.110
The first thing we do is drop
all the persistent stores.

00:50:43.210 --> 00:50:48.600
We don't want to accidentally delete the
store file out from underneath ourselves.

00:50:49.340 --> 00:50:51.750
Next,
we get a file in instance of NS file

00:50:51.750 --> 00:50:57.100
coordinator and iterate over all the
sub paths in the Ubiquiti container.

00:50:57.190 --> 00:51:00.720
We then do a coordinated write
and tell it that we are going

00:51:00.720 --> 00:51:03.830
to be deleting these items,
and then use the file manager remove

00:51:03.830 --> 00:51:06.900
item at URL API to remove the file.

00:51:07.000 --> 00:51:09.760
Now, as I mentioned before,
if there are a large number

00:51:09.840 --> 00:51:12.930
of files in the container,
it may take a little while for

00:51:13.000 --> 00:51:17.230
iCloud to transfer all of these
changes to your various devices.

00:51:18.600 --> 00:51:22.060
In Copy Container to Sandbox,
we don't even bother

00:51:22.160 --> 00:51:25.740
with file coordinator,
which has two advantages.

00:51:25.740 --> 00:51:29.250
One is that it won't trigger
a download of the file that's

00:51:29.250 --> 00:51:30.680
a fault in your container.

00:51:30.680 --> 00:51:35.720
Now, this may be disadvantageous for
you as an application developer,

00:51:35.720 --> 00:51:38.320
but for us, when we're trying to
debug your container,

00:51:38.410 --> 00:51:41.310
it's critical for us to know what
files are faults and have not

00:51:41.310 --> 00:51:43.120
been downloaded to the device.

00:51:43.600 --> 00:51:47.340
The other advantage is that because
it doesn't trigger downloads,

00:51:47.400 --> 00:51:51.080
it doesn't block, so it's very fast,
meaning that there's no risk

00:51:51.140 --> 00:51:53.870
of you getting stuck at Xcode
for two hours waiting for

00:51:53.870 --> 00:51:55.620
files to come down from iCloud.

00:51:55.620 --> 00:51:59.580
And that's debugging.

00:52:00.930 --> 00:52:03.800
There's a little bit of extra
information we thought you should know.

00:52:03.950 --> 00:52:06.770
First is that please contact
Michael Jurowicz if you have

00:52:06.800 --> 00:52:08.300
any issues with our integration.

00:52:08.300 --> 00:52:10.600
He's our developer evangelist.

00:52:10.680 --> 00:52:13.500
His email address is jury@apple.com.

00:52:13.550 --> 00:52:16.270
And there's a feedback list
that you can email us at.

00:52:16.320 --> 00:52:20.300
We monitor it every so often,
but we're busy trying to fix your bugs,

00:52:20.380 --> 00:52:23.090
so we might not get
back to you right away.

00:52:23.180 --> 00:52:27.100
There's also some documentation you
can look up on developer.apple.com.

00:52:27.140 --> 00:52:31.880
With iOS 6, we released some new release
notes for iCloud that should help

00:52:31.890 --> 00:52:34.000
you along developing your apps.

00:52:34.110 --> 00:52:36.900
Finally,
you can find us on the developer forums.

00:52:36.900 --> 00:52:40.100
We do lurk there every once in
a while and answer questions

00:52:40.100 --> 00:52:44.380
that we find relevant,
usually with "File a bug."

00:52:45.230 --> 00:52:47.050
There are some related sessions.

00:52:47.110 --> 00:52:50.980
There's the iCloud Storage Overview,
Core Data Best Practices,

00:52:50.980 --> 00:52:55.020
which was this morning,
and Advanced iCloud Document Storage,

00:52:55.120 --> 00:52:57.090
which is tomorrow at 3:15.
WEBVTT

00:00:10.690 --> 00:00:14.590
Now, I know that a lot of you guys
are brand new to iOS development.

00:00:14.600 --> 00:00:16.100
That's totally fine.

00:00:16.100 --> 00:00:19.100
Keyboard Input Basics are really,
really easy to implement.

00:00:19.140 --> 00:00:21.590
A lot of you guys have
written apps before,

00:00:21.600 --> 00:00:23.700
so for you,
some of this will be a refresher,

00:00:23.780 --> 00:00:26.910
but we do have some brand
new features to show you.

00:00:27.370 --> 00:00:30.050
And then I think that there
are a lot of guys out there,

00:00:30.100 --> 00:00:32.580
some of them sitting in the front row,
that could probably get up here

00:00:32.580 --> 00:00:34.710
and do this presentation for me.

00:00:34.830 --> 00:00:37.020
You guys are writing your
own custom text views,

00:00:37.040 --> 00:00:38.650
and for you,
we have something brand new to

00:00:38.660 --> 00:00:40.700
show you about halfway through.

00:00:40.710 --> 00:00:42.130
So let's get started.

00:00:42.230 --> 00:00:45.100
So I think that no matter
what your experience level is,

00:00:45.100 --> 00:00:49.500
we're all here at WWDC today
because we love making stuff.

00:00:49.540 --> 00:00:52.460
But as much fun as it
is to do what you love,

00:00:52.460 --> 00:00:54.130
you've got to get paid.

00:00:54.400 --> 00:00:57.820
And this figure doesn't even
include Instagram as a big payday.

00:00:59.480 --> 00:01:02.760
So enormous potential in
the App Store marketplace.

00:01:02.760 --> 00:01:04.580
But how do we tap into that?

00:01:05.570 --> 00:01:07.620
Well,
history dictates pretty clearly what kind

00:01:07.620 --> 00:01:09.580
of app rating we need to be successful.

00:01:09.580 --> 00:01:11.820
So that's what we want to
help you out with today.

00:01:11.850 --> 00:01:14.170
Obviously,
you guys are creating the innovation,

00:01:14.180 --> 00:01:15.700
driving people to the app.

00:01:15.700 --> 00:01:18.490
But once they're there,
nearly every app has a keyboard,

00:01:18.490 --> 00:01:19.520
even some games.

00:01:19.520 --> 00:01:21.510
So we think that we
can help you with this.

00:01:23.800 --> 00:01:26.410
So we're going to show you the
basics and along the way show you

00:01:26.530 --> 00:01:30.110
the holes not to fall into and
then we're going to bring the magic

00:01:30.200 --> 00:01:32.720
and show you some new iOS 6 stuff.

00:01:33.670 --> 00:01:36.620
Keyboard input can be
broken into three parts:

00:01:37.000 --> 00:01:40.560
managing the keyboard itself,
static text,

00:01:40.560 --> 00:01:43.050
and then handling live user input.

00:01:43.130 --> 00:01:46.380
I think that you all know
that the keyboard supports

00:01:46.450 --> 00:01:49.510
many different languages,
but what you may not know is that

00:01:49.880 --> 00:01:52.140
it supports emoji for all users.

00:01:52.290 --> 00:01:55.490
We actually have some
brand new emoji in iOS 6,

00:01:55.490 --> 00:01:57.010
like the dude here.

00:01:58.380 --> 00:02:01.710
We'll get back into what emoji
means for you in a minute,

00:02:01.790 --> 00:02:05.020
but for now,
we have four types of size and position

00:02:05.020 --> 00:02:06.350
changes that you need to be aware of.

00:02:06.420 --> 00:02:09.840
And then you need to know the right
way to attach views to the keyboard.

00:02:12.720 --> 00:02:14.550
So size and position changes.

00:02:14.560 --> 00:02:18.420
Bring up, of course,
you have an enormous potential user

00:02:18.420 --> 00:02:23.350
base in Asia Pacific and Japan that
use keyboards with a candidate bar.

00:02:23.680 --> 00:02:26.400
Our users love split
and undock keyboards.

00:02:26.400 --> 00:02:30.000
And as good as our software keyboard is,
a lot of people are

00:02:30.000 --> 00:02:31.980
using hardware keyboards.

00:02:33.340 --> 00:02:38.000
So your users have come to expect from
first party apps like Safari a smooth,

00:02:38.000 --> 00:02:41.200
fluid bring up experience
on keyboard bring up.

00:02:41.200 --> 00:02:46.100
Here Safari fades the UI out and animates
the Google search field to the left.

00:02:46.200 --> 00:02:49.440
They do this with three
pieces of information.

00:02:49.440 --> 00:02:54.630
The animation duration, curve,
and end frame for the keyboard.

00:02:54.990 --> 00:02:56.900
Once they have these
pieces of information,

00:02:56.900 --> 00:02:59.810
they can kick off their own
animations to match keyboard

00:02:59.810 --> 00:03:01.810
bring up animation exactly.

00:03:01.870 --> 00:03:05.840
And they do this in response
to UI keyboard will show.

00:03:06.530 --> 00:03:09.140
You pull this info out
of the notification with

00:03:09.140 --> 00:03:10.900
the user info dictionary.

00:03:10.950 --> 00:03:12.190
You obtain the end frame.

00:03:12.540 --> 00:03:14.900
Now, all of the beginning and
end frames that you'll see,

00:03:14.920 --> 00:03:17.910
remember, are in screen coordinates.

00:03:19.090 --> 00:03:21.300
You get the animation
curve with this key,

00:03:21.300 --> 00:03:22.720
duration with this key.

00:03:22.730 --> 00:03:26.350
Now you have what you need to know
to kick off your own animation.

00:03:26.820 --> 00:03:29.200
When the animation is finished,
keyboard's up,

00:03:29.270 --> 00:03:33.660
you might show an editing toolbar,
scroll the cursor to visible.

00:03:33.660 --> 00:03:36.990
On the flip side,
when the keyboard's coming down,

00:03:36.990 --> 00:03:40.580
you're going to use the exact
same keys as we'll show.

00:03:41.670 --> 00:03:45.010
and then we'll hide when the
keyboard's finally hidden.

00:03:45.250 --> 00:03:46.910
Bring up.

00:03:47.140 --> 00:03:50.750
So again, enormous potential user base
in Asia Pacific and Japan,

00:03:50.760 --> 00:03:53.160
but don't take it from me.

00:03:53.260 --> 00:03:58.000
Now, I think that some of you may never
have seen the candidate bar before.

00:03:58.410 --> 00:03:59.420
This is what it is.

00:03:59.590 --> 00:04:01.910
I have a conversation
with a friend from Japan,

00:04:02.040 --> 00:04:05.800
and I want to respond to her in Japanese,
so I switch to the Japanese keyboard.

00:04:06.000 --> 00:04:09.040
But in this hypothetical example,
messages doesn't respond

00:04:09.040 --> 00:04:11.630
to the candidate bar,
so this balloon is clipped.

00:04:11.740 --> 00:04:14.860
Fixing this is easy
with two notifications:

00:04:14.910 --> 00:04:17.450
"will change frame" and "did
change frame." In response

00:04:17.550 --> 00:04:20.560
to those notifications,
you use these two keys:

00:04:20.620 --> 00:04:22.140
"begin" and "end frame" again.

00:04:22.240 --> 00:04:24.060
And remember screen coordinates.

00:04:24.190 --> 00:04:26.520
Now you can adjust your content.

00:04:29.230 --> 00:04:32.100
Users love split and undocked keyboards.

00:04:32.100 --> 00:04:33.810
And this is what this means for you.

00:04:33.820 --> 00:04:37.300
This is what Safari does in
response to the split keyboard.

00:04:37.300 --> 00:04:39.100
Let me show you a quick demo.

00:04:39.100 --> 00:04:40.790
So here I am in Safari.

00:04:40.790 --> 00:04:48.930
And I'm doing find home page on
this apple.com page for support.

00:04:52.710 --> 00:04:57.600
The content adjusts to take
advantage of the increased space

00:04:57.700 --> 00:04:59.300
of the split keyboard offers.

00:04:59.300 --> 00:05:02.290
And then as I perform find on page,

00:05:07.600 --> 00:05:10.810
The highlighted rect always stays in the
area above the split keyboard so that

00:05:11.020 --> 00:05:13.420
the split keyboard never occludes it.

00:05:13.420 --> 00:05:15.000
And that's it.

00:05:16.350 --> 00:05:17.540
So how did they do this?

00:05:17.550 --> 00:05:20.890
Well, there are three notifications
that they leveraged to do this.

00:05:21.070 --> 00:05:25.300
First, will hide when the keyboard is
about to be split or undocked.

00:05:25.300 --> 00:05:25.910
Did hide.

00:05:26.180 --> 00:05:28.900
At this point, they adjust their content.

00:05:29.200 --> 00:05:32.090
And then as you move the split
keyboard up and down the screen,

00:05:32.090 --> 00:05:34.240
you will receive will and did
change frame notifications.

00:05:34.240 --> 00:05:36.490
And don't forget,
split keyboards are shorter

00:05:36.500 --> 00:05:38.160
than their standard variants.

00:05:41.750 --> 00:05:44.100
Now, again,
as good as the software keyboard is,

00:05:44.100 --> 00:05:47.060
people love using hardware
keyboards for iPad.

00:05:47.070 --> 00:05:50.300
Fortunately,
responding to a hardware keyboard

00:05:50.300 --> 00:05:54.880
being plugged in or disconnected
is exactly the same as dismissal.

00:05:57.210 --> 00:05:59.080
So that's size and position changes.

00:05:59.080 --> 00:06:02.100
Now, to demonstrate some of the concepts
that we're talking about today,

00:06:02.140 --> 00:06:03.900
we've prepared a demo.

00:06:03.900 --> 00:06:07.010
This is called a text-based
role-playing game.

00:06:07.880 --> 00:06:09.740
On the right-hand side,
you have the game story.

00:06:09.810 --> 00:06:12.870
It tells you where you are
and lets you enter commands to

00:06:12.970 --> 00:06:14.400
interact with the game world.

00:06:14.440 --> 00:06:16.390
On the left, character status.

00:06:16.510 --> 00:06:21.450
The problem I have now is
that the UI doesn't respond

00:06:21.450 --> 00:06:24.690
to keyboard split or docking.

00:06:25.580 --> 00:06:29.500
So what I want to do is adjust this
border and the game story view.

00:06:29.500 --> 00:06:32.090
And it's really easy with
what I just showed you.

00:06:40.300 --> 00:06:43.300
So here's keyboard we'll show.

00:06:43.300 --> 00:06:45.020
And all you need is the keyboard frame.

00:06:45.020 --> 00:06:47.920
When the keyboard is being shown,
all you need to know is its height

00:06:47.920 --> 00:06:49.700
since it's docked at the bottom.

00:06:49.820 --> 00:06:52.900
You get the animation curve, duration.

00:06:52.920 --> 00:06:55.010
Now,
when the split keyboard is being docked,

00:06:55.020 --> 00:06:59.160
it will receive again, will show,
but the animation is instantaneous.

00:06:59.160 --> 00:07:03.000
We still want an animation,
so we change the duration to 0.25.

00:07:03.040 --> 00:07:05.860
And then we adjust our border frame.

00:07:07.080 --> 00:07:09.510
In our game text view.

00:07:09.690 --> 00:07:13.140
Really quick, we'll see what that's like.

00:07:14.570 --> 00:07:17.100
There you go.

00:07:17.100 --> 00:07:19.120
So those are size and position changes.

00:07:19.120 --> 00:07:23.000
Now we need to talk about the right
way to attach views to the keyboard.

00:07:23.000 --> 00:07:28.870
What we'd like is to move text entry
from the game story view down to its

00:07:28.870 --> 00:07:31.000
own view that floats above the keyboard.

00:07:31.000 --> 00:07:32.140
You saw this on our app.

00:07:32.140 --> 00:07:33.390
This is what we want to change it to.

00:07:33.400 --> 00:07:36.420
We also have some directional
controls that we'll put in that view.

00:07:36.420 --> 00:07:37.700
How do we float this?

00:07:37.700 --> 00:07:40.120
Well, we've seen a lot of people
try and do this manually.

00:07:40.120 --> 00:07:40.920
It's problematic.

00:07:40.920 --> 00:07:42.320
There's a really easy way to do this.

00:07:42.320 --> 00:07:47.070
just the input accessory view property
on UI text field and UI text view.

00:07:47.370 --> 00:07:51.880
And really quickly,
I'm going to show that.

00:07:51.880 --> 00:07:53.860
So most of this code is
really straightforward.

00:07:53.890 --> 00:07:56.040
I'm just going to show you one thing.

00:07:56.220 --> 00:08:01.140
We have an invisible text view
that we first make first responder.

00:08:01.710 --> 00:08:05.210
This is because the text view
has been moved to a view that

00:08:05.210 --> 00:08:07.200
lives inside the keyboard.

00:08:07.200 --> 00:08:10.110
So when the keyboard is down and you
try to make that first responder,

00:08:10.220 --> 00:08:12.530
it's not in the view hierarchy
and the keyboard doesn't come up.

00:08:12.540 --> 00:08:15.820
So we have an invisible text
view that we create here.

00:08:15.820 --> 00:08:19.240
We make that first responder
once the keyboard is up.

00:08:19.240 --> 00:08:22.250
Then we switch first responder
status to the text view in the

00:08:22.250 --> 00:08:24.800
accessory view and we're good.

00:08:24.800 --> 00:08:27.600
So here it is.

00:08:27.600 --> 00:08:33.010
Coolio.

00:08:37.930 --> 00:08:42.840
So that's everything for
managing the keyboard.

00:08:42.840 --> 00:08:44.250
Now, static text.

00:08:44.260 --> 00:08:46.180
Now,
you don't need to be a Unicode expert,

00:08:46.180 --> 00:08:48.700
but you do need to know some basics.

00:08:48.700 --> 00:08:55.460
Then we're going to unveil a
brand-new feature for custom text

00:08:55.490 --> 00:09:00.100
views and show you how to leverage
UI text input in standard text views.

00:09:00.100 --> 00:09:00.100
It's not just for custom text views.

00:09:01.490 --> 00:09:03.080
So here I am in notes.

00:09:03.260 --> 00:09:06.560
I'm writing with the
Chinese handwriting keyboard.

00:09:06.600 --> 00:09:09.260
And I want this second character here.

00:09:09.320 --> 00:09:10.410
So I pick it.

00:09:10.590 --> 00:09:15.280
But how do I pull this user-visible
character out of the text view?

00:09:15.300 --> 00:09:19.760
You might think, well, character index 0,
it's the first user-visible character.

00:09:19.760 --> 00:09:23.590
The problem here is that a
character index 0 returns a Unicar,

00:09:23.700 --> 00:09:27.640
whereas this character
requires four bytes in memory.

00:09:27.640 --> 00:09:28.940
And the same goes for emoji here.

00:09:28.940 --> 00:09:32.880
So this is what you'd see if
you displayed that to the user.

00:09:33.250 --> 00:09:37.190
Again, this character occupies
four bytes in memory.

00:09:37.190 --> 00:09:40.520
Here's the character, its Unicode value.

00:09:40.520 --> 00:09:41.260
Here it is in memory.

00:09:41.260 --> 00:09:43.560
And again,
if you interpreted it as two separate

00:09:43.560 --> 00:09:46.600
Unicars and displayed it to the user,
this is what you'd get.

00:09:46.700 --> 00:09:53.380
Fortunately, fixing this is simple with a
range of composed character

00:09:53.380 --> 00:09:53.380
sequence at index zero.

00:09:54.940 --> 00:09:56.780
That obtains an NS range
for the character.

00:09:56.780 --> 00:09:59.740
You obtain a string like this,
and you're done.

00:10:01.310 --> 00:10:05.240
What if you have a whole series
of user visible characters?

00:10:05.240 --> 00:10:08.680
Here we are in messages and we want to
obtain a character count for this bubble.

00:10:08.830 --> 00:10:13.200
So we want to enumerate over all of these
user visible characters and count them.

00:10:13.200 --> 00:10:17.230
We just use enumerate substrings
in range options using block

00:10:17.230 --> 00:10:22.310
with the NSString enumeration by
composed character sequences option.

00:10:22.640 --> 00:10:24.820
I'm going to pass this block
to be performed on every

00:10:24.820 --> 00:10:26.620
user-visible character sequence.

00:10:26.620 --> 00:10:28.100
And that's it.

00:10:29.900 --> 00:10:32.300
Just don't assume Unicar.

00:10:32.300 --> 00:10:36.110
You want to be thinking of a string
as being composed of a series

00:10:36.110 --> 00:10:38.560
of composed character sequences.

00:10:38.560 --> 00:10:42.080
You saw enumeration by composed
character sequences for enumeration by

00:10:42.120 --> 00:10:47.770
other textual units see Doug Davidson's
talk on text and linguistic

00:10:47.770 --> 00:10:50.530
analysis that's going on this week.

00:10:51.420 --> 00:11:00.000
and for internationalization
topics that touch on Unicode,

00:11:00.000 --> 00:11:00.000
specifically localizing your
apps in other countries,

00:11:00.000 --> 00:11:00.000
internationalization tips and tricks.

00:11:01.690 --> 00:11:03.500
So we have a brand new feature,
as I said,

00:11:03.700 --> 00:11:06.240
in iOS 6 for custom text views.

00:11:06.240 --> 00:11:10.000
And to introduce it,
I'd like to bring up my colleague,

00:11:10.010 --> 00:11:11.510
Morgan WineR.

00:11:11.510 --> 00:11:11.510
Morgan?

00:11:20.140 --> 00:11:21.640
Little better?

00:11:21.690 --> 00:11:23.430
All right.

00:11:23.510 --> 00:11:24.730
Thank you.

00:11:24.830 --> 00:11:27.230
So we're going to go through the
UI Text Input Protocol today.

00:11:27.520 --> 00:11:35.010
So for those who have seen it before,
we did put it into iOS 3.2,

00:11:35.010 --> 00:11:35.010
and we're going to upgrade it
a little bit today in iOS 6.

00:11:36.160 --> 00:11:40.760
So, real quick,
why would you want a custom text view?

00:11:40.890 --> 00:11:43.560
Well, we provide two text
widgets with the system,

00:11:43.560 --> 00:11:47.230
UI Text View and UI Text Field,
and we'd like to think that

00:11:47.230 --> 00:11:49.800
these take care of as many
possibilities as they can,

00:11:49.800 --> 00:11:52.000
but they really can't handle everything.

00:11:52.130 --> 00:11:53.560
That's up to you.

00:11:53.730 --> 00:12:00.250
You guys have your awesome apps,
and you need some custom functionality

00:12:01.400 --> 00:12:01.400
that we really just can't account for.

00:12:01.860 --> 00:12:03.150
What would you want to do?

00:12:03.430 --> 00:12:04.800
You guys might want 3D text.

00:12:04.800 --> 00:12:06.800
You might want an equation editor.

00:12:06.800 --> 00:12:11.270
Or here in Coda, we have a syntax
highlighting HTML editor.

00:12:12.250 --> 00:12:14.500
So what's involved in this?

00:12:14.560 --> 00:12:17.230
Again, the UI Text Input
protocol being a protocol,

00:12:17.450 --> 00:12:20.740
you can apply it to any UI responder,
any UI view,

00:12:20.740 --> 00:12:26.660
and it'll turn that UI responder
into a text widget that you can

00:12:26.660 --> 00:12:30.080
type into with the system keyboard,
get auto corrections, so on and so forth.

00:12:30.550 --> 00:12:35.000
And it can interact the way that
UI Text View and UI Text Fill do.

00:12:35.000 --> 00:12:38.520
Real quick before we go on,
there's also the opportunity

00:12:38.520 --> 00:12:42.930
with a custom UI Text Input
protocol implementation to

00:12:42.930 --> 00:12:45.400
actually override the tokenizer.

00:12:45.400 --> 00:12:48.100
So there's a UI Text Input
tokenizer class.

00:12:48.210 --> 00:12:50.060
We have a default implementation in it.

00:12:50.060 --> 00:12:51.400
And you can override it.

00:12:51.400 --> 00:12:52.630
So why won't you do this?

00:12:52.830 --> 00:12:56.490
Well, tokenizers actually do the
breakings between characters,

00:12:56.490 --> 00:12:59.320
words, lines, paragraphs,
so on and so forth.

00:12:59.390 --> 00:13:05.400
And say perhaps for Germany you wanted
to not have hyphens break a word.

00:13:05.400 --> 00:13:07.060
That's pretty reasonable.

00:13:07.060 --> 00:13:08.460
So you can customize that.

00:13:08.650 --> 00:13:11.340
Or maybe you want to
change some other things.

00:13:11.390 --> 00:13:14.400
Just wanted to point out that
you do have that ability.

00:13:14.520 --> 00:13:17.480
So with the UI Text Input protocol,
though, up until now,

00:13:17.480 --> 00:13:19.400
you don't get system selection.

00:13:19.400 --> 00:13:21.400
You don't get any selection.

00:13:21.400 --> 00:13:23.370
You have to implement your own caret.

00:13:23.430 --> 00:13:25.400
You have to implement
your own magnifiers.

00:13:25.400 --> 00:13:28.400
And if you really just want
it to act like the system,

00:13:28.400 --> 00:13:30.400
you have to reimplement all the
things that we've already done.

00:13:30.400 --> 00:13:34.900
And that's a lot of work that you guys
could put into making your app special.

00:13:35.930 --> 00:13:39.560
So these are all the things that
are covered by system selection.

00:13:39.560 --> 00:13:41.040
We've got the carrot.

00:13:41.040 --> 00:13:44.170
We've got the range paddles
for the range selection.

00:13:44.380 --> 00:13:47.640
We've got, of course,
the magnifiers and even the

00:13:47.730 --> 00:13:50.000
dictation placeholder dots.

00:13:50.670 --> 00:13:56.130
So now in iOS 6,
we'd like to help you out with those.

00:13:56.820 --> 00:13:59.340
So previously you would
have subclassed UIView,

00:13:59.340 --> 00:14:01.570
most likely,
possibly UIResponder if you wanted

00:14:01.610 --> 00:14:05.200
to implement a different display
layer than your actual backend layer.

00:14:05.320 --> 00:14:08.860
So all you would ideally need to do
is just change what you subclassed.

00:14:09.090 --> 00:14:10.900
That's the opt-in mechanism.

00:14:11.090 --> 00:14:15.300
Subclass UITextView rather
than UIResponder or UIView.

00:14:15.450 --> 00:14:18.270
Now, you'll still have your own backend
implementation behind that,

00:14:18.390 --> 00:14:21.820
but you'll be replacing the
actual functionality that we put

00:14:21.820 --> 00:14:24.210
inside UITextView with your own.

00:14:24.930 --> 00:14:26.730
However,
that's not quite the whole story.

00:14:26.900 --> 00:14:29.740
Turns out the UI text input protocol
wasn't quite ready for this,

00:14:29.750 --> 00:14:31.340
so we've upgraded it.

00:14:31.430 --> 00:14:34.100
There's new selectionRexForRange method.

00:14:34.170 --> 00:14:37.070
Now, the selectionRexForRange

00:14:37.300 --> 00:14:39.600
We'll get into it in
more detail in a second,

00:14:39.640 --> 00:14:42.480
but essentially it's to
handle range selections.

00:14:42.480 --> 00:14:44.870
We already had a caret
rect for position method.

00:14:45.110 --> 00:14:47.200
This is the equivalent
for range selections.

00:14:47.200 --> 00:14:51.190
Also, don't forget,
there's the UI text input delegate.

00:14:51.200 --> 00:14:54.780
So whenever you need to change
the text or the selection,

00:14:54.780 --> 00:14:58.180
and the selection bit's important,
please let us know.

00:14:58.210 --> 00:15:01.610
Call the will change before,
call the did change after.

00:15:01.620 --> 00:15:05.200
That way we can have the system
match what you need it to do.

00:15:05.200 --> 00:15:08.910
So the UI text input protocol needs
to work with a couple of fundamental

00:15:08.910 --> 00:15:11.200
units in order to navigate a document.

00:15:11.200 --> 00:15:13.200
The first of which is UI text position.

00:15:13.200 --> 00:15:15.200
Now this is an abstract base class.

00:15:15.200 --> 00:15:18.470
You have to provide your
own implementation of it.

00:15:18.770 --> 00:15:23.730
But it doesn't specify any IVARs,
doesn't specify any properties, methods,

00:15:23.730 --> 00:15:24.640
anything.

00:15:24.640 --> 00:15:28.680
It's pretty much just an empty
encapsulation of a single position

00:15:28.680 --> 00:15:30.700
in a document such as a caret.

00:15:30.700 --> 00:15:33.700
And we make no assumptions about
what it means for your text storage.

00:15:33.700 --> 00:15:35.700
It could mean whatever you choose.

00:15:36.050 --> 00:15:37.700
Doesn't even have to be unique.

00:15:37.700 --> 00:15:39.450
You could have two UI text
positions that both correspond to

00:15:39.450 --> 00:15:40.680
the same position in the document.

00:15:40.700 --> 00:15:42.700
That's fine.

00:15:42.760 --> 00:15:45.700
But you do have to
provide an implementation.

00:15:45.740 --> 00:15:49.700
So if you stick two
UI text positions together,

00:15:49.720 --> 00:15:51.910
you get a UI text range.

00:15:52.470 --> 00:15:55.760
Now the UI text range is an
interesting little class,

00:15:55.910 --> 00:16:00.960
another abstract-based class that you'd
have to fill in an implementation of.

00:16:01.060 --> 00:16:04.510
So here in the screenshot you see
that there's multiple text directions.

00:16:04.570 --> 00:16:06.540
We have Arabic mixed with English.

00:16:06.630 --> 00:16:10.890
The selection you see here is
actually a single UI text range.

00:16:11.810 --> 00:16:15.500
So the interesting thing about
this is that in that UI text range,

00:16:15.500 --> 00:16:18.440
the English text spans
right into the Arabic text,

00:16:18.490 --> 00:16:21.300
and that's part of a single range,
but they're laid out

00:16:21.320 --> 00:16:23.480
disjointedly on the screen.

00:16:23.660 --> 00:16:25.520
That's possible.

00:16:26.060 --> 00:16:28.580
has to be something that
your document can do.

00:16:28.580 --> 00:16:31.910
Or perhaps you might want to
draw Arabic text a different way,

00:16:31.910 --> 00:16:33.240
and that's fine, too.

00:16:33.240 --> 00:16:35.840
But it does have to be something
you have to be aware of.

00:16:35.840 --> 00:16:39.820
And one final note,
UI text range can actually have the start

00:16:39.960 --> 00:16:43.420
position be the same as the end position,
in which case that's kind

00:16:43.470 --> 00:16:46.960
of an empty selection,
but we still treat that as a carrot.

00:16:47.040 --> 00:16:49.480
Just something to be aware of.

00:16:49.890 --> 00:16:52.550
So now we have this new class,
a new abstract base class, again,

00:16:52.650 --> 00:16:56.940
subclass it and fill in an
implementation of UITextSelectionRect.

00:16:57.070 --> 00:17:02.260
And this, well, individually,
I suppose you can work with it,

00:17:02.320 --> 00:17:03.860
but we ask for an array of them.

00:17:03.950 --> 00:17:09.500
Because a single UITextRange can be
any number of UITextSelectionRects.

00:17:09.570 --> 00:17:10.660
And this is what you'll return.

00:17:10.660 --> 00:17:13.230
You'll return an array of them
from that SelectionRects for range.

00:17:13.280 --> 00:17:14.680
We'll give you the UIRange we need.

00:17:14.860 --> 00:17:16.870
You'll give us back the rects.

00:17:17.190 --> 00:17:19.400
So there's a couple of
interesting things about this,

00:17:19.400 --> 00:17:20.260
too.

00:17:20.300 --> 00:17:21.600
Contains start and contains end.

00:17:21.790 --> 00:17:25.030
This is how we know where to
put those little blue paddles.

00:17:25.620 --> 00:17:28.430
So please return yes once and
only once for each of those.

00:17:28.430 --> 00:17:32.340
If you have 10 UI selection recs,
please return yes once for a

00:17:32.340 --> 00:17:36.100
Canadian start and a Canadian send
across the array of them.

00:17:36.690 --> 00:17:39.750
Also note,
that dinner plans line on the first row,

00:17:39.750 --> 00:17:43.760
it doesn't take up the whole row,
but the selection does.

00:17:43.880 --> 00:17:45.510
Line wrapping.

00:17:45.700 --> 00:17:48.770
It is entirely up to you,
but please make a decision and

00:17:48.770 --> 00:17:52.470
stick your implementation to it.

00:17:53.050 --> 00:17:59.070
Also, you'll note that between rows
of text in this selection,

00:17:59.070 --> 00:17:59.070
there's no gaps.

00:17:59.320 --> 00:18:03.140
And that's because we actually went
out of our way to fill in the line

00:18:03.140 --> 00:18:04.910
spacing with the selection reqs.

00:18:05.150 --> 00:18:07.400
Again,
that is something we're leaving entirely

00:18:07.430 --> 00:18:09.430
up to you with your text selection reqs.

00:18:09.490 --> 00:18:10.560
Just something to be aware of.

00:18:10.650 --> 00:18:15.070
And then finally, yes,
they're fairly cheap views to have,

00:18:15.440 --> 00:18:17.100
but they're not free.

00:18:17.220 --> 00:18:20.020
So if you can find a way to
union them together just so that

00:18:20.020 --> 00:18:23.200
we don't end up with a million
of them for a single selection,

00:18:23.200 --> 00:18:24.470
that would be good.

00:18:25.310 --> 00:18:27.130
And then finally,
the dictation thinking dots,

00:18:27.160 --> 00:18:32.080
these little purple dots that show
up when dictation is taking its time

00:18:32.080 --> 00:18:34.730
to translate your voice into text.

00:18:35.320 --> 00:18:37.360
That's part of the selection system.

00:18:37.510 --> 00:18:40.000
So you can get this now, too.

00:18:40.150 --> 00:18:41.470
There's these three optional methods.

00:18:41.520 --> 00:18:43.480
You can choose to skip
them if you'd like.

00:18:43.720 --> 00:18:46.390
Insert dictation result placeholder.

00:18:46.810 --> 00:18:50.280
So we're going to ask for a
placeholder from your text widget.

00:18:50.520 --> 00:18:52.600
It's an ID and NSObject.

00:18:52.640 --> 00:18:56.680
Again, we make no assumption what that
means for your internal storage.

00:18:57.150 --> 00:18:58.930
We will ask for the frame of it, though.

00:18:59.110 --> 00:19:01.100
And this is how you pick
the size of those dots.

00:19:01.210 --> 00:19:03.070
If you want to scale
it to your text height,

00:19:03.340 --> 00:19:04.220
that's fine.

00:19:04.540 --> 00:19:08.870
You might want to just
use a UI text position.

00:19:09.710 --> 00:19:13.050
The text position would actually
be a fairly ideal thing to return,

00:19:13.160 --> 00:19:14.100
but again, we'd make no assumptions.

00:19:14.100 --> 00:19:16.210
And then when we're done with
the dictation placeholder,

00:19:16.210 --> 00:19:18.920
we'll pass it back to you,
let you know whether the user canceled

00:19:18.920 --> 00:19:23.800
dictation or has some text coming,
and then you can clean it up.

00:19:24.500 --> 00:19:26.630
So let's take a look at this.

00:19:26.780 --> 00:19:30.860
So right here,
I have a very simple text implementation.

00:19:30.920 --> 00:19:32.950
It's a subclass of UIView.

00:19:33.020 --> 00:19:35.640
It's very, very, very simple.

00:19:35.710 --> 00:19:37.100
There's a fixed amount of text.

00:19:37.230 --> 00:19:39.630
I've already preloaded it.

00:19:41.320 --> 00:19:44.790
The keyboard comes up, but I can't really
interact with the document.

00:19:44.830 --> 00:19:46.600
I don't have any gestures on it.

00:19:46.630 --> 00:19:50.150
I've just really subclassed UIView,
no carets.

00:19:50.280 --> 00:19:52.180
And that's what we've had up to now.

00:19:52.430 --> 00:19:56.580
I do have an implementation
for selectionRex for range.

00:19:56.640 --> 00:20:01.290
So I'm just going to change this
to be a subclass of UITextView.

00:20:01.730 --> 00:20:03.520
Build and run that.

00:20:03.570 --> 00:20:05.160
Hey, I've got a carrot.

00:20:05.580 --> 00:20:09.210
Let me hold down, drag it around.

00:20:09.450 --> 00:20:13.310
I double clicked there and it filled out
the selection to contain the entire word.

00:20:13.420 --> 00:20:14.760
That works too.

00:20:14.860 --> 00:20:17.840
So, give it a shot.

00:20:18.110 --> 00:20:19.660
Let us know what you think.

00:20:19.710 --> 00:20:23.840
And please, of course,
file bugs if you have any problems.

00:20:23.840 --> 00:20:26.500
And that's system selection in iOS 6.

00:20:30.490 --> 00:20:34.100
So Morgan talked about UI text
input in custom text views,

00:20:34.100 --> 00:20:37.310
but you can also leverage
it in standard text views.

00:20:38.110 --> 00:20:42.230
This is VoiceOver's screen reader
reading paragraphs at a time,

00:20:42.280 --> 00:20:46.190
and it implements a paragraph
at point with UI text input.

00:20:47.090 --> 00:20:50.190
This is iBooks doing word-by-word
highlighting and it implements

00:20:50.190 --> 00:20:52.640
Word at Point using UI text input.

00:20:52.710 --> 00:20:54.350
How does this work?

00:20:56.220 --> 00:21:00.390
Well, I've written a range for a word
at point that takes in a point P,

00:21:00.390 --> 00:21:04.850
and you obtain a UI text position
with closest position to point,

00:21:04.870 --> 00:21:08.920
and then a range around the word
with range and closing position

00:21:08.920 --> 00:21:12.860
with granularity in direction,
with word granularity.

00:21:12.880 --> 00:21:17.660
And you want to use UI text layout
direction forward here to get the

00:21:17.660 --> 00:21:22.930
next word at a word boundary instead
of UI text layout direction right so

00:21:22.940 --> 00:21:23.680
your code works in right to left text.

00:21:25.590 --> 00:21:28.090
And you're done.

00:21:28.230 --> 00:21:30.980
This is an auto correction feature
that we've had for a while.

00:21:30.980 --> 00:21:33.020
When you backspace,
you get alternate suggestions

00:21:33.080 --> 00:21:34.280
for the previous word.

00:21:34.310 --> 00:21:36.690
Well, how do you get that previous word?

00:21:38.730 --> 00:21:42.110
Obtain the cursor position
with selected text range.

00:21:42.110 --> 00:21:44.810
In the event that your
selection is a range,

00:21:45.030 --> 00:21:47.920
just grab it, start,
and then go to the previous

00:21:47.920 --> 00:21:51.990
word with position from position
to boundary and direction.

00:21:52.200 --> 00:22:01.380
Again, using UI text storage direction
backward here instead of left so that

00:22:01.380 --> 00:22:01.380
your code works in right to left text.

00:22:03.410 --> 00:22:05.910
And now you obtain a word range
with those two positions with

00:22:05.920 --> 00:22:09.370
text from position to position.

00:22:11.780 --> 00:22:13.950
and pull your string with text and range.

00:22:14.160 --> 00:22:16.550
And that's managing static text.

00:22:16.550 --> 00:22:17.770
Now user input.

00:22:17.770 --> 00:22:21.750
So for you new guys,
text input traits are a really easy way

00:22:21.750 --> 00:22:24.700
to improve the text input experience.

00:22:25.080 --> 00:22:32.630
Then we have a brand new way to
do rich text editing that's a lot

00:22:32.630 --> 00:22:33.200
easier than what we had before.

00:22:33.200 --> 00:22:33.200
And we have some dictation APIs.

00:22:34.590 --> 00:22:36.490
Now, we have eight traits in total.

00:22:36.550 --> 00:22:39.120
I'm just going to show you
the most important three.

00:22:39.120 --> 00:22:41.560
Now,
keyboard type is usually pretty obvious.

00:22:41.560 --> 00:22:44.140
URL field here.

00:22:44.140 --> 00:22:45.960
Phone pad.

00:22:45.960 --> 00:22:47.430
This case is kind of interesting.

00:22:47.430 --> 00:22:50.330
This is username entry in
the Apple ID sign-on sheet.

00:22:50.330 --> 00:22:53.290
And we use the email keyboard
here because usernames

00:22:53.290 --> 00:22:54.970
are often email addresses.

00:22:56.180 --> 00:22:56.990
Auto correction.

00:22:57.000 --> 00:23:04.480
When would you ever want to
turn off auto correction?

00:23:04.840 --> 00:23:07.710
Again, user name field in the
Apple ID sign-on sheet because

00:23:07.710 --> 00:23:07.710
usernames are often not real words.

00:23:10.290 --> 00:23:11.200
auto capitalization type.

00:23:11.200 --> 00:23:13.560
Context does a really good job of this.

00:23:13.560 --> 00:23:17.900
Word capitalization and
character capitalization here.

00:23:17.900 --> 00:23:21.390
And those are traits and setting
them is really easy in Xcode.

00:23:24.120 --> 00:23:25.240
So that's traits.

00:23:25.260 --> 00:23:28.690
Now, to do rich text editing
on the system before,

00:23:28.840 --> 00:23:33.500
you used to have to write a custom text
view or use a UI web view in JavaScript,

00:23:33.510 --> 00:23:34.730
HTML, CSS.

00:23:34.800 --> 00:23:36.840
You don't have to do that anymore.

00:23:36.930 --> 00:23:38.910
It's really just --

00:23:43.080 --> 00:23:44.760
So a couple things to this.

00:23:44.760 --> 00:23:47.340
Bold Italic and Underline controls,
as you see here.

00:23:49.700 --> 00:23:54.180
multi-styled text with NS attributed
string and typing style.

00:23:54.180 --> 00:23:58.400
Bold italic and underline controls,
easy to implement with

00:23:58.410 --> 00:24:00.410
just a single property.

00:24:02.470 --> 00:24:05.290
Now let's add some
multi-styled text to our game.

00:24:05.300 --> 00:24:08.250
We want to highlight important stuff.

00:24:16.640 --> 00:24:20.790
So I'm just going to
show you styling north,

00:24:20.880 --> 00:24:23.020
south, east, and west.

00:24:28.470 --> 00:24:32.680
And then we'll do an
extended example in a minute.

00:24:32.730 --> 00:24:34.720
Actually,
let's talk about NSAttributedString

00:24:34.720 --> 00:24:35.760
before we do this.

00:24:35.770 --> 00:24:37.800
I'm just going to show
you the end result.

00:24:41.300 --> 00:24:43.200
So let's look around.

00:24:43.200 --> 00:24:44.960
All right.

00:24:44.960 --> 00:24:47.160
So we've got an imaginary friend
Bill here who's going to help

00:24:47.160 --> 00:24:48.400
us kill this undead pirate.

00:24:48.400 --> 00:24:52.390
But before we do that,
let's talk about NSAttributedString.

00:24:54.790 --> 00:24:58.860
Styling these first two characters,
or the third and fourth

00:24:58.860 --> 00:25:02.100
character green here,
how does this work?

00:25:02.250 --> 00:25:06.600
We're going to create an
NSMutable attribute string to

00:25:06.600 --> 00:25:06.600
make it easier to work with.

00:25:07.500 --> 00:25:08.390
And then we add the style.

00:25:08.400 --> 00:25:13.690
A style is composed of just three parts,
the attribute key, the attribute value,

00:25:13.700 --> 00:25:17.250
and then the range that
the style applies to.

00:25:18.540 --> 00:25:23.380
And we have some attributes for styles
that you couldn't get previously,

00:25:23.500 --> 00:25:29.400
like highlight, text shadow,
and underlining.

00:25:31.970 --> 00:25:35.240
So I'm gonna throw some strikethrough
onto this string like this.

00:25:35.240 --> 00:25:39.100
Now, strikethrough,
to turn strikethrough on,

00:25:39.100 --> 00:25:42.120
use NSNumber number with bool yes.

00:25:42.120 --> 00:25:46.340
But we have a new shorthand with
Objective-C literals that you may have

00:25:46.790 --> 00:25:49.520
seen for NSNumber that's just @yes.

00:25:49.580 --> 00:25:52.250
And you throw it in the
text field like this.

00:25:53.790 --> 00:25:57.180
Rich text editing isn't the only
thing using NS Attributed String.

00:25:57.180 --> 00:25:59.880
You've got NS Attributed
String all over the system,

00:25:59.880 --> 00:26:01.100
buttons and labels.

00:26:01.100 --> 00:26:05.600
Here's reminders using it
to do these priority glyphs.

00:26:07.480 --> 00:26:10.400
Real quick typing attributes and
then we'll jump back to the demo.

00:26:10.400 --> 00:26:11.940
This is a way to set typing styles.

00:26:11.940 --> 00:26:16.360
So what we want to have is the
ability to color things in the text

00:26:16.360 --> 00:26:21.900
entry view after commands on the fly
to match what's in the game story.

00:26:21.900 --> 00:26:25.890
So if I type kill,
I want to turn on a red typing style.

00:26:26.710 --> 00:26:29.580
This is super easy
with typing attributes.

00:26:29.580 --> 00:26:33.250
You just get the typing attributes,
add what you want, and then set it back.

00:26:33.370 --> 00:26:37.590
Typing attributes change as you
change the selection to match the

00:26:37.600 --> 00:26:40.440
style of the current selection.

00:26:40.540 --> 00:26:43.270
So real quick, let's go back to the demo.

00:26:44.980 --> 00:26:50.640
And I'm going to turn on both typing
attributes and multi-style text.

00:26:50.640 --> 00:26:52.740
And I want to get kind of
pumped for this battle,

00:26:52.740 --> 00:26:55.710
so I'm going to throw
on some battle tunes.

00:27:07.500 --> 00:27:09.660
So, yeah, let's try to do this.

00:27:09.660 --> 00:27:14.860
So we swing and miss,
and now we're... Yeah,

00:27:14.860 --> 00:27:16.620
that was kind of embarrassing.

00:27:16.620 --> 00:27:17.360
That wasn't supposed to happen.

00:27:17.360 --> 00:27:18.980
Let's go back to the slides.

00:27:18.980 --> 00:27:22.400
But you saw, real quick before we leave,
you saw typing attributes.

00:27:22.400 --> 00:27:23.120
I type kill.

00:27:23.120 --> 00:27:24.160
I get kill pirate.

00:27:24.160 --> 00:27:25.920
If I want to say something,
I get say hello.

00:27:25.920 --> 00:27:26.560
It's green.

00:27:26.560 --> 00:27:27.630
And that's it.

00:27:27.630 --> 00:27:28.680
Thanks a lot.

00:27:35.260 --> 00:27:37.390
Wrapping up, we have dictation APIs.

00:27:37.390 --> 00:27:40.880
Your users love dictation,
but what does that mean for you?

00:27:40.880 --> 00:27:43.700
Well, we have the ability to get
dictation alternatives.

00:27:45.540 --> 00:27:46.860
Here's an idea.

00:27:46.910 --> 00:27:49.790
I mocked up a messages
app that when you search,

00:27:49.790 --> 00:27:53.900
searches not just for dictation
results but dictation alternatives.

00:27:53.900 --> 00:27:59.890
For instance, if I say "flower" and
I get "flower" underlined,

00:28:00.080 --> 00:28:06.650
I get not just results for Flour,
F-L-O-W-E-R, but also Flour, F-L-O-U-R.

00:28:07.220 --> 00:28:08.800
So how do we do this?

00:28:08.850 --> 00:28:12.240
Just catch insert dictation
result on your UI text field

00:28:12.240 --> 00:28:14.240
or UI text view subclass.

00:28:14.360 --> 00:28:15.750
Iterate over the result.

00:28:15.880 --> 00:28:19.320
It's a series of UI dictation phrases.

00:28:19.450 --> 00:28:22.950
Each dictation phrase is going
to have zero more alternatives.

00:28:22.960 --> 00:28:26.150
And with those alternatives,
you can build the entire set of

00:28:26.290 --> 00:28:28.400
interpretations for this result.

00:28:28.470 --> 00:28:30.730
So great documentation.

00:28:30.770 --> 00:28:31.160
Check it out.

00:28:31.230 --> 00:28:32.400
Come to the lab.

00:28:32.400 --> 00:28:34.400
Email Paul Marcus if you get stuck.

00:28:34.480 --> 00:28:37.190
Our application service is Evangelist.

00:28:37.690 --> 00:28:40.160
Again, attributed string isn't just
about rich text editing.

00:28:40.230 --> 00:28:41.480
It's all over the system.

00:28:41.480 --> 00:28:44.880
We have two sessions this week,
internationalization tips

00:28:44.940 --> 00:28:46.520
and tricks for Unicode.

00:28:46.520 --> 00:28:48.970
So real quick and then
you guys are out of here.

00:28:48.980 --> 00:28:53.400
Keyboard size and position changes,
attaching views to the keyboard,

00:28:53.400 --> 00:28:56.750
Unicode basics,
brand new way to do system selection

00:28:56.750 --> 00:28:59.800
easily in custom text views.

00:28:59.800 --> 00:29:02.800
UITextInput isn't just
about custom text views.

00:29:02.800 --> 00:29:04.560
It applies to standard
text views as well.

00:29:04.850 --> 00:29:06.700
There's some interesting
ways to leverage it.

00:29:06.700 --> 00:29:10.560
You got traits, super important for
you guys that are new.

00:29:10.560 --> 00:29:14.200
New easy way to do rich text
editing and dictation APIs.

00:29:14.350 --> 00:29:14.990
Thanks a lot, guys.
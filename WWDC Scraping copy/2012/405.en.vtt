WEBVTT

00:00:10.960 --> 00:00:21.730
I'm Patrick Beard,
and I work on Objective-C.

00:00:21.840 --> 00:00:23.610
Let me tell you,
it's a real honor to get to work

00:00:23.690 --> 00:00:26.510
on this 30-year-old language.

00:00:29.460 --> 00:00:32.490
So Objective-C is popular,
and I can see that by how

00:00:32.490 --> 00:00:34.710
many of you are here today.

00:00:35.810 --> 00:00:39.750
In the last five years, the popularity,
according to the Tyobi

00:00:39.750 --> 00:00:43.900
Programming Community Index,
has gone up from, well,

00:00:43.900 --> 00:00:48.880
number 45-- this is popularity
in terms of search engine hits

00:00:49.030 --> 00:00:51.500
on the popular search engines--

00:00:52.040 --> 00:01:00.210
To number six last year,
and this year we've broken the top five.

00:01:05.500 --> 00:01:07.700
Mention number five.

00:01:07.700 --> 00:01:13.140
So let's talk about some of the history,
just a little bit of the

00:01:13.140 --> 00:01:15.060
history of the language.

00:01:15.060 --> 00:01:20.460
Started back in the late -- early '80s,
Brad Cox, StepStone.

00:01:20.570 --> 00:01:23.430
And the Object-Oriented-C,
very small language.

00:01:23.430 --> 00:01:26.290
I sort of think of it as
the ukulele of languages.

00:01:26.350 --> 00:01:30.900
It's a very powerful but small language.

00:01:32.790 --> 00:01:34.400
Then a little company
you may have heard of,

00:01:34.400 --> 00:01:38.660
Next, got hold of it,
added some nice features to the language,

00:01:38.830 --> 00:01:42.580
protocols, which are wonderful,
and retain and release,

00:01:42.670 --> 00:01:48.030
a memory management model that allows
you to write more scalable programs,

00:01:48.040 --> 00:01:52.410
and some great frameworks,
many of which we're still using today.

00:01:54.940 --> 00:01:58.790
When we got a hold of it, Apple that is,
we added some new features.

00:01:58.940 --> 00:02:03.310
We made -- we streamlined your
code by providing properties which

00:02:03.310 --> 00:02:05.800
automate the accessor pattern.

00:02:06.010 --> 00:02:10.000
And we added fast enumeration,
which makes your code more efficient,

00:02:10.000 --> 00:02:10.990
more concise.

00:02:11.650 --> 00:02:12.600
So there's a theme here.

00:02:12.600 --> 00:02:14.940
We are simplifying the
language we'd like to say.

00:02:14.940 --> 00:02:16.570
We're adding features.

00:02:16.690 --> 00:02:18.720
We added blocks,
which make it a lot easier to

00:02:18.800 --> 00:02:21.400
do multi-threaded programming.

00:02:21.500 --> 00:02:25.200
And finally, Arc,
which automates retain and release,

00:02:25.310 --> 00:02:28.750
makes the memory management a
lot simpler in your program.

00:02:32.110 --> 00:02:33.110
So we haven't been idle.

00:02:33.340 --> 00:02:35.560
This past year,
we've been adding some additional

00:02:35.560 --> 00:02:40.120
features to the language that I'm
happy to present to you today.

00:02:40.230 --> 00:02:42.850
These are going to help
simplify your code and help you

00:02:42.850 --> 00:02:46.080
avoid making common mistakes.

00:02:46.630 --> 00:02:50.740
So let's start off with a very
fundamental feature of the language:

00:02:50.790 --> 00:02:52.100
methods.

00:02:52.170 --> 00:02:55.770
Methods are how you give
behavior to your objects.

00:02:56.680 --> 00:02:59.940
So everybody's written, hopefully,
a class like this.

00:03:00.050 --> 00:03:03.880
It has a public method that's used
by the customers of your code.

00:03:03.880 --> 00:03:05.340
And it has a private method.

00:03:05.340 --> 00:03:09.130
So in this case, the public method says,
let's play a song.

00:03:09.130 --> 00:03:11.520
And we have some sort of song object.

00:03:11.580 --> 00:03:14.500
And the private method is
used to manage the audio,

00:03:14.560 --> 00:03:19.760
manage the audio engine that's
underlying the song player.

00:03:20.250 --> 00:03:23.100
Now, if you write it like
I've written it here,

00:03:23.170 --> 00:03:25.920
with the current compilers,
the previous compilers,

00:03:25.950 --> 00:03:28.020
you're going to get a warning.

00:03:28.110 --> 00:03:30.520
It says, basically, hey,
I have not seen this method.

00:03:30.650 --> 00:03:32.640
You're calling it before
you've even declared it.

00:03:32.680 --> 00:03:34.340
What's up with that?

00:03:35.550 --> 00:03:38.800
So let's talk about a couple
ways we could fix this problem.

00:03:38.850 --> 00:03:41.500
Oh, and by the way,
if you try to do this under Arc,

00:03:41.510 --> 00:03:42.760
Arc's going to complain even more.

00:03:42.760 --> 00:03:45.350
It's going to make it an error.

00:03:45.770 --> 00:03:47.500
Because it needs to know
about memory management,

00:03:47.500 --> 00:03:50.840
return types, all those details.

00:03:53.520 --> 00:03:59.290
So we can fix this by putting the
private method in the public interface.

00:03:59.390 --> 00:04:00.860
Probably not a good idea.

00:04:00.990 --> 00:04:04.200
Your clients,
the people who use your class,

00:04:04.240 --> 00:04:05.400
are going to be confused by that.

00:04:05.400 --> 00:04:06.960
Which one do I call?

00:04:07.080 --> 00:04:08.820
So don't do that.

00:04:09.750 --> 00:04:14.590
Another possibility is to use this whizzy
new feature we call Class Extensions.

00:04:14.730 --> 00:04:18.110
Class Extensions let you
segregate your private interfaces

00:04:18.160 --> 00:04:21.170
and your public interfaces,
and you can put them in separate

00:04:21.170 --> 00:04:24.290
header files for separate compilation.

00:04:24.980 --> 00:04:29.580
They also give you a way to add
properties that are private,

00:04:29.700 --> 00:04:35.880
properties that might be used by the
nib to actually assign a button so

00:04:35.880 --> 00:04:39.740
you can control playback of your song.

00:04:39.830 --> 00:04:40.740
This is also a detail.

00:04:40.740 --> 00:04:42.900
It doesn't really need to be
in your class's header file.

00:04:42.900 --> 00:04:46.890
And with the latest software,
the latest compilers,

00:04:46.890 --> 00:04:50.020
and our new Xcode IDE,
we can find our outlets

00:04:50.160 --> 00:04:52.000
in our class extensions.

00:04:52.100 --> 00:04:53.800
But for this case,
this is probably overkill.

00:04:53.910 --> 00:04:57.760
This is a real simple solution.

00:04:57.800 --> 00:05:01.250
We can just reorder the methods
in this particular case.

00:05:02.500 --> 00:05:05.260
However, there might be cases where
you can't reorder the methods.

00:05:05.260 --> 00:05:07.490
The methods might be mutually recursive.

00:05:07.540 --> 00:05:11.240
It just may not make sense
to the flow of your program.

00:05:11.370 --> 00:05:13.560
So we want to make it easier.

00:05:13.590 --> 00:05:18.690
And with the latest compiler,
the way I wrote it before just works.

00:05:24.490 --> 00:05:26.700
So let's talk about how it works.

00:05:26.750 --> 00:05:31.690
The compiler, when it compiles the
implementation of your class,

00:05:31.870 --> 00:05:33.280
sort of looks ahead.

00:05:33.340 --> 00:05:37.400
It looks at all the headers
of all the methods first.

00:05:37.800 --> 00:05:40.390
Then it's buffering up
the implementations,

00:05:40.480 --> 00:05:43.330
the bodies of the methods,
and it goes back, and it now has a

00:05:43.330 --> 00:05:44.920
complete list of methods.

00:05:44.960 --> 00:05:49.830
So methods that you didn't declare
in any other place are effectively

00:05:49.970 --> 00:05:52.960
declared by the implementation itself.

00:05:52.960 --> 00:05:57.030
No warning, no problem.

00:05:57.030 --> 00:05:57.030
It just works.

00:05:59.390 --> 00:06:02.280
So now I want to talk about another
fundamental feature of language,

00:06:02.470 --> 00:06:04.730
enumerated constants.

00:06:09.530 --> 00:06:13.140
Before OS 10.5,
if you were to look at our header files,

00:06:13.250 --> 00:06:17.090
and believe me, I looked,
you would find your

00:06:17.090 --> 00:06:18.800
enums declared like this.

00:06:18.800 --> 00:06:21.700
And you might do so in your code as well,
because it's simple.

00:06:21.700 --> 00:06:27.210
The problem with it is that the type used
to represent variables that hold your

00:06:27.460 --> 00:06:30.850
enumerated constants is indeterminate.

00:06:30.860 --> 00:06:34.940
It totally depends on the data
that is spanned or defined

00:06:34.940 --> 00:06:37.060
by these enum constants.

00:06:37.480 --> 00:06:40.860
So you might have negative numbers,
or you might have really big numbers,

00:06:40.860 --> 00:06:41.700
really big integers.

00:06:41.700 --> 00:06:43.360
So it doesn't fit in an integer.

00:06:43.360 --> 00:06:44.870
It may require a long integer.

00:06:48.510 --> 00:06:51.490
So when we went to 64-bit
in the 64-bit transition,

00:06:51.540 --> 00:06:54.180
we realized we needed to
do something about this.

00:06:54.180 --> 00:06:57.360
So we use what we call
explicit type enums.

00:06:57.360 --> 00:07:01.830
This is separating out the
declaration of the enum type from

00:07:02.050 --> 00:07:03.420
the definition of the constants.

00:07:03.420 --> 00:07:08.100
So you're guaranteed it's more
portable between 32-bit and 64-bit.

00:07:08.100 --> 00:07:10.190
You'll always get a predictable size.

00:07:10.220 --> 00:07:12.620
But there's a downside to this.

00:07:12.620 --> 00:07:17.700
There's no formal relationship between
the type and the constants themselves.

00:07:18.400 --> 00:07:21.960
So, well, we can't do any type checking,
for one thing.

00:07:22.060 --> 00:07:25.240
And it makes it harder
to do code completion.

00:07:28.470 --> 00:07:34.480
So we've adopted a feature from C++11,
we've added it right into Objective-C,

00:07:34.480 --> 00:07:38.300
that combines the best
of these two approaches.

00:07:38.410 --> 00:07:41.300
We call it enums with
fixed underlying type,

00:07:41.480 --> 00:07:44.300
and as you can see,
it looks a lot like inheritance.

00:07:44.360 --> 00:07:50.500
This NSNumber formatter style is
effectively a subtype of NSU integer.

00:07:50.820 --> 00:07:52.740
So this gives us better code completion.

00:07:52.860 --> 00:07:54.190
This gives us type checking.

00:07:54.200 --> 00:07:58.820
We can actually know if we use a wrong
constant with one of these types.

00:08:00.980 --> 00:08:04.960
If you're using-- if you're taking
a look at our latest header files,

00:08:04.960 --> 00:08:08.990
you're going to see the introduction
of this using the NSEnum macro,

00:08:09.150 --> 00:08:12.950
which is basically a macro that
checks whether or not fixed

00:08:12.950 --> 00:08:15.620
underlying types are available.

00:08:15.720 --> 00:08:18.820
So you'll see this in Foundation and
other frameworks that adopt this.

00:08:18.920 --> 00:08:21.440
And you can use it in your own code.

00:08:22.550 --> 00:08:28.730
So let's give an example of what
using an explicit type enum gives you.

00:08:29.160 --> 00:08:32.200
With this particular type,
we've got the NSAnimation curve,

00:08:32.260 --> 00:08:34.870
which hasn't been migrated
yet to use NSEnum.

00:08:34.880 --> 00:08:38.710
So we type in this variable,
we hit NSAnimation because we know

00:08:38.710 --> 00:08:42.740
the constants must begin with that,
and we hit escape and get

00:08:42.770 --> 00:08:46.320
our code completion going,
and we're presented with

00:08:46.320 --> 00:08:48.130
all these anonymous enums.

00:08:48.890 --> 00:08:53.430
So these are enums that have just
been used to generate values and

00:08:53.430 --> 00:08:56.120
don't have anything tied to them.

00:08:57.350 --> 00:09:00.660
I happen to know NSAnimationBlocking
is not a member of this type,

00:09:00.760 --> 00:09:04.590
so we could easily make a mistake
when we use our code completion.

00:09:16.370 --> 00:09:16.370
When we use an enum with
fixed underlying type,

00:09:16.370 --> 00:09:16.370
it's a much better experience.

00:09:16.370 --> 00:09:16.370
The pop-up can show you the types.

00:09:16.370 --> 00:09:16.370
Moreover,

00:09:31.260 --> 00:09:31.260
When you use the -wconversion
warnings flag on the compiler,

00:09:31.260 --> 00:09:31.260
if we write this,
this happens to be not the correct type,

00:09:31.260 --> 00:09:31.260
it's going to tell us.

00:09:31.260 --> 00:09:31.280
It's going to tell us
we made this mistake.

00:09:33.040 --> 00:09:38.740
One other benefit of this is it can now
again tell you that you missed something

00:09:38.740 --> 00:09:40.540
if you're using a switch statement.

00:09:40.690 --> 00:09:42.900
There are other enums
you're not handling.

00:09:42.900 --> 00:09:45.500
So you can make your
code more bulletproof,

00:09:45.700 --> 00:09:49.020
added default if you don't
care about the other values.

00:09:49.800 --> 00:09:52.980
So that's fixed underlying types.

00:09:53.040 --> 00:09:55.580
Now I'd like to talk about properties.

00:09:58.170 --> 00:10:00.940
So properties are great.

00:10:00.950 --> 00:10:03.700
I think they're a success
by any measure of the word.

00:10:03.700 --> 00:10:04.400
People use them.

00:10:04.400 --> 00:10:06.510
They're ubiquitous.

00:10:06.750 --> 00:10:11.250
They simplify your code,
so you can focus on writing the code that

00:10:11.250 --> 00:10:13.930
you need to write to make your app work.

00:10:14.550 --> 00:10:18.210
A new feature we introduced recently
was the ability to segregate

00:10:18.210 --> 00:10:22.740
your instance variables as well
from the header of your class.

00:10:22.900 --> 00:10:25.930
So if you like,
you can put your instance variables in

00:10:25.990 --> 00:10:28.380
the add implementation block itself.

00:10:29.900 --> 00:10:35.030
However, if you synthesize properties,
you don't need to declare

00:10:35.030 --> 00:10:37.200
the instance variable at all.

00:10:37.200 --> 00:10:37.900
We've known that.

00:10:37.900 --> 00:10:40.200
We've had that for a long time.

00:10:40.490 --> 00:10:44.060
Well, I'm happy to say,
as of Xcode 4.4 and later,

00:10:44.060 --> 00:10:46.990
you don't have to write anything.

00:10:47.710 --> 00:10:50.900
Synthesis is now default.

00:10:51.050 --> 00:10:56.560
So with this,
you get a fully baked model object here,

00:10:56.560 --> 00:10:58.600
this person class.

00:10:58.710 --> 00:11:02.490
Now remember, if you're not using Arc,
you'll have to write a dealloc method to

00:11:02.490 --> 00:11:05.050
make sure you don't have memory leaks.

00:11:05.170 --> 00:11:07.820
So one line is all you need.

00:11:11.990 --> 00:11:16.020
So there's some implications to the
way instance variables are synthesized.

00:11:16.200 --> 00:11:17.910
Let's talk about that.

00:11:18.350 --> 00:11:21.970
When you're synthesizing properties,
you need to know the name of the instance

00:11:22.070 --> 00:11:24.570
variable that you're going to get.

00:11:25.280 --> 00:11:29.510
If you use Synthesize by default,
you're going to get an instance

00:11:29.510 --> 00:11:31.600
variable with the underscore prefix.

00:11:31.690 --> 00:11:34.280
We've made that the new default.

00:11:40.280 --> 00:11:45.190
You're applauding,
so you probably know why.

00:11:45.270 --> 00:11:48.000
This has been a convention
that's been debated for a while,

00:11:48.000 --> 00:11:52.300
whether or not Apple reserves
underscore-prefixed instance variables.

00:11:52.350 --> 00:11:53.300
We don't.

00:11:53.300 --> 00:11:55.100
We highly recommend you use them.

00:11:55.290 --> 00:11:58.120
It makes your code clearer
when you're using your instance

00:11:58.120 --> 00:11:59.590
variables more directly.

00:12:00.190 --> 00:12:02.790
So, you're writing a method, for example,
a description method,

00:12:02.790 --> 00:12:05.070
and you're going to access
that variable directly.

00:12:05.100 --> 00:12:06.310
This is what it's going to look like.

00:12:06.470 --> 00:12:10.530
Underscore is the new default.

00:12:11.640 --> 00:12:17.570
So to summarize how this works,
this table here

00:12:17.950 --> 00:12:20.670
I'm showing in the right-hand
column the name of the instance

00:12:20.670 --> 00:12:22.900
variable for a property called name.

00:12:22.900 --> 00:12:26.850
It will always be _name if you
provide no accessor methods,

00:12:26.950 --> 00:12:28.890
if you provide just one
of the accessor methods.

00:12:28.900 --> 00:12:32.750
But if you write your property
in a sort of old-school way,

00:12:32.810 --> 00:12:36.900
then it's your job to also
provide the instance variable.

00:12:36.900 --> 00:12:40.120
So the rule is,
if you let us synthesize any accessor,

00:12:40.190 --> 00:12:42.890
you're going to get an instance variable.

00:12:42.900 --> 00:12:46.900
The same holds for read-only
properties as well.

00:12:46.900 --> 00:12:50.880
If you let us synthesize the getter,
you're going to get an instance variable.

00:12:50.960 --> 00:12:52.900
Otherwise, you won't.

00:12:52.900 --> 00:12:57.320
So what about backwards compatibility?

00:12:58.730 --> 00:13:02.600
If you just use explicit synthesis,
@synthesize name,

00:13:02.600 --> 00:13:06.270
then it's as if you had written
@synthesize name equals name.

00:13:06.360 --> 00:13:07.560
We've got a lot of code out there.

00:13:07.560 --> 00:13:09.470
We've got to keep working.

00:13:10.180 --> 00:13:13.670
So if you write this description
method in this scenario,

00:13:13.670 --> 00:13:15.860
then you're gonna be accessing
the instance variable using--

00:13:15.920 --> 00:13:17.770
without an underscore.

00:13:20.870 --> 00:13:25.920
So Core Data is this powerful
technology that provides an

00:13:25.920 --> 00:13:32.190
alternative way of managing your data,
keeping it persistent,

00:13:33.300 --> 00:13:36.030
And letting you define your
objects using data models.

00:13:36.290 --> 00:13:39.560
And a typical use of it,
you will declare a class that

00:13:39.840 --> 00:13:43.680
represents the same class as --
it's a subclass of NSManagedObject,

00:13:44.020 --> 00:13:46.640
and all the attributes and
relationships in the data model

00:13:46.640 --> 00:13:48.340
will be modeled as properties.

00:13:48.490 --> 00:13:51.220
So this gives you typed
access if you choose.

00:13:51.350 --> 00:13:55.750
You could always use value for key
and set value for key if you like,

00:13:55.750 --> 00:13:56.340
too.

00:13:56.500 --> 00:13:59.170
But this is what we see in most code.

00:14:00.680 --> 00:14:03.440
Then when you write the
implementation of these classes,

00:14:03.460 --> 00:14:07.600
the done thing has been
historically to use @dynamic.

00:14:07.600 --> 00:14:11.090
@dynamic tells the compiler, hey,
somebody else is providing

00:14:11.160 --> 00:14:14.870
the implementation,
so we'll just keep doing that.

00:14:15.390 --> 00:14:18.430
Specifically, Core Data,
NSManaged object,

00:14:18.680 --> 00:14:21.040
opts out of Synthesize by default.

00:14:21.040 --> 00:14:24.300
It does this by an attribute
that's in the header file.

00:14:24.300 --> 00:14:27.340
So it wouldn't make sense for
the compiler to automatically

00:14:27.340 --> 00:14:29.240
generate these implementations.

00:14:29.510 --> 00:14:33.800
They would shadow or get in the
way with what Core Data provides.

00:14:33.800 --> 00:14:38.800
So just continue to use @property
the way you have and use @dynamic.

00:14:39.030 --> 00:14:41.790
Things will just continue to work.

00:14:43.310 --> 00:14:44.830
Now,
if you're transitioning-- when you're

00:14:44.830 --> 00:14:50.420
transitioning to @synthesize by default,
consider this warning that we provide,

00:14:50.430 --> 00:14:52.180
implicit synthesize properties.

00:14:52.380 --> 00:14:54.560
This will just tell you-- you
can keep an eye on what the

00:14:54.560 --> 00:14:59.020
compiler is doing every time it
synthesizes a property by default.

00:14:59.200 --> 00:15:02.620
This could be good if you have
a policy in your code where you

00:15:02.630 --> 00:15:06.200
want to use explicit @synthesis,
somebody adds a new property declaration,

00:15:06.200 --> 00:15:11.200
and you want to make sure you add
the explicit @synthesize statement.

00:15:11.200 --> 00:15:13.020
So we have this warning.

00:15:15.120 --> 00:15:20.250
So in summary,
synthesize by default will synthesize any

00:15:20.250 --> 00:15:23.970
accessor method that you don't provide,
and an instance variable will

00:15:23.970 --> 00:15:26.530
be generated unless you provide
all the accessors yourself.

00:15:29.130 --> 00:15:31.760
AdSynthesize will always
generate an instance variable

00:15:32.270 --> 00:15:36.900
if you use it explicitly,
and a variable hasn't been declared.

00:15:37.150 --> 00:15:39.790
At dynamic now has more teeth.

00:15:39.850 --> 00:15:45.740
It actually will inhibit synthesize by
default on a property-by-property basis,

00:15:45.740 --> 00:15:47.730
if that's what you need.

00:15:47.840 --> 00:15:50.940
And then core managed object,
and its managed objects opt out.

00:15:50.940 --> 00:15:54.890
So that's synthesize by default.

00:16:02.400 --> 00:16:07.400
Now for the feature you've
all been waiting for.

00:16:07.460 --> 00:16:11.280
So NSNumbers are ubiquitous.

00:16:11.450 --> 00:16:15.400
They're used by lots of our frameworks.

00:16:15.400 --> 00:16:17.400
They're used for configuration data.

00:16:17.400 --> 00:16:19.400
They're used for metadata,
talking about the file

00:16:19.400 --> 00:16:21.110
system when you use NSURL.

00:16:21.480 --> 00:16:23.360
They're used for core image filters.

00:16:23.450 --> 00:16:26.270
They're everywhere.

00:16:26.640 --> 00:16:31.390
And they're simple,
but they require a lot of typing.

00:16:33.800 --> 00:16:35.270
So here I have some examples.

00:16:35.350 --> 00:16:39.680
We've got some literal data, a character,
an integer, long integer,

00:16:39.680 --> 00:16:44.890
floats and doubles and booleans, my, my,
oh, my.

00:16:46.790 --> 00:16:51.790
We're making this a lot simpler,
less typing, more straightforward.

00:16:51.910 --> 00:16:53.800
Here's what it looks like.

00:16:54.970 --> 00:16:58.980
In the same way that you prefix
a string constant with an @,

00:16:59.060 --> 00:17:01.260
you can prefix a character
literal with an @,

00:17:01.400 --> 00:17:04.300
and you'll get an NSNumber out of it.

00:17:04.420 --> 00:17:14.180
Same is true for integers,
floating points, doubles, booleans.

00:17:14.210 --> 00:17:16.100
Really simple.

00:17:16.220 --> 00:17:18.320
It's going to save you a lot of time.

00:17:21.800 --> 00:17:26.500
But wait, there's more.

00:17:26.600 --> 00:17:30.600
So we realized we made one part
of creating NSNumbers really easy,

00:17:30.600 --> 00:17:34.870
but there are still all the
cases where you compute your

00:17:34.970 --> 00:17:37.540
NSNumber values with expressions.

00:17:40.320 --> 00:17:43.940
And I find when I look at these,
the expressions,

00:17:43.940 --> 00:17:49.740
which are the important part,
often get lost in all the text

00:17:49.740 --> 00:17:52.260
that exists that you have to write.

00:17:54.770 --> 00:18:00.540
So now we have defined that a
parenthesized expression prefix

00:18:00.540 --> 00:18:02.920
with an @ gives you an NSNumber.

00:18:02.920 --> 00:18:05.810
Or not necessarily an NSNumber,
but depending on the

00:18:05.810 --> 00:18:09.800
type of the expression,
you'll get different values.

00:18:11.780 --> 00:18:14.800
So here we're indexing a string,
figuring out the hexadecimal

00:18:14.800 --> 00:18:17.800
digit of a number.

00:18:18.260 --> 00:18:22.640
Here we're wrapping a Boolean that
we've just read from a framework.

00:18:23.220 --> 00:18:28.590
Here we're putting a writing
direction enum constant into an

00:18:28.700 --> 00:18:32.270
NSNumber because we're writing,
let's say, an NS-attributed string that

00:18:32.270 --> 00:18:34.610
needs to be bidirectional.

00:18:35.810 --> 00:18:39.920
So what I observe when you use these
expressions is just your eye focuses

00:18:39.940 --> 00:18:43.440
in on what you're trying to do,
and you don't really

00:18:43.440 --> 00:18:45.490
get lost in the noise.

00:18:45.810 --> 00:18:50.040
So a little bit more about strings.

00:18:50.120 --> 00:18:54.930
Well, in the same way that we added
ats in front of literals,

00:18:55.010 --> 00:18:59.300
we decided it would be a great idea if we
could put an at in front of a character

00:18:59.300 --> 00:19:02.300
string and get an anna string out of it.

00:19:02.530 --> 00:19:04.580
So that's what we've done.

00:19:04.580 --> 00:19:08.540
One clap.

00:19:12.400 --> 00:19:14.520
So you read a variable
from the environment,

00:19:14.530 --> 00:19:16.460
and you want to parse it,
because it's a lot easier

00:19:16.460 --> 00:19:19.300
to use Foundation to parse
out the elements of a path,

00:19:19.500 --> 00:19:20.490
colon delimited.

00:19:20.630 --> 00:19:26.150
So the rules are,
it has to be a null-terminated C string,

00:19:26.150 --> 00:19:30.490
and in no other encodings
other than ASCII or UTF-8.

00:19:30.570 --> 00:19:32.500
And it can't be null.

00:19:32.500 --> 00:19:40.390
So that's numbers.

00:19:45.640 --> 00:19:52.220
A next very ubiquitous data type
would be foundation containers,

00:19:52.220 --> 00:19:55.100
NSRAs, dictionaries, as well.

00:19:55.100 --> 00:19:58.240
These are used everywhere
to represent property lists,

00:19:58.240 --> 00:20:01.590
and, you know, you use them.

00:20:04.570 --> 00:20:10.460
So we wanted to simplify the
number of choices that you

00:20:10.460 --> 00:20:12.700
have when creating these.

00:20:12.840 --> 00:20:14.370
So there are a lot of choices.

00:20:14.680 --> 00:20:16.400
There are a number of
methods you can use.

00:20:16.490 --> 00:20:19.120
We have some special case
forms in the NSArray class

00:20:19.350 --> 00:20:23.900
for creating an empty array,
for creating a single element array.

00:20:23.900 --> 00:20:27.280
And then we have our
variable arguments form,

00:20:27.280 --> 00:20:30.900
which is probably the
most common method used.

00:20:30.900 --> 00:20:34.980
It has one little bugaboo about it,
at least my personal bugaboo,

00:20:35.030 --> 00:20:38.040
is that you have to
nil-terminate the argument list.

00:20:38.040 --> 00:20:41.390
I've always thought, "Gosh,
the compiler can tell me

00:20:41.390 --> 00:20:43.190
I need to nil-terminate it.

00:20:43.190 --> 00:20:45.030
Why can't it do it for me?"

00:20:46.330 --> 00:20:49.360
And then we have this other form
where you pack up the elements

00:20:49.460 --> 00:20:53.250
of an array as a C array,
and you tell it very explicitly

00:20:53.330 --> 00:20:57.110
how big that array is,
how many elements should be in it.

00:20:57.410 --> 00:21:01.000
Well, there's an inconsistency
between these two forms.

00:21:01.100 --> 00:21:06.800
When you use the nil-terminated form,
if any of the arguments you pass are nil,

00:21:06.940 --> 00:21:08.420
you're going to get a shorter array.

00:21:08.420 --> 00:21:13.490
I know, you're saying, that's not a bug,
that's a feature, but...

00:21:14.440 --> 00:21:16.380
Not when you're trying to
debug your code and you wonder

00:21:16.380 --> 00:21:19.300
why things are not working.

00:21:19.450 --> 00:21:23.170
However, with the C array form,
if you put nil as any

00:21:23.170 --> 00:21:26.300
one of the arguments,
you're going to get an exception.

00:21:26.300 --> 00:21:30.300
And we think that's the
better default behavior.

00:21:30.300 --> 00:21:34.220
So you know if you get
one of these arrays back,

00:21:34.220 --> 00:21:37.300
it's what you expect.

00:21:37.300 --> 00:21:40.150
So now we've got a new syntax not to...

00:21:41.060 --> 00:21:44.100
Prolong it any further, the suspense.

00:21:44.160 --> 00:21:48.680
@ gives you an empty array,
a single element array,

00:21:48.720 --> 00:21:52.640
multiple element array,
and then this last form, well,

00:21:52.640 --> 00:21:54.240
their equivalent.

00:22:00.600 --> 00:22:03.940
So now you have time to do other things,
less typing.

00:22:04.000 --> 00:22:05.360
How does it work?

00:22:05.400 --> 00:22:10.570
Well, when you write this,
the compiler does this.

00:22:10.690 --> 00:22:12.680
So any time you use one
of these expressions,

00:22:12.680 --> 00:22:15.680
these array literal expressions,
you're going to get the form.

00:22:15.680 --> 00:22:19.630
It would throw an exception if
any of the values are incorrect.

00:22:21.470 --> 00:22:24.000
Okay, dictionaries.

00:22:24.000 --> 00:22:27.800
With dictionaries,
we have more of the same.

00:22:27.800 --> 00:22:31.090
We have more choices,
and we have even more

00:22:31.240 --> 00:22:33.100
ways to make a mistake.

00:22:33.210 --> 00:22:37.170
So here we have the
empty form of dictionary,

00:22:37.640 --> 00:22:41.310
single element,
and now we've got dictionary

00:22:41.310 --> 00:22:43.600
with objects and keys.

00:22:45.280 --> 00:22:47.920
Couple things about this.

00:22:47.940 --> 00:22:51.600
Alternating arguments, values and keys.

00:22:51.660 --> 00:22:54.470
Values first, keys second.

00:22:55.710 --> 00:22:57.270
Who's made a mistake with this?

00:22:57.270 --> 00:23:02.440
So I know I have,
and I know I end up writing

00:23:02.440 --> 00:23:06.660
the value key one per line,
comma, comma, comma.

00:23:06.660 --> 00:23:11.920
Well, with this particular case,
if the value is nil, you'll get a shorter

00:23:11.920 --> 00:23:14.360
dictionary than you expected.

00:23:14.360 --> 00:23:17.590
And if the key is nil, well,
it's going to say, hey,

00:23:17.590 --> 00:23:21.060
you terminated the list with
an odd number of arguments.

00:23:21.190 --> 00:23:22.040
That was a bad idea.

00:23:22.040 --> 00:23:26.120
So you'll get an exception
sometimes and not other times.

00:23:26.640 --> 00:23:30.490
And again, with a fully formed way,
it's a little easier to manage

00:23:30.540 --> 00:23:33.640
because you can see all the values
in parallel with all the keys.

00:23:33.660 --> 00:23:36.760
And this one will always throw
an exception in either case.

00:23:38.310 --> 00:23:41.130
So you can guess which one we chose.

00:23:41.220 --> 00:23:42.120
So here's what it looks like.

00:23:42.230 --> 00:23:44.960
Dictionaries, empty dictionaries.

00:23:44.960 --> 00:23:47.230
There's the no special form.

00:23:47.230 --> 00:23:48.950
Just use the syntax.

00:23:49.070 --> 00:23:51.760
Keys and values separated by colon.

00:23:51.760 --> 00:23:53.650
You can't get it wrong.

00:23:53.650 --> 00:23:55.200
You can't forget.

00:23:55.560 --> 00:23:59.020
Multiple comma delimited key colon value.

00:23:59.020 --> 00:24:04.560
Again, I think it speaks for itself.

00:24:07.110 --> 00:24:11.600
And this last form again
is the form we chose.

00:24:11.630 --> 00:24:16.590
So when you write this,
this is what we do for you.

00:24:21.980 --> 00:24:25.390
So these literals come with
a couple strings attached.

00:24:25.400 --> 00:24:28.470
Ba-dum-bum.

00:24:29.080 --> 00:24:33.040
If you have an immutable array-- sorry,
all containers that are created

00:24:33.040 --> 00:24:35.640
from literals are immutable.

00:24:35.710 --> 00:24:39.140
So if you need a mutable form,
just--you can use the literal

00:24:39.470 --> 00:24:42.250
and call the mutable copy method.

00:24:44.050 --> 00:24:48.000
Oftentimes, we're just creating mutable
containers that are empty anyway,

00:24:48.000 --> 00:24:51.100
so this may not be that common.

00:24:53.670 --> 00:24:55.060
So what about constant containers?

00:24:55.100 --> 00:24:56.500
We can have constant strings.

00:24:56.680 --> 00:24:57.900
What about constant containers?

00:24:57.900 --> 00:25:00.660
Well,
I've shown you how this is implemented.

00:25:00.840 --> 00:25:03.840
So the compiler is not
going to let you write this.

00:25:03.920 --> 00:25:08.570
It's going to tell you array
literals are not constant values.

00:25:09.200 --> 00:25:10.480
So the workaround is simple.

00:25:10.480 --> 00:25:15.670
Just use a plus initialize method in your
class for data that you need to access.

00:25:15.810 --> 00:25:18.740
And it's going to get called
before any instance of your

00:25:18.740 --> 00:25:22.610
class is ever initialized,
or any method is ever called.

00:25:22.710 --> 00:25:23.630
And it's thread safe.

00:25:23.780 --> 00:25:26.560
You just have to guard that
you're not allocating it more

00:25:26.560 --> 00:25:29.510
than once by the simple test.

00:25:31.450 --> 00:25:35.830
And if you're not using Arc-- and you
should be-- if you're not using Arc,

00:25:35.920 --> 00:25:40.160
you'll have to retain this value,
because they're always auto-released.

00:25:45.200 --> 00:25:48.430
Now, dictionaries pose a
couple of other problems.

00:25:48.460 --> 00:25:53.190
One, to have dictionary values,
you'd have to have some static

00:25:53.190 --> 00:25:58.510
data structure where the values
will be pre-hashed or pre-sorted.

00:25:59.500 --> 00:26:02.740
There's actually a more
fundamental problem.

00:26:02.750 --> 00:26:05.250
You can't even write this.

00:26:05.530 --> 00:26:09.400
The framework keys that we provide
are almost always global variables

00:26:09.400 --> 00:26:12.900
rather than string literals.

00:26:12.990 --> 00:26:16.400
So they're not compile-time
constants themselves.

00:26:16.450 --> 00:26:19.540
So you're not going to be able to
do that anyway most of the time.

00:26:19.720 --> 00:26:20.640
So the same is true.

00:26:20.640 --> 00:26:24.470
If you need to initialize one of these,
just use a +initialize.

00:26:29.220 --> 00:26:31.100
Okay, that's literals.

00:26:31.100 --> 00:26:35.290
Literals make it easier
to create new objects,

00:26:35.360 --> 00:26:37.400
new containers, new numbers.

00:26:37.400 --> 00:26:41.510
I want to talk about subscripting now,
which makes it easier to use them.

00:26:43.500 --> 00:26:48.720
So here I have a piece of code,
some kind of a song list that represents,

00:26:48.720 --> 00:26:50.600
you know,
maybe keeping track of top 10 lists

00:26:50.700 --> 00:26:52.500
or something of your favorite songs.

00:26:52.540 --> 00:26:54.740
And then we have a replace song method.

00:26:54.990 --> 00:26:59.050
And it's keeping this list
of songs in a mutable array.

00:26:59.160 --> 00:27:03.410
So we write a replace song
method like this today.

00:27:03.580 --> 00:27:06.050
Now you can write it like this.

00:27:13.280 --> 00:27:18.380
So the same is true for dictionaries.

00:27:18.380 --> 00:27:20.680
We have two kinds.

00:27:22.280 --> 00:27:24.080
If you want to access the
element of a dictionary,

00:27:24.080 --> 00:27:27.560
read or write it,
you can just use subscript notation.

00:27:27.560 --> 00:27:34.990
So let's talk about what
happens when you use the syntax.

00:27:35.510 --> 00:27:39.200
So we define two kinds of subscripting,
index subscripting and

00:27:39.360 --> 00:27:41.080
keyed subscripting.

00:27:41.130 --> 00:27:43.580
Index is when you use an
integer as the subscript,

00:27:43.630 --> 00:27:46.790
and keyed subscripting is
when you use an object.

00:27:48.470 --> 00:27:50.980
So when you write one
of these expressions,

00:27:51.010 --> 00:27:55.690
the compiler calls a method,
as you might expect.

00:27:56.100 --> 00:27:59.160
calls object index subscript
for index subscripting.

00:27:59.190 --> 00:28:02.100
And when you update an
element of an array,

00:28:02.100 --> 00:28:05.720
it calls set object
at index subscripting.

00:28:06.090 --> 00:28:09.840
So we chose these new method names
so that you can have a way to have

00:28:10.740 --> 00:28:14.210
new code opt in to using the syntax.

00:28:14.380 --> 00:28:16.010
So it's optional.

00:28:16.040 --> 00:28:18.030
You don't have to use it.

00:28:19.930 --> 00:28:21.890
Dictionaries work similarly.

00:28:22.110 --> 00:28:27.090
When you read an element,
it's object for keyed subscript

00:28:27.090 --> 00:28:30.520
and set object for keyed subscript.

00:28:32.270 --> 00:28:35.020
So here's how it works.

00:28:35.050 --> 00:28:39.340
The compiler looks for the existence,
the declaration of these methods.

00:28:39.370 --> 00:28:42.750
And if they are present in a class,

00:28:43.200 --> 00:28:45.500
- It enables the syntax.

00:28:45.610 --> 00:28:49.150
The element type can be
any object type you choose.

00:28:49.450 --> 00:28:51.610
Doesn't have to be ID.

00:29:04.460 --> 00:29:04.460
And the index type must
be some integral type.

00:29:04.460 --> 00:29:04.460
And also the key type
must be an object type.

00:29:04.460 --> 00:29:04.460
It's a very loose contract
with the compiler.

00:29:04.460 --> 00:29:04.460
We consider this a sort
of informal protocol.

00:29:06.460 --> 00:29:08.830
Your classes can use this.

00:29:08.930 --> 00:29:12.890
So you can make your code,
your groovy song list,

00:29:12.900 --> 00:29:16.700
respond to subscripting notation.

00:29:25.220 --> 00:29:28.660
So all these features are available
in the tools that you have here today,

00:29:28.660 --> 00:29:33.030
Xcode 4.4 and 4.5,
synthesized by default,

00:29:33.140 --> 00:29:35.930
the method declarations
in any order you like,

00:29:35.990 --> 00:29:42.760
the fixed underlying types, the literals,
the subscripting, and the expressions.

00:29:42.800 --> 00:29:46.030
The great thing about all
these features is they all work

00:29:46.270 --> 00:29:50.120
not only with the latest OS,
but they work on older OSes, too.

00:29:50.370 --> 00:29:52.610
It's all binary compatible.

00:30:00.920 --> 00:30:04.140
No barrier of adoption.

00:30:04.270 --> 00:30:09.370
All right, I'd like to show you a demo
now of our refactoring tool.

00:30:10.900 --> 00:30:14.470
So here we have an iOS
application called WikiHow,

00:30:14.470 --> 00:30:18.790
and if you were here last year,
you will remember this example.

00:30:21.090 --> 00:30:27.540
So we have in our Edit menu
the refactor command,

00:30:27.600 --> 00:30:30.010
convert to modern Objective-C syntax.

00:30:30.040 --> 00:30:39.550
So we could do this target
by target if we want.

00:30:44.700 --> 00:30:48.570
And as you can see,
it finds all the instances

00:30:48.650 --> 00:30:53.340
of the existing code patterns
that you're familiar with and

00:30:53.340 --> 00:30:55.610
substitutes in the new syntax.

00:30:55.790 --> 00:30:57.520
Really straightforward.

00:31:05.210 --> 00:31:10.670
Here's a case where it's converting
a C string that used to be wrapped in

00:31:10.800 --> 00:31:15.020
an N-string and using the new syntax.

00:31:15.130 --> 00:31:17.050
Lots of those in this code.

00:31:17.160 --> 00:31:19.170
Empty array.

00:31:20.290 --> 00:31:22.760
Here's a case where
we're using an object,

00:31:22.860 --> 00:31:27.490
turning an object index into a subscript.

00:31:37.830 --> 00:31:43.040
So real simple, shortens your code.

00:31:47.660 --> 00:31:49.600
Ah, that was one I was looking for.

00:31:49.750 --> 00:31:55.600
So here's a case where it's actually
doing a nested subscripting expression.

00:31:55.600 --> 00:31:58.400
It's a pretty sophisticated
conversion tool.

00:31:58.600 --> 00:32:05.390
So that's what you have available
to you if you choose to use it.

00:32:08.700 --> 00:32:16.200
[Transcript missing]

00:32:19.600 --> 00:32:23.710
There's good old wikiHow,
and let's look up ukulele.

00:32:29.400 --> 00:32:30.400
And it works.

00:32:30.400 --> 00:32:31.400
Okay.

00:32:31.400 --> 00:32:32.400
Thank you.

00:32:32.400 --> 00:32:33.400
Thank you.

00:32:33.530 --> 00:32:34.400
Thank you.

00:32:39.260 --> 00:32:45.470
So now I'd like to shift gears and talk
a little bit about using C++ with Arc.

00:32:46.520 --> 00:32:52.810
So if you've been using Arc for any time,
you'll be aware of this issue.

00:32:52.880 --> 00:32:58.460
You can't use C structs directly
to hold object pointers under Arc.

00:32:58.560 --> 00:33:01.630
If you try,
you'll get this compile error.

00:33:06.100 --> 00:33:09.860
So why do we prohibit this?

00:33:10.100 --> 00:33:14.210
One reason is that C structs
can be uninitialized.

00:33:14.230 --> 00:33:16.640
You use them on the stack.

00:33:16.740 --> 00:33:19.930
So they can have garbage values
in them that are not going

00:33:19.950 --> 00:33:22.680
to be tolerated well by Arc.

00:33:22.680 --> 00:33:26.670
If you were to release a garbage value,
odds are you'll crash.

00:33:28.280 --> 00:33:30.650
They can also just be copied willy-nilly.

00:33:30.720 --> 00:33:32.580
You can pass them as arguments.

00:33:32.720 --> 00:33:33.930
You can use mem copy.

00:33:34.280 --> 00:33:39.680
And then Arc skips out on the ability
to do any kind of ownership transfer.

00:33:41.120 --> 00:33:43.540
Of course, nothing happens to these
when they go out of scope,

00:33:43.610 --> 00:33:48.770
so memory is going to leak if you
store retained pointers in them.

00:33:50.180 --> 00:33:52.930
So to fix your code so that
it works better under Arc,

00:33:53.120 --> 00:33:57.940
you can use-- convert all your
structs to classes if you want.

00:33:57.940 --> 00:34:02.960
You can go whole hog and use
properties and synthesize by default.

00:34:05.510 --> 00:34:09.580
Another possible solution
is to use Objective-C++.

00:34:09.580 --> 00:34:12.560
If you have some structs
that you cannot convert,

00:34:12.570 --> 00:34:17.240
that's actually one of the benefits of
Objective-C++ is it gives us a real good

00:34:17.240 --> 00:34:20.000
way of using a lot of existing code.

00:34:20.000 --> 00:34:22.710
It's a good porting tool.

00:34:24.480 --> 00:34:27.560
So how does it work?

00:34:27.590 --> 00:34:32.520
Well, under Arc, if you have object
pointers in your C structs,

00:34:32.520 --> 00:34:36.060
or your C++ structs,
they're no longer considered

00:34:36.550 --> 00:34:40.080
pods or plain old data types.

00:34:40.120 --> 00:34:45.140
The compiler implicitly generates
a bunch of code for you.

00:34:45.220 --> 00:34:46.990
So let's look at that.

00:34:47.990 --> 00:34:51.740
The constructor will be generated
at a minimum to automatically

00:34:51.740 --> 00:34:56.530
initialize the variables,
the object pointer variables,

00:34:56.630 --> 00:34:59.800
and the destructor will
automatically release.

00:35:02.620 --> 00:35:06.360
It'll also generate copy constructors
and a default operator assign

00:35:06.360 --> 00:35:11.710
operator equals that do the right
retain-release dance for you.

00:35:13.970 --> 00:35:18.390
And now we have C++11,
which gives you move semantics.

00:35:18.480 --> 00:35:21.690
And so we'll automatically
generate proper move

00:35:22.100 --> 00:35:25.150
constructors and move operators.

00:35:25.240 --> 00:35:28.810
So this makes your code more efficient.

00:35:29.150 --> 00:35:32.440
Especially if instances of
these objects are inside,

00:35:32.440 --> 00:35:35.560
you know, STL vectors or something.

00:35:36.840 --> 00:35:39.700
So not to worry,
this looks like a lot of detail,

00:35:39.700 --> 00:35:41.340
but the compiler does it for you.

00:35:41.340 --> 00:35:43.410
You don't have to worry about it.

00:35:46.820 --> 00:35:50.540
This also works very
generally with STL classes,

00:35:50.540 --> 00:35:53.290
as you might expect.

00:35:53.560 --> 00:35:57.200
You could have a class where you want
to visit all the subviews of a window,

00:35:57.200 --> 00:35:58.380
for example.

00:35:58.460 --> 00:36:01.620
And to do a proper
depth-first search algorithm,

00:36:01.620 --> 00:36:05.460
you could use a vector to
keep track of where you are.

00:36:06.580 --> 00:36:12.700
So when you add an element of an object
pointer type to a template class,

00:36:12.760 --> 00:36:14.520
you're going to get the right behavior.

00:36:14.670 --> 00:36:19.610
It's going to take a strong
reference in this case.

00:36:34.230 --> 00:36:34.230
So I had another example
where you have weak pointers.

00:36:34.230 --> 00:36:34.230
Weak pointers are supported
as well in STL vectors.

00:36:34.250 --> 00:36:39.430
The compiler will support them,
and if objects are removed behind

00:36:39.660 --> 00:36:43.090
your back out of a weak vector,
a weak container,

00:36:43.130 --> 00:36:47.700
say you have a weak vector for
managing observers and you don't

00:36:47.700 --> 00:36:50.190
want to have any retain cycles.

00:36:50.420 --> 00:36:53.440
You would probably have
to write to clean up,

00:36:53.440 --> 00:36:56.680
to make your vector smaller,
periodically some kind of

00:36:56.760 --> 00:36:57.960
a compacting operation.

00:36:57.960 --> 00:37:02.260
So here we're using a new
feature in C++11 called lambdas.

00:37:02.400 --> 00:37:05.880
So C++11 lambdas just
give you a simple way.

00:37:06.000 --> 00:37:08.500
They're very analogous to blocks.

00:37:08.640 --> 00:37:13.220
And in fact, if you want,
you can just use blocks directly

00:37:13.520 --> 00:37:15.540
in place of C++ lambdas.

00:37:16.680 --> 00:37:19.370
The compiler will automatically
construct a lambda that just

00:37:19.390 --> 00:37:20.600
wraps the block for you.

00:37:20.600 --> 00:37:24.920
So you can just stick with the
notation you're comfortable with.

00:37:37.970 --> 00:37:40.340
So Arc is a great technology.

00:37:40.470 --> 00:37:44.610
It automates memory
management with CocoaObjects.

00:37:45.200 --> 00:37:47.800
But it doesn't give us any support,
really, for core foundation.

00:37:47.830 --> 00:37:54.780
Core foundation is something that
sometimes we all have to dabble with.

00:37:57.720 --> 00:38:02.210
So the stickiest issue is if you are
using some kind of core foundation API,

00:38:02.210 --> 00:38:07.310
like the address book,
and you're wanting to convert

00:38:07.460 --> 00:38:12.960
values that you get from those
APIs back into Objective-C objects.

00:38:12.960 --> 00:38:15.070
So like, for example,
here we're doing some kind of

00:38:15.190 --> 00:38:18.910
a query on the address book,
and we want to make an NSArray out of it.

00:38:19.430 --> 00:38:22.700
Well, like we introduced last year,
we provide this CAS notation

00:38:22.700 --> 00:38:25.120
called Bridge Transfer.

00:38:25.540 --> 00:38:27.080
And this does what you would expect.

00:38:27.160 --> 00:38:31.200
It's transferring ownership
from using explicit CFRetain,

00:38:31.280 --> 00:38:36.570
CFRelease into
NSArray semantics using Arc.

00:38:51.000 --> 00:38:51.000
And as we recommend,
rather than using that bridge syntax,

00:38:51.000 --> 00:38:51.000
that you just go ahead and
use CF Bridging Release,

00:38:51.000 --> 00:38:51.000
which does the same thing.

00:38:51.000 --> 00:38:51.000
So this is when you have the
need to transfer ownership.

00:38:55.000 --> 00:38:57.560
However, we've improved some things.

00:38:57.580 --> 00:39:01.710
Last year, we also talked about if
you're going to just pass

00:39:02.870 --> 00:39:05.820
So, for Cocoa objects,
two core Foundation APIs,

00:39:05.820 --> 00:39:08.980
you had to write this other cast form,
the BridgeCast,

00:39:08.980 --> 00:39:12.890
which just basically said,
"There's nothing fancy going on here.

00:39:12.950 --> 00:39:16.860
We're just using one of our objects
as one of these other types." So,

00:39:16.860 --> 00:39:19.270
this is what you needed
to do the bridging,

00:39:19.270 --> 00:39:21.980
toll-free bridging, the minimum.

00:39:22.670 --> 00:39:24.550
Well, now we've added a new capability.

00:39:24.690 --> 00:39:28.480
We've added annotations to the
header files for core Foundation.

00:39:28.490 --> 00:39:33.740
We'll be adding more to all the
sort of core Foundation-style APIs.

00:39:34.290 --> 00:39:38.690
What this annotation means,
these have been validated

00:39:38.690 --> 00:39:40.360
to be consistent.

00:39:40.430 --> 00:39:46.030
They've been annotated to have whatever
lifetime semantics are necessary.

00:39:46.500 --> 00:39:50.640
Therefore, you can just use them,
no bridge cast required.

00:39:50.730 --> 00:39:52.790
So this is what it looks like.

00:39:58.650 --> 00:40:00.760
So that should make your
code a little bit easier.

00:40:00.760 --> 00:40:09.150
So now let's talk about
garbage collection.

00:40:09.750 --> 00:40:15.200
So Garbage Collection is a feature
that has been superseded by Arc,

00:40:15.330 --> 00:40:21.440
which provides a very similar experience
for managing memory automatically.

00:40:21.540 --> 00:40:26.860
And the benefit of Arc is that
it's available on both platforms,

00:40:26.860 --> 00:40:28.220
OS X, iOS.

00:40:29.320 --> 00:40:33.120
Our frameworks, historically,
have been written in a way that

00:40:33.290 --> 00:40:35.700
is optimized for retain-release.

00:40:35.870 --> 00:40:42.900
So things happen in a predictable,
deterministic order, and Arc really fits

00:40:43.050 --> 00:40:45.450
those frameworks well.

00:40:46.220 --> 00:40:49.260
On our mobile devices,
performance is critical.

00:40:49.390 --> 00:40:51.040
Responsiveness is critical.

00:40:51.220 --> 00:40:54.160
So when you're scrolling your iPad,

00:40:54.870 --> 00:41:02.400
You want to use as few resources
as possible and let the app shine.

00:41:02.600 --> 00:41:06.380
So we know that Arc enables this.

00:41:07.340 --> 00:41:10.240
Also, battery life is really critical.

00:41:10.360 --> 00:41:13.960
So Arc gives you a way of
measuring the performance of

00:41:14.110 --> 00:41:19.190
your app and making sure that it
remains predictable and efficient.

00:41:19.320 --> 00:41:23.610
So garbage collection is
deprecated in Mountain Lion.

00:41:24.850 --> 00:41:29.090
And you can use our Migrator tool,
the refactoring tool that

00:41:29.090 --> 00:41:32.090
we showed you earlier,
to migrate your code from

00:41:32.090 --> 00:41:34.550
Garbage Collection to Arc.

00:41:34.630 --> 00:41:38.430
And a lot of times, it goes real simply.

00:41:43.600 --> 00:41:49.300
[Transcript missing]

00:41:50.060 --> 00:41:52.890
So for more information
about these issues,

00:41:52.890 --> 00:41:57.160
and make contact with us,
please contact Michael Jurowicz.

00:41:57.160 --> 00:41:59.730
And if you want to read more
about the language extensions

00:41:59.730 --> 00:42:03.050
that I talked about today,
then there's a website,

00:42:03.050 --> 00:42:07.880
the LLVM website has information
about the language extensions.

00:42:07.970 --> 00:42:12.390
And there's always the
Apple Developer Forums to ask questions.

00:42:12.940 --> 00:42:15.600
Also, if you want more information,
we have two labs,

00:42:15.600 --> 00:42:20.790
one starting at 2 today and
another one starting at...

00:42:23.010 --> 00:42:24.460
Sorry, we have related sessions.

00:42:24.470 --> 00:42:28.000
The very next session coming up
is adopting reference counting,

00:42:28.000 --> 00:42:29.500
more information on that.

00:42:29.500 --> 00:42:33.000
And then tomorrow we have a talk
about migrating to Objective-C.

00:42:33.000 --> 00:42:35.000
So thanks for coming.

00:42:35.000 --> 00:42:39.000
This is what we talked about today,
the new feature synthesized by default,

00:42:39.000 --> 00:42:42.000
the better -- lack of
forward declarations,

00:42:42.000 --> 00:42:48.960
fixed underlying type enums and literals,
subscripting, and GC is deprecated.

00:42:49.260 --> 00:42:51.000
So thanks a lot.

00:42:51.000 --> 00:42:53.270
Thanks for your time.
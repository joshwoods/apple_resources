WEBVTT

00:00:10.760 --> 00:00:11.700
Hello.

00:00:11.810 --> 00:00:14.860
Welcome to Layer-Backed Views:
AppKit + Core Animation.

00:00:14.960 --> 00:00:18.660
My name is Corbin Dunn,
and I'm an AppKit software engineer.

00:00:19.740 --> 00:00:23.700
So what are we going to talk about
today and what are our expectations?

00:00:23.780 --> 00:00:26.220
Well, we're going to assume you
have some experience with

00:00:26.290 --> 00:00:29.610
traditional AppKit drawing or
maybe have experience with UIKit.

00:00:29.700 --> 00:00:33.510
You don't necessarily have to have
experience with Core Animation,

00:00:33.510 --> 00:00:36.400
but if you do,
a lot of this will be great information

00:00:36.400 --> 00:00:38.700
and will fill in a lot of holes for you.

00:00:40.040 --> 00:00:42.940
So, effectively using layer-backed views.

00:00:43.010 --> 00:00:45.540
What does using a layer-backed view mean?

00:00:45.590 --> 00:00:47.600
It means using Core Animation.

00:00:47.600 --> 00:00:50.080
And you want to use Core Animation in
order to get smooth,

00:00:50.110 --> 00:00:51.710
fast animations.

00:00:51.820 --> 00:00:55.190
And the reason that they're smooth
and fast is the animations aren't

00:00:55.190 --> 00:00:58.070
going to be done by the CPU,
but they're going to offload a

00:00:58.070 --> 00:00:59.710
lot of the work into the GPU.

00:01:00.000 --> 00:01:02.750
By using a layer-backed view,
you can utilize all the great

00:01:02.750 --> 00:01:07.820
things that are already in NSViews,
like the hierarchy, events, hit testing,

00:01:08.090 --> 00:01:10.430
the responder chain, etc.

00:01:10.720 --> 00:01:13.500
Historically,
all of our layer-backed views have

00:01:13.570 --> 00:01:18.000
worked in AppKit and used traditional
DrawRack-based drawing for a long time,

00:01:18.000 --> 00:01:19.990
since Leopard and 10.5.

00:01:20.870 --> 00:01:23.740
Now let's jump right in and do
a little demo to show how this

00:01:23.740 --> 00:01:26.110
can improve your application.

00:01:29.800 --> 00:01:32.650
So what I have here is just a quick
little demo with the frame rate

00:01:32.650 --> 00:01:34.800
meter from Quartz Debug showing.

00:01:34.800 --> 00:01:37.460
I'm going to start an animation,
and this is not layer-backed.

00:01:37.460 --> 00:01:41.660
This is just your traditional,
regular Cocoa application.

00:01:41.660 --> 00:01:45.860
Start a few things, get going,
and the frame rate's kind of hovering

00:01:45.860 --> 00:01:48.070
at about 25 frames per second.

00:01:48.110 --> 00:01:51.460
And I can turn layers off,
and what this does is I just call a

00:01:51.460 --> 00:01:56.500
setOnce layer in the entire content view,
and now the frame rate is pegged at 60,

00:01:56.500 --> 00:01:57.900
which is what we cap it at.

00:01:57.900 --> 00:02:00.790
We could even do some more animations
like fading views in between,

00:02:00.850 --> 00:02:05.750
animate sorting, change the heights,
and it's still pegged right at 60.

00:02:08.750 --> 00:02:14.190
So that shows some of the benefits
of adopting layer-backed views.

00:02:14.270 --> 00:02:15.940
So what are we going to talk about today?

00:02:16.030 --> 00:02:17.590
We're going to first talk about drawing.

00:02:17.600 --> 00:02:20.580
We're going to cover traditional
AppKit drawing and how it works,

00:02:20.590 --> 00:02:23.720
how to turn on Core Animation and
get layer-backed views.

00:02:23.800 --> 00:02:26.850
Then we're going to discuss animating,
say how it works traditionally

00:02:26.850 --> 00:02:29.310
inside of AppKit and how it
works when you're layer-backed.

00:02:29.370 --> 00:02:31.320
We're going to talk about
contents updating and animating

00:02:31.320 --> 00:02:34.520
to get efficient animations,
and how to do synchronized sub-view

00:02:34.520 --> 00:02:37.800
animations so that everything
works together really well.

00:02:37.860 --> 00:02:39.940
We're going to discuss
some best practices,

00:02:39.990 --> 00:02:42.970
such as how to deal with text
and get fonts moving right.

00:02:43.020 --> 00:02:45.350
We're going to discuss focus
rings so that focus rings work

00:02:45.350 --> 00:02:46.930
right in a layer-backed view.

00:02:47.000 --> 00:02:48.620
And then finally,
I'm going to do some more details,

00:02:48.690 --> 00:02:50.930
tips and tricks at the end.

00:02:51.380 --> 00:02:54.990
Let's jump right in and
start talking about drawing.

00:02:55.060 --> 00:03:00.140
The traditional NSView drawing model,
it's going to use... Or what I'm

00:03:00.140 --> 00:03:02.900
going to talk about is first the
traditional NSView drawing model,

00:03:02.970 --> 00:03:04.750
then I'm going to jump
into Core Animation,

00:03:04.810 --> 00:03:06.800
how to actually turn
in layer-backed views,

00:03:06.840 --> 00:03:08.810
and how it works with AppKit.

00:03:08.980 --> 00:03:11.600
Then I'm going to discuss some
differences in set-needs-display,

00:03:11.640 --> 00:03:14.000
and how we actually do redrawing,
and how it's different when it's

00:03:14.000 --> 00:03:16.510
layer-backed and not layer-backed.

00:03:17.070 --> 00:03:19.150
So the traditional NSView drawing model.

00:03:19.210 --> 00:03:22.080
And to emphasize this is the traditional
Cocoa and not necessarily layer-backed,

00:03:22.180 --> 00:03:24.350
I have this Cocoa icon up in the corner.

00:03:24.430 --> 00:03:26.260
So let's say you have
this cool custom view.

00:03:26.260 --> 00:03:28.940
It's got a gray background,
a custom image drawn in there,

00:03:28.940 --> 00:03:31.650
and some custom text drawn on it.

00:03:32.140 --> 00:03:34.390
How would we draw this with
traditional AppKit drawing?

00:03:34.500 --> 00:03:37.240
Well, you're probably very familiar
with implementing DrawRect.

00:03:37.370 --> 00:03:41.100
You'll do a fill of like a light
gray color that you'll set,

00:03:41.240 --> 00:03:43.030
fill in the background.

00:03:43.150 --> 00:03:45.940
Then you're going to draw
a border on top of that.

00:03:46.050 --> 00:03:48.890
Then you'll probably use our string
drawing API to draw the text,

00:03:48.890 --> 00:03:51.030
like the word tandem unicycle.

00:03:51.160 --> 00:03:53.330
Then finally,
you'll draw the image on top of it.

00:03:53.500 --> 00:03:56.570
So you're just drawing one
thing on top of the other.

00:03:57.800 --> 00:03:59.670
Now,
what happens when the window actually

00:03:59.670 --> 00:04:02.490
needs to be displayed and drawn?

00:04:02.640 --> 00:04:04.370
Well, at draw time,
the window's going to start at the

00:04:04.370 --> 00:04:07.890
topmost level and find the dirty
region that needs to be redrawn and

00:04:07.890 --> 00:04:09.940
recursively redraw all children.

00:04:10.050 --> 00:04:11.970
So first,
the parent window and its content

00:04:11.970 --> 00:04:13.640
and frame area will redraw.

00:04:13.720 --> 00:04:15.370
It's going to enumerate
to all the subviews.

00:04:15.540 --> 00:04:18.720
Draw, say,
the blue one and then the red subview.

00:04:18.820 --> 00:04:20.510
And each time,
it's going to enumerate down to each

00:04:20.670 --> 00:04:22.760
child subview and draw it on top.

00:04:22.850 --> 00:04:26.750
So the custom view that we have there
would be drawn last in this case.

00:04:27.900 --> 00:04:32.600
Now what this is basically doing is it's
drawing into the window backing store.

00:04:32.660 --> 00:04:34.760
And what you can really think
about doing is drawing into

00:04:34.810 --> 00:04:38.090
one large image all at once.

00:04:39.200 --> 00:04:42.140
So let's take a quick look at a flow
chart about how this traditionally works.

00:04:42.290 --> 00:04:45.700
Your window has a dirty area
that needs to be redrawn.

00:04:45.740 --> 00:04:47.610
It's going to prepare the
window context for drawing,

00:04:47.650 --> 00:04:50.340
so it's going to set up that big
image you're going to draw into.

00:04:50.400 --> 00:04:53.660
Enumerate all the views that are in
that dirty region that need to be drawn,

00:04:53.660 --> 00:04:54.940
and call their drawRect.

00:04:55.050 --> 00:04:57.270
First on the parent one,
and then the drawRect for

00:04:57.350 --> 00:04:58.520
all the children ones.

00:04:58.630 --> 00:05:00.550
Now this is just showing
how the flow chart works.

00:05:00.720 --> 00:05:02.580
drawRect doesn't really
call the other drawRects,

00:05:02.660 --> 00:05:05.590
but it's just to emphasize
how it works here.

00:05:06.290 --> 00:05:10.860
So how does it work when you opt
into layers with a layer-backed

00:05:10.860 --> 00:05:13.300
view inside of a Cocoa application?

00:05:13.400 --> 00:05:15.950
So I have the little Cocoa or the
little Core Animation icon in the

00:05:16.000 --> 00:05:20.550
corner here to kind of emphasize that
this is a Core Animation-based slide.

00:05:20.670 --> 00:05:24.050
To opt into layer-backed views,
you call setOnceLayer

00:05:24.050 --> 00:05:25.600
on your topmost view.

00:05:25.660 --> 00:05:28.490
What's going to happen,
all your subviews are going

00:05:28.490 --> 00:05:30.140
to implicitly get layers.

00:05:30.220 --> 00:05:34.950
Those views don't actually have
setOnceLayer set to yes on them,

00:05:34.950 --> 00:05:38.380
but they do have a layer implicitly
created by AppKit by virtue of the

00:05:38.380 --> 00:05:41.970
parent having setOnceLayer yes being set.

00:05:42.570 --> 00:05:44.800
So when it is layer-backed,
what it really means

00:05:44.800 --> 00:05:47.790
is there's a CA layer,
a Core Animation layer,

00:05:47.850 --> 00:05:50.310
that kind of backs all these views.

00:05:50.430 --> 00:05:53.620
So all these views,
each layer is effectively

00:05:53.620 --> 00:05:57.980
like a little image,
and each image is created and filled

00:05:57.990 --> 00:06:00.930
in with your DROC implementation.

00:06:01.730 --> 00:06:06.350
So what happens when a layer needs to
draw is the layer has a dirty area.

00:06:06.720 --> 00:06:10.190
It creates, Core Animation creates,
a CGContextRef,

00:06:10.190 --> 00:06:14.360
which is essentially an image for
that entire layer's bound size.

00:06:14.480 --> 00:06:17.700
Core Animation calls into
AppKit using a delegate method,

00:06:17.750 --> 00:06:20.520
drawLayerInContext,
and that delegate method calls

00:06:20.520 --> 00:06:22.600
your implementation of drawRect.

00:06:22.680 --> 00:06:26.460
And whatever you drew in drawRect inside
of your bounds for your view is going

00:06:26.460 --> 00:06:28.130
to be cached into the layer contents.

00:06:28.320 --> 00:06:32.510
So essentially you're drawing
into just that layer's image.

00:06:33.430 --> 00:06:36.720
What happens when Core Animation actually
goes to display everything is it has

00:06:36.760 --> 00:06:39.920
all those individual layer contents,
all those little images,

00:06:40.010 --> 00:06:42.430
and it's going to composite them
together quickly on screen to

00:06:42.490 --> 00:06:45.010
give you what you finally see.

00:06:46.200 --> 00:06:49.520
So back to some traditional
Cocoa drawing and how we actually

00:06:49.520 --> 00:06:51.200
mark views as being dirty.

00:06:51.320 --> 00:06:53.970
So with traditional NSViews,
to mark a view as being dirty,

00:06:53.970 --> 00:06:55.600
you just call setNeedsDisplay: Yes.

00:06:55.740 --> 00:06:58.830
This should be hopefully very familiar.

00:06:58.960 --> 00:07:03.310
So what happens is the window's going
to keep track of that dirty region.

00:07:03.460 --> 00:07:07.690
Now, the interesting thing,
which hopefully you're all familiar with,

00:07:07.740 --> 00:07:11.410
if you invalidate that parent region,
everything in that parent

00:07:11.410 --> 00:07:14.500
region is going to invalidate,
and anything which happens

00:07:14.560 --> 00:07:17.740
to overlap with it will also
be invalidated and redraw.

00:07:17.860 --> 00:07:20.070
So if you have that
orange view underneath,

00:07:20.080 --> 00:07:21.700
it's going to also redraw.

00:07:22.050 --> 00:07:25.760
So if you call setNeedsDisplay
on the orange one subsequently,

00:07:25.790 --> 00:07:27.440
it will do the reverse.

00:07:27.440 --> 00:07:31.860
The parent view that's on top of it
will also be redrawn because the window

00:07:31.860 --> 00:07:34.280
is keeping track of that dirty region.

00:07:35.780 --> 00:07:38.010
Now, let's see how it works
when it's layer-backed,

00:07:38.060 --> 00:07:39.860
because it's slightly different.

00:07:39.910 --> 00:07:42.160
So if you call set-needs-display
on that orange view,

00:07:42.160 --> 00:07:44.900
on a layer-backed view,
just that view is going

00:07:44.940 --> 00:07:47.620
to be marked as dirty,
and just that view is

00:07:47.620 --> 00:07:49.100
going to be redrawn.

00:07:49.210 --> 00:07:52.300
So that other view, the custom one that's
overlapping with it,

00:07:52.390 --> 00:07:54.500
will not get redrawn.

00:07:54.590 --> 00:07:58.340
Now this is important because I found
some people will accidentally depend

00:07:58.340 --> 00:08:00.200
on the validation of sub-views.

00:08:00.260 --> 00:08:02.600
So you may call set-needs-display
on a parent view,

00:08:02.600 --> 00:08:05.560
and assume it would invalidate
the children views along with it.

00:08:05.650 --> 00:08:07.620
When you're layer-backed,
that will not happen.

00:08:07.630 --> 00:08:11.660
So if you see views not being redrawn,
make sure you're actually calling

00:08:11.660 --> 00:08:13.260
set-needs-display on them.

00:08:14.390 --> 00:08:16.860
So what we quickly covered here,
we talked about the traditional

00:08:16.860 --> 00:08:18.800
NSView drawing model.

00:08:18.870 --> 00:08:21.800
We talked about Core Animation and
how to opt into it and kind of how

00:08:21.800 --> 00:08:23.700
it works and draws with AppKit.

00:08:23.750 --> 00:08:26.030
And I discussed some differences
in set needs display for

00:08:26.030 --> 00:08:29.200
redrawing a layer-backed view
and a non-layer-backed view.

00:08:30.360 --> 00:08:33.890
So let's jump right in
and talk about animating.

00:08:33.950 --> 00:08:37.300
So how do we animate
traditionally inside of AppKit?

00:08:37.390 --> 00:08:40.590
Well, we introduced this
NSAnimatablePropertyContainer,

00:08:40.590 --> 00:08:43.300
which is implemented on custom
views or our standard views

00:08:43.300 --> 00:08:46.300
like NSView and NSWindow.

00:08:46.310 --> 00:08:49.240
And it introduces an
animator proxy object.

00:08:49.660 --> 00:08:55.300
This object is an opaque object which
you can treat as the original object.

00:08:55.460 --> 00:08:58.640
And any message you send to it,
which is changing a property

00:08:58.640 --> 00:09:02.300
value that's animatable,
will automatically animate for you.

00:09:02.300 --> 00:09:06.550
And what's going to happen is that
animator proxy is going to start

00:09:06.550 --> 00:09:10.610
the animation and potentially
also drive the animation.

00:09:10.920 --> 00:09:14.380
So what it looks like
for a practice case,

00:09:14.380 --> 00:09:16.720
or a use case,
is you'll do something like

00:09:16.720 --> 00:09:18.790
this with a little bit of code.

00:09:18.800 --> 00:09:23.160
You're going to grab the view frame,
let's say it starts out like 100x100,

00:09:23.200 --> 00:09:26.540
and you want to change that frame
to be 300x300 in the animation.

00:09:26.630 --> 00:09:29.910
So grab the View Animator
and call Set Frame on it.

00:09:30.030 --> 00:09:32.700
Now at this point,
if you read the view's frame back,

00:09:32.790 --> 00:09:35.700
the value that it's going
to have is still be 100x100.

00:09:35.700 --> 00:09:38.890
It's still going to be that original
value that it started out as.

00:09:38.970 --> 00:09:43.110
And what's going to happen is the
proxy's going to call Set Frame again

00:09:43.220 --> 00:09:45.840
and again and again on your view.

00:09:45.900 --> 00:09:49.770
Subsequently, your view will redraw on
each step of the animation.

00:09:49.970 --> 00:09:53.690
So it kind of looks something like this
for a traditional AppKit animation.

00:09:53.790 --> 00:09:56.050
Your view starts out as 100x100.

00:09:56.160 --> 00:09:59.790
The proxy calls set frame, say, 175x175.

00:09:59.860 --> 00:10:04.400
You redraw, call set frame again,
250x250, and you redraw.

00:10:04.460 --> 00:10:07.200
And finally, it calls it at 300x300,
the file size,

00:10:07.200 --> 00:10:09.280
and you redraw the file size.

00:10:09.400 --> 00:10:12.140
This is all done by
AppKit on the main thread,

00:10:12.200 --> 00:10:14.740
which is non-optimal,
so we're going to see how

00:10:14.840 --> 00:10:16.260
we can make this better.

00:10:17.290 --> 00:10:20.040
First of all, let's see how it's
done in Core Animation.

00:10:20.040 --> 00:10:23.080
So this is directly using Core Animation,
and it doesn't necessarily have

00:10:23.120 --> 00:10:25.000
anything to do with AppKit.

00:10:25.080 --> 00:10:28.500
The Core Animation layers
don't need an animator proxy.

00:10:28.550 --> 00:10:31.820
So if you want to change the frame size,
you grab your original frame,

00:10:31.970 --> 00:10:35.690
say 100 by 100,
you set it to be 300 by 300,

00:10:35.690 --> 00:10:37.510
and you assign that property.

00:10:37.620 --> 00:10:40.880
That Core Animation layer property is
going to implicitly animate automatically

00:10:41.270 --> 00:10:43.770
without having to use the animator proxy.

00:10:43.860 --> 00:10:47.170
And if you read that frame value back in,
it's going to be the

00:10:47.170 --> 00:10:51.550
final value of 300 by 300,
even though what you're seeing on

00:10:51.550 --> 00:10:55.300
screen is going to be the small,
original 100 by 100 image.

00:10:55.300 --> 00:10:58.680
So Core Animation is going to do all
that work in a background thread.

00:10:58.720 --> 00:11:01.940
It's going to do the interpolation
from the small image to the large

00:11:01.940 --> 00:11:04.490
image automatically for you.

00:11:04.960 --> 00:11:09.900
And what it's going to do is it's going
to stretch the contents of that layer.

00:11:09.970 --> 00:11:12.150
And the way it's going to
stretch depends on various

00:11:12.150 --> 00:11:14.230
Core Animation layer properties.

00:11:14.330 --> 00:11:17.280
But it's all done automatically,
and you do not get a call for

00:11:17.340 --> 00:11:20.380
drawRect each time it needs to draw.

00:11:22.250 --> 00:11:25.960
So if all these animation--
or all these properties for

00:11:26.030 --> 00:11:28.980
our CL layer are animatable,
AppKit doesn't want

00:11:28.980 --> 00:11:30.340
them to always animate.

00:11:30.440 --> 00:11:33.960
So AppKit's going to disable
all implicit animations that

00:11:34.020 --> 00:11:35.990
happen on Core Animation layers.

00:11:36.060 --> 00:11:40.950
It's going to enable them explicitly
when you use the animator proxy object.

00:11:41.020 --> 00:11:45.400
So when you call ViewAnimatorSetFrame,
it's going to implicitly turn on

00:11:45.400 --> 00:11:48.820
Core Animation layer animations
and allow that set frame

00:11:49.020 --> 00:11:51.410
change to actually animate.

00:11:52.980 --> 00:11:56.630
So that was quickly discussing how
we start animations and how they

00:11:56.630 --> 00:12:00.200
work with traditional AppKit and how
they work in Core Animation layers.

00:12:00.210 --> 00:12:03.390
Let's take a look at the
layer-contents-redraw policy we

00:12:03.390 --> 00:12:08.210
introduced in Lion and see how it
helps with a layer-backed view.

00:12:08.370 --> 00:12:12.870
So what this property does is it
tells AppKit how the NSView should

00:12:12.870 --> 00:12:16.400
invalidate the layer and when
it should invalidate the layer.

00:12:16.400 --> 00:12:19.890
It also is a key for how we
can actually drive animations.

00:12:20.010 --> 00:12:22.340
So let's take a look at
some of these values.

00:12:22.340 --> 00:12:26.110
We have the
NSViewLayerContentsRedrawDuringViewResize

00:12:26.110 --> 00:12:30.140
,
OnSetNeedsDisplay, BeforeFrameResize,

00:12:30.140 --> 00:12:31.930
and Never.

00:12:31.950 --> 00:12:34.530
All these properties only
apply to a layer-backed view,

00:12:34.680 --> 00:12:37.890
and so if you aren't using layers,
it doesn't do anything.

00:12:38.060 --> 00:12:42.740
So let's take a look at that first one,
the RedrawDuringViewResize.

00:12:42.740 --> 00:12:45.410
This is the default
value inside of AppKit,

00:12:45.450 --> 00:12:48.260
and we're going to recommend that
you don't use it because it's

00:12:48.260 --> 00:12:51.780
going to call SetNeedsDisplay
each time the frame changes.

00:12:51.780 --> 00:12:54.770
Now, it's the default value because
it's the most compatible

00:12:54.770 --> 00:12:57.780
with how AppKit animations
have traditionally worked.

00:12:57.780 --> 00:13:03.280
So if you have your view frame size,
again, going from 100x100 to 300x300,

00:13:03.280 --> 00:13:06.420
and you use the ViewAnimator
to change it to 300x300,

00:13:06.420 --> 00:13:09.700
if you read in that frame size,
it's still at 100x100,

00:13:09.830 --> 00:13:12.140
and the proxy is going
to call SetFrame for you.

00:13:12.220 --> 00:13:15.100
So again, looking at that previous
slide that we looked at,

00:13:15.100 --> 00:13:19.890
even though you have a layer-backed view,
this animation is going

00:13:19.890 --> 00:13:23.960
to be driven by AppKit,
in the main thread,

00:13:23.960 --> 00:13:27.910
because we assume you need to
draw on each SetFrame call.

00:13:28.070 --> 00:13:31.340
We don't know if you can
properly stretch your contents,

00:13:31.360 --> 00:13:33.750
so that is why it's the default value.

00:13:34.780 --> 00:13:38.990
A better value to use is the
OnSetNeedsDisplay value for the

00:13:38.990 --> 00:13:41.600
layer content's redraw policy.

00:13:41.720 --> 00:13:44.230
So let's take a look
at why this is better.

00:13:44.360 --> 00:13:45.830
And what does this property mean?

00:13:46.050 --> 00:13:49.110
Well, it means you have to actually
call SetNeedsDisplay on the

00:13:49.110 --> 00:13:51.340
layer to tell us when to redraw.

00:13:51.350 --> 00:13:54.130
We're not going to do it
when SetFrame is called.

00:13:54.220 --> 00:13:55.890
So that means whenever
your frame changes,

00:13:56.000 --> 00:13:59.620
you actually have to explicitly
call SetNeedsDisplay on the layer.

00:13:59.730 --> 00:14:04.330
It's not the default value,
so we require you to go ahead and set it.

00:14:05.270 --> 00:14:07.720
So if you do set this value,
what's going to happen is if

00:14:07.760 --> 00:14:11.550
you have a layer-backed view,
like this single image here,

00:14:11.550 --> 00:14:17.160
your frame starts out by 100x100,
you change the frame size to be 300x300,

00:14:17.160 --> 00:14:19.200
and set it using the Animator Proxy.

00:14:19.260 --> 00:14:21.270
If you read that value
back in from the view,

00:14:21.320 --> 00:14:24.680
just like when it's a strict layer,
your value is going to be

00:14:24.830 --> 00:14:29.700
the final size of 300x300,
and Core Animation is going to drive

00:14:29.700 --> 00:14:33.800
that animation in the background thread,
and you will not get a draw-rec

00:14:34.080 --> 00:14:37.960
call on each step of the animation,
but it's very fast and efficient.

00:14:38.220 --> 00:14:40.100
So why isn't that the default value?

00:14:40.220 --> 00:14:43.120
Well, the reason why is because what
if you have a custom view like

00:14:43.230 --> 00:14:46.890
this one that really needed to
redraw each step of the animation?

00:14:47.010 --> 00:14:49.800
So if drawX is not being called,
what's going to happen is the

00:14:49.800 --> 00:14:51.850
contents are going to be stretched.

00:14:51.950 --> 00:14:55.630
So you're stretching the text
and you're stretching the image,

00:14:55.660 --> 00:14:57.180
which actually is going
to be displayed there,

00:14:57.310 --> 00:14:59.060
and it's going to not look good.

00:14:59.160 --> 00:15:03.050
The image will probably be blurry
and the text will probably be blurry.

00:15:04.890 --> 00:15:09.010
So, what is the solution to that so you
can use Onset Needs Display to get fast

00:15:09.010 --> 00:15:11.890
animations driven by Core Animation?

00:15:11.900 --> 00:15:14.510
You can composite your view
with subviews in order to

00:15:14.580 --> 00:15:16.280
actually make it work correctly.

00:15:16.320 --> 00:15:20.550
So your background could just be
a view which draws a light gray

00:15:20.550 --> 00:15:23.500
with a dark gray border fill.

00:15:23.520 --> 00:15:25.840
And then you can composite
it made of subviews,

00:15:25.840 --> 00:15:30.200
so you could drop in an NSTextField
for your actual text area,

00:15:30.200 --> 00:15:33.000
and an NSImageView for your image there.

00:15:33.010 --> 00:15:36.180
Or you can just use the
AutoResizingMask or AutoLayout

00:15:36.380 --> 00:15:39.990
to actually control your position
of where these views are located.

00:15:40.460 --> 00:15:42.990
Then at runtime,
what happens when the animation happens,

00:15:42.990 --> 00:15:44.910
it's going to be smooth,
it's going to be driven

00:15:44.910 --> 00:15:47.940
by Core Animation inside
the background thread.

00:15:47.940 --> 00:15:50.940
The text is not going to stretch because
it's just going to move the layer

00:15:50.940 --> 00:15:53.640
around from one position to another,
because in this case we didn't

00:15:53.640 --> 00:15:56.330
even want to change the text size.

00:15:56.410 --> 00:15:59.430
And the ImageView is going to
properly stretch and know how

00:15:59.470 --> 00:16:04.140
to redraw itself or stretch,
and will look perfectly fine.

00:16:05.950 --> 00:16:09.780
Now another option for the
layer contents redraw policy,

00:16:09.780 --> 00:16:14.150
we have the
NSViewLayerContentsRedrawBeforeViewResize

00:16:14.150 --> 00:16:14.150
.

00:16:14.820 --> 00:16:18.690
So what this means is it's going to
invalidate the view and the layer

00:16:19.330 --> 00:16:21.670
right before the animation starts.

00:16:21.670 --> 00:16:26.030
And it's going to let you redraw
at the final size of the animation.

00:16:26.070 --> 00:16:29.900
It's going to use that as the contents
for the animation as it happens.

00:16:29.900 --> 00:16:32.590
In Core Animation,
we use that for driving the

00:16:32.590 --> 00:16:34.460
animation on the background thread.

00:16:34.530 --> 00:16:38.520
This means the contents are going to
look crisp at the end of the animation,

00:16:38.520 --> 00:16:41.020
but might look a little bad at the start.

00:16:41.130 --> 00:16:44.330
So let me emphasize and
show how that works.

00:16:44.430 --> 00:16:47.940
So if you're using this
Before View Resize option,

00:16:48.060 --> 00:16:51.340
and you're changing
from 100x100 to 300x300,

00:16:51.340 --> 00:16:54.550
as soon as you make that
animator call before the

00:16:54.550 --> 00:16:58.390
animator even starts animating,
your view is going to instantly

00:16:58.400 --> 00:17:01.220
see itself at the final size of,
say, 300x300,

00:17:01.460 --> 00:17:03.980
and redraw once right there.

00:17:04.060 --> 00:17:07.720
Then that's going to be the contents
for your layer stretched down.

00:17:07.810 --> 00:17:10.470
Since it's stretched down,
your contents might look

00:17:10.550 --> 00:17:11.980
a little down-sampled.

00:17:11.980 --> 00:17:13.810
It might not look perfect or quite good.

00:17:15.590 --> 00:17:19.080
But during the animation,
it's going to be fast and smooth,

00:17:19.080 --> 00:17:22.340
and at the end of the animation,
it will look correct and perfect.

00:17:22.480 --> 00:17:25.430
So this is a good option to
use in some cases where you

00:17:25.430 --> 00:17:29.000
know that you can redraw once,
and it will look fine.

00:17:30.870 --> 00:17:36.570
Next, we have the NSView Layer Contents
Redraw Never option.

00:17:36.670 --> 00:17:38.160
So what is this good for?

00:17:38.430 --> 00:17:43.020
Well, what it means is whenever you call
setNeedsDisplayYes on your view,

00:17:43.260 --> 00:17:44.670
the view is not going to do anything.

00:17:44.920 --> 00:17:48.160
It's not going to invalidate
the layer or touch it at all.

00:17:48.260 --> 00:17:51.070
So this is good in some very
limited and useful cases,

00:17:51.070 --> 00:17:52.320
or some limited cases.

00:17:52.540 --> 00:17:57.130
One particular place that's very
useful is for a layer-hosted view,

00:17:57.180 --> 00:17:59.600
which begs the question,
"What's the difference between

00:17:59.600 --> 00:18:02.840
layer-backing and layer-hosting?"
Layer-backing is what we're

00:18:02.920 --> 00:18:06.440
talking about in this talk,
and that's when AppKit's going to

00:18:06.440 --> 00:18:10.200
create and manage a layer for you
that's essentially behind the view.

00:18:10.400 --> 00:18:12.540
You don't really have
to do anything with it.

00:18:12.550 --> 00:18:15.140
It's going to own most of
the properties on the layer,

00:18:15.230 --> 00:18:19.110
and you don't have
explicit control over it.

00:18:19.600 --> 00:18:24.360
Layer hosting is you as a developer
say create a custom CA layer

00:18:24.360 --> 00:18:28.650
subclass called MyCustomLayer,
and you call setLayer in that view.

00:18:28.780 --> 00:18:31.650
We're going to host that layer
inside of the view for you.

00:18:31.840 --> 00:18:35.880
We're going to keep a hands-off
approach and not touch things on it.

00:18:37.410 --> 00:18:40.330
So that was discussing animating,
and in particular using the

00:18:40.330 --> 00:18:43.790
Layer Contents Redraw policy to get fast,
smooth animations.

00:18:43.910 --> 00:18:46.460
Let's talk about contents updating.

00:18:46.540 --> 00:18:48.080
So you have these fast animations.

00:18:48.230 --> 00:18:50.580
It's great,
but you have lots of memory now,

00:18:50.580 --> 00:18:53.700
because on screen you have a
ton of these layers that all

00:18:53.700 --> 00:18:55.300
have the same exact contents.

00:18:55.300 --> 00:18:56.500
They all have a green background.

00:18:56.500 --> 00:18:58.100
They all have the same image.

00:18:58.180 --> 00:19:01.200
So how can we actually
make memory better?

00:19:01.310 --> 00:19:03.650
Or use less memory?

00:19:03.770 --> 00:19:08.010
The way to use less memory
is to not use drawRact.

00:19:09.240 --> 00:19:11.640
Now, how can you not use DrawEct?

00:19:11.790 --> 00:19:13.420
Well,
the way you can do it is by directly

00:19:13.420 --> 00:19:17.850
using Core Animation properties
to represent your user interface.

00:19:17.970 --> 00:19:21.350
Now, CA Layer has some properties like
background color and border color

00:19:21.350 --> 00:19:25.260
that you can explicitly set to
control how your layer looks.

00:19:25.390 --> 00:19:28.480
You can also directly set
the layer's contents to be a

00:19:28.490 --> 00:19:30.500
particular image that you have.

00:19:30.630 --> 00:19:33.740
And you can use that same layer contents,
that same image,

00:19:33.870 --> 00:19:38.650
in multiple views that have the actual
same look and share it everywhere.

00:19:38.780 --> 00:19:43.010
You can also take a small image
and have it stretch properly.

00:19:43.250 --> 00:19:46.840
Let's take a look at how that
works by just a regular CA layer

00:19:47.120 --> 00:19:48.290
and how you set properties.

00:19:48.460 --> 00:19:51.530
If you have a typical CA layer,
you can do things like set the

00:19:51.630 --> 00:19:54.990
background color to be white,
border color to be 2 pixels

00:19:54.990 --> 00:19:57.590
wide or 2 points wide,
and red.

00:19:57.660 --> 00:20:00.200
And you get these intrinsic
properties that are set,

00:20:00.200 --> 00:20:01.850
and they're very cheap to set.

00:20:02.120 --> 00:20:06.690
Interesting thing that's new to
Mountain Lion is we now have methods on

00:20:06.700 --> 00:20:11.720
NSColor to convert from the NSColor to a
CGColorRef because Core Animation layers

00:20:11.770 --> 00:20:14.470
utilize CGColorRefs.

00:20:17.080 --> 00:20:19.150
In addition to setting
intrinsic properties like the

00:20:19.150 --> 00:20:21.800
border and background color,
you can also set the

00:20:21.800 --> 00:20:25.290
contents explicitly to be,
say, an image that you have,

00:20:25.290 --> 00:20:29.990
and just have it stretch to
be the contents of the layer.

00:20:30.680 --> 00:20:34.400
Let's take a look at the traditional
layer updating again and how it works.

00:20:34.530 --> 00:20:37.910
So again, your layer needs to draw,
recreate an image,

00:20:37.910 --> 00:20:41.380
or Core Animation creates an
image to have you draw into,

00:20:41.380 --> 00:20:43.040
the CGContextRef.

00:20:43.170 --> 00:20:46.400
And then it calls drawRack to
fill in the layer contents.

00:20:46.520 --> 00:20:49.400
Now in Mountain Lion,
we added a new step here to

00:20:49.520 --> 00:20:51.700
more efficiently update things.

00:20:51.800 --> 00:20:55.940
We added a new API in
NSView called WantsUpdateLayer.

00:20:56.020 --> 00:20:59.420
If you say no to WantsUpdateLayer,
it's going to retrieve the traditional

00:20:59.440 --> 00:21:02.700
AppKit drawing of filling in the
layer contents with drawRack.

00:21:02.750 --> 00:21:05.670
If you say yes,
then AppKit's going to use a different

00:21:05.670 --> 00:21:10.900
Core Animation delegate method called
DisplayLayer to fill in the contents.

00:21:11.000 --> 00:21:14.680
And what it's going to do is it's going
to call a new method in AppKit called

00:21:14.680 --> 00:21:19.730
UpdateLayer for you to explicitly
update the layer however you want.

00:21:20.410 --> 00:21:22.460
So let's take a look
at implementing this.

00:21:22.530 --> 00:21:25.700
You override wantsUpdateLayer,
and you say yes.

00:21:26.010 --> 00:21:28.870
Your updateLayer implementation
is going to just directly set

00:21:28.870 --> 00:21:30.500
those Core Animation properties.

00:21:30.570 --> 00:21:33.760
So you could just directly say, hey,
the background color is white

00:21:33.860 --> 00:21:35.590
and the border color is red.

00:21:35.930 --> 00:21:38.040
You can also directly
set your layer contents.

00:21:38.040 --> 00:21:40.190
So you just directly set the
layer contents to be whatever

00:21:40.200 --> 00:21:42.900
image you already happen to have.

00:21:44.230 --> 00:21:47.380
Now, why is this better and
why does it save memory?

00:21:47.430 --> 00:21:50.890
Well, now you have that same image,
which is actually shared

00:21:50.890 --> 00:21:52.430
in multiple locations.

00:21:52.510 --> 00:21:57.100
So instead of having DrawRect drawing
into an individual image for each one,

00:21:57.130 --> 00:22:00.520
we're utilizing the same
image in multiple locations.

00:22:00.570 --> 00:22:04.520
In addition, those backgrounds actually
aren't even drawing anymore.

00:22:04.530 --> 00:22:07.150
It's just setting a
Core Animation property to

00:22:07.150 --> 00:22:09.090
say it's gonna be light gray.

00:22:09.110 --> 00:22:13.370
So it's very efficient and cheap
for memory in order to do this.

00:22:15.190 --> 00:22:17.140
So that's cool,
but what if you want to do

00:22:17.140 --> 00:22:19.200
some more complex things,
such as you want to

00:22:19.200 --> 00:22:22.980
create a button like this,
which has a background that needs to be

00:22:23.110 --> 00:22:25.490
stretched with like a nine-part image?

00:22:25.610 --> 00:22:28.280
So how do we do that and have it
actually get it so that when your

00:22:28.280 --> 00:22:31.350
button is animated and resized,
it animates and resides smoothly

00:22:31.460 --> 00:22:35.830
and correctly and is done by
Core Animation and background thread?

00:22:36.790 --> 00:22:39.940
What you're going to do is you're
going to make your view have several

00:22:39.940 --> 00:22:42.500
sub-views to represent each piece.

00:22:42.600 --> 00:22:46.750
You'll have a background view area
that's just the background of the button.

00:22:46.850 --> 00:22:50.660
And you have this background nine-part
image which you want to stretch properly.

00:22:50.740 --> 00:22:54.840
And normally you'd use NSImageDrawing
to just draw it and fill it in.

00:22:54.990 --> 00:22:57.340
Instead of that,
you want to share this image

00:22:57.620 --> 00:23:00.880
with all buttons that you happen
to have in your application.

00:23:01.610 --> 00:23:03.250
And the way you're going to do
it is you're going to implement

00:23:03.260 --> 00:23:06.400
this new Mountain Lion method,
update layer,

00:23:06.490 --> 00:23:10.650
set the contents directly to
that image that you already have,

00:23:10.740 --> 00:23:16.100
And the thing to note here is that image
is smaller than your actual view's size.

00:23:16.100 --> 00:23:18.530
And you want Core Animation to
stretch it properly.

00:23:18.660 --> 00:23:22.490
You want to take that middle
pixel line and repeat it.

00:23:22.580 --> 00:23:25.860
Core Animation has a great property
called the Content Center that

00:23:25.860 --> 00:23:27.700
tells it how to properly stretch.

00:23:27.740 --> 00:23:30.750
And so what we're doing here is,
in this example, I'm saying,

00:23:30.750 --> 00:23:34.530
take that middle pixel and use
that as the stretching portion.

00:23:34.620 --> 00:23:37.140
So the end caps are left
exactly as they are,

00:23:37.140 --> 00:23:39.860
and just the middle portion is stretched.

00:23:39.940 --> 00:23:43.360
I highly recommend looking at
the CA Layer header and the

00:23:43.440 --> 00:23:46.170
Core Animation documentation
to see how this property

00:23:46.170 --> 00:23:49.030
works to fully understand it.

00:23:50.680 --> 00:23:53.960
So how do you do something
like add the text field there?

00:23:53.970 --> 00:23:55.600
Normally you would just draw it.

00:23:55.690 --> 00:23:59.600
Well now you're going to override layout,
and inside of layout you're

00:23:59.600 --> 00:24:04.640
going to probably alloc-init a
text field and store it in Ivar.

00:24:04.640 --> 00:24:06.780
If you didn't have it, you'll create it.

00:24:06.840 --> 00:24:09.690
If you already have your text field,
then what you're going to do is

00:24:09.690 --> 00:24:11.160
just update the frame for it.

00:24:11.190 --> 00:24:13.570
And then you call super layout.

00:24:13.760 --> 00:24:18.580
Now, if you're familiar with Auto Layout,
this method layout was introduced

00:24:18.870 --> 00:24:21.800
for Auto Layout on Lion.

00:24:21.870 --> 00:24:24.960
And this method is called
if you're using Auto Layout,

00:24:24.960 --> 00:24:28.610
or what we did in Mountain Lion is
if you aren't using Auto Layout,

00:24:28.610 --> 00:24:32.670
but you are using layer-backed view,
we will call Layout for you so

00:24:32.680 --> 00:24:36.680
you can opt into using this new
technology without having to

00:24:36.710 --> 00:24:39.170
necessarily adopt Auto Layout.

00:24:40.660 --> 00:24:43.850
Now how do you deal with multiple states?

00:24:43.980 --> 00:24:45.910
Well, you're going to do what you
typically did in drawing,

00:24:45.910 --> 00:24:48.260
which is switch based on
something like your press state,

00:24:48.390 --> 00:24:51.740
except you're going to just set
different layer contents based

00:24:51.740 --> 00:24:53.810
on if you're pressed or not.

00:24:54.080 --> 00:24:55.490
So that's pretty easy.

00:24:55.620 --> 00:24:58.070
And then the way to actually
invalidate yourself is the

00:24:58.130 --> 00:24:59.600
same way you'd do it before.

00:24:59.650 --> 00:25:02.560
Say in your mouse down,
you just call setNeedDisplay: yes,

00:25:02.560 --> 00:25:06.180
and that will trigger us to
call updateLayer again lazily,

00:25:06.180 --> 00:25:07.540
only when it needs to be.

00:25:07.650 --> 00:25:09.560
and you can actually update
your state for your button

00:25:09.590 --> 00:25:11.980
background to be a press state.

00:25:13.340 --> 00:25:15.660
Now, how do you update the title?

00:25:15.710 --> 00:25:18.150
Well, if you have the title as
a separate text field,

00:25:18.310 --> 00:25:19.700
then it's really easy.

00:25:19.800 --> 00:25:23.190
You're just going to forward to the
text field the setting of the title.

00:25:23.400 --> 00:25:27.210
And the NSTextField is going to know
how to actually draw itself and redraw

00:25:27.490 --> 00:25:29.580
itself properly and efficiently.

00:25:29.780 --> 00:25:31.820
You're going to call
setNeedLayout on yourself.

00:25:32.090 --> 00:25:34.610
You're not going to call
setNeedDisplay on yourself because

00:25:34.650 --> 00:25:38.450
you as a button don't need to draw
when your title changes anymore.

00:25:38.520 --> 00:25:41.300
But you need to layout because your
title might have gone from big to

00:25:41.300 --> 00:25:44.880
small and you need another call to
layout to actually layout your text

00:25:44.880 --> 00:25:46.780
position in the right location.

00:25:48.880 --> 00:25:51.720
So that was discussing animating
and how to actually break up

00:25:51.820 --> 00:25:55.320
your view into subviews and get
efficient animations that way.

00:25:55.480 --> 00:25:59.220
Let's talk about how to
synchronize subview animations.

00:25:59.490 --> 00:26:02.170
So consider this:
you're using the new Layer Contents

00:26:02.240 --> 00:26:06.110
Redraw policy that we introduced in Lion,
and you want to animate a

00:26:06.110 --> 00:26:11.300
parent view's frame size which
has a child view inside of it.

00:26:12.880 --> 00:26:15.510
Now you're going to use the
animator proxy to change that parent

00:26:15.510 --> 00:26:19.560
view's frame size to be small,
from being small to, say, being large,

00:26:19.590 --> 00:26:22.480
like 500 by 500.

00:26:22.590 --> 00:26:25.810
Now, if you recall what I said earlier,
that view's going to instantly

00:26:25.940 --> 00:26:29.200
think it's at the final size
before the animation starts.

00:26:29.280 --> 00:26:32.870
So if your view does something
like layout inside a set frame,

00:26:33.010 --> 00:26:37.100
it's going to put that child
view at the final location.

00:26:37.430 --> 00:26:40.250
And so when the animation starts,
you'll probably see something like this.

00:26:40.370 --> 00:26:43.130
That view's out in the middle of space.

00:26:43.150 --> 00:26:45.920
and the actual other view is going
to only be the thing that animates.

00:26:45.980 --> 00:26:50.200
So how do we synchronize those
subviews' animations together?

00:26:50.440 --> 00:26:53.240
What we really want is
something that looks like this.

00:26:53.240 --> 00:26:55.540
Animates together synchronized.

00:26:56.880 --> 00:27:00.720
First,
let's discuss the NSAnimationContext,

00:27:00.850 --> 00:27:04.300
which applies to layer-backed
or non-layer-backed views.

00:27:04.360 --> 00:27:08.420
What this context does is allows
you to group animations together.

00:27:08.500 --> 00:27:11.550
You can group animations
and change the duration,

00:27:11.610 --> 00:27:14.350
the timing,
and some other properties that happen

00:27:14.350 --> 00:27:17.020
for that particular group of animations.

00:27:17.930 --> 00:27:18.850
Why is this important?

00:27:19.150 --> 00:27:21.310
Because in Mountain Lion we
introduced a new property

00:27:21.500 --> 00:27:24.960
called AllowsImplicitAnimations.

00:27:25.070 --> 00:27:29.510
This property controls those
implicit layer animations.

00:27:29.970 --> 00:27:32.550
What happens is this
property defaults to No.

00:27:32.590 --> 00:27:35.500
When it's set to Yes on
the animation context,

00:27:35.550 --> 00:27:39.400
all view or layer properties
will implicitly animate without

00:27:39.400 --> 00:27:42.060
having to use the animator proxy.

00:27:42.160 --> 00:27:44.140
So this allows nested
animations to happen.

00:27:44.390 --> 00:27:47.440
You can call SetFrame on the
parent view using the animator,

00:27:47.460 --> 00:27:51.120
and the children will implicitly
animate without having to

00:27:51.120 --> 00:27:53.800
be using the animator proxy.

00:27:53.820 --> 00:27:57.720
Now, if you're familiar with UIKit,
this is very similar to UIView's

00:27:57.720 --> 00:27:59.830
SetAnimationsEnabled property.

00:27:59.960 --> 00:28:03.090
And of course,
this only applies to layer-backed views,

00:28:03.110 --> 00:28:06.690
so it does not work or do anything
for non-layer-backed cases.

00:28:08.090 --> 00:28:09.390
So how does it work?

00:28:09.490 --> 00:28:12.570
Well,
you actually don't have to ever set this.

00:28:12.830 --> 00:28:16.300
If you're using the animator proxy,
it'll be set for you automatically

00:28:16.440 --> 00:28:18.550
and you don't have to do anything.

00:28:18.690 --> 00:28:22.830
So when you call the animator,
it's implicitly going to say, "Hey,

00:28:22.830 --> 00:28:25.340
animation context,
let's say it allows implicit

00:28:25.340 --> 00:28:30.540
animations to be yes." Then change
your frame and then set it back to no.

00:28:30.670 --> 00:28:34.370
So what's cool about this
is in your frame change,

00:28:34.370 --> 00:28:38.010
if you do any layout that
changes subview frames,

00:28:38.410 --> 00:28:42.000
they're going to implicitly animate
along with that parent view,

00:28:42.060 --> 00:28:44.190
which is generally what you want.

00:28:44.340 --> 00:28:47.220
And in the end, it gives you that view
where the child view,

00:28:47.220 --> 00:28:49.680
the little blue one,
will animate synchronized

00:28:49.680 --> 00:28:50.940
with the parent view.

00:28:53.010 --> 00:28:56.550
So that was discussing animating,
and I was talking about how to

00:28:56.550 --> 00:29:02.160
actually do synchronized sub-view
animations with Apparent View.

00:29:02.240 --> 00:29:04.760
Let's move on and talk
about some best practices,

00:29:04.810 --> 00:29:06.440
and in particular,
text and font smoothing

00:29:06.440 --> 00:29:08.480
and how to deal with it.

00:29:09.420 --> 00:29:13.460
First of all, LCD font smoothing,
what is it?

00:29:13.530 --> 00:29:16.650
Well, it's also known as
subpixel anti-aliasing.

00:29:16.790 --> 00:29:18.840
It is actually different
than anti-aliasing,

00:29:18.840 --> 00:29:20.300
which is separate.

00:29:20.400 --> 00:29:22.720
And you can kind of see it in
this close-up shot here of the

00:29:22.820 --> 00:29:26.800
word "button." The LCD font
smoothing on an LCD display will,

00:29:26.910 --> 00:29:30.300
when we render text,
will make it look better to read by

00:29:30.300 --> 00:29:33.300
changing the colors adjacent to the text.

00:29:33.300 --> 00:29:38.170
So next to the letters "b" and
"button," you can see a blue area on

00:29:38.170 --> 00:29:43.250
the right and a little yellow area
kind of on the left of the text.

00:29:43.300 --> 00:29:47.630
And that's what LCD font smoothing is.

00:29:49.150 --> 00:29:54.310
In order for LCD font smoothing to work,
we actually have to draw the text

00:29:54.480 --> 00:29:56.640
into something that's opaque.

00:29:56.710 --> 00:30:00.690
The text needs something to composite
with in order to do font smoothing.

00:30:00.790 --> 00:30:02.500
In other words,
it needs to know the colors

00:30:02.680 --> 00:30:06.890
that are by the letters in order
for it to do font smoothing.

00:30:07.330 --> 00:30:10.970
Now, with normal AppKit drawing,
this all works great because,

00:30:10.970 --> 00:30:13.670
as I showed at the start,
you're going to draw

00:30:13.670 --> 00:30:16.480
your background first,
and then you explicitly

00:30:16.540 --> 00:30:18.940
draw the text on top of it,
so when the text is drawn,

00:30:18.940 --> 00:30:22.970
it has something to composite
with and do LCD font smoothing.

00:30:24.000 --> 00:30:27.660
When you have a layer-backed view,
that may not be the case.

00:30:27.660 --> 00:30:30.340
So you might have a separate
layer for your background,

00:30:30.350 --> 00:30:33.830
and that separate opaque layer
is separate from the text.

00:30:34.170 --> 00:30:36.880
So pretend that word
"tandem" is in its own layer,

00:30:37.000 --> 00:30:40.240
and "pretend" it has a
non-opaque background layer.

00:30:40.310 --> 00:30:44.000
So in other words,
that white area is actually transparent.

00:30:44.090 --> 00:30:46.950
So the text there, when it's drawn,
wouldn't have anything to

00:30:46.950 --> 00:30:49.810
do font-smoothing with when
it's drawn into that layer.

00:30:50.380 --> 00:30:52.050
So this presents a problem.

00:30:52.110 --> 00:30:55.310
If you draw text into
something that's transparent,

00:30:55.340 --> 00:30:56.940
it's going to not look right.

00:30:57.100 --> 00:30:59.260
In particular,
it's going to look a little

00:30:59.260 --> 00:31:00.600
bowler than it should.

00:31:00.710 --> 00:31:03.390
And again in this screenshot,
pretend the white area is transparent.

00:31:03.450 --> 00:31:06.090
It's just hard to represent in slides.

00:31:06.370 --> 00:31:10.170
So if we turn off font smoothing,
we discovered, hey,

00:31:10.260 --> 00:31:14.440
the text actually looks better because,
well, it's still got anti-aliasing.

00:31:14.530 --> 00:31:16.660
So let me go back to the
previous slide really quick.

00:31:16.810 --> 00:31:18.940
So here, notice how the text looks bold?

00:31:18.970 --> 00:31:22.780
If we turn off font smoothing,
it looks a little bit smoother

00:31:22.840 --> 00:31:24.500
and better to the eye.

00:31:26.180 --> 00:31:29.080
So what AppKit is going to do
is it's going to automatically

00:31:29.080 --> 00:31:32.240
turn off font smoothing for
your view when it does drawing,

00:31:32.240 --> 00:31:37.090
and it's going to automatically turn
it off if you say "No" to "Is Opaque."

00:31:37.140 --> 00:31:40.720
So if you don't have an opaque view,
then we'll just turn it off so it

00:31:40.750 --> 00:31:43.090
looks better without font smoothing.

00:31:43.100 --> 00:31:47.620
If your view says "Yes" to "Is Opaque,"
we leave font smoothing on so that

00:31:47.700 --> 00:31:50.090
you get that great-looking text.

00:31:50.610 --> 00:31:53.150
Of course,
what if you have a view that says

00:31:53.250 --> 00:31:57.040
"no to being is-opaque" because,
say, it's drawing a round background,

00:31:57.040 --> 00:32:00.940
but you really are drawing text
into an opaque area in that view?

00:32:01.000 --> 00:32:03.940
So you know you can
do LCD font smoothing.

00:32:04.040 --> 00:32:08.220
What you can do as a developer
is manually turn it on.

00:32:08.700 --> 00:32:15.100
And the way you turn it on is you grab
the current context as a CG Context

00:32:15.100 --> 00:32:19.840
Ref using Inits Graphic Context,
Current Context, Graphics Port.

00:32:19.840 --> 00:32:24.710
Explicitly use the
CGContextSetShouldSmoothFonts to true

00:32:25.090 --> 00:32:28.060
to turn it actually on explicitly.

00:32:28.210 --> 00:32:32.790
And then you can go ahead and draw your
text and you'll get LCD font smoothing.

00:32:33.340 --> 00:32:37.620
So, that's great, you can control it,
but what if you really just want to

00:32:37.620 --> 00:32:40.800
use a text field and have it have
a background that's transparent?

00:32:40.930 --> 00:32:43.260
Well, the great thing that we
did in Mountain Lion is

00:32:43.540 --> 00:32:47.110
text fields automatically
implement LCD font smoothing,

00:32:47.110 --> 00:32:49.860
even if they're in a transparent layer.

00:32:49.960 --> 00:32:51.460
So this is really cool and great.

00:32:51.570 --> 00:32:53.720
It means you can just
drop a text field down,

00:32:53.850 --> 00:32:56.530
the text field can have a
background that's transparent,

00:32:56.570 --> 00:32:59.060
and it's going to properly
do font smoothing.

00:32:59.060 --> 00:33:01.510
We did all the work in
AppKit magically to make it work

00:33:01.560 --> 00:33:05.390
automatically with Core Animation,
so you don't have to worry about

00:33:05.390 --> 00:33:07.500
it if you're using text fields.

00:33:09.970 --> 00:33:14.410
So there's a caveat with this is
we still need a layer-backed view

00:33:14.570 --> 00:33:16.800
in the hierarchy that is opaque.

00:33:16.850 --> 00:33:20.810
So if you just set do set wants layer
on a text field and it doesn't have

00:33:20.810 --> 00:33:23.900
any parents which are layer-backed,
then it won't work.

00:33:23.970 --> 00:33:25.140
But that's generally not the case.

00:33:25.140 --> 00:33:27.740
Usually you have more than
one layer-backed area.

00:33:27.740 --> 00:33:31.970
So it works great if at least
one ancestor layer is opaque.

00:33:33.980 --> 00:33:37.400
So that was discussing some
best practices with text,

00:33:37.400 --> 00:33:40.060
in particular how to get
fonts moving and how it should

00:33:40.060 --> 00:33:42.340
work with layer-backed views.

00:33:42.380 --> 00:33:44.770
Let's talk about focus rings.

00:33:45.110 --> 00:33:48.370
So this is typical Cocoa drawing
of how you actually deal with

00:33:48.860 --> 00:33:50.720
focus rings and how you draw them.

00:33:50.830 --> 00:33:55.140
So your typical draw implementation
will do all your typical normal drawing

00:33:55.140 --> 00:33:57.340
of drawing the text and image first.

00:33:57.450 --> 00:34:00.160
And then you'll probably check,
see if you are the

00:34:00.170 --> 00:34:02.130
window's first responder.

00:34:02.250 --> 00:34:05.530
So if the self.windowFirstResponder
is yourself,

00:34:05.540 --> 00:34:08.650
you'll probably do something
like NSSetFocusRingStyle

00:34:08.750 --> 00:34:12.350
to be NSFocusRingOnly,
saying that whatever's going to be

00:34:12.350 --> 00:34:14.300
drawn is just going to be a focus ring.

00:34:14.400 --> 00:34:17.110
And then you'll do a fill,
and whatever you fill or drew

00:34:17.280 --> 00:34:20.510
isn't going to draw what you drew,
but instead draw the focus

00:34:20.510 --> 00:34:21.890
ring around that area.

00:34:21.960 --> 00:34:26.070
So this will just draw the focus ring
around the whole view that we had there.

00:34:26.180 --> 00:34:30.500
But notice the focus ring is actually
drawing outside the bounds of your view.

00:34:31.330 --> 00:34:35.120
That's important because if you do that
same type of code in a layer-backed view,

00:34:35.120 --> 00:34:39.040
well, it's going to clip that focus ring
outside of your view's bounds,

00:34:39.040 --> 00:34:40.460
and it's going to look wrong.

00:34:40.490 --> 00:34:41.980
Let me go back again so you can see.

00:34:42.170 --> 00:34:45.240
See how it's blurry around
the edge with the focus ring?

00:34:45.300 --> 00:34:47.040
And now the focus ring is clipped.

00:34:47.060 --> 00:34:50.170
So how do you solve that
with a layer-backed view?

00:34:51.680 --> 00:34:55.840
Well, what we did is, in Lion,
we introduced a new API to solve this.

00:34:55.940 --> 00:35:02.310
We introduced three new methods:
drawFocusRingMaskBounds,

00:35:02.310 --> 00:35:07.050
drawFocusRingMask,
and noteFocusRingMaskChanged.

00:35:07.140 --> 00:35:11.170
So let me tell you how those methods
work and how to utilize them.

00:35:11.550 --> 00:35:15.480
The Focus Ring Mask Bounds:
This is where you should return the

00:35:15.560 --> 00:35:17.840
enclosing shape for your focus ring.

00:35:17.910 --> 00:35:21.130
And in general, 99% of the time,
it's just your bounds for your view,

00:35:21.230 --> 00:35:25.230
even if you might draw the focus
ring as a subset of your bounds.

00:35:25.410 --> 00:35:28.460
This is only called in your view
if it is the first responder,

00:35:28.530 --> 00:35:30.590
so you don't have to worry about
checking to see if your view

00:35:30.670 --> 00:35:31.950
is the first responder anymore.

00:35:32.030 --> 00:35:35.490
We'll automatically do
it only when you are.

00:35:35.660 --> 00:35:39.060
If you don't want to have the focus ring,
even though you are the first responder,

00:35:39.200 --> 00:35:42.350
just return an empty rect,
and we won't draw the focus ring

00:35:42.360 --> 00:35:44.460
or call you back to draw it at all.

00:35:45.720 --> 00:35:49.590
So inside a Draw Focus Ring mask,
you'll override and implement this

00:35:49.660 --> 00:35:52.030
method to actually draw your focus ring.

00:35:52.150 --> 00:35:55.460
So if you have some crazy shape,
like a Bezier path that you create,

00:35:55.550 --> 00:35:59.290
you can go ahead and fill that shape and
the focus ring will appear around it.

00:35:59.410 --> 00:36:02.730
You could also do things like
I showed before where you just

00:36:02.730 --> 00:36:04.620
fill the bounds of your view.

00:36:04.730 --> 00:36:07.090
You don't have to set any
focus ring styles or anything.

00:36:07.110 --> 00:36:09.460
It's automatically set
up for you correctly.

00:36:09.560 --> 00:36:12.340
All you need to draw here is
your area that you want the

00:36:12.340 --> 00:36:14.130
focus ring to appear around.

00:36:15.340 --> 00:36:17.700
Now, what if your focus ring
changes inside of you?

00:36:17.700 --> 00:36:19.060
What do you need to do?

00:36:19.090 --> 00:36:21.800
You need to let AppKit know
that that area changed.

00:36:21.920 --> 00:36:26.040
And the way you let it know is by
calling NoteFocusRingMaskChanged.

00:36:26.070 --> 00:36:30.290
AppKit will then invalidate the focus
ring and call you back to draw it again,

00:36:30.310 --> 00:36:32.250
if you are the first responder.

00:36:33.220 --> 00:36:35.160
So how does this work
when it's layer-backed,

00:36:35.160 --> 00:36:36.440
and why is this better?

00:36:36.540 --> 00:36:39.990
Well, now that we have the focus ring
drawing separate from the view drawing,

00:36:40.070 --> 00:36:43.360
we can draw the focus ring into
a separate layer from where

00:36:43.360 --> 00:36:46.740
your actual view is and just
composite the two together.

00:36:46.800 --> 00:36:51.820
So the focus ring will be placed on top
of your view when you're layer-backed.

00:36:53.890 --> 00:36:54.470
So that was great.

00:36:54.590 --> 00:36:57.880
That's dealing with how to
fix and solve focus rings when

00:36:57.880 --> 00:36:59.840
you have a layer-backed view.

00:36:59.910 --> 00:37:03.900
The other thing that's important to
mention is that inside of AppKit,

00:37:03.900 --> 00:37:07.240
we updated AppKit to properly
use this API in Mountain Lion,

00:37:07.240 --> 00:37:11.520
so all focus rings for all our standard
controls should draw correctly.

00:37:11.640 --> 00:37:18.120
So let's talk about some more details,
tips and tricks for layer-backed views.

00:37:19.360 --> 00:37:23.340
So, when you have a layer-backed
and a layer-hosted view,

00:37:23.440 --> 00:37:26.340
what properties do we
manage inside of AppKit?

00:37:26.410 --> 00:37:29.700
There's quite a few properties that
we implicitly manage that you probably

00:37:29.700 --> 00:37:31.640
don't want to change explicitly.

00:37:31.730 --> 00:37:36.500
And I'm going to quickly tell you them:
geometry-flipped, bounds, frame.

00:37:36.570 --> 00:37:38.270
And if you're familiar
with Core Animation,

00:37:38.460 --> 00:37:41.450
frame is really an implied
property that's created from the

00:37:41.450 --> 00:37:44.450
position and bounds of a layer.

00:37:44.810 --> 00:37:47.970
The anchor point, transform, shadow,
meaning all the shadow

00:37:47.980 --> 00:37:51.180
properties like the color,
offset, opacity, and radius.

00:37:51.260 --> 00:37:55.330
The hidden property, the filters,
and the compositing filter.

00:37:55.430 --> 00:37:58.470
All those properties we have
always controlled in AppKit,

00:37:58.620 --> 00:38:02.470
but new to Mountain Lion is the fact
that we control geometry-flipped.

00:38:02.560 --> 00:38:05.230
We've always recommended you
to not actually change it,

00:38:05.280 --> 00:38:08.380
but if you do change it and
you're linking on Mountain Lion,

00:38:08.380 --> 00:38:10.710
you're going to have some problems.

00:38:11.560 --> 00:38:15.850
So, prior to Mountain Lion,
layer coordinates were not

00:38:15.850 --> 00:38:17.750
equal to view coordinates.

00:38:17.820 --> 00:38:20.750
And AppKit would try and control
the position of a layer by

00:38:20.790 --> 00:38:22.960
changing the anchor point.

00:38:23.060 --> 00:38:26.000
So depending on if your view
said "yes" to being isFlipped,

00:38:26.080 --> 00:38:30.920
the anchor point might be or .
And for you to convert from one

00:38:30.920 --> 00:38:35.200
coordinate system to the other,
you had to use convertPointToLayer

00:38:35.200 --> 00:38:38.360
or convertPointFromLayer
to go back and forth.

00:38:38.420 --> 00:38:40.380
In our implementation,
AppKit would look at the

00:38:40.380 --> 00:38:44.380
isFlipped property and do some
math and coordinate transforms

00:38:44.460 --> 00:38:46.790
to get everything to be correct.

00:38:46.980 --> 00:38:49.020
We didn't recommend that you
would change the geometry flip

00:38:49.130 --> 00:38:51.360
property back for Mountain Lion,
but you could,

00:38:51.420 --> 00:38:54.510
and you could kind of get away with it.

00:38:55.950 --> 00:38:59.610
Now, in Mountain Lion and above,
we made it so layer coordinates are

00:38:59.670 --> 00:39:04.430
exactly equal to view coordinates.

00:39:06.310 --> 00:39:09.970
This helps a lot with actually
creating and placing views and layers

00:39:10.070 --> 00:39:12.260
and makes things a lot simpler.

00:39:12.390 --> 00:39:14.300
AppKit no longer changes
the anchor point.

00:39:14.520 --> 00:39:19.320
It's going to always be at . And the
way it's going to make this work is by

00:39:19.320 --> 00:39:21.150
managing this geometry flip property.

00:39:21.350 --> 00:39:23.060
You don't have to do
anything to get this.

00:39:23.120 --> 00:39:26.670
It just works when you
link on Mountain Lion.

00:39:26.860 --> 00:39:30.450
But it's important to understand
how Geometry Flip works because it

00:39:30.450 --> 00:39:35.880
might affect your application if you
were expecting it to not be changed.

00:39:36.200 --> 00:39:39.600
So this is just a regular
CA layer that I have showing here.

00:39:39.640 --> 00:39:42.600
And Geometry Flipped is
set to "no," the default,

00:39:42.670 --> 00:39:45.550
and the anchor point is set to
"00," and we're at the bottom

00:39:45.550 --> 00:39:48.700
left there of that view-- or,
sorry, layer.

00:39:49.250 --> 00:39:51.820
If the only thing you
change is geometry flipped,

00:39:51.850 --> 00:39:54.960
your coordinate system for your
view is going to-- or sorry,

00:39:55.010 --> 00:39:58.700
your layer is going to change and flip,
but also all your sub-layers

00:39:58.700 --> 00:40:01.040
are going to also flip too.

00:40:01.110 --> 00:40:04.960
Now, that might cause trouble
for inside of AppKit.

00:40:05.050 --> 00:40:08.110
So it looks like-- let's see how
we actually solve this inside

00:40:08.110 --> 00:40:11.390
AppKit by managing geometry flipped
so that your view coordinates are

00:40:11.390 --> 00:40:13.770
equal to your layer coordinates.

00:40:14.170 --> 00:40:18.390
If a view says yes to isFlipped,
we're going to make the backing

00:40:18.390 --> 00:40:20.800
layer's geometry flip property be yes.

00:40:20.850 --> 00:40:22.970
But if you recall before,
that's going to flip

00:40:22.970 --> 00:40:24.410
all the children layers.

00:40:24.600 --> 00:40:27.970
And so what we're going to do is,
for the children layers,

00:40:28.010 --> 00:40:30.830
dependent on the superlayer
or the superview,

00:40:30.890 --> 00:40:34.260
we're going to flip its geometry
flipped value also in order

00:40:34.260 --> 00:40:35.760
to get things to look right.

00:40:35.990 --> 00:40:37.790
So this is really kind of confusing.

00:40:37.870 --> 00:40:41.380
And the bottom line is, you don't have to
manage geometry flipped,

00:40:41.470 --> 00:40:43.620
and you probably shouldn't change it.

00:40:43.770 --> 00:40:46.180
But if you're linking a
Mountain Lion and your views are

00:40:46.180 --> 00:40:49.350
appearing upside down for some reason,
it might be because of this.

00:40:49.520 --> 00:40:52.050
So that's one reason,
or one thing to look into

00:40:52.050 --> 00:40:53.710
if you're having trouble.

00:40:55.760 --> 00:41:00.630
Now, how to support high resolution
and our new Retina display

00:41:01.020 --> 00:41:03.210
with layer-backed views?

00:41:03.380 --> 00:41:07.020
Well, the best way is just to use
layer-backed views and to not create

00:41:07.020 --> 00:41:09.530
your own CA layer hierarchies.

00:41:09.610 --> 00:41:12.450
By utilizing layer-backed views,
you get all the great things

00:41:12.450 --> 00:41:16.900
that we have in NSView,
like hit testing, tracking, mouse events,

00:41:16.900 --> 00:41:18.600
the responder chain.

00:41:18.680 --> 00:41:22.920
In addition, we automatically do
high resolution support.

00:41:23.040 --> 00:41:26.300
So, if you use an image which
has two representations,

00:41:26.300 --> 00:41:31.200
a low-res and a high-res representation,
and set as your layer's contents,

00:41:31.250 --> 00:41:34.150
we will automatically go ahead and update
things for you on your layer-backed

00:41:34.290 --> 00:41:36.740
view when the resolution changes.

00:41:36.810 --> 00:41:38.960
So, for instance,
you move your view from a

00:41:38.970 --> 00:41:42.800
1x display to a 2x display,
everything will work automatically.

00:41:43.230 --> 00:41:46.780
But if you must use CA layer directly,
we introduced a new

00:41:46.810 --> 00:41:52.260
delegate method called
LayerShouldInheritContentScaleFromWindow.

00:41:52.390 --> 00:41:54.700
And this is in Lion now.

00:41:54.810 --> 00:41:58.850
And what you can do here is you can go
ahead and update your layer's contents

00:41:58.850 --> 00:42:03.330
explicitly for layers that we don't know
about in AppKit to update their contents,

00:42:03.330 --> 00:42:06.200
their content scale properties,
and make it look properly

00:42:06.200 --> 00:42:07.280
for high resolution.

00:42:07.430 --> 00:42:10.930
We have a whole talk about this,
which I'll reference later.

00:42:11.720 --> 00:42:14.520
Now, before I said, well,
don't use draw-rect,

00:42:14.520 --> 00:42:16.830
and we really want you
to use update-layer.

00:42:16.950 --> 00:42:20.380
Well, that's not the case,
and there are still some cases where it's

00:42:20.380 --> 00:42:23.410
really easy or good to use draw-rect.

00:42:23.560 --> 00:42:25.660
For instance,
if you have a view which is small,

00:42:25.940 --> 00:42:27.710
then its layer contents will be small.

00:42:27.840 --> 00:42:33.000
And if that view's frame never changes,
or in particular the size never changes,

00:42:33.270 --> 00:42:34.760
then it doesn't matter
if you use draw-rect,

00:42:34.770 --> 00:42:37.330
because it's never going to
need to stretch the contents,

00:42:37.410 --> 00:42:39.630
and it'll probably always look right.

00:42:39.730 --> 00:42:42.510
And you can just set the layer
contents redraw policy and get

00:42:42.510 --> 00:42:44.460
everything to animate correctly.

00:42:44.550 --> 00:42:47.420
So, if you have a small button
or a small custom view,

00:42:47.420 --> 00:42:49.510
it's still great to use draw-rect.

00:42:49.750 --> 00:42:52.260
In addition, you might want to implement
draw-rect because you want

00:42:52.260 --> 00:42:54.810
to support 10.7 and 10.8.

00:42:54.810 --> 00:42:57.670
So you want to have a layer-backed
application review and you

00:42:57.670 --> 00:43:01.000
want to opt-in to update layer
when you're on Mountain Lion,

00:43:01.070 --> 00:43:07.170
but still use draw-rect when
you aren't on Mountain Lion,

00:43:07.170 --> 00:43:07.170
and so you can implement
both to support both.

00:43:08.330 --> 00:43:10.560
In addition,
in order to actually do printing,

00:43:10.740 --> 00:43:12.480
we still utilize DrawRect.

00:43:12.650 --> 00:43:16.050
So if you have a view that has to print,
then you're going to need

00:43:16.050 --> 00:43:17.150
to implement DrawRect.

00:43:17.250 --> 00:43:19.590
And of course,
all the standard AppKit controls are

00:43:19.730 --> 00:43:23.320
going to still implement DrawRect,
so all of them will still print properly,

00:43:23.330 --> 00:43:25.800
so it can still print text, images, etc.

00:43:25.800 --> 00:43:27.300
correctly.

00:43:29.860 --> 00:43:36.010
So, for traditional Cocoa drawing,
we had this thing called NSCell.

00:43:36.080 --> 00:43:41.020
And NSCell won't work properly with
layer-backed views if you have a

00:43:41.140 --> 00:43:43.590
control which was dependent on cells.

00:43:43.970 --> 00:43:46.660
So, for instance,
if you have a cell-based table view,

00:43:46.700 --> 00:43:50.660
all those individual cells will
not get an individual layer when

00:43:50.660 --> 00:43:52.540
you're making the view layer-backed.

00:43:52.590 --> 00:43:55.260
The whole table will become layer-backed.

00:43:55.280 --> 00:43:58.860
So, what we're encouraging you
to do is for efficiency,

00:43:58.890 --> 00:44:01.220
you should be using a
view-based table view.

00:44:01.400 --> 00:44:03.140
And if you aren't familiar
with view-based table views,

00:44:03.210 --> 00:44:06.880
I highly recommend looking at
the talk that I gave last year

00:44:06.940 --> 00:44:12.100
on introduction from basics to
advance on view-based table views.

00:44:12.170 --> 00:44:15.530
When you do have a view-based table view,
all those individual views there will

00:44:15.530 --> 00:44:19.420
each individually be layer-backed,
and you can do fast, smooth animations.

00:44:19.490 --> 00:44:24.190
So, the demo that I gave at the start was
all using a view-based table view.

00:44:26.550 --> 00:44:30.490
In addition, some other legacy cell-based
controls are NSMatrix,

00:44:30.560 --> 00:44:33.250
so we recommend not using NSMatrix.

00:44:33.300 --> 00:44:35.470
Instead, just use regular views.

00:44:35.530 --> 00:44:38.160
It should be really simple
to create an array of views.

00:44:38.290 --> 00:44:41.810
The nice thing about Matrix is radio
buttons would all work together.

00:44:41.950 --> 00:44:44.780
If you check one radio button,
it will uncheck the others.

00:44:44.910 --> 00:44:46.420
Take a look at the AppKit release notes.

00:44:46.520 --> 00:44:49.580
We have a way of now having the
radio buttons interact together

00:44:49.580 --> 00:44:55.000
automatically when you're using a regular
NSButton without utilizing NSMatrix.

00:44:55.090 --> 00:44:57.460
You could also consider
using Collection View,

00:44:57.460 --> 00:45:00.280
which is another way of getting
a group of views together

00:45:00.280 --> 00:45:01.990
that's managed automatically.

00:45:02.120 --> 00:45:04.410
If you're using NSForm,
which was also cell-based,

00:45:04.450 --> 00:45:05.990
instead just use text fields.

00:45:06.040 --> 00:45:09.370
You can have a label and a
text field really easily.

00:45:10.880 --> 00:45:14.800
Now, how do you deal with subclassing
standard AppKit controls?

00:45:14.840 --> 00:45:19.040
So most of our AppKit controls now
implement "WantsUpdate" layer and

00:45:19.040 --> 00:45:23.050
say "Yes." So we took the time in
AppKit and Mountain Lion to adopt all

00:45:23.050 --> 00:45:26.910
this technology so all our standard
controls use a small image and just

00:45:27.040 --> 00:45:29.110
properly stretch the layer contents.

00:45:29.160 --> 00:45:33.660
This is great for memory efficiency,
allows fast, smooth animations.

00:45:33.690 --> 00:45:37.490
And how do you actually go ahead
and take advantage in subclassing

00:45:37.490 --> 00:45:40.110
and customize our custom views?

00:45:40.820 --> 00:45:44.520
Well, what we need to do is,
if you override anything

00:45:44.620 --> 00:45:48.700
that was drawing,
such you override draw-rect,

00:45:48.700 --> 00:45:52.000
cell draw with frame,
draw interior with frame and view,

00:45:52.000 --> 00:45:54.650
we're going to have to say
no to wants update layer for

00:45:54.650 --> 00:45:56.430
that standard AppKit control.

00:45:56.610 --> 00:45:58.810
And the reason why is we don't
know what you're going to do

00:45:58.810 --> 00:46:02.140
in your drawing implementation,
so we can't go ahead and try

00:46:02.140 --> 00:46:04.370
and create it with a subview.

00:46:05.650 --> 00:46:09.400
So what you want to do if you want
to extend a standard AppKit control

00:46:09.760 --> 00:46:14.360
is you're going to have to override
wants update layer and say yes.

00:46:14.800 --> 00:46:19.190
You can add additional subviews to
represent your user interface inside

00:46:19.190 --> 00:46:24.000
of layout that adds whatever type of
things you want to our custom views.

00:46:24.120 --> 00:46:27.910
You can also use our
standard position methods.

00:46:28.110 --> 00:46:34.230
So if you have a cell-based control,
you could subclass in a cell,

00:46:34.410 --> 00:46:36.760
don't override the draw methods,
but do override things

00:46:36.760 --> 00:46:40.000
like title-rec for bounds,
image-rec for bounds,

00:46:40.120 --> 00:46:43.780
and those will create or control
the position of the actual image

00:46:43.780 --> 00:46:48.680
and title view that we actually add
to our custom controls ourselves.

00:46:51.020 --> 00:46:54.430
So, in conclusion,
what's the most important

00:46:54.430 --> 00:46:56.240
thing to take away from this?

00:46:56.330 --> 00:46:59.600
We want you to use the
Layer Contents Redraw policy of

00:46:59.620 --> 00:47:03.800
NSViewLayerContentsRedrawOnSetNeedsDis
play.

00:47:03.890 --> 00:47:07.770
Again, it's not the default value,
so you must explicitly set it

00:47:07.770 --> 00:47:09.710
when you have a custom view.

00:47:09.800 --> 00:47:12.860
We want you to use
subviews whenever possible,

00:47:12.860 --> 00:47:15.970
so recomposite your view using
multiple subviews for efficiency.

00:47:16.290 --> 00:47:19.980
Use the new Mountain Lion API,
WantsUpdateLayer and UpdateLayer

00:47:20.110 --> 00:47:24.140
to directly set the layer contents
and content center property.

00:47:24.220 --> 00:47:27.930
Share your image contents among
multiple layers or multiple views

00:47:28.240 --> 00:47:30.460
that have the same UI representation.

00:47:30.690 --> 00:47:34.250
Use NSTextField to automatically
get proper font smoothing.

00:47:34.420 --> 00:47:37.840
Avoid manual text drawing if possible.

00:47:37.900 --> 00:47:40.910
Use the AnimatorProxy
to start animations.

00:47:41.040 --> 00:47:47.330
Use the NewProperty on the
AnimationContext to allow implicit

00:47:47.370 --> 00:47:51.500
animations to be explicitly started.

00:47:51.600 --> 00:47:57.730
Use the LionFocusRingDrawing API to get
focus rings to draw and look properly.

00:47:59.170 --> 00:48:03.800
So for more information, contact Jake,
our UI Frameworks evangelist,

00:48:03.850 --> 00:48:05.890
and his email is up there.

00:48:06.000 --> 00:48:06.880
Documentation.

00:48:07.140 --> 00:48:10.130
I highly recommend reading through the
Core Animation Programming Guide to

00:48:10.150 --> 00:48:12.060
get familiar with how that works.

00:48:12.120 --> 00:48:14.850
You can ask questions on
the Apple Developer Forums.

00:48:14.910 --> 00:48:18.800
I'm frequently on there and
can sometimes give you a hand.

00:48:19.940 --> 00:48:22.710
Some related sessions:
Advanced Tips and Tricks

00:48:22.710 --> 00:48:26.140
for High Resolution OSX and
Mission Friday at 10:15.

00:48:26.400 --> 00:48:29.300
Go check that out.

00:48:29.330 --> 00:48:30.140
That's it.

00:48:30.180 --> 00:48:32.210
Thank you very much.
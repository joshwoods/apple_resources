WEBVTT

00:00:10.080 --> 00:00:15.840
We're going to deal with this
sort of big topic that is building

00:00:15.840 --> 00:00:18.160
document-based applications,
and in particular,

00:00:18.160 --> 00:00:22.460
building document-based applications
that are going to live in iCloud.

00:00:22.460 --> 00:00:25.310
Because if you're going to write a
great document-based application on iOS,

00:00:25.310 --> 00:00:26.500
you're going to use iCloud.

00:00:26.500 --> 00:00:30.190
So it's a big topic,
document-based applications,

00:00:30.320 --> 00:00:32.520
and in particular in iCloud.

00:00:32.520 --> 00:00:35.570
But we're going to try to hit on
some key points that will help

00:00:35.580 --> 00:00:39.370
you write better document-based
applications using UIDoctument.

00:00:40.000 --> 00:00:45.710
So how we're going to do that is walk
through actually building an app.

00:00:45.860 --> 00:00:49.840
We're going to walk through some
of the key steps today in building

00:00:50.180 --> 00:00:52.390
a working iCloud application.

00:00:52.400 --> 00:00:56.110
And the main areas we're going
to focus on in building that

00:00:56.110 --> 00:00:59.790
app are application design,
things we can do up front to

00:01:00.220 --> 00:01:04.460
ensure that our application is
well-tailored for working in iCloud.

00:01:04.460 --> 00:01:07.280
We're going to talk
about document design,

00:01:07.280 --> 00:01:09.980
which is the thinking that we have.

00:01:09.980 --> 00:01:13.280
We're going to talk about the
things that we need to put in to

00:01:13.640 --> 00:01:17.300
making sure we have a well-tailored
format for writing our data to

00:01:17.300 --> 00:01:19.760
storage and syncing up to the cloud.

00:01:19.760 --> 00:01:23.100
And lastly,
we'll talk about finishing touches,

00:01:23.100 --> 00:01:26.900
things to make sure we have
taken care of in our application

00:01:26.900 --> 00:01:28.950
before we ship it to users.

00:01:28.960 --> 00:01:32.590
So I'd like to start out today by
actually showing you the app that

00:01:32.590 --> 00:01:34.540
we're going to be working with.

00:01:34.640 --> 00:01:39.680
And this is version 2.0 of the CloudNodes
app that some of you may have seen.

00:01:39.980 --> 00:01:41.480
In last year's demo.

00:01:41.480 --> 00:01:44.370
Here's my application, CloudNodes.

00:01:48.300 --> 00:01:51.520
And it wants to know if
I want to use iCloud.

00:01:51.520 --> 00:01:52.790
I, in fact, do.

00:01:52.920 --> 00:01:57.740
And this application presents me
with a list of note documents.

00:01:57.740 --> 00:01:59.350
I have a couple.

00:02:11.650 --> 00:02:11.650
And each note document has -- contains
within it several note records.

00:02:11.650 --> 00:02:11.650
So a note document is a list of
notes where each note has a --

00:02:12.270 --> 00:02:15.640
has a picture associated
with it and some text.

00:02:15.640 --> 00:02:19.990
In this app, I can create new documents.

00:02:19.990 --> 00:02:23.330
I can make some stage notes for myself.

00:02:24.790 --> 00:02:29.040
You know, something like, you know,
talk loudly.

00:02:29.040 --> 00:02:32.560
I have a microphone for that, thankfully.

00:02:32.560 --> 00:02:35.110
And, you know, enunciate.

00:03:00.350 --> 00:03:00.350
And that's the kind of
thing that this app does.

00:03:00.350 --> 00:03:00.350
I can go back, close it, save it,
reopen it, my data's there.

00:03:00.350 --> 00:03:00.350
Pretty simple application,
document-based.

00:03:00.350 --> 00:03:00.350
And we're going to spend the
rest of the talk talking about

00:03:00.350 --> 00:03:00.350
the main -- the key pieces going
into building an app like this.

00:03:00.350 --> 00:03:00.350
So that's what we can look forward to.

00:03:00.350 --> 00:03:00.350
First step in this is application design.

00:03:00.780 --> 00:03:05.780
We want to determine what are the key
steps that we want to take care of up

00:03:05.780 --> 00:03:10.060
front when we're first building our
application to ensure that we're in

00:03:10.110 --> 00:03:13.260
the best place to work with iCloud.

00:03:13.710 --> 00:03:17.140
And the first step in this
is deciding where are we

00:03:17.140 --> 00:03:18.060
going to store our documents.

00:03:18.100 --> 00:03:21.520
This is a very key question if we're
going to be a document-based application.

00:03:21.520 --> 00:03:23.160
Where do our documents live?

00:03:23.160 --> 00:03:27.680
And our basic choices are files
are going to live locally or

00:03:27.680 --> 00:03:28.810
they're going to live in the cloud.

00:03:28.820 --> 00:03:34.170
And the message that I really want
you to take away from this talk is

00:03:34.180 --> 00:03:37.300
let your users make this decision.

00:03:37.340 --> 00:03:41.580
Documents are either stored locally
or they're stored in the cloud.

00:03:41.810 --> 00:03:44.220
And we want the decision when
we ask the user to make it

00:03:44.220 --> 00:03:45.590
to be as easy as it can be.

00:03:45.600 --> 00:03:47.750
So we want to ask them once,
like the first time that

00:03:47.750 --> 00:03:49.240
they launch the application.

00:03:49.240 --> 00:03:52.950
And when they decide,
it's completely all or none.

00:03:53.000 --> 00:03:55.640
They say, yes, I want to use iCloud.

00:03:55.640 --> 00:03:59.270
Then you're going to store all of
their documents in the cloud from that

00:03:59.270 --> 00:04:00.880
point on and not even ask them again.

00:04:00.880 --> 00:04:05.270
One of the things that this implies
is we don't want to necessarily

00:04:05.280 --> 00:04:08.960
think about not only storing some
in the cloud and some locally,

00:04:08.960 --> 00:04:13.230
but also let's not worry
about... trying to sync,

00:04:13.540 --> 00:04:17.440
having mirrored versions of our
documents locally at the same time

00:04:17.440 --> 00:04:18.400
that we're putting in the cloud.

00:04:18.480 --> 00:04:21.880
It's a very simple user
experience to understand.

00:04:21.920 --> 00:04:24.980
We're just going to put everything
in the cloud or everything locally if

00:04:25.080 --> 00:04:30.660
that's what they choose and not try to
maintain local versus cloud versions.

00:04:30.660 --> 00:04:32.900
If they sign out of iCloud,
they won't be able to

00:04:33.080 --> 00:04:34.590
access their data anymore.

00:04:34.760 --> 00:04:35.320
But that's fine.

00:04:35.320 --> 00:04:38.030
They'll be able to sign back in and
access their data if they so choose.

00:04:38.080 --> 00:04:38.880
They can understand that.

00:04:38.960 --> 00:04:41.080
So we want to have something
that looks like this.

00:04:41.150 --> 00:04:41.710
On the first time.

00:04:41.720 --> 00:04:43.580
They launch their application.

00:04:43.720 --> 00:04:47.320
You don't need this exact UI,
but this is the rough

00:04:47.320 --> 00:04:50.450
idea of asking your user,
hey, do you want to use iCloud?

00:04:50.480 --> 00:04:52.480
They decide yes or no.

00:04:52.480 --> 00:04:54.200
You don't have to ask them again.

00:04:54.360 --> 00:04:57.830
After you know what you're going to do,
and we're going to assume that what

00:04:57.830 --> 00:05:00.940
you're going to do is use iCloud
for the purposes of this talk,

00:05:00.940 --> 00:05:05.710
let's talk about how you write
sort of the bootstrapping

00:05:05.710 --> 00:05:10.020
code in your application,
the stuff that you do up front so that

00:05:10.020 --> 00:05:12.500
you're prepared to access iCloud Storage.

00:05:12.500 --> 00:05:15.410
And many of you understand
that as accessing URL for

00:05:15.410 --> 00:05:17.580
Ubiquiti Container Identifier.

00:05:17.580 --> 00:05:22.200
So this is work we're going to do
in Application Did Finish Launching.

00:05:22.450 --> 00:05:26.230
Right when your application gets started,
we're going to call a new

00:05:26.230 --> 00:05:29.400
API that we introduced in iOS 6.

00:05:29.400 --> 00:05:32.560
And this is NSFileManager
Ubiquiti Identity Token.

00:05:32.580 --> 00:05:37.850
And the reason we introduced this
API is because the URL for Ubiquiti

00:05:37.870 --> 00:05:42.590
Container Identifier can take
up to a few seconds to complete.

00:05:42.600 --> 00:05:43.990
Many of you have run into this problem.

00:05:44.000 --> 00:05:47.550
And it's not something that's
safe to call on the main thread.

00:05:47.580 --> 00:05:51.700
And it doesn't guarantee a
quick answer to the question of,

00:05:51.860 --> 00:05:52.340
is iCloud?

00:05:52.360 --> 00:05:57.420
So this is a method you can call safely
in your Application Did Finish Launching

00:05:57.420 --> 00:06:01.840
method that if it returns non-nil,
that tells you iCloud is in

00:06:02.050 --> 00:06:03.690
fact enabled on this device.

00:06:03.700 --> 00:06:06.180
So you call this right away in
Application Did Finish Launching

00:06:06.180 --> 00:06:07.480
to know if iCloud is enabled.

00:06:07.480 --> 00:06:11.010
After you've determined
whether it is enabled,

00:06:11.020 --> 00:06:14.860
you register for another
bit of new API in iOS 6.

00:06:14.860 --> 00:06:17.250
A notification,
NS Ubiquiti Identity Token

00:06:17.250 --> 00:06:20.100
did change notification,
that tells you whether the

00:06:20.130 --> 00:06:22.100
aforementioned token changed.

00:06:22.360 --> 00:06:24.350
And it tells you when it changed, rather.

00:06:24.400 --> 00:06:27.420
So if you launch your application
and the user signed in,

00:06:27.510 --> 00:06:29.400
but later they sign out,
you'll get a notification

00:06:29.400 --> 00:06:30.360
that tells you that.

00:06:30.550 --> 00:06:34.560
Or alternatively,
if your application launches,

00:06:34.560 --> 00:06:39.320
but the user hasn't set
up an iCloud account yet,

00:06:39.320 --> 00:06:42.370
if they sign in later in the
running of your application,

00:06:42.460 --> 00:06:44.020
you'll get a notification so
you know that they signed in.

00:06:44.020 --> 00:06:45.870
And then maybe you can deal
with iCloud at that time.

00:06:46.020 --> 00:06:49.990
So let's go ahead and
assume iCloud is enabled.

00:06:50.290 --> 00:06:52.020
The user has an account.

00:06:52.520 --> 00:06:56.360
Now we have to access URL for
Ubiquiti Container Identifier.

00:06:56.360 --> 00:06:59.550
This is where we're going to
get the actual location in

00:06:59.680 --> 00:07:01.720
storage where we store our data.

00:07:13.110 --> 00:07:13.110
And as I mentioned,
since I can take up to

00:07:13.110 --> 00:07:13.110
a few seconds to launch,
it's only safe to call this

00:07:13.110 --> 00:07:13.110
method on a background queue.

00:07:13.110 --> 00:07:13.110
We don't want to call it
on the main thread lest we

00:07:13.110 --> 00:07:13.110
potentially lock up the UI.

00:07:14.850 --> 00:07:19.990
So what makes this sort of interesting
is it might take up to a few seconds,

00:07:20.040 --> 00:07:21.790
but it also might be fast.

00:07:21.940 --> 00:07:22.940
We don't actually know.

00:07:22.950 --> 00:07:27.220
This is sort of undefined from the
application's perspective whether it

00:07:27.460 --> 00:07:29.540
will be really fast or a little bit slow.

00:07:47.290 --> 00:07:47.290
And so we have to do a little
extra work to accommodate for

00:07:47.290 --> 00:07:47.290
this sort of known unknown in
that if it does take a long time,

00:07:47.290 --> 00:07:47.290
we want to put up some UI so the
user knows what's going on because

00:07:47.290 --> 00:07:47.290
we're not going to allow interaction
with our application until we have

00:07:47.290 --> 00:07:47.290
that cloud storage identifier.

00:07:47.840 --> 00:07:50.920
And so what we do is we
start some kind of timer.

00:07:50.960 --> 00:07:55.850
And we're looking to see how long
it takes to return from this method.

00:07:55.940 --> 00:07:58.020
If it takes some
non-trivial amount of time,

00:07:58.020 --> 00:08:00.310
say 150 milliseconds, we hit a timeout.

00:08:00.450 --> 00:08:02.870
And we say, OK,
it's taking a non-trivial amount of time.

00:08:03.150 --> 00:08:05.550
We want to display some
UI to the user so that they,

00:08:05.550 --> 00:08:08.070
in fact, know what's going on.

00:08:08.360 --> 00:08:11.130
The reason we have this timer is
because if it does return quickly,

00:08:11.230 --> 00:08:13.280
we don't want to flash
any UI on the screen.

00:08:13.280 --> 00:08:15.890
That'll just be distracting.

00:08:16.130 --> 00:08:19.400
But if it, in fact, does return quickly,
we don't need any of this.

00:08:19.440 --> 00:08:20.530
We're gone.

00:08:20.540 --> 00:08:22.820
Don't flash any UI to the user.

00:08:22.840 --> 00:08:24.840
And we can move on with life.

00:08:24.840 --> 00:08:26.420
We have our URL.

00:08:26.630 --> 00:08:28.470
And we can use it.

00:08:28.610 --> 00:08:31.720
So with that,
I'd like to show you actual code

00:08:31.720 --> 00:08:35.540
that we will use in Cloud Notes to
bootstrap our application.

00:08:35.660 --> 00:08:39.120
So this is Cloud Notes 2.0.

00:08:39.410 --> 00:08:42.770
And you'll notice on the
left side of the screen,

00:08:42.770 --> 00:08:45.060
we've got our source files.

00:08:45.260 --> 00:08:50.840
And I just want to give you a quick
rundown to begin of what you see here.

00:08:50.910 --> 00:08:52.550
We have an application delegate.

00:08:52.560 --> 00:08:53.310
We're going to need that.

00:08:53.340 --> 00:08:55.480
We're going to handle
application launching there.

00:08:55.480 --> 00:08:56.520
We have a note document.

00:08:56.680 --> 00:09:02.220
That's our UI document subclass handling
our reading and writing of data.

00:09:02.240 --> 00:09:07.630
I wrote this extra little class
here that I call Cloud Manager that,

00:09:07.630 --> 00:09:12.770
from an application design perspective,
I did this so that I could

00:09:12.770 --> 00:09:17.080
just have sort of a pulled-out
abstraction of the non- UI-related

00:09:17.080 --> 00:09:19.940
bits of interfacing with iCloud.

00:09:20.270 --> 00:09:23.480
This is actually where the code
lives that goes and accesses the

00:09:23.480 --> 00:09:26.400
URL for Ubiquity Container Identifier.

00:09:26.420 --> 00:09:28.700
And then it will store
that value within itself.

00:09:28.700 --> 00:09:30.110
It's a singleton class.

00:09:30.290 --> 00:09:32.690
So that it is globally accessible.

00:09:32.700 --> 00:09:37.180
And any other pieces of my application
will be able to use that object to

00:09:37.180 --> 00:09:42.160
determine the URL for Ubiquity Container
Identifier because it will just store it.

00:09:42.190 --> 00:09:45.990
And other bits of my application can
access it directly and synchronize.

00:09:46.020 --> 00:09:50.580
So I'll just show you the API actually
that I've put here in my Cloud Manager.

00:09:50.580 --> 00:09:54.260
It has a property to tell
me if the cloud is enabled.

00:09:54.260 --> 00:09:57.570
And the semantic of that is, one,
I determined that iCloud is

00:09:57.630 --> 00:10:01.600
enabled on this device and the
user selected to use iCloud.

00:10:01.600 --> 00:10:04.420
And if both of those are true,
this will be yes on my

00:10:04.420 --> 00:10:06.000
little singleton class.

00:10:06.000 --> 00:10:09.560
And then it has a property that tells
me where the data directory is and the

00:10:09.560 --> 00:10:16.000
documents directory as derived from the
URL for Ubiquity Container Identifier.

00:10:16.000 --> 00:10:18.310
And for those of you
who maybe don't know,

00:10:18.330 --> 00:10:21.490
the distinction between a documents
directory and data directory is

00:10:21.490 --> 00:10:25.250
documents is where user visible
documents live and data is where

00:10:25.630 --> 00:10:28.880
your application metadata lives.

00:10:48.280 --> 00:10:48.420
And to make this sort of extra
convenient for my application,

00:10:48.420 --> 00:10:48.420
this Cloud Manager will automatically
make the data directory and the documents

00:10:48.420 --> 00:10:48.420
directory be the right thing whether
I'm using iCloud or using local storage.

00:10:48.420 --> 00:10:48.420
So it will return a local
URL if I'm using local storage.

00:10:48.420 --> 00:10:48.420
And it makes the architecture of
the rest of my application easier.

00:10:49.170 --> 00:10:51.280
And then I have a root view controller,
which is the thing that

00:10:51.280 --> 00:10:52.600
shows my document list.

00:10:52.740 --> 00:10:57.280
So right now we want to look at what we
do in application did finish launching.

00:10:58.060 --> 00:11:00.360
There's a few steps we're
going to walk through.

00:11:00.440 --> 00:11:03.860
And actually, you know,
before I run this,

00:11:03.880 --> 00:11:08.750
I'm going to go ahead and just
run the application on my device.

00:11:09.100 --> 00:11:17.840
And we'll see where we are before
implementing this iCloud code.

00:11:17.850 --> 00:11:19.100
Launch Buddy.

00:11:19.100 --> 00:11:20.900
There we go.

00:11:21.540 --> 00:11:25.740
Okay, so in this state,
I haven't implemented the iCloud stuff,

00:11:25.820 --> 00:11:28.600
so my application is
just showing local notes.

00:11:28.610 --> 00:11:30.730
I can -- even though
I'm not using iCloud,

00:11:30.780 --> 00:11:32.400
I can add something local.

00:11:32.490 --> 00:11:38.520
So, you know, I can add a local file
here in the local zone.

00:11:55.180 --> 00:11:55.180
I forgot to set something up on this app,
so that doesn't work.

00:11:55.180 --> 00:11:55.180
That's a setup problem with my phone.

00:11:55.180 --> 00:11:55.180
Sorry about that.

00:11:55.180 --> 00:11:55.180
But so I'm in just the local state.

00:11:55.490 --> 00:11:59.800
And I'm going to go write
some code to enable iCloud.

00:12:00.040 --> 00:12:07.870
Let me kill that.

00:12:07.870 --> 00:12:07.870
And so let's go.

00:12:09.970 --> 00:12:10.770
Ta-da!

00:12:11.050 --> 00:12:13.290
Back to my machine.

00:12:13.360 --> 00:12:14.240
Good!

00:12:14.590 --> 00:12:16.540
And so let's walk through
the steps of this.

00:12:16.720 --> 00:12:20.800
The first thing I'm going to do is check
what the user's iCloud preference is.

00:12:20.800 --> 00:12:23.990
This is the idea for the very first
time we launch our application,

00:12:23.990 --> 00:12:26.710
we want to know whether the
user is going to use iCloud.

00:12:26.710 --> 00:12:31.850
And it's also called setup if necessary
because we're going to set up our

00:12:31.850 --> 00:12:36.840
iCloud storage if the user is in
fact using iCloud and it's enabled.

00:12:37.780 --> 00:12:38.470
Okay.

00:12:38.580 --> 00:12:42.680
So I'm also going to register
for a couple of notifications.

00:12:42.680 --> 00:12:48.830
And two of these notifications
are ones that I've defined myself.

00:12:48.990 --> 00:12:54.100
They're container will begin fetching
and container fetching did end.

00:12:54.490 --> 00:12:58.890
These are actually defined by my
Cloud Manager with the idea that

00:12:59.240 --> 00:13:02.670
this is how I set up that timer
for the UI we talked about earlier.

00:13:02.910 --> 00:13:07.160
When the Cloud Manager starts fetching
the ubiquitous container identifier URL,

00:13:07.160 --> 00:13:12.500
it sends a will begin
fetching notification.

00:13:12.580 --> 00:13:15.000
My app delegate,
which is responsible for the UI,

00:13:15.000 --> 00:13:16.920
will start a timer.

00:13:16.920 --> 00:13:20.690
And if it does not receive the
fetching did end notification,

00:13:20.690 --> 00:13:24.560
by the time the timer times out,
it will put up UI.

00:13:24.770 --> 00:13:28.200
If it has put up UI,
it uses the did end notification

00:13:28.200 --> 00:13:29.860
to tear down that UI.

00:13:30.860 --> 00:13:35.670
And let's look at the implementation
of this sort of critical method,

00:13:35.750 --> 00:13:37.480
check user iCloud preference.

00:13:37.670 --> 00:13:39.430
And set up.

00:13:40.420 --> 00:13:41.310
All right, great.

00:13:41.590 --> 00:13:44.900
So this is, as I said,
the first thing we end up

00:13:44.900 --> 00:13:49.080
actually doing is asking for
the Ubiquiti Identity Token.

00:13:49.190 --> 00:13:51.780
This is our new bit of API.

00:13:52.150 --> 00:13:55.820
Then we're going to check our
user defaults because we're

00:13:55.820 --> 00:13:59.700
going to use NSUserDefaults to
store the user's preference as to

00:13:59.700 --> 00:14:02.910
whether they use iCloud or not.

00:14:18.070 --> 00:14:18.070
And so I'm asking for a key that
I've just called use iCloud Storage.

00:14:18.070 --> 00:14:18.070
And I'm going to skip over this a
little bit of code later because we're

00:14:18.070 --> 00:14:18.070
going to use it in a subsequent demo.

00:14:18.070 --> 00:14:18.070
But then I check if my --

00:14:21.380 --> 00:14:28.140
If my token is valid,
which means the user

00:14:28.140 --> 00:14:28.140
is signed into iCloud,

00:14:28.400 --> 00:16:21.800
[Transcript missing]

00:16:22.700 --> 00:16:27.660
So the things we're going to talk
about are using file packages here,

00:16:27.660 --> 00:16:34.840
things to avoid storing in your document,
how to have sort of

00:16:34.960 --> 00:16:37.930
forward-thinking design principles,
and we're also going to talk

00:16:38.010 --> 00:16:42.240
about how to design a document
that is able to have previews.

00:16:42.240 --> 00:16:45.000
As you saw when I first
showed the application,

00:16:45.000 --> 00:16:47.320
my document had previews.

00:16:47.660 --> 00:16:50.800
That wasn't true in the last demo,
but we'll get there.

00:16:50.980 --> 00:16:53.600
So first of all, file packages.

00:16:53.670 --> 00:16:57.610
This is really the biggest
thing about document design

00:16:57.640 --> 00:16:59.710
that you want to take away.

00:16:59.920 --> 00:17:04.280
If you're not using file packages today,
then it's something I hope you

00:17:04.290 --> 00:17:08.140
will be thinking strongly about
when you walk out of this talk.

00:17:08.250 --> 00:17:14.640
And what file packages are is a directory
on the file system that is treated

00:17:14.640 --> 00:17:18.000
as a single document to your user.

00:17:18.060 --> 00:17:22.360
And this has some advantages.

00:17:22.530 --> 00:17:24.540
At a very simple level,
it makes it so that you don't

00:17:24.540 --> 00:17:27.410
have to take maybe disparate
parts of the user's data and shove

00:17:27.460 --> 00:17:29.760
them into a single file blob.

00:17:29.800 --> 00:17:33.420
But more than that, it can make your
application perform better,

00:17:33.420 --> 00:17:37.880
because when you change just a
single part of your document,

00:17:38.060 --> 00:17:41.850
if that single part is represented
by one little file inside

00:17:41.850 --> 00:17:45.380
your larger file package,
we only have to write that one

00:17:45.590 --> 00:17:47.740
little file out to the NAND storage.

00:17:47.740 --> 00:17:51.370
And likewise, we only have to upload that
one file into the cloud.

00:17:51.530 --> 00:17:55.920
So we use less network traffic,
and our saving action can be faster.

00:17:56.020 --> 00:17:58.660
So let's talk about how we do that.

00:17:58.680 --> 00:18:01.680
If you have a, you know,
if we started with a note

00:18:01.740 --> 00:18:04.020
document and we think of,
okay, we've got all this content

00:18:04.170 --> 00:18:06.390
in a note document,
and maybe in our first iteration

00:18:06.400 --> 00:18:08.840
of writing our application,
we just took all that content

00:18:08.840 --> 00:18:11.600
and we wrote it out into a file,
and we have a file blob.

00:18:11.600 --> 00:18:13.630
And we're thinking, you know,
I think I can make this better

00:18:14.010 --> 00:18:17.830
by moving the file packages,
but how do I do that?

00:18:17.840 --> 00:18:22.440
Well, the first step is breaking things
out into logical components.

00:18:22.740 --> 00:18:27.840
Since a note document has
several notes associated with it,

00:18:28.200 --> 00:18:53.700
[Transcript missing]

00:19:19.910 --> 00:19:19.910
We can actually go a step further.

00:19:19.910 --> 00:19:19.910
We can think about separating
assets from content,

00:19:19.910 --> 00:19:19.910
which is to say,
if you think about assets

00:19:19.910 --> 00:19:19.910
as things like images,
movies, things that would be treated as

00:19:19.910 --> 00:19:19.910
attachments in your document,
that are separate maybe

00:19:19.910 --> 00:19:19.910
from the core content,
like the text.

00:19:19.910 --> 00:19:19.910
In the case of Cloud Notes,
each note itself has text

00:19:19.910 --> 00:19:19.910
associated with it and an asset,
which is the limits that you see.

00:19:20.200 --> 00:19:32.300
[Transcript missing]

00:19:33.510 --> 00:19:37.540
And when the user edits, say, the text,
we can just save out that file that

00:19:37.540 --> 00:19:39.430
has the text for that one note.

00:19:39.630 --> 00:19:43.110
And we save out one file out of ten,
one little text file.

00:19:43.250 --> 00:19:47.990
And we don't have to spend the time
writing out all of that content,

00:19:48.150 --> 00:19:52.560
nor do we have to spend the time
syncing that content up to the cloud.

00:19:52.720 --> 00:19:57.030
Another thing you can do is
try to separate out things that

00:19:57.030 --> 00:19:59.500
are edited less frequently.

00:20:00.470 --> 00:20:03.250
This also applies to actually things
that are edited quite frequently.

00:20:03.470 --> 00:20:08.710
If you have knowledge about your
application that a particular part

00:20:08.710 --> 00:20:13.250
of the document is rarely edited
or there's a particular part of the

00:20:13.250 --> 00:20:16.880
document that is edited all the time,
those components are candidates

00:20:16.880 --> 00:20:18.600
for moving out into their own file.

00:20:19.800 --> 00:20:23.290
So if you have something that
the user edits constantly and you

00:20:23.320 --> 00:20:27.140
can stick it in a nice separated
component from everything else,

00:20:27.170 --> 00:20:29.000
then when the user makes
those edits all the time,

00:20:29.000 --> 00:20:30.790
you're only just writing
out that little component.

00:20:30.940 --> 00:20:32.610
So it'll help you.

00:20:34.040 --> 00:20:37.860
Now let's think about the actual
code for reading these file packages.

00:20:37.930 --> 00:20:39.990
If you've never actually
done this before,

00:20:40.140 --> 00:20:41.940
maybe you'll find this helpful.

00:20:41.940 --> 00:20:45.720
So this is how you do this
in a UI document world.

00:20:45.840 --> 00:20:48.740
We have our canonical reading
method in UI document,

00:20:48.960 --> 00:20:51.740
which is load from contents of type.

00:20:51.980 --> 00:20:57.880
And when we're using file packages,
that type -- or rather the

00:20:57.880 --> 00:21:01.560
contents will be a NS file wrapper.

00:21:01.670 --> 00:21:04.600
That's what we give you when
you're using a file package.

00:21:04.750 --> 00:21:08.670
And the way to put this into your
model is to have sort of a master file

00:21:08.670 --> 00:21:11.150
wrapper that you keep a reference to.

00:21:11.150 --> 00:21:15.070
It can be like an instance
variable in your document.

00:21:15.580 --> 00:21:17.360
And you just take the contents,
which is a file wrapper

00:21:17.360 --> 00:21:19.550
that we've given you,
and assign that to

00:21:19.550 --> 00:21:21.130
your instance variable.

00:21:21.310 --> 00:21:25.600
So now your model,
which is a master file wrapper,

00:21:25.630 --> 00:21:27.610
is the contents that we've given you.

00:21:27.810 --> 00:21:32.660
You can also use an index file that
is part of your document file wrapper

00:21:33.080 --> 00:21:37.740
that helps you understand what all
everything else is in this document.

00:21:37.890 --> 00:21:42.250
In the case of Cloud Notes, I've got,
you know, some arbitrary number of

00:21:42.250 --> 00:21:43.740
notes inside a note document.

00:21:43.740 --> 00:21:47.770
And I use an index so I can -- that
index will tell me how many notes are

00:21:47.860 --> 00:21:51.610
in there and what their file names are,
how I can access them.

00:21:51.680 --> 00:21:55.340
So you can peer inside the
index to know what you actually

00:21:55.340 --> 00:21:57.140
have in your file package.

00:21:57.140 --> 00:21:59.700
And right away when
you load your contents,

00:21:59.750 --> 00:22:02.540
you just kind of load your
little index into your model.

00:22:02.680 --> 00:22:04.070
So there you've got your model.

00:22:04.080 --> 00:22:06.290
When it comes time to
write out your model,

00:22:06.500 --> 00:22:10.010
the way that that works in UIDoctument
is we always want you to snapshot

00:22:10.210 --> 00:22:12.380
your model and return to us a
snapshot that we can write to disk.

00:22:12.380 --> 00:22:15.060
that we can write to disk.

00:22:38.090 --> 00:22:38.090
So when you're using this sort of
master file wrapper as your model,

00:22:38.090 --> 00:22:38.090
then snapshotting it is really
just a matter of creating another

00:22:38.090 --> 00:22:38.090
NSFileWrapper instance with the
contents of the sub-file wrappers

00:22:38.090 --> 00:22:38.090
of your master file wrapper.

00:22:38.090 --> 00:22:38.090
So that will act as a snapshot
of your data that we can take

00:22:38.090 --> 00:22:38.090
with us and write to storage.

00:22:39.760 --> 00:22:45.270
This is actually where the NSFileWrapper
smarts kick in and optimize the behavior

00:22:45.270 --> 00:22:49.630
for you because NSFileWrapper is smart
enough to notice subfile wrappers

00:22:49.650 --> 00:22:54.070
that haven't changed and it won't
bother writing those out to storage.

00:22:54.300 --> 00:22:56.810
So only the stuff that you've
changed will actually get

00:22:56.810 --> 00:23:01.200
written out at this point,
and that's what makes it fast.

00:23:02.440 --> 00:23:06.230
In between reading and writing,
how you manage your model

00:23:06.520 --> 00:23:10.160
is as changes come in,
you make those changes directly to that

00:23:10.160 --> 00:23:13.540
master file wrapper that we've saved off,
and that's what we're

00:23:13.570 --> 00:23:14.940
treating as our model.

00:23:15.240 --> 00:23:17.490
So if I add a new note...

00:23:17.940 --> 00:23:23.090
I create new file wrappers,
add them inside my master file wrapper,

00:23:23.250 --> 00:23:28.910
and I update that index file,
and then I move on with life.

00:23:29.220 --> 00:23:32.450
And part of the way that
UIDocument is designed is that

00:23:32.550 --> 00:23:34.940
we only save when we're asked to.

00:23:35.010 --> 00:23:39.020
So we will update that file
wrapper that we're containing

00:23:39.020 --> 00:23:42.130
as our master file wrapper,
and then wait for contents

00:23:42.130 --> 00:23:45.430
for type to get called,
which will be invoked when

00:23:45.430 --> 00:23:49.700
autosaving happens or when
the user closes the document.

00:23:49.900 --> 00:24:05.100
[Transcript missing]

00:24:05.630 --> 00:24:09.690
And really what this is going to
be all about is thinking about

00:24:09.740 --> 00:24:13.480
the fact that when you write
version 2.0 of your application,

00:24:13.480 --> 00:24:18.100
you may also write version
2.0 of your file format.

00:24:18.190 --> 00:24:27.630
If you decide that there's extra data
that you want to store in the document,

00:24:27.630 --> 00:24:27.630
or you want to store your
existing data in a different way,

00:24:28.910 --> 00:24:33.870
You want a way that your previous
version of your application can

00:24:34.320 --> 00:24:36.740
deal with this in a graceful manner.

00:24:36.810 --> 00:24:41.010
And the way that we do this
is version your file format.

00:24:41.130 --> 00:24:45.330
This is something that we want you to
write into your document format today

00:24:45.490 --> 00:24:50.510
so that you have a field and if you
call your document format version 1.0,

00:24:50.510 --> 00:24:54.460
you have that field that you
can mark up to 2.0 in a future

00:24:54.550 --> 00:24:56.590
update in your application.

00:24:56.850 --> 00:25:01.260
And this is especially important in
today's world of multiple devices

00:25:01.260 --> 00:25:04.540
because it's likely that you're going
to run into a situation where the

00:25:04.690 --> 00:25:08.930
user doesn't update your application
simultaneously on all their devices.

00:25:09.130 --> 00:25:12.730
So you can very easily run into a
situation where the user is actually

00:25:12.790 --> 00:25:16.850
using different versions of your
application on different devices and

00:25:16.850 --> 00:25:21.340
all of those versions need to be able
to coexist as gracefully as possible.

00:25:21.520 --> 00:25:25.420
So that's what file format
versioning will help you with.

00:25:25.430 --> 00:25:27.290
And you can...

00:25:28.450 --> 00:25:32.460
Make your versioning help you as
much as possible by defining levels

00:25:32.460 --> 00:25:34.920
of interversion compatibility.

00:25:35.130 --> 00:25:39.150
And what that means is
maybe in an ideal world,

00:25:39.500 --> 00:25:42.610
you make a change to the file
format in version 2.0 of your

00:25:42.610 --> 00:25:44.840
application and your document format.

00:25:45.050 --> 00:25:50.730
But you do so in a way that version 1.0
of your application actually is able

00:25:50.730 --> 00:25:53.990
to safely read and write that document.

00:25:54.220 --> 00:25:57.770
So you can actually,
in addition to the format version,

00:25:58.090 --> 00:26:01.820
have a field also contained
in your document format that

00:26:01.920 --> 00:26:04.980
tells previous versions what
they're able to do with that.

00:26:05.010 --> 00:26:08.110
And it might say, hey,
this is actually read-write compatible

00:26:08.790 --> 00:26:11.330
with version 1.0 of my application.

00:26:11.340 --> 00:26:15.280
And one of the ways you can get to
that place is by designing version

00:26:15.630 --> 00:26:20.890
1.0 of your application to ignore
fields that it doesn't understand.

00:26:20.900 --> 00:26:24.450
So if it sees a field in your
document that... that you

00:26:24.450 --> 00:26:27.840
didn't have code for in 1.0,
the version 1.0 of your

00:26:27.890 --> 00:26:31.370
application should probably
just not touch that field.

00:26:31.440 --> 00:26:35.190
That will give you the best chance to
be able to write updates in the future

00:26:35.550 --> 00:26:39.970
that are able to write out new fields
and version 1.0 of your application

00:26:39.980 --> 00:26:43.540
can actually read and write that
document without screwing things up.

00:26:43.540 --> 00:26:44.870
So that's how you can get there.

00:26:45.040 --> 00:26:46.880
In some cases, that won't be possible.

00:26:47.360 --> 00:26:50.790
You'll make changes that...

00:26:50.910 --> 00:26:54.360
that the old version of your application
won't be able to safely write out.

00:26:54.500 --> 00:26:58.680
But you might still be in a place
where it can safely read version

00:26:58.680 --> 00:27:00.210
2.0 of the document format.

00:27:00.230 --> 00:27:04.020
That's another marking you can
make in the file format itself.

00:27:04.120 --> 00:27:08.680
You can say, this is version 2.0,
but version 1.0 of my application

00:27:08.680 --> 00:27:10.340
can safely read this file.

00:27:10.400 --> 00:27:14.520
And so version 1.0 can then do the right
thing in terms of being able to read it,

00:27:14.580 --> 00:27:16.400
display it to the user,
but it won't let the user

00:27:16.400 --> 00:27:17.810
make changes to that document.

00:27:18.480 --> 00:27:19.840
And of course,
in the worst case scenario,

00:27:19.840 --> 00:27:23.390
we make an update to our
document format that is simply

00:27:23.390 --> 00:27:24.710
not compatible between versions.

00:27:24.720 --> 00:27:27.130
And then we mark that in
the file format itself.

00:27:27.290 --> 00:27:29.840
So version 1.0 of our
application comes along,

00:27:29.840 --> 00:27:35.020
reads a file saved by 2.0, says, oh,
this is 2.0 version of the file format,

00:27:35.020 --> 00:27:36.250
I don't understand this.

00:27:36.360 --> 00:27:39.290
And more than that,
I was told by the info

00:27:39.290 --> 00:27:42.710
I find in this document that
I shouldn't try to read this.

00:27:42.720 --> 00:27:46.550
So putting that information,
putting those fields in your document

00:27:46.550 --> 00:27:48.110
format today will help you tomorrow.

00:27:48.440 --> 00:27:52.000
Let's talk about things not
to put in your document,

00:27:52.000 --> 00:27:55.180
since we've just talked about great
things to put in your document.

00:27:56.820 --> 00:27:59.880
One is maybe not so obvious.

00:27:59.880 --> 00:28:05.440
Try not to save scroll positions
in your document format.

00:28:05.990 --> 00:28:09.920
And what I mean by that is like
UI scroll view content offset.

00:28:09.920 --> 00:28:14.320
That's something we want to
avoid saving in our document.

00:28:15.440 --> 00:28:17.190
There's a lot of reasons for this.

00:28:17.440 --> 00:28:21.710
One is very simply like between
different versions of your application,

00:28:21.710 --> 00:28:26.400
different versions of the iOS software,
and different devices perhaps,

00:28:26.900 --> 00:28:31.940
then the scroll view position can change.

00:28:31.940 --> 00:28:36.160
And you wouldn't want to be stuck in
a situation where the user is opening

00:28:36.160 --> 00:28:41.030
a document and you're writing data out
just because they opened the document.

00:28:41.030 --> 00:28:42.440
That's something we want to avoid.

00:28:42.460 --> 00:28:44.820
And so to sort of go along with that.

00:28:45.180 --> 00:28:47.960
We also wouldn't want to save
the timestamp for the last time

00:28:47.960 --> 00:28:50.070
the user opened the document.

00:28:50.500 --> 00:28:55.980
One bad situation that this particular
practice can get us into is imagine that

00:28:55.980 --> 00:29:01.080
we have one instance of our application
running with the document open.

00:29:01.080 --> 00:29:03.890
And we take another
instance of our application,

00:29:03.890 --> 00:29:05.500
open that same document.

00:29:05.500 --> 00:29:08.420
And our new instance says, hey,
I've just opened the application

00:29:08.420 --> 00:29:10.130
or I've opened the document.

00:29:10.130 --> 00:29:12.400
I'm going to write out
a timestamp for this.

00:29:12.400 --> 00:29:17.160
And this already running instance of our
application sees an update because it

00:29:17.160 --> 00:29:19.860
comes across the cloud to this document.

00:29:19.860 --> 00:29:21.310
That we wrote out the timestamp.

00:29:21.350 --> 00:29:23.320
So it reopens the document.

00:29:23.320 --> 00:29:27.490
And because it did that,
then it rewrites a last open timestamp.

00:29:27.490 --> 00:29:31.300
And then that goes to the cloud,
back to the other device.

00:29:31.300 --> 00:29:33.860
And now they start fighting
for who gets to write the

00:29:33.860 --> 00:29:35.400
last open timestamp the most.

00:29:35.400 --> 00:29:37.960
And that's going to chew
up network bandwidth,

00:29:37.960 --> 00:29:39.900
chew up CPU, chew up everything.

00:29:39.900 --> 00:29:41.350
That's a bad situation.

00:29:41.350 --> 00:29:47.290
So the moral of that story is avoid
anything that can result in a sync loop.

00:29:49.250 --> 00:29:53.420
Last thing we want to think about
here is if you have any sensitive data

00:29:53.420 --> 00:29:57.960
that can be stored in your document,
think about this if your application

00:29:58.490 --> 00:30:01.320
has a means of publishing the document.

00:30:01.340 --> 00:30:04.770
This is pretty common that we have
a way to put a document on the web,

00:30:04.770 --> 00:30:07.350
email it to somebody just
with a couple of taps.

00:30:07.440 --> 00:30:12.050
And if your application has
functionality like this,

00:30:12.050 --> 00:30:19.740
and yet you have information in there
like an undo stack or user information,

00:30:19.760 --> 00:30:23.020
any kind of user information that
people wouldn't necessarily want to

00:30:23.020 --> 00:30:26.350
publish along with their document,
then it's a good idea to think

00:30:26.350 --> 00:30:29.820
about having a step that strips
out this kind of information.

00:30:31.830 --> 00:30:39.280
So one feature that people ask how
to do a lot is having a document

00:30:39.280 --> 00:30:44.640
preview that they can access on
their device so that they can have

00:30:44.780 --> 00:30:50.330
something like a document chooser
that shows previews a la iWork without

00:30:50.960 --> 00:30:53.860
having to download all the documents.

00:30:53.870 --> 00:30:58.820
Because the basic story in iCloud is
you have to download a document before

00:30:58.820 --> 00:31:01.050
you get to access any part of it.

00:31:01.750 --> 00:31:05.040
So we're going to talk
about now how to write that.

00:31:05.090 --> 00:31:08.700
So in the beginning,
there was your documents.

00:31:08.720 --> 00:31:11.370
And they were in the documents directory.

00:31:34.990 --> 00:31:34.990
What we want to do to create a preview
is move over to the data directory,

00:31:34.990 --> 00:31:34.990
which is where we put
application metadata,

00:31:34.990 --> 00:31:34.990
and create preview files over here.

00:31:34.990 --> 00:31:34.990
And we want to establish a
one-to-one relationship between

00:31:34.990 --> 00:31:34.990
preview files and documents,
and that relationship is

00:31:34.990 --> 00:31:34.990
mapped to by the document name.

00:31:36.150 --> 00:31:39.660
That way,
just by discovering the document,

00:31:39.690 --> 00:31:43.600
then we can also know the
URL where its preview file is.

00:31:43.640 --> 00:31:46.820
And once we have this,
we know our file list

00:31:46.820 --> 00:31:51.720
from an NSMetadata query,
and then we can access the

00:31:51.720 --> 00:31:56.290
URL for the preview file and
download just that rather than

00:31:56.290 --> 00:31:58.220
downloading the entire document.

00:31:58.370 --> 00:32:01.130
You might have a
200-megabyte document file,

00:32:01.260 --> 00:32:05.160
but you've got a nice thumbnail image
that you include -- that you write out

00:32:05.250 --> 00:32:09.340
as a preview image that's only a few K,
and you can just download that

00:32:09.390 --> 00:32:12.890
and display it to the user in some
kind of document chooser and not

00:32:12.900 --> 00:32:16.700
download the whole document unless
and until they choose to open it.

00:32:16.940 --> 00:32:21.420
So let's look at actual code
that will do that for you.

00:32:21.560 --> 00:32:25.640
So we're going to look in the
UIDoctument low-level writing method,

00:32:25.780 --> 00:32:29.320
write contents and attributes
safely to your URL.

00:32:29.320 --> 00:32:34.600
This is a method on UIDocument that
you can override that is called

00:32:34.670 --> 00:32:39.800
in a background queue UIDocument's
managed file access queue.

00:32:40.150 --> 00:32:42.400
So you're safely in the background.

00:32:42.430 --> 00:32:48.760
And in here, we want to,
using that method,

00:32:48.760 --> 00:32:54.180
write out a preview using the
preview URL that we've established

00:32:54.600 --> 00:32:56.510
and write it to that URL.

00:32:56.700 --> 00:32:57.880
Now there's one thing.

00:32:57.880 --> 00:33:04.970
I had an updated version of this slide,
which I guess I didn't include in here.

00:33:05.130 --> 00:33:08.860
So take note of what I'm about to say,
because it's actually important.

00:33:09.320 --> 00:33:15.870
The part that is highlighted right
now should be in NS file coordination.

00:33:16.020 --> 00:33:18.730
So you want to create an
NS file coordinator instance

00:33:19.120 --> 00:33:20.790
and do coordinate for writing.

00:33:21.040 --> 00:33:24.270
You want to coordinate the write out
of that preview data as you would

00:33:24.640 --> 00:33:26.900
anything that's in iCloud storage.

00:33:27.030 --> 00:33:30.230
So we're working on pushing out
to you actually the code for this

00:33:30.230 --> 00:33:31.900
Cloud Notes app that I'm showing to you.

00:33:31.920 --> 00:33:34.090
And in that code, this is done right.

00:33:34.450 --> 00:33:36.160
So take note of that.

00:33:36.310 --> 00:33:39.190
So I'll show you that now.

00:33:39.640 --> 00:33:45.930
So, if we go over to our note document,
and this is where we're going

00:33:45.930 --> 00:33:47.470
to write out the content,

00:33:47.640 --> 00:33:53.180
I have this little method up here that
returns me a little NSData of preview

00:33:53.180 --> 00:33:57.710
JPEG that I'll be able to use for my
preview data that I'll write out to disk.

00:33:57.750 --> 00:34:03.280
And then the code here is essentially
what we just saw on the slide.

00:34:03.280 --> 00:34:06.730
After I have called super,
which will write the actual

00:34:06.830 --> 00:34:11.960
contents of my document out,
if that has succeeded,

00:34:11.960 --> 00:34:16.460
I will go ahead and create a URL.

00:34:17.120 --> 00:34:22.840
In my case, I simply append .preview to
the end of the document name,

00:34:22.840 --> 00:34:28.080
and I do store it in the data directory
rather than the document directory.

00:34:28.080 --> 00:34:33.620
So if I have note1.note,
that's how I use the .note

00:34:33.620 --> 00:34:37.130
extension for my files,
then the preview file is

00:34:37.130 --> 00:34:40.180
called note1.note.preview.

00:34:40.200 --> 00:34:43.140
And I put that in the data directory.

00:34:43.160 --> 00:34:49.840
And then I actually... I properly create
an NS file coordinator and coordinate

00:34:50.700 --> 00:34:52.990
writing to write the preview file out.

00:34:53.010 --> 00:34:56.440
And that's just taking the data
and writing it to the proper URL.

00:34:56.440 --> 00:35:02.000
The other bit I want to show you is
how to handle this on the other end,

00:35:02.030 --> 00:35:03.500
the receiving device.

00:35:03.500 --> 00:35:06.950
And that's going to be in
my root view controller,

00:35:06.970 --> 00:35:09.340
which has a table view
that shows all my files.

00:35:09.340 --> 00:35:11.960
That's my version of a document chooser.

00:35:11.960 --> 00:35:16.360
I have this very simple
self-wrote index path.

00:35:16.630 --> 00:35:20.290
And I'm going to put the preview
image in the cell's image view,

00:35:20.290 --> 00:35:23.140
but I start out just
by setting it to nil,

00:35:23.310 --> 00:35:27.230
and then I'm going to call this method,
which is load preview for index path,

00:35:27.230 --> 00:35:30.260
and this guy is a little
asynchronous operation that goes

00:35:30.260 --> 00:35:33.620
and fetches the preview image
and will apply it to the cell.

00:35:33.620 --> 00:35:37.100
So I'm going to do that,
and then let's go look at that code.

00:35:37.900 --> 00:35:42.440
In here, I go look at my model,
which is this little file representation,

00:35:42.440 --> 00:35:46.810
and the file representation will tell
me the document URL for each row,

00:35:46.880 --> 00:35:49.580
and also the preview
URL associated with it,

00:35:49.580 --> 00:35:54.730
which I know because I know to take
note1.note to note1.note.preview and

00:35:54.730 --> 00:35:57.170
look in the data directory for it.

00:35:58.800 --> 00:36:10.000
[Transcript missing]

00:36:28.590 --> 00:36:28.590
And I also have this little guy,
which is a dictionary of

00:36:28.590 --> 00:36:28.590
preview loading operations,
this actual NS block operations.

00:36:28.590 --> 00:36:28.590
I'm going to use that in a little bit
for the purpose of actually being able to

00:36:28.590 --> 00:36:28.590
cancel this operation if the cell becomes
no longer on screen or I reload data,

00:36:28.590 --> 00:36:28.590
something like that.

00:36:30.610 --> 00:36:33.370
So all I need to do is go
to a background thread,

00:36:33.370 --> 00:36:38.730
so I dispatch async to the global queue,
and I use an NS file coordinator to

00:36:38.810 --> 00:36:42.500
coordinate reading to the preview URL.

00:36:42.500 --> 00:36:46.410
And that operation,
coordinate reading to the preview URL,

00:36:46.410 --> 00:36:49.500
will result in downloading
the preview file.

00:36:49.500 --> 00:36:53.190
So I download what hopefully
is a very small file while

00:36:53.190 --> 00:36:55.500
not downloading my document.

00:36:55.500 --> 00:36:58.460
And when that operation is done,
on the main queue,

00:36:58.550 --> 00:37:02.670
I can enqueue the preview loading
operation that I created up here,

00:37:02.670 --> 00:37:06.290
and that will go and apply
the image to the cell.

00:37:06.480 --> 00:37:12.450
The last little bit of making
this code great is implementing a

00:37:12.520 --> 00:37:13.800
delegate method on the table view.

00:37:13.800 --> 00:37:20.010
This is actually a new method
in iOS 6 for UI table view.

00:37:20.010 --> 00:37:22.120
That's didEndDisplayingCell.

00:37:22.440 --> 00:37:27.130
And that tells us when the
user scrolls a cell off screen

00:37:27.130 --> 00:37:32.380
or when reload data is called,
we no longer need a cell.

00:37:32.380 --> 00:37:32.380
For any reason that a cell gets reused,

00:37:32.500 --> 00:37:48.200
[Transcript missing]

00:37:49.450 --> 00:37:53.000
Now that I should have preview,
let's try this.

00:37:53.040 --> 00:37:58.360
So there's -- I now have previews
popped up in this document.

00:37:58.470 --> 00:38:03.360
And, you know, I can edit this preview,
too.

00:38:03.360 --> 00:38:07.360
You know, for my WWDC, you know,
maybe I want to change this.

00:38:07.370 --> 00:38:12.050
I think about this as more
of an Xcode kind of thing.

00:38:12.060 --> 00:38:14.930
Oh, I don't have that on here.

00:38:14.930 --> 00:38:16.690
Maybe I have it on here.

00:38:16.690 --> 00:38:16.690
Let's see.

00:38:35.630 --> 00:38:35.630
Yeah, I've got some images on here.

00:38:35.630 --> 00:38:35.630
We'll also get to see this
sync across and it'll be fun.

00:38:35.630 --> 00:38:35.630
So I'm going to change --
it changes the preview and

00:38:35.630 --> 00:38:35.630
momentarily we should actually
see the preview come up over here.

00:38:35.630 --> 00:38:35.630
Ta-da.

00:38:38.700 --> 00:38:48.610
is a great guy.

00:38:48.610 --> 00:38:48.610
He's a great guy.

00:38:48.610 --> 00:38:48.610
He's a great guy.

00:38:48.610 --> 00:38:48.610
He's a great guy.

00:38:48.610 --> 00:38:48.610
He's a great guy.

00:38:49.340 --> 00:38:51.040
All right.

00:38:51.180 --> 00:38:51.900
So that's preview.

00:38:51.900 --> 00:38:53.530
It's not that hard.

00:38:53.810 --> 00:38:57.300
Write out the data in the background
thread using UIDoctrment override.

00:38:57.390 --> 00:39:01.960
And then we just download that
individual preview file without

00:39:02.010 --> 00:39:04.500
downloading the entire document.

00:39:04.610 --> 00:39:08.740
Save network,
save storage on the user's device.

00:39:10.030 --> 00:39:11.060
It's a great technique.

00:39:11.070 --> 00:39:12.310
All right.

00:39:12.470 --> 00:39:14.510
It's time to talk about

00:39:15.580 --> 00:39:19.890
The last things we want to think about
to polish our app and get it ready to

00:39:19.970 --> 00:39:25.130
put on the store and maybe think about
some of the ideas that are what we would

00:39:25.130 --> 00:39:27.320
consider being a good iCloud citizen.

00:39:27.550 --> 00:39:33.170
And being a good iCloud citizen
is really about handling conflicts

00:39:33.170 --> 00:39:36.790
in addition to using -- trying not
to use a lot of network bandwidth,

00:39:36.790 --> 00:39:38.880
which we've talked about
a little bit already.

00:39:39.020 --> 00:39:42.180
But conflicts,
I'm sure you've heard about this before

00:39:42.290 --> 00:39:46.790
if you came to this talk last year or
if you've been to other iCloud talks.

00:39:46.940 --> 00:39:50.660
It's always going to be reiterated
because we simply can't avoid

00:39:50.660 --> 00:39:54.230
in a cloud-based world the
idea of conflicts happening.

00:39:54.240 --> 00:39:59.390
We've got all these devices all living
under the cloud all at the same time.

00:39:59.590 --> 00:40:01.860
User can be making edits on any of them.

00:40:01.930 --> 00:40:04.750
But any of them may or may
not be connected to the

00:40:04.750 --> 00:40:06.570
network at any given time.

00:40:06.690 --> 00:40:08.830
That's the network -- or
that's the nature of the beast.

00:40:08.900 --> 00:40:13.290
So if we end up in a situation
where we make different changes on

00:40:13.290 --> 00:40:18.640
different devices and they're not
connected to the network at that time,

00:40:18.640 --> 00:40:21.840
but eventually they do get
connected to the network,

00:40:21.990 --> 00:40:24.030
at the time they get
connected to the network,

00:40:24.140 --> 00:40:26.080
we've got a conflict.

00:40:26.280 --> 00:40:30.630
So how do we handle it?

00:40:31.490 --> 00:40:34.910
In an ideal world, we have to, well,
in a definite world,

00:40:34.910 --> 00:40:37.130
we must always handle conflicts.

00:40:37.130 --> 00:40:41.630
And the reason for that is
the way that iCloud manages

00:40:42.170 --> 00:40:47.150
conflicts is when it detects them,
it creates a version that is,

00:40:47.310 --> 00:40:51.220
it decides is effectively
the winner of that conflict.

00:40:51.220 --> 00:40:54.940
And that is the current
version of your file on disk.

00:40:55.190 --> 00:40:57.810
That's what you will read if
you go access your document even

00:40:57.810 --> 00:40:59.580
after the conflict has occurred.

00:40:59.580 --> 00:41:01.380
Whatever iCloud has
decided is the winner.

00:41:01.400 --> 00:41:04.420
winner, which is basically the last one.

00:41:04.870 --> 00:41:09.510
iCloud will also pick a conflict loser
and create a new version of the file

00:41:09.510 --> 00:41:11.740
that represents the conflict loser.

00:41:11.740 --> 00:41:15.470
You access that through
the NSFileVersion API.

00:41:16.660 --> 00:41:19.120
If you don't deal with
conflicts in some way,

00:41:19.370 --> 00:41:22.540
these conflict versions
stay on your user's device.

00:41:22.700 --> 00:41:27.150
And if you've got large documents,
you can build up conflict

00:41:27.260 --> 00:41:31.430
versions that stick around forever
and needlessly waste space.

00:41:31.590 --> 00:41:33.460
So always handle conflicts.

00:41:34.380 --> 00:41:38.570
Now, getting back to my perfect world,
a great strategy for handling conflicts

00:41:38.570 --> 00:41:40.300
is some kind of automatic merging.

00:41:40.650 --> 00:41:44.200
If your application has the
smarts to be able to take two

00:41:44.200 --> 00:41:47.700
conflicted versions of a document,
put them together,

00:41:47.760 --> 00:41:53.660
figure out what the right thing is,
and save that to disk, awesome.

00:41:53.700 --> 00:41:57.810
I will personally give you a high five,
a handshake, and a pat on the back.

00:41:59.200 --> 00:41:59.910
Nobody has done it.

00:41:59.980 --> 00:42:00.410
Oh, man.

00:42:00.440 --> 00:42:01.340
Okay.

00:42:01.340 --> 00:42:03.840
Well, you'll have it done by next year.

00:42:05.400 --> 00:42:24.200
[Transcript missing]

00:42:24.390 --> 00:42:25.940
This isn't always possible.

00:42:25.940 --> 00:42:30.580
In those cases, when it's not possible,
the direction is be lazy

00:42:30.610 --> 00:42:32.100
about conflict handling.

00:42:32.100 --> 00:42:37.140
And what we mean by that is don't
ping the user as soon as you detect a

00:42:37.220 --> 00:42:44.110
conflict and force them to stop whatever
they're doing and deal with the conflict.

00:42:44.120 --> 00:42:47.220
I mean, it's great to tell the user
that there was a conflict,

00:42:47.240 --> 00:42:49.860
but don't make it so they
can't do anything else before

00:42:49.860 --> 00:42:50.860
they deal with the conflict.

00:42:51.020 --> 00:42:53.960
So what we want is maybe
something like this,

00:42:53.990 --> 00:42:59.390
where we show a little bit of UI that
lets the user know that they're in a

00:42:59.390 --> 00:43:04.960
state and gives them a way to access
conflict resolution on their own time.

00:43:05.030 --> 00:43:09.130
So when they decide, "Hey,
I wanna deal with whatever conflict

00:43:09.130 --> 00:43:12.740
happened "and run through whatever
conflict handling mechanism

00:43:12.740 --> 00:43:14.920
"you have created for them,"

00:43:15.080 --> 00:43:15.900
They can do that on their own time.

00:43:15.960 --> 00:43:18.440
So that's dealing with conflicts.

00:43:18.500 --> 00:43:23.450
Let's talk about some advanced error
handling stuff you can do in UIDocument.

00:43:23.460 --> 00:43:28.020
I'm putting this part in there because
I think it's a great polished thing,

00:43:28.020 --> 00:43:31.160
and I think that nobody really knows
about what I'm about to tell you.

00:43:31.200 --> 00:43:36.590
And that's that reading and
writing methods in UIDocument,

00:43:36.600 --> 00:43:39.710
they all return this
NSError instance by indirection,

00:43:39.850 --> 00:43:41.610
but what happens with that?

00:43:42.040 --> 00:43:47.320
Well, the UIDocument machinery takes that
NSError and it sends it to this method,

00:43:47.320 --> 00:43:50.380
which you can override on UIDocument,
which is handleError user

00:43:50.380 --> 00:43:51.500
interaction permitted.

00:43:51.500 --> 00:43:52.140
Great.

00:43:52.450 --> 00:43:53.730
What does that method do?

00:43:53.740 --> 00:44:01.400
Well, what that method does is take the
NSError and look at it and see,

00:44:01.400 --> 00:44:05.040
you know, first of all,
the error message, but more importantly,

00:44:05.040 --> 00:44:07.980
does this error have a recovery
attempter associated with it?

00:44:08.030 --> 00:44:11.760
And if that's true,
if the error has a recovery attempter,

00:44:12.020 --> 00:44:16.630
and the user interaction
parameter is yes.

00:44:17.990 --> 00:44:20.710
Then the default implementation of
UIDoctument will actually put up an

00:44:20.710 --> 00:44:24.360
alert that shows your error message
to the user and gives them the option

00:44:24.660 --> 00:44:27.170
to invoke your recovery attempter.

00:44:28.360 --> 00:44:32.460
So you can get in the way by overriding
this method in your subclass.

00:44:32.520 --> 00:44:35.340
And when we send an error,
you intercept it.

00:44:35.400 --> 00:44:39.380
You can then customize that error,
possibly by changing the message and

00:44:39.380 --> 00:44:43.260
by including a recovery attempter,
sending your customized instance

00:44:43.690 --> 00:44:46.640
to UIDoctument's default handler.

00:44:47.380 --> 00:44:49.390
Another way that you can get
in the way of this is simply in

00:44:49.390 --> 00:44:50.760
the reading and writing methods.

00:44:50.880 --> 00:44:53.700
If you've overridden these,
you can create your custom

00:44:53.700 --> 00:44:57.510
NSError instance there and our machinery
will send it over to HandleError.

00:44:59.170 --> 00:45:01.340
Additionally,
you can also just yourself call

00:45:01.340 --> 00:45:04.360
HandleError user interaction
permitted at any time.

00:45:04.480 --> 00:45:07.570
Or if you don't like our UI,
you have your own UI,

00:45:07.570 --> 00:45:13.430
you can implement HandleError user
interaction permitted yourself and

00:45:13.430 --> 00:45:16.480
do essentially whatever you want.

00:45:16.480 --> 00:45:19.000
You just need to respect the
user interaction permitted flag.

00:45:19.170 --> 00:45:21.680
So if that's no, you don't put up UI.

00:45:22.020 --> 00:45:27.540
And that flag would be no in situations
like when we're closing the application.

00:45:27.540 --> 00:45:31.020
If the application is closing,
UI doesn't help us because

00:45:31.020 --> 00:45:33.280
the application is going away.

00:45:33.680 --> 00:45:37.210
So let's talk about
signing out of iCloud.

00:45:37.250 --> 00:45:41.790
This is kind of the last architectural
thing that we're going to deal with.

00:45:41.900 --> 00:45:55.200
[Transcript missing]

00:46:20.830 --> 00:46:21.930
The application really just
wants to get out of the way.

00:46:21.930 --> 00:46:21.930
That's all it wants to do.

00:46:21.930 --> 00:46:21.930
It wants to determine that this
has happened by registering

00:46:21.930 --> 00:46:21.930
for the NS Ubiquity token,
identity token to change notification,

00:46:21.930 --> 00:46:21.930
the new notification iOS 6.

00:46:21.930 --> 00:46:21.930
This will tell you when
that token changed.

00:46:21.930 --> 00:46:21.930
And when that happens,
it just closes any open documents

00:46:21.930 --> 00:46:21.930
because they don't make sense anymore.

00:46:21.930 --> 00:46:21.930
If the user had a document in
iCloud and the user signed out,

00:46:22.650 --> 00:46:23.070
Get out of the way.

00:46:23.290 --> 00:46:24.640
Close those documents.

00:46:24.760 --> 00:46:26.250
They're no longer accessible.

00:46:26.470 --> 00:46:29.400
If the user wants to get
those documents back,

00:46:29.500 --> 00:46:32.010
they will sign back into
that iCloud account.

00:46:32.270 --> 00:46:33.730
Simple as that.

00:46:33.940 --> 00:46:38.500
And you want to provide user
feedback so that the user understands

00:46:38.500 --> 00:46:40.700
that their data isn't gone.

00:46:40.820 --> 00:46:43.900
It just requires their, you know,
nice little credentials,

00:46:43.960 --> 00:46:46.850
their account name and password
and settings to sign back into

00:46:47.150 --> 00:46:48.860
iCloud and get their data back.

00:46:49.080 --> 00:46:50.660
So that's pretty easy.

00:46:50.670 --> 00:46:54.130
We're going to talk about
code for that in a second.

00:46:54.500 --> 00:46:56.690
But, you know,
you can write a little alert that

00:46:56.690 --> 00:46:59.880
looks like this that shows them,
you know, hey, you signed out iCloud.

00:47:00.120 --> 00:47:01.260
Sign back in to get your data back.

00:47:01.260 --> 00:47:03.680
Last thing is,
should be the last thing for

00:47:03.680 --> 00:47:06.750
any application that you ship,
but really especially

00:47:06.880 --> 00:47:09.250
in the iCloud world,
that's testing.

00:47:11.660 --> 00:47:13.840
You can do testing effectively
in iCloud by using Airplane

00:47:13.840 --> 00:47:15.020
Mode to create conflicts.

00:47:15.040 --> 00:47:17.570
That's something people ask about a lot,
like, you know,

00:47:17.570 --> 00:47:19.000
how do I test a conflict pass?

00:47:19.140 --> 00:47:21.000
Well,
Airplane Mode is a great way to do that.

00:47:21.160 --> 00:47:24.220
Take two devices,
put one of them on Airplane Mode,

00:47:24.220 --> 00:47:27.520
make changes on both devices,
bring the one in Airplane

00:47:27.620 --> 00:47:28.650
Mode back online.

00:47:28.770 --> 00:47:30.120
When they get to talk
to each other again,

00:47:30.220 --> 00:47:31.020
conflicts come in.

00:47:31.040 --> 00:47:34.380
This is a great analog for
user scenarios because Airplane

00:47:34.510 --> 00:47:38.750
Mode simulates simply being out of
contact with the network for a while,

00:47:38.930 --> 00:47:41.000
and that's a great simulation.

00:47:41.650 --> 00:47:46.990
basic changes,
things you can do to your document while

00:47:46.990 --> 00:47:48.840
that document is open on one application.

00:47:48.840 --> 00:47:52.190
So that's as simple as have
the document open on one app,

00:47:52.190 --> 00:47:57.500
make a change from another device,
and make sure that syncs over

00:47:57.500 --> 00:48:01.520
properly and everything happens
correctly on the remote device.

00:48:02.120 --> 00:48:03.870
Also,
while a document is open on one device,

00:48:03.870 --> 00:48:06.170
change the name of that
document from another device.

00:48:06.170 --> 00:48:09.920
You can also delete the document
while it is open on one device.

00:48:09.920 --> 00:48:14.440
You can also do all of these
things rather than while the

00:48:14.440 --> 00:48:17.690
document is open and running,
while the document is sort of

00:48:17.690 --> 00:48:22.060
conceptually open but your application
is waiting for state restoration.

00:48:22.060 --> 00:48:25.850
And if you're expecting sort of
that document to come back up

00:48:25.850 --> 00:48:30.330
when you do state restoration,
you can exercise all of these things,

00:48:30.420 --> 00:48:31.880
changing concepts.

00:48:31.930 --> 00:48:34.910
I'm moving and deleting.

00:48:35.760 --> 00:48:39.140
And then see that your state restoration
machinery handles it correctly.

00:48:39.160 --> 00:48:43.900
The last thing there is use
Network Activity Monitor to -- if

00:48:43.900 --> 00:48:47.200
you are interested in looking at
the performance of your application

00:48:47.550 --> 00:48:49.240
while it's doing all these things.

00:48:49.240 --> 00:48:53.150
It's great if you get all the right
things happening at the user level,

00:48:53.270 --> 00:48:57.760
but you might also want to ensure
that you're not creating unnecessary

00:48:57.760 --> 00:49:01.040
amounts of network activity and
using bandwidth in the process,

00:49:01.100 --> 00:49:05.000
maybe doing -- syncing more data back
and forth than is actually required.

00:49:05.000 --> 00:49:06.960
So I'm going to show you one last demo.

00:49:07.280 --> 00:49:11.940
And that's the code for responding
to sign out in Cloud Notes.

00:49:12.000 --> 00:49:14.990
So we're going to go back
to our application delegate.

00:49:15.260 --> 00:49:20.830
And so we registered for the NS Ubiquity
identity did change notification up here

00:49:20.940 --> 00:49:24.000
and application did finish launching.

00:49:24.000 --> 00:49:27.560
And the selector that we used
for that is check user iCloud

00:49:27.560 --> 00:49:29.960
preference and setup if necessary.

00:49:30.060 --> 00:49:32.000
That's the same thing
that we called up here.

00:49:32.000 --> 00:49:34.980
So the idea is this is a method that
we run when we launch our application.

00:49:35.020 --> 00:49:39.190
but we also run it any time
the iCloud state changes.

00:49:41.160 --> 00:49:45.570
And to make sign-out work great,
if the user is set up

00:49:45.910 --> 00:49:51.440
having chosen to use iCloud,
we're going to make sure we

00:49:51.460 --> 00:49:56.520
check the ubiquitous token,
which is something that we're going to

00:49:56.520 --> 00:50:01.490
store also in NSUserDefaults alongside
the user's iCloud choice.

00:50:01.680 --> 00:50:06.300
So that method is this thing
that looks in NSUserDefaults,

00:50:06.300 --> 00:50:09.820
takes token data,
unarchives it to create a

00:50:10.020 --> 00:50:16.650
version of the ubiquitous token,
and then our logic is -- oops.

00:50:37.560 --> 00:50:37.580
If that token has changed
and we used to have a token,

00:50:37.580 --> 00:50:37.580
meaning in our previous
time we went through this,

00:50:37.580 --> 00:50:37.580
we were signed into iCloud,
then we have signed out and we should

00:50:37.580 --> 00:50:37.580
let the user know that this happened.

00:50:37.580 --> 00:50:37.580
We use a UI alert view for this again.

00:50:38.890 --> 00:50:43.400
Then in our backup and check user iCloud
preference and setup if necessary,

00:50:43.400 --> 00:50:49.680
a little bit of work we do
here is check whether -- if the

00:50:49.680 --> 00:50:52.740
user is not signed into iCloud,
we make sure we set our

00:50:52.850 --> 00:50:54.840
Cloud Manager to not using iCloud.

00:50:55.070 --> 00:50:59.220
That way all the other bits of our
application get to know about that state.

00:50:59.470 --> 00:51:06.510
And then -- hopefully that works.

00:51:06.510 --> 00:51:06.510
Yay.

00:51:07.950 --> 00:51:12.650
We actually remove from the
NSUser defaults our user choice.

00:51:12.900 --> 00:51:15.790
And the idea for this is if
you sign out from iCloud and

00:51:16.040 --> 00:51:19.360
then you sign back in later,
we'll actually want to ask you

00:51:19.360 --> 00:51:21.490
again if you want to use iCloud now.

00:51:21.730 --> 00:51:24.990
So we have to switch to local
storage when they sign out,

00:51:24.990 --> 00:51:27.850
but when they sign back in,
we may want to switch

00:51:27.920 --> 00:51:29.590
back to iCloud Storage.

00:51:29.610 --> 00:51:34.560
So the last bit to make this all
work is to store the Ubiquiti token.

00:51:34.630 --> 00:51:38.570
And that's just in NSUser
defaults right down here.

00:51:38.740 --> 00:51:42.790
We take a look, and if we have a token,
we'll go ahead and archive it up,

00:51:42.980 --> 00:51:44.600
set it in NSUser defaults.

00:51:44.600 --> 00:51:46.600
My key is Ubiquiti identity token.

00:51:46.600 --> 00:51:49.640
If we don't have a token,
we'll just go ahead and remove

00:51:49.640 --> 00:51:51.600
that key from NSUser defaults.

00:51:51.830 --> 00:51:54.600
And let's go ahead and
run our application.

00:51:54.600 --> 00:51:55.420
Okay.

00:51:55.690 --> 00:51:56.450
So here's our app.

00:51:56.590 --> 00:51:58.820
Let's try signing out.

00:52:00.400 --> 00:52:07.920
I can short-circuit this operation pretty
easily by going into Documents and Data,

00:52:08.030 --> 00:52:09.680
turning that off.

00:52:09.680 --> 00:52:11.790
Documents are off.

00:52:12.240 --> 00:52:13.840
Go back to Cloud Notes.

00:52:13.880 --> 00:52:17.190
Pops me up an alert that says, "Hey,
I've signed out.

00:52:17.630 --> 00:52:21.680
I can sign back in if I want to
retrieve my documents." I can see that,

00:52:21.760 --> 00:52:27.670
hey, I'm just down to local stuff now,
and I don't get to use the cloud.

00:52:28.540 --> 00:52:31.140
I can sign back in, though,
which is really just turning

00:52:31.140 --> 00:52:33.550
documents and data back on.

00:52:34.390 --> 00:52:36.560
Go back to Cloud Notes.

00:52:36.600 --> 00:52:41.400
I'm re-presented with the alert that
asks me if I want to use iCloud.

00:52:41.400 --> 00:52:41.400
I do.

00:52:41.880 --> 00:52:42.890
My data comes back.

00:52:43.050 --> 00:52:46.950
I download the preview
files and put them back up.

00:52:47.060 --> 00:52:49.740
I can even access a file.

00:52:49.740 --> 00:52:53.120
It'll download that from the
cloud and my content comes back.

00:52:53.330 --> 00:52:56.580
Everything's great just by
signing back into the cloud.

00:52:56.860 --> 00:52:57.260
That's it.

00:52:57.260 --> 00:53:02.760
If you have any other
questions about using iCloud,

00:53:02.760 --> 00:53:07.410
we've talked about high-level concepts,
key things that will make

00:53:07.470 --> 00:53:13.170
building an iCloud application
easier and make it work for you.

00:53:13.180 --> 00:53:17.360
We're working on getting you the
code that I just wrote today so

00:53:17.410 --> 00:53:21.180
you can see other pieces of it,
like how the little cloud manager

00:53:21.180 --> 00:53:22.960
singleton works and such like that.

00:53:24.360 --> 00:53:28.580
If you have additional questions,
you can email jury.apple.com.

00:53:28.580 --> 00:53:32.260
Our evangelist, Mike Jurowicz,
always happy to help you.

00:53:32.260 --> 00:53:35.040
We have some additional sessions.

00:53:35.040 --> 00:53:38.500
Thankfully,
these are all still yet to happen.

00:53:38.500 --> 00:53:41.350
A couple this afternoon on using
iCloud with NSDocument if you're

00:53:41.450 --> 00:53:43.220
interested in iCloud on the desktop.

00:53:43.220 --> 00:53:44.570
Using iCloud with Core Data.

00:53:44.570 --> 00:53:46.590
I know a lot of people
are interested in that.

00:53:46.680 --> 00:53:49.220
And Advanced iCloud Storage tomorrow.

00:53:49.220 --> 00:53:52.160
Good luck to you in writing
fantastic iCloud applications.

00:53:52.160 --> 00:53:53.450
I can't wait to see them.
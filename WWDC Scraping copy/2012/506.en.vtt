WEBVTT

00:00:11.200 --> 00:00:14.030
Good afternoon, everyone,
and welcome to Optimizing 2D

00:00:14.030 --> 00:00:15.990
Graphics and Animation Performance.

00:00:16.020 --> 00:00:18.190
I'm Tim Oriol,
and I'm going to be joined a

00:00:18.190 --> 00:00:20.300
little bit later on by Mike Funk.

00:00:20.380 --> 00:00:23.910
So let's take a look at
our schedule for today.

00:00:24.030 --> 00:00:27.400
We're going to talk about how you can
support Retina display both in your

00:00:27.400 --> 00:00:30.340
OSÂ X apps as well as your iOS apps.

00:00:30.400 --> 00:00:34.150
We're going to talk a little bit about
optimizing 2D drawing performance

00:00:34.310 --> 00:00:40.920
using some techniques with both
Core Animation as well as Quartz 2D.

00:00:41.190 --> 00:00:44.550
And then we're going to point out some of
the more common Retina display pitfalls

00:00:44.720 --> 00:00:48.690
and give you the information and guidance
you need to navigate around those.

00:00:48.790 --> 00:00:51.970
And finally,
we're going to introduce the new

00:00:51.970 --> 00:00:57.350
CG Display Stream API that will allow
you to get real-time display updates.

00:00:59.960 --> 00:01:03.130
A couple of prerequisites that
we're expecting to have coming

00:01:03.220 --> 00:01:06.700
into this session is knowledge
of the Core Animation framework,

00:01:06.700 --> 00:01:09.460
knowledge of Quartz
2D drawing techniques,

00:01:09.560 --> 00:01:13.040
and basic fundamental
knowledge of NS view,

00:01:13.040 --> 00:01:16.020
UI view, how to lay out your stuff.

00:01:17.480 --> 00:01:21.160
So what changes with Retina displays?

00:01:21.160 --> 00:01:22.840
Well, now we have four times the pixels.

00:01:22.840 --> 00:01:24.730
We've doubled the dimension in the width.

00:01:24.730 --> 00:01:26.610
We doubled the dimension in the height.

00:01:26.620 --> 00:01:29.410
And so we have four times
the total number of pixels

00:01:29.410 --> 00:01:31.160
in the same amount of space.

00:01:31.160 --> 00:01:33.030
So now how do you lay your stuff out?

00:01:33.030 --> 00:01:34.660
Are you going to use pixels?

00:01:34.660 --> 00:01:36.810
Are you going to use the old pixels?

00:01:36.840 --> 00:01:37.820
What do we do?

00:01:37.820 --> 00:01:40.030
So if you start reading our
developer documentation,

00:01:40.030 --> 00:01:42.360
you are no doubt going to
encounter the term points.

00:01:42.370 --> 00:01:46.260
So let's take a minute now and just
clear up any discrepancies between

00:01:46.260 --> 00:01:50.780
points and pixels and figure out
what we need to do in our app.

00:01:50.780 --> 00:01:54.740
So points have nothing to do with
font points for this session.

00:01:54.840 --> 00:01:56.010
Font points.

00:01:56.010 --> 00:02:00.000
For our session,
we're going to be talking in

00:02:00.000 --> 00:02:01.390
logical coordinates for points.

00:02:01.500 --> 00:02:04.120
So points are what you want to
use to lay out your buttons,

00:02:04.130 --> 00:02:07.240
what size everything is going to be,
set up your entire app in this

00:02:07.250 --> 00:02:09.380
logical coordinate space of points.

00:02:09.380 --> 00:02:12.600
And then pixels on the other
side of the spectrum are the

00:02:12.600 --> 00:02:14.140
actual device display units.

00:02:14.140 --> 00:02:21.010
When it's rendered on, like, say,
the new iPad or even an old iPhone.

00:02:21.610 --> 00:02:26.700
And the whole point is that one point
is not always equal to one pixel.

00:02:26.700 --> 00:02:30.360
And so we're going to be using the
term scale factor in this session.

00:02:30.360 --> 00:02:34.830
And what we mean when we use scale
factor is the number of pixels

00:02:34.830 --> 00:02:37.050
per point that's in one dimension.

00:02:37.060 --> 00:02:40.510
So if we doubled both dimensions,
our scale factor is going to be two.

00:02:40.510 --> 00:02:45.900
And the whole idea is for you to be able
to use points when you do your Quartz 2D,

00:02:45.900 --> 00:02:50.320
Core Animation, UI kit, app kit layout,
and then you supply

00:02:50.320 --> 00:02:53.350
the scale factor to us,
and we will automatically

00:02:53.360 --> 00:02:56.690
render it in the crisp,
clean resolution that's perfect

00:02:56.770 --> 00:02:58.550
for the devices being run on.

00:03:00.310 --> 00:03:02.760
Okay, so how do you get that
scale factor to us,

00:03:02.820 --> 00:03:04.360
and where do you set it?

00:03:04.360 --> 00:03:07.200
If you're working with CA layers,
then you're going to want to look at

00:03:07.200 --> 00:03:11.390
the content scale property on the layer,
and you want to set this on

00:03:11.390 --> 00:03:14.180
any layer that you want to
provide high-resolution content.

00:03:14.320 --> 00:03:17.960
So if you have CA text layers,
if you have CA shape layers,

00:03:17.960 --> 00:03:22.760
if you have your own layer that you're
doing some quartz 2D drawing in there,

00:03:22.800 --> 00:03:26.900
these are all great candidates where you
want to set that scale factor in there,

00:03:26.930 --> 00:03:29.960
and you're going to get an
automatic upscale to the correct

00:03:30.060 --> 00:03:32.110
resolution for the display.

00:03:32.550 --> 00:03:36.800
Any layers where you've
supplied images for the content,

00:03:36.800 --> 00:03:39.980
if you supply the high-resolution images,
then you're going to want

00:03:40.090 --> 00:03:41.060
to set the scale factor.

00:03:41.260 --> 00:03:42.790
If you don't, then you don't.

00:03:42.890 --> 00:03:44.200
You have to do both of these in tandem.

00:03:44.200 --> 00:03:48.620
So if you leave your original
1X artwork there and you set the

00:03:48.620 --> 00:03:51.530
scale factor to match the screen,
you're telling us you have

00:03:51.530 --> 00:03:53.840
artwork for the screen scale,
but you don't actually have it.

00:03:53.840 --> 00:03:57.600
You may end up with some
unexpected behavior,

00:03:57.600 --> 00:04:00.870
like maybe your image is only going
to take up the bottom left-hand

00:04:01.150 --> 00:04:04.400
corner of the layer because you've
set it to be laid out down there,

00:04:04.460 --> 00:04:06.830
and we don't have enough
image data to supply it.

00:04:07.030 --> 00:04:09.390
So if you're going to leave
your 1X artwork in there,

00:04:09.490 --> 00:04:12.190
leave the content scale at 1X.

00:04:12.410 --> 00:04:16.430
And as always, any layers that were
created by AppKit or UIKit,

00:04:16.430 --> 00:04:19.100
you shouldn't really mess with.

00:04:19.100 --> 00:04:21.000
They're going to set their
content scale appropriately.

00:04:21.000 --> 00:04:22.260
You don't need to worry about that.

00:04:22.380 --> 00:04:26.570
You should really only be using
these layers as a point where you

00:04:26.570 --> 00:04:29.170
can add your own custom sublayers.

00:04:29.270 --> 00:04:32.770
If you're on iOS,
you can get the scale factor of the

00:04:32.770 --> 00:04:35.540
main screen right here on the slide.

00:04:35.540 --> 00:04:38.620
The UI screen main screen
method will get that for you.

00:04:38.620 --> 00:04:40.960
And that is most likely what
you'd want to set for the

00:04:41.030 --> 00:04:42.520
content scale for your layer.

00:04:42.610 --> 00:04:47.070
I should mention now that for
the course of this presentation,

00:04:47.070 --> 00:04:52.540
I'll be using iOS and UIKit metaphors,
but there are parallel

00:04:52.540 --> 00:04:54.850
APIs on the desktop side.

00:04:57.120 --> 00:04:59.560
So that was for if you're
working with CA layers,

00:04:59.560 --> 00:05:02.940
if you're working with views,
that gets set for you.

00:05:03.020 --> 00:05:06.630
If you're working with CG contexts,
if you've already told us the scale

00:05:06.630 --> 00:05:09.600
factor for your layer or view,
by the time you get the CG context

00:05:09.600 --> 00:05:13.100
in the draw rect or draw in context,
that's going to be set up for you.

00:05:13.100 --> 00:05:14.130
You've already told us once.

00:05:14.170 --> 00:05:15.220
We'll take care of the rest.

00:05:16.220 --> 00:05:20.580
The caveat comes in when you create
a bitmap context or any CG context

00:05:20.580 --> 00:05:25.280
that's not directly tied to the view,
you need to recognize that this is going

00:05:25.280 --> 00:05:29.080
to be specified in pixel dimensions,
and then you won't have to adapt

00:05:29.090 --> 00:05:33.000
any of your drawing to match the
scale that you intend to render at.

00:05:33.100 --> 00:05:35.460
If you are on iOS, you're in luck.

00:05:35.460 --> 00:05:37.740
We have a helper method for you.

00:05:37.740 --> 00:05:42.280
The UI graphics method here will allow
you to specify the size in points.

00:05:42.360 --> 00:05:46.200
You can let us know if
you need any of these.

00:05:46.200 --> 00:05:48.840
You can let us know if you need
transparency in your bitmap context.

00:05:48.900 --> 00:05:51.200
As always,
if you can do opaque rendering,

00:05:51.250 --> 00:05:53.340
that's a lot faster for us to render.

00:05:53.350 --> 00:05:56.660
So if you are doing opaque rendering,
opt in, let us know.

00:05:57.090 --> 00:05:58.610
And then finally, the scale.

00:05:58.640 --> 00:06:01.360
That should be the scale
factor equivalent of what

00:06:01.360 --> 00:06:02.890
you would set on a layer.

00:06:03.020 --> 00:06:05.970
And a neat little trick is if
you pass in zero for the scale,

00:06:05.970 --> 00:06:09.840
we're going to automatically detect
what the scale is on the main screen,

00:06:09.930 --> 00:06:12.190
and we'll set that up for your context.

00:06:14.890 --> 00:06:19.790
So to recap,
your Quartz 2D and CA-based drawing

00:06:19.800 --> 00:06:22.140
should be scaled using this scale factor.

00:06:22.140 --> 00:06:24.000
You provide the scale factor to us.

00:06:24.030 --> 00:06:28.270
This is all your lines, your paths,
your shapes, any high-resolution images

00:06:28.270 --> 00:06:29.700
that you've provided.

00:06:29.700 --> 00:06:32.840
If you are going to supply
high-resolution artwork,

00:06:32.990 --> 00:06:36.540
one way you can do this really
nicely is to leave your existing

00:06:36.540 --> 00:06:40.960
1X artwork there and you make
another file with an at-2X suffix.

00:06:41.100 --> 00:06:44.970
If you do this when you load up your
assets using UI image or NS image,

00:06:44.970 --> 00:06:48.560
we're going to automatically look for
the resolution that's appropriate for

00:06:48.640 --> 00:06:52.820
your device so we don't waste memory
and we always get pixel-perfect results.

00:06:56.490 --> 00:06:57.200
The cost of this.

00:06:57.420 --> 00:07:01.500
So now that we have all these
extra pixels and we're using them,

00:07:01.500 --> 00:07:02.940
we have four times the pixels.

00:07:02.940 --> 00:07:05.990
This is going to magnify any
performance issues that we may

00:07:06.270 --> 00:07:07.640
have had in our app before.

00:07:07.640 --> 00:07:10.160
We may have been able to
get away with it before.

00:07:10.160 --> 00:07:15.150
Now the hard truth is we simply cannot
afford not to optimize our drawing code.

00:07:16.560 --> 00:07:18.200
So where do we start?

00:07:18.240 --> 00:07:20.940
First thing you want to
do is collect some data,

00:07:20.940 --> 00:07:22.030
do some profiling.

00:07:22.040 --> 00:07:24.980
Let's see if we can get
a good starting point.

00:07:25.020 --> 00:07:27.620
And one of the great instruments
that I like to use is the

00:07:27.730 --> 00:07:29.320
Core Animation instrument.

00:07:29.320 --> 00:07:33.350
It's got a number of useful debug options
you can see in the lower corner there.

00:07:33.410 --> 00:07:35.520
A lot of people don't know they're there.

00:07:35.520 --> 00:07:37.700
And so I just want to take a few minutes
and we're going to go through each

00:07:37.700 --> 00:07:39.980
one of those and see what they do.

00:07:46.100 --> 00:07:47.760
So I'm in Instruments here.

00:07:47.760 --> 00:07:51.690
If you don't have the panel up,
Command-D, and that'll bring it right up.

00:07:51.800 --> 00:07:53.260
It doesn't happen by default.

00:07:53.450 --> 00:07:57.630
And so we're going to go through
each one of these options here,

00:07:57.890 --> 00:08:02.340
and I'm going to switch you into -- so
you can see the iPad while I do this.

00:08:02.400 --> 00:08:06.990
And we'll just see how each one of
those affects the display on the iPad.

00:08:08.370 --> 00:08:10.290
So throughout the session today,
we're going to be using

00:08:10.290 --> 00:08:14.590
this finger-painting app
to do some of our examples.

00:08:14.910 --> 00:08:16.370
We just track the user's point.

00:08:16.520 --> 00:08:20.460
We have a custom CA layer subclass here
that we're going to do Quartz 2D drawing.

00:08:20.460 --> 00:08:23.370
We're just going to stroke
a path that follows through

00:08:23.370 --> 00:08:25.000
the points that were put in.

00:08:26.270 --> 00:08:28.600
So I'm going to go ahead
and enable the first option,

00:08:28.600 --> 00:08:31.300
which is color blended layers.

00:08:31.300 --> 00:08:35.000
So when I turn this on,
you notice that half the screen is green,

00:08:35.000 --> 00:08:36.160
half the screen is red.

00:08:36.160 --> 00:08:38.930
Well, ideally more than half
the screen would be green.

00:08:38.940 --> 00:08:41.800
Because anywhere that's
green is marked as opaque,

00:08:41.850 --> 00:08:45.240
and that's a region that we
can composite a lot faster.

00:08:45.240 --> 00:08:47.720
So you see we've done the right
thing with our layer here.

00:08:47.720 --> 00:08:50.350
We know that when we're
doing our finger painting,

00:08:50.500 --> 00:08:52.080
we have an opaque background.

00:08:52.080 --> 00:08:54.800
We're going to be putting opaque
strokes on top so we know that our

00:08:54.800 --> 00:08:59.110
rendering is always going to be opaque,
and we've let them know that, yes,

00:08:59.170 --> 00:09:00.430
we are opaque.

00:09:00.430 --> 00:09:05.570
You'll notice that some of the UI kit
elements do have this red tint on them,

00:09:05.570 --> 00:09:07.950
and that's not necessarily a bad thing.

00:09:08.060 --> 00:09:10.310
I'm sure you would like,
if you put a label on top of

00:09:10.310 --> 00:09:14.230
some of your animating content,
if it actually showed through underneath.

00:09:14.240 --> 00:09:18.370
So labels, anything that has a little
transparency around the borders

00:09:18.370 --> 00:09:21.170
will have by default this opaque.

00:09:22.300 --> 00:09:26.100
So now I'm going to turn that one off,
and we're going to move to color

00:09:26.410 --> 00:09:29.300
off-screen rendered yellow.

00:09:29.300 --> 00:09:32.960
So that's enabled,
and we don't see anything.

00:09:32.960 --> 00:09:34.680
That's because we don't have
anything being rendered off-screen.

00:09:34.680 --> 00:09:38.620
What a neat trick you can do
is if you do the four-finger

00:09:38.620 --> 00:09:43.270
pinch gesture to dismiss an app,
you can see that now our entire

00:09:43.270 --> 00:09:46.090
app has been colored this color.

00:09:46.860 --> 00:09:51.020
And what we do here is whenever
you do this pinch to dismiss,

00:09:51.020 --> 00:09:54.750
we're going to save an off-screen image
of your entire app in its current state,

00:09:54.750 --> 00:09:57.530
and we're going to use that
to do this scaling and fading

00:09:57.540 --> 00:09:59.390
animation as you dismiss the app.

00:10:02.460 --> 00:10:05.060
And when we get back to our normal state,
you notice the yellow tint goes

00:10:05.060 --> 00:10:08.990
away because we're back in our
app and we're rendering normally.

00:10:09.490 --> 00:10:11.350
So a related one,
I'm going to turn this one off,

00:10:11.630 --> 00:10:16.460
and I'll turn on a related one,
is color hits green and misses red.

00:10:16.460 --> 00:10:17.260
What does this mean?

00:10:17.260 --> 00:10:21.210
So this is if we do have to render
an off-screen cache of the state

00:10:21.640 --> 00:10:23.990
of one of your layers or your app.

00:10:24.040 --> 00:10:26.260
Let's do this again.

00:10:26.260 --> 00:10:29.620
You'll notice that it is green,
and what green means is we

00:10:29.620 --> 00:10:31.560
were able to reuse that cache.

00:10:31.560 --> 00:10:33.840
So if we were not able
to reuse that cache,

00:10:33.840 --> 00:10:37.260
let's say your app is changing a lot,
let me bring up one that has

00:10:37.260 --> 00:10:39.060
more dynamic content here.

00:10:39.100 --> 00:10:42.490
If I was to do it on here,
you'll notice that this is red.

00:10:42.500 --> 00:10:46.220
So if you have a game or something
like that that does change every frame,

00:10:46.220 --> 00:10:49.020
we're going to cache the bitmap so
we can use it for the animation.

00:10:49.040 --> 00:10:51.590
But since it changes every frame,
we're going to have to

00:10:51.590 --> 00:10:52.760
redo that every time.

00:10:52.760 --> 00:10:56.690
So in general, you want to see lots
of green here as well.

00:10:57.420 --> 00:10:59.130
Turn that off.

00:10:59.330 --> 00:11:02.800
Next one is color OpenGL Fast Path blue.

00:11:02.850 --> 00:11:04.620
This is super important
for your OpenGL apps,

00:11:04.620 --> 00:11:08.160
but we aren't dealing with that today,
so we're going to skip that.

00:11:08.160 --> 00:11:11.160
And then we have Flash updated regions.

00:11:11.160 --> 00:11:13.860
So Flash updated regions is going
to paint yellow over any part of

00:11:13.860 --> 00:11:15.360
the screen that we actually update.

00:11:15.470 --> 00:11:17.050
So you'll notice now we're being good.

00:11:17.060 --> 00:11:20.620
We're not actually updating any part of
the screen when we're not doing anything.

00:11:20.680 --> 00:11:24.480
If I start drawing in the canvas,
you'll notice that we do --

00:11:24.480 --> 00:11:27.710
we are updating the canvas,
and you notice that the performance

00:11:27.710 --> 00:11:31.180
metrics I've put in the bottom here,
our frames per second and time spent in

00:11:31.180 --> 00:11:34.040
our draw call are being updated as well.

00:11:34.040 --> 00:11:37.090
So if I do a clear,
we update the button state

00:11:37.090 --> 00:11:38.830
as well as the canvas.

00:11:38.890 --> 00:11:40.790
If I move one of these
controls for the size,

00:11:40.790 --> 00:11:43.480
we're going to redraw that
control as well as the preview.

00:11:43.650 --> 00:11:46.090
What you don't want to see is
updating the entire app every

00:11:46.160 --> 00:11:47.460
time you change one little thing.

00:11:47.460 --> 00:11:50.170
And we do a lot of this for
you in AppKit and UIKit,

00:11:50.310 --> 00:11:53.550
but it's up to you to do
that for your own elements.

00:11:53.580 --> 00:11:55.620
We'll turn that one off.

00:11:55.620 --> 00:12:00.170
And we'll go to the most
important one for this topic

00:12:00.570 --> 00:12:03.440
is color misaligned images.

00:12:03.440 --> 00:12:07.240
So what color misaligned images does
is it's going to do a couple things.

00:12:07.240 --> 00:12:10.620
The first thing it's going to
do is it's going to put a yellow

00:12:10.730 --> 00:12:14.140
tint over any content that is
being scaled that doesn't have the

00:12:14.150 --> 00:12:16.240
native scale factor of the display.

00:12:16.240 --> 00:12:19.740
So these are things that we haven't
set up properly for retina display.

00:12:19.740 --> 00:12:23.150
You'll notice we have not yet
enabled this for our painting canvas,

00:12:23.170 --> 00:12:24.780
so we still have the default scale of 1.

00:12:24.780 --> 00:12:24.780
And we're going to go
ahead and change this.

00:12:24.780 --> 00:12:28.170
You will also notice this on the
UI elements and you may think

00:12:28.170 --> 00:12:30.090
you want to go in and set those.

00:12:30.540 --> 00:12:31.110
You don't.

00:12:31.380 --> 00:12:33.440
We've already talked about this before.

00:12:33.440 --> 00:12:37.600
Any layer that UIKit or AppKit creates,
they're going to set that correctly.

00:12:37.600 --> 00:12:41.000
We do this intentionally to scale
images for the buttons to be any

00:12:41.110 --> 00:12:44.780
length and we design them so that
they will be shown appropriately.

00:12:44.810 --> 00:12:49.350
The other thing that color misaligned
images will do is let me do this again,

00:12:49.350 --> 00:12:53.910
is we will put a magenta tint on any
content that isn't pixel aligned.

00:12:53.940 --> 00:12:57.260
So this is the right scale,
but if it's not pixel aligned,

00:12:57.260 --> 00:13:01.260
you will get slight artifacting or
aliasing when your images are drawn.

00:13:01.260 --> 00:13:04.340
And so you notice as these
app icons are animating in,

00:13:04.500 --> 00:13:08.760
they do have that magenta tint,
but when we let them finish,

00:13:08.760 --> 00:13:10.140
that goes away.

00:13:10.140 --> 00:13:12.320
So you want to finish
on pixel boundaries,

00:13:12.360 --> 00:13:15.730
but it's perfectly normal to be in
between pixel boundaries while animating.

00:13:19.260 --> 00:13:23.000
Turn that off, and then I've put in a
handy little switch here.

00:13:23.000 --> 00:13:25.660
We can set our content scale correctly.

00:13:25.660 --> 00:13:28.340
Let me just turn on the missile
line again so we can see that.

00:13:28.590 --> 00:13:31.070
So we have that yellow tint now.

00:13:31.070 --> 00:13:34.100
If we do set our content
scale to match the screen,

00:13:34.100 --> 00:13:37.420
in this case, 2,
and then I update my painting canvas,

00:13:37.420 --> 00:13:41.100
you know that tint has gone away,
and we can see through to the content.

00:13:41.830 --> 00:13:44.140
You might also notice,
as I'm painting here,

00:13:44.140 --> 00:13:46.840
I don't know if you can see,
there's a little bit of ghosting,

00:13:46.840 --> 00:13:49.740
or the last path element looks
kind of like it's fading in.

00:13:49.740 --> 00:13:53.670
And if you watch when we clear it,
it kind of fades out instead

00:13:53.670 --> 00:13:55.730
of immediately going away.

00:13:55.740 --> 00:13:59.090
So what we've encountered
here is a feature of CA Layer,

00:13:59.090 --> 00:14:02.340
and you'll know if you've
worked with them before.

00:14:02.340 --> 00:14:05.140
Whenever you change one of
the properties on a layer,

00:14:05.140 --> 00:14:08.430
we're going to implicitly animate
from the old property to the new one.

00:14:08.440 --> 00:14:11.540
And this is great if you want to move
your layer around or flip it or fade it.

00:14:11.740 --> 00:14:16.730
But what's happening here is
whenever we invalidate our layer

00:14:16.740 --> 00:14:20.970
and we redraw via drawn context,
Core Animation assumes, okay,

00:14:21.050 --> 00:14:22.530
the layer's content has changed.

00:14:22.560 --> 00:14:23.540
What are we going to do?

00:14:23.540 --> 00:14:25.960
We're going to animate from
the old image to the new image.

00:14:26.040 --> 00:14:28.750
And so this isn't really what we
want in the finger painting app,

00:14:28.820 --> 00:14:32.370
and we're also going to pay a
performance price for that as well.

00:14:32.540 --> 00:14:36.100
So let me show you how to avoid that.

00:14:36.210 --> 00:14:39.410
We'll switch into Xcode for a sec.

00:14:40.120 --> 00:14:43.470
This is what you want to do right here.

00:14:43.650 --> 00:14:46.410
So every CA layer,
whenever you change a property,

00:14:46.490 --> 00:14:48.500
is going to call this
action for key method.

00:14:48.500 --> 00:14:52.020
So this is the default
animation or action to perform

00:14:52.020 --> 00:14:54.000
when that key has changed.

00:14:54.100 --> 00:14:57.420
And so what we're going to do
is we're going to filter out

00:14:57.420 --> 00:15:00.900
any time the contents change,
and then we're going to return nil.

00:15:00.970 --> 00:15:03.820
Nil means go directly to the new value,
don't perform any

00:15:03.820 --> 00:15:05.480
animations or transitions.

00:15:05.580 --> 00:15:10.120
And we're going to just defer to super
for the rest of our keys so we get the

00:15:10.120 --> 00:15:14.500
implicit behavior of the animations
that we want for the other properties.

00:15:14.680 --> 00:15:20.820
So now if we go back to our app,
so this is what we have now

00:15:20.820 --> 00:15:23.000
with that sort of fading in.

00:15:24.000 --> 00:15:27.650
And now if we turn on that,
you'll notice we get nice,

00:15:27.810 --> 00:15:28.800
smooth strokes there.

00:15:28.800 --> 00:15:32.070
The strokes are shorter because
we're able to sample faster,

00:15:32.070 --> 00:15:35.930
and we don't have the
ghosting unclear or drying.

00:15:38.480 --> 00:15:43.300
Let's go back to slides.

00:15:43.380 --> 00:15:43.900
Okay.

00:15:43.980 --> 00:15:47.000
So that was a number of things we
found using the Instruments tool,

00:15:47.000 --> 00:15:48.760
and we fixed a couple of them.

00:15:48.760 --> 00:15:51.230
Instruments tool is great,
the Core Animation tool

00:15:51.230 --> 00:15:52.360
for your iOS apps.

00:15:52.410 --> 00:15:56.600
If you are writing an OSÂ X app,
Quartz Debug has some

00:15:56.680 --> 00:15:57.940
equivalent functionality.

00:15:57.940 --> 00:15:59.980
It will let you flash
the updated regions.

00:16:00.010 --> 00:16:03.290
We can tint scaled artwork as well.

00:16:03.560 --> 00:16:07.680
This is part of the Xcode suite,
but it no longer ships with Xcode now.

00:16:07.800 --> 00:16:11.440
So you can get it by going
into the Xcode menu bar,

00:16:11.440 --> 00:16:14.000
choosing Open Developer Tool,
More Developer Tools.

00:16:14.340 --> 00:16:16.570
This will bring you to a website,
and you just download the

00:16:16.570 --> 00:16:20.150
graphics tool for Xcode package,
and you'll have all the old tools,

00:16:20.150 --> 00:16:21.980
including Quartz Debug.

00:16:23.970 --> 00:16:28.230
So what can we do additionally
within Quartz 2D to optimize some

00:16:28.230 --> 00:16:30.490
of this drawing that we're doing?

00:16:31.710 --> 00:16:34.640
First of all,
the golden rule for all graphics is never

00:16:34.640 --> 00:16:36.340
draw more than you actually need to.

00:16:36.340 --> 00:16:40.490
It's a very simple rule,
but it's very easy to ignore.

00:16:42.080 --> 00:16:44.510
So if we look at our
finger-painting app here,

00:16:44.510 --> 00:16:47.870
and in this scenario,
the user is painting this long path.

00:16:47.960 --> 00:16:52.460
Maybe they're making a large drawing,
and it's fine in the beginning,

00:16:52.460 --> 00:16:55.540
but after we get a few
thousand points on our lines,

00:16:55.540 --> 00:16:58.040
we don't really need to be redrawing
the entire path every time.

00:16:58.040 --> 00:17:01.460
We don't need to be updating our
entire layer every time something

00:17:01.460 --> 00:17:06.190
little is added to the end of the path,
especially not at Retina display.

00:17:07.480 --> 00:17:08.690
So what do we need to do?

00:17:08.720 --> 00:17:12.180
So the set needs display in rect is
not designed for you to pass in the

00:17:12.180 --> 00:17:14.070
rect of your view or your layer.

00:17:14.100 --> 00:17:18.200
This is actually for you to
calculate the dirty region of your

00:17:18.200 --> 00:17:20.450
layer or view and pass that in.

00:17:20.460 --> 00:17:23.210
If you just called set needs display,
we're going to automatically

00:17:23.210 --> 00:17:24.590
invalidate the entire view.

00:17:24.600 --> 00:17:27.800
So if you pass this in,
the benefit you get is we're

00:17:27.820 --> 00:17:32.360
going to automatically set up your
CG context to clip to that area.

00:17:32.360 --> 00:17:35.230
And then when you submit your draw calls,
you don't have to change

00:17:35.270 --> 00:17:36.620
anything in your draw rect.

00:17:36.900 --> 00:17:39.280
We're going to automatically
call out anything that was

00:17:39.430 --> 00:17:41.980
submitted outside of that region,
and we will only draw to the

00:17:41.980 --> 00:17:43.560
area that you've marked dirty.

00:17:43.560 --> 00:17:45.820
So you get a nice big win.

00:17:45.820 --> 00:17:48.810
You don't have to change any of your
drawing code just by keeping track

00:17:48.810 --> 00:17:50.300
of what area has actually changed.

00:17:53.560 --> 00:17:56.500
Another thing we can do
is set up once and reuse.

00:17:56.530 --> 00:17:59.470
So inside our draw rect,
we don't want to be querying

00:17:59.470 --> 00:18:02.260
UI elements and see what is selected.

00:18:02.260 --> 00:18:05.570
It would be great to create
a variable for these.

00:18:05.570 --> 00:18:08.940
We'll hold the value of them when they
change and then use it when we draw.

00:18:08.940 --> 00:18:12.070
We don't want to be creating color
spaces and then creating a color

00:18:12.070 --> 00:18:15.100
from that color space and then
using that to do our drawing.

00:18:15.100 --> 00:18:17.440
This is something that we
can set up once and reuse.

00:18:17.440 --> 00:18:20.590
The best would be to set it
up on initialization and then

00:18:21.010 --> 00:18:22.400
reuse every time we draw.

00:18:24.490 --> 00:18:30.050
So this would be colors, path,
clip shapes, set up once, reuse.

00:18:30.410 --> 00:18:33.180
Even if you know it's going to change,
like our drawing color here,

00:18:33.290 --> 00:18:34.210
it is going to change.

00:18:34.310 --> 00:18:36.030
People are going to want to
paint with more than one color.

00:18:36.030 --> 00:18:39.450
But this is something that we
should change when they actually

00:18:39.550 --> 00:18:43.400
change the color and not query it
every time within our draw rect.

00:18:45.610 --> 00:18:50.100
Another thing we can do is we can
utilize these off-screen buffers

00:18:50.100 --> 00:18:54.900
or bitmap contexts to flatten
some of our drawing into an image.

00:18:54.900 --> 00:18:58.050
So if we have a CG path,
generally very quick to draw,

00:18:58.130 --> 00:19:02.430
once we add a few thousand points,
like a finger painting demo like this,

00:19:02.470 --> 00:19:04.400
it becomes a little slower.

00:19:04.400 --> 00:19:08.170
So if we're really only
updating this part of the path,

00:19:08.200 --> 00:19:12.380
wouldn't it be great if we could
just save the rest of it and only

00:19:12.380 --> 00:19:14.890
draw the part that actually changed?

00:19:15.000 --> 00:19:17.510
What we can do is we can
create a bitmap context,

00:19:17.530 --> 00:19:19.930
we can draw into there,
and then we can use that

00:19:19.930 --> 00:19:23.040
image to draw into our view,
and then on top of that we'll

00:19:23.040 --> 00:19:24.920
just draw what's changed.

00:19:26.610 --> 00:19:32.460
So let's take a look at a few of these
optimizations and put them into the app.

00:19:32.460 --> 00:19:36.770
Let me just turn off that tinting.

00:19:36.770 --> 00:19:36.770
Okay.

00:19:37.590 --> 00:19:39.150
So first of all,
we'll just take the initial

00:19:39.150 --> 00:19:40.160
behavior that we have here.

00:19:40.160 --> 00:19:44.100
If I just start going and drawing,
we start at 60 frames per second.

00:19:44.100 --> 00:19:47.070
And if I keep going, we're going to drop.

00:19:48.960 --> 00:19:51.970
And it doesn't actually bottom out.

00:19:51.970 --> 00:19:55.620
We're going to keep going down
and down and down until it

00:19:55.860 --> 00:19:57.490
becomes pretty much unusable.

00:19:57.500 --> 00:19:58.460
It's not even slow anymore.

00:19:58.460 --> 00:20:00.630
It's just unusable.

00:20:03.470 --> 00:20:06.270
So what we can do is we can
flatten these paths once we get

00:20:06.360 --> 00:20:07.700
over a certain number of points.

00:20:07.730 --> 00:20:09.540
We'll pick like 100, 200 points.

00:20:09.630 --> 00:20:12.960
Once we get that many points,
we can flatten our current drawing

00:20:12.960 --> 00:20:17.720
into an image and then use that as
our basis for the next segment of

00:20:17.780 --> 00:20:19.450
path that we're going to draw on top.

00:20:19.530 --> 00:20:23.690
So if I enable that option,
you'll notice as I'm going,

00:20:23.690 --> 00:20:25.850
we're still going to drop.

00:20:26.030 --> 00:20:28.160
We're still going to drop a lot.

00:20:28.810 --> 00:20:31.620
But we should stay above 10.

00:20:31.730 --> 00:20:34.600
So what happens there is
every once in a while,

00:20:34.600 --> 00:20:39.860
we're going to flatten all of our content
into the bitmap and then use that.

00:20:39.860 --> 00:20:43.240
So we're never actually drawing
more than a couple hundred points.

00:20:43.360 --> 00:20:46.590
And so this is going to give
us a consistent frame rate,

00:20:46.600 --> 00:20:49.090
and we're never going to go below here,
no matter how many more

00:20:49.120 --> 00:20:50.440
points we add to the path.

00:20:50.530 --> 00:20:55.060
So consistent frame rates are great
if they're not 10 frames per second,

00:20:55.060 --> 00:20:55.700
right?

00:20:56.380 --> 00:20:57.290
So what are we going to do?

00:20:57.300 --> 00:20:57.920
What's going wrong?

00:20:57.920 --> 00:20:59.760
We're flattening our content.

00:20:59.760 --> 00:21:01.500
Why is it taking so long to draw?

00:21:01.500 --> 00:21:04.590
Well, we need to look at what we're
actually drawing every frame,

00:21:04.590 --> 00:21:06.620
and maybe we're still drawing too much.

00:21:06.620 --> 00:21:09.880
Because what we're doing right now is
we're just setting set needs display.

00:21:09.880 --> 00:21:12.540
And we're going to be,
even though we have this image

00:21:12.570 --> 00:21:15.260
for our flattened content,
we're drawing this entire

00:21:15.530 --> 00:21:18.650
Retina resolution image into
the view every single frame.

00:21:18.650 --> 00:21:23.290
So earlier I mentioned the
instruments function where you can

00:21:23.290 --> 00:21:26.040
tint the areas that you're updating.

00:21:27.990 --> 00:21:30.810
This works great for most cases,
but it doesn't actually respect

00:21:31.000 --> 00:21:33.500
the clip rect for CG context.

00:21:33.530 --> 00:21:37.300
So we have a quick little
fix that we can put in.

00:21:37.410 --> 00:21:42.940
I'm just going to draw a one-point
red rectangle around the current

00:21:42.940 --> 00:21:45.190
clip rect whenever I get a draw call.

00:21:45.290 --> 00:21:48.390
So if I turn that on and I start drawing,
I don't know if you can see it,

00:21:48.460 --> 00:21:51.600
but it's around the entire view there,
and it doesn't go anywhere else.

00:21:51.700 --> 00:21:55.900
So every single time we draw,
we're going to draw the entire view.

00:21:55.990 --> 00:21:59.570
So let's take a look at how we
can fix that and go into Xcode.

00:22:03.390 --> 00:22:07.060
Okay, so this is our draw function here.

00:22:07.150 --> 00:22:10.880
So if we have a bitmap image from before,
we're going to draw that.

00:22:10.900 --> 00:22:13.610
If we don't have one yet,
then we're just going to fill

00:22:13.730 --> 00:22:15.140
with our background color.

00:22:15.140 --> 00:22:19.620
And then if we have any additional
path points to draw on top of there,

00:22:19.620 --> 00:22:23.850
we're going to add our path,
use our line width that we've already

00:22:23.860 --> 00:22:27.560
set once the user selected it,
and use our stroke color that

00:22:27.560 --> 00:22:30.370
we've already created once
the user selected a new color,

00:22:30.370 --> 00:22:31.960
and use those to draw our path.

00:22:32.920 --> 00:22:35.080
This here is if we have a
single point at the end,

00:22:35.080 --> 00:22:38.120
we can't draw a path with a single point,
so we're just going to draw

00:22:38.160 --> 00:22:41.100
an ellipse in the point where
the finger is currently down.

00:22:41.100 --> 00:22:45.980
And this is what I did here just to
give us a little visual feedback for

00:22:45.980 --> 00:22:48.750
what area we're actually drawing.

00:22:48.760 --> 00:22:52.360
So we just get the current clip rack,
and we're going to just

00:22:52.760 --> 00:22:55.210
draw this rectangle,
a red rectangle,

00:22:55.290 --> 00:22:57.920
around what the current clip rack is.

00:23:00.150 --> 00:23:04.840
Now if we take a look at what we're doing
when we add a new point to the path.

00:23:04.840 --> 00:23:08.080
So in here,
first thing we do -- this is another

00:23:08.080 --> 00:23:11.610
way you can optimize a little bit --
is we're getting our current point.

00:23:11.740 --> 00:23:15.030
First we're going to check,
is that point a significant distance

00:23:15.090 --> 00:23:16.900
away from the last one we've drawn?

00:23:17.020 --> 00:23:20.040
So if we know that these are almost
exactly on the same point and we're

00:23:20.150 --> 00:23:23.510
just getting some very high-resolution
touch information in from the system,

00:23:23.510 --> 00:23:27.400
we can maybe skip this point and wait
for one that's more further away.

00:23:27.440 --> 00:23:31.350
And we're going to keep track of our
current point and our previous point,

00:23:31.350 --> 00:23:34.560
and we'll add the new point to our path.

00:23:34.560 --> 00:23:38.160
Then if we have too
many points in our path,

00:23:38.160 --> 00:23:41.270
we'll go ahead and flatten all
of our current content into that

00:23:41.340 --> 00:23:45.370
bitmap image that we're going to use
that we saw in the draw rect when

00:23:45.370 --> 00:23:47.770
first we check and draw from there.

00:23:48.030 --> 00:23:50.880
And then this is really
what we should be doing.

00:23:50.980 --> 00:23:53.200
This is what we're doing now,
just setting set needs display.

00:23:53.200 --> 00:23:55.080
We need to see a lot less of these.

00:23:55.210 --> 00:24:00.730
So just -- this is like five lines
here for this particular case.

00:24:00.880 --> 00:24:02.780
And we're going to get an
enormous benefit from doing this.

00:24:02.800 --> 00:24:06.130
We just take the current point,
the previous point.

00:24:06.140 --> 00:24:08.240
We'll figure out the
bounding rectangle for there.

00:24:08.260 --> 00:24:11.690
We'll compensate for the line width that
we're going to be drawing along the path.

00:24:11.800 --> 00:24:14.200
So we include all of the drawing.

00:24:14.310 --> 00:24:17.020
And then we'll set that instead
of just doing set needs display.

00:24:17.210 --> 00:24:20.310
So let's turn some of these
options on within the app.

00:24:22.290 --> 00:24:25.060
So this is what we have currently,
drawing the whole thing.

00:24:25.130 --> 00:24:30.450
And now, if we turn this on,
you notice all these tiny little

00:24:30.450 --> 00:24:32.500
rectangles we get along the path.

00:24:32.620 --> 00:24:37.160
And that's the only area we're
actually updating during that call.

00:24:37.380 --> 00:24:39.140
And we haven't changed
our draw code one bit.

00:24:39.190 --> 00:24:40.440
So we got a nice boost there.

00:24:40.440 --> 00:24:43.150
And if you've been
watching the frame rate,

00:24:43.190 --> 00:24:45.350
you'll notice that we got a
nice performance boost as well.

00:24:45.360 --> 00:24:47.730
We're staying at 60 now.

00:24:49.330 --> 00:24:52.090
You do see a little hiccup once in a
while when we render to the bitmap,

00:24:52.150 --> 00:24:55.720
but in general, we can stay at a pretty
responsive rate there.

00:24:55.760 --> 00:24:57.880
Okay.

00:24:57.880 --> 00:25:00.440
Go back to our slides.

00:25:04.430 --> 00:25:06.160
So those were some great optimizations.

00:25:06.160 --> 00:25:10.080
We already got a lot of speed up just by
looking at some of the stuff we can do

00:25:10.080 --> 00:25:14.400
with Quartz 2D and correctly specifying
our set needs display and erect.

00:25:14.460 --> 00:25:18.170
We're going to take a look at a few other
things we can do within Core Animation to

00:25:18.170 --> 00:25:20.070
provide a little benefit as well.

00:25:20.710 --> 00:25:23.430
So the first thing would be
an alternative to the bitmap

00:25:23.570 --> 00:25:25.650
context that we're using.

00:25:25.650 --> 00:25:28.080
What you can do if you're working
with views and you know you

00:25:28.080 --> 00:25:30.860
have some content that's static,
it's not going to change much,

00:25:30.860 --> 00:25:33.400
you can separate that all
out into another view,

00:25:33.400 --> 00:25:35.180
put your canvas on top.

00:25:35.340 --> 00:25:38.290
In this case, you would have to do
transparent rendering for that.

00:25:38.420 --> 00:25:41.680
Let's say we wanted to render
onto an actual image of a canvas

00:25:41.690 --> 00:25:43.740
sheet instead of a gray square.

00:25:43.740 --> 00:25:45.090
This would be a great candidate for that.

00:25:45.200 --> 00:25:49.940
And what Core Animation will
automatically do for you is it will

00:25:49.940 --> 00:25:54.740
take any views in your hierarchy and
will maintain a bitmap cache of those

00:25:54.740 --> 00:25:58.590
views and will composite them together
in hardware when it's time to display.

00:25:58.710 --> 00:26:00.860
So this is something
you can get for free.

00:26:01.050 --> 00:26:03.930
You don't even have to go down
to the Core Animation level.

00:26:04.200 --> 00:26:09.110
You can just do this by separating
out static content into static views.

00:26:10.420 --> 00:26:13.610
If you are working with layers and
you want to have this fine-tuned

00:26:13.610 --> 00:26:18.740
control on a per-layer basis,
you can use the property

00:26:18.740 --> 00:26:22.030
should rasterize on CA layer.

00:26:22.040 --> 00:26:25.090
So this is the same effect that
we're doing with the views,

00:26:25.130 --> 00:26:28.120
but you can specify it on
any layer in your layer tree.

00:26:28.120 --> 00:26:31.790
And so what this is going to do is
it's going to composite that layer,

00:26:31.840 --> 00:26:34.600
all of its children together
into a bitmap cache,

00:26:34.600 --> 00:26:37.520
and then we'll use that to draw from
again whenever it needs to be updated.

00:26:38.390 --> 00:26:43.740
So if you have this layer rasterized and
you scale it or rotate it or fade it,

00:26:43.800 --> 00:26:44.270
that's great.

00:26:44.280 --> 00:26:46.250
We can redraw again from the cache.

00:26:46.250 --> 00:26:49.650
If you have a layer whose
contents changed a lot,

00:26:49.650 --> 00:26:52.680
like a movie or a particle
system or something like that,

00:26:52.680 --> 00:26:56.030
this is not a good candidate because this
is running into the case we were looking

00:26:56.030 --> 00:26:57.740
at earlier with those hits and misses.

00:26:57.740 --> 00:27:00.480
You want to open up instruments
if you're getting red on there.

00:27:00.480 --> 00:27:02.530
If you're changing your
content every frame,

00:27:02.530 --> 00:27:04.310
we have to regenerate the new bitmap.

00:27:04.360 --> 00:27:06.320
It's actually a little bit extra work.

00:27:06.340 --> 00:27:10.840
When you do rasterize your layer,
this is going to inherently

00:27:10.850 --> 00:27:12.460
lock it to a specific size.

00:27:12.460 --> 00:27:16.030
We create a size of this bitmap
cache to rasterize your layer to,

00:27:16.030 --> 00:27:18.060
and then it's fixed to that size.

00:27:18.100 --> 00:27:20.430
So how do you specify what size you want?

00:27:20.480 --> 00:27:23.300
You want to use the
rasterization scale property.

00:27:23.300 --> 00:27:26.680
You want to set that whenever you
set should rasterize on your layer.

00:27:26.680 --> 00:27:29.350
In general,
if you've set your content scale,

00:27:29.350 --> 00:27:33.080
you'd also want to set your
rasterization scale to match that.

00:27:33.100 --> 00:27:36.320
If you know that you're going to be
scaling up your layer to a specific size,

00:27:36.320 --> 00:27:36.320
you want to set that.

00:27:36.320 --> 00:27:37.140
If you know that you're
going to be scaling up your

00:27:37.140 --> 00:27:39.060
layer to a much larger size,
you may even want to set this to

00:27:39.060 --> 00:27:42.740
four or higher to have that extra
data there available for you when you

00:27:42.740 --> 00:27:43.310
want to render it at a larger size.

00:27:43.320 --> 00:27:48.320
So let's take a little bit more
in-depth look about how this works.

00:27:48.320 --> 00:27:50.320
So this is our standard layer tree.

00:27:50.320 --> 00:27:52.320
We have a blue square layer.

00:27:52.320 --> 00:27:56.410
We have an image layer as a child,
and we have a text layer

00:27:56.410 --> 00:27:58.320
as a child as well.

00:27:58.320 --> 00:28:00.320
So normally when we
render this to the screen,

00:28:00.320 --> 00:28:04.290
we draw the parent,
and then we draw the image underneath,

00:28:04.320 --> 00:28:06.300
and then we draw the
text underneath as well.

00:28:06.300 --> 00:28:10.300
If I go and enable should
rasterize on the blue layer here,

00:28:10.300 --> 00:28:13.220
something a little different
is going to happen.

00:28:13.320 --> 00:28:15.300
The first time we render,
we're going to create this cache buffer.

00:28:15.300 --> 00:28:17.300
We're going to render
everything into there,

00:28:17.300 --> 00:28:20.220
and then we render from
there to the screen.

00:28:20.370 --> 00:28:22.320
So that's the extra step
I was talking about.

00:28:22.320 --> 00:28:25.550
If you're going to be doing this a lot,
sometimes it can actually be a little

00:28:25.550 --> 00:28:27.320
bit slower than not doing it at all.

00:28:27.440 --> 00:28:29.780
And the benefit for this is
when we need to draw again,

00:28:29.780 --> 00:28:31.840
we can redraw right from the cache.

00:28:31.840 --> 00:28:38.060
So if I was to change the scale on this
layer to be a quarter instead of a half,

00:28:38.070 --> 00:28:41.460
and then Core Animation is going
to make this nice animation for me,

00:28:41.460 --> 00:28:44.580
every frame of that animation is
going to redraw right from the cache.

00:28:44.580 --> 00:28:46.340
We don't have to go to
each individual layer.

00:28:46.340 --> 00:28:48.800
So this is a big benefit if
you have a large layer tree.

00:28:48.910 --> 00:28:52.380
It doesn't need to be recomposited a lot.

00:28:52.380 --> 00:28:54.940
So if you have a complex
something like that,

00:28:55.090 --> 00:28:58.530
you can save that off as an
image and just redraw from there.

00:28:59.990 --> 00:29:02.160
So a couple of caveats.

00:29:02.200 --> 00:29:04.900
This rasterization occurs
before the mask is applied.

00:29:04.900 --> 00:29:07.630
So if you have a mask on your layer,
you're looking to speed that up.

00:29:07.690 --> 00:29:10.300
This probably isn't the
right option for that.

00:29:10.300 --> 00:29:12.910
And like I said,
caching and not reusing is more

00:29:12.910 --> 00:29:14.950
expensive than not caching at all.

00:29:15.140 --> 00:29:18.400
And they do take up memory,
these off-screen caches.

00:29:18.400 --> 00:29:20.590
So you can't just go around and
set these on all of your layers.

00:29:20.590 --> 00:29:23.510
You're going to gobble
up a ton of our RAM.

00:29:25.330 --> 00:29:27.190
Alpha Blending,
we've touched on a few times.

00:29:27.190 --> 00:29:29.160
If you can do it opaque, do it opaque.

00:29:29.220 --> 00:29:33.300
And if you're supplying image content
to any of your views or layers,

00:29:33.300 --> 00:29:36.570
you want to make sure your
images are opaque as well.

00:29:36.570 --> 00:29:39.340
If they need to be transparent,
then if that's what you

00:29:39.340 --> 00:29:41.530
need for the visual field,
then go for it.

00:29:41.630 --> 00:29:43.980
But if you think that you're
providing an opaque image,

00:29:44.060 --> 00:29:46.540
make sure you're actually
providing an opaque image.

00:29:46.540 --> 00:29:49.540
A lot of times you've designed
your image to be opaque within

00:29:49.540 --> 00:29:52.480
whatever image editor you use,
and for whatever reason,

00:29:52.480 --> 00:29:55.180
they've included the alpha
channel in the image.

00:29:55.200 --> 00:29:57.980
So in this case,
we have an image who has an

00:29:57.980 --> 00:30:00.200
alpha channel who is all ones.

00:30:00.200 --> 00:30:03.260
You want to check and make
sure we have this here that

00:30:03.330 --> 00:30:05.440
says alpha channel no in there.

00:30:06.310 --> 00:30:08.880
If we do get an image from you
and it has an alpha channel,

00:30:08.880 --> 00:30:11.330
we have to assume that it has
some transparency and we are

00:30:11.330 --> 00:30:12.550
going to take the slower path.

00:30:14.990 --> 00:30:16.690
Drop shadows look great.

00:30:16.690 --> 00:30:18.180
They are expensive.

00:30:18.180 --> 00:30:21.750
There's a couple of ways you
could mitigate this cost.

00:30:21.860 --> 00:30:26.560
If you need drop shadows on your
element and you know the general shape,

00:30:26.560 --> 00:30:30.710
the opaque shape of your layer,
you can specify a shadow path,

00:30:30.710 --> 00:30:34.870
which is a CG path,
to define that region of your layer.

00:30:34.880 --> 00:30:38.100
And then we can generate the shadow
based on that path instead of

00:30:38.150 --> 00:30:42.260
inspecting every pixel of your output
and generating the shadow from there.

00:30:42.870 --> 00:30:47.040
The other one we just talked about,
you can use rasterization.

00:30:47.160 --> 00:30:50.840
CA layer should rasterize
to include this shadow.

00:30:50.920 --> 00:30:52.780
It does get included
in the rasterized copy,

00:30:52.780 --> 00:30:56.110
so you can generate it
once and then reuse it.

00:30:56.440 --> 00:31:01.400
And if you do supply the shadow path
and you scale or move your layer,

00:31:01.400 --> 00:31:04.710
we'll scale and move the shadow
path as well so we can keep

00:31:04.710 --> 00:31:09.300
regenerating the shadow path based
on the one you originally supplied.

00:31:09.430 --> 00:31:12.130
So if I have an image like
this and I know I want a nice

00:31:12.250 --> 00:31:17.100
big drop shadow behind there,
instead of just turning on the shadow,

00:31:17.250 --> 00:31:21.200
if I actually just
supply this circle here,

00:31:21.320 --> 00:31:24.010
we can use that to generate it instead.

00:31:24.920 --> 00:31:28.400
Next is a brand-new API we've
added to Core Animation.

00:31:28.480 --> 00:31:31.600
It's called Draws Asynchronously.

00:31:31.600 --> 00:31:36.990
What this does is it introduces a
second method of submitting your

00:31:36.990 --> 00:31:42.630
Core graphics drawing calls whenever
you override the drawn context or draw

00:31:42.630 --> 00:31:45.810
rect methods to do your Quartz drawing.

00:31:45.820 --> 00:31:50.060
The normal drawing, if you submit a call,
we're going to block,

00:31:50.070 --> 00:31:52.870
perform all of that rendering,
and then we'll return

00:31:52.870 --> 00:31:55.150
control back to you,
and you go on about your business

00:31:55.260 --> 00:31:58.690
doing whatever useful work you're
going to do for your users.

00:31:58.880 --> 00:32:03.740
If you have enabled Draws Asynchronously,
we can take all those commands and we'll

00:32:03.740 --> 00:32:08.020
execute the rendering in parallel and
we'll return immediately to your app so

00:32:08.040 --> 00:32:14.140
you can do some processing at the same
time as we're rendering the graphics.

00:32:14.310 --> 00:32:16.050
So to take a look at
this a little better,

00:32:16.140 --> 00:32:17.760
this is our normal drawing mode.

00:32:17.760 --> 00:32:20.820
If I have my custom
CA layer subclass here,

00:32:20.820 --> 00:32:24.750
like, for instance,
my canvas layer in the painting app,

00:32:24.830 --> 00:32:26.890
I get my drawn context.

00:32:26.980 --> 00:32:29.300
I'm going to say, okay, draw this image.

00:32:29.410 --> 00:32:32.690
Quartz goes, draws that image,
and then come back to me,

00:32:32.690 --> 00:32:35.740
and I get to do whatever
other work I'm going to do.

00:32:36.560 --> 00:32:40.480
In the second scenario,
if I've turned on draws asynchronously,

00:32:40.480 --> 00:32:42.110
we get the drawn context.

00:32:42.120 --> 00:32:45.700
Then I can submit any number
of drawing calls that I want.

00:32:45.700 --> 00:32:49.130
I'm going to return
immediately into my process,

00:32:49.180 --> 00:32:53.960
and I'll be able to finish doing whatever
work I want while Quartz is rendering.

00:32:56.930 --> 00:32:59.430
So first we should point out
that this is not always a win,

00:32:59.430 --> 00:33:01.740
hence we've disabled it by default.

00:33:01.840 --> 00:33:04.940
So this is generally helpful
when you're filling large areas

00:33:04.940 --> 00:33:09.140
of your context with images,
rectangles, shadings,

00:33:09.140 --> 00:33:12.780
especially any non-opaque
content if you are doing alpha

00:33:12.780 --> 00:33:14.940
blending within your context.

00:33:15.720 --> 00:33:17.570
and it really is a case-by-case basis.

00:33:17.680 --> 00:33:20.390
There's no clear-cut way to say
whether you want this on or not.

00:33:20.470 --> 00:33:23.740
So this is something you're going
to want to open up instruments on,

00:33:23.740 --> 00:33:26.760
do some profiling,
get some frame rate statistics,

00:33:26.870 --> 00:33:28.760
figure out whether this is
actually a win or not for you.

00:33:28.760 --> 00:33:37.480
It might actually prove to be less
performant than original rendering was.

00:33:37.480 --> 00:33:37.480
So it's really something
you need to measure,

00:33:37.480 --> 00:33:37.480
measure, measure.

00:33:38.230 --> 00:33:41.140
So now we'll take a look at a
few of these and see if they

00:33:41.140 --> 00:33:43.340
actually do anything for our app.

00:33:43.820 --> 00:33:51.660
First bring up an app here that is
doing rendering in a CG context as well.

00:33:51.660 --> 00:33:53.300
We have a lot of squares around here.

00:33:53.300 --> 00:33:54.320
It's going pretty well.

00:33:54.320 --> 00:33:58.070
We have about 60 frames
per second on here.

00:33:58.110 --> 00:34:03.640
If I start drawing non-opaque colors,
you notice we take a little hit there.

00:34:03.640 --> 00:34:05.520
We're down to about 30.

00:34:05.520 --> 00:34:07.790
This also happens if I start
drawing a lot of images as well

00:34:07.790 --> 00:34:09.350
and we're updating every frame.

00:34:09.350 --> 00:34:12.420
We're going down to about four
frames per second in this case

00:34:12.420 --> 00:34:14.440
with the normal rendering.

00:34:14.440 --> 00:34:18.110
If I do turn on this asynchronous
rendering for our layer,

00:34:18.170 --> 00:34:20.440
you notice we immediately speed back up.

00:34:20.440 --> 00:34:22.270
We can do the images.

00:34:22.270 --> 00:34:24.940
We can do transparent colors.

00:34:24.940 --> 00:34:29.160
We can even bump up the number of objects
on the screen to be a ridiculous amount.

00:34:29.160 --> 00:34:32.020
And then see what happens
if we switch this back off.

00:34:32.360 --> 00:34:34.400
We kind of just crawl to a halt there.

00:34:34.400 --> 00:34:36.130
So this is the optimal case.

00:34:36.140 --> 00:34:36.890
It's a big win here.

00:34:36.920 --> 00:34:44.300
But it is something you want
to test case-by-case basis.

00:34:44.300 --> 00:34:44.300
So in light of that --

00:34:50.490 --> 00:34:52.400
Let's get back to where we were in here.

00:34:52.400 --> 00:34:55.840
And this was our previous performance.

00:34:55.840 --> 00:34:56.740
We're holding 60.

00:34:56.740 --> 00:34:57.500
This was great.

00:34:57.500 --> 00:35:00.270
If you take a look at how much time
we are spending in our draw call,

00:35:00.270 --> 00:35:02.720
it's about one millisecond,
maybe a little bit more.

00:35:02.720 --> 00:35:06.280
If I get rid of this and we
turn on draws asynchronously,

00:35:06.280 --> 00:35:09.720
we've already done so
much optimization already.

00:35:09.720 --> 00:35:13.020
We're still at 60,
so it hasn't made a huge impact here.

00:35:13.020 --> 00:35:15.690
But what you will notice is
if you look at the time we're

00:35:15.810 --> 00:35:18.450
spending in our draw call now,
we're down to about 5% of

00:35:18.550 --> 00:35:19.890
what we were spending before.

00:35:20.100 --> 00:35:23.870
So you can use this to do some other
useful functionality for your app.

00:35:24.750 --> 00:35:28.470
Okay, well,
we have taken an underperforming app

00:35:28.800 --> 00:35:32.970
that didn't support Retina display,
and we've added a bunch of enhancements.

00:35:33.070 --> 00:35:36.660
We now fully support Retina display,
and we provide a nice, fluid,

00:35:36.660 --> 00:35:40.360
smooth interaction
experience for our users.

00:35:40.530 --> 00:35:43.570
And this concludes the
portion of our session dealing

00:35:43.570 --> 00:35:45.410
with graphics optimization.

00:35:45.650 --> 00:35:47.540
And now I'd like to bring up
Mike Funk to tell you a little

00:35:47.540 --> 00:35:50.000
bit about CG Display Stream.

00:35:57.260 --> 00:35:58.360
Thank you, Tim.

00:35:58.360 --> 00:36:00.580
So I'm going to be talking
about CG Display Stream.

00:36:00.580 --> 00:36:04.240
This is a new API for high-performance
screen capture that we're

00:36:04.240 --> 00:36:05.940
introducing in Mountain Lion.

00:36:05.940 --> 00:36:08.660
So far, this is desktop-specific.

00:36:08.660 --> 00:36:11.540
Now, when I say screen capture,
what I'm talking about is

00:36:11.600 --> 00:36:14.360
basically taking screenshots,
which you can use for a

00:36:14.380 --> 00:36:15.840
lot of different things.

00:36:15.860 --> 00:36:20.140
Maybe you want to do a remote desktop or
remote display type of an application,

00:36:20.140 --> 00:36:24.340
or maybe you just want to take
screenshots to record to a movie

00:36:24.340 --> 00:36:26.590
or to save to a file for later.

00:36:27.100 --> 00:36:31.360
So why is taking a screen
capture a performance issue?

00:36:31.360 --> 00:36:35.860
Well, frequently,
you're being tunneled down a

00:36:35.860 --> 00:36:39.320
very low-performance bottleneck.

00:36:39.350 --> 00:36:42.170
So for one thing,
you end up doing round-trip copies

00:36:42.170 --> 00:36:44.000
between VRAM and RAM and VRAM.

00:36:44.000 --> 00:36:46.460
That's a very expensive operation.

00:36:46.460 --> 00:36:49.300
Every time you cross the
boundary between VRAM and RAM,

00:36:49.300 --> 00:36:51.130
that ends up being very expensive.

00:36:51.180 --> 00:36:53.750
Of course,
now we have four times as many pixels.

00:36:53.750 --> 00:36:55.330
That makes it a lot worse.

00:36:56.420 --> 00:36:59.970
Ideally, what you want to do is you
want to do the screen capture,

00:36:59.970 --> 00:37:02.380
have it stay in VRAM,
and then immediately do

00:37:02.430 --> 00:37:05.650
whatever you need to do with
the GPU while it's still there,

00:37:05.650 --> 00:37:09.070
and then pull it out to RAM to
stream over the network or whatever

00:37:09.070 --> 00:37:10.820
you were going to do with it.

00:37:10.880 --> 00:37:11.910
So what's the difference between
a screen capture and a VRAM?

00:37:12.420 --> 00:37:15.440
To illustrate this,
this is the traditional

00:37:15.440 --> 00:37:17.540
display capture situation.

00:37:17.540 --> 00:37:21.150
So everything above the line is VRAM,
everything below is RAM.

00:37:21.160 --> 00:37:24.500
So your frame buffer contents
start in VRAM by definition.

00:37:24.500 --> 00:37:27.940
Now usually the first thing
that ends up happening is it

00:37:28.170 --> 00:37:29.790
gets copied over into RAM.

00:37:29.790 --> 00:37:34.570
And again,
this is a very expensive operation.

00:37:34.570 --> 00:37:35.780
But you're not done with it.

00:37:35.780 --> 00:37:39.760
You want to scale it or you want
to do some sort of compression or

00:37:39.760 --> 00:37:42.380
encoding or color space conversion.

00:37:42.400 --> 00:37:44.290
And so--but you want
to do that on the GPU,

00:37:44.300 --> 00:37:47.150
so you end up copying it back into RAM.

00:37:48.950 --> 00:37:51.400
Then you can do your operations.

00:37:51.550 --> 00:37:54.220
And then finally,
you pull it back over where it's

00:37:54.320 --> 00:37:57.430
ready for use by your application.

00:37:59.060 --> 00:38:03.220
So this is the traditional
display capture pipeline.

00:38:03.220 --> 00:38:07.640
What we'd like to show you is what
the CG Display Stream offers you,

00:38:07.640 --> 00:38:10.140
is the high-performance
variation on this.

00:38:10.140 --> 00:38:13.800
Again, you start out in VRAM.

00:38:13.800 --> 00:38:17.150
However, you do the capture right
away and it stays there,

00:38:17.150 --> 00:38:19.600
and you can process the data right away.

00:38:19.600 --> 00:38:23.840
90% of the things that you want to
do with the GPU you can do before

00:38:23.840 --> 00:38:26.130
you ever have to pull it into RAM.

00:38:27.310 --> 00:38:29.900
So you're pretty much
all done with it in VRAM.

00:38:29.980 --> 00:38:35.150
You copy it back out and
now it is available to you.

00:38:37.900 --> 00:38:41.280
So again, this is a traditional
display capture pipeline,

00:38:41.280 --> 00:38:44.960
and this is the high-performance
one that is much more desirable.

00:38:47.350 --> 00:38:49.800
So before we go any further,
let's look at what some of your options

00:38:49.800 --> 00:38:52.740
are already for doing display capture.

00:38:52.740 --> 00:38:57.200
The simplest one is
CG display create image.

00:38:57.270 --> 00:38:59.470
It's very simple,
and if it does what you need it to do,

00:38:59.580 --> 00:39:00.740
continue using it.

00:39:00.750 --> 00:39:02.610
Basically,
you just provide it with a display

00:39:02.610 --> 00:39:03.940
ID of the display you're interested in.

00:39:03.940 --> 00:39:08.600
It gives you back a CG image that
you can do whatever you want with.

00:39:08.600 --> 00:39:12.700
This is ideal for if you just
want to do a one-shot thing.

00:39:12.700 --> 00:39:16.290
There's also a recording...

00:39:16.480 --> 00:39:19.260
API in AV Foundation.

00:39:19.340 --> 00:39:20.050
It's very simple.

00:39:20.110 --> 00:39:21.400
It's very effective.

00:39:21.400 --> 00:39:23.890
You start recording.

00:39:23.970 --> 00:39:25.120
You record your data.

00:39:25.160 --> 00:39:27.850
You tell it when to stop,
and it will save to a QuickTime file.

00:39:27.870 --> 00:39:31.400
Again, if that's all you want to do,
then this is perfect.

00:39:31.400 --> 00:39:35.990
But for a lot of applications,
you need more functionality than that.

00:39:36.110 --> 00:39:40.800
Finally, one thing people have resorted
to is raw frame buffer access.

00:39:41.270 --> 00:39:43.870
This is very hacky and kludgy.

00:39:43.900 --> 00:39:45.330
It's very difficult to do.

00:39:45.340 --> 00:39:49.340
We don't really-- We don't offer any
supported API for this right now,

00:39:49.340 --> 00:39:54.030
so if this is what you're doing,
please do not.

00:39:55.180 --> 00:39:57.680
Finally,
so that brings us to CG Display Stream.

00:39:57.680 --> 00:40:00.940
So, again,
it is a real-time display capture API.

00:40:00.940 --> 00:40:02.240
It is mountain-line only.

00:40:02.240 --> 00:40:05.820
You can use it for, like,
the non-interactive applications.

00:40:05.840 --> 00:40:09.070
If you want to take individual
screenshots or do a screen recording,

00:40:09.070 --> 00:40:10.300
you can use it for that.

00:40:10.400 --> 00:40:12.580
But unlike those other
APIs that we had before,

00:40:12.580 --> 00:40:15.560
you can also use it for
interactive real-time applications.

00:40:15.610 --> 00:40:19.180
So if you wanted to write a VNC server,
this would be perfect for that.

00:40:19.180 --> 00:40:22.370
If you wanted to have remote display,
this would be perfect for that.

00:40:23.020 --> 00:40:27.400
There's also classes of display devices,
like USB projectors, for example,

00:40:27.480 --> 00:40:31.120
which need to get the contents
of the frame buffer to display,

00:40:31.120 --> 00:40:32.720
but they're not traditional
display devices.

00:40:32.720 --> 00:40:34.700
They don't plug into a display port.

00:40:34.730 --> 00:40:39.280
So you have to have some mechanism
for streaming them out over USB.

00:40:39.280 --> 00:40:41.690
This is perfect for that as well.

00:40:43.660 --> 00:40:45.480
So, when do you want to use it?

00:40:45.480 --> 00:40:48.930
If you need to do real-time
processing of screen updates,

00:40:48.930 --> 00:40:51.880
obviously that's pretty
much your only choice.

00:40:51.880 --> 00:40:55.180
It is integrated with
CFRunLoop and Dispatch Queues.

00:40:55.180 --> 00:40:57.320
You can use either one of those.

00:40:57.320 --> 00:41:02.010
It gives you GPU-based image
scaling and color space conversion,

00:41:02.010 --> 00:41:03.650
among other things.

00:41:04.210 --> 00:41:09.890
Another very handy feature is it gives
you update recs for each new capture.

00:41:09.890 --> 00:41:13.150
So, whenever we give you a new capture,
we'll give you a set of recs

00:41:13.150 --> 00:41:16.500
that tells you exactly what has
changed since the previous one.

00:41:16.500 --> 00:41:20.100
So, for example, if you're doing a remote
desktop type of an application,

00:41:20.100 --> 00:41:22.620
you only want to send over
the network what has changed

00:41:22.620 --> 00:41:24.190
since the previous update.

00:41:24.200 --> 00:41:26.030
You want to minimize
your network bandwidth,

00:41:26.030 --> 00:41:27.310
and this allows you to do that.

00:41:29.810 --> 00:41:31.740
The API itself is very simple.

00:41:31.850 --> 00:41:35.880
First thing you have to do
is create a display stream.

00:41:35.880 --> 00:41:37.980
This is one of two functions
that you can use to do that.

00:41:37.980 --> 00:41:41.640
This is what you would use if you
wanted to use this with CFRunLoop.

00:41:41.660 --> 00:41:44.770
There's another one that's very
similar for if you wanted something

00:41:44.770 --> 00:41:46.500
you can use with dispatch queues.

00:41:46.760 --> 00:41:50.650
So you just provide the display ID,
the width and the height of the

00:41:50.670 --> 00:41:52.800
image that you want to capture.

00:41:52.800 --> 00:41:54.500
If it's different from
what you are capturing,

00:41:54.500 --> 00:41:56.800
we will scale it on the GPU for you.

00:41:56.800 --> 00:41:59.960
And also the pixel format
that you want it in.

00:41:59.960 --> 00:42:02.590
There's also a properties
dictionary where you can specify

00:42:02.590 --> 00:42:03.960
a lot of different options.

00:42:03.960 --> 00:42:07.300
And then finally you provide a
handler function that's going to be

00:42:07.300 --> 00:42:10.950
invoked every single time there's
another screen capture for you.

00:42:12.350 --> 00:42:15.480
Some of the properties here,
you can specify a source rect,

00:42:15.620 --> 00:42:19.000
so if you're not interested in
capturing the whole display,

00:42:19.000 --> 00:42:22.130
just a subset of it, you can do that.

00:42:22.180 --> 00:42:24.770
You can tell us that
you're not interested in

00:42:24.770 --> 00:42:27.480
preserving the aspect ratio,
for example.

00:42:27.540 --> 00:42:30.220
Right now,
if the bounds that you give us for

00:42:30.220 --> 00:42:34.760
the capture are not the same aspect
ratio as what you're capturing from,

00:42:34.760 --> 00:42:37.380
we'll put in black bars
to avoid stretching.

00:42:37.380 --> 00:42:39.940
But if you don't want us to do that,
we won't do that with this option.

00:42:39.940 --> 00:42:42.250
You can specify a color
space for your output.

00:42:42.260 --> 00:42:45.110
You can also specify a queue depth.

00:42:45.220 --> 00:42:48.540
And basically, this is,
if you wanted to operate on

00:42:48.540 --> 00:42:51.650
these captures in parallel,
you can do that.

00:42:51.660 --> 00:42:54.540
This is how many captures we
keep around in our buffer at

00:42:54.540 --> 00:42:56.040
once for you to work with.

00:42:56.120 --> 00:42:57.040
It defaults to three.

00:42:57.040 --> 00:43:00.470
In practice,
you probably should not go beyond eight,

00:43:00.470 --> 00:43:04.270
simply because at some point,
you start using up a tremendous

00:43:04.280 --> 00:43:07.090
amount of memory and VRAM,
and it's no longer a

00:43:07.090 --> 00:43:09.060
performance win for you.

00:43:11.010 --> 00:43:13.100
So once you have your
display stream object,

00:43:13.100 --> 00:43:17.000
these three functions are
all there is to managing it.

00:43:17.120 --> 00:43:20.570
The first one allows you to get
a run loop source object out

00:43:20.570 --> 00:43:22.080
of your display stream object.

00:43:22.210 --> 00:43:23.390
You just put that into your run loop.

00:43:23.400 --> 00:43:25.800
It will not immediately start capturing.

00:43:25.800 --> 00:43:29.400
For that, you have to tell it you have
to use CG display stream start,

00:43:29.520 --> 00:43:32.700
and you basically just use
these start and stop functions.

00:43:32.700 --> 00:43:34.700
You can start and stop as
many times as you want.

00:43:34.700 --> 00:43:37.130
It's not a one-shot thing.

00:43:38.250 --> 00:43:42.080
This is the prototype for the
handler that you install when

00:43:42.080 --> 00:43:43.800
you create the display stream.

00:43:43.800 --> 00:43:44.830
You'll notice this is a block.

00:43:44.890 --> 00:43:46.640
This is not going to be
just a function pointer,

00:43:46.640 --> 00:43:47.870
but it's an arbitrary block.

00:43:47.880 --> 00:43:50.680
And the parameters for
this block are what we're,

00:43:50.680 --> 00:43:53.820
that's the information that
we're providing to you with

00:43:53.820 --> 00:43:55.530
each one of these updates.

00:43:55.540 --> 00:43:59.260
There's a status flag,
which is generally just going to say,

00:43:59.260 --> 00:44:01.220
we have a new capture for you.

00:44:01.220 --> 00:44:04.330
If you had stopped the stream,
it might indicate that the stream

00:44:04.330 --> 00:44:07.670
is now stopped and you shouldn't
expect anything more from us.

00:44:08.600 --> 00:44:09.920
There is a timestamp.

00:44:09.960 --> 00:44:14.740
The timestamp is in Mach absolute time,
so that is a very accurate,

00:44:14.790 --> 00:44:17.350
very high-resolution timestamp.

00:44:17.380 --> 00:44:20.640
We're giving you the capture
itself in the form of an IOSurface,

00:44:20.640 --> 00:44:23.670
which is something that I'll
explain in just a moment.

00:44:23.680 --> 00:44:29.260
But essentially, an IOSurface is an
abstract object that...

00:44:29.780 --> 00:44:33.670
Can represent an image
that's stored in VRAM or RAM,

00:44:33.670 --> 00:44:36.700
or it could be something that's
synchronized across both.

00:44:36.700 --> 00:44:39.300
And if something has to live in
both places at the same time,

00:44:39.300 --> 00:44:42.400
it does the right thing as far
as synchronizing between them.

00:44:42.430 --> 00:44:44.140
It's very high performance.

00:44:44.170 --> 00:44:48.970
And then finally,
you get an update object,

00:44:48.970 --> 00:44:52.290
which is something you can query
to get more information about the

00:44:52.290 --> 00:44:52.290
update that you just received.

00:44:53.090 --> 00:44:56.210
One of the things that you can do
with this update object is you can

00:44:56.220 --> 00:44:58.890
query it to get the update rects.

00:44:58.990 --> 00:45:02.660
Again,
this is just telling you what has changed

00:45:02.740 --> 00:45:05.980
in this update since the last one.

00:45:06.170 --> 00:45:09.850
If you have multiple updates that you
want to coalesce into a single update,

00:45:09.910 --> 00:45:12.720
the second function will do that for you.

00:45:12.720 --> 00:45:16.070
So, for example,
if you do have a remote desktop

00:45:16.170 --> 00:45:21.540
server and you're streaming your
screen captures out over the network,

00:45:21.800 --> 00:45:27.640
You can coalesce the updates if you know
that you don't have the bandwidth to send

00:45:27.720 --> 00:45:30.590
the intervening updates to your client.

00:45:32.550 --> 00:45:35.930
Now, before I mention I/O surfaces,
which is--this is something that has

00:45:35.930 --> 00:45:37.900
been around for a long time in OSÂ X.

00:45:37.900 --> 00:45:41.900
This has long been a part
of the internals of OSÂ X.

00:45:41.900 --> 00:45:45.580
It became API in Snow Leopard.

00:45:45.600 --> 00:45:50.810
It's just a very high-performance
representation of a bitmap,

00:45:50.810 --> 00:45:55.000
which can migrate back and forth
between VRAM and main memory.

00:45:55.000 --> 00:45:58.200
One of the nice things about it is
you can share it between processes.

00:45:58.200 --> 00:46:04.970
So each one has an ID,
which you can designate as being global,

00:46:04.970 --> 00:46:06.930
and then another--hand that
ID off to somebody else,

00:46:07.000 --> 00:46:10.400
and another process can use that
ID to look it up and also handle that.

00:46:10.400 --> 00:46:14.690
So if you wanted to do a recording
in one process and actually deal

00:46:14.690 --> 00:46:18.330
with the data in another one,
this would allow you to do that.

00:46:18.440 --> 00:46:20.610
I/O surfaces are
interoperable with OpenGL,

00:46:20.680 --> 00:46:22.690
OpenCL, Core Image, and Core Video.

00:46:22.700 --> 00:46:25.850
They all have convenience
functions that allow you to take

00:46:25.900 --> 00:46:28.000
an I/O surface and import it into
whatever the best way you want.

00:46:28.000 --> 00:46:30.410
So you can see what the
best representation of that

00:46:30.410 --> 00:46:31.700
surface is in that API.

00:46:31.700 --> 00:46:37.610
So for example, in OpenGL, you can use
CGL Text Image I/O Surface 2D to

00:46:37.610 --> 00:46:39.880
initialize an OpenGL texture
with an I/O surface.

00:46:40.020 --> 00:46:43.780
Once you do that,
you just use it like any

00:46:43.780 --> 00:46:46.200
other OpenGL texture.

00:46:46.250 --> 00:46:50.280
So I'll do a quick demo of this so
you can see what I'm talking about.

00:46:56.600 --> 00:47:01.530
Okay, basically what's going on here is
the window on the left is capturing

00:47:01.530 --> 00:47:04.020
data from the screen on the right.

00:47:04.060 --> 00:47:06.770
So whatever you see on the
left is being captured,

00:47:06.970 --> 00:47:10.380
represented as an IO surface,
and then we're storing it as

00:47:10.440 --> 00:47:14.900
an OpenGL texture and blitting
that back out into the window.

00:47:14.900 --> 00:47:17.720
Of course,
because it's an OpenGL texture,

00:47:17.720 --> 00:47:19.950
you can do all sorts,
anything that you would

00:47:19.950 --> 00:47:23.710
normally do with a texture you
can do with a display stream.

00:47:23.860 --> 00:47:26.740
So, for example,
you can use fragment shaders

00:47:26.740 --> 00:47:30.560
if you wanted to do a grayscale
transformation or sepia.

00:47:30.560 --> 00:47:33.600
If you wanted to get fancy,
you could do edge detection.

00:47:33.600 --> 00:47:38.220
This specifically,
this may or may not be useful to you,

00:47:38.220 --> 00:47:41.560
but it does demonstrate
that you can use all sorts,

00:47:41.560 --> 00:47:47.080
all of your standard toolbox of shaders
and OpenGL tips and tricks to do anything

00:47:47.080 --> 00:47:49.820
you need to do with display streams.

00:47:59.510 --> 00:48:00.980
And that concludes our talk.

00:48:00.980 --> 00:48:05.120
For more information,
you can contact Alan Schaefer.

00:48:05.120 --> 00:48:08.160
He's our graphics and game
technologies evangelist.

00:48:08.160 --> 00:48:10.960
There's a mailing list for Quartz.

00:48:10.960 --> 00:48:15.910
The URL listed there is a hub for all
of the graphics documentation online.

00:48:15.920 --> 00:48:20.440
Specifically, there's a new document,
the high-resolution guidelines for OSÂ X.

00:48:20.440 --> 00:48:24.540
So if you're concerned about making sure
your app is ready for Retina displays,

00:48:24.550 --> 00:48:28.180
that should contain all of the
information you need right there.

00:48:28.790 --> 00:48:32.480
And of course, there's always the
Apple Developer Forums.

00:48:33.100 --> 00:48:35.000
There's some related sessions.

00:48:35.000 --> 00:48:38.850
If you're interested in
the Retina display stuff,

00:48:39.040 --> 00:48:42.220
I highly recommend the introduction
to high resolution on OSÂ X.

00:48:42.220 --> 00:48:46.220
This is by the same people that prepared
that document that I just mentioned.

00:48:46.220 --> 00:48:50.810
There's also some other sessions
related to getting the best

00:48:50.810 --> 00:48:55.830
performance out of AppKit and
Core Animation and otherwise dealing

00:48:55.830 --> 00:48:59.180
with the higher resolution displays.
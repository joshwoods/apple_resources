WEBVTT

00:00:20.280 --> 00:00:21.190
Welcome.

00:00:21.540 --> 00:00:25.540
Just getting started with Objective-C,
a simple, elegant, and dynamic language.

00:00:25.560 --> 00:00:26.410
I'm Bill Bumgarner.

00:00:26.490 --> 00:00:27.840
I manage the runtime team.

00:00:27.960 --> 00:00:30.700
We're responsible for Objective-C,
garbage collection, blocks,

00:00:30.830 --> 00:00:32.240
and a handful of other things.

00:00:32.320 --> 00:00:37.780
And I really do want to welcome you
to Mac OS X and iPhone OS programming.

00:00:37.780 --> 00:00:39.310
I know a lot of you are new to this.

00:00:39.340 --> 00:00:41.240
It's an exciting platform.

00:00:41.240 --> 00:00:43.320
There's a lot of movement in this.

00:00:43.570 --> 00:00:45.500
There's a lot of new things.

00:00:45.540 --> 00:00:47.690
Yet at the same time,
I think you'll find that it's

00:00:47.690 --> 00:00:49.160
also a very mature platform.

00:00:49.500 --> 00:00:54.370
You can rely on the features,
you can rely on the language.

00:00:54.600 --> 00:00:57.100
In particular, I know that when you're
learning something,

00:00:57.100 --> 00:01:00.220
if you learn like I do,
you often learn by example.

00:01:00.310 --> 00:01:04.650
And to that end,
what we're going to do is we're

00:01:04.650 --> 00:01:05.940
actually going to look at an example.

00:01:05.950 --> 00:01:08.160
Excuse me for a second.

00:01:08.200 --> 00:01:12.610
And I want to show you
what is Objective-C.

00:01:14.050 --> 00:01:16.880
I want to give you a foundation
with which you can read

00:01:16.880 --> 00:01:20.000
Objective-C effectively
and you can understand it,

00:01:20.160 --> 00:01:25.050
and then show you that Objective-C is
a foundation for a lot of patterns

00:01:25.050 --> 00:01:29.410
in Mac OS X and on the iPhone,
and really give you a set of tools that

00:01:29.410 --> 00:01:33.950
you can go forth into the other sessions
throughout the week and very quickly

00:01:33.950 --> 00:01:36.740
digest and internalize the information.

00:01:36.800 --> 00:01:39.850
I don't have enough time to
do a full language survey.

00:01:39.920 --> 00:01:47.590
I really don't have enough time to
effectively teach you all of Objective-C.

00:01:47.590 --> 00:01:47.590
But with that, let's move on.

00:01:48.440 --> 00:01:49.400
What is Objective-C?

00:01:49.400 --> 00:01:51.490
Well, let's do a little bit
of a guided tour here.

00:01:51.630 --> 00:01:54.570
I'm going to do a
little high level intro,

00:01:54.780 --> 00:01:57.200
and then we're going
to get into some code.

00:01:57.280 --> 00:02:01.280
So Objective-C is a language
that's been around quite a while.

00:02:01.400 --> 00:02:05.400
1984, I believe, was when StepStone,
the company that created Objective-C,

00:02:05.400 --> 00:02:07.200
was actually created.

00:02:07.220 --> 00:02:11.330
It's a set of syntactic extensions to C.

00:02:11.440 --> 00:02:12.670
It's literally extensions.

00:02:12.700 --> 00:02:15.790
It doesn't try to
change the meaning of C.

00:02:16.240 --> 00:02:19.280
There's a couple of additional types
that you'll find in the language

00:02:19.280 --> 00:02:21.660
and you'll see throughout the code.

00:02:21.950 --> 00:02:23.960
It does have class methods.

00:02:23.960 --> 00:02:27.140
They're not like Java static methods.

00:02:28.030 --> 00:02:31.600
As well,
it's like C++ in that it separates

00:02:31.660 --> 00:02:36.100
the interface from the implementation,
so your implementation will

00:02:36.100 --> 00:02:38.180
be kind of more private,
and your interface,

00:02:38.240 --> 00:02:43.400
the part that other people will use or
you'll use in other places in your code,

00:02:43.400 --> 00:02:44.250
is separated out.

00:02:44.280 --> 00:02:48.020
It has a single inheritance model,
which is a little bit simpler.

00:02:49.840 --> 00:02:53.000
But it does have a
feature called protocols,

00:02:53.000 --> 00:02:55.750
which Java borrowed as interfaces.

00:02:57.480 --> 00:03:02.640
Which allows you to actually share
interfaces across multiple classes.

00:03:03.960 --> 00:03:09.810
There are categories which give you
the ability to extend existing classes.

00:03:10.220 --> 00:03:25.260
Subdivide your implementation.

00:03:25.260 --> 00:03:25.260
Method invocation.

00:03:25.260 --> 00:03:25.260
Objective-C is different
than C++ or other languages.

00:03:26.380 --> 00:03:29.590
On the garbage, or on, I should say,
memory management,

00:03:29.680 --> 00:03:32.300
there are two different styles of
memory management you can choose

00:03:32.300 --> 00:03:34.240
when you're programming for OS X.

00:03:34.240 --> 00:03:37.130
On the iPhone,
you use reference counting only.

00:03:37.280 --> 00:03:41.400
On OS X, you can use reference counting
or garbage collection.

00:03:42.130 --> 00:03:45.830
There's also a feature called Properties,
which is relatively new to the language.

00:03:45.840 --> 00:03:50.760
It was added in the last few years,
which allow you to syntactically express

00:03:50.760 --> 00:03:53.520
what items are data in your objects.

00:03:55.340 --> 00:03:57.560
There's also a dynamic runtime
underneath all of this.

00:03:57.560 --> 00:03:58.900
It's actually active.

00:03:58.900 --> 00:04:01.030
It runs with your application.

00:04:01.030 --> 00:04:06.160
It's very important,
and we'll get to that in a moment.

00:04:06.160 --> 00:04:10.300
So,
let's talk about grokking Objective-C.

00:04:10.300 --> 00:04:13.580
And when I said learn by example,
I mean quite literally.

00:04:13.580 --> 00:04:16.500
If you have your computer open,
you have the dev tools installed.

00:04:16.500 --> 00:04:20.910
If you were to open the example,
developer examples, app kit, iSpend,

00:04:21.010 --> 00:04:24.460
most of the code is going
to come directly from that.

00:04:25.200 --> 00:04:28.350
You'll see some differences
on screen because,

00:04:28.350 --> 00:04:33.640
well, no one programs on 1024 by 768,
but I have to make slides in that size.

00:04:36.840 --> 00:04:40.620
So, first, Objective-C.

00:04:41.100 --> 00:04:42.630
It is C.

00:04:42.920 --> 00:04:47.220
It's a set of extensions to C,
and this is probably the first

00:04:47.270 --> 00:04:52.810
Hello World program ever written,
back in '70-something.

00:04:52.890 --> 00:04:57.180
And if you were to look in your project,
which will look something like this,

00:04:57.280 --> 00:05:00.350
and open up,
you'll see that there is a main file.

00:05:00.410 --> 00:05:05.360
And if you look in that main file in
Objective-C in a Cocoa app on the iPhone,

00:05:05.360 --> 00:05:08.420
you'd see something very similar,
not quite the same.

00:05:08.480 --> 00:05:10.840
You'll see it's C.

00:05:11.000 --> 00:05:14.010
Calls the main, passes control to Cocoa.

00:05:15.100 --> 00:05:17.320
Now, you probably built and run the app.

00:05:17.400 --> 00:05:18.340
It comes up.

00:05:18.440 --> 00:05:19.720
It shows a window on the screen.

00:05:19.720 --> 00:05:20.720
It's a document window.

00:05:20.720 --> 00:05:23.480
So you're thinking, okay,
let's go figure out how this thing works.

00:05:23.480 --> 00:05:25.780
Let's look at the document class.

00:05:25.780 --> 00:05:29.180
And you'll see there's
a mydocument.im file.

00:05:29.180 --> 00:05:31.470
And if you were to open
that up and look at it,

00:05:31.470 --> 00:05:33.470
there'll be something like this.

00:05:34.340 --> 00:05:36.570
And if we look at this,
we can see that there are some

00:05:36.580 --> 00:05:38.340
differences in Objective-C than C.

00:05:38.340 --> 00:05:42.740
In particular,
we can see there's some of the new types.

00:05:42.740 --> 00:05:46.310
So in this case, we see I've highlighted
some of them here.

00:05:46.310 --> 00:05:47.310
There's nil.

00:05:47.310 --> 00:05:48.990
Nil is the empty object.

00:05:49.060 --> 00:05:51.530
It's like null in C.

00:05:51.530 --> 00:05:55.780
But it's nil so that the compiler can
differentiate between an empty object

00:05:55.780 --> 00:05:58.900
and a pointer to nowhere or nothing,
I should say.

00:05:58.900 --> 00:06:02.000
Oh, sorry.

00:06:02.000 --> 00:06:04.280
I went one forward.

00:06:04.350 --> 00:06:04.900
too fast.

00:06:09.400 --> 00:06:16.780
There's also an ID,
which is a generic object reference.

00:06:16.780 --> 00:06:19.520
It's a typeless reference
to some object somewhere.

00:06:19.520 --> 00:06:22.710
It's kind of like a void pointer,
but this gives the compiler

00:06:22.720 --> 00:06:25.220
the ability to know that,
oh, you've got a reference

00:06:25.300 --> 00:06:26.280
to some object somewhere.

00:06:26.280 --> 00:06:27.200
You can message it.

00:06:27.200 --> 00:06:29.140
You can do things with it,
but you don't know what type it is.

00:06:29.720 --> 00:06:31.360
There's also Boolean type.

00:06:31.450 --> 00:06:33.950
Objective-C defines bool, all uppercase.

00:06:33.950 --> 00:06:36.590
It is different than bool, all lowercase.

00:06:36.590 --> 00:06:39.450
Of course, this is C,
so there's some wonderfully

00:06:39.450 --> 00:06:41.350
intuitive details like that.

00:06:41.360 --> 00:06:45.110
There's a yes and a no that are defined,
and I will mention it again.

00:06:45.200 --> 00:06:47.780
It's different than bool,
the lowercase one,

00:06:47.830 --> 00:06:51.500
and when you convert between the two,
you have to be careful.

00:06:54.810 --> 00:06:57.790
As well, Objective-C is an
object-oriented language.

00:06:57.860 --> 00:06:59.980
What's the first object
you ever encounter in any

00:06:59.980 --> 00:07:01.480
object-oriented language?

00:07:01.480 --> 00:07:02.870
A String class.

00:07:02.960 --> 00:07:04.930
In Objective-C there's NSString.

00:07:04.970 --> 00:07:06.390
This encapsulates strings.

00:07:06.540 --> 00:07:10.240
Now,
this gets into something very important.

00:07:10.250 --> 00:07:13.460
When we talk about a tour of
language like this on a platform

00:07:13.540 --> 00:07:18.020
like Mac OS X and the iPhone,
it's impossible to separate the language

00:07:18.320 --> 00:07:20.730
from the implementation details.

00:07:21.000 --> 00:07:25.290
So when we talk about NSString,
that's really not part of the language.

00:07:25.340 --> 00:07:27.890
There is this convenient
syntax for creating these

00:07:27.950 --> 00:07:31.900
things inline and on the fly,
but really NSString is

00:07:32.260 --> 00:07:33.910
part of the foundation.

00:07:34.100 --> 00:07:37.440
However, you know,
you've got to write code quick,

00:07:37.440 --> 00:07:39.540
so here's a convenience for you.

00:07:39.580 --> 00:07:42.450
You'll see the @ sign
a lot in Objective-C.

00:07:42.500 --> 00:07:46.700
It's often used to introduce
Objective-C-isms into code.

00:07:47.790 --> 00:07:50.760
And of course, it's object-oriented,
so we declare methods.

00:07:50.800 --> 00:07:54.060
This is an init method.

00:07:54.140 --> 00:07:56.590
It has a dash in front of it
because it's an instance method.

00:07:56.590 --> 00:08:00.440
And this is the initialize method,
which has a plus in front of

00:08:00.490 --> 00:08:02.730
it because it's a class method.

00:08:04.140 --> 00:08:07.550
And if you'll notice, there's this
Add Implementation My Document,

00:08:07.700 --> 00:08:12.120
which again gets back to the separation
of implementation and interface.

00:08:12.310 --> 00:08:15.920
So, at implementation implies
that there's probably gonna

00:08:15.920 --> 00:08:17.760
be an add interface somewhere.

00:08:17.760 --> 00:08:20.380
And sure enough,
if we go back to our project,

00:08:20.540 --> 00:08:22.920
we'll see there's a my document.h file.

00:08:23.170 --> 00:08:25.550
It's being C or being derived from C.

00:08:25.560 --> 00:08:29.440
You'll have .h files,
which are the parts that are included

00:08:29.440 --> 00:08:33.600
into other things to allow those
other things to use that interface.

00:08:33.600 --> 00:08:39.150
So, double clicking my document,
we'll see a standard

00:08:39.150 --> 00:08:40.930
class declaration here.

00:08:44.130 --> 00:08:49.240
In particular, @interface, my document,
the class name,

00:08:49.660 --> 00:08:52.920
inherits from the class NSDocument.

00:08:53.090 --> 00:08:57.340
So we're creating a subclass
of the NSDocument class.

00:08:57.920 --> 00:09:01.300
And of course,
we can declare instance variables.

00:09:01.320 --> 00:09:05.340
Now, instance variables are kind
of an implementation detail.

00:09:05.360 --> 00:09:08.550
Yet, because we're in C,
it's often very important for

00:09:08.550 --> 00:09:11.450
the compiler to know exactly how
things are laid out in memory.

00:09:11.450 --> 00:09:17.340
And thus, this implementation detail
usually has to be exposed.

00:09:17.350 --> 00:09:21.830
So you'll see the instance variable
declarations in the interfaces.

00:09:22.060 --> 00:09:23.990
And then we also can
declare a lot of methods.

00:09:24.000 --> 00:09:26.000
In this case,
we're declaring three instance

00:09:26.000 --> 00:09:28.220
methods and a class method.

00:09:28.220 --> 00:09:33.100
Now, what's interesting about method
declaration is you might have noticed,

00:09:33.120 --> 00:09:37.870
well, yes, instance, class,
I forgot about these transitions.

00:09:39.140 --> 00:09:40.830
You might have noticed
in your source file,

00:09:40.830 --> 00:09:44.020
if you have it up on screen,
that these methods are not declared.

00:09:44.020 --> 00:09:46.130
The reason why is because
they're actually declared

00:09:46.130 --> 00:09:47.440
in a superclass somewhere.

00:09:47.440 --> 00:09:52.000
And because my document's implementation
of them is not really that interesting.

00:09:52.000 --> 00:09:56.860
It's not something that the designer of
my document felt needed to be called out.

00:09:56.880 --> 00:09:58.860
So they're inherited from somewhere.

00:09:58.860 --> 00:10:03.900
You typically won't see things like this,
their declarations repeated.

00:10:03.900 --> 00:10:09.170
So moving along,
we now see we've got three methods here.

00:10:10.580 --> 00:10:14.910
And we have transactions.

00:10:14.980 --> 00:10:19.470
This is a method that returns
a reference to an NSArray,

00:10:19.580 --> 00:10:20.330
takes no arguments.

00:10:20.340 --> 00:10:24.870
Objective-C interleaves
arguments with the method names.

00:10:24.870 --> 00:10:29.970
So we see set transactions
colon as a method in here.

00:10:29.980 --> 00:10:32.330
The colon means there's
going to be an argument.

00:10:32.330 --> 00:10:34.850
And when you get two arguments,
like this one,

00:10:34.850 --> 00:10:37.620
you'll see that the name of
the method is interleaved

00:10:37.620 --> 00:10:39.630
with the actual argumentation.

00:10:39.640 --> 00:10:43.600
So this method is insert
transactions at indexes.

00:10:43.660 --> 00:10:49.180
That's the whole name, the full name,
and nothing but the name.

00:10:49.180 --> 00:10:52.540
Names of methods,
they're called selectors.

00:10:52.920 --> 00:10:55.810
So,
these are three selectors on our object,

00:10:55.810 --> 00:10:58.360
three methods that it implements.

00:10:58.360 --> 00:10:59.640
You can't drop parts of them.

00:10:59.650 --> 00:11:02.830
So, again,
and this is something I'll repeat

00:11:02.830 --> 00:11:07.700
a little bit because I've taught a
lot of Objective-C over the years,

00:11:07.700 --> 00:11:09.840
and this comes up for people
that are coming to the language.

00:11:09.880 --> 00:11:13.620
A method's name is its selector,
and it's very important to

00:11:13.620 --> 00:11:16.840
know that in Objective-C,
there is a type, an SEL,

00:11:16.840 --> 00:11:18.930
which represents a method name.

00:11:19.280 --> 00:11:20.670
And you'll see it quite often.

00:11:20.670 --> 00:11:25.150
For example, the NSObject class,
which is the base class used throughout

00:11:25.150 --> 00:11:28.080
Cocoa and iPhone programming,
implements a method

00:11:28.130 --> 00:11:30.120
called responseToSelector.

00:11:30.120 --> 00:11:32.200
It takes a selector as an argument.

00:11:32.200 --> 00:11:35.970
It returns a Boolean if that
object responds to that selector.

00:11:35.980 --> 00:11:40.730
This means it's very easy to ask
objects these kinds of questions.

00:11:40.760 --> 00:11:43.320
Because it's so easy,
you'll see certain design patterns

00:11:43.440 --> 00:11:45.080
fall out of that that rely upon that.

00:11:45.760 --> 00:11:50.760
For example, delegation, target action,
the way the thread class works,

00:11:50.760 --> 00:11:54.420
the way operations work,
a number of other classes.

00:11:54.680 --> 00:11:57.960
And again, set transactions:
if our class were to

00:11:57.960 --> 00:12:02.410
implement all of these,
set transactions: set transactions:

00:12:02.520 --> 00:12:07.560
of type: and finally, set transactions:
of type: in context:.

00:12:07.570 --> 00:12:13.520
Normally we don't say the colons,
but for specificity I'll mention them.

00:12:13.570 --> 00:12:15.020
These are all distinct selectors.

00:12:15.240 --> 00:12:18.780
In Objective-C,
you can't drop parts of the selector.

00:12:18.820 --> 00:12:21.030
That becomes a different method.

00:12:21.770 --> 00:12:25.360
So moving on here,
we saw that our document class was

00:12:25.360 --> 00:12:27.970
doing a lot of stuff with transactions.

00:12:29.480 --> 00:12:31.220
Let's have a look at
the transaction class.

00:12:31.220 --> 00:12:34.980
The declaration of this
looks a little bit different.

00:12:34.980 --> 00:12:36.820
As a matter of fact,
I think if I don't remember correctly,

00:12:36.820 --> 00:12:40.110
the declaration of it doesn't
contain anything like the method

00:12:40.240 --> 00:12:41.930
declarations we saw before.

00:12:41.940 --> 00:12:45.180
It also has this little
thing up at the top,

00:12:45.180 --> 00:12:48.640
NSCoding, in brackets, angle brackets.

00:12:48.650 --> 00:12:49.940
This is a protocol.

00:12:50.880 --> 00:12:54.460
This is telling the compiler
and declaring that this class

00:12:54.680 --> 00:12:58.160
is going to implement whatever
is promised by the protocol.

00:12:58.160 --> 00:13:01.650
In this case,
a protocol is a reusable interface.

00:13:01.650 --> 00:13:05.210
It is a collection of methods,
a set of method declarations.

00:13:05.220 --> 00:13:10.620
And what we are saying when we declare
that our class implements a protocol

00:13:10.620 --> 00:13:13.420
is that we are promising to provide
an implementation of those methods.

00:13:13.460 --> 00:13:18.410
Now, furthermore, we can also ask the
instances of the class later,

00:13:18.420 --> 00:13:20.020
hey, do you conform to this protocol?

00:13:22.250 --> 00:13:28.850
So protocols can also have
optional methods and required

00:13:28.850 --> 00:13:31.150
methods in their declarations.

00:13:31.420 --> 00:13:34.090
So when you say that you
implement a particular protocol,

00:13:34.090 --> 00:13:37.260
like the UI table view
data source on your class,

00:13:37.480 --> 00:13:40.130
you must provide those first two methods.

00:13:40.140 --> 00:13:43.290
And you can optionally provide any
of a number of other methods that are

00:13:43.290 --> 00:13:48.250
declared in the add optional section
to further change the interaction

00:13:48.260 --> 00:13:50.870
between a table view and your object.

00:13:52.250 --> 00:13:56.010
And it's important to note
@Required is the default.

00:13:56.020 --> 00:13:57.790
If you looked at the
NS coding declaration,

00:13:57.800 --> 00:13:59.080
there was no @Required there.

00:13:59.300 --> 00:14:01.670
It's cuz all the methods are required.

00:14:02.250 --> 00:14:03.690
So, protocols.

00:14:03.760 --> 00:14:08.010
There's something you can,
when you declare a class,

00:14:08.100 --> 00:14:10.440
you can say that the class
implements a protocol,

00:14:10.440 --> 00:14:12.960
and you are promising to provide
an implementation of the required

00:14:12.960 --> 00:14:15.380
methods in that protocol.

00:14:15.820 --> 00:14:19.240
You can also specify multiple protocols.

00:14:19.240 --> 00:14:23.330
You can also declare a protocol
that implements another protocol.

00:14:23.390 --> 00:14:26.420
So you're basically promising that
anything that uses that protocol or

00:14:26.420 --> 00:14:30.400
implements that protocol will have
to implement all required methods in

00:14:30.530 --> 00:14:32.890
whatever protocol that protocol uses.

00:14:32.900 --> 00:14:35.940
And you'll see there's
this NSObject protocol.

00:14:35.940 --> 00:14:38.850
There's actually a number of protocols
on the system that are pretty common.

00:14:38.860 --> 00:14:45.270
That's because in Objective-C,
the base class is more or less advisory.

00:14:45.550 --> 00:14:48.250
That is, you can write your own
root class if you want to.

00:14:48.250 --> 00:14:51.790
Almost no one ever does.

00:14:51.960 --> 00:14:54.910
If you do,
you'd have to pretty much reinvent

00:14:54.990 --> 00:14:58.840
everything in the NSObject protocol,
which, again,

00:14:59.200 --> 00:15:04.440
the language being inseparable from
the system itself is a lot of work.

00:15:04.440 --> 00:15:08.100
Some of the other protocols
you'll find on the platform in

00:15:08.240 --> 00:15:11.690
the foundation is NSCopying,
NSMutableCopying.

00:15:11.700 --> 00:15:14.440
NSCopying for creating
a copy of an object.

00:15:14.510 --> 00:15:17.580
MutableCopying for creating a
copy of the object where that

00:15:17.580 --> 00:15:19.300
copy could be changed later.

00:15:19.300 --> 00:15:23.490
NSLocking for integration with threading.

00:15:23.500 --> 00:15:29.300
And NSFastEnumeration for taking
advantage of the four enumeration

00:15:29.300 --> 00:15:31.830
of collections of objects.

00:15:32.610 --> 00:15:36.200
It's interesting to note that the
iPhone OS actually uses protocols

00:15:36.200 --> 00:15:38.150
a lot more than Cocoa programming.

00:15:38.200 --> 00:15:40.240
It's one of the few areas
where there is some difference.

00:15:40.240 --> 00:15:43.470
In particular, you'll see things like
the application delegate,

00:15:43.470 --> 00:15:47.370
table view data sources,
all these things declared as protocols.

00:15:47.390 --> 00:15:51.030
That was actually done because it
allows the compiler to give you better

00:15:51.030 --> 00:15:54.590
warnings and errors when you mess
up a type or something like that.

00:15:54.720 --> 00:15:57.220
It's literally to
provide better checking.

00:15:59.350 --> 00:16:02.740
Now, there's something else interesting
when you look at this project.

00:16:02.770 --> 00:16:06.620
You see there's this mydocument.h,
mydocument.m.

00:16:06.850 --> 00:16:10.980
But then there's also a couple of
other My Document file names in here.

00:16:11.020 --> 00:16:12.960
We have these two pasteboard ones.

00:16:13.190 --> 00:16:17.350
That's because the implementer
of this application decided,

00:16:17.350 --> 00:16:21.640
let's subdivide the implementation of
My Document for organizational purposes

00:16:21.840 --> 00:16:24.900
and pull the pasteboard functionality
out and put them in different files.

00:16:24.940 --> 00:16:28.580
And they did that by using
Objective-C categories.

00:16:28.600 --> 00:16:31.980
A category allows you to take
a collection of methods and

00:16:32.020 --> 00:16:33.960
add it to an existing class.

00:16:35.510 --> 00:16:38.730
So, in this case,
we're declaring a category

00:16:38.730 --> 00:16:43.440
called Pasteboard that
extends the My Document class.

00:16:43.440 --> 00:16:45.090
It adds a number of methods to it.

00:16:45.120 --> 00:16:49.350
And if we look at the
implementation file,

00:16:50.250 --> 00:16:52.300
We'll actually see the
implementations of those methods in

00:16:52.470 --> 00:16:57.350
an Add Implementation block that,
again, declares a pasteboard category

00:16:57.350 --> 00:16:59.280
on the My Document class.

00:17:00.860 --> 00:17:04.430
Now, what's interesting about this,
and I worked hard to make sure

00:17:04.430 --> 00:17:07.630
I got a screenshot of this in,
because this is a new feature

00:17:07.630 --> 00:17:10.640
in the Xcode you have with
you called Open Quickly,

00:17:10.640 --> 00:17:11.900
and it is terribly cool.

00:17:11.900 --> 00:17:15.120
If you were to hit
Shift-Command-D and type nsthread,

00:17:15.120 --> 00:17:17.500
you'd see a list something like this.

00:17:17.540 --> 00:17:22.150
And if you open nsthread.h,
you'll see that it actually

00:17:22.150 --> 00:17:26.870
has in its API a declaration of
a category on NSObject called

00:17:26.870 --> 00:17:29.520
nsthread perform additions.

00:17:30.390 --> 00:17:32.780
What this is actually doing is
adding additional functionality

00:17:32.860 --> 00:17:35.060
to the NSObject class.

00:17:35.210 --> 00:17:39.440
Now, you can add additional functionality
to NSObject if you want to as well.

00:17:39.680 --> 00:17:44.580
It's not--the barrier is not at, say,
framework boundaries.

00:17:44.660 --> 00:17:47.810
So if you have some particular
thing that you want every object

00:17:47.910 --> 00:17:52.190
in your entire application,
no matter who wrote it, to do,

00:17:52.290 --> 00:17:55.380
you could add it to NSObject if you want.

00:17:56.050 --> 00:17:59.770
It's a feature to be used with
care from a design perspective,

00:17:59.770 --> 00:18:02.100
as you can probably imagine.

00:18:03.440 --> 00:18:06.390
And again,
NSThread has an implementation something

00:18:06.400 --> 00:18:08.960
like this for adding those methods.

00:18:09.320 --> 00:18:13.710
So categories, they allow you to add
methods to existing classes,

00:18:13.720 --> 00:18:18.960
kinda like class extensions in C#.

00:18:19.420 --> 00:18:21.570
But Java doesn't do this.

00:18:21.770 --> 00:18:25.830
You can add methods to classes
outside of your project.

00:18:25.940 --> 00:18:28.870
You cannot add instance variables.

00:18:29.010 --> 00:18:31.270
It can't affect the storage of the class.

00:18:31.270 --> 00:18:35.000
And this is because, of course,
if you change, say,

00:18:35.000 --> 00:18:38.780
the storage in a C program,
change the layout of a structure,

00:18:38.780 --> 00:18:42.610
and you have other structures
that are dependent on that,

00:18:42.650 --> 00:18:46.480
then everything has to be recompiled
or else the layout gets all messed up

00:18:46.480 --> 00:18:48.800
and you get really interesting crashes.

00:18:51.460 --> 00:18:55.190
However, on Snow Leopard,
you can add associative references.

00:18:55.190 --> 00:18:58.150
You can use associative references
to associate a piece of data

00:18:58.160 --> 00:19:02.010
with an instance or a class,
which gives an instance

00:19:02.010 --> 00:19:04.900
variables-like feature.

00:19:05.710 --> 00:19:08.700
You can also,
you can access instance variables though.

00:19:08.700 --> 00:19:10.820
So if the class declares
instance variables,

00:19:10.820 --> 00:19:13.040
you can access them from
within your categories.

00:19:13.080 --> 00:19:15.600
Do this with care.

00:19:15.600 --> 00:19:20.630
It's likely that the class has some
logic related to the state management.

00:19:20.800 --> 00:19:23.230
There may also be some
limitations to doing this,

00:19:23.230 --> 00:19:26.820
depending on what version of the
operating system you're linking with

00:19:26.820 --> 00:19:30.630
and whether or not the instance variable
you're trying to get to is inside

00:19:30.720 --> 00:19:35.030
whatever you're compiling or is in,
say, a system-provided framework

00:19:35.030 --> 00:19:37.140
or some other piece of code.

00:19:38.570 --> 00:19:42.670
So let's step away from the
syntax part of this a little bit,

00:19:42.690 --> 00:19:45.450
the declarative part,
and let's actually look at the

00:19:45.530 --> 00:19:47.770
method calling mechanism itself.

00:19:49.410 --> 00:19:54.740
Objective-C uses a Smalltalk-like
syntax for calling methods.

00:19:54.810 --> 00:20:02.000
It's not the functional style that
you're familiar with from Java or C#.

00:20:02.000 --> 00:20:02.000
In particular,

00:20:02.250 --> 00:20:03.960
You can call class methods.

00:20:04.040 --> 00:20:07.200
It's bracket, the target,
and then some thing to do.

00:20:07.290 --> 00:20:09.530
So in this case,
we're calling the array method

00:20:09.880 --> 00:20:11.930
on the NS immutable array class.

00:20:12.120 --> 00:20:15.780
And if you were to look at
the NSArray declaration,

00:20:15.820 --> 00:20:18.450
you would see a method
declared something like this.

00:20:18.530 --> 00:20:22.870
Returns an object,
doesn't take any arguments.

00:20:23.200 --> 00:20:26.720
Similarly, we can call instance methods.

00:20:26.840 --> 00:20:27.540
Same syntax.

00:20:27.690 --> 00:20:29.670
In this case,
we're calling an instance method on self.

00:20:29.690 --> 00:20:32.250
Self is like this.

00:20:32.310 --> 00:20:35.960
It's a reference to whatever object is
currently executing the current method.

00:20:35.960 --> 00:20:41.440
So we're calling the writable
pasteboard types method on the instance,

00:20:41.440 --> 00:20:42.610
our self.

00:20:44.140 --> 00:20:46.040
And its declaration would look like this.

00:20:46.040 --> 00:20:49.280
I think it was actually
a couple slides ago.

00:20:50.360 --> 00:20:55.620
Similarly, we can call an instance method
on some random object reference.

00:20:55.780 --> 00:21:00.220
We're calling the containsObject:,
or just containsObject method,

00:21:00.250 --> 00:21:05.590
passing one argument, type,
on the object types.

00:21:06.900 --> 00:21:26.100
[Transcript missing]

00:21:29.400 --> 00:21:48.400
[Transcript missing]

00:21:49.650 --> 00:21:51.880
It's a single flat
namespace for all methods.

00:21:52.150 --> 00:21:58.110
That is, there is a one namespace
for all selectors,

00:21:58.110 --> 00:21:58.110
all method names in your application.

00:21:59.520 --> 00:22:01.470
There is no type-based dispatch.

00:22:01.510 --> 00:22:03.320
So what that means is
when you declare a method,

00:22:03.320 --> 00:22:06.590
if you declare the same method
name twice and you declare it with

00:22:06.660 --> 00:22:10.510
different types for the arguments,
then you're very likely going

00:22:10.620 --> 00:22:12.500
to get compiler warnings.

00:22:12.540 --> 00:22:16.760
So generally, you won't see that
done anywhere in Cocoa.

00:22:16.850 --> 00:22:19.970
I think there's one case where it's done.

00:22:21.530 --> 00:22:26.510
So nil, the empty object,
it eats messages silently.

00:22:26.520 --> 00:22:31.030
If you try to call a method on nil,
it's just nothing's going to happen.

00:22:31.040 --> 00:22:36.020
As long as the type sort of
looks like an object reference,

00:22:36.020 --> 00:22:39.060
it's an integer or a float
or something like that,

00:22:39.110 --> 00:22:41.620
you're generally going to
get a zero back if you try to

00:22:41.620 --> 00:22:42.930
take the return value from it.

00:22:43.000 --> 00:22:46.120
But that behavior is not
really well specified,

00:22:46.120 --> 00:22:51.320
and if you look in the documentation,
it will warn against relying upon that.

00:22:51.500 --> 00:22:55.540
So, there's no null pointer
exception in Objective-C.

00:22:58.550 --> 00:23:01.410
And again, Objective-C,
the arguments are always

00:23:01.410 --> 00:23:04.780
interleaved with the method name,
both for declarations

00:23:04.840 --> 00:23:06.010
and for invocations.

00:23:06.210 --> 00:23:08.560
And it's important to note
that Objective-C doesn't have

00:23:08.730 --> 00:23:12.180
keyword arguments that are so
common in scripting languages.

00:23:12.240 --> 00:23:15.730
So you could say the arguments are named,
but they're not keywords.

00:23:15.830 --> 00:23:17.500
The order is critical.

00:23:17.540 --> 00:23:21.720
Change the order,
you get a different method.

00:23:21.720 --> 00:23:23.580
Drop something, different method.

00:23:23.580 --> 00:23:23.580
Add something, different method.

00:23:25.340 --> 00:23:29.570
And Objective-C, being born out of C,
does support variable

00:23:29.570 --> 00:23:30.700
number of arguments.

00:23:30.710 --> 00:23:35.080
So you've got the vararg style, dot, dot,
dot, declaration available.

00:23:35.100 --> 00:23:36.310
And you can parse those lists.

00:23:36.370 --> 00:23:38.800
Generally don't see this a lot.

00:23:38.800 --> 00:23:40.240
You'll see it within a string class.

00:23:40.380 --> 00:23:42.990
You'll see it with some
of the collection classes.

00:23:45.380 --> 00:23:51.180
Which,
now that we've got some syntax in hand,

00:23:51.180 --> 00:23:56.140
and we have method invocation in hand,
we can talk about memory management.

00:23:56.200 --> 00:23:59.180
We're going to talk about
non-GC memory management.

00:23:59.610 --> 00:24:02.570
And frankly, C does not provide a lot of
inspiration on this front.

00:24:02.570 --> 00:24:07.040
If you have programmed C,
you'll know that a lot of times you have

00:24:07.040 --> 00:24:11.180
to go look at the documentation and you
either have to free the thing returned

00:24:11.190 --> 00:24:15.620
to you or don't free it or send it off
somewhere else to get cleaned up or,

00:24:15.800 --> 00:24:18.370
you know, nil it out or whatever.

00:24:18.400 --> 00:24:19.880
I mean, it's a hodgepodge.

00:24:19.900 --> 00:24:24.280
And originally, Objective-C was actually
done the same way.

00:24:24.280 --> 00:24:32.140
And then in about 19--early '90s or so,
when the APIs that were provided

00:24:32.140 --> 00:24:35.640
in the system kind of expanded
and became more of a foundation,

00:24:35.640 --> 00:24:38.280
quite literally called the foundation,

00:24:39.200 --> 00:24:42.440
Objective-C move to reference counting.

00:24:42.460 --> 00:24:45.630
And reference counting
is really dead simple.

00:24:45.910 --> 00:24:49.310
It's so simple,
it's very easy to make a mistake.

00:24:49.490 --> 00:24:52.330
If you want to keep something around,
retain it.

00:24:52.330 --> 00:24:54.630
Literally call the retain method.

00:24:55.760 --> 00:24:57.930
If you don't want it anymore,
call release.

00:24:59.890 --> 00:25:03.450
And a method might typically, you think,
look like this.

00:25:03.730 --> 00:25:08.190
However,
the problem here is that we're returning

00:25:08.210 --> 00:25:12.290
something we've retained because we want
it to stay around once we've returned it,

00:25:12.380 --> 00:25:15.830
so whoever called us can make a decision
about what they want to do with it.

00:25:15.920 --> 00:25:19.320
But now we've kind of said, okay, well,
I'm passing ownership to you.

00:25:19.320 --> 00:25:21.460
Well, what if that thing calling
us doesn't want ownership?

00:25:21.510 --> 00:25:23.940
What if they just wanted to poke
at my stash of goods a little

00:25:23.950 --> 00:25:25.220
bit and then forget about it?

00:25:25.320 --> 00:25:29.490
We need some way of
delaying that release,

00:25:29.610 --> 00:25:32.610
some way of kind of saying,
we're going to make sure the

00:25:32.610 --> 00:25:34.450
object stays around for a while,
and we're going to kind

00:25:34.450 --> 00:25:36.050
of throw it out there,
and if anyone else wants it,

00:25:36.060 --> 00:25:38.900
you have an opportunity to grab
it before it goes away forever.

00:25:38.900 --> 00:25:42.830
This led to the introduction
of auto-release pools.

00:25:44.910 --> 00:25:48.070
And what an auto-release
pool does is it's literally,

00:25:48.270 --> 00:25:49.530
you can think of it as a bucket.

00:25:49.540 --> 00:25:51.640
You throw the object in the
bucket and it sticks around

00:25:51.640 --> 00:25:54.200
and eventually the bucket gets

00:25:55.380 --> 00:26:00.240
They're automatically created and cleared
for you when you're running a run loop.

00:26:00.370 --> 00:26:02.120
So if you're running the
run loop on the phone,

00:26:02.120 --> 00:26:04.990
you're running a run loop in Cocoa,
the main event loop,

00:26:05.080 --> 00:26:07.440
or you're running a run loop
in a thread you've created,

00:26:07.440 --> 00:26:11.210
the auto-release pools will be
managed as a part of the run loop.

00:26:11.960 --> 00:26:15.030
You can create them
manually if you want to.

00:26:16.750 --> 00:26:20.060
There's an auto-release pool per thread,
generally.

00:26:20.060 --> 00:26:23.380
If you have a run loop,
it's created automatically.

00:26:23.490 --> 00:26:25.350
If not, you can create one if you want.

00:26:25.360 --> 00:26:29.690
When you call retain or you call release
or you call the auto-release method,

00:26:29.700 --> 00:26:32.980
which I'll show in a second,
the auto-release throws it into the

00:26:32.980 --> 00:26:35.490
auto-release pool for the current thread.

00:26:35.520 --> 00:26:37.470
What that means, though,
is when you're doing

00:26:37.540 --> 00:26:41.010
multi-threaded programming,
you must make sure that you retain

00:26:41.060 --> 00:26:44.240
the object for the duration of
passing it between two threads.

00:26:44.880 --> 00:26:49.190
You can never rely on an auto-release
pool to keep an object around long

00:26:49.200 --> 00:26:51.840
enough for a thread pass to be safe.

00:26:54.650 --> 00:26:56.050
The auto-release pool,
like everything else,

00:26:56.050 --> 00:26:56.940
is fully documented.

00:26:56.940 --> 00:26:59.060
I actually point the documentation
out because it's actually

00:26:59.300 --> 00:27:01.260
quite good on this subject.

00:27:01.390 --> 00:27:04.260
Fills in a lot of more detail.

00:27:04.780 --> 00:27:10.130
and revisiting the retrieveGoods
method that we wrote before.

00:27:10.690 --> 00:27:13.900
Now we can modify this so we
first retain my stash of goods,

00:27:13.930 --> 00:27:15.970
and then we auto-release
it before returning it.

00:27:16.060 --> 00:27:21.020
And what this means is the caller
can poke at my stash of goods,

00:27:21.060 --> 00:27:24.200
do whatever it wants to,
and if it wants to keep it,

00:27:24.200 --> 00:27:26.900
it retains it, and if it does it,
it does nothing.

00:27:26.900 --> 00:27:29.260
And then when we get to the
bottom of the event loop,

00:27:29.290 --> 00:27:32.850
we get to whenever the auto-release
pool for that thread is drained,

00:27:32.860 --> 00:27:37.550
then that reference to my stash of
goods will go away if my stash of

00:27:37.550 --> 00:27:40.180
goods was replaced in my stash box.

00:27:40.700 --> 00:27:44.210
At some point in time,
then the one that was pulled out of

00:27:44.210 --> 00:27:46.700
there earlier will get destroyed.

00:27:50.190 --> 00:27:57.900
So memory management rules for non-GC,
again, this is the definition of it.

00:27:59.070 --> 00:28:00.930
You own any object you create.

00:28:01.210 --> 00:28:02.720
That means you've retained it.

00:28:02.940 --> 00:28:07.000
You can create objects via methods
that begin with ALAC New or Copy.

00:28:07.160 --> 00:28:08.640
I'm going to go through this quickly.

00:28:08.660 --> 00:28:09.800
It's all documented.

00:28:09.820 --> 00:28:11.390
ALAC New, Copy, Mutable Copy.

00:28:11.470 --> 00:28:14.290
Those are things that
create retained stuff.

00:28:14.570 --> 00:28:20.510
Everything else generally returns an
auto-released or non-retained reference.

00:28:21.420 --> 00:28:25.080
And again, non-retained does not
always mean auto-released.

00:28:25.080 --> 00:28:28.930
If you own an object,
you have to release it.

00:28:28.930 --> 00:28:32.520
And don't ever directly
deallocate an object.

00:28:32.630 --> 00:28:34.770
Because something else
may have retained it.

00:28:34.810 --> 00:28:38.480
Maybe the design of some framework
you're using has changed,

00:28:38.480 --> 00:28:41.820
and now it's retaining things
when you don't expect it.

00:28:41.870 --> 00:28:44.240
So just don't call deallocate directly.

00:28:44.240 --> 00:28:47.400
If you don't own an object,
don't release it.

00:28:47.400 --> 00:28:51.460
If you call retain,
you've got to balance it with

00:28:51.460 --> 00:28:53.610
a release or an auto-release.

00:28:54.320 --> 00:28:56.410
Retains can lead to cycles.

00:28:56.440 --> 00:29:01.980
So if A retains B, B retains C,
and C retains A, that's a cycle.

00:29:02.040 --> 00:29:03.540
It's gotta be broken.

00:29:03.590 --> 00:29:04.240
They're hard to debug.

00:29:04.340 --> 00:29:09.490
Or, but there's good tools for that.

00:29:10.330 --> 00:29:12.920
Or you could just use Garbage Collection.

00:29:13.070 --> 00:29:15.830
And under Garbage Collection,

00:29:16.720 --> 00:29:19.620
All this stuff goes away.

00:29:19.730 --> 00:29:23.180
And there's some great sessions on using
Garbage Collection later in the week.

00:29:23.180 --> 00:29:28.440
Unfortunately, Garbage Collection is a
Mac OS X only technology.

00:29:28.500 --> 00:29:32.340
So if you're on the phone,
be careful with retains and releases.

00:29:32.500 --> 00:29:36.100
There's also an advanced session on
Friday which will go into this in much,

00:29:36.170 --> 00:29:38.280
much greater detail.

00:29:39.620 --> 00:29:43.890
Plus, there's the instrument session,
which I highly recommend.

00:29:43.900 --> 00:29:49.200
Instruments is an incredible debugging
and performance analysis tool.

00:29:53.410 --> 00:29:56.840
Okay, so let's go back to our
transaction class for a second.

00:29:56.840 --> 00:30:01.590
Let's have a look at these properties.

00:30:02.320 --> 00:30:04.120
Now, when you're doing
object-oriented programming,

00:30:04.120 --> 00:30:06.270
what's one of the reasons you
do object-oriented programming?

00:30:06.390 --> 00:30:09.960
It's so you can encapsulate
things in objects.

00:30:09.970 --> 00:30:13.200
Generally, you're encapsulating
data and functionality,

00:30:13.270 --> 00:30:15.240
but in this case,
we're looking at some data.

00:30:15.240 --> 00:30:18.520
A transaction object has a bunch
of data associated with it.

00:30:18.550 --> 00:30:22.100
It has an amount, a date, a description,
things like that.

00:30:22.110 --> 00:30:26.750
Well, let's look at what this class
would look like before properties.

00:30:28.270 --> 00:30:31.130
Before properties,
you'd have pretty much two

00:30:31.130 --> 00:30:32.710
methods for each piece of data.

00:30:32.740 --> 00:30:37.500
You'd have a setter, set amount,
set date, set description string,

00:30:37.500 --> 00:30:41.040
and a getter, amount, date,
description string.

00:30:41.060 --> 00:30:41.700
Pretty repetitive.

00:30:41.740 --> 00:30:46.110
Now, you know a little bit about
the memory management stuff.

00:30:46.250 --> 00:30:49.950
What you don't see here is
any information to developers

00:30:49.950 --> 00:30:53.740
using this class as to how to
manage the memory appropriately.

00:30:53.790 --> 00:30:56.180
They don't know if the
date is gonna be retained,

00:30:56.180 --> 00:30:57.920
which should be,
but they don't know that.

00:30:57.950 --> 00:30:59.710
They don't know if the description
string is gonna be copied,

00:30:59.760 --> 00:31:01.900
so they wouldn't know if, well,
what happens if I pass

00:31:01.900 --> 00:31:04.700
a mutable string in,
something that could change later?

00:31:04.700 --> 00:31:05.510
Is that gonna be bad?

00:31:05.580 --> 00:31:10.700
So this is how it was for a long,
long time.

00:31:10.780 --> 00:31:14.950
In the last few years,
we revisited this and we captured

00:31:15.730 --> 00:31:20.160
The standard Cocoa setter-gitter pattern
into something we call properties.

00:31:20.160 --> 00:31:24.990
What properties allow you to do is
to take these very typical repetitive

00:31:24.990 --> 00:31:28.520
method pairs and reduce them to
a single declaration per pair.

00:31:28.540 --> 00:31:31.420
And at the same time,
give users of your class,

00:31:31.540 --> 00:31:34.820
including yourself,
more information to work with

00:31:34.940 --> 00:31:37.380
to successfully use that class.

00:31:37.380 --> 00:31:40.930
So looking at amount,
we can replace set amount and amount

00:31:40.930 --> 00:31:43.290
with an at property double amount.

00:31:44.430 --> 00:31:48.330
Properties declaring the type,
it's double, its name is amount.

00:31:50.280 --> 00:31:54.920
And similarly,
we can do the same thing for date.

00:31:54.980 --> 00:31:57.090
Now, dates aren't mutable,
so we don't need to

00:31:57.090 --> 00:31:58.640
worry about copying it.

00:31:59.330 --> 00:32:03.950
And we're gonna say we're gonna retain
this thing so that clients of our code

00:32:03.960 --> 00:32:08.090
knows that if they pass us a date,
we're gonna keep it around.

00:32:10.090 --> 00:32:12.790
So set description string
and description string again.

00:32:12.850 --> 00:32:15.180
We can replace it with a property.

00:32:15.380 --> 00:32:18.030
In this case,
we're going to say that we copy

00:32:18.320 --> 00:32:20.400
the string being passed in.

00:32:20.450 --> 00:32:25.240
So clients of our class know
that whatever they pass to us,

00:32:25.240 --> 00:32:29.760
we're gonna be copying it so they don't
have to worry about mutating it later.

00:32:30.110 --> 00:32:32.940
And we're also going to declare
that this property is non-atomic.

00:32:32.980 --> 00:32:38.840
That means that the act of setting
something via this property,

00:32:38.840 --> 00:32:41.540
the act of setting the
description string,

00:32:41.560 --> 00:32:46.820
isn't going to do anything to protect
against thread-based conflict,

00:32:46.820 --> 00:32:48.620
more or less.

00:32:49.940 --> 00:32:52.820
And now our class declaration
is a little bit simpler.

00:32:52.850 --> 00:32:55.780
And more importantly,
not only is it simpler,

00:32:55.840 --> 00:32:58.210
it's also much more precise.

00:33:00.060 --> 00:33:02.470
But we didn't stop with
just the declaration side.

00:33:02.770 --> 00:33:06.590
Properties also provide tools for
helping you with the implementation of

00:33:06.590 --> 00:33:09.040
getting and setting data on your classes.

00:33:09.090 --> 00:33:12.830
So in particular,
we can synthesize a property,

00:33:12.830 --> 00:33:15.420
which means in the implementation,
in this case the

00:33:15.450 --> 00:33:18.220
implementation of transaction,
we are going to synthesize the

00:33:18.220 --> 00:33:20.180
description string property.

00:33:20.700 --> 00:33:23.950
Which means the compiler will
actually create set description

00:33:23.950 --> 00:33:27.290
string and description string
methods for us automatically,

00:33:27.290 --> 00:33:30.120
and it's going to use the
instance variable underbar

00:33:30.120 --> 00:33:32.020
description string as the storage.

00:33:33.430 --> 00:33:37.490
So now not only have we reduced the
amount of code we've had to write

00:33:37.680 --> 00:33:41.240
and the least buggy lines of code
are ones you don't write at all,

00:33:41.240 --> 00:33:45.790
but we've also taken advantage
of the compiler's ability to

00:33:45.820 --> 00:33:49.270
generate these setters and
getters that are exactly correct.

00:33:49.420 --> 00:33:53.660
So you don't have to worry
about bugs in the storage.

00:33:53.660 --> 00:33:59.280
And now we are in the torturing
a cat phase of the session.

00:34:03.360 --> 00:34:07.180
You can also choose to
write it all yourself.

00:34:07.200 --> 00:34:11.530
In the case of transaction, the amount,
the set amount methods, they're custom.

00:34:11.530 --> 00:34:15.210
They have some custom logic in them,
so the implementer of it just

00:34:15.210 --> 00:34:17.180
wrote everything themselves.

00:34:17.530 --> 00:34:20.390
As well,
you can actually choose to mix and match.

00:34:20.390 --> 00:34:24.940
So for the date property,
we actually have a custom set date method

00:34:24.940 --> 00:34:29.780
because it does some additional logic,
but we're letting the compiler

00:34:29.780 --> 00:34:33.190
synthesize the date method itself,
the getter.

00:34:35.370 --> 00:34:37.740
Finally, the other thing you
can do with properties,

00:34:37.740 --> 00:34:40.540
which is pretty cool,
you can say @dynamic.

00:34:40.570 --> 00:34:43.190
And this gets back to the
dynamic nature of Objective-C.

00:34:43.470 --> 00:34:46.240
What you're telling the compiler
is that even though you're not

00:34:46.350 --> 00:34:49.640
providing an implementation
of the methods at this time,

00:34:49.650 --> 00:34:53.540
you will ensure that the implementation
comes into existence at runtime before

00:34:53.720 --> 00:34:58.940
or during the first time any one
of those properties is accessed.

00:35:00.930 --> 00:35:03.690
So,
there's one other aspect of properties.

00:35:03.700 --> 00:35:08.680
We also added something we
call the dot syntax in Leopard,

00:35:08.680 --> 00:35:11.150
which allows easy access to properties.

00:35:11.160 --> 00:35:14.060
And it works for non-property
setters and getters,

00:35:14.060 --> 00:35:14.540
too.

00:35:14.540 --> 00:35:17.430
So you don't have to convert stuff
to properties to use the dot.

00:35:17.440 --> 00:35:21.920
And when you see APIs that use
set something and something as

00:35:21.920 --> 00:35:24.640
the standard setters and getters,
you can just use a dot.

00:35:24.690 --> 00:35:27.820
And literally,
these two implementations of the

00:35:27.820 --> 00:35:30.610
addService method are equivalent.

00:35:30.900 --> 00:35:35.840
In every way, outside of the minor
syntactic difference.

00:35:40.310 --> 00:35:41.790
So, properties.

00:35:41.810 --> 00:35:46.700
It's a syntactic encapsulation of the
standard Cocoa Setter-Gitter pattern,

00:35:46.700 --> 00:35:49.990
as well as the iPhone OS Setter-Gitter.

00:35:50.880 --> 00:35:53.640
It also declares the memory
management intentions,

00:35:53.680 --> 00:35:57.970
so it provides more information to
clients of the class than just the

00:35:57.970 --> 00:36:00.270
method declarations themselves.

00:36:01.310 --> 00:36:03.990
It ensures compatibility
with Cocoa patterns.

00:36:03.990 --> 00:36:05.590
And again,
when we talk about the language,

00:36:05.600 --> 00:36:10.220
the language in this case is
inseparable from the APIs of the system.

00:36:10.220 --> 00:36:13.280
And by using properties,
you are ensuring that your classes

00:36:13.280 --> 00:36:16.460
are going to be compatible with
various mechanisms in Cocoa,

00:36:16.460 --> 00:36:20.010
like key value coding,
key value observation, bindings,

00:36:20.010 --> 00:36:22.730
and a number of other patterns.

00:36:25.730 --> 00:36:31.230
You can automatically synthesize parts
of the implementation using properties.

00:36:31.660 --> 00:36:35.050
And those synthesized bits of
functionality can be atomic,

00:36:35.210 --> 00:36:39.630
meaning that under threading,
if you pound on a property setter from

00:36:39.630 --> 00:36:45.100
two threads at the same time with atomic,
it won't crash.

00:36:45.380 --> 00:36:47.400
It might not do quite the right thing,
but it won't crash.

00:36:47.400 --> 00:36:51.000
Whereas non-atomic's a
little more efficient,

00:36:51.040 --> 00:36:51.760
not quite as safe.

00:36:51.800 --> 00:36:56.330
You'll see on the iPhone,
most of the UI kit uses non-atomic

00:36:56.390 --> 00:37:00.530
throughout because the user
interface is intended to only

00:37:00.660 --> 00:37:02.830
be used from the main thread.

00:37:05.350 --> 00:37:09.780
On the, what we call, modern runtime,
which is the runtime

00:37:09.780 --> 00:37:13.330
that's on the iPhone OS,
as well as the 64-bit runtime

00:37:13.530 --> 00:37:16.810
on Leopard and Snow Leopard,
you can actually synthesize

00:37:16.810 --> 00:37:18.200
the instance variable storage.

00:37:21.210 --> 00:37:23.820
And this will take care of
basically creating the slots

00:37:23.820 --> 00:37:24.940
to store the data away.

00:37:24.940 --> 00:37:28.320
When you go this route, though,
at the moment,

00:37:28.320 --> 00:37:31.420
you can't actually directly
access the instance variables.

00:37:31.440 --> 00:37:35.980
So it's actually interesting
because this allows you to both

00:37:36.510 --> 00:37:39.610
synthesize the storage so you don't
have to worry about that part,

00:37:39.680 --> 00:37:42.700
but it also means that there's no way
someone can go in through a back door

00:37:42.700 --> 00:37:44.560
to change that value out from under you.

00:37:45.200 --> 00:37:48.890
So if you have some custom logic
or whatever that you need to do,

00:37:48.890 --> 00:37:52.290
this is a way to guarantee that
it gets called at this time.

00:37:54.740 --> 00:37:58.790
And this brings us to
the dynamic runtime.

00:37:58.850 --> 00:38:02.440
So we've talked about the syntax,
we've talked about memory management,

00:38:02.440 --> 00:38:03.780
method invocation.

00:38:05.260 --> 00:38:09.640
All of which is built on
top of this dynamic runtime.

00:38:09.660 --> 00:38:16.530
And it's important to know that
every method call in Objective-C will

00:38:16.530 --> 00:38:19.150
be dispatched by the runtime.

00:38:19.350 --> 00:38:21.350
It will go through the
runtime dispatchers.

00:38:21.360 --> 00:38:25.400
It will go through the
runtime mechanisms.

00:38:25.420 --> 00:38:27.420
No exceptions.

00:38:28.930 --> 00:38:32.030
And that in and of itself is
very much an enabling technology.

00:38:32.030 --> 00:38:37.780
It's a pattern or a feature that
drives implementation or drives

00:38:37.780 --> 00:38:41.680
the patterns of functionality
across the rest of the frameworks.

00:38:43.440 --> 00:38:46.960
In particular,
that runtime is what enables

00:38:47.360 --> 00:38:51.520
the ability to introspect
object capabilities very easily.

00:38:51.560 --> 00:38:53.480
So you can ask objects, "Hey,
can you do this?

00:38:53.610 --> 00:38:57.500
Can you do that?" And you'll
see this in Cocoa a lot.

00:38:57.500 --> 00:39:00.290
You'll see a pattern called delegation.

00:39:00.500 --> 00:39:04.430
Which allows Object A to ask Object B,
"Hey, do you care about,

00:39:04.540 --> 00:39:06.400
do you want to do something about this?

00:39:06.510 --> 00:39:09.570
Okay, go do something about it."
Which allows you to avoid

00:39:09.610 --> 00:39:11.140
subclassing in a lot of cases.

00:39:11.140 --> 00:39:14.540
It allows for simpler
implementation patterns.

00:39:15.900 --> 00:39:18.670
This also means that dynamic loading,
when you dynamically

00:39:18.670 --> 00:39:21.970
load a chunk of code,
you can extend existing classes

00:39:22.000 --> 00:39:24.330
through the use of categories.

00:39:24.360 --> 00:39:27.930
And because every dispatch is
going to go through that runtime,

00:39:28.000 --> 00:39:33.000
those additional methods that you've
added to those classes will be visible.

00:39:33.000 --> 00:39:35.980
And of course,
because of introspection and the

00:39:36.220 --> 00:39:39.870
ability for the runtime to go,
yes, that object does that, no,

00:39:39.870 --> 00:39:44.180
it doesn't do that, that means that this
additional functionality will

00:39:44.370 --> 00:39:46.160
immediately become visible.

00:39:46.160 --> 00:39:48.850
There's no hidden stuff.

00:39:48.860 --> 00:39:50.180
There's no static finals.

00:39:50.180 --> 00:39:53.320
There's no optimizer, say,
running that's going to fold

00:39:53.380 --> 00:39:54.900
or inline a method on you.

00:39:57.440 --> 00:40:00.180
You can also dynamically construct
implementation as needed.

00:40:00.350 --> 00:40:02.130
Now,
this is not something you're typically

00:40:02.150 --> 00:40:10.610
going to do when you're writing the code,
but it is a pattern that is very useful

00:40:10.610 --> 00:40:10.610
to be aware of because there's a lot of
functionality on the system that uses it.

00:40:10.760 --> 00:40:15.130
There's a full runtime provided
in the Objective-C runtime itself,

00:40:15.140 --> 00:40:17.850
a C-based runtime,
so you can go and you can

00:40:17.850 --> 00:40:21.080
actually construct class
on the fly if you want to.

00:40:21.100 --> 00:40:25.440
With the at dynamic properties,
there's this method,

00:40:25.460 --> 00:40:26.640
resolve instance method.

00:40:26.660 --> 00:40:30.360
Go read the documentation on that
and you can actually see how to

00:40:30.360 --> 00:40:34.950
dynamically construct the setter
or the getter for a property.

00:40:36.340 --> 00:40:39.570
And in particular,
this dynamic runtime enables very

00:40:39.570 --> 00:40:41.570
rich proxying and bridging solutions.

00:40:45.720 --> 00:40:52.690
So when we talk about this enabling
technology above the dynamic runtime,

00:40:52.690 --> 00:40:56.250
and we talk about things like
categories and properties and protocols,

00:40:56.970 --> 00:41:01.100
These are pervasively used throughout
Cocoa and throughout the iPhone OS.

00:41:01.100 --> 00:41:05.710
You'll see patterns like the delegation,
the key value coding,

00:41:05.710 --> 00:41:08.680
key value observation, Cocoa bindings,
even things like

00:41:08.720 --> 00:41:11.830
Interface Builder itself,
which Interface Builder is allowing

00:41:11.890 --> 00:41:15.340
you to graphically configure a bunch
of objects for your user interface.

00:41:15.340 --> 00:41:18.780
When you hit save,
it doesn't generate code.

00:41:19.000 --> 00:41:23.770
It uses the NS coding protocol
to archive a binary copy of that

00:41:23.780 --> 00:41:27.980
configuration of the user interface
that can then use the NS coding protocol

00:41:27.980 --> 00:41:30.820
at runtime to pull that back in,
connect everything back up.

00:41:30.900 --> 00:41:34.980
Again, connecting everything,
that's a lot of introspection,

00:41:35.010 --> 00:41:39.000
key value coding, the bindings is using
key value observation,

00:41:39.000 --> 00:41:39.580
etc.

00:41:42.210 --> 00:41:48.470
Core Data, which uses dynamic property
generation and actually will generate

00:41:48.570 --> 00:41:52.110
classes at runtime for your models.

00:41:52.510 --> 00:41:56.430
Again, it allows Core Data to be a
much simpler implementation,

00:41:56.430 --> 00:41:59.020
while at the same time achieving
levels of performance that are

00:41:59.020 --> 00:42:00.570
just really frankly astonishing.

00:42:00.580 --> 00:42:04.100
And I encourage you to
go to Cocoa Fundamentals.

00:42:04.260 --> 00:42:07.790
Even if you're an iPhone OS programmer,
if it fits into your schedule,

00:42:07.870 --> 00:42:11.110
go to Cocoa Fundamentals,
because so much of the Cocoa Fundamentals

00:42:11.120 --> 00:42:12.430
is universal to the iPhone.

00:42:12.440 --> 00:42:17.480
And the What's New in Core Data session
is very interesting as well.

00:42:20.150 --> 00:42:22.360
So when we talk about the
introspection and delegation,

00:42:22.380 --> 00:42:26.640
this is a pattern that is pervasive
enough I really wanted to call it out.

00:42:26.680 --> 00:42:30.200
When an application is launched,
the NS application,

00:42:30.380 --> 00:42:34.790
the one shared application
object that's created in every

00:42:34.840 --> 00:42:39.490
Cocoa application as it launches,
it has a delegate.

00:43:00.750 --> 00:43:00.750
And you'll typically set that
delegate up in Interface Builder.

00:43:00.750 --> 00:43:00.750
You can do it in code if you want.

00:43:00.750 --> 00:43:00.750
And the first thing the application
does is it asks its delegate,

00:43:00.750 --> 00:43:00.750
"Hey, delegate,
do you respond to the selector?

00:43:00.750 --> 00:43:00.750
Application will finish
launching." And if it does,

00:43:00.750 --> 00:43:00.750
it calls it.

00:43:00.750 --> 00:43:00.750
Now, what's interesting about this
is this means as a developer,

00:43:00.750 --> 00:43:00.750
you don't have to subclass
the application class.

00:43:00.980 --> 00:43:04.000
You can have kind of an application
controller thing that maybe does

00:43:04.170 --> 00:43:07.330
some application control stuff and
maintains some other state in your

00:43:07.520 --> 00:43:11.180
app that can also help customize
the launching of an application.

00:43:11.220 --> 00:43:15.460
And you'll see there's probably, I think,
close to a dozen of these delegate

00:43:15.460 --> 00:43:17.830
methods for application alone.

00:43:18.050 --> 00:43:23.280
Some other classes that have delegates,
the file manager for handling files,

00:43:23.420 --> 00:43:27.800
file creation and file errors,
NSKeyedArchiver,

00:43:27.840 --> 00:43:30.590
which is a part of the NSCoding protocol.

00:43:36.030 --> 00:43:44.040
This is actually interesting because
this allows you to do things like if you,

00:43:44.290 --> 00:43:48.260
say, rewrite your app for a 2.0,
you can use the NSKeyedArchiver delegate

00:43:48.660 --> 00:43:53.280
to help convert your 1.0 data without
actually having to subclass and greatly

00:43:53.400 --> 00:43:55.500
change the Cocoa coding mechanism.

00:43:55.500 --> 00:43:58.720
The XML parser,
there's a number of others.

00:43:58.860 --> 00:44:03.200
At the application layer,
NSWindow is very much like NSApplication.

00:44:03.200 --> 00:44:07.220
You can use the delegates to do
things like change the way the

00:44:07.220 --> 00:44:09.290
window resize behavior works.

00:44:09.370 --> 00:44:11.780
If you want a window that's
always four by three,

00:44:11.780 --> 00:44:15.750
you could do the math in the delegate
method to ensure that that's the case.

00:44:15.800 --> 00:44:19.040
NSTableView, NSImage, NSText,
all of these things have these

00:44:19.130 --> 00:44:23.060
delegates that allow you to control
their behavior without subclassing.

00:44:23.100 --> 00:44:23.100
And the same thing with the XML parser.

00:44:23.100 --> 00:44:23.100
If you're new to Objective-C,
there's a number of other applications

00:44:23.100 --> 00:44:23.100
that allow you to do things like change
the way the window resize behavior works.

00:44:23.100 --> 00:44:23.100
If you want a window that's
always four by three,

00:44:23.100 --> 00:44:23.100
you could do the math in the delegate
method to ensure that that's the case.

00:44:23.100 --> 00:44:27.650
And the same is true on the phone.

00:44:30.790 --> 00:44:34.420
So when we talk about dynamic loading,
there's an NSBundle class.

00:44:34.420 --> 00:44:37.810
And this is just a little snippet of code
that actually shows loading a bundle.

00:44:37.820 --> 00:44:40.940
And I wanted to call this out
briefly because Objective-C,

00:44:40.940 --> 00:44:43.420
one thing it doesn't have is namespaces.

00:44:43.420 --> 00:44:47.080
It's something that a lot of people
have requested over the years.

00:44:47.180 --> 00:44:49.630
We are definitely aware of
the need for namespaces.

00:44:49.660 --> 00:44:54.400
But we frankly haven't come up with
what we would consider to be an elegant

00:44:54.400 --> 00:44:58.280
enough solution to provide at this point.

00:44:58.760 --> 00:45:00.640
You need to keep that in mind.

00:45:00.650 --> 00:45:02.670
Avoid namespace conflicts.

00:45:02.820 --> 00:45:03.820
They can be problematic.

00:45:03.950 --> 00:45:05.900
Typically, it's done by having a prefix.

00:45:05.970 --> 00:45:09.380
If you notice,
all the Cocoa classes have NS.

00:45:09.420 --> 00:45:13.990
All the iPhone classes have UI,
Core Animation, CA.

00:45:14.250 --> 00:45:15.980
So pick some free prefix.

00:45:15.980 --> 00:45:20.550
I would suggest three letters
because I don't think any of

00:45:20.550 --> 00:45:22.040
Apple's stuff uses three letters.

00:45:25.450 --> 00:45:28.700
And when we talk about dynamically
generated implementation,

00:45:28.730 --> 00:45:32.100
this is not a piece of code that I want
to go into in terribly much detail,

00:45:32.100 --> 00:45:33.000
but it's rather advanced.

00:45:33.000 --> 00:45:36.670
It's also not a piece of code that
I would expect that many of you

00:45:36.670 --> 00:45:38.790
are ever going to need to write.

00:45:38.800 --> 00:45:42.970
However, I wanted to call it out because
this is a demonstration of the use

00:45:42.970 --> 00:45:45.280
of the Objective-C API underneath.

00:45:46.730 --> 00:45:51.900
So you'll see things like selector
manipulation and adding methods,

00:45:51.900 --> 00:45:53.060
etc.

00:45:53.060 --> 00:45:55.950
And these are bits of functionality
that are actually leveraged quite

00:45:55.950 --> 00:45:58.340
a bit in the Cocoa frameworks.

00:46:00.470 --> 00:46:02.900
So when we talk about
proxying and bridging,

00:46:02.930 --> 00:46:06.790
this is another pattern
that you will see often.

00:46:06.910 --> 00:46:09.670
For example, the scripting bridge.

00:46:09.810 --> 00:46:14.860
Which allows basically you to
generate an Objective-C class whose

00:46:14.860 --> 00:46:19.370
API talks via Apple script through,
not really actually Apple script,

00:46:19.380 --> 00:46:22.560
via Apple event to an application.

00:46:22.580 --> 00:46:24.790
And it generates those
classes on the fly from that

00:46:24.790 --> 00:46:27.490
application scripting dictionary.

00:46:28.320 --> 00:46:32.240
So this actually allows you to treat,
say, iTunes as an object,

00:46:32.380 --> 00:46:34.690
as an instance of some class.

00:46:35.260 --> 00:46:38.500
The bridges between Objective-C and
scripting languages,

00:46:38.500 --> 00:46:41.420
it turns out Objective-C is
a very natural language to

00:46:41.420 --> 00:46:45.500
bridge to other languages
because of this dynamic runtime.

00:46:46.020 --> 00:46:48.750
They all use these APIs.

00:46:48.880 --> 00:46:51.230
In particular,
they use something called Bridge Support,

00:46:51.340 --> 00:46:54.230
which is a bunch of metadata
on the disk that describes

00:46:54.310 --> 00:46:55.720
all the APIs in the system.

00:46:55.720 --> 00:46:59.380
And the Cocoa Development Using Scripting
session later on in the week is

00:46:59.380 --> 00:47:02.540
actually going to cover a lot
of this information in detail.

00:47:02.540 --> 00:47:06.480
If this is of interest,
I highly recommend that you go see that.

00:47:08.000 --> 00:47:09.660
And finally, proxying.

00:47:09.730 --> 00:47:12.660
So what proxying allows you
to do is literally create

00:47:12.660 --> 00:47:18.000
an object that's a proxy,
that's a stand-in for another object.

00:47:18.860 --> 00:47:22.550
And that stand-in can capture
all the method calls that would

00:47:22.550 --> 00:47:26.890
normally go to the real object
and do something about it.

00:47:27.060 --> 00:47:32.090
In the case of key value observation,
every time you say use Cocoa bindings

00:47:32.250 --> 00:47:36.800
or you're using core data,
it's actually creating a proxy for your

00:47:36.800 --> 00:47:42.570
object such that any time the setter
or the getter is called via protocol

00:47:42.570 --> 00:47:47.130
or via properties or via the methods,
the key value observation proxy will

00:47:47.130 --> 00:47:51.620
pick that up and give other parts
of your application notification

00:47:51.700 --> 00:47:56.180
that something's about to be read,
about to change, or that it did change.

00:47:56.760 --> 00:47:59.120
Distributed Objects,
which is a technology that's

00:47:59.200 --> 00:48:02.370
built into the foundation,
uses proxies,

00:48:02.370 --> 00:48:06.390
and it literally enables a local proxy,
a local object.

00:48:06.600 --> 00:48:32.300
[Transcript missing]

00:48:34.990 --> 00:48:39.200
So, Objective-C.

00:48:39.320 --> 00:48:43.080
It's a small set of additions to C,
as you've seen.

00:48:43.190 --> 00:48:46.540
And the focus is really
on simple and consistent.

00:48:46.700 --> 00:48:48.970
And through that, I believe, elegant.

00:48:49.030 --> 00:48:50.750
I've been doing this for a while.

00:48:50.940 --> 00:48:53.420
It's built on top of a dynamic runtime.

00:48:53.490 --> 00:48:58.320
That dynamic runtime is both there for
your use as well as leveraged heavily

00:48:58.480 --> 00:49:00.880
by the frameworks that you'll be using.

00:49:01.460 --> 00:49:04.160
It uses a very simple object model.

00:49:04.190 --> 00:49:06.220
You have single inheritance.

00:49:06.410 --> 00:49:08.580
You don't have type-based dispatch.

00:49:08.700 --> 00:49:13.850
But this also means that you don't
have things like namespace mangling

00:49:13.980 --> 00:49:17.200
and other complexities of debugging.

00:49:17.200 --> 00:49:23.500
You can reuse interfaces
through the use of protocols,

00:49:23.500 --> 00:49:26.870
which you've seen are used quite
often in the Cocoa and on the iPhone.

00:49:29.690 --> 00:49:32.010
It has a very simple
method dispatch mechanism.

00:49:32.040 --> 00:49:35.020
Every single method goes
through that dispatcher.

00:49:35.040 --> 00:49:37.370
There's no type-based dispatch.

00:49:37.440 --> 00:49:39.870
There are selectors.

00:49:39.940 --> 00:49:41.830
Selectors are method names.

00:49:41.840 --> 00:49:45.030
Selectors are first class
type in Objective-C,

00:49:45.040 --> 00:49:47.190
and you will see them often.

00:49:48.540 --> 00:49:50.440
There are labs.

00:49:50.470 --> 00:49:52.980
We will actually be in the
labs pretty much all week long.

00:49:52.990 --> 00:49:55.820
So if you want to find us, come down,
look for the team.

00:49:56.000 --> 00:49:58.690
We're happy to answer
any questions you have.

00:49:58.800 --> 00:50:00.480
If you see us in the hallways,
pull us aside.

00:50:00.480 --> 00:50:03.080
We're quite happy to help.

00:50:03.080 --> 00:50:07.420
There's official lab times as
well for the Objective-C 2.0 lab,

00:50:07.440 --> 00:50:10.760
and as well as garbage collection lab,
which I don't know why

00:50:10.760 --> 00:50:12.020
it wasn't on there.

00:50:12.060 --> 00:50:14.480
There's some publications.

00:50:14.690 --> 00:50:15.600
Thank you, Bill.

00:50:15.600 --> 00:50:21.600
I'm going to go ahead and introduce
you to the next section of the session.

00:50:21.600 --> 00:50:23.600
Objective-C is C.

00:50:23.600 --> 00:50:27.330
There's the classic Kernegan and Ritchie,
the original C programming language book,

00:50:27.390 --> 00:50:28.590
or C for Dummies.

00:50:28.660 --> 00:50:31.600
It's another very good book, actually.

00:50:31.600 --> 00:50:37.450
As well, there's lots and lots of
documentation on your systems already.

00:50:37.700 --> 00:50:39.990
The Objective-C 2.0 programming
language is an excellent document,

00:50:40.090 --> 00:50:40.540
though.

00:50:40.540 --> 00:50:44.780
Object-oriented programming in
Objective-C is just another great way

00:50:44.780 --> 00:50:45.590
to use object-oriented programming.

00:50:45.600 --> 00:50:54.490
It's a really nice piece of introduction
to object-oriented programming,

00:50:54.490 --> 00:50:55.100
too.

00:50:56.680 --> 00:51:00.980
There's the Cocoa Fundamentals Guide and
the iPhone OS Programming Guide,

00:51:01.130 --> 00:51:06.030
which of course are all built on top of
the foundations provided by Objective-C.

00:51:06.930 --> 00:51:09.910
There's some very,
very useful mailing lists as well.

00:51:09.910 --> 00:51:14.000
There's the CocoaDev
and the OBSI-Lang list.

00:51:14.040 --> 00:51:16.010
Sorry, I call it OBSI-Dev.

00:51:16.070 --> 00:51:18.960
These lists are on Apple's list server.

00:51:18.960 --> 00:51:21.960
The community of people in
there are extremely helpful.

00:51:21.960 --> 00:51:25.230
If you have questions,
bring them to these lists and

00:51:25.380 --> 00:51:28.280
you'll find the answers very,
very quickly.

00:51:28.280 --> 00:51:32.110
The archives are all online as well,
and there's extensive

00:51:32.110 --> 00:51:34.100
resources in the archives.

00:51:35.480 --> 00:51:39.290
These are wonderful just reference
materials as well as being a really

00:51:39.290 --> 00:51:40.700
warm and friendly community of people.

00:51:43.060 --> 00:51:43.900
Useful people.

00:51:43.900 --> 00:51:48.600
There's one of them right here,
Michael Jurowicz, the seventh.

00:51:48.600 --> 00:51:50.720
There's also Derek Horn.

00:51:54.410 --> 00:51:57.200
And, of course,
plenty of documentation in the

00:51:57.200 --> 00:52:00.500
Mac Dev Center and the iPhone Dev Center.

00:52:00.630 --> 00:52:04.600
With that,
I would like to open this up for some QA.
WEBVTT

00:00:20.870 --> 00:00:22.650
Hello, thank you all for coming.

00:00:22.740 --> 00:00:26.970
Welcome to session 401,
Leveraging Cocoa's Layer-Backed Views.

00:00:27.090 --> 00:00:30.360
Our topic for this morning's talk
is an AppKit level technology

00:00:30.690 --> 00:00:32.830
that we introduced in Leopard,
and we like to call

00:00:32.830 --> 00:00:33.920
it Layer-Backed Views.

00:00:33.920 --> 00:00:36.530
And I'll talk a little bit in
a moment about what exactly

00:00:36.620 --> 00:00:38.100
I mean when I use that term.

00:00:38.100 --> 00:00:40.530
My name is Troy Stephens.

00:00:40.650 --> 00:00:43.000
I'm an AppKit engineer.

00:00:43.810 --> 00:00:46.660
For the most part,
this is oriented as sort of

00:00:46.740 --> 00:00:50.250
an intermediate-level talk,
such that you may get the most

00:00:50.360 --> 00:00:52.890
benefit out of it if you've already
had the opportunity to sort of

00:00:52.890 --> 00:00:55.670
get your hands in there and start
experimenting with using Layer-Backed

00:00:55.790 --> 00:00:56.980
View functionality in AppKit.

00:00:56.980 --> 00:00:59.570
However,
for the benefit of those who have not,

00:00:59.580 --> 00:01:02.300
and also to help put the
rest of the talk in context,

00:01:02.300 --> 00:01:05.250
I will begin with a brief review,
sort of looking at what

00:01:05.590 --> 00:01:07.960
Layer-Backed View mode is,
and why we introduced

00:01:07.960 --> 00:01:10.440
this new operating mode,
and why it might be interesting

00:01:10.440 --> 00:01:12.140
for your applications to work with.

00:01:12.960 --> 00:01:15.490
From there,
we will dive in quickly to new material

00:01:15.490 --> 00:01:18.620
and sort of the meat of the talk,
which will be a series of tips

00:01:18.620 --> 00:01:21.840
and tricks-style topics designed
to help sort of demystify the

00:01:21.930 --> 00:01:25.620
operation of Layer-Backed View mode
and provide answers to some common

00:01:25.730 --> 00:01:29.200
questions that we get from developers
about using Layer-Backed Views.

00:01:29.240 --> 00:01:32.480
And I'd also like to point out that there
are a couple of pieces of sample code

00:01:32.480 --> 00:01:35.950
that will be available very shortly that
illustrate some of the techniques that

00:01:35.970 --> 00:01:39.150
I'll be talking about in this session,
so I encourage you to download that

00:01:39.150 --> 00:01:41.980
sample code when it becomes available
and examine it at your leisure.

00:01:41.980 --> 00:01:44.830
To get some more concrete ideas
and code that you can copy and

00:01:44.830 --> 00:01:48.120
paste into your own apps or emulate
to perform these techniques.

00:01:48.120 --> 00:01:51.180
So first, a quick review,
sort of a recap.

00:01:51.180 --> 00:01:54.910
What exactly is Layer-Backed View mode,
and what do we mean

00:01:54.970 --> 00:01:56.720
when we talk about this?

00:01:57.420 --> 00:02:01.770
Layer-backed View Mode is a special
operating mode of AppKit's NSView system

00:02:01.850 --> 00:02:05.360
of the view hierarchy that is based
on Core Animation's rendering and

00:02:05.410 --> 00:02:08.490
compositing model and animation engine.

00:02:08.830 --> 00:02:10.850
Core Animation,
as is widely known by now,

00:02:10.950 --> 00:02:15.270
is a very powerful framework for
compositing and animating content.

00:02:15.460 --> 00:02:19.980
It is the basis for the amazing
iPhone and iPod Touch user interfaces.

00:02:20.160 --> 00:02:22.970
It's an Objective-C API,
part of the same Quartz

00:02:23.130 --> 00:02:27.100
Core framework that encompasses
Core Image and Core Video.

00:02:27.790 --> 00:02:29.610
Core Animation presents to you,
the developer,

00:02:29.720 --> 00:02:33.670
the model of a tree or hierarchy
of layers that are in many ways

00:02:33.700 --> 00:02:37.320
analogous to AppKit's NSViews
and AppKit's NSView hierarchy.

00:02:37.320 --> 00:02:42.040
Each layer has its own position
and orientation and bounds.

00:02:42.040 --> 00:02:45.580
It has content that it either
displays or is drawn within it.

00:02:45.670 --> 00:02:48.660
Each layer has its own local
coordinate system that it draws into,

00:02:48.660 --> 00:02:51.290
so it doesn't have to worry
about what context it's in.

00:02:51.290 --> 00:02:53.750
Every layer has its own little world.

00:02:53.770 --> 00:02:56.100
Layers can have sublayers,
and those sublayers can

00:02:56.100 --> 00:02:57.550
have sublayers of their own.

00:02:57.850 --> 00:03:00.640
The Core Animation layer provides
the tree or hierarchy construct,

00:03:00.640 --> 00:03:03.810
so you have the ability to build very
complex kinds of scenes with layers.

00:03:03.810 --> 00:03:06.690
There are a lot of architectural
similarities that you'll notice as

00:03:06.690 --> 00:03:09.290
you look at the CA Layer API and
compare it with the NSView API,

00:03:09.290 --> 00:03:11.640
but there are also some very
important key differences,

00:03:11.740 --> 00:03:14.120
and I'd like to talk
about some of those today.

00:03:14.120 --> 00:03:17.960
One of the most important features of
layers that makes Core Animation layer

00:03:17.960 --> 00:03:21.750
compositing so powerful is that you
have per-layer content buffering.

00:03:21.760 --> 00:03:25.480
So this is distinct from what you're used
to with working with NSViews with the

00:03:25.480 --> 00:03:27.680
ordinary compositing model for views.

00:03:27.700 --> 00:03:30.710
You can see that you have a window
where all of the rendering that

00:03:30.980 --> 00:03:33.760
views do becomes inextricably
intertwined in the window.

00:03:33.760 --> 00:03:35.780
We're rendering into a
single-window backing store,

00:03:35.840 --> 00:03:37.900
so any time you need to update
some part of the window,

00:03:37.900 --> 00:03:41.610
you end up having to go through and
redraw all of the views that touch

00:03:41.620 --> 00:03:44.850
that part of the window because all
the data gets mixed together in the

00:03:44.850 --> 00:03:46.520
pixels of the window backing store.

00:03:46.520 --> 00:03:48.870
So when you're in layer-backed
mode or when you're using

00:03:48.870 --> 00:03:52.280
Core Animation layers to render,
you have per-layer content buffering.

00:03:52.280 --> 00:03:55.890
Each layer gets its own backing store,
and obviously this costs a

00:03:55.890 --> 00:03:57.680
bit more in terms of graphic.

00:03:57.740 --> 00:03:59.900
So you can see that you
have a lot of pixels now,

00:03:59.900 --> 00:04:02.140
and you have a backing
store for each layer.

00:04:02.140 --> 00:04:04.680
But at the same time,
it enables some very powerful fluid

00:04:04.780 --> 00:04:08.080
kind of animation techniques because
rather than spending a whole lot of

00:04:08.080 --> 00:04:12.260
time redrawing content that is static,
we can very quickly move things around

00:04:12.260 --> 00:04:14.500
and just recomposite them as we go.

00:04:16.140 --> 00:04:18.900
Along with this,
Core Animation provides a very powerful

00:04:18.910 --> 00:04:21.750
implied animation model wherein,
by default,

00:04:21.960 --> 00:04:26.550
changing any property of a layer
initiates an animation or interpolation

00:04:26.550 --> 00:04:30.640
to the new value over time rather than
immediately jumping to the new value.

00:04:30.760 --> 00:04:34.590
This animation model is also asynchronous
in that Core Animation executes

00:04:34.590 --> 00:04:38.140
animations on a background thread such
that they're not waiting on your main

00:04:38.140 --> 00:04:39.660
thread's run loop or things like that.

00:04:39.800 --> 00:04:43.950
It's all happening asynchronously
in a way that everything

00:04:43.950 --> 00:04:45.750
is very nice and fluid.

00:04:46.580 --> 00:04:48.650
In addition to this,
Core Animation provides a very

00:04:48.650 --> 00:04:51.500
powerful and expressive set of
animation description classes.

00:04:51.500 --> 00:04:54.090
There are six classes,
four of them are concrete,

00:04:54.120 --> 00:04:56.620
and from those you can compose
just about any kind of animation

00:04:56.620 --> 00:04:59.500
description that you can imagine,
put together a request for

00:04:59.630 --> 00:05:02.180
a kind of animation that
you want to show on screen.

00:05:02.180 --> 00:05:04.840
And these classes are so powerful,
CA Animation and all of

00:05:04.840 --> 00:05:07.330
its descendant classes,
that we've adopted the use of

00:05:07.330 --> 00:05:10.660
these and lifted them up from
Core Animation up to the AppKit layer.

00:05:10.660 --> 00:05:14.480
We're using them in AppKit APIs as
the means for expressing animations

00:05:14.480 --> 00:05:16.130
for views and for windows.

00:05:16.500 --> 00:05:17.700
Thank you.

00:05:18.600 --> 00:05:28.660
Core Animation features:
Core Image Filter Effects, Shadows,

00:05:28.690 --> 00:05:30.600
and Masking.

00:05:30.600 --> 00:05:35.660
Core Animation also serves as a
powerful unifying graphics architecture,

00:05:35.760 --> 00:05:37.600
the likes of which we haven't had before.

00:05:37.600 --> 00:05:46.040
Core Animation features: Quartz Composer,
OpenGL, QuickTime Movie Playback,

00:05:46.040 --> 00:05:51.600
and Core Animation Layer Tree.

00:05:51.680 --> 00:05:55.300
There are a number of things
that Core Animation does not

00:05:55.420 --> 00:05:59.560
attempt to provide that are
beyond the scope of its design.

00:05:59.600 --> 00:06:02.800
First and foremost,
Core Animation is not a

00:06:02.800 --> 00:06:04.600
user interface toolkit.

00:06:04.720 --> 00:06:07.600
Although it is the foundation for
other powerful user interfaces,

00:06:07.600 --> 00:06:11.670
such as UIKit on the phone and
the Layer-Backed View mode of

00:06:11.930 --> 00:06:14.600
AppKit's NSView system on the Mac.

00:06:14.600 --> 00:06:19.670
You won't find things like buttons,
sliders, table views,

00:06:19.670 --> 00:06:22.600
all the sorts of UI elements that you
usually build your interfaces from,

00:06:22.600 --> 00:06:25.590
that you use to present data to users
and allow them to edit that data.

00:06:25.600 --> 00:06:28.690
All of that stuff is beyond
the scope of Core Animation,

00:06:28.690 --> 00:06:33.080
which is really focused as a
graphics-level compositing and animation

00:06:33.150 --> 00:06:35.780
framework that's very lean and mean.

00:06:36.150 --> 00:06:38.420
So in hand with that,
there are a bunch of other consequences.

00:06:38.460 --> 00:06:41.610
You won't see things like high-level
event handling mechanisms,

00:06:41.620 --> 00:06:44.140
the concept of input
focus or first responder,

00:06:44.140 --> 00:06:47.880
the responder chain for delegating
responsibility for handling events,

00:06:47.880 --> 00:06:51.670
things like accessibility support,
drag and drop, tooltips, cursor wrecks,

00:06:51.670 --> 00:06:52.710
tracking wrecks.

00:06:52.720 --> 00:06:55.510
These are all user interface
toolkit-level features that you

00:06:55.510 --> 00:06:58.400
really need something more like
AppKit or UIKit to provide.

00:07:01.190 --> 00:07:04.200
So we have these two sorts of frameworks,
and when Core Animation came along,

00:07:04.200 --> 00:07:07.600
we thought, well,
we wanted to really enable developers

00:07:07.600 --> 00:07:10.820
to readily take advantage of all these
great animation capabilities to take

00:07:10.820 --> 00:07:16.860
advantage of the benefits of per-layer or
per-view content buffering very easily.

00:07:16.860 --> 00:07:21.140
But we didn't want you guys to
have to rewrite your user interface

00:07:21.230 --> 00:07:25.360
code or design and build whole
new UIs in Interface Builder.

00:07:25.860 --> 00:07:28.780
Leo Parmigiano-Rossi So basically
what we came up with was the idea of

00:07:28.880 --> 00:07:32.460
offering automatic mirroring of a view
tree into a corresponding layer tree,

00:07:32.460 --> 00:07:37.000
where you continue to work primarily
with views and let AppKit automatically

00:07:37.000 --> 00:07:40.360
manage a layer tree into which
that view tree is mirrored.

00:07:40.360 --> 00:07:45.070
And this basic concept is what I'm
referring to as layer-backed views.

00:07:45.100 --> 00:07:49.930
And to get a concrete visual illustration
of just exactly what I'm talking about,

00:07:49.930 --> 00:07:53.480
let's take a trip back down memory
lane and go to demo and take a

00:07:53.520 --> 00:07:55.820
look at Cocoa's Layer-Backed Views.

00:07:55.860 --> 00:07:59.070
So we have Cocoa Slides,
which is the application that was

00:07:59.070 --> 00:08:02.570
used to demo this functionality
when it was first introduced,

00:08:02.570 --> 00:08:04.580
and we'll launch Cocoa Slides.

00:08:04.810 --> 00:08:09.140
This is a simple sort of image browser
that presents a bunch of thumbnails of

00:08:09.150 --> 00:08:14.820
image files as slides for anyone here
who knows what slides are or remembers.

00:08:14.840 --> 00:08:19.070
The main take-home point here,
and I want to point out that this is

00:08:19.070 --> 00:08:23.400
available publicly as sample code,
developer.apple.com slash sample

00:08:23.480 --> 00:08:26.640
code slash Cocoa Slides or search
for Cocoa Slides on the ADC site.

00:08:26.800 --> 00:08:29.210
This remains an excellent
example of how to do a number of

00:08:29.260 --> 00:08:30.990
things with Layer-Backed Views.

00:08:31.020 --> 00:08:33.820
The interesting thing to note
here is that this entire user

00:08:33.820 --> 00:08:35.550
interface is built using views.

00:08:35.560 --> 00:08:39.510
When you look at the source code,
you'll notice there's very little in here

00:08:39.510 --> 00:08:43.760
that has to do with either animation or
even less to do with layers directly.

00:08:43.760 --> 00:08:47.910
All the code manipulates views directly,
so these are all views in here,

00:08:47.910 --> 00:08:50.850
except this whole area,
the sort of dark gray area,

00:08:51.260 --> 00:08:53.670
canvas area here where
all the slides are housed,

00:08:53.680 --> 00:08:54.960
is Layer-Backed.

00:08:55.000 --> 00:08:59.530
So we can do things like very readily
sort of move things around very fluidly.

00:09:00.340 --> 00:09:03.150
Because all these views have
their content automatically

00:09:03.150 --> 00:09:04.920
buffered on a per-view basis.

00:09:04.920 --> 00:09:07.310
So we're not doing re-rendering,
we're just moving things around,

00:09:07.310 --> 00:09:09.640
and Core Animation is doing all
this on a background thread.

00:09:11.470 --> 00:09:14.910
Leo Parmigiano, CEO, At the same time,
these views remain fully interactive.

00:09:14.910 --> 00:09:17.560
These are standard checkboxes, NSButtons,
in other words,

00:09:17.670 --> 00:09:19.960
the checkbox style of NSButton
at the top of each slide.

00:09:19.960 --> 00:09:21.240
We can check off some slides.

00:09:21.300 --> 00:09:23.180
Let's say we want to show a slideshow.

00:09:23.180 --> 00:09:26.290
Here's another feature that
we get by being layer-backed.

00:09:26.340 --> 00:09:29.660
We have the opportunity to use
all kinds of Core Image transition

00:09:29.660 --> 00:09:33.190
filters to very easily transition
between one image and another.

00:09:33.190 --> 00:09:36.190
When you look at the code for this,
it's really very simple

00:09:36.200 --> 00:09:37.310
what's being done.

00:09:37.310 --> 00:09:39.590
We specify a transition
that we want to use,

00:09:39.590 --> 00:09:43.000
and then we're just pulling
one subview out of the window,

00:09:43.000 --> 00:09:45.240
one image view that's
showing the previous image,

00:09:45.240 --> 00:09:46.940
and stick in another image view.

00:09:46.940 --> 00:09:49.070
And when we do that,
replace subview with operation

00:09:49.070 --> 00:09:53.590
through the containing views animator,
the transition gets picked up and used,

00:09:53.590 --> 00:09:55.130
and it's really very automatic.

00:09:55.280 --> 00:09:58.120
So you can do all kinds of
things very powerfully like this.

00:09:58.120 --> 00:10:01.550
But the thing to remember here
is these are all standard views.

00:10:01.600 --> 00:10:03.710
We can add things like shadow effects.

00:10:03.710 --> 00:10:06.920
That might be a little difficult to see,
but it gives you a bit

00:10:06.920 --> 00:10:08.100
more of a 3D effect.

00:10:08.170 --> 00:10:10.020
That's something we just switch on.

00:10:10.020 --> 00:10:12.280
We tell the view, set shadow.

00:10:12.450 --> 00:10:17.310
Here's a shadow to use,
and it all just sort of works.

00:10:17.500 --> 00:10:19.830
So this is sort of, visually,
this is what Layer-Backed

00:10:19.870 --> 00:10:20.920
Views are all about.

00:10:20.920 --> 00:10:24.890
Enabling you to work with views but
leverage Core Animation to get some

00:10:24.900 --> 00:10:26.870
powerful effects and fluid animations.

00:10:26.870 --> 00:10:29.520
So if we could go back to slides, please.

00:10:29.520 --> 00:10:32.620
We'll talk about how all this is done.

00:10:32.800 --> 00:10:35.130
So how does this work
in this application?

00:10:35.310 --> 00:10:38.330
How do you get your view
subtree to become layer-backed?

00:10:38.330 --> 00:10:40.510
Well, we added a simple new interface.

00:10:40.510 --> 00:10:44.870
SetWantsLayer is the setter method for a
new wants layer property that views have.

00:10:44.870 --> 00:10:46.520
This was added in Leopard.

00:10:46.520 --> 00:10:49.960
You setWantsLayer yes for a view
and it has a number of consequences.

00:10:49.980 --> 00:10:52.260
When you switch this on,
AppKit automatically

00:10:52.260 --> 00:10:53.690
mirrors that view subtree.

00:10:53.690 --> 00:10:57.280
Everything from that view on down through
its descendants all the way to the

00:10:57.280 --> 00:10:59.490
leaves into a corresponding layer tree.

00:10:59.500 --> 00:11:01.980
So each view gets a corresponding layer.

00:11:02.620 --> 00:11:04.410
We call it the views backing
layer because that's the

00:11:04.470 --> 00:11:05.530
backing store for the view.

00:11:05.600 --> 00:11:09.320
The views, as far as they're concerned,
are drawing as they normally would.

00:11:09.390 --> 00:11:12.520
They implement draw rect and they
get their draw rect called by AppKit.

00:11:12.830 --> 00:11:16.360
Only instead of the drawing
they do going into the window,

00:11:16.360 --> 00:11:19.580
AppKit redirects that drawing into
the views corresponding backing layer.

00:11:19.580 --> 00:11:24.160
So we're capturing content separately
on a sort of per view basis,

00:11:24.300 --> 00:11:28.210
the way a professional animator
might drawing cartoons on

00:11:28.220 --> 00:11:30.970
animation cells so that you don't
have to keep redrawing things.

00:11:30.970 --> 00:11:32.240
You can just move things around.

00:11:32.450 --> 00:11:34.440
To get animation effects
more efficiently.

00:11:35.060 --> 00:11:38.440
Similarly, when you mark part of the
view as needing display,

00:11:38.440 --> 00:11:39.940
we make that carry over to the layer.

00:11:39.940 --> 00:11:42.460
So we redisplay that portion of
the view into the corresponding

00:11:42.460 --> 00:11:43.560
portion of the layer.

00:11:43.560 --> 00:11:47.360
Any view property changes you make,
AppKit automatically maps those

00:11:47.360 --> 00:11:48.720
to layer property changes.

00:11:48.720 --> 00:11:51.300
We figure out which layer property
needs to change so that the layer tree

00:11:51.310 --> 00:11:53.930
that the user is actually seeing in
the window looks exactly like the view

00:11:53.930 --> 00:11:55.710
tree that you think they're seeing.

00:11:55.720 --> 00:12:02.210
And this is what we call sort of a push
model where changes are made on views.

00:12:02.260 --> 00:12:05.950
And AppKit pushes those changes over
to the corresponding layer properties.

00:12:05.960 --> 00:12:09.410
So we expect you to mostly continue
interacting with views wherever you can

00:12:09.430 --> 00:12:13.450
and let AppKit automatically push the
changes to the layer tree and manage it.

00:12:15.480 --> 00:12:19.140
Wherever possible,
AppKit delegates animation execution

00:12:19.180 --> 00:12:22.240
to Core Animation's background
threads that can be asynchronous.

00:12:22.240 --> 00:12:24.650
So if we can map animations
that you request onto

00:12:25.130 --> 00:12:27.670
animations of layer properties,
we'll do that.

00:12:27.790 --> 00:12:29.980
In some cases, that's not possible.

00:12:29.980 --> 00:12:34.750
For example, when resizing views,
currently there's no general way for a

00:12:34.750 --> 00:12:39.780
view to tell AppKit how its content will
be affected when the view is resized.

00:12:40.320 --> 00:12:42.540
So as far as we know,
to be safe and to be correct,

00:12:42.620 --> 00:12:45.790
we always have to redraw a view every
time it's resized by a little bit,

00:12:45.830 --> 00:12:47.540
including during animation.

00:12:47.540 --> 00:12:50.110
So we do those kinds of
things on the main run loop.

00:12:50.160 --> 00:12:53.060
We use, under the hood,
Core Animation's evaluation

00:12:53.060 --> 00:12:56.400
engine for CA animation,
so the results all come out the same,

00:12:56.570 --> 00:12:59.570
but they're all executed by
AppKit on the main thread.

00:12:59.580 --> 00:13:01.980
Similar thing for all
non-layer properties.

00:13:01.980 --> 00:13:04.490
Any custom properties you
define for your views,

00:13:04.490 --> 00:13:06.960
as we'll see,
that you want to make animatable,

00:13:06.960 --> 00:13:09.070
those are executed on the main thread.

00:13:10.120 --> 00:13:12.850
So visually, what this looks like,
if we have a single slide,

00:13:12.850 --> 00:13:14.840
it's actually composed
of a set of four views,

00:13:14.840 --> 00:13:16.990
or actually we have two
text fields at the bottom,

00:13:16.990 --> 00:13:17.840
so it's five.

00:13:17.840 --> 00:13:20.280
There's a slide carrier view that's
the container view at the top.

00:13:20.340 --> 00:13:23.290
You have a standard NS button,
a pretty standard image view,

00:13:23.290 --> 00:13:25.600
a simple subclass,
a text field at the bottom that

00:13:25.690 --> 00:13:27.840
specifies the dimensions of the image.

00:13:27.880 --> 00:13:31.620
So when we switch on layer backing,
AppKit magically creates a layer tree

00:13:31.750 --> 00:13:33.680
that corresponds to that view tree.

00:13:33.680 --> 00:13:37.640
Each view gets a corresponding layer,
and we wire those up together.

00:13:39.990 --> 00:13:51.520
So we have a set of four views,
and we wire those up together.

00:13:51.520 --> 00:13:51.520
Each view gets a corresponding layer,
and we wire those up together.

00:13:51.940 --> 00:13:54.970
And that in a nutshell is the
idea of Layer-Backed Views.

00:13:54.970 --> 00:13:57.640
Hopefully that's fairly
clear as an overview.

00:13:57.640 --> 00:14:00.970
So now let's dive into some tips
and techniques and some concrete

00:14:00.970 --> 00:14:04.900
tips that I hope will help you
in dealing with various issues.

00:14:04.900 --> 00:14:07.540
We'll look at layer management
and sort of the life cycles of

00:14:07.540 --> 00:14:09.130
layers and how layers come and go.

00:14:09.130 --> 00:14:11.090
Some people find these things surprising.

00:14:11.210 --> 00:14:13.980
AppKit does manage layers and
they appear and disappear and are

00:14:13.980 --> 00:14:17.430
associated and dissociated from your
views in ways that can be surprising.

00:14:17.440 --> 00:14:20.240
But if you know how to handle that,
it's not a problem.

00:14:20.240 --> 00:14:21.780
We'll look at text rendering.

00:14:21.800 --> 00:14:23.990
In Layer-Backed Mode,
people have been surprised

00:14:24.080 --> 00:14:26.460
that text rendering doesn't
quite come out the same.

00:14:26.470 --> 00:14:27.260
And why is that?

00:14:27.260 --> 00:14:28.190
We'll look at that.

00:14:28.330 --> 00:14:31.140
Driving motion programmatically,
a simple tip but a useful one.

00:14:31.260 --> 00:14:34.210
We'll look at some performance,
drawing and debugging tips.

00:14:34.260 --> 00:14:38.910
And then we'll dive into a couple more
lengthy and in-depth sections where we'll

00:14:38.910 --> 00:14:41.610
talk about how to sequence animations.

00:14:41.620 --> 00:14:44.160
People often ask, well,
how can I make animation A go first

00:14:44.270 --> 00:14:46.760
and then animation B start after that,
animation C?

00:14:46.760 --> 00:14:51.140
And that's very easily
done using CA animations.

00:14:51.140 --> 00:14:52.270
And we'll look at how to do that.

00:14:52.350 --> 00:14:55.330
And then lastly,
we'll take a look at NSView's

00:14:55.570 --> 00:14:59.780
geometry model and how it compares
to CA layers geometry model.

00:14:59.780 --> 00:15:03.390
And that's something that can be
useful to know a little bit about

00:15:03.480 --> 00:15:07.590
when you're trying to figure out what
kinds of keys to hang your animations

00:15:07.590 --> 00:15:09.510
off of and that sort of thing.

00:15:09.520 --> 00:15:11.790
We'll see that when we get to it.

00:15:12.530 --> 00:15:15.600
So first, let's talk about the
life cycles of layers.

00:15:15.620 --> 00:15:18.410
And ideally,
we want you to have your views able

00:15:18.500 --> 00:15:20.380
to operate sort of agnostically.

00:15:20.380 --> 00:15:24.020
They can work in layer-backed mode and
they can work in non-layer-backed mode.

00:15:24.020 --> 00:15:26.170
And for the most part,
for general simple views,

00:15:26.170 --> 00:15:29.150
you won't really need to worry about
which mode you're operating in,

00:15:29.150 --> 00:15:32.230
hopefully, because AppKit will take care
of all the details of mapping

00:15:32.230 --> 00:15:33.580
your view into a layer.

00:15:33.580 --> 00:15:37.640
Leo Parmigiano-Rossi But occasionally,
maybe you want to take advantage of,

00:15:37.640 --> 00:15:40.290
maybe you have a special view where,
okay, you're drawing some items and

00:15:40.350 --> 00:15:41.960
if you're in layer-backed mode,
well, hey,

00:15:41.960 --> 00:15:44.030
you can use a Core Image filter
to provide a nice highlight

00:15:44.030 --> 00:15:45.440
effect on the selected item.

00:15:45.500 --> 00:15:47.930
Leo Parmigiano-Rossi And that avoids
having to redraw the item when

00:15:47.930 --> 00:15:50.090
you want to select it or deselect
it because you just apply the

00:15:50.090 --> 00:15:51.580
filter and it's all done on the GPU.

00:15:51.580 --> 00:15:54.250
Leo Parmigiano-Rossi But you want your
view to also work in non-layer-backed

00:15:54.250 --> 00:15:55.820
mode if people are using it in that case.

00:15:55.830 --> 00:15:58.720
So you might want it to be able
to adapt to being in layer-backed

00:15:58.720 --> 00:16:00.240
or non-layer-backed mode.

00:16:00.240 --> 00:16:02.290
Leo Parmigiano-Rossi You also might
want to be able to add sub-layers of

00:16:02.380 --> 00:16:03.490
your own or set custom layer paths.

00:16:03.580 --> 00:16:05.540
Leo Parmigiano-Rossi
So how does this work?

00:16:05.650 --> 00:16:07.910
To understand this,
we first need to understand

00:16:07.910 --> 00:16:10.840
that there are two basic
modes of Core Animation usage

00:16:10.840 --> 00:16:12.280
that we support in AppKit.

00:16:12.420 --> 00:16:14.820
Leo Parmigiano-Rossi And the first
one listed here is the one that we're

00:16:14.880 --> 00:16:16.900
talking about primarily in this talk,
layer-backed views,

00:16:16.990 --> 00:16:19.570
where you have a view tree,
you flip on layer-backing,

00:16:19.730 --> 00:16:22.540
AppKit automatically creates
and manages the backing layers

00:16:22.540 --> 00:16:26.930
for you and for the most part,
you don't need to deal with them at all.

00:16:27.350 --> 00:16:31.270
We also support a standalone mode where
maybe you have a portion of your user

00:16:31.330 --> 00:16:34.060
interface where you just want to work
with Core Animation layers directly.

00:16:34.060 --> 00:16:37.200
You're not building user interface
where you need dials and sliders

00:16:37.220 --> 00:16:38.810
and buttons and things like that.

00:16:38.860 --> 00:16:42.170
You're showing some graphics or an
animation that you want to present and

00:16:42.170 --> 00:16:44.180
you just want to use CA layers directly.

00:16:44.180 --> 00:16:46.080
You may have a layer
tree you want to render.

00:16:46.960 --> 00:16:49.120
Leo Parmigiano-Rocco So the
standalone mode is a mode in

00:16:49.120 --> 00:16:52.110
which you can simply tell a view,
I want you to just be a canvas for

00:16:52.110 --> 00:16:54.360
rendering and animating this layer tree.

00:16:54.360 --> 00:16:55.300
That's all I want you to do.

00:16:55.300 --> 00:16:56.440
I'm going to give you the layer tree.

00:16:56.440 --> 00:16:58.000
You construct a layer tree yourself.

00:16:58.160 --> 00:16:59.690
You populate it with content yourself.

00:16:59.690 --> 00:17:01.380
You set up all the geometry yourself.

00:17:01.530 --> 00:17:03.420
Leo Parmigiano-Rocco You tell the view,
set layer.

00:17:03.420 --> 00:17:05.440
Here's your root layer
that I want you to render.

00:17:05.440 --> 00:17:09.030
And then you tell the view after that,
set once layer, yes.

00:17:09.030 --> 00:17:11.600
And that flips on
AppKit layer tree rendering,

00:17:11.600 --> 00:17:14.600
but we don't otherwise
interfere with the layer tree.

00:17:14.600 --> 00:17:16.930
Leo Parmigiano-Rocco The root layer
will be resized to Leo Parmigiano-Rocco

00:17:17.170 --> 00:17:19.520
fit always in the area of the
view when the view resizes,

00:17:19.580 --> 00:17:21.200
but all the other layers are left alone.

00:17:21.200 --> 00:17:24.050
And so that's for using
core animation directly.

00:17:24.050 --> 00:17:26.810
And the reason this is important
to understand these two different

00:17:26.810 --> 00:17:30.660
modes of usage is that AppKit treats
the layers that it creates and

00:17:30.660 --> 00:17:34.120
manages for you differently from
the layers that you give it.

00:17:34.200 --> 00:17:36.280
Leo Parmigiano-Rocco
If you give us a layer,

00:17:36.280 --> 00:17:38.940
we don't want to interfere
with any of its properties.

00:17:38.940 --> 00:17:40.770
You may have set content on the layer.

00:17:40.860 --> 00:17:42.890
Well,
if we set needs display on the layer,

00:17:42.890 --> 00:17:46.120
your content will disappear and
we don't know how to replace it.

00:17:46.880 --> 00:17:49.120
Leo Parmigiano-Rocco We generally
try not to interfere with the

00:17:49.120 --> 00:17:51.280
properties of layers that you give us.

00:17:51.440 --> 00:17:54.060
But when we create the backing layer,
we assume what we can mark it

00:17:54.080 --> 00:17:56.960
as needing display and you want
us to draw view content into it.

00:17:56.960 --> 00:17:58.240
It's a view backing layer.

00:17:58.240 --> 00:17:59.960
So we'll do those kinds of things.

00:17:59.960 --> 00:18:02.040
Anytime the views geometry changes,
as I said,

00:18:02.040 --> 00:18:03.700
we push those changes to the layer.

00:18:03.700 --> 00:18:05.850
Leo Parmigiano-Rocco As I said,
the root layer of a

00:18:05.850 --> 00:18:07.960
standalone layer tree,
this happens to also.

00:18:07.960 --> 00:18:11.760
For backing layers again,
AppKit will destroy and

00:18:11.760 --> 00:18:16.490
recreate views backing layers
at will to manage resources.

00:18:16.500 --> 00:18:19.390
Leo Parmigiano-Rocco Remember,
every pixel that your view

00:18:19.390 --> 00:18:22.540
covers is a pixel in that views
backing layers backing store.

00:18:22.540 --> 00:18:24.690
So we're allocating
lots of graphic memory,

00:18:24.770 --> 00:18:27.710
lots of texture memory for
all these view backing layers.

00:18:27.710 --> 00:18:30.800
And if we figure out that, well,
your view is not visible anymore,

00:18:30.800 --> 00:18:33.020
it's been pulled out of
the window or something,

00:18:33.020 --> 00:18:35.760
we want to reclaim those
resources for the system to use.

00:18:35.820 --> 00:18:38.050
Leo Parmigiano-Rocco So this
kind of thing can happen.

00:18:38.050 --> 00:18:41.090
You can lose your backing layer when,
say, someone does set wants layer no on

00:18:41.130 --> 00:18:42.510
a view higher up in the hierarchy.

00:18:42.530 --> 00:18:46.060
Maybe you had an ancestor that had wants
layer set to yes and your whole subtree.

00:18:46.520 --> 00:18:47.310
was drawing layer back.

00:18:47.430 --> 00:18:51.240
Now that gets it to know and all
those descendants of that view

00:18:51.240 --> 00:18:52.300
cease to become layer backed.

00:18:52.410 --> 00:18:54.180
We'll pull the backing
layers off of them.

00:18:54.180 --> 00:18:57.440
This can also happen, as I said,
when you pull a view subtree,

00:18:57.440 --> 00:19:01.100
when you're pruning and grafting,
you pull a view subtree out of window

00:19:01.100 --> 00:19:05.340
by doing remove from superview,
backing layers can be torn down then too.

00:19:05.340 --> 00:19:09.360
And one common case where this
happens is if you have views in a tab

00:19:09.360 --> 00:19:13.830
view and there are subviews of the
tab view and they're layer backed.

00:19:13.910 --> 00:19:18.280
If the user switches tabs,
it just so happens that the mechanism

00:19:18.310 --> 00:19:22.210
that's used for doing the tab swapping
is to prune and graft those view

00:19:22.210 --> 00:19:24.500
subtrees into and out of the window.

00:19:24.500 --> 00:19:27.990
So when you user switches tabs, oh,
your backing layers might go away

00:19:28.350 --> 00:19:32.060
for some of your views that were in
the tab that they switched away from.

00:19:34.150 --> 00:19:36.420
Likewise,
if you added properties or sublayers

00:19:36.470 --> 00:19:39.990
to an AppKit-owned view backing layer,
these things can disappear

00:19:39.990 --> 00:19:42.750
unexpectedly because,
well, the backing layer goes away

00:19:42.820 --> 00:19:45.760
and there's nothing referencing
those sublayers anymore.

00:19:45.760 --> 00:19:49.640
So, therefore, you tend to need a way,
if you are going to be going in

00:19:49.640 --> 00:19:53.440
there and you can access a views
layer with the layer getter method,

00:19:53.550 --> 00:19:56.600
you can go in there and
tweak layer properties.

00:19:56.600 --> 00:19:59.860
If you're going to do that kind of thing,
you really need a way to react to

00:19:59.900 --> 00:20:03.490
your backing layer coming and going
if it's one that's managed by AppKit.

00:20:04.000 --> 00:20:05.320
So, how can you do this?

00:20:05.320 --> 00:20:07.580
One of the first things
that developers try is,

00:20:07.580 --> 00:20:10.430
you know, it makes sense,
override setWantsLayer because

00:20:10.520 --> 00:20:12.880
that's what switches this on and off,
right?

00:20:12.880 --> 00:20:15.240
Well, it turns out that this
doesn't work so well,

00:20:15.260 --> 00:20:18.940
and the reason for that is that while
setWantsLayer is recursive in its effect,

00:20:18.970 --> 00:20:22.400
when you do wantsLayer yes for a view,
it affects the whole subtree,

00:20:22.400 --> 00:20:26.000
setWantsLayer itself as a method
is not invoked recursively.

00:20:26.000 --> 00:20:27.980
So, if you're a descendant of a
view that became layer-backed,

00:20:27.980 --> 00:20:30.160
well, you're becoming layer-backed too,
but you're not going to get

00:20:30.160 --> 00:20:31.520
the setWantsLayer yes message.

00:20:31.610 --> 00:20:33.300
So, that doesn't work out so well.

00:20:34.710 --> 00:20:35.590
How about Set Layer?

00:20:35.590 --> 00:20:39.940
Well, it turns out this is an excellent
place to handle layers coming

00:20:39.940 --> 00:20:42.840
and going because this is,
in addition to being the public

00:20:42.840 --> 00:20:46.080
API that you use to provide a
standalone layer tree to AppKit,

00:20:46.080 --> 00:20:49.750
this is also the funnel point that
AppKit goes through when it associates

00:20:49.750 --> 00:20:53.280
a backing layer with a view and when
it pulls that backing layer off.

00:20:53.360 --> 00:20:55.860
So if you override Set Layer in
your custom view class,

00:20:55.960 --> 00:20:58.070
call up to Super Set Layer to
let it do its thing,

00:20:58.170 --> 00:21:01.350
and then you can look at the new
layer parameter that's coming in.

00:21:01.360 --> 00:21:04.070
And if it's non-nil, well,
then you're becoming layer-backed

00:21:04.070 --> 00:21:06.760
or maybe you're getting a different,
you should be prepared to

00:21:06.760 --> 00:21:09.490
have had a layer before,
but now you're getting a different type

00:21:09.490 --> 00:21:12.700
of backing layer because AppKit might
need to substitute a different time,

00:21:12.730 --> 00:21:14.230
a different kind of layer.

00:21:14.240 --> 00:21:16.520
There are different kinds of layers
for different kinds of rendering.

00:21:16.520 --> 00:21:19.570
Let's say your view decides it's
going to start rendering using OpenGL,

00:21:19.570 --> 00:21:21.360
it associates in this OpenGL context.

00:21:21.360 --> 00:21:23.340
We might in the future say, okay,
we're going to tear it down.

00:21:23.360 --> 00:21:25.310
We're going to tear down that CA layer
and give you a CA OpenGL layer.

00:21:25.320 --> 00:21:29.180
So you may get a layer where
you didn't have one before,

00:21:29.180 --> 00:21:31.930
you may get a different layer,
or you may get a parameter of nil,

00:21:31.930 --> 00:21:34.350
meaning that your view is
ceasing to be layer-backed and

00:21:34.350 --> 00:21:35.950
we're tearing the layer down.

00:21:35.960 --> 00:21:38.910
So overriding Set Layer,
this is an excellent place to respond

00:21:38.910 --> 00:21:42.300
to all of these things because whenever
a view acquires or loses a layer,

00:21:42.300 --> 00:21:44.120
the view gets a Set Layer message.

00:21:44.170 --> 00:21:46.630
It doesn't matter what
triggered the mode switch,

00:21:46.640 --> 00:21:50.350
so it's a great place to set up your
additional properties or sublayers.

00:21:50.360 --> 00:21:53.300
So the take-home point, override.

00:21:53.360 --> 00:21:56.580
set layer to do this kind of stuff.

00:21:57.200 --> 00:22:11.700
[Transcript missing]

00:22:12.060 --> 00:22:14.370
To understand why that is,
we'll need to look at the

00:22:14.400 --> 00:22:17.000
two basic kinds of text
anti-aliasing that Quartz supports.

00:22:17.000 --> 00:22:20.430
First, we have what I call whole-pixel
anti-aliasing that treats

00:22:20.460 --> 00:22:22.310
each pixel as a discrete unit.

00:22:22.320 --> 00:22:25.800
And then we have the more advanced
sort of sub-pixel anti-aliasing,

00:22:25.800 --> 00:22:29.520
also called LCD anti-aliasing,
because it relies on special properties

00:22:29.520 --> 00:22:31.240
of the LCD panels we all use now.

00:22:31.240 --> 00:22:33.660
This is also called font
smoothing in the API.

00:22:34.720 --> 00:22:37.440
So whole-pixel anti-aliasing, first,
how does that work?

00:22:37.440 --> 00:22:39.280
Well,
let's say you have a grid of pixels,

00:22:39.280 --> 00:22:41.230
you've cleared the
background color white,

00:22:41.230 --> 00:22:44.690
and you've got a glyph that you want
to rasterize into that grid of pixels.

00:22:44.700 --> 00:22:46.740
You want to draw a letter A in black.

00:22:46.820 --> 00:22:50.680
Well, with whole-pixel anti-aliasing,
again, we treat each pixel as a unit,

00:22:50.680 --> 00:22:54.120
and what the graphics system does is
it computes the partial coverage of

00:22:54.120 --> 00:22:56.160
the glyph on each of these squares.

00:22:56.160 --> 00:23:00.450
And if 70% of the square is covered
by a piece of that ideal vector glyph,

00:23:00.470 --> 00:23:04.960
then you'll get 70% of the foreground
color blended with 30%. And you

00:23:05.040 --> 00:23:08.850
end up with sort of a nicely,
mostly nicely smoothed glyph there that

00:23:09.010 --> 00:23:12.430
when you look at normal magnification,
it looks a lot smoother

00:23:12.430 --> 00:23:15.720
than the old jagged text we
used to get a long time ago.

00:23:15.720 --> 00:23:18.050
So that was an improvement on alias text.

00:23:18.060 --> 00:23:20.570
But then on OS X,
the graphics system added the

00:23:20.570 --> 00:23:23.000
concept of sub-pixel anti-alias text.

00:23:23.000 --> 00:23:25.660
And there,
let's say you have the same situation.

00:23:25.660 --> 00:23:28.850
You have a white background,
you have a black glyph that you're

00:23:28.950 --> 00:23:30.640
trying to rasterize on top of it.

00:23:30.640 --> 00:23:33.250
But in this case,
the graphics system knows that it

00:23:33.250 --> 00:23:37.450
can treat... Each pixel is actually
being composed of three discrete

00:23:37.450 --> 00:23:40.950
components that are adjacent to
each other and not overlapping.

00:23:41.010 --> 00:23:44.020
So in each pixel cell on an LCD display,
you have the red component

00:23:44.020 --> 00:23:46.540
occupies the left-hand third,
the green component is

00:23:46.660 --> 00:23:48.690
in the middle third,
and the blue component is

00:23:48.690 --> 00:23:50.200
in the right-hand third.

00:23:50.200 --> 00:23:53.310
And effectively, for anti-aliasing,
this triples our resolution.

00:23:53.320 --> 00:23:57.460
If we look at each of those components
as if it was almost a separate pixel,

00:23:57.460 --> 00:24:01.240
now we can anti-alias with
triple the horizontal resolution.

00:24:01.330 --> 00:24:04.480
And what this ends up looking like to
users is not quite the eyesore there.

00:24:04.480 --> 00:24:07.940
It's more of all the white pixels
sort of blend together to white

00:24:07.940 --> 00:24:10.020
where R equals G equals B equals one.

00:24:10.380 --> 00:24:14.600
That sort of blends out to white when
you're looking at normal magnification.

00:24:14.600 --> 00:24:17.650
And for the areas around the edges,
you end up getting these sort of color

00:24:17.650 --> 00:24:20.500
fringes that result from different
amounts of blending of the red,

00:24:20.500 --> 00:24:23.520
green and blue because we're
computing different coverage values.

00:24:23.660 --> 00:24:26.340
But when you zoom out,
if you go across the street

00:24:26.420 --> 00:24:28.740
and you look at this,
it looks like a nicely

00:24:28.800 --> 00:24:30.300
anti-aliased glyph.

00:24:30.800 --> 00:24:33.530
So that's all well and good,
but why is there a problem with

00:24:33.580 --> 00:24:35.570
doing this in Layer-Backed Mode?

00:24:35.580 --> 00:24:39.070
Well, the situation,
the problem there is the same thing

00:24:39.090 --> 00:24:41.250
that's the benefit for doing animations.

00:24:41.270 --> 00:24:43.950
In Layer-Backed Mode, again,
each view is drawn into its own separate

00:24:43.950 --> 00:24:47.040
layer rather than being commingled
with the drawing that other views have

00:24:47.040 --> 00:24:48.540
drawn into the Window Backing Store.

00:24:48.540 --> 00:24:51.820
And this is wonderful for animation,
but it turns out it doesn't work

00:24:51.820 --> 00:24:53.660
out so well for text anti-aliasing.

00:24:53.800 --> 00:24:58.050
And the reason for that is that
subpixel or LCD anti-aliasing relies

00:24:58.050 --> 00:25:02.300
on having an opaque background
to draw into at compositing time.

00:25:02.300 --> 00:25:06.300
And to reiterate that,
there really is no way,

00:25:06.300 --> 00:25:09.500
no good way that you can perform
high quality subpixel anti-aliasing

00:25:09.500 --> 00:25:13.170
without having an opaque background,
unless say we added two more alpha

00:25:13.170 --> 00:25:16.680
components and we'd have six samples
per pixel and a whole lot more graph,

00:25:16.810 --> 00:25:18.620
about 50% more graphics memory usage.

00:25:18.620 --> 00:25:21.060
So really you need an opaque background.

00:25:21.060 --> 00:25:22.560
You need to know your
background at draw time.

00:25:22.690 --> 00:25:25.140
Well, in Layer-Backed Mode, I mean,
we might have a text field

00:25:25.140 --> 00:25:28.460
that draws text into itself,
but it's not drawing the background.

00:25:28.460 --> 00:25:31.500
It's the window or some other view higher
up that's providing the background.

00:25:31.500 --> 00:25:34.490
And the background only gets in
there later when the layer tree

00:25:34.490 --> 00:25:38.060
is fully drawn and then finally
composited as the last step.

00:25:38.790 --> 00:25:40.750
So, like I said,
many kinds of views and controls do

00:25:40.750 --> 00:25:42.700
no background drawing of their own.

00:25:43.030 --> 00:25:44.820
Unfortunately,
making matters a little worse,

00:25:44.920 --> 00:25:48.890
LCD anti-aliasing or font smoothing
is switched on by default in

00:25:48.890 --> 00:25:51.400
the graphics context that you
get when you're asked to draw.

00:25:51.540 --> 00:25:55.410
So the graphics system will happily
do its best to try to do subpixel

00:25:55.500 --> 00:25:58.880
anti-aliasing into a transparent
background if that's what you have.

00:25:58.980 --> 00:26:02.480
And unfortunately, to some eyes,
those results can actually look

00:26:02.510 --> 00:26:06.280
worse than if you were just
attempting whole pixel anti-aliasing.

00:26:06.570 --> 00:26:07.790
So, okay, we get it.

00:26:07.860 --> 00:26:08.410
There's a problem.

00:26:08.420 --> 00:26:09.510
How do you solve this problem?

00:26:09.510 --> 00:26:11.110
Well, there are a couple of
different approaches.

00:26:11.110 --> 00:26:14.240
If it's acceptable to you to put
an opaque background in your view,

00:26:14.240 --> 00:26:16.080
that's the simplest way to do this.

00:26:16.080 --> 00:26:18.250
So you give the text a solid
background to draw into.

00:26:18.260 --> 00:26:20.720
If you have something
like an NSTextField,

00:26:20.720 --> 00:26:25.160
this is real easy because NSTextField
has a set background color property.

00:26:25.160 --> 00:26:27.920
So you can set the text field's
background color in code if you want.

00:26:28.050 --> 00:26:30.570
Be sure to also set the text
field to draw its background

00:26:30.570 --> 00:26:33.760
or it will just ignore that
background color that you just set.

00:26:33.910 --> 00:26:36.480
And you can also do this in Interface
Builder without writing anything.

00:26:36.500 --> 00:26:38.300
any code.

00:26:38.640 --> 00:26:41.910
For other types of controls
that show text but don't have an

00:26:42.000 --> 00:26:45.220
analogous background color property,
one thing you can do is

00:26:45.220 --> 00:26:47.960
subclass the control or view,
override Draw Rect,

00:26:47.960 --> 00:26:50.380
and provide your own background drawing.

00:26:50.400 --> 00:26:52.710
And that's as simple as at
the top of your Draw Rect,

00:26:52.760 --> 00:26:55.220
filling with some background
color that you want.

00:26:55.220 --> 00:26:56.640
It doesn't have to be
window background color.

00:26:56.640 --> 00:26:58.700
It's whatever you know you're
going to be compositing over later.

00:26:59.320 --> 00:27:00.660
Do an NS Rect fill.

00:27:00.660 --> 00:27:02.880
If you saw Ken's talk
earlier this morning,

00:27:02.880 --> 00:27:05.930
you might think I'm going to get
in a little bit of trouble here

00:27:06.010 --> 00:27:08.880
with him because I'm telling
you to use a Rect fill that uses

00:27:08.880 --> 00:27:11.710
basically a replace operation,
a copy operation.

00:27:11.720 --> 00:27:14.720
But that's okay here because the
layer owns its own backing store.

00:27:14.720 --> 00:27:17.020
We're really replacing
the pixels in the layer.

00:27:17.020 --> 00:27:20.120
We could do source over two because
it'll be cleared to transparent.

00:27:20.120 --> 00:27:21.040
It doesn't matter either way.

00:27:21.090 --> 00:27:24.550
But we're putting a solid opaque
fill in the backing store before

00:27:24.550 --> 00:27:27.440
we call up to Super Draw Rect,
and that way you will get

00:27:27.440 --> 00:27:29.070
subpixel anti-aliasing.

00:27:29.430 --> 00:27:31.780
Well, what if that's not an option?

00:27:31.780 --> 00:27:34.780
What if you're going to be moving
your view around over a complex

00:27:34.780 --> 00:27:38.230
background and you don't want it to be
carrying this big slug of color with

00:27:38.250 --> 00:27:40.260
it that makes everything look awful?

00:27:40.260 --> 00:27:46.910
The alternative then in those cases is to
fall back to whole pixel anti-aliasing.

00:27:46.930 --> 00:27:49.080
So what you can do is
turn off font smoothing,

00:27:49.080 --> 00:27:52.280
and this is a similar kind of thing where
you can subclass your viewer control,

00:27:52.280 --> 00:27:56.520
override Draw Rect,
and use the CG context set should smooth

00:27:56.580 --> 00:27:59.300
fonts call to message the CG context.

00:27:59.360 --> 00:28:01.320
So you can use the CG context
that you're drawing into,

00:28:01.320 --> 00:28:03.500
tell it,
I want to turn off font smoothing,

00:28:03.500 --> 00:28:04.740
and then call up to Super Draw Rect.

00:28:04.820 --> 00:28:07.920
And at least then you get better
looking whole pixel anti-aliasing.

00:28:07.920 --> 00:28:11.180
So unfortunately, this is other than the
slide we had before,

00:28:11.180 --> 00:28:15.300
this is a little difficult to illustrate
without being on a machine where you can

00:28:15.300 --> 00:28:17.740
actually look at this magnified in Pixie.

00:28:17.740 --> 00:28:20.300
But we're providing a subpixel
anti-aliasing example.

00:28:20.340 --> 00:28:24.710
It's a real simple app that allows you
to turn layer backing on and off for

00:28:24.780 --> 00:28:27.190
a set of checkboxes and text fields.

00:28:27.200 --> 00:28:29.300
And some of these checkboxes and text
fields are going to be in the layer.

00:28:29.320 --> 00:28:32.160
And some of these checkboxes and text
fields in the example implement some of

00:28:32.160 --> 00:28:33.550
the techniques that I just mentioned.

00:28:33.750 --> 00:28:35.500
So I encourage you to
take a look at this,

00:28:35.520 --> 00:28:38.230
look at the rendered results with
Pixie and compare between layer

00:28:38.230 --> 00:28:41.440
backed and non-layer backed mode to
understand how this all works and how

00:28:41.440 --> 00:28:43.610
you can make your text look better.

00:28:49.780 --> 00:28:54.280
So after that complex discussion,
let's have a real quick tip.

00:28:54.280 --> 00:28:56.370
One of the things people
often ask about is,

00:28:56.370 --> 00:28:58.210
how can I drive motion programmatically?

00:28:58.270 --> 00:29:01.210
Core animation gives you these
ways to express canned animations,

00:29:01.220 --> 00:29:05.260
these sort of pre-planned paths of
motion for different types of properties.

00:29:05.260 --> 00:29:08.480
But what if you're hooking things
up to a game physics engine

00:29:08.480 --> 00:29:09.800
and you're simulating gravity?

00:29:09.800 --> 00:29:12.940
Or you really don't know what the
position of an object is going

00:29:12.940 --> 00:29:16.460
to be until you calculate your
next simulation frame or whatever?

00:29:16.500 --> 00:29:18.190
Well, this is really easy to do.

00:29:18.200 --> 00:29:21.220
And it barely merits a slide,
but it's worth pointing out

00:29:21.220 --> 00:29:22.920
because people often ask about it.

00:29:22.930 --> 00:29:25.160
Because even when you're
not using animations,

00:29:25.160 --> 00:29:29.470
you can get a lot of benefit from being
layer-backed or from using layers.

00:29:29.550 --> 00:29:32.120
If you're using layer-backed views,
the answer is simply, well,

00:29:32.120 --> 00:29:34.480
set the view's frame origin,
frame rotation,

00:29:34.480 --> 00:29:35.720
other properties immediately.

00:29:35.720 --> 00:29:38.190
Don't go through the view's animator,
which is the usual means

00:29:38.190 --> 00:29:40.050
of initiating an animation,
but just set those

00:29:40.110 --> 00:29:41.130
properties immediately.

00:29:41.240 --> 00:29:45.270
If you're working with standalone layers,
that is, working with CA layers directly

00:29:45.320 --> 00:29:48.670
that you've created yourself,
the situation is sort of the reverse.

00:29:48.810 --> 00:29:51.620
Whereas for views,
the default is to not animate.

00:29:51.720 --> 00:29:54.840
With core animation,
you get implied animations by default.

00:29:54.880 --> 00:29:57.360
So you need to actually disable actions.

00:29:57.410 --> 00:30:02.720
This is the means of suppressing
implied animations in core animations.

00:30:02.790 --> 00:30:04.940
Disable actions in the
enclosing transaction,

00:30:04.940 --> 00:30:07.810
and then you make all the layer
property changes you want before

00:30:07.810 --> 00:30:09.370
you commit the transaction.

00:30:09.420 --> 00:30:12.050
In either of these cases,
even though you're not using

00:30:12.050 --> 00:30:15.780
the animation capabilities that
are built into core animation,

00:30:15.930 --> 00:30:18.100
you still get the benefit
of content caching.

00:30:18.100 --> 00:30:19.440
Your content is pre-rendered.

00:30:19.440 --> 00:30:20.500
It's not going to be redrawn.

00:30:20.500 --> 00:30:23.090
You're just moving stuff around,
so you still can get very smooth,

00:30:23.120 --> 00:30:23.840
fluid animations.

00:30:23.880 --> 00:30:26.340
So it's worth pointing out that
you still get some benefit even if

00:30:26.390 --> 00:30:29.280
you're not using the animations,
if you're just moving

00:30:29.410 --> 00:30:31.520
stuff around that's static.

00:30:31.910 --> 00:30:33.760
So what about performance tuning?

00:30:33.760 --> 00:30:38.050
What can you do to get the best
performance out of your Layer-Backed

00:30:38.050 --> 00:30:41.140
View portions of your user interfaces?

00:30:42.310 --> 00:30:45.880
One of the most important things to point
out is that it's important to minimize

00:30:45.880 --> 00:30:48.310
backing store use in layer-backed mode.

00:30:48.320 --> 00:30:51.640
And this is very different from
sort of the normal mode you're used

00:30:51.640 --> 00:30:54.640
to with views in a window where
only the window has a backing store.

00:30:54.640 --> 00:30:57.710
So you can have, say,
a text field that displays one word,

00:30:57.710 --> 00:30:59.500
but it's got a lot of slop in it.

00:30:59.500 --> 00:31:01.690
It's stretched across the
full width of the window,

00:31:01.720 --> 00:31:03.000
has more room than it needs.

00:31:03.090 --> 00:31:06.210
Well, the problem with that in
layer-backed mode is that that view

00:31:06.330 --> 00:31:07.980
is going to get a backing store.

00:31:07.980 --> 00:31:11.700
It's going to get a layer that is
sized exactly to the frame of the view.

00:31:12.200 --> 00:31:14.780
So you may have pixels that
aren't being used there,

00:31:14.780 --> 00:31:16.900
but that are nonetheless
allocated on the graphics card,

00:31:16.900 --> 00:31:18.120
and you're wasting resources there.

00:31:18.120 --> 00:31:21.110
So with layer-backed mode,
it's more important than it has been

00:31:21.110 --> 00:31:24.870
before to crop your content tightly,
make your views crop as small

00:31:24.870 --> 00:31:27.560
as you can around the actual
content that you need to draw.

00:31:27.560 --> 00:31:29.600
Try not to leave empty
space in the margins.

00:31:29.600 --> 00:31:33.160
Avoid unnecessary
redraw whenever you can.

00:31:33.160 --> 00:31:36.860
And ways to do this include, as I said,
avoiding resizing.

00:31:36.860 --> 00:31:39.660
Obviously, sometimes you need to
resize a view in your UI.

00:31:39.660 --> 00:31:42.800
But if you can avoid doing it where
you don't need to do it... that will

00:31:42.800 --> 00:31:45.420
make animations a whole lot smoother.

00:31:45.500 --> 00:31:48.500
If you're just moving stuff around,
that's really fast.

00:31:48.500 --> 00:31:51.730
But as I said, if you're resizing views,
including using animations,

00:31:51.730 --> 00:31:55.050
and they're layer-backed, well,
we have to assume that we need

00:31:55.050 --> 00:31:58.800
to potentially redraw the view
at each step along the animation.

00:31:58.800 --> 00:32:00.750
That's going to be done
on the main thread.

00:32:00.860 --> 00:32:03.580
It's going to occupy
view drawing machinery.

00:32:03.680 --> 00:32:05.990
So it's going to be a bit of
a heavier load on the system.

00:32:06.100 --> 00:32:07.850
So for now, try to avoid resizing.

00:32:08.000 --> 00:32:11.690
Try to isolate static parts
of your user interface.

00:32:11.750 --> 00:32:13.700
Things that don't need to be redrawn.

00:32:13.700 --> 00:32:14.680
Take the dynamic parts.

00:32:14.710 --> 00:32:16.400
I guess the flip side
of that would be to say,

00:32:16.400 --> 00:32:18.880
isolate the dynamic parts,
the parts that you're going to

00:32:18.880 --> 00:32:23.310
need to redraw in their own views,
so that you're just redrawing minimally.

00:32:23.500 --> 00:32:45.100
[Transcript missing]

00:32:45.910 --> 00:32:49.630
Another thing to do,
and this ties into a new feature

00:32:49.630 --> 00:32:53.120
that we've added on Snow Leopard
that's beginning in your seed,

00:32:53.120 --> 00:32:56.580
consider enabling your
views to draw concurrently.

00:32:56.600 --> 00:33:00.830
We've been looking at, of course,
what's been happening with CPUs lately,

00:33:00.920 --> 00:33:03.690
and we have machines with
up to eight cores now under

00:33:03.710 --> 00:33:05.420
our desks or on our desks.

00:33:05.420 --> 00:33:08.380
We want AppKit and the system as
a whole to be able to leverage

00:33:08.380 --> 00:33:12.010
concurrency more effectively and
the ability to use multiple cores.

00:33:12.130 --> 00:33:15.500
So it doesn't make a whole lot of sense
to force all of the view hierarchy to

00:33:15.500 --> 00:33:18.780
draw just on the main thread anymore
because there may be other cores

00:33:18.800 --> 00:33:20.910
that are idle and can help with that.

00:33:21.040 --> 00:33:25.080
So we have a new canDrawConcurrently
property that's been added on NSView.

00:33:25.080 --> 00:33:28.620
So you can flag individual views
as being able to draw concurrently,

00:33:28.620 --> 00:33:31.530
and this gives AppKit permission
to call your view back,

00:33:31.530 --> 00:33:34.380
to call its drawRect back
on a background thread.

00:33:34.380 --> 00:33:37.300
So you're saying, my view,
you can safely invoke my drawRect.

00:33:37.380 --> 00:33:41.260
There's a bunch of information about
this in the AppKit release notes.

00:33:41.400 --> 00:33:42.940
What you need to do,
what are the requirements?

00:33:42.940 --> 00:33:45.790
We've tried to make them as simple
as possible for your views to

00:33:45.820 --> 00:33:48.880
be able to be considered thread
safe for concurrent drawing.

00:33:48.880 --> 00:33:53.740
This is not leveraged yet in layer-backed
mode in the seed that you have,

00:33:53.770 --> 00:33:56.030
but it is very likely that
layer-backed mode will take

00:33:56.030 --> 00:33:57.540
advantage of this in the future.

00:33:57.540 --> 00:34:00.750
On the one hand, when you think about it,
it's less of an issue because

00:34:00.750 --> 00:34:03.310
you're ideally doing less
redraw in layer-backed mode,

00:34:03.360 --> 00:34:03.930
right?

00:34:03.960 --> 00:34:06.700
We're reusing existing content,
moving it around, recompositing.

00:34:06.700 --> 00:34:09.680
So there's less overall redraw to do,
so maybe less important

00:34:09.680 --> 00:34:11.020
to do it concurrently.

00:34:11.090 --> 00:34:13.950
But then on the other hand,
we're drawing views individually

00:34:13.950 --> 00:34:16.320
into their own backing layers,
so there's no longer

00:34:16.320 --> 00:34:17.460
this order dependency.

00:34:17.460 --> 00:34:23.360
The compositing happens as the last step,
so we can execute drawRects

00:34:23.360 --> 00:34:27.130
in any order we want to,
so we have a lot more flexibility in

00:34:27.130 --> 00:34:30.740
layer-backed mode in terms of how we
delegate things to different cores.

00:34:30.740 --> 00:34:32.690
So consider using canDraw concurrently.

00:34:33.060 --> 00:34:36.180
Typically, as the advice in the
AppKit release notes says,

00:34:36.180 --> 00:34:40.880
we expect you'll want to just select a
few views that you have that do extra.

00:34:40.880 --> 00:34:43.360
So we're going to use the
canDraw component to do that.

00:34:43.360 --> 00:34:44.670
And then we're going to use the canDraw
component to do the other expensive

00:34:44.670 --> 00:34:46.310
drawing that have complex drawing they
need to do and make those candidates.

00:34:47.500 --> 00:34:48.500
What about drawing?

00:34:48.500 --> 00:34:51.840
The rules for drawing are mostly
very similar in Layer-Backed Mode,

00:34:51.840 --> 00:34:53.640
but there are a few
nuances to be aware of.

00:34:53.740 --> 00:35:00.240
One is that the semantic difference
between sending set needs display to

00:35:00.820 --> 00:35:04.740
one particular view and sending set
needs display to some ancestor of

00:35:04.770 --> 00:35:07.780
the view or an overlapping sibling,
this didn't really matter

00:35:07.920 --> 00:35:09.520
before in Non-Layer-Backed Mode.

00:35:09.520 --> 00:35:12.550
If you mark a view as needing display,
in Non-Layer-Backed Mode, you know,

00:35:12.550 --> 00:35:15.600
effectively you're saying, well,
the part of the window that this view

00:35:15.600 --> 00:35:18.750
touches is going to have to be redrawn,
and the AppKit view system is going

00:35:18.750 --> 00:35:22.000
to redraw all the views that it has
to that touch that area of the window.

00:35:22.000 --> 00:35:25.350
Well, in Layer-Backed Mode, again,
each view is drawing into its own layer,

00:35:25.350 --> 00:35:28.000
so we're only going to redraw the
backing layer or the portion of

00:35:28.000 --> 00:35:31.020
the backing layer for the view
that you marked as needing display.

00:35:31.020 --> 00:35:35.590
So be very specific about which views
you want redisplayed and which portions

00:35:35.590 --> 00:35:37.820
of those views need to be redrawn.

00:35:37.820 --> 00:35:39.500
Use set needs display
and rect when you can.

00:35:39.520 --> 00:35:42.150
It's always a help.

00:35:42.780 --> 00:35:46.700
Pixel alignment works a little bit
differently in Layer-Backed Mode.

00:35:46.740 --> 00:35:49.400
In Layer-Backed Mode,
layer content is drawn, buffered,

00:35:49.400 --> 00:35:52.960
axis aligned in the view's
own local coordinate system.

00:35:52.960 --> 00:35:56.200
And this is important really for
when you have views that are rotated.

00:35:56.200 --> 00:35:59.660
If you use the frame rotation or the
frame center rotation property on views,

00:35:59.660 --> 00:36:01.900
you've got a view that's
rotated in a window.

00:36:01.900 --> 00:36:04.100
Well,
normally with non-Layer-Backed Mode,

00:36:04.100 --> 00:36:06.690
you'd end up, if you drew a horizontal
line in your view,

00:36:06.800 --> 00:36:09.530
that would end up rasterized
sort of stair-step diagonally

00:36:09.530 --> 00:36:11.210
in the window backing store.

00:36:11.460 --> 00:36:13.800
Well, when you're drawing to a layer,
you're axis aligned as far

00:36:13.800 --> 00:36:16.010
as you're concerned when
you're doing your own drawing.

00:36:16.030 --> 00:36:18.360
And then that drawing is
rotated subsequently and

00:36:18.360 --> 00:36:21.750
composited in like an image by
Core Animation's compositing system.

00:36:21.760 --> 00:36:24.880
So, axis, so, sorry,
pixel alignment rules are a

00:36:24.880 --> 00:36:26.800
little bit different there.

00:36:26.800 --> 00:36:29.440
We provided some new pixel
alignment helper API.

00:36:29.460 --> 00:36:32.040
These aren't specifically
for pixel alignment,

00:36:32.100 --> 00:36:35.380
but they get you to where you
need to be to do pixel alignment.

00:36:35.380 --> 00:36:36.930
These were added in Leopard.

00:36:36.940 --> 00:36:39.580
We have convert rect to base,
convert point to base,

00:36:39.580 --> 00:36:40.220
convert size to base.

00:36:40.220 --> 00:36:44.190
And what they do, and then there are the
corresponding from methods,

00:36:44.190 --> 00:36:47.040
convert rect from base,
convert point from base,

00:36:47.290 --> 00:36:48.720
convert size from base.

00:36:48.900 --> 00:36:52.420
And base space is basically defined
as a space that is reasonable for you

00:36:52.430 --> 00:36:54.720
to do pixel alignment calculations in.

00:36:54.720 --> 00:36:58.580
In other words, if you round to integral
values in that space,

00:36:58.580 --> 00:37:00.880
you will get pixel aligned drawing.

00:37:00.880 --> 00:37:04.520
So, for Layer-Backed Mode, well,
base space is the layer's

00:37:04.520 --> 00:37:07.250
own backing store space,
the actual pixels in

00:37:07.250 --> 00:37:08.980
the layer backing store.

00:37:08.980 --> 00:37:11.030
For non-Layer-Backed Mode,
it's going to be the

00:37:11.030 --> 00:37:12.440
window's backing store space.

00:37:12.550 --> 00:37:16.300
And the nice thing about these convert
to and from base methods that are on

00:37:16.300 --> 00:37:19.130
NSView is that they do the right thing,
whether or not you're

00:37:19.130 --> 00:37:21.450
in Layer-Backed Mode,
and you don't need to worry about that.

00:37:21.500 --> 00:37:23.700
So, I encourage you to use those.

00:37:23.780 --> 00:37:25.090
Okay.

00:37:26.090 --> 00:37:26.760
What about debugging?

00:37:26.760 --> 00:37:30.780
What do you do when things aren't
quite going the way you expected,

00:37:30.780 --> 00:37:35.930
the animations that you set up and were
all ready to see didn't quite show up?

00:37:36.060 --> 00:37:39.640
Well, we have some tips to help you
debug those kinds of situations.

00:37:39.640 --> 00:37:42.930
I'll be talking about some
private elements that are not

00:37:42.930 --> 00:37:46.280
part of AppKit's public API,
but that are things that are

00:37:46.280 --> 00:37:48.440
nonetheless useful for debugging.

00:37:49.440 --> 00:37:51.650
So, don't depend on these in your code.

00:37:51.700 --> 00:37:55.200
Absolutely don't try to parse their
output because the output could go away

00:37:55.260 --> 00:37:57.220
or it could change at any point in time.

00:37:57.220 --> 00:38:00.420
But this stuff has been
there since at least Leopard,

00:38:00.420 --> 00:38:01.770
so it may be useful.

00:38:01.780 --> 00:38:04.060
One that's useful with
Layer-Backed Views,

00:38:04.060 --> 00:38:06.550
potentially, is NSDebugLayerAnimations.

00:38:06.560 --> 00:38:07.610
This is a user default.

00:38:07.610 --> 00:38:08.380
It's a Boolean.

00:38:08.380 --> 00:38:11.180
You set it to yes,
and what it does is it will have

00:38:11.180 --> 00:38:14.740
AppKit automatically log out
indications of animation for key

00:38:14.740 --> 00:38:16.540
and default animation for key.

00:38:16.540 --> 00:38:20.190
So, these happen when AppKit or
CoreAnimation is searching for an

00:38:20.190 --> 00:38:22.600
animation to use for a property change.

00:38:22.600 --> 00:38:24.710
That's sort of how the model
works for implied animations.

00:38:24.720 --> 00:38:26.990
You change the property and
then AppKit or CoreAnimation

00:38:26.990 --> 00:38:28.700
calls you back and says,
well, okay,

00:38:28.750 --> 00:38:30.280
you want to change this property.

00:38:30.280 --> 00:38:32.450
Which animation should I use
or should I use an animation

00:38:32.450 --> 00:38:33.830
at all to change this property?

00:38:33.840 --> 00:38:37.700
So, NSDebugLayerAnimations, yes,
is useful for that, potentially.

00:38:37.700 --> 00:38:40.140
Alternatively,
that can create a lot of spew because

00:38:40.340 --> 00:38:43.360
it'll give you output for all of
the views that are being asked for

00:38:43.360 --> 00:38:45.260
animations in your application.

00:38:45.260 --> 00:38:46.460
So, you might just override.

00:38:46.540 --> 00:38:49.000
You could override animation for key,
which is the funnel point

00:38:49.120 --> 00:38:51.500
that AppKit uses for searching
for a view's animation.

00:38:51.500 --> 00:38:52.700
That's a method on NSView.

00:38:52.700 --> 00:38:55.090
You could override that and,
for your specific view class,

00:38:55.130 --> 00:38:56.620
provide some logging in there.

00:38:56.620 --> 00:39:00.170
NSDebugLayerActivity logs out
information about the pushes that

00:39:00.170 --> 00:39:04.300
I talked about when a view property
changes and AppKit figures out,

00:39:04.300 --> 00:39:07.230
okay, we need to update the corresponding
layer property or when we need

00:39:07.430 --> 00:39:11.550
to redraw a view content to the
layer every time that happens.

00:39:11.580 --> 00:39:14.340
So, like all other user defaults,
you can use these on the command line

00:39:14.340 --> 00:39:16.170
when you're launching your application.

00:39:16.540 --> 00:39:17.840
So, you can use this in the command line,
you can use this in the command line

00:39:17.840 --> 00:39:18.740
when you're launching your application.

00:39:18.740 --> 00:39:20.120
You can use this in the command line
when you're launching your application.

00:39:20.120 --> 00:39:23.010
You can use this in GDB using
setargs and the same sort of dash

00:39:23.400 --> 00:39:25.000
syntax with the value afterward.

00:39:25.000 --> 00:39:28.670
And if you're using Xcode,
you can open up the inspector for your

00:39:28.800 --> 00:39:32.840
executable and there's a nice little
list that you can specify a bunch

00:39:32.930 --> 00:39:37.040
of different arguments you want and
check them on and off as you're doing

00:39:37.040 --> 00:39:39.460
debugging or not wanting debugging.

00:39:41.270 --> 00:39:43.890
What about when you want to take
a look at what the geometry of

00:39:43.910 --> 00:39:46.930
your view tree looks like in the
corresponding backing layer tree?

00:39:46.940 --> 00:39:49.770
Well, there's a subtree description
method that's been in

00:39:49.770 --> 00:39:51.260
there actually since Tiger.

00:39:51.260 --> 00:39:53.800
And again, this is something not
to rely on in your code.

00:39:53.800 --> 00:39:54.620
This could go away.

00:39:54.620 --> 00:39:55.730
Its output could change.

00:39:55.740 --> 00:39:58.890
Please don't parse the output or rely
on it because your code will break.

00:39:59.090 --> 00:40:01.260
But when you're in there in GDB,
it can be very useful.

00:40:01.260 --> 00:40:05.500
And this works for non-layer-backed
views as well as layer-backed views.

00:40:05.500 --> 00:40:08.000
So let's say you have
a pointer to some view.

00:40:08.000 --> 00:40:11.200
A subtree description is analogous
to the public description method.

00:40:11.280 --> 00:40:12.070
It's a debugging method.

00:40:12.160 --> 00:40:13.420
It returns you an NSString.

00:40:13.420 --> 00:40:16.850
So if you print out the value
of the subtree description,

00:40:16.870 --> 00:40:19.500
you get sort of a one line per view.

00:40:19.500 --> 00:40:22.940
If you're not on a wrap display,
you get a one line per view sort

00:40:22.940 --> 00:40:27.690
of summary of the view hierarchy
with indenting indicating nesting.

00:40:28.070 --> 00:40:31.580
The following slides are a little bit
of a cheat sheet at the bottom that

00:40:31.580 --> 00:40:33.610
helps you interpret some of the flags.

00:40:33.610 --> 00:40:35.560
Look at what all of this consists of.

00:40:35.560 --> 00:40:37.200
How do you interpret this stuff?

00:40:37.610 --> 00:40:39.510
First, there's a set of square brackets.

00:40:39.590 --> 00:40:41.990
Each view corresponds to
one line in the output,

00:40:42.070 --> 00:40:44.200
so we're looking at
the line for one view.

00:40:44.200 --> 00:40:45.840
There are various Boolean flags.

00:40:46.250 --> 00:40:48.780
Here we have a view that has
a capital W that tells us that

00:40:48.780 --> 00:40:51.500
it's set as wanting a layer,
and it also has a hardware

00:40:51.500 --> 00:40:54.590
surface that it's rendering into,
which is consistent with

00:40:54.590 --> 00:40:56.660
layer-backed rendering.

00:40:58.000 --> 00:41:02.940
If the view auto-resized its subviews,
its auto-resizing mask is indicated next.

00:41:02.940 --> 00:41:05.880
The horizontal and vertical components,
where a dash indicates a rigid

00:41:05.920 --> 00:41:08.880
component and an ampersand,
think of it like a spring in

00:41:08.880 --> 00:41:10.980
the old interface builder UI.

00:41:10.980 --> 00:41:13.780
It indicates a flexible space.

00:41:13.780 --> 00:41:17.350
You'll see the name of the class
and an instance pointer to the view,

00:41:17.350 --> 00:41:20.590
so if you want to inspect it further,
you can use that pointer,

00:41:20.640 --> 00:41:23.170
copy and paste it into
GDB's command line.

00:41:23.180 --> 00:41:27.150
You'll see the frame for the view,
origin, width, and height.

00:41:28.000 --> 00:41:31.510
The bounds for the view oftentimes
will just be indicated as a dash,

00:41:31.510 --> 00:41:34.560
because the case for most
views is that a view's bounds,

00:41:34.560 --> 00:41:37.010
unless you explicitly
set a bounds for a view,

00:41:37.010 --> 00:41:40.820
the view's bounds track the view's frame,
where the bounds is implicitly

00:41:40.930 --> 00:41:43.780
has an origin of 00,
a width equal to the frame width,

00:41:43.860 --> 00:41:45.950
and a height equal to the frame height.

00:41:45.960 --> 00:41:49.020
So you'll see that oftentimes,
but if the view has an explicit bounds,

00:41:49.040 --> 00:41:50.600
you'll see it displayed there.

00:41:50.600 --> 00:41:54.240
If the view has a backing layer,
if the view is in layer-backed

00:41:54.240 --> 00:41:57.880
mode or has an associated layer,
you'll see an arrow next.

00:41:58.000 --> 00:42:00.580
And then the class name and
pointer of the view backing layer.

00:42:00.580 --> 00:42:03.540
You'll see the position of
the layer and its bounds,

00:42:03.540 --> 00:42:05.790
and it's linked to its super layer.

00:42:05.800 --> 00:42:09.060
In this case, it's the top level,
so it has no super layer.

00:42:09.060 --> 00:42:11.580
So subtree description,
underbar subtree description,

00:42:11.630 --> 00:42:14.060
remember this,
it can be very useful for debugging both

00:42:14.060 --> 00:42:16.220
non-layer-backed and layer-backed cases.

00:42:16.220 --> 00:42:18.020
And of course,
remember that it's private.

00:42:18.020 --> 00:42:21.850
For when you're working with
either view backing layers or just

00:42:21.960 --> 00:42:25.720
a raw core animation layer tree,
a standalone layer tree,

00:42:25.720 --> 00:42:27.580
there's also a debugging facility.

00:42:27.590 --> 00:42:27.740
And if you're working with a
raw core animation layer tree,

00:42:27.740 --> 00:42:27.900
there's also a debugging facility.

00:42:28.080 --> 00:42:29.580
Core animation is particularly useful.

00:42:29.580 --> 00:42:32.290
This is an environment variable,
not a user default.

00:42:32.300 --> 00:42:35.020
If you set ca print tree,
that's ca underscore

00:42:35.030 --> 00:42:37.480
print underscore tree,
all uppercase,

00:42:37.480 --> 00:42:40.910
set that to one in your environment
before you run your app,

00:42:41.000 --> 00:42:46.340
core animations render thread
will dump a description.

00:42:46.340 --> 00:42:49.700
Each time it renders a frame,
it's going to tell you the time it's

00:42:49.700 --> 00:42:53.680
rendering at and the bounds of the root,
and then it'll give you a similar

00:42:53.790 --> 00:42:57.370
sort of subtree description of
what does the layer tree look like.

00:42:57.440 --> 00:42:57.900
So you'll see.

00:42:58.010 --> 00:43:00.670
Things like I won't go over all of this,
but you'll see the position of the layer.

00:43:00.680 --> 00:43:03.010
And remember, it has X, Y,
and an optional Z position

00:43:03.100 --> 00:43:04.120
that's usually zero.

00:43:04.120 --> 00:43:05.670
It's always zero for view backing layers.

00:43:05.680 --> 00:43:09.240
Layers bounds, the layers anchor point.

00:43:09.240 --> 00:43:10.300
We'll talk about that in a bit.

00:43:10.460 --> 00:43:13.900
So those are all useful,
hopefully useful to you techniques

00:43:14.020 --> 00:43:17.310
that you can use for debugging stuff
and seeing what's going on there

00:43:17.310 --> 00:43:19.110
when what you expect isn't happening.

00:43:23.520 --> 00:43:28.120
Sequencing Animations:
How can I put multiple

00:43:28.120 --> 00:43:30.610
animations together?

00:43:30.610 --> 00:43:35.470
How can I know when an
animation has completed?

00:43:35.470 --> 00:43:41.880
Core Animation provides two
powerful CA Animation subclasses:

00:43:41.880 --> 00:43:46.960
CA Keyframe Animation and
CA Animation Group.

00:43:47.070 --> 00:43:50.470
CA Keyframe Animation is a group of
animations that work together to create

00:43:50.560 --> 00:43:52.340
complex and intricate animations.

00:43:52.340 --> 00:43:55.000
We'll look at CA Keyframe
Animation first briefly.

00:43:55.000 --> 00:43:59.410
A keyframe animation animates a
single property through a sequence

00:43:59.410 --> 00:44:01.950
of waypoint values that you define.

00:44:02.050 --> 00:44:04.060
I want it to go from here
to here to here to here.

00:44:04.060 --> 00:44:06.580
When we hear keyframe,
we think of frames and positions,

00:44:06.580 --> 00:44:08.330
and it does apply to that kind of thing.

00:44:08.330 --> 00:44:11.010
If you have a view or a layer and
you have a sequence of positions

00:44:11.070 --> 00:44:13.830
that you want it to go through,
you can use a keyframe animation to

00:44:13.830 --> 00:44:15.670
have it go from 0 to 1 to 2 to 3.

00:44:16.000 --> 00:44:18.490
It also applies to other
types of properties as well.

00:44:18.500 --> 00:44:21.930
Maybe you want to animate the view
through a series of angle positions,

00:44:22.060 --> 00:44:24.450
or maybe you want to change its
color through a series of colors and

00:44:24.450 --> 00:44:25.860
have it interpolate through those.

00:44:26.240 --> 00:44:28.000
These are all the kinds
of things that you can do,

00:44:28.060 --> 00:44:30.000
for example, with keyframe animations.

00:44:30.000 --> 00:44:33.800
For a keyframe animation,
the key path names the property

00:44:33.800 --> 00:44:35.690
that you want to animate.

00:44:35.860 --> 00:44:37.800
So if you're working
with layers directly,

00:44:37.800 --> 00:44:39.190
you'll be naming a layer property here.

00:44:39.200 --> 00:44:40.560
But when you're working
with Layer-Backed Views,

00:44:40.560 --> 00:44:42.440
remember it's a view property
that you're animating,

00:44:42.440 --> 00:44:43.240
that you're specifying.

00:44:43.240 --> 00:44:47.320
AppKit will automatically try to
translate that key to a corresponding

00:44:47.320 --> 00:44:49.360
layer property to be animated.

00:44:50.290 --> 00:44:55.640
The values array on CA Keyframe
Animation specifies the

00:44:55.640 --> 00:44:56.600
waypoints that I described.

00:44:56.600 --> 00:45:00.360
These are the points that you want to
hit along the way as you're animating.

00:45:00.360 --> 00:45:04.220
You can optionally specify an
array of corresponding key times,

00:45:04.220 --> 00:45:07.580
of the same number of key
times as you specified values,

00:45:07.610 --> 00:45:10.020
and that'll say, well,
here's where in time I want you

00:45:10.020 --> 00:45:11.560
to hit each of those values.

00:45:12.000 --> 00:45:14.350
You can also specify timing functions.

00:45:14.350 --> 00:45:18.280
If you have n values and key times,
you can have n-1 timing functions

00:45:18.280 --> 00:45:22.160
that specify what sort of acceleration
curve should be used in moving

00:45:22.170 --> 00:45:24.760
between any particular pair of points.

00:45:24.760 --> 00:45:28.590
So you can specify an ease-in,
ease-out curve is a popular one,

00:45:28.590 --> 00:45:29.980
that kind of thing.

00:45:29.980 --> 00:45:33.480
And there are some other optional
properties that you can use as

00:45:33.480 --> 00:45:37.210
alternative ways to specify how
the value will change over time.

00:45:37.240 --> 00:45:40.120
But those first ones are
the main interesting ones.

00:45:40.120 --> 00:45:43.720
But again, with CA Keyframe Animation,
we're talking about animating a single

00:45:43.720 --> 00:45:45.610
property through a sequence of values.

00:45:45.650 --> 00:45:49.120
So what if you have something
more complex you want to do?

00:45:49.120 --> 00:45:51.280
You want to animate multiple
properties of an object,

00:45:51.720 --> 00:45:53.980
maybe color, position, orientation.

00:45:53.980 --> 00:45:55.740
You want to animate
multiple objects at once.

00:45:55.880 --> 00:45:57.130
How do you handle that kind of thing?

00:45:57.140 --> 00:45:59.890
Well,
that's where CA Animation Group comes in.

00:45:59.900 --> 00:46:03.630
And it's a very simple yet powerful
construct that allows you to arbitrarily

00:46:03.730 --> 00:46:06.480
aggregate animations together.

00:46:06.790 --> 00:46:09.840
You can have animations of various types,
including other animation groups.

00:46:09.900 --> 00:46:12.900
So these can be nested in
a hierarchy themselves.

00:46:12.900 --> 00:46:16.410
You can animate various properties
of all kinds of different types,

00:46:16.410 --> 00:46:18.560
colors, geometry, that sort of thing.

00:46:18.710 --> 00:46:21.490
And you can animate multiple target
objects at once with an animation group,

00:46:21.490 --> 00:46:22.960
because again,
you're just gathering up a bunch

00:46:22.960 --> 00:46:26.360
of other kinds of animations
and executing them together.

00:46:26.360 --> 00:46:28.640
CA Animation Group,
like Keyframe Animation,

00:46:28.710 --> 00:46:30.300
is a subclass of CA Animation.

00:46:30.410 --> 00:46:34.920
So it can be used anywhere in the
API that a CA Animation is called for.

00:46:35.280 --> 00:46:37.560
There's one important property
for CA Animation Group.

00:46:37.580 --> 00:46:38.150
Well, maybe two.

00:46:38.200 --> 00:46:41.340
The main one is the Animations property,
which provides the animations

00:46:41.410 --> 00:46:42.200
that you're giving it.

00:46:42.200 --> 00:46:46.200
Okay, I'm gathering these up,
make these into a group.

00:46:46.500 --> 00:46:49.520
Animations is typed as an NSArray,
but really it almost might

00:46:49.530 --> 00:46:51.940
as well be an NS set because
the order of the constituent

00:46:51.940 --> 00:46:53.580
components is not significant.

00:46:53.650 --> 00:46:56.400
What is significant is the
timing properties that are

00:46:56.400 --> 00:46:58.400
set on those sub-animations.

00:46:58.400 --> 00:47:02.780
It's the timing properties that specify
where each sub-animation gets executed,

00:47:02.800 --> 00:47:06.040
when it starts, what speed it goes at,
what duration it runs for.

00:47:06.040 --> 00:47:09.670
And these are the eight timing
properties that are defined by

00:47:09.670 --> 00:47:13.720
the CA Media Timing Protocol that
all CA animations conform to.

00:47:14.210 --> 00:47:18.100
The other interesting property to note is
the group's duration is important in that

00:47:18.100 --> 00:47:21.890
whatever sub-animations you put in there,
it doesn't matter what their

00:47:21.940 --> 00:47:23.930
begin times and durations are,
they will be clipped to

00:47:24.010 --> 00:47:25.220
the duration of the parent.

00:47:25.220 --> 00:47:29.260
So when the group duration has expired,
none of its constituent animations

00:47:29.260 --> 00:47:30.790
will continue to execute.

00:47:30.790 --> 00:47:32.690
They're all done at that point.

00:47:34.580 --> 00:47:36.710
Timing Model:
These are the eight basic and

00:47:36.830 --> 00:47:40.460
not-so-basic timing properties
that you can use to have animations

00:47:40.460 --> 00:47:42.440
be driven in various kinds of ways.

00:47:42.530 --> 00:47:45.960
There are four in particular
that are interesting to focus on.

00:47:45.960 --> 00:47:49.110
Duration and begin time are
probably the two most basic.

00:47:49.110 --> 00:47:51.860
When the animation starts,
how long it runs for.

00:47:51.960 --> 00:47:53.440
These are both in seconds.

00:47:53.740 --> 00:47:56.030
Optionally,
you can also specify a time offset

00:47:56.030 --> 00:47:59.450
and a speed that work in this sort
of linear equation to map local

00:47:59.450 --> 00:48:01.200
layer time to animation time.

00:48:01.200 --> 00:48:04.480
But most of the time,
your time offset is zero.

00:48:04.500 --> 00:48:07.760
Your speed is 1.0,
so this collapses to basically you're

00:48:07.760 --> 00:48:11.820
figuring out how far along you are in
the animation linearly with no scaling.

00:48:11.830 --> 00:48:14.450
So duration and begin time,
those are the real important

00:48:14.450 --> 00:48:17.280
ones to pay attention to as
we're looking at some examples.

00:48:17.300 --> 00:48:20.830
Okay, so concretely,
let's say we have an animation group.

00:48:20.830 --> 00:48:23.660
We want to execute an
animation for one second.

00:48:23.660 --> 00:48:27.490
And simplest case, we have, let's say,
two constituent animations that

00:48:27.490 --> 00:48:29.210
we want to put in those groups.

00:48:29.280 --> 00:48:32.140
And we want those all to start
together and execute for the

00:48:32.140 --> 00:48:33.620
same one second duration.

00:48:33.620 --> 00:48:34.920
How do we set this up in code?

00:48:34.960 --> 00:48:37.970
Well, let's say we've allocated a
CA animation group called group.

00:48:38.150 --> 00:48:42.060
We set its animations property to
an array of consisting of anim two.

00:48:42.060 --> 00:48:43.920
Specify a duration for the group.

00:48:43.920 --> 00:48:45.090
Remember to do that.

00:48:45.090 --> 00:48:47.820
That defines the duration
it's going to run for.

00:48:47.820 --> 00:48:50.440
And then let's say anim one,
we want it to begin at time zero,

00:48:50.530 --> 00:48:51.920
the beginning of the group.

00:48:51.920 --> 00:48:53.290
The group has its own local time.

00:48:53.290 --> 00:48:55.200
So time zero is the
beginning of that group.

00:48:55.300 --> 00:48:57.180
We want it to execute for one second.

00:48:57.190 --> 00:48:58.610
Same thing with anim two.

00:48:58.610 --> 00:49:01.130
Begin at time zero,
execute for one second.

00:49:01.130 --> 00:49:02.860
And that's how you would set
up simultaneous animations.

00:49:02.860 --> 00:49:03.060
Okay.

00:49:03.060 --> 00:49:03.060
So let's say we have an animation group.

00:49:03.060 --> 00:49:03.060
We want it to begin at time zero,
execute for one second.

00:49:03.060 --> 00:49:03.060
And that's how you would set
up simultaneous animations.

00:49:03.060 --> 00:49:03.060
And that's how you would set
up simultaneous animations.

00:49:03.060 --> 00:49:03.310
Okay.

00:49:03.320 --> 00:49:03.530
Okay.

00:49:03.590 --> 00:49:03.600
Okay.

00:49:03.620 --> 00:49:05.500
using groups.

00:49:05.730 --> 00:49:09.920
So this is very powerful in that groups
aren't just sequences of animations,

00:49:09.920 --> 00:49:11.360
you can do all kinds of things with them.

00:49:11.360 --> 00:49:14.910
You can have an animation
proceed after another animation.

00:49:14.920 --> 00:49:17.530
Let's say we want Anim1 to run
for three quarters of a second,

00:49:17.600 --> 00:49:19.240
we set its duration to 0.75.

00:49:19.390 --> 00:49:22.560
Anim2 should start at the end of that,
so we set its begin time to

00:49:22.710 --> 00:49:26.480
0.75 and its duration to 0.25,
so it runs for the remaining

00:49:26.630 --> 00:49:28.200
quarter second of the group.

00:49:28.640 --> 00:49:32.620
You can do all kinds of other
things like overlapping animations,

00:49:32.620 --> 00:49:35.480
so having them execute
partially together.

00:49:35.480 --> 00:49:39.540
You can have gaps in between animations
where for a quarter of a second here

00:49:39.640 --> 00:49:44.270
we have nothing happening after Anim1
completes and before Anim2 starts.

00:49:44.320 --> 00:49:47.260
And again, the scales to arbitrary
numbers of animations you

00:49:47.260 --> 00:49:48.650
want to put into the group.

00:49:48.730 --> 00:49:50.890
So animation groups,
very powerful constructs,

00:49:50.890 --> 00:49:53.610
and also keyframe animations,
very powerful constructs.

00:49:53.650 --> 00:49:54.840
So what's the crucial last step?

00:49:55.010 --> 00:49:57.410
Once you've built your animation
group or keyframe animation,

00:49:57.450 --> 00:49:58.330
how do you use this?

00:49:58.800 --> 00:50:01.600
There are a couple of different
approaches you can use in the AppKit API.

00:50:01.600 --> 00:50:05.160
There's the per instance approach
and the per class approach.

00:50:05.240 --> 00:50:07.820
If you have a particular view
instance and you just want that

00:50:07.820 --> 00:50:10.700
particular instance to fire off
the animation you've constructed

00:50:10.730 --> 00:50:13.590
when one of its properties changes,
let's say here we have the

00:50:13.840 --> 00:50:15.160
frame origin property of view.

00:50:15.160 --> 00:50:16.670
When that changes,
we want to fire off this

00:50:17.010 --> 00:50:18.350
animation group we've constructed.

00:50:18.440 --> 00:50:20.800
You use the set animations method.

00:50:20.800 --> 00:50:23.120
Each view has an animations dictionary.

00:50:23.120 --> 00:50:26.660
Each view instance has its own
dictionary of animations that

00:50:26.850 --> 00:50:28.560
maps property key names to.

00:50:28.640 --> 00:50:35.460
So if you have a custom view class and
you want all the instances of your custom

00:50:35.460 --> 00:50:41.420
view class to do the same thing when,
say, frame origin changes,

00:50:41.420 --> 00:50:45.180
you can use the set animations method.

00:50:45.250 --> 00:50:48.560
A better thing to do is to override
the class method default animation

00:50:48.560 --> 00:50:50.360
for key on your view class.

00:50:50.360 --> 00:50:52.400
And you'll look at the
incoming key and say,

00:50:52.400 --> 00:50:53.640
hey, is that the key I'm interested in?

00:50:53.640 --> 00:50:54.380
Is it frame origin?

00:50:54.440 --> 00:50:57.010
Okay, well, if so,
I've got this complex animation.

00:50:57.030 --> 00:50:59.470
Maybe it's keyframe animation,
group animation,

00:50:59.580 --> 00:51:02.350
whatever that I want to be applied
to change the frame origin or

00:51:02.350 --> 00:51:04.150
when the frame origin is changed.

00:51:04.150 --> 00:51:06.720
Always call up to super if
you don't recognize the key.

00:51:06.720 --> 00:51:09.520
This is the chaining mechanism
for default animation for key

00:51:09.520 --> 00:51:12.690
so you can inherit default
animations from your super classes.

00:51:15.180 --> 00:51:18.100
So lastly,
how do we know when animation's complete?

00:51:18.100 --> 00:51:20.600
Simple question with a
surprisingly simple answer,

00:51:20.600 --> 00:51:22.100
or actually a set of different answers.

00:51:22.100 --> 00:51:24.700
If you really want to get a callback
when your animation completes,

00:51:24.750 --> 00:51:28.210
and you happen to be providing your
own CA animation instance already,

00:51:28.210 --> 00:51:30.710
like when we created our own
group or keyframe animation,

00:51:30.710 --> 00:51:34.060
well then, you can just easily set the
delegate of that animation.

00:51:34.060 --> 00:51:35.430
Each animation can have a delegate.

00:51:35.610 --> 00:51:37.560
And the delegate,
if it implements these methods,

00:51:37.560 --> 00:51:40.660
will get animationDidStart
and animationDidStopFinished.

00:51:40.660 --> 00:51:43.770
It begins executing
and when it terminates.

00:51:44.300 --> 00:51:46.830
But alternatively,
if that's not convenient,

00:51:46.830 --> 00:51:50.830
remember that you can also rely on
animations completing in wall clock time.

00:51:50.830 --> 00:51:55.270
All of Core Animation's facilities are
designed to be scalable to system load.

00:51:55.340 --> 00:51:58.180
So the system can be really loaded down,
but if your animation was set

00:51:58.180 --> 00:52:00.680
to execute for three seconds,
well, when three seconds of

00:52:00.680 --> 00:52:02.710
wall clock time go by,
it's going to be done.

00:52:03.870 --> 00:52:06.360
So this means that you can
just use something simple

00:52:06.360 --> 00:52:09.320
like a timer to call you back,
an NS timer or other equivalent

00:52:09.340 --> 00:52:13.090
OS facility to give you a poke when
the animation duration has elapsed.

00:52:13.230 --> 00:52:15.750
And often that's actually simpler
because then you don't have to mess

00:52:15.760 --> 00:52:18.580
with creating your own animation
when you wouldn't otherwise have to.

00:52:20.280 --> 00:52:22.040
And then, of course,
remember in the context of looking

00:52:22.040 --> 00:52:25.040
at groups and keyframe animations,
in many cases,

00:52:25.040 --> 00:52:27.810
the ability to sequence animations,
if that's all you want to do is

00:52:27.810 --> 00:52:31.100
have animation A happen before
animation B and then animation C,

00:52:31.100 --> 00:52:32.520
you can do that with groups.

00:52:32.640 --> 00:52:33.840
And you don't need to get a callback.

00:52:33.930 --> 00:52:37.440
You just set that all up
in advance and let it fly.

00:52:37.560 --> 00:52:44.130
So we have a brief demo of that,
just to give you an idea how that works.

00:52:45.470 --> 00:52:48.360
This will also be available very
soon for download as sample code.

00:52:48.360 --> 00:52:49.180
It is in the pipe.

00:52:49.280 --> 00:52:53.070
This is intentionally designed as
a very simple example so that the

00:52:53.120 --> 00:52:56.220
code is not overly complicated,
but we are animating three

00:52:56.220 --> 00:52:57.760
different properties of a view.

00:52:57.760 --> 00:53:00.230
We have this blue sort of
canvas view that draws some

00:53:00.230 --> 00:53:03.030
guide points that tell us,
well, we're going to take this

00:53:03.030 --> 00:53:05.840
orange sub-view and we want to
move it through to point one,

00:53:05.950 --> 00:53:07.640
to point two, to point three.

00:53:07.780 --> 00:53:10.540
And you can see we're going to change the
orientation of the view as we go along.

00:53:10.540 --> 00:53:12.820
So we're changing not only
the view's frame origin,

00:53:12.850 --> 00:53:15.420
we're going to change its
frame rotation as we go,

00:53:15.730 --> 00:53:20.400
and we're also going to have
it change colors as we go.

00:53:20.400 --> 00:53:20.400
So when we execute that animation...

00:53:20.640 --> 00:53:27.090
This is done using both keyframe
animations and animation groups.

00:53:27.090 --> 00:53:30.190
I'm using a group as the top-level
animation so that I can aggregate

00:53:30.190 --> 00:53:31.900
these different animations together.

00:53:31.900 --> 00:53:34.410
For each of the
properties being animated,

00:53:34.410 --> 00:53:36.500
I'm using a keyframe animation.

00:53:36.500 --> 00:53:39.440
There's a keyframe animation for
the frame origin that specifies

00:53:39.510 --> 00:53:41.010
where the corner of the view goes.

00:53:41.060 --> 00:53:45.540
There's a keyframe animation for
the scalar frame rotation property.

00:53:45.540 --> 00:53:49.690
And there's a keyframe animation
also for the color property.

00:53:49.700 --> 00:53:52.920
One interesting thing to note,
NSColor properties,

00:53:52.920 --> 00:53:57.140
AppKit didn't know how to interpolate
those or animate them in Leopard,

00:53:57.140 --> 00:53:58.610
although there's a neat trick.

00:53:58.700 --> 00:54:03.210
If you link against the Quartz framework,
there's a category inside Quartz

00:54:03.210 --> 00:54:05.210
Composer that provides that.

00:54:05.280 --> 00:54:05.960
So it'll actually work.

00:54:06.060 --> 00:54:08.340
This is running on 10.5.3, by the way,
on Leopard.

00:54:08.340 --> 00:54:10.830
As I think I meant to say before,
all of these techniques that

00:54:10.830 --> 00:54:13.540
I'm describing today work on
Leopard as well as Snow Leopard.

00:54:13.540 --> 00:54:18.900
So you can link against
the Quartz framework to get

00:54:18.900 --> 00:54:18.900
NSColor animation support.

00:54:18.900 --> 00:54:21.300
On Leopard or in the
Snow Leopard seed that you have,

00:54:21.300 --> 00:54:22.050
this is fixed.

00:54:22.100 --> 00:54:23.700
It's an intrinsic part of AppKit now.

00:54:23.700 --> 00:54:25.860
So you have NSColor animation built in.

00:54:25.860 --> 00:54:28.450
And another interesting thing
to point out is that all of

00:54:28.590 --> 00:54:31.700
this animation capability that
we built into AppKit is also,

00:54:31.700 --> 00:54:34.230
even if you're using
CA animations to describe it,

00:54:34.260 --> 00:54:36.100
you don't have to be in
layer back mode to use it.

00:54:36.100 --> 00:54:37.770
So when I toggle off
this layer back checkbox,

00:54:37.770 --> 00:54:40.090
now we're just running in
conventional view drawing mode.

00:54:40.090 --> 00:54:41.950
And the frame rate maybe
isn't quite as fluid,

00:54:42.060 --> 00:54:43.040
but it's pretty good.

00:54:43.060 --> 00:54:45.960
And I haven't changed anything
otherwise about the way that the

00:54:45.960 --> 00:54:48.100
animation is specified and implemented.

00:54:48.100 --> 00:54:49.580
Okay.

00:54:53.000 --> 00:54:57.540
So that is group animations and keyframe
animations operating simultaneously.

00:54:57.540 --> 00:55:00.010
I don't have time to go through
the code step-by-step on stage,

00:55:00.030 --> 00:55:02.170
but there's going to be a readme with it.

00:55:02.200 --> 00:55:03.100
It's all set to go.

00:55:03.100 --> 00:55:05.470
So as soon as that's
available to download,

00:55:05.580 --> 00:55:08.200
I hope you will take a look
at it and encourage you to

00:55:08.240 --> 00:55:10.000
examine it at your leisure.

00:55:10.000 --> 00:55:11.740
So we can go back to slides, please.

00:55:16.920 --> 00:55:19.300
So, one more topic, last topic for today.

00:55:19.300 --> 00:55:22.650
Hopefully you left a little
room in your memories for it.

00:55:23.000 --> 00:55:25.320
Layer and view geometry mapping.

00:55:25.320 --> 00:55:26.930
Why is this important?

00:55:26.990 --> 00:55:31.490
Why are the differences between
NSView's geometry and a CA layer's

00:55:31.490 --> 00:55:33.740
model of geometry important?

00:55:34.120 --> 00:55:36.280
Leo Parad Well,
it turns out to matter a bit

00:55:36.280 --> 00:55:39.290
because AppKit has to do some
automatic mapping between view

00:55:39.290 --> 00:55:43.240
properties and layer properties,
as I said, to implement that push model.

00:55:43.240 --> 00:55:44.700
And we try to get it
right most of the time.

00:55:44.700 --> 00:55:46.810
In some cases,
it doesn't quite come out looking

00:55:46.820 --> 00:55:49.360
like what you might expect,
and you might have animations

00:55:49.360 --> 00:55:52.520
hanging off of certain key values
that don't seem to get executed.

00:55:52.520 --> 00:55:54.180
So, why is that sometimes?

00:55:54.180 --> 00:55:57.160
As I said, there are many similarities
between the geometry models,

00:55:57.160 --> 00:55:59.190
but there are several
important differences.

00:55:59.240 --> 00:56:01.720
So, let's take a look at what
those differences are.

00:56:05.020 --> 00:56:08.650
is the founder of the Let's look at this
slide on accommodating those differences.

00:56:08.670 --> 00:56:12.570
As I said, we map view property
changes to layer properties.

00:56:12.580 --> 00:56:16.090
Every time we change a view property,
I'm probably...

00:56:17.320 --> 00:56:19.760
Every time you change a view property,
we're going to map that to

00:56:19.760 --> 00:56:22.070
a change in one or more of a
backing layer's properties.

00:56:22.080 --> 00:56:24.410
That's really the most
important point on this slide,

00:56:24.410 --> 00:56:27.290
is that it's not necessarily
a one-to-one mapping.

00:56:27.290 --> 00:56:30.140
We change a view property,
sometimes we're going to have to change

00:56:30.140 --> 00:56:33.450
more than one layer property to get
the corresponding look on the screen.

00:56:36.480 --> 00:56:39.630
So what do these two models look like
when we look at them side by side?

00:56:39.630 --> 00:56:43.000
First thing interesting to
point out is that AppKit strives

00:56:43.020 --> 00:56:46.440
to be resolution independent,
so all view geometry properties

00:56:46.440 --> 00:56:50.120
are specified in units of points,
which are ideally a 72nd of an inch,

00:56:50.120 --> 00:56:52.690
whereas Core Animation doesn't
really try to deal with

00:56:52.690 --> 00:56:54.510
resolution independence issues.

00:56:54.580 --> 00:56:58.410
You specify everything in
pixel units always with layers.

00:56:59.610 --> 00:57:07.950
Leo Parmigiano-Rocco So this will come
up if you're looking at your Layer-Backed

00:57:07.950 --> 00:57:10.020
View tree and you use PO of your view
subtree description and you look at the

00:57:10.020 --> 00:57:12.010
backing layers bounds and you'll say,
well, if you're running at more

00:57:12.080 --> 00:57:13.610
than a 1.0 scale factor,
you might notice that the

00:57:13.610 --> 00:57:15.780
layer is going to be sized
numerically larger than the view.

00:57:15.780 --> 00:57:19.530
AppKit automatically does that
to try to accommodate running

00:57:19.780 --> 00:57:21.550
at higher scale factors.

00:57:21.560 --> 00:57:23.900
Leo Parmigiano-Rocco
What about exterior geometry?

00:57:23.900 --> 00:57:28.580
For a view, the primary determiner of the
view's size is its frame size.

00:57:29.320 --> 00:57:31.880
Leo Parmigiano-Rocco Whereas for a layer,
it's really bounds that's

00:57:31.880 --> 00:57:33.420
a more intrinsic property.

00:57:33.420 --> 00:57:37.890
Bounds is what defines how many
pixels wide and high a layer is,

00:57:37.900 --> 00:57:42.380
as well as what the layer's
interior coordinate origin is.

00:57:42.660 --> 00:57:45.580
For positioning with views,
we use frame origin.

00:57:45.610 --> 00:57:48.300
Whereas for a CA layer,
figuring out where the layer

00:57:48.310 --> 00:57:51.250
goes in its super layer,
determining that is done by a

00:57:51.300 --> 00:57:55.190
combination of setting the layer's
position and also an anchor point

00:57:55.190 --> 00:57:56.920
value that basically specifies,
well,

00:57:57.060 --> 00:58:03.000
what part of this layer should I pin
to that position in my super layer?

00:58:03.000 --> 00:58:07.800
Leo Parmigiano-Rocco We do have a concept
of frame in the AppKit level for NSView,

00:58:07.800 --> 00:58:10.820
but really it's frame size and
frame origin that are the more

00:58:10.820 --> 00:58:12.620
fundamental properties for a view.

00:58:12.620 --> 00:58:14.370
In that if you invoke
set frame for a view,

00:58:14.370 --> 00:58:17.470
well, AppKit behind the scenes is just
going through the public set frame

00:58:17.470 --> 00:58:19.150
size and set frame origin methods.

00:58:19.240 --> 00:58:21.590
Those are the fundamental components,
and frame is really more

00:58:21.590 --> 00:58:22.690
of a convenience concept.

00:58:22.810 --> 00:58:25.200
The same is true for CA layers.

00:58:25.200 --> 00:58:27.330
There's a frame property
defined on CA layer,

00:58:27.330 --> 00:58:29.060
but that's really a convenience.

00:58:29.060 --> 00:58:31.600
When you set a layer's frame,
Core Animation under the hood

00:58:31.600 --> 00:58:32.980
figures out that it's a frame.

00:58:32.980 --> 00:58:34.590
It figures out, okay, well,
what position do I need

00:58:34.650 --> 00:58:35.500
to assign to the layer?

00:58:35.500 --> 00:58:39.700
What's the layer's new bound size going
to be in order to get the same effect?

00:58:39.800 --> 00:58:42.420
So frame is really kind
of a convenience concept.

00:58:42.420 --> 00:58:46.490
In terms of other exterior transforms,
you can rotate a view by setting

00:58:46.490 --> 00:58:48.340
the view's frame rotation.

00:58:48.340 --> 00:58:52.620
Core Animation exposes a bit more
of a general model for CA layers.

00:58:52.620 --> 00:58:57.730
You can apply an arbitrary transform
defined by any 4x4 matrix to a

00:58:58.110 --> 00:59:02.790
layer to scale and translate and
rotate and do all of those things.

00:59:02.960 --> 00:59:05.470
with a single property.

00:59:05.850 --> 00:59:07.900
Interior Coordinates.

00:59:07.900 --> 00:59:10.180
As you may know from working with views,
views can be flipped.

00:59:10.190 --> 00:59:13.340
And when an NS view is flipped,
that means its origin for its own

00:59:13.460 --> 00:59:16.960
drawing and for positioning of
subviews is in its upper left corner.

00:59:16.960 --> 00:59:20.950
And its y-axis extends
downward from the top.

00:59:21.040 --> 00:59:22.190
So positive y goes down.

00:59:22.260 --> 00:59:24.660
This is convenient for
certain kinds of views.

00:59:24.660 --> 00:59:26.320
But it doesn't really affect the views.

00:59:26.320 --> 00:59:28.940
It affects where the views,
immediate subviews get positioned,

00:59:29.050 --> 00:59:30.770
how their frame origins are interpreted.

00:59:30.770 --> 00:59:33.620
But it's not recursive in effect
further down the view tree.

00:59:34.270 --> 00:59:35.880
In Snow Leopard, C.A.

00:59:35.880 --> 00:59:40.300
Layer introduces an IsGeometryFlipped
property that John Harper talked about

00:59:40.300 --> 00:59:42.600
in the Core Animation talks yesterday.

00:59:42.890 --> 00:59:46.360
IsGeometryFlipped is a
recursive property in effect.

00:59:46.440 --> 00:59:50.120
Sort of affects the whole layer
hierarchy going all the way down.

00:59:50.120 --> 00:59:52.610
So it's not really
exactly the same concept.

00:59:52.680 --> 00:59:56.100
It has a different purpose really,
which is to accommodate...

00:59:56.330 --> 01:00:01.620
Porting your code that works with
layers between the iPhone or iPod

01:00:01.620 --> 01:00:07.200
Touch world and the Mac desktop world
where things are flipped differently.

01:00:08.110 --> 01:00:10.700
So those don't really map
to each other exactly.

01:00:10.700 --> 01:00:12.060
What about translation?

01:00:12.100 --> 01:00:14.520
When you want to shift
the contents of a view,

01:00:14.520 --> 01:00:16.680
you've got more content
than will fit in your view,

01:00:16.680 --> 01:00:20.780
and so you're just drawing a
certain visible portion at a time.

01:00:20.780 --> 01:00:26.480
This is accomplished using bounds
origin changes at the NSView level.

01:00:26.480 --> 01:00:29.960
You change a view's bounds origin,
and you end up changing which rectangle

01:00:29.960 --> 01:00:31.870
of your content it ends up drawing.

01:00:31.920 --> 01:00:35.060
Same thing in that case
actually applies to CA layers.

01:00:35.060 --> 01:00:40.820
But it's important to note that bounds
is an atomic property for a layer.

01:00:40.820 --> 01:00:45.000
It's not bound size and bounds origin
that are the fundamental components,

01:00:45.080 --> 01:00:51.190
but bounds itself is one value that
you can set atomically as a unit.

01:00:51.900 --> 01:00:55.490
Scaling and other kinds of transforms.

01:00:55.540 --> 01:00:57.320
You can set the bound size for a view.

01:00:57.320 --> 01:00:58.990
You can set the bounds rotation.

01:00:59.000 --> 01:01:01.500
Bounds rotation hasn't been really
useful to people over the years.

01:01:01.500 --> 01:01:03.800
It's kind of esoteric, but it's there.

01:01:03.800 --> 01:01:08.730
Again, in the Layer Kit land,
or rather Core Animation land, sorry,

01:01:08.810 --> 01:01:12.760
you can apply more general kinds
of transforms at draw time.

01:01:12.820 --> 01:01:15.800
It's not defined in the
CA Layer API exactly as a property,

01:01:15.800 --> 01:01:18.680
but you can just apply whatever
transforms you want when you're

01:01:18.680 --> 01:01:20.470
doing your drawing and hit testing.

01:01:21.280 --> 01:01:22.580
So why is this important to know?

01:01:22.580 --> 01:01:25.320
Well, let's take an example where
we have a Layer-Backed View,

01:01:25.320 --> 01:01:26.760
and we're changing its frame origin.

01:01:26.760 --> 01:01:28.410
And we're messaging the
view through its animator,

01:01:28.460 --> 01:01:30.850
so we want to get an animation.

01:01:31.040 --> 01:01:46.230
is the founder of AppKit.

01:01:46.230 --> 01:01:46.230
He's the founder of the new layer
that maps to this new origin.

01:01:46.230 --> 01:01:46.230
When the view is layer-backed,
AppKit starts by mapping this to, okay,

01:01:46.230 --> 01:01:46.230
well, changing the view's frame origin
means I've got to update the

01:01:46.230 --> 01:01:46.230
layer's corresponding position.

01:01:46.230 --> 01:01:46.230
So we figure out the corresponding
position for the layer that maps

01:01:46.230 --> 01:01:46.230
to that new origin for the view.

01:01:46.300 --> 01:04:48.300
[Transcript missing]

01:04:48.630 --> 01:04:50.500
So that's what we have for today.

01:04:50.500 --> 01:04:53.940
In brief recap,
we looked at layer life cycles and how

01:04:53.940 --> 01:04:55.380
to deal with layers coming and going.

01:04:55.380 --> 01:04:57.660
The take-home point there,
override set layer.

01:04:57.660 --> 01:05:00.420
That's an excellent funnel point to find
out when you're getting a backing layer,

01:05:00.420 --> 01:05:03.180
when it's getting pulled away from you,
so you can adapt to that if you need to.

01:05:03.950 --> 01:05:07.130
Subpixel anti-aliasing works
differently in layer-backed mode.

01:05:07.140 --> 01:05:11.260
And the best solution there is usually
to either provide an opaque background

01:05:11.260 --> 01:05:15.220
for your viewer control so that you
get good quality LCD anti-aliasing,

01:05:15.260 --> 01:05:18.410
or leave your control without a
background and fall back to whole

01:05:18.510 --> 01:05:22.420
pixel anti-aliasing by disabling font
smoothing in the graphics context.

01:05:22.420 --> 01:05:24.860
We looked at how to drive
motion programmatically,

01:05:24.960 --> 01:05:25.700
real simple.

01:05:25.700 --> 01:05:28.080
Performance drawing and debugging tips.

01:05:28.080 --> 01:05:29.220
Sequencing animations.

01:05:29.230 --> 01:05:32.030
Again, there will be a code sample,
a sequencing code sample that

01:05:32.030 --> 01:05:33.540
should be available very soon.

01:05:33.970 --> 01:05:35.690
You can inspect the code,
and there's a readme that

01:05:35.700 --> 01:05:36.800
explains how it all works.

01:05:36.800 --> 01:05:39.490
That's the very same example
that I showed here just now.

01:05:39.500 --> 01:05:41.950
And we looked at how layer
and view geometry compare,

01:05:41.950 --> 01:05:44.400
and hopefully I didn't confuse
you too much with that.

01:05:44.510 --> 01:05:46.120
Try not to let it hurt your head.

01:05:46.120 --> 01:05:48.440
But it's just good to know that
things are a little different,

01:05:48.440 --> 01:05:51.060
and even where the same terms are used,
things like frame and bounds,

01:05:51.060 --> 01:05:52.950
they don't necessarily
quite mean the same thing,

01:05:52.980 --> 01:05:54.090
so be careful about that.

01:05:56.010 --> 01:05:57.820
We will have a Q&A session briefly.

01:05:57.820 --> 01:05:59.710
We have about 10 minutes
for Q&A after this talk.

01:05:59.760 --> 01:06:03.340
But for anything more complicated,
if you have a very complicated issue or

01:06:03.340 --> 01:06:06.390
some debugging issue you need help with,
I'd like to also point out

01:06:06.490 --> 01:06:09.520
there's a Cocoa Lab that started
at noon and is continuing until,

01:06:09.520 --> 01:06:11.500
I believe, 1.45 today.

01:06:11.500 --> 01:06:14.860
I will be there immediately after
this talk to try to help answer any

01:06:14.860 --> 01:06:16.910
more in-depth questions you may have.

01:06:16.970 --> 01:06:18.440
So I encourage you to come.

01:06:18.440 --> 01:06:20.310
There were a couple of
Core Animation sessions

01:06:20.310 --> 01:06:23.120
yesterday that were an excellent
introduction to Core Animation and

01:06:23.120 --> 01:06:24.440
all the details of how it works.

01:06:24.440 --> 01:06:26.370
Those will serve you well,
even if you're working

01:06:26.440 --> 01:06:27.850
with Layer-Backed Views.

01:06:27.850 --> 01:06:30.260
It helps to understand what's
happening under the hood.

01:06:30.260 --> 01:06:32.190
So when those become
available on ADC on iTunes,

01:06:32.190 --> 01:06:33.630
I encourage you to look at those.

01:06:33.680 --> 01:06:36.460
We have three more excellent
Cocoa sessions lined

01:06:36.530 --> 01:06:38.810
up for this afternoon,
back-to-back.

01:06:38.880 --> 01:06:43.620
At 2 o'clock in Marina, we will have a
Cocoa Performance Techniques

01:06:43.720 --> 01:06:45.400
talk that is all new.

01:06:45.400 --> 01:06:47.930
This is something that hasn't
been presented before at WWDC.

01:06:48.020 --> 01:06:51.560
And there's a bunch of new material
in there covering new Snow Leopard

01:06:51.600 --> 01:06:55.000
features and techniques you can
use specifically on Snow Leopard,

01:06:55.110 --> 01:06:58.260
as well as on earlier OSs for
optimizing things like caching,

01:06:58.270 --> 01:07:01.380
purgeable memory,
ways to exploit concurrency and ways

01:07:01.480 --> 01:07:04.780
that we provide concurrent APIs for
you in AppKit and Foundation to

01:07:04.800 --> 01:07:08.280
enable you to leverage multi-core
machines more effectively.

01:07:08.280 --> 01:07:11.760
Polishing your Cocoa application
in Russian Hill today at 3.30.

01:07:11.760 --> 01:07:15.910
And another performance session
focusing on document-centric Cocoa apps.

01:07:15.980 --> 01:07:17.340
If you're using the NS Document.

01:07:17.600 --> 01:07:22.240
You'll want to go to Russian Hill today
at 5 o'clock to hear about that.

01:07:22.310 --> 01:07:25.350
And I believe there will also be some
talk about sudden termination in there,

01:07:25.350 --> 01:07:26.800
a new feature of Snow Leopard.

01:07:28.320 --> 01:07:32.020
For more information about any of this,
you can contact Derek Horn if you like.

01:07:32.120 --> 01:07:34.150
He's our
Application Technologies Evangelist.

01:07:34.150 --> 01:07:38.440
I encourage you to read the documentation
that we have and also keep an eye on the

01:07:38.440 --> 01:07:42.750
App Kit release notes for latest changes,
especially starting with your seed

01:07:42.750 --> 01:07:45.130
because we've been working on stuff.

01:07:45.980 --> 01:07:48.400
Your feedback and bug reports
matter very much to us.

01:07:48.400 --> 01:07:51.820
This is a technology that we're very
interested in advancing further.

01:07:51.820 --> 01:07:55.190
We have some ideas in mind about
things that we want to improve in it,

01:07:55.270 --> 01:07:58.090
but we'd like to know especially
what's important to you,

01:07:58.200 --> 01:08:00.320
what kinds of issues have you run into.
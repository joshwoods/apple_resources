WEBVTT

00:00:20.100 --> 00:00:25.100
Good morning.

00:00:25.180 --> 00:00:30.100
So welcome to the final day of WDC 2008.

00:00:30.100 --> 00:00:31.300
My name is Dean Reece.

00:00:31.300 --> 00:00:33.660
I manage the I/O Kit team.

00:00:33.890 --> 00:00:38.530
at Apple and this morning I'm going to
be talking a little bit about I/O Kit.

00:00:38.590 --> 00:00:41.500
Just a quick show of hands,
who here is brand new to I/O Kit,

00:00:41.500 --> 00:00:44.440
haven't really looked at
I/O Kit drivers before?

00:00:44.440 --> 00:00:47.110
Wow, so we have a bunch of new
folks in the audience,

00:00:47.110 --> 00:00:48.780
that's excellent, welcome.

00:00:48.780 --> 00:00:51.980
Hopefully this will be a good session
for you to learn some interesting

00:00:52.040 --> 00:00:55.370
details about I/O Kit and show of hands,
how many people have already

00:00:55.370 --> 00:00:58.670
done some I/O Kit work before
and is looking for a refresher?

00:00:58.800 --> 00:01:01.150
Alright,
so hopefully there'll be something

00:01:01.150 --> 00:01:02.760
in there for you as well.

00:01:02.760 --> 00:01:05.450
Let's dive in,
we've got a lot to go through,

00:01:05.450 --> 00:01:07.690
I/O Kit is not a small
piece of technology.

00:01:09.590 --> 00:01:10.550
So what is I/O Kit?

00:01:10.680 --> 00:01:13.910
Let's draw a box around it so
you can kind of get an idea of

00:01:14.010 --> 00:01:15.390
what it is and what it isn't.

00:01:15.480 --> 00:01:19.580
So simply stated, it's the device driver
model for MacÂ OSÂ X.

00:01:19.640 --> 00:01:24.380
And I/O Kit drivers are
written in a subset of C++.

00:01:24.380 --> 00:01:27.020
We use a standard C++ compiler,
but we restrict the

00:01:27.020 --> 00:01:28.120
language features a bit.

00:01:28.250 --> 00:01:30.420
I'll talk about that shortly.

00:01:30.810 --> 00:01:32.500
And it runs inside the kernel.

00:01:32.500 --> 00:01:35.800
The Darwin kernel that's used
on MacÂ OSÂ X is a single process,

00:01:35.910 --> 00:01:36.700
single address space.

00:01:36.700 --> 00:01:39.700
All the drivers run in
that single process,

00:01:39.710 --> 00:01:42.190
and we'll talk about what that means.

00:01:42.400 --> 00:01:45.400
And it also,
in addition to being the kernel

00:01:45.400 --> 00:01:50.540
runtime environment for drivers,
it's also a framework that applications

00:01:50.540 --> 00:01:52.160
use to talk to those drivers.

00:01:52.200 --> 00:01:56.200
So it's really two separate things
depending on your perspective.

00:01:56.200 --> 00:01:59.700
Now, the I/O Kit is not
part of the iPhone SDK,

00:01:59.700 --> 00:02:03.170
so if you're interested in
writing iPhone applications,

00:02:03.210 --> 00:02:06.470
I/O Kit is not available to you.

00:02:08.390 --> 00:02:11.580
So to describe it graphically
where it fits in the system,

00:02:11.600 --> 00:02:14.780
the large purple area at the
bottom there represents the

00:02:14.780 --> 00:02:18.440
entire kernel address space,
the entire kernel process.

00:02:18.440 --> 00:02:22.190
And we're going to be focusing
in specifically on I/O Kit and

00:02:22.190 --> 00:02:25.240
the drivers that plug into it.

00:02:25.550 --> 00:02:27.590
And we'll also talk
about libkern as well,

00:02:27.590 --> 00:02:31.800
because that's the basic kernel
library that I/O Kit builds upon.

00:02:31.820 --> 00:02:35.620
So you can't really talk about
I/O Kit without exploring libkern some.

00:02:36.990 --> 00:02:39.030
So the next question then
is when do you use I/O Kit?

00:02:39.040 --> 00:02:41.540
When is it appropriate
to use this framework?

00:02:41.580 --> 00:02:44.780
Well, if you're writing a driver
that needs to be in the kernel,

00:02:44.800 --> 00:02:47.460
and what does that mean?

00:02:47.510 --> 00:02:51.220
Well, the number one thing is if you need
to take interrupts directly or you

00:02:51.220 --> 00:02:55.250
need to get registers directly,
then you're probably going to

00:02:55.250 --> 00:02:56.420
need to live in the kernel.

00:02:56.420 --> 00:02:59.670
Those things are not available
to user-space applications.

00:02:59.940 --> 00:03:03.710
The third reason up here
is a performance reason.

00:03:03.950 --> 00:03:07.780
If you're inside the kernel and your
primary client is inside the kernel,

00:03:07.840 --> 00:03:11.300
then you can stack very neatly
and communications very quick.

00:03:11.360 --> 00:03:14.540
If your primary client,
say a file system, lives in the kernel,

00:03:14.620 --> 00:03:16.620
but your driver were to
live outside the kernel,

00:03:16.670 --> 00:03:21.110
that would require multiple user-kernel
boundary crossings just to move data from

00:03:21.110 --> 00:03:24.180
the physical device up to your driver,
back down to the file system,

00:03:24.260 --> 00:03:26.100
and there's obvious
performance issues there.

00:03:26.100 --> 00:03:29.480
And it may be appropriate in some cases,
but as a rule of thumb,

00:03:29.630 --> 00:03:31.650
if your primary client
lives in the kernel,

00:03:31.860 --> 00:03:33.900
your driver should probably
live in the kernel as well.

00:03:33.900 --> 00:03:35.010
Amen.

00:03:35.300 --> 00:03:39.220
The in-kernel drivers,
all in kernel code for that matter,

00:03:39.300 --> 00:03:41.090
uses the kernel framework.

00:03:41.300 --> 00:03:44.890
The kernel framework is unique among
the frameworks in that it is the only

00:03:44.900 --> 00:03:48.340
framework kernel extensions can use,
and it is also not

00:03:48.340 --> 00:03:50.300
available to applications.

00:03:50.300 --> 00:03:52.170
Kernel framework is only
for use by kernel code.

00:03:52.300 --> 00:03:55.300
It's also a framework that
is made up only of headers.

00:03:55.300 --> 00:03:57.210
It has no binary component.

00:03:57.300 --> 00:04:00.430
The binary component is the
actual live running kernel,

00:04:00.430 --> 00:04:03.300
and that's the way kernel
extensions get loaded.

00:04:03.300 --> 00:04:07.130
So kernel framework is available
for kernel extensions only.

00:04:07.300 --> 00:04:09.470
Now, that being said,
you should avoid writing an

00:04:09.470 --> 00:04:11.300
in-kernel driver if you can avoid it.

00:04:11.300 --> 00:04:14.570
If you're able to accomplish
what you need by writing

00:04:14.570 --> 00:04:16.290
code outside of the kernel,
that's preferable.

00:04:16.300 --> 00:04:21.390
It's easier to debug,
and it's also a little bit safer if

00:04:21.390 --> 00:04:25.280
something were to crash in your code,
it wouldn't bring the whole system down.

00:04:27.210 --> 00:04:30.040
So the other half of I/O Kit,
the user-space half.

00:04:30.060 --> 00:04:34.100
A lot of drivers actually work
correctly outside of the kernel.

00:04:34.100 --> 00:04:39.110
Cameras, scanners, image capture,
printer, plug-ins,

00:04:39.110 --> 00:04:43.860
and also applications and utilities
that want to present a GUI to,

00:04:43.860 --> 00:04:46.590
say,
expose some control aspect of a device.

00:04:46.600 --> 00:04:49.610
Those things all live outside
of the kernel and make use

00:04:49.720 --> 00:04:52.480
of the I/O Kit framework,
not the kernel framework,

00:04:52.480 --> 00:04:53.600
the I/O Kit framework.

00:04:53.820 --> 00:04:57.800
And I/O Kit framework is
available to user-space programs,

00:04:57.930 --> 00:05:02.600
and it gives you access to the
device drivers inside the kernel,

00:05:02.600 --> 00:05:05.100
but it itself doesn't run in the kernel.

00:05:05.100 --> 00:05:08.100
It's kind of a proxy to
get you into the kernel.

00:05:08.150 --> 00:05:10.540
And again,
I reiterate on the last bullet there,

00:05:10.600 --> 00:05:13.100
avoid writing a kernel
extension if you can.

00:05:13.100 --> 00:05:16.570
It's generally better for you
and better for your customers.

00:05:18.670 --> 00:05:20.400
So what were the design goals of I/O Kit?

00:05:20.410 --> 00:05:22.800
What were we thinking when
we put all this together?

00:05:22.800 --> 00:05:24.290
What was in our heads?

00:05:24.430 --> 00:05:28.000
Well, writing a device driver for
a modern operating system is

00:05:28.000 --> 00:05:29.400
a very complicated process.

00:05:29.400 --> 00:05:30.800
There's a lot to it.

00:05:30.800 --> 00:05:34.800
So we tried to simplify it as much as
we could without oversimplifying it.

00:05:34.840 --> 00:05:38.800
And some of the things are
multiprocessor systems,

00:05:38.800 --> 00:05:43.060
preemptive kernel environment,
multiple address spaces and

00:05:43.060 --> 00:05:46.200
sizes and Indian-nesses,
the byte ordering.

00:05:46.200 --> 00:05:50.700
All that has to be coped with by drivers
because drivers talk to hardware,

00:05:50.720 --> 00:05:53.990
drivers also talk to applications,
and drivers run in the kernel.

00:05:54.000 --> 00:05:58.080
So there's three separate address
spaces that drivers have to deal with.

00:05:58.450 --> 00:06:02.870
And we also really want drivers to
focus on mechanism and not policy.

00:06:03.180 --> 00:06:06.960
This is kind of a central concept that
you might want to really think about when

00:06:06.960 --> 00:06:09.300
you're putting your software together.

00:06:09.300 --> 00:06:12.400
If you need to have policy that is
some kind of decision being made

00:06:12.400 --> 00:06:16.190
based on what the machine is doing,
based on what a user is doing,

00:06:16.210 --> 00:06:19.220
you probably want that policy to
be put into a piece of software

00:06:19.340 --> 00:06:21.300
that runs outside the kernel.

00:06:21.560 --> 00:06:25.450
The kernel is really just a
service library intended to do

00:06:25.450 --> 00:06:28.300
whatever the user-space apps want.

00:06:28.300 --> 00:06:31.300
The user-space apps call into
the kernel to get things done,

00:06:31.300 --> 00:06:32.300
the kernel gets them done.

00:06:32.300 --> 00:06:34.300
That's the mechanism piece.

00:06:34.300 --> 00:06:38.270
The thing that lives in the kernel
is really supposed to get things done

00:06:38.340 --> 00:06:40.660
at the request of user-space pieces.

00:06:41.680 --> 00:06:44.630
At the core,
I/O Kit has a set of APIs that

00:06:44.630 --> 00:06:46.200
are device independent.

00:06:46.300 --> 00:06:48.610
We really wanted to make sure
that we didn't wire in any

00:06:48.610 --> 00:06:52.480
dependencies about USB or SCSI.

00:06:52.700 --> 00:06:54.170
You know,
we didn't want to have anything built

00:06:54.250 --> 00:06:59.370
in that would 10 years down the road
make us not be able to move forward.

00:06:59.470 --> 00:07:02.100
So the core of I/O Kit APIs are
completely architecture

00:07:02.100 --> 00:07:06.300
and protocol independent.

00:07:06.490 --> 00:07:09.550
Now, obviously,
we have to have protocol-specific bits.

00:07:09.550 --> 00:07:13.000
We have to have PCI, we have to have USB,
and we even have SCSI.

00:07:13.100 --> 00:07:15.140
So we do that by these
things called families.

00:07:15.230 --> 00:07:20.200
They add chunks of functionality into the
kernel that device drivers can build on.

00:07:20.200 --> 00:07:22.070
And, um...

00:07:22.270 --> 00:07:24.160
Developers can also extend the kernel.

00:07:24.240 --> 00:07:25.200
You can write your own drivers.

00:07:25.200 --> 00:07:27.200
You can also write your own
families if you need to.

00:07:27.200 --> 00:07:35.700
If you have some functionality that
you need to share between several

00:07:35.980 --> 00:07:38.190
drivers and you don't want to cut
and paste it into all the drivers,

00:07:38.190 --> 00:07:38.190
you can write your own family
as a common service library.

00:07:40.070 --> 00:07:42.070
So what is it like to
develop for the kernel?

00:07:42.150 --> 00:07:45.700
What developing in the kernel is
different than developing for user-space?

00:07:45.830 --> 00:07:50.310
Well, the Darwin kernel is a process,
just like any other

00:07:50.310 --> 00:07:51.700
process on the system.

00:07:51.700 --> 00:07:55.890
You can run top or PS or other utilities,
and it'll show you process

00:07:55.890 --> 00:07:57.700
zero is the kernel.

00:07:57.700 --> 00:08:00.500
It's not exactly like other
processes in that it has a

00:08:00.500 --> 00:08:01.900
few things that are different.

00:08:01.920 --> 00:08:05.900
A lot of the things that you would
normally associate with a BSD process,

00:08:05.910 --> 00:08:07.400
like file descriptors
and things like that,

00:08:07.400 --> 00:08:08.900
are not there.

00:08:08.900 --> 00:08:11.370
But it has most of the other
trappings of a process.

00:08:11.400 --> 00:08:18.010
It has an address space, it has threads,
and, you know, IPC works between the

00:08:18.020 --> 00:08:20.380
kernel and other processes.

00:08:21.320 --> 00:08:25.220
But one thing that's very different
about the kernel is you don't launch it.

00:08:25.410 --> 00:08:27.800
Booting the system launches the kernel.

00:08:27.870 --> 00:08:29.490
It's actually the booter
that starts it up.

00:08:29.740 --> 00:08:33.100
And the kernel doesn't exit-- well,
hopefully it doesn't exit--

00:08:33.140 --> 00:08:35.540
until you shut down cleanly.

00:08:35.620 --> 00:08:39.880
So to get code into the kernel,
you're actually injecting code into

00:08:39.880 --> 00:08:42.930
a live running piece of software,
which is a little different than

00:08:42.930 --> 00:08:44.620
most applications on the system.

00:08:44.760 --> 00:08:49.310
So we have a fairly extensive collection
of technology we call text management

00:08:49.340 --> 00:08:51.170
or kernel extension management.

00:08:51.360 --> 00:08:57.160
And there's actually a session
on that after lunch today.

00:08:57.530 --> 00:09:00.110
These kernel extensions
are packaged as CFBundles.

00:09:00.220 --> 00:09:03.400
If you've played around on
the Mac platform at all,

00:09:03.460 --> 00:09:06.100
you've certainly seen
this notion of a CFBundle.

00:09:06.100 --> 00:09:09.070
It's basically a directory that
contains all the bits and pieces

00:09:09.090 --> 00:09:11.300
that are necessary for your product.

00:09:11.530 --> 00:09:14.100
Kernel extensions are CFBundles.

00:09:15.570 --> 00:09:18.120
Another important thing to think
about when you're putting code

00:09:18.130 --> 00:09:21.000
in the kernel and another reason
not to put code in the kernel,

00:09:21.060 --> 00:09:23.440
all the code running in the
kernel is inherently trusted.

00:09:23.490 --> 00:09:26.660
Once that first instruction
is executed in your code,

00:09:26.730 --> 00:09:30.380
you're running basically
completely unrestricted.

00:09:30.430 --> 00:09:32.530
You can do anything that
any kernel code can do.

00:09:32.780 --> 00:09:35.950
You can see any memory.

00:09:36.020 --> 00:09:38.100
That's why it's very important
when you're writing code for the

00:09:38.100 --> 00:09:39.890
kernel to always have that in mind.

00:09:40.130 --> 00:09:43.910
Make sure that you vet any parameters
you receive from user space.

00:09:43.980 --> 00:09:44.960
Never trust a pointer.

00:09:45.080 --> 00:09:49.090
We'll talk more about that later,
but you need to keep that in mind when

00:09:49.090 --> 00:09:50.270
you're writing a kernel extension.

00:09:53.170 --> 00:09:55.820
So also all kernel extensions
and the kernel itself share

00:09:55.820 --> 00:09:57.100
a single address space.

00:09:57.100 --> 00:09:58.200
It's like any other process.

00:09:58.300 --> 00:10:03.900
All the code running in that process zero
shares the same kernel address space.

00:10:03.950 --> 00:10:09.400
And on PowerPC and the i386 architecture,
that's a 32-bit address space.

00:10:09.400 --> 00:10:14.800
Now, if you've heard, hopefully you have,
we have a 64-bit version of the

00:10:14.930 --> 00:10:17.710
kernel in the Snow Leopard seed.

00:10:17.810 --> 00:10:20.390
And that architecture is x86-64.

00:10:20.410 --> 00:10:22.700
That's the actual
identifier we use in code.

00:10:22.730 --> 00:10:29.200
And this is just a third architecture,
PPC, i386, x86-64.

00:10:29.200 --> 00:10:31.400
But that obviously means
you have to update code.

00:10:31.400 --> 00:10:35.460
You have to make it aware that
pointers are bigger and so forth.

00:10:36.900 --> 00:10:41.030
Now, all of the APIs in the
kernel we refer to as KPIs,

00:10:41.180 --> 00:10:47.140
Kernel Programmatic Interface,
and I might call them APIs up here.

00:10:47.140 --> 00:10:49.640
I apologize if I'm inconsistent,
but when I'm talking about

00:10:49.640 --> 00:10:53.360
an in-kernel interface,
it's technically a KPI.

00:10:53.700 --> 00:10:56.140
The KPIs are in the kernel framework,
as I said before,

00:10:56.140 --> 00:10:58.430
and they're only available there.

00:11:00.510 --> 00:11:02.780
So the kernel is kind of
like a long-running app.

00:11:02.860 --> 00:11:04.840
As I said before,
hopefully it won't exit.

00:11:04.900 --> 00:11:09.000
Well, if it does exit,
that's called a crash or panic.

00:11:09.070 --> 00:11:12.600
Now, a lot of apps,
particularly small helper utilities,

00:11:12.600 --> 00:11:13.890
don't really bother to free memory.

00:11:13.900 --> 00:11:16.700
They do something and then they exit,
and that's how they free memory.

00:11:16.700 --> 00:11:18.800
Well,
you can't count on that in the kernel.

00:11:18.850 --> 00:11:22.290
You have to make sure that all of
your resource management is balanced.

00:11:22.390 --> 00:11:24.200
If you allocate something,
you have to free it.

00:11:24.210 --> 00:11:26.220
If you acquire a lock,
you have to release the lock.

00:11:26.310 --> 00:11:28.000
Everything has to be balanced.

00:11:28.110 --> 00:11:30.920
Otherwise,
the kernel will not be long running.

00:11:31.350 --> 00:11:33.560
All kernel memory, by default, is wired.

00:11:33.710 --> 00:11:36.380
When you allocate memory in the kernel,
it's wired memory.

00:11:36.500 --> 00:11:38.300
That means that it will not page out.

00:11:38.300 --> 00:11:44.300
So if an application allocates a megabyte
and doesn't touch it or doesn't use it,

00:11:44.300 --> 00:11:46.300
it's kind of an accounting trick.

00:11:46.340 --> 00:11:49.590
But if the kernel allocates a megabyte,
you've just acquired a megabyte

00:11:49.720 --> 00:11:52.280
of physical RAM that will not be
available to any other processes.

00:11:52.320 --> 00:11:54.530
So in that way,
you can think of kernel memory as

00:11:54.530 --> 00:11:56.160
more expensive than user memory.

00:11:56.300 --> 00:12:00.300
If you need to use the memory,
allocate it and use it.

00:12:00.300 --> 00:12:03.290
But just be mindful that
kernel memory is wired.

00:12:03.300 --> 00:12:06.300
Floating point is not
available in the kernel.

00:12:06.300 --> 00:12:09.300
That's a bit of an exaggeration.

00:12:09.300 --> 00:12:13.300
It's not available without
some extensive tricks.

00:12:13.300 --> 00:12:15.250
Best not to use floating point.

00:12:15.320 --> 00:12:17.300
If you're trying to use
floating point in the kernel,

00:12:17.300 --> 00:12:19.300
you need to step back and look at
what you're trying to accomplish.

00:12:19.300 --> 00:12:23.310
And maybe you need to factor your
code differently and do the floating

00:12:23.430 --> 00:12:25.570
point pieces outside the kernel.

00:12:25.910 --> 00:12:29.100
Most of your familiar libraries are
not available in the kernel either.

00:12:29.100 --> 00:12:32.570
For example,
we have an incomplete port of libc.

00:12:32.720 --> 00:12:34.660
The kernel environment is
intended to be minimal.

00:12:34.820 --> 00:12:37.000
We don't want to have more
in there than we need,

00:12:37.000 --> 00:12:38.800
kernel memory being wired and all.

00:12:38.830 --> 00:12:41.730
So you're going to find that your
options are a little bit limited

00:12:41.730 --> 00:12:44.790
when you're developing the kernel,
and that's intentional.

00:12:44.800 --> 00:12:49.800
It's actually a way of keeping the
kernel environment under control.

00:12:49.800 --> 00:12:52.510
Also, file I/O is not supported
from the kernel.

00:12:52.860 --> 00:12:55.800
The kernel does file I/O on
behalf of user processes,

00:12:55.800 --> 00:12:57.800
but it doesn't initiate any file I/O.

00:12:57.800 --> 00:13:01.960
So if you've got a KEXT and you say, "Oh,
I need to read a file," the

00:13:02.010 --> 00:13:04.800
KEXT needs to have a user component,
a daemon or something,

00:13:04.800 --> 00:13:08.350
handling the file I/O on its behalf.

00:13:10.900 --> 00:13:12.600
Debugging in the kernel
is also different.

00:13:12.680 --> 00:13:15.740
Again, it's a running process that
you can't really stop without

00:13:15.740 --> 00:13:17.100
stopping the whole system.

00:13:17.250 --> 00:13:20.900
So the way we do this is we use
a two-machine debug environment.

00:13:21.050 --> 00:13:24.500
You have one machine that is
running your test software,

00:13:24.500 --> 00:13:25.730
running your kernel extension.

00:13:26.050 --> 00:13:28.000
Your other machine has got GDB.

00:13:28.170 --> 00:13:32.000
You remotely connect over
either Ethernet or FireWire,

00:13:32.140 --> 00:13:34.840
and you can halt the machine,
you can single-step it,

00:13:35.030 --> 00:13:37.750
you can get symbolic backtraces.

00:13:37.960 --> 00:13:39.700
There's a tutorial called Hello Debugger.

00:13:39.700 --> 00:13:43.970
It's available on the ADC site,
along with the other

00:13:43.970 --> 00:13:45.990
simple Kecks tutorials.

00:13:46.000 --> 00:13:48.490
And it kind of walks you through
the process of simply quickly

00:13:48.490 --> 00:13:53.480
setting up a two-machine environment
and debugging a little bit.

00:13:56.570 --> 00:14:00.480
I said before that we use a restricted
subset of C++ in the kernel,

00:14:00.610 --> 00:14:03.420
and let's talk briefly
about what that means.

00:14:03.780 --> 00:14:08.520
Back when we first conceived of I/O Kit,
we consciously decided to restrict

00:14:08.570 --> 00:14:14.500
ourselves to the set of features
in a standard called embedded C++.

00:14:14.500 --> 00:14:17.050
I believe that's a defunct
standard these days,

00:14:17.140 --> 00:14:19.290
but we've stayed with the core concepts.

00:14:19.500 --> 00:14:22.880
So exceptions are not available,
and that was done because the rest of

00:14:22.990 --> 00:14:26.400
the kernel doesn't support exceptions,
and if an exception went

00:14:26.400 --> 00:14:28.940
uncaught through I/O Kit,
it could propagate out of the

00:14:28.950 --> 00:14:30.500
kernel and cause problems.

00:14:30.500 --> 00:14:34.420
We don't support multiple inheritance
that pose too much of a binary

00:14:34.510 --> 00:14:36.500
compatibility problem for us.

00:14:36.500 --> 00:14:38.410
We don't support
non-trivial constructors.

00:14:38.490 --> 00:14:41.500
That actually goes
back to the exceptions.

00:14:41.600 --> 00:14:45.140
The constructors pretty much
just boil down to allocators

00:14:45.160 --> 00:14:47.370
and initializers at this point.

00:14:47.890 --> 00:14:51.830
And we also don't support STL,
the Standard Template Library,

00:14:51.830 --> 00:14:56.770
and we don't use the standard C++ RTTI,
the Runtime Type Information System.

00:14:56.860 --> 00:14:59.800
We actually have our own simplified RTTI.

00:14:59.800 --> 00:15:03.920
It's different, but it meets our needs,
and it's mostly there for

00:15:03.930 --> 00:15:07.510
binary compatibility and
some limited introspection.

00:15:09.260 --> 00:15:11.820
So templates are partially
supported in that they don't

00:15:11.940 --> 00:15:14.460
cross kernel extension boundaries.

00:15:14.690 --> 00:15:19.960
You can actually use language features
available in the compiler that don't

00:15:19.960 --> 00:15:24.180
cause any runtime requirements or
don't cause any linkage changes.

00:15:24.290 --> 00:15:27.750
So you can put inline ASMs, you know,
you can put things in your code

00:15:27.750 --> 00:15:31.190
if you can get the compiler to
emit a kernel extension that's,

00:15:31.190 --> 00:15:35.130
you know, that we'll be able to link to,
but we don't support that.

00:15:35.200 --> 00:15:38.190
It's kind of a
no-lifeguard-on-duty situation.

00:15:38.290 --> 00:15:40.200
So we recommend not using templates.

00:15:40.200 --> 00:15:43.370
We have heard anecdotally there
are developers that have code that

00:15:43.370 --> 00:15:46.200
they're reporting that use templates
and they were able to get it to work.

00:15:46.200 --> 00:15:49.030
So if you have templates and
you need to get them to work,

00:15:49.030 --> 00:15:52.190
it's possible,
but it's not something we do internally.

00:15:52.200 --> 00:15:54.200
It's not something we test.

00:15:56.710 --> 00:15:59.060
So let's talk objects.

00:15:59.200 --> 00:16:01.490
Specifically,
I'm going to give you a brief

00:16:01.490 --> 00:16:05.880
tour of our class hierarchy,
at least some of the highlights of it.

00:16:05.920 --> 00:16:10.590
The root class within the kernel
C++ hierarchy is called OSObject.

00:16:10.670 --> 00:16:14.130
This is part of that
libkern library I mentioned.

00:16:14.790 --> 00:16:17.480
And it's really the root class
for all the kernel classes.

00:16:17.720 --> 00:16:19.940
It gives you some basic
type introspection.

00:16:19.940 --> 00:16:21.700
You can find out what class you are.

00:16:21.700 --> 00:16:25.700
You can find out if you're
compatible with a particular class.

00:16:25.700 --> 00:16:27.600
You can find out if another
object is compatible.

00:16:27.760 --> 00:16:30.540
You can do safe typing, typecasting.

00:16:31.000 --> 00:16:36.710
It also handles reference
counting for you.

00:16:36.710 --> 00:16:36.710
Some pretty basic
object-oriented type stuff.

00:16:37.410 --> 00:16:41.740
It also embodies the macros that
we use for binary compatibility,

00:16:41.770 --> 00:16:45.050
these OS declare structures and
OS define structures macros.

00:16:45.200 --> 00:16:48.190
If you've looked at any of our sample
code or any of the Darwin source code,

00:16:48.200 --> 00:16:49.000
you'll see these in there.

00:16:49.000 --> 00:16:50.340
They're very important.

00:16:50.500 --> 00:16:53.390
They provide information
that our linker uses,

00:16:53.390 --> 00:16:56.990
the KEXT linker uses for
binary compatibility.

00:16:57.150 --> 00:16:59.740
I've seen cases where
developers didn't put those in

00:16:59.740 --> 00:17:03.360
or didn't use them correctly,
and their KEXT worked until

00:17:03.360 --> 00:17:04.880
we changed the kernel.

00:17:04.970 --> 00:17:08.700
As soon as we changed something,
the binary compatibility patcher

00:17:08.700 --> 00:17:11.700
was not able to do the right thing,
and the KEXT wouldn't load anymore.

00:17:11.700 --> 00:17:14.200
So it's very important to make sure
you've got those right for any class,

00:17:14.330 --> 00:17:17.600
any subclass that you
declare of OS object.

00:17:19.110 --> 00:17:22.640
So very briefly,
we have some standard container objects.

00:17:22.810 --> 00:17:27.760
These are very similar to the
CF objects that Core Foundation has.

00:17:27.780 --> 00:17:31.440
OS number,
OS Boolean contain ordinal values.

00:17:31.470 --> 00:17:35.980
And we've got OS data, OS string,
and OS symbol to contain

00:17:35.980 --> 00:17:38.820
string and data values.

00:17:38.880 --> 00:17:40.900
These are not used for runtime data.

00:17:40.980 --> 00:17:44.780
You wouldn't use these to encapsulate
data you send down to your driver.

00:17:44.830 --> 00:17:47.430
These are basically used
for command and control.

00:17:47.680 --> 00:17:49.590
They're used to communicate
configuration details,

00:17:49.730 --> 00:17:52.790
things that are typically
lower bandwidth.

00:17:53.300 --> 00:17:56.710
We also have collection classes, again,
very similar to the

00:17:56.710 --> 00:17:59.200
Core Foundation collection classes.

00:17:59.200 --> 00:18:01.180
And these collection classes,
for the most part,

00:18:01.320 --> 00:18:03.200
contain other collection
classes or strings.

00:18:03.230 --> 00:18:06.160
If you look at how they're
used in I/O Kit and look at how

00:18:06.160 --> 00:18:10.230
they're used in our drivers,
we mostly use them just to build up a

00:18:10.230 --> 00:18:14.350
data structure of dictionaries and arrays
and strings that describe a device,

00:18:14.350 --> 00:18:16.200
that help with our matching and so on.

00:18:16.200 --> 00:18:18.200
So I'm not going to
get too far into these.

00:18:18.200 --> 00:18:26.200
They're pretty basic and very similar to
other object-oriented systems out there.

00:18:28.340 --> 00:18:30.320
Now,
we're going to get down into I/O Kit,

00:18:30.320 --> 00:18:33.250
where notice the prefix
has changed from OS to I/O.

00:18:33.730 --> 00:18:38.140
And there's a bunch of core concepts
of I/O Kit I want to talk about.

00:18:38.290 --> 00:18:44.600
So the Work Loop is probably one of the
fundamental core concepts of I/O Kit and

00:18:44.600 --> 00:18:46.300
the event sources that go with it.

00:18:46.370 --> 00:18:48.500
Work Loop is our synchronization model.

00:18:48.540 --> 00:18:52.800
It's conceptually
similar to a CF Run Loop,

00:18:52.820 --> 00:18:57.100
but its goal, its entire purpose,
is to provide you a way to know that

00:18:57.100 --> 00:18:59.100
your routines are not being re-entered.

00:18:59.160 --> 00:19:01.450
You can have routines that
are run on the Work Loop,

00:19:01.540 --> 00:19:06.600
as we say, and those routines will be
effectively single-threaded.

00:19:06.700 --> 00:19:10.380
So you don't have to worry about
protecting critical data structures.

00:19:10.400 --> 00:19:15.700
You don't have to worry about
serializing access to your device.

00:19:15.740 --> 00:19:18.330
I/O Work Loop handles that for you.

00:19:18.450 --> 00:19:21.420
And more importantly,
and this is something that it's

00:19:21.420 --> 00:19:25.600
easy to lose in the details,
but Work Loop is crafted specifically

00:19:25.600 --> 00:19:28.440
to work well when you've got
a bunch of drivers stacked up.

00:19:28.710 --> 00:19:30.900
If you look at the way
a system actually works,

00:19:31.090 --> 00:19:33.480
you've got a device plugged into PCI,
and that's got some

00:19:33.510 --> 00:19:35.440
device plugged into it,
and then that's got a

00:19:35.480 --> 00:19:36.990
partition scheme on top of it.

00:19:37.000 --> 00:19:39.220
And when you look at how
these drivers stack up,

00:19:39.300 --> 00:19:42.600
and we will in a few minutes,
there's a lot of layers there.

00:19:42.710 --> 00:19:46.740
And once you start adding up a lot of
locking schemes through those layers,

00:19:46.930 --> 00:19:49.500
you can wind up with some
real performance bottlenecks.

00:19:49.580 --> 00:19:53.910
Work Loop is designed specifically
to be efficient in that case,

00:19:53.910 --> 00:19:58.520
the way it shares context and shares
a lock between the various layers,

00:19:58.590 --> 00:20:01.800
and that's largely transparent
to any given layer.

00:20:01.920 --> 00:20:06.700
So one layer will do the right thing,
but then when the system stacks them up,

00:20:06.830 --> 00:20:09.500
the Work Loop is shared in
such a way that's efficient.

00:20:09.640 --> 00:20:11.600
And that's a very intentional
and careful design,

00:20:11.600 --> 00:20:15.560
though it's not obvious just
to look at the APIs or KPIs.

00:20:17.460 --> 00:20:20.190
A very important point here,
and I want to stress this,

00:20:20.400 --> 00:20:24.300
this is probably going to be the
one area that you have to do some

00:20:24.310 --> 00:20:28.530
rewriting if you're reporting
an existing driver to MacÂ OSÂ X.

00:20:29.210 --> 00:20:31.560
Most of the families in
I/O Kit assume that you're using a

00:20:31.560 --> 00:20:33.390
work loop for your synchronization.

00:20:33.400 --> 00:20:35.100
Some of them actually require it.

00:20:35.100 --> 00:20:39.430
And if you're bringing a driver
over that already has critical data

00:20:39.450 --> 00:20:44.630
locking and device serialization,
and you try to marry a work

00:20:44.630 --> 00:20:47.100
loop up with the locking that
you've already got in there,

00:20:47.100 --> 00:20:50.100
you are going to run into
deadlocks that are hard to debug.

00:20:50.100 --> 00:20:54.150
So I strongly recommend that instead
of trying to do a minimal port there,

00:20:54.150 --> 00:20:58.090
you really tear your code apart,
figure out what the critical areas are,

00:20:58.100 --> 00:21:01.060
and port it cleanly over to work loop.

00:21:01.140 --> 00:21:03.500
It's going to take a
little more work up front,

00:21:03.510 --> 00:21:06.210
but I guarantee it will
save you time in the end.

00:21:08.990 --> 00:21:10.970
So the event sources
go with the work loop.

00:21:11.080 --> 00:21:13.080
The work loop,
think of it really as a lock,

00:21:13.080 --> 00:21:17.660
and it's a context on which to run,
a single-threaded context.

00:21:17.690 --> 00:21:20.980
The event sources are the ways
that you get into that context,

00:21:20.980 --> 00:21:22.720
the way that you acquire that lock.

00:21:22.760 --> 00:21:25.080
And so we have some
built into the system.

00:21:25.080 --> 00:21:28.420
We have an interrupt event source,
timer event source.

00:21:28.430 --> 00:21:31.260
We have an event source that allows
you to receive commands coming

00:21:31.260 --> 00:21:34.500
in from outside of your context.

00:21:34.530 --> 00:21:37.020
And you can also create
custom event sources.

00:21:37.040 --> 00:21:40.720
You can, if you needed to have some
kind of a special queue,

00:21:40.740 --> 00:21:43.520
or you wanted to have some
special IPC event source,

00:21:43.530 --> 00:21:46.000
or maybe you have drivers
that are cooperating,

00:21:46.020 --> 00:21:47.740
you can invent your own event sources.

00:21:47.740 --> 00:21:50.020
It's a class that's available to you.

00:21:50.300 --> 00:21:52.160
And they're relatively straightforward.

00:21:52.160 --> 00:21:55.720
You basically have a service routine
that you wire up to each one of these.

00:21:55.760 --> 00:21:59.320
And whenever the timer fires
or the interrupt comes in,

00:21:59.340 --> 00:22:02.320
your service routine is called
in the work loop context,

00:22:02.320 --> 00:22:05.080
and that's guaranteed to be serialized.

00:22:08.720 --> 00:22:11.540
Okay, so next on the agenda today,
we'll talk about the memory

00:22:11.540 --> 00:22:12.440
classes a little bit.

00:22:12.480 --> 00:22:16.600
There's a lot to learn here,
and depending on what your driver

00:22:16.600 --> 00:22:20.960
is going to be doing with memory,
I can't really go into all the details

00:22:20.960 --> 00:22:23.550
because there's simply too many
for an overview session like this,

00:22:23.590 --> 00:22:25.720
but there's some good
documentation out there.

00:22:25.720 --> 00:22:28.640
This is an area that has
changed with Snow Leopard.

00:22:28.640 --> 00:22:32.300
It actually changed more with
the introduction of Intel,

00:22:32.300 --> 00:22:36.090
but we're continuing as
machines get bigger and have

00:22:36.260 --> 00:22:40.160
more complex memory models,
to have to evolve these.

00:22:40.160 --> 00:22:44.650
So memory descriptor is sort of the
basic way that we describe memory.

00:22:44.660 --> 00:22:46.050
Now, what do I mean by that?

00:22:48.900 --> 00:22:52.400
Think about having a user process that
wants to do I/O down into the kernel.

00:22:52.470 --> 00:22:55.390
It has some memory buffer
that it's going to write.

00:22:55.510 --> 00:22:59.040
So it calls into the kernel with
this pointer to this memory.

00:22:59.110 --> 00:23:02.620
Well, that's some memory that's
mapped in a user's process.

00:23:03.210 --> 00:23:05.800
We need to be able to describe
that memory so that kernel

00:23:06.080 --> 00:23:07.690
drivers can work on it.

00:23:07.810 --> 00:23:09.940
So we create a memory
descriptor and we say,

00:23:10.080 --> 00:23:12.810
the memory at this
address in this process.

00:23:12.980 --> 00:23:15.220
And that gets kind of wrapped
up in a memory descriptor.

00:23:15.370 --> 00:23:18.990
So the memory descriptor doesn't
actually allocate memory,

00:23:19.080 --> 00:23:20.500
it just describes it.

00:23:21.160 --> 00:23:23.870
Now, what's interesting is as this
memory descriptor gets passed

00:23:23.890 --> 00:23:25.940
around through the kernel,
different mappings and other

00:23:25.940 --> 00:23:26.960
things can happen to it.

00:23:26.960 --> 00:23:28.090
It can be wired.

00:23:28.260 --> 00:23:29.920
It can be mapped into
other address spaces.

00:23:30.140 --> 00:23:32.540
The memory descriptor keeps
track of that for you,

00:23:32.610 --> 00:23:36.300
so you don't have to worry
about repeating operations

00:23:36.430 --> 00:23:37.460
that have already been done.

00:23:37.510 --> 00:23:41.960
Memory descriptor kind of
caches that information.

00:23:43.820 --> 00:23:45.940
Now we do have, I said before,
a memory descriptor

00:23:45.950 --> 00:23:46.880
doesn't allocate memory.

00:23:47.100 --> 00:23:48.180
We do have a helper for this.

00:23:48.230 --> 00:23:49.860
We have this buffer memory descriptor.

00:23:49.880 --> 00:23:53.700
And sometimes you do need to allocate
a buffer to send down to a device.

00:23:53.700 --> 00:23:55.700
Let's say you actually need
to create a command buffer.

00:23:55.700 --> 00:23:59.630
You need to issue a command where the
data is not coming from user-space.

00:23:59.720 --> 00:24:01.700
You create a buffer memory descriptor.

00:24:01.700 --> 00:24:04.700
It allocates wired kernel memory with it.

00:24:04.700 --> 00:24:06.530
You fill in that memory
however you need to.

00:24:06.840 --> 00:24:09.210
And then you can pass it along
to lower layers of the system

00:24:09.210 --> 00:24:10.680
like any other memory descriptor.

00:24:10.700 --> 00:24:13.710
It can do DMA on it and so forth.

00:24:15.390 --> 00:24:17.680
So DMA.

00:24:18.000 --> 00:24:22.390
If Memory Descriptor describes memory,
then I/O DMA Command is the class

00:24:22.490 --> 00:24:24.120
that allows you to access that memory.

00:24:24.190 --> 00:24:26.790
In particular,
it's there to help you get physical

00:24:26.790 --> 00:24:31.870
addresses that you can pass down to
your DMA controllers on your hardware.

00:24:32.090 --> 00:24:34.320
So basically it will generate
a physical address list,

00:24:34.320 --> 00:24:38.110
and it will do as much or as
little work as necessary to that

00:24:38.120 --> 00:24:39.890
memory to get it ready for you.

00:24:40.060 --> 00:24:43.610
So on systems that require it,
it might actually even copy the memory

00:24:43.610 --> 00:24:44.990
into a low memory buffer for you.

00:24:45.000 --> 00:24:48.000
It will wire the memory
if it's not already wired.

00:24:48.000 --> 00:24:49.970
It will do whatever is necessary
to get it prepared for you.

00:24:50.000 --> 00:24:52.000
If it was already
prepared by somebody else,

00:24:52.000 --> 00:24:54.000
then that can be very quick.

00:24:55.520 --> 00:24:59.020
Any driver that has to actually get
to the physical memory or if you just

00:24:59.020 --> 00:25:02.640
want to read bytes out of the memory,
maybe you need to sniff a few bytes

00:25:02.640 --> 00:25:06.900
to see what the buffer looks like,
you'd use DMA command for that as well.

00:25:07.070 --> 00:25:10.490
Now this class supersedes an older
class called I/O Memory Cursor.

00:25:10.860 --> 00:25:13.900
Memory Cursor is still
available in Snow Leopard.

00:25:13.900 --> 00:25:16.960
However,
it has some architectural limits that

00:25:16.960 --> 00:25:19.400
kind of bind it to the 32-bit world.

00:25:19.400 --> 00:25:23.440
So we recommend very strongly that
you port all of your code off of

00:25:23.440 --> 00:25:27.060
Memory Cursor and we recommend
that you not use Memory Cursor

00:25:27.060 --> 00:25:28.100
for any new code at all.

00:25:28.100 --> 00:25:30.590
Just go straight to DMA command.

00:25:33.100 --> 00:25:36.440
So as I said, some changes were necessary
to support 64-bit memory.

00:25:36.570 --> 00:25:38.750
It was really more for
user processes than kernel,

00:25:38.750 --> 00:25:43.400
but these classes, Memory Descriptor,
Buffer Memory Descriptor,

00:25:43.400 --> 00:25:45.900
and DMA Commander are affected by this.

00:25:45.900 --> 00:25:50.600
And drivers may need to make changes
when you're porting to x86/64

00:25:50.600 --> 00:25:52.400
with respect to these classes.

00:25:52.450 --> 00:25:55.010
Obviously,
you'll have to change all your pointer

00:25:55.010 --> 00:25:58.300
math and make sure it's 64-bit clean.

00:25:58.340 --> 00:26:00.890
Now drivers that actually
subclass I/O Memory Descriptor.

00:26:00.900 --> 00:26:03.300
This is a practice we
strongly discourage.

00:26:03.350 --> 00:26:05.800
We know that some
developers have done it,

00:26:05.810 --> 00:26:10.270
and we don't prevent it,
but we will absolutely,

00:26:10.270 --> 00:26:12.800
with Snow Leopard,
have to update your subclasses of

00:26:12.800 --> 00:26:16.200
I/O Memory Descriptor if you have any.

00:26:16.380 --> 00:26:19.430
So the Snow Leopard Developer Seed
actually has some release notes

00:26:19.430 --> 00:26:23.320
on there that give you the
correlation between what API you

00:26:23.320 --> 00:26:25.190
were using and what you need to use.

00:26:25.280 --> 00:26:27.860
So have a look at those if you're
using any of these classes.

00:26:30.210 --> 00:26:34.100
We also have some helper classes here:
I/O Command, I/O Command Pool.

00:26:34.100 --> 00:26:39.470
These are really used for putting
together buffers of commands that you

00:26:39.470 --> 00:26:41.720
will want to send down to your driver,
and rather than having to

00:26:41.740 --> 00:26:45.100
allocate them and free them a lot,
which fragments kernel memory,

00:26:45.100 --> 00:26:47.890
you can store them on a
command pool and reuse them.

00:26:52.640 --> 00:26:55.000
So IPC classes, I call it IPC.

00:26:55.000 --> 00:26:59.440
It's really Kernel to
Other Process Communication.

00:26:59.460 --> 00:27:03.360
And we have a large
variety of ways to do this.

00:27:03.380 --> 00:27:07.780
And the details really determine which
method you're going to want to use.

00:27:07.830 --> 00:27:10.320
So I'm going to go through them very
quickly and just kind of give you a

00:27:10.320 --> 00:27:16.750
heads up on which each one is strong
and what the strengths are of each one.

00:27:17.010 --> 00:27:23.420
So the simplest but also the lowest
bandwidth one here is I/O Registry Entry.

00:27:24.800 --> 00:27:29.180
We'll see a lot more about
the registry later on,

00:27:29.320 --> 00:27:36.520
but the registry entry class contains
properties that each driver can publish,

00:27:37.000 --> 00:27:41.440
but it also allows a user
process to locate the registry

00:27:41.440 --> 00:27:46.020
entry object and set properties
which the driver can then trap.

00:27:46.270 --> 00:27:50.000
It's actually very similar in
concept to the way I/O controls work,

00:27:50.000 --> 00:27:54.000
except instead of finding the
thing by a device name in /dev,

00:27:54.060 --> 00:27:56.360
you actually use the I/O Kit framework
to look up the registry

00:27:56.590 --> 00:28:00.430
object you're interested in,
and then you can do some I/O to it.

00:28:00.680 --> 00:28:02.370
It's, as I said,
it's fairly low bandwidth.

00:28:02.450 --> 00:28:03.790
It uses strings.

00:28:03.930 --> 00:28:06.990
Everything gets serialized into
XML across the user-kernel boundary,

00:28:07.010 --> 00:28:09.990
so don't do this for video capture,
for instance.

00:28:10.070 --> 00:28:12.260
But it's great if you just
want to set a property.

00:28:12.370 --> 00:28:14.940
You need to, you know,
set a buffer size or you need to set

00:28:15.070 --> 00:28:16.920
a baud rate or something like that.

00:28:17.100 --> 00:28:18.900
It's perfect for that.

00:28:21.180 --> 00:28:23.090
We also have a couple
simple queue mechanisms,

00:28:23.110 --> 00:28:25.390
I/O Data Queue and I/O Shared Data Queue.

00:28:25.400 --> 00:28:29.590
This is just a simple way of
setting up a bucket brigade of

00:28:29.680 --> 00:28:32.680
bytes between user and kernel.

00:28:34.870 --> 00:28:37.360
I/O Stream is a relatively new class.

00:28:37.440 --> 00:28:38.800
We added it with Leopard.

00:28:38.940 --> 00:28:44.760
It hasn't been widely adopted yet,
but I expect to see more uses of it soon.

00:28:44.990 --> 00:28:47.900
And basically,
it's a few classes that all work together

00:28:47.920 --> 00:28:52.650
to create a high bandwidth shared
memory interface between the kernel,

00:28:52.730 --> 00:28:55.770
a particular driver,
and a user-space process.

00:28:55.800 --> 00:28:57.800
And it's really intended
for doing video frames.

00:28:57.800 --> 00:29:00.720
That was its reason to
come into existence.

00:29:00.840 --> 00:29:03.780
But anything that uses
sort of fixed-size,

00:29:03.890 --> 00:29:08.650
large-ish buffers that you want to have
use a shared memory model to communicate

00:29:08.770 --> 00:29:13.800
up to user-space or down from user-space,
I/O Stream is a good place to look.

00:29:13.800 --> 00:29:17.560
It's a lockless, single producer,
single consumer,

00:29:17.560 --> 00:29:19.800
and each I/O Stream is one way.

00:29:19.800 --> 00:29:22.800
Now, if you need to do bidirectional,
you just create two I/O Streams.

00:29:22.800 --> 00:29:24.800
There's nothing wrong with that.

00:29:24.800 --> 00:29:29.000
And as I said,
it was introduced in Leopard, so.

00:29:31.030 --> 00:29:34.990
Now, the primary mechanism for doing
user-to-kernel communication

00:29:35.110 --> 00:29:39.090
in I/O Kit is this thing
called I/O User Client.

00:29:39.290 --> 00:29:45.100
I/O User-Client objects are kernel-side
objects that represent user-side clients.

00:29:45.280 --> 00:29:47.100
That's where the name
"user-client" comes in.

00:29:47.100 --> 00:29:51.100
It's kind of a confusing naming at first,
but when you think about it,

00:29:51.420 --> 00:29:56.000
Kernel objects expect
to have kernel clients.

00:29:56.040 --> 00:29:58.860
If you've got something in the kernel,
if ending a service,

00:29:58.860 --> 00:30:02.380
it generally will expect the client
of that service to be in the kernel.

00:30:02.400 --> 00:30:04.390
A user client lives in the kernel.

00:30:04.400 --> 00:30:06.400
I/O user client object
lives in the kernel,

00:30:06.480 --> 00:30:13.400
but it handles the bridging of that data,
those KPIs, out into user-spaces APIs.

00:30:13.520 --> 00:30:16.390
They're called into existence at
the request of a user process.

00:30:16.470 --> 00:30:20.400
A user process locates the driver
it's interested in talking to,

00:30:20.400 --> 00:30:24.400
and if a user client object
is available for that class,

00:30:24.400 --> 00:30:26.120
it can say,
"I would like to create one of

00:30:26.120 --> 00:30:29.080
these." One will be created for it,
and that will be its conduit

00:30:29.090 --> 00:30:33.400
then for getting information
into and out of the kernel.

00:30:33.770 --> 00:30:37.360
So the neat thing about it is the
driver doesn't really care that

00:30:37.420 --> 00:30:38.940
it's a user client on top of it.

00:30:38.950 --> 00:30:42.390
The driver just knows that there's
some in-kernel client talking to it.

00:30:42.400 --> 00:30:44.890
It could be another in-kernel driver,
it could be a user client.

00:30:45.040 --> 00:30:48.480
It's a nice, clean abstraction.

00:30:51.140 --> 00:30:53.960
So this brings us to I/O Service.

00:30:54.010 --> 00:30:56.960
I/O Service is the
central class of I/O Kit.

00:30:56.970 --> 00:31:00.070
It is where the bulk of our
implementation is for our core APIs,

00:31:00.300 --> 00:31:04.550
core KPIs,
and it is also the root class that

00:31:04.770 --> 00:31:07.830
all device drivers inherit from.

00:31:09.290 --> 00:31:14.120
So things like driver lifecycle,
driver matching, creating the driver,

00:31:14.120 --> 00:31:18.920
initializing it, tearing it down,
all those things are managed through

00:31:18.920 --> 00:31:21.300
code and KPIs and I/O service.

00:31:21.390 --> 00:31:25.290
Power management, access control,
and discovery,

00:31:25.310 --> 00:31:29.140
having somebody discover your driver
or you discover some other driver,

00:31:29.200 --> 00:31:31.590
all happens through I/O service.

00:31:33.570 --> 00:31:36.830
So I'm going to talk a little
bit about power management.

00:31:36.920 --> 00:31:40.590
A device driver in its most basic
form does no power management.

00:31:40.630 --> 00:31:43.500
We recommend that you do a little bit.

00:31:43.500 --> 00:31:47.310
Devices nowadays are certainly more
and more constrained by battery size

00:31:47.410 --> 00:31:49.290
and how much heat they can dissipate.

00:31:49.500 --> 00:31:54.500
So keeping your devices in their lowest
power state is good for your customers.

00:31:54.500 --> 00:31:58.500
And so the most basic driver
would have two power states.

00:31:58.500 --> 00:32:01.500
Obviously,
you can have an intermediate power state.

00:32:01.500 --> 00:32:04.500
So you can have a power state that's
actually a disk drive where the

00:32:04.840 --> 00:32:06.500
green on state is active and spun up.

00:32:06.500 --> 00:32:10.500
The yellow state might actually
be in standby but spun down,

00:32:10.500 --> 00:32:12.490
and then off would be
completely powered down.

00:32:12.500 --> 00:32:15.510
And you can have as many states
as you want as long as you

00:32:15.710 --> 00:32:19.230
can actually have some useful
distinction between those states.

00:32:19.570 --> 00:32:23.140
Our power manager will allow you to
handle as many states as you want,

00:32:23.140 --> 00:32:26.490
though that may be limited by
the family that you're using.

00:32:26.500 --> 00:32:29.500
So go and look at your
family documentation.

00:32:29.500 --> 00:32:32.390
If it's going to constrain you
to a specific number of states,

00:32:32.390 --> 00:32:34.500
then you'll have to follow those rules.

00:32:34.500 --> 00:32:38.500
But a generic device driver can
create any number of states.

00:32:39.980 --> 00:32:44.260
So how do you go about becoming
a power-managed driver?

00:32:44.300 --> 00:32:47.400
So the first thing is you have to
define that array of power states,

00:32:47.400 --> 00:32:52.600
and you describe them in order
as to what they're going to be.

00:32:52.660 --> 00:32:53.650
It's a simple array.

00:32:53.660 --> 00:32:58.200
It's handed off, I believe,
to PMInit or JoinPMtree.

00:32:58.200 --> 00:33:00.730
I have to look at the
documentation to know for sure.

00:33:00.750 --> 00:33:02.350
But you have to implement one method.

00:33:02.360 --> 00:33:04.100
You implement setPowerState.

00:33:04.120 --> 00:33:07.330
And then in your inner start routines,
you're going to call these

00:33:07.460 --> 00:33:11.320
three methods in sequence.

00:33:11.460 --> 00:33:14.240
And after you've done that,
your set power state routine is going

00:33:14.240 --> 00:33:18.100
to be called any time the system
wants you to change power states.

00:33:18.220 --> 00:33:19.370
It's very simple.

00:33:19.480 --> 00:33:23.560
The power manager automatically
looks at your children and

00:33:23.560 --> 00:33:24.800
manages their power state.

00:33:24.900 --> 00:33:30.420
If they depend on you for power,
they'll be powered-- the ordering

00:33:30.420 --> 00:33:33.900
is guaranteed so that everybody's
powered in the correct sequence,

00:33:33.950 --> 00:33:37.030
so that anybody who's dependent
on another node for power will be

00:33:37.030 --> 00:33:40.190
powered up after the dependent node.

00:33:44.510 --> 00:33:45.430
So the I/O Registry.

00:33:45.620 --> 00:33:46.710
What is the I/O Registry?

00:33:46.910 --> 00:33:49.960
It is nothing at all like
the Windows Registry.

00:33:50.510 --> 00:33:54.500
Windows Registry is a persistent
collection of data that lives on disk.

00:33:54.590 --> 00:33:56.280
I/O Registry is not.

00:33:56.420 --> 00:34:00.390
It is a dynamic network of
objects that live in the kernel.

00:34:00.470 --> 00:34:01.390
It's not ever stored.

00:34:01.400 --> 00:34:02.400
It's not written out.

00:34:02.400 --> 00:34:05.000
You can do a static dump
of it to look at it,

00:34:05.080 --> 00:34:07.740
but it is a live running
structure and it's recreated

00:34:07.740 --> 00:34:08.920
every time the system boots.

00:34:09.000 --> 00:34:12.540
There's no store.

00:34:13.770 --> 00:34:15.450
So we have these objects.

00:34:15.450 --> 00:34:17.030
The term "nub" may be new to you.

00:34:17.210 --> 00:34:19.200
You'll hear it a lot in I/O Kit.

00:34:19.260 --> 00:34:22.080
So we have driver
objects and we have nubs.

00:34:22.300 --> 00:34:41.600
[Transcript missing]

00:34:43.990 --> 00:34:47.630
So if you just look at a pair of
objects and their relationship,

00:34:47.750 --> 00:34:50.050
the relationships are directional.

00:34:50.120 --> 00:34:55.800
So in this case, we have a driver object
that is a client of a nub.

00:34:55.850 --> 00:34:58.870
The nub is a provider to that driver.

00:34:58.990 --> 00:35:02.130
So it's the client-provider relationship.

00:35:06.840 --> 00:35:10.610
So additionally,
beyond just these being live objects,

00:35:10.610 --> 00:35:13.490
they also have connected
to them a collection of

00:35:13.490 --> 00:35:15.570
strings and other properties.

00:35:15.690 --> 00:35:18.710
And these are handy for
discovering the objects.

00:35:18.890 --> 00:35:20.180
They're handy for controlling.

00:35:20.300 --> 00:35:22.040
If you recall earlier,
I said you could set

00:35:22.040 --> 00:35:23.200
properties on the driver.

00:35:23.200 --> 00:35:25.390
It was an I/O control-like operation.

00:35:25.480 --> 00:35:27.750
Well, this is what I'm talking about.

00:35:30.980 --> 00:35:33.860
So to further define nubs, what is a nub?

00:35:33.890 --> 00:35:35.550
Well, it is an I/O service subclass.

00:35:35.710 --> 00:35:38.890
Everything in the
registry pretty much is.

00:35:39.480 --> 00:35:41.360
They're considered interface objects.

00:35:41.550 --> 00:35:45.700
Probably the closest thing to think of
it is like a /dev node that lives inside

00:35:45.710 --> 00:35:47.910
the kernel for other kernel drivers.

00:35:48.180 --> 00:35:49.680
It is the unit of access.

00:35:49.930 --> 00:35:52.470
You find services by looking for nubs.

00:35:52.620 --> 00:35:53.840
You acquire the nub.

00:35:53.910 --> 00:35:55.000
You then talk to the nub.

00:35:55.110 --> 00:35:57.200
When you're done, you close the nub.

00:35:57.250 --> 00:36:01.080
They generally tend to be
fairly thin pieces of code that

00:36:01.080 --> 00:36:05.000
mostly just handle the vetting
of clients and pass the request

00:36:05.000 --> 00:36:06.700
straight on through to the driver.

00:36:06.740 --> 00:36:09.700
One driver can publish as
many nubs as it wants to.

00:36:09.700 --> 00:36:11.950
Many drivers just publish a single nub.

00:36:12.140 --> 00:36:14.140
Some publish dozens.

00:36:14.240 --> 00:36:17.300
But they tend to not have device-specific
implementation details in them.

00:36:17.300 --> 00:36:22.460
They tend to be pretty straightforward
conduits down to the driver.

00:36:23.040 --> 00:36:25.180
The driver, on the other hand,
is kind of the opposite.

00:36:25.280 --> 00:36:26.400
It's more downward-focused.

00:36:26.400 --> 00:36:28.090
It's not thinking about clients.

00:36:28.210 --> 00:36:29.900
It's thinking about its hardware.

00:36:30.060 --> 00:36:33.000
So it's also an I/O service subclass.

00:36:33.150 --> 00:36:34.870
They're loaded via matching.

00:36:35.150 --> 00:36:37.000
They're the thing that gets
matched into the system,

00:36:37.000 --> 00:36:40.480
and this is the piece of code
you're going to be writing.

00:36:40.600 --> 00:36:44.200
And that's where all the
device-specific implementation is.

00:36:44.360 --> 00:36:49.090
So you'll see this kind of hierarchy
of nubs and drivers throughout I/O Kit.

00:36:49.450 --> 00:36:52.590
It's a very common
pattern that you'll see.

00:36:55.000 --> 00:36:56.390
So how does the registry grow?

00:36:56.600 --> 00:37:00.150
As I told you earlier,
we start with a single nub that

00:37:00.210 --> 00:37:02.360
represents the entire platform.

00:37:02.420 --> 00:37:06.270
And nubs have one responsibility
when they're first created.

00:37:06.280 --> 00:37:08.840
When they're registered,
their responsibility is to go

00:37:08.840 --> 00:37:11.600
out and actively seek a client.

00:37:11.670 --> 00:37:12.960
It's kind of an interesting model.

00:37:13.040 --> 00:37:16.000
They actually ask the system, well,
tell me what drivers are available.

00:37:16.270 --> 00:37:18.950
They then go through and look at
all of the properties of those

00:37:18.950 --> 00:37:23.340
drivers and figure out which driver
is the best driver to drive them.

00:37:23.480 --> 00:37:25.810
and they match that in.

00:37:26.000 --> 00:37:28.030
So in our case,
if we're talking about the root nub,

00:37:28.030 --> 00:37:30.700
it's going to need a platform expert,
a platform driver.

00:37:30.710 --> 00:37:36.070
That, you can kind of think of it
as a main system board driver.

00:37:36.610 --> 00:37:40.700
Well, that's going to publish nubs for
each piece of silicon on there.

00:37:40.700 --> 00:37:44.240
Obviously more than two,
but slides only so big.

00:37:45.200 --> 00:37:47.900
And those nubs do what
they're supposed to do.

00:37:47.900 --> 00:37:50.600
They go off and look for
drivers to drive them.

00:37:50.770 --> 00:37:54.690
And they're going to match
in the suitable driver.

00:37:55.180 --> 00:38:00.210
And this process continues until
the whole registry is built up.

00:38:01.410 --> 00:38:03.030
There's a very important point, though.

00:38:03.190 --> 00:38:05.600
We never consider matching done.

00:38:05.700 --> 00:38:06.800
We don't have a steady state.

00:38:06.800 --> 00:38:09.300
We don't say, "Okay,
we're done with matching," and we stop.

00:38:09.300 --> 00:38:13.190
Nubs--just creating a nub and
registering it causes the matching

00:38:13.290 --> 00:38:14.800
process for that nub to occur.

00:38:14.940 --> 00:38:17.560
So this is how hot
swap works on MacÂ OSÂ X.

00:38:17.560 --> 00:38:19.580
The system's been up
and running for days.

00:38:19.610 --> 00:38:21.290
You plug in a USB device.

00:38:21.420 --> 00:38:24.970
The USB driver notices it
and publishes a new nub.

00:38:27.400 --> 00:38:29.200
So how does it-- what
drives the matching?

00:38:29.290 --> 00:38:31.320
How does it pick the best driver?

00:38:31.410 --> 00:38:34.120
Well,
the details are very family-specific,

00:38:34.180 --> 00:38:37.400
but they all follow a
fairly basic pattern.

00:38:37.450 --> 00:38:40.190
In the property list,
which is a file in the

00:38:40.220 --> 00:38:43.610
CFBundle that is your text--

00:38:43.870 --> 00:38:45.470
There's some properties in there.

00:38:45.490 --> 00:38:48.070
We have something called
I/O Kit Personalities.

00:38:48.090 --> 00:38:51.290
A personality is a unit of matching.

00:38:51.290 --> 00:38:56.440
It's basically a dictionary that says,
"I can match on these kinds of things."

00:38:56.700 --> 00:38:59.700
So here's one matching dictionary.

00:38:59.700 --> 00:39:01.700
One driver can have multiple
matching dictionaries,

00:39:01.700 --> 00:39:02.690
multiple personalities.

00:39:02.700 --> 00:39:07.630
Maybe the same driver could load
against several different USB devices

00:39:07.700 --> 00:39:11.690
or several different PCI devices,
and they can be matched in

00:39:11.700 --> 00:39:13.590
as separate personalities.

00:39:13.700 --> 00:39:16.590
But let's just look at one for now.

00:39:17.050 --> 00:39:20.560
So this is the chunk of properties
that are necessary to match,

00:39:20.560 --> 00:39:24.570
and this particular
example is a PCI KEXT.

00:39:24.740 --> 00:39:26.690
Doesn't really matter.

00:39:26.900 --> 00:39:30.610
The first thing,
and this is common to all families,

00:39:30.660 --> 00:39:31.810
is we have I/O Class.

00:39:32.030 --> 00:39:34.560
This specifies the name
of the class to create.

00:39:34.620 --> 00:39:37.230
This is sort of the, "Okay,
you've loaded my driver.

00:39:37.340 --> 00:39:41.500
Now what do you do?" It has to
instantiate one of these objects,

00:39:41.500 --> 00:39:45.870
and this is the actual driver
object that gets attached to a nub.

00:39:46.700 --> 00:39:52.280
The Provider Class, this is you,
your driver, declaring what nubs it can

00:39:52.290 --> 00:39:54.490
successfully attach to.

00:39:54.620 --> 00:39:57.900
Obviously, you don't want a PCI driver
trying to talk to a SCSI nub.

00:39:57.900 --> 00:40:00.740
That would not be recipe for success.

00:40:00.880 --> 00:40:06.820
So the Provider Class here
tells the system what nub class

00:40:06.820 --> 00:40:06.820
it can successfully talk to.

00:40:08.610 --> 00:40:11.620
So in this particular case,
we've got something called

00:40:11.620 --> 00:40:15.640
I/O PCI Class Match that's
relevant to this example.

00:40:15.750 --> 00:40:18.410
But PCI offers two or
three different matching.

00:40:18.500 --> 00:40:22.300
You can match on class,
you can match on vendor ID, device ID,

00:40:22.480 --> 00:40:24.300
and some other stuff as well.

00:40:24.370 --> 00:40:26.900
But every family is going to
have its own matching details.

00:40:27.140 --> 00:40:30.240
USB, for example,
follows the USB specification

00:40:30.240 --> 00:40:32.500
for some of its matching details.

00:40:32.640 --> 00:40:36.590
So you're going to have to look
to your family documentation

00:40:36.590 --> 00:40:36.590
to get details there.

00:40:37.390 --> 00:40:40.140
Probescore is a generic I/O Kit concept.

00:40:40.140 --> 00:40:42.630
Most families support this, not all do.

00:40:42.790 --> 00:40:46.140
But if there's a tie,
if all of the other properties come

00:40:46.140 --> 00:40:49.840
down and at the end you've got a--

00:40:50.250 --> 00:40:53.800
More than one driver identified,
we sort them in probe score order

00:40:53.800 --> 00:40:57.140
to decide which one to load first,
give it a first crack at it,

00:40:57.140 --> 00:41:00.560
and if it fails, then we'll go down to
the next one and so on.

00:41:04.800 --> 00:41:09.110
So now I want to shift gears a little
bit and give you some graphics to see how

00:41:09.110 --> 00:41:11.700
that user-client connection looks like.

00:41:11.700 --> 00:41:15.680
I described it earlier in text,
and now we're going to see it in pixels.

00:41:15.770 --> 00:41:18.130
So this is sort of the setup.

00:41:18.280 --> 00:41:21.670
You've got a nub that represents
a service that's of interest

00:41:21.710 --> 00:41:24.700
to a user-space application,
the gray bar at the top.

00:41:24.700 --> 00:41:27.660
So it's going to use the
I/O Kit framework to locate

00:41:27.660 --> 00:41:30.690
that nub by its properties.

00:41:30.700 --> 00:41:32.690
It's going to match it,
and it may just say,

00:41:32.690 --> 00:41:35.190
"Give me all the instances
of this class." It may give

00:41:35.200 --> 00:41:36.700
it something more specific.

00:41:36.700 --> 00:41:39.700
We have a fairly rich matching language.

00:41:39.700 --> 00:41:44.700
So once it's found it, it says, "Oh,
please conjure me a user-client."

00:41:44.880 --> 00:41:47.530
And the user-client object
gets created in the kernel.

00:41:47.730 --> 00:41:49.700
And you notice it even has properties.

00:41:49.700 --> 00:41:51.700
It's just another in-kernel driver.

00:41:51.700 --> 00:41:56.550
There's also a user-space plug-in piece,
a library that your application can load.

00:41:56.700 --> 00:42:00.180
And those two pieces,
the user-client in the kernel and the

00:42:00.180 --> 00:42:06.700
plug-in in user-space talk to each other
and then that service out to user-space.

00:42:12.390 --> 00:42:14.100
So let's talk a little
bit about families.

00:42:14.190 --> 00:42:18.510
A device driver or device is really
an intersection of two technologies.

00:42:18.670 --> 00:42:20.180
Devices are bridges.

00:42:20.330 --> 00:42:21.790
You've got a USB serial adapter.

00:42:21.800 --> 00:42:24.030
You've got a PCI Ethernet adapter.

00:42:24.320 --> 00:42:26.500
You've got, you know,

00:42:27.400 --> 00:42:28.470
FireWire hard disk drive.

00:42:28.580 --> 00:42:31.620
They're all bridging from
one technology to another.

00:42:31.690 --> 00:42:35.350
And so,
let's talk about the naming and how that

00:42:35.380 --> 00:42:37.920
fits into the I/O Kit scheme of families.

00:42:38.250 --> 00:42:42.480
So devices can be described either
by their method of attachment

00:42:42.800 --> 00:42:44.410
or by the service they provide.

00:42:44.570 --> 00:42:46.720
And in I/O Kit,
we generally name them based

00:42:46.720 --> 00:42:48.100
on the service they provide.

00:42:48.100 --> 00:42:54.100
So for a PCI Express, for example,
the attachment method is PCI.

00:42:54.100 --> 00:42:56.100
For a USB HID device,
the attachment is USB.

00:42:56.100 --> 00:43:02.400
So the orange highlights there show
how the attachment point specifies the

00:43:02.490 --> 00:43:05.910
family that you use as your provider nub.

00:43:06.100 --> 00:43:13.100
So the provider nub for a PCI device
is going to come out of the PCI family.

00:43:13.100 --> 00:43:18.290
The provider nub for a USB device is
going to come out of the USB family.

00:43:18.960 --> 00:43:21.500
This is the family that
controls matching you in.

00:43:21.660 --> 00:43:24.400
So if you're writing
a PCI Ethernet driver,

00:43:24.570 --> 00:43:28.900
it's the PCI family that manages the
matching process of bringing you in.

00:43:29.420 --> 00:43:32.870
However, your driver is not a PCI driver.

00:43:32.900 --> 00:43:34.300
It's an Ethernet driver.

00:43:34.420 --> 00:43:39.900
It is named based on the service
that it provides to the system,

00:43:39.900 --> 00:43:42.900
and the family that you're going
to actually wind up subclassing

00:43:42.900 --> 00:43:47.390
out of is the family that is
described by your service.

00:43:47.680 --> 00:43:52.270
So PCI Ethernet driver,
the provider class is PCI.

00:43:52.540 --> 00:43:55.390
You're matched in by PCI,
but your service class,

00:43:55.490 --> 00:43:57.400
the actual thing you're
going to subclass from,

00:43:57.440 --> 00:43:59.400
is in the networking family.

00:43:59.890 --> 00:44:00.910
So keep that in mind.

00:44:00.920 --> 00:44:05.620
You're always subclassing from a family
that describes the service you provide.

00:44:07.990 --> 00:44:11.140
So the families, as I said earlier,
they provide the protocol

00:44:11.240 --> 00:44:14.440
specifics for USB or FireWire,
whatever.

00:44:14.490 --> 00:44:17.020
And they provide all the basic classes.

00:44:17.080 --> 00:44:18.450
So they provide the nub glasses.

00:44:18.480 --> 00:44:20.670
This is very important,
because that's sort of

00:44:20.690 --> 00:44:21.810
the unit of abstraction.

00:44:21.870 --> 00:44:26.320
So all USB devices look the
same at some basic level.

00:44:26.320 --> 00:44:29.720
So you can discover them and
talk to them at a basic level.

00:44:29.800 --> 00:44:31.510
They also provide the
driver superclasses,

00:44:31.510 --> 00:44:34.700
the thing that you're going to extend
when you go to write your driver.

00:44:34.700 --> 00:44:38.700
And where appropriate,
they provide I/O user client classes.

00:44:38.700 --> 00:44:43.230
And they may also provide other helper
classes that are useful for managing

00:44:43.230 --> 00:44:45.690
data in the realm of that technology.

00:44:46.890 --> 00:44:49.620
Now the families, of course,
they extend I/O Kit behaviors,

00:44:49.710 --> 00:44:52.030
but they can also replace
them or override them.

00:44:52.140 --> 00:44:54.920
So as I mentioned earlier,
USB has some matching rules that

00:44:54.920 --> 00:44:57.800
are a little bit different than
the generic I/O Kit implementation.

00:44:57.890 --> 00:45:00.600
So you're going to have to look at
the family that you're inheriting from

00:45:00.600 --> 00:45:05.360
and the family that you're matching
on to get the details of all that.

00:45:05.360 --> 00:45:08.460
Power management is another example
where families actually extend

00:45:08.560 --> 00:45:12.460
the I/O Kit model and sometimes
force specific implementations.

00:45:12.540 --> 00:45:13.750
And also for threading and locking.

00:45:13.760 --> 00:45:16.940
Out of necessity,
the families have to know somewhat

00:45:16.940 --> 00:45:19.300
what your locking model is going to be.

00:45:19.510 --> 00:45:22.210
Now that being said,
new families can be created,

00:45:22.210 --> 00:45:23.440
and they have been.

00:45:23.560 --> 00:45:25.920
Obviously,
families can also be obsoleted over

00:45:25.920 --> 00:45:27.730
time as they become unimportant.

00:45:27.880 --> 00:45:30.830
So it's a nice way of allowing
the technology conveyor

00:45:30.950 --> 00:45:32.360
belt to keep cranking.

00:45:32.360 --> 00:45:35.720
New stuff can come in on one side,
old stuff can fall off the other side.

00:45:35.810 --> 00:45:40.570
But I/O Kit as a core technology
doesn't really get dated because

00:45:40.570 --> 00:45:42.170
it's extended by new families.

00:45:45.900 --> 00:45:48.970
So this is just a brief list,
an incomplete list of I/O Kit families

00:45:48.970 --> 00:45:52.640
to kind of give you an idea of the
granularity and how we break them down.

00:45:52.690 --> 00:45:55.210
The headers for all these families
are in the kernel framework.

00:45:55.300 --> 00:45:56.840
That's where their KPIs live.

00:45:56.880 --> 00:45:59.370
And the binaries are actually
in the kernel extensions.

00:45:59.400 --> 00:46:05.780
If you go to system library extensions,
all the I/O whatever family texts,

00:46:05.830 --> 00:46:08.200
that's the actual binary,
the runtime code that's going to

00:46:08.200 --> 00:46:13.250
be running your-- that provides the
implementation of those families.

00:46:15.400 --> 00:46:18.680
So you want to write a driver,
where do you start?

00:46:19.050 --> 00:46:22.560
The first thing to do is figure
out how you're going to attach your

00:46:22.560 --> 00:46:24.470
driver into the software stack.

00:46:24.620 --> 00:46:29.690
So run I/O Registry
Explorer app or I/O Reg.

00:46:29.790 --> 00:46:32.690
Attach your device and look for changes.

00:46:32.700 --> 00:46:35.000
Run I/O Reg again,
or if you're running Registry Explorer,

00:46:35.000 --> 00:46:37.280
you'll see a little green item.

00:46:37.390 --> 00:46:40.300
So if it's a hot-swappable device,
like a USB or FireWare device,

00:46:40.300 --> 00:46:43.630
the system will notice it appear,
and you'll be able to see where in the

00:46:43.630 --> 00:46:47.290
I/O Registry the nub is going to appear.

00:46:48.380 --> 00:46:49.460
Look at that nub.

00:46:49.580 --> 00:46:52.910
Click on it, look at those properties,
and you're going to use your

00:46:52.910 --> 00:46:55.000
family-specific documentation.

00:46:55.000 --> 00:46:58.680
You're going to look at the nub
that was created for your device,

00:46:58.880 --> 00:47:00.510
and you're going to be able to
figure out what the matching

00:47:00.680 --> 00:47:01.790
language is going to need to be.

00:47:01.930 --> 00:47:04.590
Whether you're going to be a
vendor ID match or whatever,

00:47:04.750 --> 00:47:06.920
that's where you're going to find out.

00:47:07.290 --> 00:47:10.240
If you've got more than one device that
your driver is going to need to support,

00:47:10.280 --> 00:47:14.810
repeat this process for each one and
get a list of personalities that you're

00:47:14.870 --> 00:47:17.300
going to need to build into your driver.

00:47:20.160 --> 00:47:20.950
So that's what it looks like.

00:47:21.050 --> 00:47:22.290
This is Registry Explorer.

00:47:22.480 --> 00:47:27.600
It's the projector that makes
it a little bit hard to read,

00:47:27.600 --> 00:47:31.810
but the selected blue highlight
here is actually over the new

00:47:31.970 --> 00:47:33.000
device that I had plugged in.

00:47:33.000 --> 00:47:35.700
This is actually a USB Wi-Fi dongle.

00:47:35.770 --> 00:47:38.600
And that's why the text in
the highlight bar is green.

00:47:38.600 --> 00:47:41.340
It's because it's a new
device that was plugged in.

00:47:41.380 --> 00:47:44.320
And then over here on my left,
on your right,

00:47:44.340 --> 00:47:48.360
you'll see the properties for that nub,
and there's information in there that

00:47:48.360 --> 00:47:49.790
would help you know how to match on it.

00:47:54.320 --> 00:47:55.680
All right,
so you've figured out what your

00:47:55.680 --> 00:47:56.860
provider family is going to be.

00:47:56.860 --> 00:47:59.160
You've figured out what your
matching dictionary looks like.

00:47:59.220 --> 00:48:01.040
Let's talk about selecting your family.

00:48:01.180 --> 00:48:05.490
So in the I/O Kit fundamentals,
we have an Appendix A that actually

00:48:05.490 --> 00:48:08.200
walks you through all the families
and tells you what they do.

00:48:08.280 --> 00:48:11.270
And that's, you know,
going to be your quick guide to figure

00:48:11.430 --> 00:48:16.460
out what family you need to inherit from,
what class you need to inherit from.

00:48:18.600 --> 00:48:24.070
And the family that you choose is
going to help you figure out what

00:48:24.480 --> 00:48:26.730
superclass you need to inherit from.

00:48:26.740 --> 00:48:30.580
And one of the best resources there
is the Darwin source repository.

00:48:30.580 --> 00:48:32.560
If you're not sure,
if it's not obvious just

00:48:32.560 --> 00:48:35.210
from looking at the headers,
go off and find a driver that

00:48:35.210 --> 00:48:38.560
does the same thing that the
driver you want to write will do.

00:48:38.560 --> 00:48:40.730
And that's a great place to look.

00:48:40.800 --> 00:48:42.610
Obviously,
you're going to want to do that

00:48:42.650 --> 00:48:44.400
anyway for other pieces of code.

00:48:44.590 --> 00:48:48.160
So once you've done that,
you select your base class.

00:48:48.700 --> 00:48:50.370
And...

00:48:51.430 --> 00:48:53.700
You're going to go into Xcode
and you're going to create a

00:48:53.760 --> 00:48:56.270
new I/O Kit driver project.

00:48:56.420 --> 00:49:00.700
You're going to define a new class that
extends the base class that you picked.

00:49:00.730 --> 00:49:05.490
And you're going to add personalities
into your Info.plist in your project.

00:49:05.690 --> 00:49:07.640
And you get the thing to build.

00:49:07.740 --> 00:49:09.710
Well, at that point,
you now have a shell of a driver.

00:49:09.900 --> 00:49:13.570
If you actually have it to build,
get it to build, and then you put it in

00:49:13.630 --> 00:49:16.140
the extensions folder,
when your device is attached,

00:49:16.140 --> 00:49:17.180
your driver should load.

00:49:17.180 --> 00:49:18.360
Now,
it's not going to do anything because

00:49:18.360 --> 00:49:19.900
it's a hollow shell of a driver.

00:49:20.200 --> 00:49:21.960
But you've kind of got a playground now.

00:49:21.960 --> 00:49:25.760
You've got a place where
you can put your code.

00:49:27.390 --> 00:49:28.840
That's really where
you're going to start.

00:49:28.850 --> 00:49:31.520
At that point, you've got to go look at
the family-specific details,

00:49:31.630 --> 00:49:34.420
look at your silicon or whatever
it is you're talking to,

00:49:34.630 --> 00:49:37.210
what are the things that make it unique,
and that's where you're

00:49:37.210 --> 00:49:38.180
going to be coding up.

00:49:38.180 --> 00:49:41.040
At this point,
go ahead and set up the two-machine

00:49:41.040 --> 00:49:42.940
debugger because you're going to need it.

00:49:42.940 --> 00:49:46.100
The next step is going to
be writing kernel code.

00:49:46.110 --> 00:49:48.960
If you haven't done that before,
this is your first exercise.

00:49:49.210 --> 00:49:51.640
You will be seeing the panic screen.

00:49:51.640 --> 00:49:54.910
Learn to love two-machine debugging.

00:49:54.920 --> 00:49:57.250
It'll make your life a lot easier.

00:49:59.200 --> 00:50:03.110
All right, so to put this in pixels,
what I kind of just described to you,

00:50:03.110 --> 00:50:06.030
in the stack that we're
immediately concerned with,

00:50:06.030 --> 00:50:07.900
we've got three objects here.

00:50:07.900 --> 00:50:11.030
We've got--at the bottom,
we have a nub that represents the

00:50:11.030 --> 00:50:13.700
device that the system detected.

00:50:13.890 --> 00:50:17.800
In the middle, we have your driver class,
the class that you're creating,

00:50:17.880 --> 00:50:21.970
and then that is going to publish a nub
for the rest of the system to match on,

00:50:21.970 --> 00:50:23.200
depending, again, on your family.

00:50:23.330 --> 00:50:26.800
So in this particular example,
we have an Ethernet controller that's

00:50:26.800 --> 00:50:29.240
publishing an Ethernet interface nub.

00:50:29.980 --> 00:50:32.150
So out of this,
this is the code that you're

00:50:32.150 --> 00:50:33.660
going to need to write.

00:50:33.870 --> 00:50:36.990
The superclass of Ethernet
controller is provided for you.

00:50:37.000 --> 00:50:39.640
You plug in the functions you need to.

00:50:39.640 --> 00:50:42.380
And for some families,
you will also need to modify the nub.

00:50:42.390 --> 00:50:45.960
It's going to vary by family,
so you have to look at the docs on that.

00:50:49.390 --> 00:50:54.350
So, in summary, I/O Kit is the device
driver model for MacÂ OSÂ X.

00:50:54.670 --> 00:50:59.490
I/O Kit drivers run inside the kernel,
and families provide support for those

00:50:59.490 --> 00:51:02.150
drivers in protocol-specific areas.

00:51:02.630 --> 00:51:05.120
For applications,
I/O Kit is a framework that they use

00:51:05.270 --> 00:51:09.250
to locate and talk to I/O Kit drivers.

00:51:09.590 --> 00:51:15.510
And I/O Kit provides many mechanisms
for bridging the user-kernel boundary.

00:51:16.090 --> 00:51:17.190
You might not even need to do that.

00:51:17.200 --> 00:51:18.200
I should have mentioned that earlier.

00:51:18.200 --> 00:51:20.700
A lot of the families
take care of that for you,

00:51:20.700 --> 00:51:21.930
such as Ethernet.

00:51:22.090 --> 00:51:24.980
Most Ethernet drivers don't care about
bridging the user-kernel boundary

00:51:25.020 --> 00:51:30.070
'cause we have a whole BSD sockets
layer that takes care of that for you.

00:51:30.450 --> 00:51:34.620
And again, to reiterate,
I/O Kit is not part of the iPhone SDK.

00:51:37.070 --> 00:51:40.410
So if you'd like some more information,
Craig Keithley is the

00:51:40.410 --> 00:51:42.400
technology manager for I/O Kit.

00:51:42.840 --> 00:51:45.740
We have, of course, on the seed,
we have the release notes that

00:51:45.740 --> 00:51:48.200
I mentioned that have some good
information that you need to

00:51:48.200 --> 00:51:49.700
know if you're porting a driver.

00:51:49.980 --> 00:51:54.240
And in the I/O Kit Fundamentals book,
there's the section

00:51:54.600 --> 00:51:55.610
called Hardware Drivers.

00:51:55.740 --> 00:51:57.400
The URL is there.

00:51:57.450 --> 00:52:01.390
It actually has--gives you sort of a
menu of all our available documentation

00:52:01.470 --> 00:52:03.250
for I/O Kit and the families.

00:52:03.390 --> 00:52:06.600
And then there's also the open-source
project with the Darwin kernel

00:52:06.600 --> 00:52:09.990
and all of the related drivers,
it will be a tremendous resource for you.

00:52:15.310 --> 00:52:18.940
So if you have the opportunity
to watch the reruns,

00:52:18.940 --> 00:52:23.060
on Tuesday there was the
64-bit kernel session.

00:52:23.460 --> 00:52:27.190
And then later today,
we have two more sessions in this room.

00:52:27.210 --> 00:52:31.160
Right after this, we have the Maximizing
Driver Compatibility for I/O Kit Drivers.

00:52:31.160 --> 00:52:36.420
And this will be talking about how
to create one Xcode project that

00:52:36.420 --> 00:52:40.200
creates a driver to run across
multiple generations of MacÂ OSÂ X.

00:52:41.240 --> 00:52:47.580
So this is a very simple project.

00:52:47.580 --> 00:52:47.580
It works on multiple architectures,
multiple memory sizes,

00:52:47.580 --> 00:52:47.580
basically handles all the
permutations that make sense.

00:52:47.890 --> 00:52:49.690
Then right after lunch,
we have the Kernel

00:52:49.690 --> 00:52:53.270
Extension Management Session,
where we'll be learning about the details

00:52:53.370 --> 00:52:56.580
of how kernel extensions are managed,
and we'll learn about how that's

00:52:56.580 --> 00:52:58.100
changing for Snow Leopard.
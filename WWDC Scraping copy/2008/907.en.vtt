WEBVTT

00:00:20.400 --> 00:00:22.390
Hello, everyone.

00:00:22.430 --> 00:00:24.900
Good afternoon.

00:00:24.900 --> 00:00:29.610
And welcome to the new compiler
technologies on future direction session.

00:00:30.000 --> 00:00:33.960
This session is for everyone
that cares about their compiler.

00:00:33.960 --> 00:00:35.700
And everyone should care
about their compiler.

00:00:35.700 --> 00:00:37.950
And it looks like you got the
message because you came in a

00:00:37.950 --> 00:00:40.570
very large number to this session.

00:00:41.550 --> 00:00:44.290
We believe that every
developer on Mac OS X should

00:00:44.390 --> 00:00:45.460
care about their compiler.

00:00:45.490 --> 00:00:47.380
What should they care?

00:00:47.740 --> 00:00:51.580
Well, compilers do their job in
a more or less great way,

00:00:51.590 --> 00:00:54.580
depending on the configuration
they are passed and the

00:00:54.580 --> 00:00:57.060
characteristics of the system.

00:00:57.170 --> 00:01:01.260
We believe that there is no easier
way to squeeze out the last 10% of the

00:01:01.260 --> 00:01:06.540
performance of your killer applications
than by tweaking your compiler.

00:01:22.400 --> 00:01:28.090
This session is going to... Oh, okay,
I already clicked on that.

00:01:29.800 --> 00:01:32.840
Perhaps you're after
improving your performance.

00:01:32.840 --> 00:01:36.040
As Andreas talked about
in the State of the Union,

00:01:36.050 --> 00:01:39.800
perhaps you just care about the
pure speed of your execution code.

00:01:39.850 --> 00:01:46.370
Or is it more about minimizing
the memory footprint of your

00:01:46.430 --> 00:01:50.270
application on a cool new iPhone?

00:01:50.650 --> 00:01:53.500
or compilation time in your build form.

00:01:53.520 --> 00:01:58.660
Are you looking after the latest security
features that the compiler could provide?

00:01:59.620 --> 00:02:00.520
or CPU load?

00:02:00.790 --> 00:02:05.880
Do you care about load balancing the
CPU load on your multi-core architecture?

00:02:05.880 --> 00:02:10.140
With the right configuration,
you can get the most of your

00:02:10.580 --> 00:02:12.390
compiler on our platforms.

00:02:13.380 --> 00:02:15.320
It should be quite easy to achieve this.

00:02:15.640 --> 00:02:19.180
We have a few guidelines
we can help you through.

00:02:19.240 --> 00:02:20.690
And this is what this session is about.

00:02:23.710 --> 00:02:26.960
So our agenda of the day is quite simple.

00:02:27.170 --> 00:02:28.810
First,
we are going to take an unusual look at

00:02:28.810 --> 00:02:32.230
the iPhone SDK from the compiler angle.

00:02:32.440 --> 00:02:36.460
Then we will move on to
Mac OS X and the great compiler

00:02:36.460 --> 00:02:39.590
choice you have in Xcode 3.1.

00:02:39.980 --> 00:02:45.780
will go into more detail on GCC 4.2
and on the brand new LLVM compiler.

00:02:46.360 --> 00:02:50.210
For once, you'll get forward-looking
statements about our compiler

00:02:50.210 --> 00:02:56.310
strategy moving forward beyond
Xcode 3.1 and Snow Leopard.

00:02:58.400 --> 00:03:02.100
This session is shaping up
as one of the best compiler

00:03:02.100 --> 00:03:04.000
sessions we've had in a long time.

00:03:04.070 --> 00:03:06.740
We have tons to talk about.

00:03:06.950 --> 00:03:11.020
and I'm really proud to have
two excellent presenters,

00:03:11.050 --> 00:03:14.780
which also double up as
experts in their fields.

00:03:14.840 --> 00:03:17.580
Eric Christopher and Chris Lattner.

00:03:17.610 --> 00:03:20.530
But you can judge by yourself because
it's time for Eric Christopher to

00:03:20.620 --> 00:03:25.200
come up on stage now and talk
about the iPhone SDK compiler.

00:03:31.200 --> 00:03:32.200
Thanks, Francois.

00:03:32.200 --> 00:03:36.740
I'm not really sure I can quite live up
to that glowing recommendation there,

00:03:36.740 --> 00:03:40.310
but I would like to start off by
talking a little bit about iPhone

00:03:40.310 --> 00:03:42.910
OS development and really what it means.

00:03:42.980 --> 00:03:45.770
Now, whether or not you're new to
the Mac platform or whether

00:03:45.770 --> 00:03:48.510
you're a seasoned developer,
a lot of you are here trying to

00:03:48.590 --> 00:03:51.500
figure out how the compiler and
the hardware inside the iPhone

00:03:51.500 --> 00:03:53.120
is going to affect what you do.

00:03:54.220 --> 00:03:57.500
So I'd like to really start
off a little bit by talking

00:03:57.500 --> 00:04:00.540
about the iPhone internals,
the ARM processor,

00:04:00.650 --> 00:04:04.100
and how it is going to affect
the code that comes out of the

00:04:04.160 --> 00:04:06.710
compiler and what you do about that.

00:04:06.760 --> 00:04:09.860
So the processor itself is pretty simple.

00:04:09.860 --> 00:04:12.390
It's an ILP32 processor.

00:04:12.400 --> 00:04:17.090
What that means, integers, longs,
and pointers are all 32-bit.

00:04:17.100 --> 00:04:19.980
It's a little Indian, just like the x86.

00:04:20.000 --> 00:04:24.190
It's a low-power risk processor
that's heavily used in mobile devices.

00:04:24.200 --> 00:04:25.420
It's a little bit more complex
than the ARM processor,

00:04:25.420 --> 00:04:26.840
but it's a little bit more
complex than the ARM processor.

00:04:26.840 --> 00:04:30.920
And it supports two computation modes,
ARM mode and thumb mode.

00:04:30.920 --> 00:04:33.890
So, all right, well, what are those?

00:04:34.040 --> 00:04:40.360
The ARM processor mode is the larger
of the two set of instruction sets.

00:04:40.460 --> 00:04:42.660
It's a 32-bit instruction set.

00:04:42.660 --> 00:04:45.600
It has access to all 16
registers on the chip,

00:04:45.600 --> 00:04:48.820
and it has direct access to
the full instruction set.

00:04:48.880 --> 00:04:52.250
This means that you have no
penalties when trying to do

00:04:52.250 --> 00:04:54.020
anything within ARM mode.

00:04:54.100 --> 00:04:58.730
Then there's the thumb processor mode,
which has 16-bit instructions,

00:04:58.730 --> 00:05:00.840
access to only eight registers.

00:05:00.840 --> 00:05:02.900
Well, still more than x86.

00:05:02.900 --> 00:05:06.870
And it only has indirect access
to some of the instructions.

00:05:06.920 --> 00:05:11.780
So there's a little bit of an overhead
involved in doing floating-point access.

00:05:11.780 --> 00:05:16.900
One of the really nice things about thumb
mode is that thumb code is generally

00:05:16.900 --> 00:05:19.860
25% to 30% smaller than ARM code.

00:05:19.880 --> 00:05:23.970
This is huge when you're talking about
running some code on an embedded device.

00:05:24.220 --> 00:05:25.220
Thank you.

00:05:25.690 --> 00:05:31.990
Now, this smaller code is the big reason
why we decided to make Thumb the

00:05:31.990 --> 00:05:35.770
default mode for the iPhone SDK.

00:05:36.280 --> 00:05:42.320
Smaller is faster in an embedded system,
and smaller code uses less system memory.

00:05:42.430 --> 00:05:47.030
System memory in the iPhone is the
most important system resource.

00:05:47.160 --> 00:05:50.230
There's no virtual machine,
which means there's no swapping.

00:05:50.300 --> 00:05:53.990
So you want to try to keep your
application as small as possible.

00:05:54.460 --> 00:05:55.680
All right.

00:05:55.930 --> 00:05:58.300
When do I want to use Arm?

00:05:58.370 --> 00:06:00.930
Arm you're going to want to use
when you have either a lot of

00:06:01.040 --> 00:06:05.030
floating point calculations or
routines that need lots of registers.

00:06:05.180 --> 00:06:08.230
You probably don't run
into the second very much,

00:06:08.230 --> 00:06:10.780
but you will run into the first.

00:06:10.780 --> 00:06:10.780
So,

00:06:12.020 --> 00:06:16.890
Let's talk a little bit about
the specifics of the SDK here,

00:06:16.890 --> 00:06:21.430
so we can decide how
everything shapes up.

00:06:22.300 --> 00:06:26.280
Well, first of all, it's GCC 4.0.

00:06:26.360 --> 00:06:29.840
It's GCC 4.0 for the ARM processor.

00:06:29.940 --> 00:06:32.870
We do support both modes
I've just talked about,

00:06:32.960 --> 00:06:37.840
and it's going to be compatible in just
about every way with the Leopard GCC 4.0.

00:06:37.960 --> 00:06:40.010
One of the big things,
and you'll hear about this later

00:06:40.010 --> 00:06:43.480
in a lot of the iPhone sessions,
is that there is no Objective-C 2.0

00:06:43.480 --> 00:06:45.680
garbage collection on the iPhone.

00:06:45.780 --> 00:06:49.590
Therefore, at the compiler level,
we don't support this either.

00:06:50.510 --> 00:06:54.200
That said, all of your portable code
should just recompile and work,

00:06:54.200 --> 00:06:57.990
with a few exceptions, you know,
inline assembly, Indianess assumptions,

00:06:58.070 --> 00:07:01.350
all the things that if you were here
for the PowerPC to Intel transition,

00:07:01.350 --> 00:07:04.460
you've already had to deal
with and suffer through,

00:07:04.460 --> 00:07:07.390
and so your code already handles that.

00:07:09.800 --> 00:07:12.760
There are a few tweaks that you
can do to your code from just the

00:07:12.760 --> 00:07:17.600
toolchain side to make sure that you
can get the best performance out.

00:07:18.760 --> 00:07:21.390
One of which is, as I said,
there are gonna be times that

00:07:21.390 --> 00:07:24.000
you're gonna wanna use ARM mode.

00:07:24.000 --> 00:07:28.000
We only handle ARM on a file level basis.

00:07:28.000 --> 00:07:30.680
What this means is that to use ARM mode,
you're gonna have to take all

00:07:30.680 --> 00:07:33.000
the code out of your application
that you want to use ARM mode,

00:07:33.000 --> 00:07:36.140
and you're gonna want to stick
that into a separate file.

00:07:36.140 --> 00:07:38.340
And then within X code,
you're gonna want to use the UI.

00:07:38.340 --> 00:07:41.600
You're gonna want to
uncheck compile for thumb.

00:07:41.600 --> 00:07:44.090
And then all of that will
be compiled in ARM mode.

00:07:44.100 --> 00:07:47.990
And then at runtime,
it will swap between thumb and

00:07:48.230 --> 00:07:51.010
ARM mode for that invisibly to you.

00:07:51.640 --> 00:07:54.770
So back to that precious
system resource of memory.

00:07:54.910 --> 00:07:58.510
So if you're programming in C++,
there are a couple of very,

00:07:58.510 --> 00:08:02.370
very easy things you can do
to help optimize for memory.

00:08:02.530 --> 00:08:05.480
One of which,
you can avoid C++ exceptions.

00:08:05.480 --> 00:08:08.520
And you can avoid
runtime type information.

00:08:08.520 --> 00:08:12.530
Now, these two things are very,
very helpful in reducing the

00:08:12.530 --> 00:08:14.860
memory used by your application.

00:08:14.860 --> 00:08:19.900
Because they have some non-significant
overhead of just sitting in memory.

00:08:19.960 --> 00:08:23.030
They're not significant
overhead at runtime,

00:08:23.030 --> 00:08:25.860
but they are significant memory overhead.

00:08:25.860 --> 00:08:29.280
So if you can,
you'll want to uncheck those two boxes

00:08:29.370 --> 00:08:32.140
so you're not using either of those.

00:08:32.500 --> 00:08:34.690
language features.

00:08:35.130 --> 00:08:37.480
So that's a little bit
about the iPhone SDK.

00:08:37.670 --> 00:08:41.470
There are tons of sessions here during
the week that'll tell you about the

00:08:41.470 --> 00:08:43.600
more specific things for the iPhone.

00:08:43.600 --> 00:08:46.350
You know,
the APIs that you'll be developing too,

00:08:46.390 --> 00:08:49.420
the various different things,
different in OpenGL and

00:08:49.430 --> 00:08:50.780
all that kind of stuff.

00:08:50.780 --> 00:08:53.630
But from the compiler side,
everything should just

00:08:53.630 --> 00:08:57.070
continue to work just fine,
which is one of the nice things about

00:08:57.150 --> 00:09:01.380
using the same compiler as we transition
between the Mac development side that

00:09:01.470 --> 00:09:05.080
you're used to and the iPhone SDK,
and it's warranted.

00:09:05.100 --> 00:09:06.900
embedded side.

00:09:07.090 --> 00:09:09.220
Now that said,
I would like to switch gears a little

00:09:09.220 --> 00:09:12.430
bit and talk about Mac OS X development.

00:09:12.860 --> 00:09:18.640
We have a huge array of
compilers in Mac OS X now.

00:09:18.950 --> 00:09:23.580
To go over just some of the evolution,
we've had GCC 3.3,

00:09:24.000 --> 00:09:25.940
which was quite some time ago.

00:09:26.010 --> 00:09:30.900
We GMed GCC 4.0 in the Tiger timeframe.

00:09:31.020 --> 00:09:38.250
And then, and now at the conference here,
last year, we gave a beta of GCC 4.2.

00:09:38.320 --> 00:09:43.220
This year, with Xcode 3.1,
it's going to be a GM compiler.

00:09:43.220 --> 00:09:48.210
And it's going to be the default compiler
that we're using for all of Snow Leopard.

00:09:49.030 --> 00:09:51.440
and it would be a lot of great features.

00:09:51.490 --> 00:09:53.290
However,
we haven't been sitting on our hands

00:09:53.290 --> 00:09:58.940
there either because we also have the
LLVM compiler development side of things,

00:09:58.940 --> 00:10:04.060
where also in Xcode 3.1,
we're shipping LLVM GCC 4.2.

00:10:04.060 --> 00:10:08.480
Now, this has a GCC 4.2 frontend
and an LLVM backend.

00:10:08.660 --> 00:10:11.430
And one of the other things
that we've been working on is

00:10:11.430 --> 00:10:13.160
something called LLVM clang.

00:10:13.220 --> 00:10:16.480
Now, this has an LLVM frontend
and an LLVM backend.

00:10:16.480 --> 00:10:19.700
Now, I'm not going to talk much
more about those today.

00:10:19.700 --> 00:10:21.680
However, Chris Lattner,
when he comes up here,

00:10:21.680 --> 00:10:23.870
is going to talk in much
more detail about them.

00:10:24.020 --> 00:10:28.130
Just wanted to whet the appetite a little
bit and talk about where we're going.

00:10:28.300 --> 00:10:31.830
So with all these compilers,
probably your biggest question is, well,

00:10:31.990 --> 00:10:34.720
what compiler do I want to use?

00:10:34.970 --> 00:10:36.900
It comes down to a couple of questions.

00:10:36.900 --> 00:10:39.310
One, you want to target Tiger and later.

00:10:39.570 --> 00:10:41.110
Well, there's an easy choice there.

00:10:41.250 --> 00:10:43.980
You want to use GCC 4.0.

00:10:44.390 --> 00:10:48.290
and Eric Lange, and I'll be talking about
the new features of LLVM-GCC.

00:10:48.300 --> 00:10:51.300
So, the new features of
LLVM-GCC supports everything

00:10:51.300 --> 00:10:54.300
you need to target Tigran later.

00:10:54.300 --> 00:10:56.910
However, you want to target Leopard,
you want to use some of the

00:10:56.910 --> 00:11:00.120
cool new features that we've
been talking about here.

00:11:00.120 --> 00:11:02.300
You want to use blocks,
you want to use all these different

00:11:02.400 --> 00:11:04.770
features I'll be talking about later.

00:11:04.790 --> 00:11:08.300
You want to use one of the
GCC 4.2 based compilers,

00:11:08.300 --> 00:11:10.340
either GCC 4.2 or LLVM-GCC 4.2.

00:11:10.390 --> 00:11:11.750
It has everything you need,
and it's quite a bit more advanced.

00:11:12.050 --> 00:11:14.160
I gave you a big landscape,
a big development,

00:11:14.290 --> 00:11:17.600
but a picture is really worth
more than a thousand words,

00:11:17.600 --> 00:11:18.430
hopefully.

00:11:18.470 --> 00:11:21.750
So, let's talk about the compiler
progression that we've had,

00:11:21.750 --> 00:11:25.190
just to emphasize where things have been,
where things are now,

00:11:25.190 --> 00:11:27.800
and where things are going.

00:11:29.450 --> 00:11:34.500
So, back in the olden days,
we had GCC 3.3.

00:11:34.560 --> 00:11:38.720
It GMed about Panther timeframe,
and we've moved it through

00:11:38.720 --> 00:11:42.670
all the way through Xcode 3.1,
where we're going to leave it.

00:11:44.440 --> 00:11:47.740
Then we have GCC 4.0.

00:11:47.740 --> 00:11:50.280
GMed in the Tiger timeframe.

00:11:50.520 --> 00:11:52.640
was our default compiler for Leopard.

00:11:52.730 --> 00:11:55.830
It's going to be supported
for the coming future.

00:11:55.990 --> 00:11:59.980
Today at the conference,
we're shipping both GCC 4.2 and

00:11:59.980 --> 00:12:05.110
LLVM-GCC 4.2 when we release Xcode 3.1.

00:12:05.420 --> 00:12:09.050
Now, we've had some default
compilers over time,

00:12:09.050 --> 00:12:12.410
and this kind of gives you an idea of
where we've been going as we continue

00:12:12.410 --> 00:12:14.630
our way down to the bottom right.

00:12:14.980 --> 00:12:20.150
And as I said,
GCC 3.3 is no longer supported.

00:12:20.330 --> 00:12:22.540
You really, really do need to move.

00:12:22.690 --> 00:12:25.130
But hopefully I'll provide a
couple of compelling reasons for

00:12:25.130 --> 00:12:29.280
you to want to do that here now,
as I talk about GCC 4.0.

00:12:29.300 --> 00:12:33.320
Now, GCC 4.0 was our leopard default.

00:12:33.320 --> 00:12:35.520
It is still supported now.

00:12:35.760 --> 00:12:38.300
It's a great upgrade path from 3.3.

00:12:38.390 --> 00:12:41.910
There's a porting guide that some very,
very talented people have on the

00:12:41.910 --> 00:12:45.580
ADC website that gives you a lot of
information on what you're going to want

00:12:45.580 --> 00:12:49.160
to do to upgrade from 3.3 to 4.0 or 4.2.

00:12:49.270 --> 00:12:52.140
Provide lots of information there.

00:12:52.280 --> 00:12:57.700
However, there are going to be no new
features added to GCC 4.0.

00:12:57.740 --> 00:12:59.770
It's nothing else.

00:12:59.900 --> 00:13:02.550
And we're only going to be
making the most critical of

00:13:02.640 --> 00:13:05.710
bug fixes that are necessary.

00:13:05.880 --> 00:13:09.030
Very, very critical bug fixes only.

00:13:09.660 --> 00:13:12.330
However, as I said,
we did add some features.

00:13:12.410 --> 00:13:14.630
In particular,
we added some security features

00:13:14.740 --> 00:13:19.640
to GCC 4.0 that are around
now for GCC 4.0 and later,

00:13:19.660 --> 00:13:22.390
especially in GCC 4.2.

00:13:22.880 --> 00:13:26.100
So we added these security features
around the Leopard timeframe.

00:13:26.230 --> 00:13:29.100
And since security is our
continuing emphasis here at Apple,

00:13:29.100 --> 00:13:31.700
I'd like to talk to you
a little bit about them.

00:13:31.820 --> 00:13:34.820
Now, with security,
there are lots of different

00:13:35.200 --> 00:13:38.980
approaches you can make,
but there are no silver bullets

00:13:39.800 --> 00:13:44.230
in writing secure applications.

00:13:45.170 --> 00:13:48.080
There's no process you
can say by doing this,

00:13:48.080 --> 00:13:52.100
by doing this, by doing this,
my app is magically secure.

00:13:52.220 --> 00:13:56.380
However, the compiler can help you
out in a few different ways.

00:13:56.470 --> 00:14:01.090
For example, we actually have stack
canaries in GCC 4.0.

00:14:01.320 --> 00:14:02.870
Well, okay, how do those help?

00:14:03.070 --> 00:14:08.390
Well, what we've got here is your
standard buffer overflow problem,

00:14:08.390 --> 00:14:11.520
where we've got a buffer and
we're copying data that our

00:14:11.640 --> 00:14:15.790
conceivably malicious attacker
has decided to put on the system.

00:14:16.520 --> 00:14:18.680
All right, what does this look like?

00:14:18.680 --> 00:14:21.400
OK, here's our stack frame.

00:14:21.420 --> 00:14:26.040
So here's our little small
buffer there that's fixed length.

00:14:26.050 --> 00:14:28.800
We can put up to 32 characters in it.

00:14:28.810 --> 00:14:30.080
Wow.

00:14:30.100 --> 00:14:34.460
And then we read from the outside,
where our malicious attacker

00:14:34.510 --> 00:14:36.620
has decided to do something bad.

00:14:36.710 --> 00:14:40.410
What he's going to do is he's going to
overwrite the return address and use that

00:14:40.490 --> 00:14:44.010
to execute arbitrary code on the system.

00:14:44.170 --> 00:14:51.100
and Eric are here.

00:14:51.100 --> 00:14:55.100
So, we have a huge, huge problem.

00:14:55.100 --> 00:14:57.100
He can execute as you,
or if you happen to have one

00:14:57.100 --> 00:14:59.820
of those increased privilege
applications that you're writing,

00:14:59.820 --> 00:15:01.880
he's executing as root on the system.

00:15:01.950 --> 00:15:04.650
You really don't want to allow
this in your application,

00:15:04.690 --> 00:15:08.420
so you want to try to
find some way of fixing

00:15:09.670 --> 00:15:12.890
is also known as a sentinel,
if you've heard that term before.

00:15:13.070 --> 00:15:17.680
So in our execution,
we again have our buffer here.

00:15:17.740 --> 00:15:21.190
And then our malicious attacker comes in.

00:15:21.310 --> 00:15:24.590
And yeah, our canary isn't very happy.

00:15:24.600 --> 00:15:27.000
He's run out of fresh air.

00:15:27.860 --> 00:15:31.070
So what happens with this and with
the canary is that it's a random

00:15:31.080 --> 00:15:35.950
number generated at compile time,
or run time, I'm sorry, on the system.

00:15:36.080 --> 00:15:39.630
And it's checked before we
return from the function.

00:15:39.870 --> 00:15:42.460
So what happens is that instead
of using the return address

00:15:42.850 --> 00:15:46.510
that was previously listed,
well,

00:15:47.100 --> 00:15:50.800
When we find that there's been a
problem and you're going to end

00:15:50.800 --> 00:15:54.370
up having a security violation,
you really want to abort the program

00:15:54.370 --> 00:15:57.940
to minimize the risk to your user.

00:15:57.960 --> 00:16:01.300
So we're going to go ahead and
abort your application there.

00:16:02.510 --> 00:16:06.440
It's much better than having
malicious code and viruses and

00:16:06.440 --> 00:16:08.890
everything else running on the system.

00:16:09.210 --> 00:16:11.590
So, stack canaries are
particularly easy to use.

00:16:11.630 --> 00:16:15.040
It's a simple command line option,
checkbox hopefully soon,

00:16:15.370 --> 00:16:18.670
that you'll add via the Xcode UI.

00:16:18.880 --> 00:16:22.190
You just use MySF stack protector,
it'll go ahead and enable it,

00:16:22.300 --> 00:16:24.020
and for those of you worried,
it is a very,

00:16:24.020 --> 00:16:26.860
very small performance impact to do this.

00:16:26.920 --> 00:16:30.090
It's mostly not even worth talking about.

00:16:30.350 --> 00:16:31.680
However,
there are a few things that we're

00:16:31.680 --> 00:16:34.240
not going to catch using this.

00:16:34.310 --> 00:16:38.360
We're not going to catch if, for example,
your data is not on the stack.

00:16:38.630 --> 00:16:41.260
Therefore,
we've got another tool for the Arsenal to

00:16:41.270 --> 00:16:42.770
handle these kinds of situations.

00:16:42.780 --> 00:16:44.860
It's called object size checking.

00:16:44.860 --> 00:16:46.980
It'll help protect against
non-stack overflows,

00:16:46.980 --> 00:16:49.910
where you're just going to go ahead
and write across memory or right

00:16:50.260 --> 00:16:52.520
across your passing of your data.

00:16:52.570 --> 00:16:56.100
So if you happen to have your
fixed length buffer again there

00:16:56.100 --> 00:16:59.770
in your more global memory,
what's going to happen is we're

00:17:00.070 --> 00:17:04.160
going to rewrite that string copy
routine into a checking version,

00:17:04.160 --> 00:17:06.790
where as you can see,
we're passing an extra argument

00:17:06.800 --> 00:17:08.350
with the size of the buffer.

00:17:08.700 --> 00:17:10.970
and Eric Lange,
and what happens is that either

00:17:10.970 --> 00:17:14.100
at compile time if we can,
or at runtime,

00:17:14.150 --> 00:17:17.660
we're going to see whether or
not we can determine that you're

00:17:17.660 --> 00:17:19.520
writing past the end of your buffer.

00:17:19.580 --> 00:17:21.220
And if you're writing past
the end of your buffer,

00:17:21.220 --> 00:17:24.650
well, we're going to do the same thing
we did previously and abort your

00:17:24.650 --> 00:17:27.080
application because it's not safe.

00:17:27.080 --> 00:17:28.960
At compile time,
if we can determine though,

00:17:29.020 --> 00:17:30.040
it's an even nicer thing.

00:17:30.050 --> 00:17:32.550
It will give you a wonderful
warning so you can say,

00:17:32.550 --> 00:17:35.210
"Oh, I've got a fixed link buffer here.

00:17:35.210 --> 00:17:39.830
There's a problem." Now,
there There are some things that--

00:17:40.960 --> 00:17:42.560
Well, we're not going to catch.

00:17:42.560 --> 00:17:46.320
Like, if you decide,
I hate those standard C library routines,

00:17:46.430 --> 00:17:49.430
I can write a better one myself.

00:17:51.060 --> 00:17:53.610
I would like to mention as an aside,
it took me two times to

00:17:53.640 --> 00:17:56.180
write this little for loop.

00:17:56.860 --> 00:18:03.000
So I'd really suggest you use
the standard C library routines.

00:18:03.210 --> 00:18:05.030
There are a few different reasons
you're going to want to do that,

00:18:05.120 --> 00:18:07.660
not the least of which it
minimizes the amount of times

00:18:07.660 --> 00:18:09.640
that you'll make some mistakes.

00:18:09.740 --> 00:18:13.580
One, we can check these calls if you
pass in the correct options,

00:18:13.600 --> 00:18:15.140
which I'll give you in a second.

00:18:15.260 --> 00:18:19.240
And these are optimized by
Apple for every CPU we ship.

00:18:19.510 --> 00:18:22.390
That means if you're using the standard
library routines and we ship some

00:18:22.390 --> 00:18:27.360
new whippity-doo machine next week,
no forward-looking statements here,

00:18:27.430 --> 00:18:33.140
I have no idea,
the string copy on that machine will

00:18:33.140 --> 00:18:36.120
be optimized for that CPU already.

00:18:36.310 --> 00:18:40.880
So it's a much better idea that you
want to use all the standard library

00:18:40.880 --> 00:18:44.900
calls so that we can have all this
checking so we can have the performance.

00:18:45.000 --> 00:18:48.830
Now, object-size checking is
also very easy to use.

00:18:48.920 --> 00:18:52.070
It's a simple preprocessor
macro that you'll throw in.

00:18:52.180 --> 00:18:56.680
This communicates into libc that you
want to turn on object-size checking,

00:18:56.680 --> 00:18:59.120
which communicates to the compiler
that you want to use the checking

00:18:59.120 --> 00:19:00.700
versions of lots of things.

00:19:00.720 --> 00:19:02.160
It's very handy.

00:19:02.460 --> 00:19:04.800
And as I said,
it is a couple of tools in your arsenal

00:19:04.820 --> 00:19:10.100
that you can use to help make your
applications a little more secure.

00:19:10.860 --> 00:19:14.140
So we made sure that these were in 4.0.

00:19:14.140 --> 00:19:16.980
They came from a little
later in the compiler,

00:19:16.980 --> 00:19:19.740
and they're also in GCC 4.2 as well.

00:19:19.930 --> 00:19:23.660
So I'd like to spend about the rest of
my time up here talking a little bit

00:19:23.660 --> 00:19:31.810
more about GCC 4.2 and why you should
move there as you're migrating off of 3.3

00:19:31.810 --> 00:19:31.810
to at least 4.0 and hopefully into 4.2.

00:19:32.170 --> 00:19:36.280
So 4.2, as I said,
is our Snow Leopard default compiler.

00:19:36.280 --> 00:19:40.290
I mean,
Snow Leopard is built with GCC 4.2.

00:19:40.490 --> 00:19:42.230
It has numerous front-end improvements.

00:19:42.290 --> 00:19:46.480
We've got new parsers,
better C++ language conformance,

00:19:46.590 --> 00:19:48.160
and all the cool new features
that you're going to hear

00:19:48.160 --> 00:19:51.080
about here at the conference,
like blocks.

00:19:51.250 --> 00:19:56.090
We also have a huge number of performance
enhancements going on behind the scenes.

00:19:56.220 --> 00:20:00.800
Now, they are behind the scenes,
so here's a huge laundry list of them.

00:20:00.950 --> 00:20:03.580
Now, there are tons more of
them than I've listed here,

00:20:03.600 --> 00:20:06.900
which, you know, dead code elimination,
inter-procedural optimizations,

00:20:06.970 --> 00:20:10.400
auto vectorization improvements,
visibility improvements.

00:20:10.490 --> 00:20:11.500
As I said, lots more.

00:20:11.500 --> 00:20:13.900
If you want the full list,
what you'll really want to do

00:20:13.900 --> 00:20:15.980
is take a look at the release
notes that we're shipping if you

00:20:15.980 --> 00:20:18.200
want to get more information.

00:20:18.290 --> 00:20:21.900
Now, I did talk a little bit about here
about visibility improvements,

00:20:21.970 --> 00:20:25.800
and visibility is usually an
obscure enough topic that it

00:20:25.800 --> 00:20:29.410
might be worth talking about it
in a brief introduction here.

00:20:29.670 --> 00:20:33.040
What visibility is, essentially,
is how do I control access to

00:20:33.100 --> 00:20:38.400
my symbols with my source file,
my library, or my executable?

00:20:38.530 --> 00:20:42.870
So what this means is that you
don't want all of your symbols

00:20:42.930 --> 00:20:44.050
to be visible everywhere.

00:20:44.280 --> 00:20:47.700
The minute you export a function
outside of your library,

00:20:47.700 --> 00:20:50.900
outside of your executable,
someone's going to use it.

00:20:50.900 --> 00:20:53.200
And therefore,
especially if you're like Apple,

00:20:53.200 --> 00:20:57.720
you're going to be supporting it
until probably the day you die.

00:20:58.300 --> 00:21:03.930
So, on the Mac, we have three available
visibility levels.

00:21:03.990 --> 00:21:06.610
Up here at the top,
we have static visibility.

00:21:06.770 --> 00:21:09.040
This means that it's only
visible within a file,

00:21:09.040 --> 00:21:11.560
and it's all you have to worry about.

00:21:11.590 --> 00:21:15.790
Now, down at the bottom,
we have whole program, or more the point,

00:21:15.860 --> 00:21:17.110
external visibility.

00:21:17.240 --> 00:21:20.160
And this is what you might
want to take careful care,

00:21:20.160 --> 00:21:23.330
because you don't really want
to have all of your functions

00:21:23.390 --> 00:21:25.780
visible from the outside.

00:21:26.020 --> 00:21:29.500
One of the things that GCC allows
is what's called hidden visibility,

00:21:29.640 --> 00:21:32.660
which basically means that it's
only visible within a library,

00:21:32.760 --> 00:21:35.840
which is very handy when you don't
want to write huge export lists for

00:21:35.840 --> 00:21:40.900
your C++ code that has all sorts
of name-mangled functions that you

00:21:40.990 --> 00:21:45.770
get to enumerate based on guessing,
mostly, whether or not you want

00:21:45.800 --> 00:21:47.970
to actually export those.

00:21:48.330 --> 00:21:52.260
So the visibility improvements that
we've done in GCC 4.2 are very,

00:21:52.260 --> 00:21:54.460
very handy for these sorts of occasions.

00:21:54.460 --> 00:21:57.200
Basically,
a lot of the functions you're not

00:21:57.200 --> 00:22:00.850
going to want to export end up
being things that take internal

00:22:01.000 --> 00:22:03.960
types to your application,
private types.

00:22:03.960 --> 00:22:06.390
So if you mark those
as visibility hidden,

00:22:06.410 --> 00:22:10.670
the compiler is just going to go
ahead and automatically hide all the

00:22:10.670 --> 00:22:13.290
functions that take that as a parameter.

00:22:13.360 --> 00:22:14.210
It's very handy.

00:22:14.310 --> 00:22:17.270
It helps minimize the amount
of time you're going to want to

00:22:17.370 --> 00:22:21.940
spend looking at export lists and
doing all sorts of other things.

00:22:21.960 --> 00:22:23.760
So it's kind of a new feature.

00:22:23.760 --> 00:22:27.100
It's also a new optimization
because it helps us generate

00:22:27.100 --> 00:22:29.240
code a little differently.

00:22:29.240 --> 00:22:31.300
So it's very handy to use.

00:22:33.820 --> 00:22:37.560
We get an awful lot of
feature requests for GCC.

00:22:37.560 --> 00:22:42.560
We get more feature requests than anyone
would have time to look at and deal with.

00:22:42.860 --> 00:22:46.100
However, probably one of the most popular
feature requests we get are,

00:22:46.130 --> 00:22:48.510
"I have to turn on warnings everywhere.

00:22:48.510 --> 00:22:51.910
I've got all of these warnings
and I want to turn on errors,

00:22:52.070 --> 00:22:56.120
but I only want to turn on errors
for this warning or that warning or

00:22:56.120 --> 00:23:00.390
this other warning over here." So,
let's say you've got this example

00:23:00.410 --> 00:23:04.080
here where you want format
security and format warnings.

00:23:04.080 --> 00:23:08.640
Now, format warnings are nice,
they're handy, they're useful,

00:23:08.940 --> 00:23:10.280
good coding practice.

00:23:10.430 --> 00:23:12.630
Format security is a
different matter entirely.

00:23:12.640 --> 00:23:14.010
It's a security warning.

00:23:14.110 --> 00:23:17.560
You want to know any time something
like that happens immediately.

00:23:17.560 --> 00:23:21.080
But you don't want to turn all of your
warnings into errors using -wError.

00:23:21.080 --> 00:23:26.680
One of the nice things that GCC 4.2
allows is that you can use -wError

00:23:26.870 --> 00:23:30.280
equals whatever the warning name is.

00:23:30.280 --> 00:23:33.940
So, that will go ahead and turn
only those warnings into errors.

00:23:33.960 --> 00:23:37.110
It's very helpful for when you want
to turn a specific class of warnings

00:23:37.110 --> 00:23:40.710
into errors but not have to worry
about it for all of your warnings.

00:23:43.750 --> 00:23:49.770
Lastly, I'd like to talk to you a little
bit about multi-core computing.

00:23:50.320 --> 00:23:56.080
So, Apple is shipping four and
eight-way machines today.

00:23:56.090 --> 00:23:58.300
I don't know what we're
shipping next year.

00:23:58.360 --> 00:24:00.840
It could be huge numbers
of cores on this ship.

00:24:00.980 --> 00:24:04.260
Intel has announced 80
core chips running around.

00:24:04.520 --> 00:24:08.520
The problem is, is that direct P-thread
programming is hard.

00:24:08.670 --> 00:24:11.730
You run into synchronization issues.

00:24:11.950 --> 00:24:14.710
You run into deadlocks.

00:24:15.300 --> 00:24:21.400
There are all sorts of options on
OS X that enable you to do better

00:24:21.520 --> 00:24:26.940
parallel programming without having to
worry about directly using Pthreads.

00:24:26.940 --> 00:24:29.590
So let's take a look at a few of

00:24:30.020 --> 00:24:33.860
Well, there's OpenCL,
there's NSOperation,

00:24:33.980 --> 00:24:35.840
there's Grand Central Dispatch.

00:24:35.860 --> 00:24:38.880
The real problem is that these all
require you to restructure your code.

00:24:39.210 --> 00:24:41.690
They are wonderful if you're
writing new applications.

00:24:41.770 --> 00:24:44.980
They're wonderful if you have the
time to restructure your code.

00:24:45.080 --> 00:24:48.470
The problem is,
is that you may not want to do that,

00:24:48.470 --> 00:24:50.420
or you may not have time.

00:24:50.420 --> 00:24:53.880
So, can the compiler help you
out here a little bit?

00:24:53.880 --> 00:24:55.940
Can you throw me something here?

00:24:56.190 --> 00:25:02.280
I'd like to talk to you about OpenMP,
which is compiler-directed parallelism.

00:25:02.280 --> 00:25:04.360
It's easy to use.

00:25:04.390 --> 00:25:06.380
It's an open standard,
which means it's portable to

00:25:06.450 --> 00:25:08.180
other compilers that implement it.

00:25:08.350 --> 00:25:16.090
There are tons of compilers around
the world that implement it.

00:25:16.090 --> 00:25:17.020
You can migrate your code easily
that uses OpenMP to GCC 4.2 as well.

00:25:17.520 --> 00:25:20.720
As the graph shows,
it's also amazingly scalable.

00:25:20.990 --> 00:25:23.260
So I did a simple Mandelbrot calculation.

00:25:23.260 --> 00:25:25.890
I parallelized it with OpenMP.

00:25:25.890 --> 00:25:30.740
And as you can see,
I'm getting almost linear scaling per

00:25:31.490 --> 00:25:32.720
This is amazing.

00:25:32.800 --> 00:25:34.400
It's very handy, very easy.

00:25:34.460 --> 00:25:35.900
Well, okay, it's easy.

00:25:36.130 --> 00:25:37.640
Example, example.

00:25:37.810 --> 00:25:39.230
Well, this is how easy it is.

00:25:40.690 --> 00:25:42.750
So you've got your simple for
loop here that's doing some

00:25:42.750 --> 00:25:44.700
sort of pixely manipulation.

00:25:44.700 --> 00:25:47.600
It's just straight line code, normally.

00:25:47.670 --> 00:25:50.190
And you decide, well,
let's parallelize it.

00:25:50.410 --> 00:25:52.750
All right, what's this little thing mean?

00:25:52.910 --> 00:25:59.790
So pal and pragma OMP is just the
standard preface to every OMP directive.

00:25:59.970 --> 00:26:04.740
Parallel for means I've got a for loop,
parallelize it for me.

00:26:04.760 --> 00:26:05.670
That's all there is to it.

00:26:05.760 --> 00:26:07.600
You've just parallelized this for loop.

00:26:07.880 --> 00:26:11.660
It will go ahead and spawn off
additional threads as we go along.

00:26:11.660 --> 00:26:13.770
Well, OK.

00:26:14.200 --> 00:26:15.600
How does it work?

00:26:15.660 --> 00:26:17.450
It really does work just like that.

00:26:17.720 --> 00:26:20.020
You're executing your
straight line code here,

00:26:20.110 --> 00:26:25.150
you fork off a bunch of threads,
you do all of your computation,

00:26:25.220 --> 00:26:27.810
you join them all in,
and you start executing your

00:26:27.820 --> 00:26:29.580
straight line code again.

00:26:29.620 --> 00:26:32.310
And what's great is you can
do it over and over again.

00:26:32.380 --> 00:26:40.460
So you can parallelize every for loop
just by a simple pragma and go through.

00:26:40.460 --> 00:26:40.460
Well, okay.

00:26:40.680 --> 00:26:43.050
and Eric Levy are the founders of Xcode.

00:26:43.050 --> 00:26:47.810
They are the first developers to have
implemented Xcode in their own software.

00:26:47.810 --> 00:26:50.410
They have been working
on a new application,

00:26:50.450 --> 00:26:53.030
and they are working
on a new application.

00:26:53.080 --> 00:26:55.510
The new application is called Xcode.

00:26:55.510 --> 00:26:55.510
It is a new application that
is being developed in the

00:26:57.320 --> 00:27:01.750
Now, with OpenMP,
we're talking about profitability

00:27:03.200 --> 00:27:07.430
and safety in parallelizing loops.

00:27:08.020 --> 00:27:12.000
Profitable means you want to
have a long enough running loop

00:27:12.000 --> 00:27:14.530
that's worthwhile to parallelize.

00:27:14.660 --> 00:27:18.300
Safety means that no
iteration depends on another.

00:27:18.390 --> 00:27:22.040
As an example of something where, well,
we have a loop iteration that

00:27:22.160 --> 00:27:25.340
does depend on something else,
we've decided to parallelize

00:27:25.340 --> 00:27:28.970
this outer loop where we
have these two nested loops.

00:27:28.980 --> 00:27:31.790
So J here is shared
among all these loops.

00:27:31.800 --> 00:27:33.660
Well, there's a problem here.

00:27:33.660 --> 00:27:36.460
We violated our safety property.

00:27:36.460 --> 00:27:40.380
Now what this means is that since
all of our loop iterations modify J,

00:27:40.380 --> 00:27:45.240
what we've now done is we've decided
to take this nice single running loop

00:27:45.240 --> 00:27:48.400
and introduce synchronization issues.

00:27:48.400 --> 00:27:50.780
So we're not just writing
in a straight line.

00:27:50.780 --> 00:27:55.000
We're writing at almost random times into
this array where we have all of our loop

00:27:55.000 --> 00:28:00.780
iterations modifying all over the place,
and it's corrupt data.

00:28:00.780 --> 00:28:02.780
You're going to wonder what
the heck you did wrong.

00:28:02.940 --> 00:28:06.480
Well, there's a very,
very simple solution to this.

00:28:06.480 --> 00:28:08.020
J is private.

00:28:08.020 --> 00:28:11.450
All you do is say that J is
private to every thread,

00:28:11.550 --> 00:28:17.110
and what this does is it makes sure
that each loop gets its own copy of J.

00:28:17.180 --> 00:28:21.500
It's a very simple way of making
sure that your nested loops can

00:28:21.500 --> 00:28:25.480
also be parallelized simply,
easily, and safely.

00:28:25.890 --> 00:28:30.200
Now this is just a brief overview
of what OpenMP really is.

00:28:30.280 --> 00:28:34.000
OpenMP basically is a set of compiler
directives that you can use to

00:28:34.000 --> 00:28:36.460
parallelize your program much easier.

00:28:36.460 --> 00:28:39.580
They involve things like how
do you want to parallelize,

00:28:39.820 --> 00:28:42.720
how do you share your data,
how do you synchronize your work,

00:28:42.870 --> 00:28:44.260
and there's a lot more to it.

00:28:44.260 --> 00:28:45.360
It is an open standard.

00:28:45.360 --> 00:28:49.250
It's published on the web at OpenMP.org,
and it provides tons of information

00:28:49.250 --> 00:28:53.060
on how you can parallelize
your programs easily with just

00:28:53.090 --> 00:28:55.490
a few simple lines of code.

00:28:59.130 --> 00:29:06.230
So, GCC 4.2 is a new major version that
we're going to be using in Snow Leopard.

00:29:06.470 --> 00:29:08.570
and Eric Cronin.

00:29:08.570 --> 00:29:10.000
It is our default compiler.

00:29:10.010 --> 00:29:14.240
It also means it is binary
compatible to previous OS releases.

00:29:14.240 --> 00:29:15.280
This is very, very handy.

00:29:15.330 --> 00:29:17.070
All of our compilers
are binary compatible.

00:29:17.070 --> 00:29:18.900
You can mix and match and switch easily.

00:29:19.000 --> 00:29:23.470
We also have these symbol
visibility improvements that I was

00:29:23.550 --> 00:29:27.880
talking about that help you reduce
the amount of symbols you are

00:29:27.880 --> 00:29:32.380
exporting from all your programs,
which also have a side effect of helping

00:29:32.380 --> 00:29:32.380
your performance by reducing load times.

00:29:33.150 --> 00:29:37.380
gave you a feature, warnings that can be
upgraded to errors easily,

00:29:37.400 --> 00:29:41.220
a laundry list of optimizations,
and OpenMP.

00:29:41.430 --> 00:29:45.760
Now, there's a lot more to
GCC 4.2 than just this.

00:29:45.990 --> 00:29:49.140
I really encourage all of you to see
the release notes for more information

00:29:49.140 --> 00:29:52.000
on exactly what we've been doing.

00:29:52.120 --> 00:29:56.320
Now, in addition to all of this,
we haven't really been sitting

00:29:56.320 --> 00:30:00.070
on our hands here at Apple,
so I'd like to invite here up on

00:30:00.220 --> 00:30:04.240
stage to talk about LLVM and all of
the exciting work we're doing there.

00:30:04.340 --> 00:30:06.190
It's really great.

00:30:13.300 --> 00:30:14.680
Thanks a lot, Eric.

00:30:14.680 --> 00:30:16.960
So I'm here to talk about LLVM.

00:30:16.960 --> 00:30:17.900
My name is Chris Lattner.

00:30:17.940 --> 00:30:20.060
I am the architect of LLVM.

00:30:20.060 --> 00:30:22.940
I also run the LLVM group here at Apple.

00:30:22.940 --> 00:30:26.640
So first I thought I would
talk about what LLVM is,

00:30:26.640 --> 00:30:29.480
because it's something
that's often misunderstood.

00:30:29.480 --> 00:30:32.290
The two letters VM has some
very interesting connotations

00:30:32.290 --> 00:30:34.540
that sometimes confuse people.

00:30:34.540 --> 00:30:38.940
So if you boil LLVM down,
it's really a framework-based

00:30:39.070 --> 00:30:42.090
approach to building compilers.

00:30:42.090 --> 00:30:42.220
Okay?

00:30:42.530 --> 00:30:45.040
And Apple does a lot with frameworks,
so this should be something

00:30:45.040 --> 00:30:46.110
that's somewhat familiar.

00:30:46.300 --> 00:30:51.230
But it basically means we have components
for building compiler stuff out of.

00:30:51.370 --> 00:30:53.940
And so, for example,
we have components for building

00:30:53.950 --> 00:30:55.780
optimizers and code generators.

00:30:55.910 --> 00:30:58.450
We also have components
that plug into GCC,

00:30:58.450 --> 00:31:00.520
this is our LLVM GCC front end.

00:31:00.630 --> 00:31:03.970
We have components for doing
native LLVM front ends,

00:31:03.990 --> 00:31:06.310
and so Clang,
which I'll talk about later,

00:31:06.410 --> 00:31:07.820
is built on that.

00:31:07.870 --> 00:31:10.180
LLVM has a lot of other pieces,
like a JIT compiler and

00:31:10.180 --> 00:31:12.820
other things like that,
that are used elsewhere in the system.

00:31:12.820 --> 00:31:16.560
But I'm going to be talking
mostly about static compilation,

00:31:16.560 --> 00:31:20.930
or just drop-in batch
programming like you do with GCC.

00:31:21.010 --> 00:31:23.470
So LLVM, of course,
is also an open source compiler.

00:31:23.520 --> 00:31:25.840
Open source is very important to us.

00:31:25.860 --> 00:31:28.380
If you go to LLVM.org,
you can see a lot of information.

00:31:28.640 --> 00:31:30.150
I apologize a little
bit for the web page,

00:31:30.150 --> 00:31:32.650
it's not the best organized,
but it gets some of the

00:31:32.740 --> 00:31:34.290
important points across.

00:31:34.620 --> 00:31:37.670
LLVM is widely developed,
and it's widely in use.

00:31:37.720 --> 00:31:37.720
But it's not the best organized.

00:31:37.720 --> 00:31:37.770
But it gets some of the
important points across.

00:31:37.780 --> 00:31:37.820
LLVM is widely developed,
and it's widely in use.

00:31:37.820 --> 00:31:39.260
by a lot of different people.

00:31:39.260 --> 00:31:43.030
We have industry people like Apple,
we have research groups and

00:31:43.030 --> 00:31:44.460
academia doing interesting things.

00:31:44.460 --> 00:31:47.430
We also have a lot of individuals
who contribute on their spare time.

00:31:47.450 --> 00:31:50.090
And so if you go to the webpage,
you can find out a lot

00:31:50.110 --> 00:31:51.480
of this information.

00:31:51.480 --> 00:31:55.600
So I thought I'd give a brief
introduction to where LLVM came

00:31:55.600 --> 00:31:59.380
from and then we'll talk about
where it's going of course.

00:31:59.380 --> 00:32:02.210
So LLVM actually started
in the year 2000.

00:32:02.220 --> 00:32:04.560
When it first came out,
when we first started,

00:32:04.560 --> 00:32:06.420
it was basically a research project.

00:32:06.420 --> 00:32:13.010
And it was a research project in the
most traditional sense of it's broken

00:32:13.080 --> 00:32:18.360
and useless and has a lot of potential,
but it's not really something

00:32:18.360 --> 00:32:20.200
that you wanted to use.

00:32:20.200 --> 00:32:25.260
In 2003, LLVM finally became usable to a
certain class of people and so

00:32:25.280 --> 00:32:29.880
we had an open source release and
this was the 1.0 release of LLVM.

00:32:29.880 --> 00:32:32.600
This again wasn't super usable, right?

00:32:32.600 --> 00:32:35.720
It was basically at the point where
other researchers and other people

00:32:36.100 --> 00:32:39.160
in related research groups could
use it to hack on it and improve

00:32:39.160 --> 00:32:41.860
it and do things in specific areas.

00:32:42.220 --> 00:32:45.060
However, LLVM has progressed
at an incredible pace.

00:32:45.070 --> 00:32:48.940
The project has a release every
three to four months typically and

00:32:48.940 --> 00:32:53.120
these releases keep improving the
compiler in a lot of different ways,

00:32:53.120 --> 00:32:56.330
pushing performance and
compile time and compatibility,

00:32:56.400 --> 00:32:57.850
all kinds of different things.

00:32:58.010 --> 00:33:01.260
And so it's really been making
a lot of progress very quickly.

00:33:01.260 --> 00:33:03.320
In 2005,
Apple started hiring people to work

00:33:03.380 --> 00:33:08.640
full time on LLVM and has made a huge
commitment and investment in LLVM.

00:33:08.640 --> 00:33:12.080
One example is that in 2007,
the Clang project,

00:33:12.170 --> 00:33:14.530
which was actually started
by Apple engineers at Apple,

00:33:14.600 --> 00:33:18.320
was open source and released back
to the project and continues this

00:33:18.320 --> 00:33:21.830
development and it's maturing
in the open source community.

00:33:22.100 --> 00:33:26.680
Finally, in Xcode 3.1,
we're of course shipping LLVM GCC and

00:33:26.680 --> 00:33:28.980
I'd like to talk about that today.

00:33:29.170 --> 00:33:45.290
and Eric Cronin.

00:33:45.290 --> 00:33:45.290
We're going to be talking
about the new LLVM project.

00:33:45.290 --> 00:33:45.290
One interesting point about this is
that Apple is actually the single

00:33:45.290 --> 00:33:45.290
biggest contributor to the LLVM project.

00:33:45.290 --> 00:33:45.290
Apple does a lot with open source.

00:33:45.290 --> 00:33:45.290
Open source compilers are very important,
and we're driving the LLVM development.

00:33:45.290 --> 00:33:45.290
We think this is a
really important thing.

00:33:49.610 --> 00:33:52.120
So today, to start off with,
I want to talk about

00:33:52.300 --> 00:33:54.710
what you can use today,
and what you can play with,

00:33:54.780 --> 00:33:57.680
and how LLVM is useful.

00:33:57.750 --> 00:34:00.670
So LLVM-GCC is a compiler.

00:34:00.850 --> 00:34:02.900
It's a compiler just like GCC.

00:34:02.970 --> 00:34:05.870
In fact, in Xcode,
there's a drop-down compiler

00:34:05.940 --> 00:34:08.960
selection box where you can actually
pick the compiler you want to use.

00:34:08.960 --> 00:34:11.260
You go to Build Settings for
your application,

00:34:11.290 --> 00:34:19.260
and you can pick between GCC 3.3,
GCC 4.0, GCC 4.2, and LLVM-GCC 4.2.

00:34:19.260 --> 00:34:22.860
If you're on the command line,
LLVM-GCC is a little bit well-hidden,

00:34:22.860 --> 00:34:23.620
I'm told.

00:34:23.620 --> 00:34:26.250
It's in the developer user bin directory.

00:34:26.380 --> 00:34:29.960
And developer is wherever you
choose to install LLVM-GCC.

00:34:30.000 --> 00:34:32.930
But you can run it directly
from the command line,

00:34:32.940 --> 00:34:34.020
just like GCC.

00:34:34.020 --> 00:34:36.900
If you're using Makefile, of course,
you can replace your CC commands

00:34:36.900 --> 00:34:37.670
and things like that.

00:34:37.680 --> 00:34:42.100
And it works just like a
GCC-compatible compiler.

00:34:42.300 --> 00:35:53.000
[Transcript missing]

00:35:53.590 --> 00:35:56.540
So one question now is,
you get the basic idea

00:35:56.540 --> 00:35:57.790
that LLVM is a compiler.

00:35:57.910 --> 00:36:00.560
And Eric, of course,
talked about how GCC is a compiler.

00:36:00.560 --> 00:36:03.200
But what does it really
mean to be both things,

00:36:03.200 --> 00:36:03.850
right?

00:36:03.860 --> 00:36:07.880
So I thought I'd talk a little
bit about how compilers work and

00:36:07.880 --> 00:36:10.170
how these pieces fit together.

00:36:10.180 --> 00:36:13.340
So if you look at a
well-designed compiler,

00:36:13.340 --> 00:36:16.640
a well-designed compiler, and, you know,
every compiler fudges a

00:36:16.640 --> 00:36:19.200
little bit here and there,
but a well-designed compiler

00:36:19.250 --> 00:36:20.610
basically has three pieces.

00:36:20.620 --> 00:36:23.360
It has the parser, the front end.

00:36:23.490 --> 00:36:26.570
The front end of a compiler is
the piece that is really in charge

00:36:26.570 --> 00:36:27.960
of looking at your source code.

00:36:27.980 --> 00:36:29.160
It parses the code.

00:36:29.240 --> 00:36:31.380
It analyzes it for correctness.

00:36:31.380 --> 00:36:32.840
It determines what it means.

00:36:32.850 --> 00:36:35.050
It builds a syntax tree, right?

00:36:35.060 --> 00:36:38.000
And this is the part that emits
warning messages and errors.

00:36:38.120 --> 00:36:41.550
This is the part that parses
all the command line options,

00:36:41.550 --> 00:36:42.070
okay?

00:36:42.200 --> 00:38:08.400
[Transcript missing]

00:38:08.950 --> 00:38:12.380
So if we get back to LLVM and GCC,
GCC is designed very

00:38:12.380 --> 00:38:15.080
much like this picture.

00:38:15.080 --> 00:38:17.930
It has a front end,
which uses the GCC parsers,

00:38:18.110 --> 00:38:21.580
has an optimizer,
and has a code generator.

00:38:21.580 --> 00:38:25.680
So LLVM-GCC is basically
a modification of GCC,

00:38:25.680 --> 00:38:29.860
where we take the GCC optimizer and
the code generator and replace them

00:38:30.110 --> 00:38:32.440
with pieces from the LLVM project.

00:38:32.440 --> 00:38:37.420
Now LLVM is designed to be very modular,
and so this is a pretty straightforward,

00:38:37.420 --> 00:38:42.700
well, relatively speaking,
fairly straightforward thing to do.

00:38:42.760 --> 00:38:46.430
But basically this means that
now we have the same front end,

00:38:46.430 --> 00:38:49.180
the same parser as GCC 4.2.

00:38:49.180 --> 00:38:53.100
This means that all the logic for
instantiating templates and all the

00:38:53.100 --> 00:38:57.410
name resolution and objective C and
all that stuff is the exact same

00:38:57.410 --> 00:39:00.820
between GCC 4.2 and LLVM-GCC 4.2.

00:39:00.820 --> 00:39:05.180
We also reuse the same runtime libraries,
lib standard C++, lib GCC.

00:39:05.180 --> 00:39:07.580
All the stuff is exactly the same.

00:39:07.580 --> 00:39:10.300
So furthermore,
we've worked really hard to make

00:39:10.310 --> 00:39:14.310
the back end and the optimizer as
compatible with GCC as possible.

00:39:14.350 --> 00:39:18.160
What this means is that you can actually
take two different files and on a file

00:39:18.260 --> 00:39:21.840
basis mix and match your code with GCC,
and all the different versions

00:39:21.840 --> 00:39:24.820
of GCC are compatible,
and so you can mix and match

00:39:24.820 --> 00:39:28.940
LLVM-GCC compiled code with
GCC compiled code on the system.

00:39:28.940 --> 00:39:32.610
Now this is actually really important
because you may not necessarily be mixing

00:39:32.610 --> 00:39:37.400
and matching on object file boundaries,
but you're very likely to be caught up

00:39:37.400 --> 00:39:38.400
in the process of making a compiler.

00:39:38.400 --> 00:39:40.100
So if you're going to be calling into
code compiled by some other compiler,

00:39:40.100 --> 00:39:43.430
and so if you have, you know,
you build your application with LLVM-GCC,

00:39:43.430 --> 00:39:46.580
you really want to be able to compile
into a foundation which may be

00:39:46.580 --> 00:39:48.440
compiled with a different compiler.

00:39:48.450 --> 00:39:50.690
And so the output of
the back ends are very,

00:39:50.690 --> 00:39:53.220
very compatible between
these two compilers,

00:39:53.220 --> 00:39:56.360
and this is true across all
three supported architectures.

00:39:56.360 --> 00:40:00.730
So the output of these compilers are
these object files represented with

00:40:00.730 --> 00:40:05.550
the beautiful dots on our hard drive,
and then they go into the linker,

00:40:05.550 --> 00:40:08.220
and then that produces your object file.

00:40:08.220 --> 00:40:09.220
So this is your executable.

00:40:09.220 --> 00:40:12.760
I guess we're building Xcode.

00:40:12.800 --> 00:40:18.120
But so the question then may be, okay,
we've done all this work.

00:40:18.120 --> 00:40:19.440
We've replaced this optimizer.

00:40:19.440 --> 00:40:20.780
We have a new code generator.

00:40:21.020 --> 00:40:24.380
Well, what is the benefit of doing this?

00:40:24.660 --> 00:40:27.160
Well, so basically,
if you're talking about the optimizer,

00:40:27.200 --> 00:40:30.770
the optimizer is really in charge of,
or is capable of impacting three things,

00:40:30.790 --> 00:40:31.200
right?

00:40:31.200 --> 00:40:34.630
One is, how good is the code
coming out of the compiler?

00:40:34.790 --> 00:40:35.700
How optimized is it?

00:40:35.760 --> 00:40:36.610
How fast does it run?

00:40:36.620 --> 00:40:39.720
The second is,
how fast does the compiler itself run,

00:40:39.720 --> 00:40:40.300
right?

00:40:40.400 --> 00:40:42.490
How fast do we get code
out of the compiler?

00:40:42.500 --> 00:40:45.980
The third is, well,
is there room for new features?

00:40:45.980 --> 00:40:50.150
Right, and everybody loves features, and,
well, to some extent, I guess.

00:40:50.160 --> 00:40:53.010
So let's talk about
features to begin with,

00:40:53.100 --> 00:40:56.140
and the one biggest feature
that we have in LLVM-GCC is

00:40:56.140 --> 00:40:58.770
called link time optimization.

00:40:58.980 --> 00:41:02.120
Linktime Optimization is something
that a lot of people have been

00:41:02.120 --> 00:41:05.720
asking for for a long time,
and it's very straightforward with

00:41:05.740 --> 00:41:08.560
the architecture of the LLVM compiler.

00:41:08.900 --> 00:44:12.800
[Transcript missing]

00:44:13.000 --> 00:44:17.820
So, we're talking in very vague terms
about how compilers are good

00:44:17.820 --> 00:44:19.650
and how performance is good.

00:44:19.670 --> 00:44:22.090
I want to talk about a
couple of specific examples,

00:44:22.090 --> 00:44:22.660
okay?

00:44:22.730 --> 00:44:27.550
H.264 is an incredibly
important video codec at Apple.

00:44:27.700 --> 00:44:29.150
It's highly optimized.

00:44:29.200 --> 00:44:33.870
And so what we're going to do is we're
going to look at the H.264 decoder on the

00:44:33.870 --> 00:44:38.980
Mac compiled by both GCC and LLVM-GCC at
different optimization levels.

00:44:39.110 --> 00:44:42.920
And across the bottom here,
we'll have bars for O2, O3,

00:44:42.920 --> 00:44:46.030
and O4 and compare the
performance across here.

00:44:46.210 --> 00:44:49.640
So, of course, with decoding,
decoding video, higher is better.

00:44:49.690 --> 00:44:53.930
And so if we look at O2, for example,
what we've basically done

00:44:54.020 --> 00:44:58.080
is we've taken H.264,
compiled with LLVM-GCC 4.2,

00:44:58.230 --> 00:45:02.110
also compiled it with GCC 4.2
and compared the performance.

00:45:02.260 --> 00:45:05.020
And so in this case,
you can see that LLVM-GCC is

00:45:05.050 --> 00:45:10.110
actually producing code at O2,
which they're both compiled at O2,

00:45:10.220 --> 00:45:12.680
that runs almost 7% faster.

00:45:12.830 --> 00:45:16.700
So this is actually a pretty
impressive result when you consider

00:45:16.700 --> 00:45:22.000
the fact that H.264 has been highly
optimized by hand and tuned for GCC.

00:45:22.080 --> 00:45:26.740
It uses hand-vectorized code using
the SSE intrinsics in XMM and Trin,

00:45:26.740 --> 00:45:27.610
for example.

00:45:27.750 --> 00:45:30.120
And people have paid very close
attention to the performance

00:45:30.120 --> 00:45:31.120
of the code coming out.

00:45:31.240 --> 00:45:33.600
So 7% is pretty good.

00:45:33.830 --> 00:45:37.290
If we look at O3, actually,
it turns out that the gap widens.

00:45:37.340 --> 00:45:41.580
So O3 optimizes me harder.

00:45:41.580 --> 00:45:45.460
It enables new features like inlining.

00:45:45.460 --> 00:45:48.230
It enables loop enrolling.

00:45:48.240 --> 00:45:51.810
It enables some loop transformations,
things like that, right?

00:45:51.840 --> 00:45:55.280
The tradeoff is you say,
"I'm okay with bigger code and slower

00:45:55.280 --> 00:45:58.650
compiles as long as I get faster
code." That's roughly what it means.

00:45:58.660 --> 00:46:00.240
And in this case, it's very true.

00:46:00.240 --> 00:46:05.040
H.264 is a large C++ source base,
or the H.264 decoder,

00:46:05.040 --> 00:46:06.480
and so inlining is very important.

00:46:06.480 --> 00:46:09.380
And all these kinds of things
are very important for it.

00:46:09.380 --> 00:46:13.710
And so here you see that both --
the performance of both compiled

00:46:13.710 --> 00:46:17.880
versions of the program go faster,
which is good.

00:46:17.880 --> 00:46:21.420
But actually,
LLVM-GCC increases its lead a little bit,

00:46:21.420 --> 00:46:23.460
and now it's up to 9% faster.

00:46:23.460 --> 00:46:26.220
Another interesting detail
about this is that in this case,

00:46:26.340 --> 00:46:31.680
O3 with LLVM-GCC actually runs -- or O2
compiled code with LLVM-GCC actually runs

00:46:31.680 --> 00:46:36.280
faster than O3 compiled code with GCC,
which is also a nice result.

00:46:37.290 --> 00:46:38.410
So let's talk about 04.

00:46:38.440 --> 00:46:41.750
04 turns on optimization across files.

00:46:41.820 --> 00:46:45.770
So in this case,
we find that 04 is a small incremental

00:46:45.900 --> 00:46:49.500
improvement over 03 on this code base.

00:46:49.700 --> 00:46:52.530
Again, this is highly optimized code,
and so we think this is

00:46:52.530 --> 00:46:53.900
actually a really good result.

00:46:54.050 --> 00:46:59.500
They've already done most of the things
that link time optimization gets by hand.

00:46:59.500 --> 00:47:02.490
So they've moved file, you know,
inline functions into headers,

00:47:02.490 --> 00:47:04.970
and they've done all kinds of
stuff to really tune their code.

00:47:05.140 --> 00:47:09.000
And so getting another 3% improvement,
we think, is actually really good.

00:47:09.110 --> 00:47:13.550
And again,
going from 65 to 66.8 frames a second is

00:47:13.550 --> 00:47:18.330
a big deal in the video decoding world,
because you're potentially

00:47:18.330 --> 00:47:21.400
decoding movies to do editing,
and you're spending a lot of time

00:47:21.710 --> 00:47:24.500
sitting with a lot of content,
and the faster you can decode video,

00:47:24.500 --> 00:47:27.000
the faster you can get your jobs done,
particularly if you're editing.

00:47:27.000 --> 00:47:30.080
So the question, of course, is, okay,
this is one axis of

00:47:30.080 --> 00:47:32.000
goodness for compilers,
right,

00:47:32.000 --> 00:47:34.000
which is how fast the code comes out.

00:47:34.000 --> 00:47:38.360
Another axis is compile time,
and if it's taking us, you know,

00:47:38.360 --> 00:47:41.000
ten times as long to get performance,
it's not necessarily as interesting.

00:47:41.000 --> 00:47:44.840
So let's look at the same code base,
H.264.

00:47:45.010 --> 00:47:47.990
Again, this is a large C++ code base.

00:47:48.020 --> 00:47:49.000
This is real-world code.

00:47:49.000 --> 00:47:51.000
It's been hand-tuned.

00:47:51.000 --> 00:47:53.960
It's had a lot of history behind it.

00:47:54.100 --> 00:47:55.760
It's real-world.

00:47:56.000 --> 00:47:59.010
So instead of looking at performance now,
I'm going to look at compile

00:47:59.320 --> 00:48:02.990
times across optimization levels,
and we'll see how, you know,

00:48:03.000 --> 00:48:03.000
03 time takes off.

00:48:03.000 --> 00:48:06.000
And 03 time takes longer than 02,
for example.

00:48:06.000 --> 00:48:10.000
And so one of the things that we
consistently see with LLVM GCC is

00:48:10.000 --> 00:48:14.440
that if you turn on optimizations,
LLVM GCC compiles code approximately

00:48:14.440 --> 00:48:17.000
30% faster than GCC 4.2.

00:48:17.000 --> 00:48:20.000
And this is a big deal.

00:48:22.360 --> 00:48:24.940
So this is not a single case either.

00:48:24.940 --> 00:48:28.120
We see this consistently across
a vast number of code bases.

00:48:28.350 --> 00:48:31.730
And again, when you're optimizing,
you spend a lot of time in the optimizer.

00:48:31.790 --> 00:48:37.270
So the time you spend in the optimizer
is a very big impact on this.

00:48:37.340 --> 00:48:39.240
At O0, you're not spending much
time in the optimizer,

00:48:39.240 --> 00:48:41.830
so it doesn't really matter
how fast the optimizer goes.

00:48:42.190 --> 00:48:44.100
So let's look at O3 now.

00:48:44.100 --> 00:48:48.070
O3, of course, takes longer than O2,
because we turn on inlining

00:48:48.070 --> 00:48:49.650
and we optimize harder.

00:48:49.810 --> 00:48:52.060
So at O3, both compilers slow down.

00:48:52.080 --> 00:48:57.970
But actually, it turns out that
LLVM-GCC does slow down.

00:48:57.980 --> 00:49:00.230
It takes 20 seconds longer
to compile this code.

00:49:00.440 --> 00:49:02.620
But it's still about 30% faster.

00:49:02.620 --> 00:49:05.370
In fact, it's 36% faster in this case.

00:49:05.450 --> 00:49:07.620
And so it's also very good.

00:49:07.780 --> 00:49:11.700
So the big question now is, OK,
we have O4.

00:49:12.010 --> 00:49:14.940
O4 involves a huge amount
of work for the compiler.

00:49:15.060 --> 00:49:18.650
So at compile time,
we're doing basically as much

00:49:18.790 --> 00:49:21.600
optimization as we're doing at O3.

00:49:21.820 --> 00:49:25.260
Because it's O3 plus work in the linker.

00:49:25.280 --> 00:49:29.880
We don't do code generation
at O4 during compile time.

00:49:29.880 --> 00:49:31.580
We do it in the linker.

00:49:31.600 --> 00:49:34.600
But we have to read in
the entire application,

00:49:34.740 --> 00:49:38.220
which, again,
is a large C++ source space, into memory,

00:49:38.230 --> 00:49:42.870
optimize across all these files,
run code generation, and produce output.

00:49:43.040 --> 00:49:44.860
So the question is,
how long does it take to

00:49:44.880 --> 00:49:46.360
do all this extra work?

00:49:46.380 --> 00:49:48.360
Well,
when we set out to find these numbers,

00:49:48.360 --> 00:49:51.310
we were actually really surprised.

00:49:52.130 --> 00:49:55.750
and Eric Lange, and the rest of the team.

00:49:55.750 --> 00:49:59.830
So,
this is not something you should expect,

00:49:59.830 --> 00:50:01.510
unfortunately.

00:50:01.510 --> 00:50:06.320
In general,
we see that 04 is about 20% slower

00:50:06.320 --> 00:50:09.510
than 03 on most source spaces.

00:50:09.630 --> 00:50:15.110
And so, across a lot of source spaces,
we find that 04 with

00:50:15.120 --> 00:50:16.950
LLVM-GCC actually takes about the
same amount of time as 03 with GCC.

00:50:17.100 --> 00:50:50.000
[Transcript missing]

00:50:50.960 --> 00:50:54.460
So, in summary,
I want to wrap up what LLVM-GCC is.

00:50:54.460 --> 00:50:56.800
The takeaway points are it's
very compatible with GCC.

00:50:56.800 --> 00:50:58.000
We've stressed this really hard.

00:50:58.000 --> 00:51:01.830
It's very important for us to be able
to take an existing code base and

00:51:01.830 --> 00:51:03.710
drop in LLVM-GCC and just build it.

00:51:03.870 --> 00:51:08.150
It's important because we don't want to
have to tweak the source code to change,

00:51:08.150 --> 00:51:10.660
you know, picky details in the parser.

00:51:10.800 --> 00:51:13.940
We don't have to change our make
files to work around differences in

00:51:13.940 --> 00:51:15.740
options and all that kind of stuff.

00:51:15.910 --> 00:51:17.800
Compatibility is key.

00:51:17.800 --> 00:51:22.800
Of course, LLVM-GCC supports the
languages that GCC supports,

00:51:22.800 --> 00:51:23.800
which is important.

00:51:23.870 --> 00:51:26.800
And we support code generation
for the same set of processors.

00:51:26.800 --> 00:51:30.410
The one missing one is PowerPC 64.

00:51:30.870 --> 00:51:33.330
So across a large
number of source spaces,

00:51:33.420 --> 00:51:37.560
we find that LLVM-GCC compiles code
significantly faster than GCC does

00:51:37.980 --> 00:51:39.040
when optimizations are enabled.

00:51:39.040 --> 00:51:43.100
And we typically find about 5%
to 10% better code generation

00:51:43.100 --> 00:51:44.790
at one specific O level.

00:51:44.800 --> 00:51:47.300
So if you compare O2 to O2 or O3 to O3.

00:51:47.300 --> 00:51:50.940
So again, LLVM-GCC has a new feature.

00:51:50.940 --> 00:51:52.840
A major new feature is
link time optimization.

00:51:52.840 --> 00:51:56.150
And with link time optimization,
you can get significantly

00:51:56.150 --> 00:51:59.100
better performance than with O3,
for example.

00:51:59.360 --> 00:52:01.820
And a lot of the benefit,
the runtime benefit,

00:52:01.820 --> 00:52:03.960
the code generation benefit,
depends on your source space.

00:52:03.960 --> 00:52:07.190
If it's heavily optimized or
maybe only consists of one file,

00:52:07.190 --> 00:52:10.180
link time optimization
won't help you as much.

00:52:10.180 --> 00:52:12.280
If it's a code base that's
seen a lot of evolution,

00:52:12.280 --> 00:52:14.420
it's been hacked on by
lots of different people,

00:52:14.420 --> 00:52:18.540
then link time optimization can
sometimes be 20%, 30% speed up.

00:52:18.600 --> 00:52:20.420
And we've seen that in real world code.

00:52:21.900 --> 00:52:24.560
So LLVM-GCC,
the big takeaway picture is that

00:52:24.560 --> 00:52:25.690
we're focusing on performance.

00:52:25.820 --> 00:52:28.600
Performance, both of the generated
code and of the compiler,

00:52:28.750 --> 00:52:30.520
and we really want to
keep pushing this forward,

00:52:30.520 --> 00:52:32.990
and we'll continue to do that.

00:52:33.740 --> 00:52:37.290
So LLVM-GCC is something
that exists today.

00:52:37.360 --> 00:52:39.540
You have it in Xcode 3.1.

00:52:39.540 --> 00:52:40.740
It exists on Snow Leopard.

00:52:40.970 --> 00:52:42.660
I want to talk about something
that doesn't exist today.

00:52:42.800 --> 00:52:47.560
Well, it exists, but you don't have it,
unless you go to the website.

00:52:47.570 --> 00:52:51.340
So I'll give you a little
teaser on what Clang is.

00:52:51.340 --> 00:52:55.270
So the problem that we've found
with LLVM-GCC is we can do a lot

00:52:55.270 --> 00:52:57.080
of work to speed up the optimizer.

00:52:57.170 --> 00:53:02.020
And we really care about compile times
at Apple because we have huge code bases.

00:53:02.070 --> 00:53:04.720
And we have huge code bases that
we try to build very frequently

00:53:04.720 --> 00:53:06.770
because lots of things are changing,
right?

00:53:06.770 --> 00:53:09.210
And when you're building huge
code bases really frequently,

00:53:09.290 --> 00:53:11.130
you care about compile time.

00:53:11.270 --> 00:53:15.100
Furthermore, we really care about O0.

00:53:15.480 --> 00:53:20.640
At O0, which is usually what you
build your code at to debug,

00:53:20.960 --> 00:53:25.560
if I'm hacking on my code,
I want to change something, compile it,

00:53:25.650 --> 00:53:30.020
run it, debug it, fix something,
compile it, run it, debug it,

00:53:30.020 --> 00:53:33.400
over and over and over again,
the speed of the compiler really matters.

00:53:33.400 --> 00:53:35.650
And at O0,
no time is being spent in the optimizer,

00:53:35.700 --> 00:53:40.350
and so there's not really much you
can do by changing the optimizer.

00:53:40.560 --> 00:53:43.080
One of the goals that we have is
we want to build a new front end.

00:53:43.130 --> 00:53:47.690
And it's aiming at solving a
lot of problems that we've seen.

00:53:47.800 --> 00:53:51.940
One, the basic idea we want to do,
the basic idea of the project

00:53:52.000 --> 00:53:57.580
is we want to take and build
a new C++ front end for LLVM.

00:53:57.640 --> 00:54:00.810
So we're going to be as
compatible as we can with GCC.

00:54:00.960 --> 00:54:03.960
Now here, this will be a new front end,
so it will be a completely new parser.

00:54:03.960 --> 00:54:05.580
So there may be bugs here and there.

00:54:05.810 --> 00:54:06.990
But we'll try really hard.

00:54:07.100 --> 00:54:09.990
And if you file bugs, we'll fix them.

00:54:10.130 --> 00:54:14.840
So the big architectural
difference between a Clang-based

00:54:14.840 --> 00:54:18.840
compiler and a GCC front end-based
compiler is that with Clang,

00:54:18.850 --> 00:54:20.560
we can embed it into Xcode.

00:54:21.460 --> 00:54:23.140
Well, what does that really mean?

00:54:23.230 --> 00:54:26.340
Well, embedding into Xcode
has a lot of benefits.

00:54:26.340 --> 00:54:28.120
It means that we can improve Xcode.

00:54:28.270 --> 00:54:32.440
It means that Xcode can use
Clang to do indexing or factoring

00:54:32.440 --> 00:54:34.010
or other operations like that.

00:54:34.290 --> 00:54:38.180
It also means that embedding into Xcode,
you can do a lot of interesting

00:54:38.180 --> 00:54:40.030
optimizations for compile time.

00:54:40.080 --> 00:54:42.180
So you can do caching across compiles.

00:54:42.240 --> 00:54:47.200
When Xcode invokes GCC,
every time GCC starts up, or LLVM-GCC,

00:54:47.210 --> 00:54:49.390
it has to relearn everything
about the program.

00:54:49.480 --> 00:54:50.840
It needs to learn where
all the header files are,

00:54:50.840 --> 00:54:54.440
it needs to search the hard drive
to find all those pound includes.

00:54:54.480 --> 00:54:57.170
And as soon as it's done
the 1C file or M file,

00:54:57.170 --> 00:54:59.930
it goes on to the next one,
and it has to relearn all that stuff,

00:54:59.930 --> 00:55:00.280
right?

00:55:00.280 --> 00:55:03.480
Well, there's no reason to do this when
you're compiling a large code base,

00:55:03.480 --> 00:55:03.820
right?

00:55:03.980 --> 00:55:05.440
The IDE has all that information.

00:55:05.440 --> 00:55:06.120
We can cache that.

00:55:06.120 --> 00:55:09.390
We can do a lot more with that.

00:55:09.620 --> 00:55:12.530
A side note is that even though
we're going to embed into Xcode,

00:55:12.530 --> 00:55:15.570
we still really care
about command line use,

00:55:15.570 --> 00:55:16.890
and so we'll continue to support that.

00:55:16.940 --> 00:55:20.270
So Clang, as I mentioned before,
is an open source project.

00:55:20.270 --> 00:55:23.950
It has a website, clang.llvm.org.

00:55:23.990 --> 00:55:26.340
It has a lot of information
about our motivation,

00:55:26.340 --> 00:55:27.640
what we're trying to do.

00:55:27.640 --> 00:55:29.890
You can get the code there,
you can play with it.

00:55:29.940 --> 00:55:35.800
I really want to talk about four
major features of Clang today.

00:55:36.620 --> 00:55:40.170
So the major feature number
one is that when you compare

00:55:40.310 --> 00:55:44.080
Clang head-to-head against GCC,
against time spent in the front end,

00:55:44.080 --> 00:55:50.450
which is F syntax only effectively,
right now we see that Clang is about

00:55:50.450 --> 00:55:55.160
two to three times faster than GCC.

00:55:56.220 --> 00:56:01.330
So we see two to three times speedups
across a broad number of C and

00:56:01.330 --> 00:56:03.200
Objective-C based applications.

00:56:03.200 --> 00:56:06.060
So this is real world stuff
parsing huge source bases,

00:56:06.170 --> 00:56:09.090
for example, Xcode.

00:56:09.610 --> 00:56:12.650
So the sub-bullet there is
actually really important,

00:56:12.650 --> 00:56:15.700
though, because this is, again,
head-to-head comparison

00:56:15.700 --> 00:56:17.620
doing exactly what GCC does.

00:56:17.640 --> 00:56:21.570
So this is straight out engineering
improvement in the front end.

00:56:21.660 --> 00:56:24.580
Of course, we don't want to run
exactly the way GCC does,

00:56:24.580 --> 00:56:25.440
because that's very limiting.

00:56:25.440 --> 00:56:27.200
We actually want to embed
this thing into Xcode.

00:56:27.200 --> 00:56:30.350
And when you start taking advantage
of some of the information you have,

00:56:30.350 --> 00:56:33.730
we think we can push this
significantly farther and get several

00:56:33.730 --> 00:56:35.670
multipliers of speedup in there.

00:56:35.920 --> 00:56:36.970
And we'll have to see.

00:56:36.980 --> 00:56:39.460
But this is front-end time.

00:56:39.460 --> 00:56:41.420
This is a project in development.

00:56:41.420 --> 00:56:44.000
We think that there's
a lot of headroom left.

00:56:44.310 --> 00:56:49.410
Second, we really care about the user
interface of the compiler.

00:56:49.440 --> 00:56:53.260
So how often have you
gone to compile something,

00:56:53.270 --> 00:56:56.330
and the compiler basically spits
out a big mass of error messages,

00:56:56.330 --> 00:56:58.540
and you have no idea
what it's talking about,

00:56:58.540 --> 00:56:59.040
right?

00:56:59.040 --> 00:57:01.990
Well, the error messages and the warnings
coming out of the compiler are

00:57:01.990 --> 00:57:03.680
basically its user interface,
right?

00:57:03.750 --> 00:57:05.810
The user interface is
kind of a nasty one,

00:57:06.090 --> 00:57:08.870
because it's usually
through the command line.

00:57:09.040 --> 00:57:11.470
But if you compile code with Clang today,
if you check it out from

00:57:11.530 --> 00:57:13.880
the open source repository,
you'll see that it gives

00:57:13.880 --> 00:57:14.970
really good error messages.

00:57:14.990 --> 00:57:18.100
And the error messages not
only are worded well so that

00:57:18.100 --> 00:57:20.370
they tell you what's going on,
in this case, you know,

00:57:20.460 --> 00:57:23.920
that you have some invalid operations,
it actually highlights the line of

00:57:23.920 --> 00:57:27.320
source code where the error occurs,
and then pinpoints the location of the

00:57:27.320 --> 00:57:29.140
error and the sub-expressions involved.

00:57:29.140 --> 00:57:33.280
And what this means is that in this case,
there's four pluses, for example,

00:57:33.280 --> 00:57:34.100
on this line.

00:57:34.100 --> 00:57:35.930
It identifies the exact
plus that is the problem,

00:57:36.010 --> 00:57:37.560
and it identifies the sub-expressions.

00:57:37.560 --> 00:57:40.000
This is really important and very
useful when you have precedence

00:57:40.000 --> 00:57:41.720
problems and other things like that.

00:57:41.720 --> 00:57:42.680
In Xcode,
you can imagine that there are bubbles.

00:57:42.680 --> 00:57:42.680
You can see that there are bubbles.

00:57:42.680 --> 00:57:45.580
You can see that there are bubbles around
the sub-expressions and other nice,

00:57:45.580 --> 00:57:49.320
pretty things,
but we'll get there someday.

00:57:49.320 --> 00:57:52.120
So, which is the third bullet,
Xcode integration, right?

00:57:52.120 --> 00:57:54.110
So we really care about Xcode.

00:57:56.550 --> 00:57:58.700
And furthermore,
what we really want is we really want

00:57:58.700 --> 00:58:05.330
to build good programmer tools for C++,
Objective-C, Objective-C++ programmers.

00:58:05.410 --> 00:58:07.270
And this is really what's
motivating all this work.

00:58:07.370 --> 00:58:12.080
We really want to build the first
class UI for developing code,

00:58:12.160 --> 00:58:14.160
and that is Xcode.

00:58:14.420 --> 00:58:18.470
Fourth, and this is something that
we'll talk about soon,

00:58:18.470 --> 00:58:21.340
is a brand new tool that's in
development for automatically

00:58:21.340 --> 00:58:23.300
finding bugs in your code.

00:58:23.330 --> 00:58:27.140
And so this is just a teaser on Clang.

00:58:27.140 --> 00:58:29.540
We'll have a full session on LLVM,
actually.

00:58:29.660 --> 00:58:32.520
The session is Thursday at 5 o'clock.

00:58:32.630 --> 00:58:36.910
This session will talk about a
lot more detail about LLVM-GCC,

00:58:37.060 --> 00:58:39.290
including how link time
optimization works,

00:58:39.310 --> 00:58:41.250
how to use it, examples of optimization.

00:58:41.430 --> 00:58:45.320
Also includes details on Clang,
more performance information for Clang,

00:58:45.320 --> 00:58:48.250
more detailed compile numbers,
things like that,

00:58:48.310 --> 00:58:49.920
more of the architecture design.

00:58:50.110 --> 00:58:51.490
We also talk about a
new bug-finding tool,

00:58:51.520 --> 00:58:52.420
which is in development.

00:58:52.500 --> 00:58:56.250
This bug-finding tool is really designed
to take advantage of the information you

00:58:56.250 --> 00:59:00.860
get from a compiler as it parses code
to analyze your code much more deeply

00:59:00.860 --> 00:59:03.530
and point out problems that you have.

00:59:03.540 --> 00:59:06.580
For example, memory leaks,
things like that.

00:59:07.330 --> 00:59:10.190
So with all of that,
it's a very brief introduction.

00:59:10.190 --> 00:59:13.350
I want to wrap up the session
with saying where we are,

00:59:13.440 --> 00:59:14.940
where we're going.

00:59:15.000 --> 00:59:18.240
So there's a lot of compilers here.

00:59:18.240 --> 00:59:22.100
We have GCC, GCC 4.0 on the iPhone.

00:59:22.180 --> 00:59:23.920
If you're building for the iPhone,
your choice is simple.

00:59:23.920 --> 00:59:25.850
You have one compiler, GCC 4.0.

00:59:25.990 --> 00:59:27.120
It's a great compiler.

00:59:27.240 --> 00:59:31.020
This compiler has been used to build
all the source code for the iPhone.

00:59:31.090 --> 00:59:32.820
On the Mac, you have more choice.

00:59:32.970 --> 00:59:35.960
3.3 you really want to get off of,
so I'm not going to talk about that.

00:59:36.040 --> 00:59:38.720
4.0 is a very stable compiler.

00:59:38.840 --> 00:59:41.300
4.0 is most important if you're
building applications that

00:59:41.300 --> 00:59:43.190
have to run on Tiger machines.

00:59:43.260 --> 00:59:45.520
If those apps have to
run on Tiger machines,

00:59:45.520 --> 00:59:48.520
unfortunately,
4.0 is your only choice there.

00:59:48.730 --> 00:59:53.510
However, if you're willing to develop
your app for Leopard and later,

00:59:53.560 --> 00:59:55.460
you have other good choices.

00:59:55.460 --> 00:59:59.690
So LLVM-GCC 4.2,
GCC 4.2 are two really good compilers.

00:59:59.890 --> 01:00:00.670
They're available.

01:00:00.830 --> 01:00:05.240
They have many new features over 4.0,
and I'd love for you to try them out.

01:00:05.200 --> 01:01:28.400
[Transcript missing]
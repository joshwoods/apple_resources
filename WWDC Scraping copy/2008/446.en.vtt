WEBVTT

00:00:20.550 --> 00:00:22.720
Good morning, my name is Andrew Platzer.

00:00:22.720 --> 00:00:30.780
I'm a... I haven't finished yet,
so... My name is Andrew Platzer.

00:00:30.780 --> 00:00:31.840
I'm an iPhone engineer.

00:00:31.840 --> 00:00:32.870
I work on the UI kit.

00:00:32.920 --> 00:00:36.010
And today I'm going to talk about some
tips and tricks along with my co-worker,

00:00:36.010 --> 00:00:36.420
Paul.

00:00:36.420 --> 00:00:38.820
And we're going to cover some
of the classes that maybe didn't

00:00:38.820 --> 00:00:41.270
get full sessions and also some
of the ways that you can make

00:00:41.270 --> 00:00:44.880
your application draw faster,
respond to the user faster,

00:00:44.880 --> 00:00:47.070
and also some other setup stuff.

00:00:47.140 --> 00:00:50.710
So what we'll be covering today
are... We'll be covering these.

00:00:50.770 --> 00:00:54.640
So drawing, how to draw fast,
how the drawing system works,

00:00:54.640 --> 00:00:58.260
some stuff about image and graphics,
how scroll views work,

00:00:58.260 --> 00:01:01.040
some of the basic settings
for that and how it's set up.

00:01:01.050 --> 00:01:03.120
I'll also be talking about
how to display large content,

00:01:03.120 --> 00:01:05.900
like, for example, maps by using tiles.

00:01:05.930 --> 00:01:09.040
And then I'll talk about
how to animate controls.

00:01:09.150 --> 00:01:11.370
So if you want to, for example,
have them resized or have

00:01:11.370 --> 00:01:14.920
new components added,
I'll show you some examples of that.

00:01:14.960 --> 00:01:18.890
And then Paul will be
covering these sections.

00:01:20.670 --> 00:01:23.080
So first to drawing.

00:01:23.220 --> 00:01:27.090
So you've got your screen, the button,
and you touch.

00:01:27.920 --> 00:01:33.750
The system will send the event
from the sensors to the framework.

00:01:34.400 --> 00:01:57.800
[Transcript missing]

00:01:57.910 --> 00:02:00.550
Once your Touch's method returns,
we actually call back

00:02:00.550 --> 00:02:01.800
into your application.

00:02:01.840 --> 00:02:03.960
And here we call layout subviews.

00:02:04.010 --> 00:02:07.600
This method's available to any view,
and any view that was added,

00:02:07.660 --> 00:02:11.800
or whose geometry is changed by
either the size or the bounds origin,

00:02:11.860 --> 00:02:15.080
or explicit calls to set
needs layout will be called.

00:02:15.150 --> 00:02:17.920
And it'll work from the top down,
calling each view.

00:02:17.920 --> 00:02:21.920
And what you should do in that
call is lay out your subviews.

00:02:22.030 --> 00:02:24.720
So if you've got some parts to your view,
you'll want to put them

00:02:24.830 --> 00:02:26.000
in certain locations.

00:02:26.060 --> 00:02:28.160
You can also call set needs display here.

00:02:28.240 --> 00:02:30.680
And you can change the
geometry and the attributes.

00:02:30.680 --> 00:02:34.270
And you can begin animations here too.

00:02:34.520 --> 00:02:37.950
Then after the layout
subviews have been done,

00:02:37.950 --> 00:02:39.500
the draw rect calls will be called.

00:02:39.750 --> 00:02:45.770
So any view whose class implements draw
rect and whose has been just recently,

00:02:46.070 --> 00:02:49.070
just been shown,
or you call set needs display,

00:02:49.180 --> 00:02:52.070
or you have the view
content mode set to redraw,

00:02:52.380 --> 00:02:53.460
will be called.

00:02:53.460 --> 00:02:55.090
They'll be called in no particular order,
and each one will be

00:02:55.090 --> 00:02:56.450
given its own context.

00:02:56.450 --> 00:02:59.920
There's no sort of shared window context.

00:02:59.950 --> 00:03:01.910
Again, you can also queue up,
you really shouldn't

00:03:01.910 --> 00:03:03.920
do any more animations,
you should just be just doing

00:03:03.920 --> 00:03:05.890
drawing as quickly as possible.

00:03:06.170 --> 00:03:10.360
All that information is bundled up,
the attribute and geometry changes,

00:03:10.370 --> 00:03:13.500
the images, the view buffers that have
been created by draw rect,

00:03:13.500 --> 00:03:16.470
any animations,
and all shipped over to the compositor,

00:03:16.560 --> 00:03:20.740
and then to the graphics hardware,
and something shows up on your screen.

00:03:20.900 --> 00:03:25.930
So you've got to remember this is,
it's three phase steps are important.

00:03:25.940 --> 00:03:28.390
That's sort of what we'll be using
through the whole other parts of the,

00:03:28.390 --> 00:03:29.600
the, the, the, the, the, the course.

00:03:31.240 --> 00:03:33.370
Drawing.

00:03:33.990 --> 00:03:38.130
So if you want to
efficiently draw content,

00:03:38.380 --> 00:03:39.570
you avoid DrawRect.

00:03:39.730 --> 00:03:41.140
The system isn't that fast.

00:03:41.170 --> 00:03:45.460
Doing a lot of fancy drawing,
like gradients and so on, will be slow.

00:03:45.510 --> 00:03:47.800
Instead, use ImageView.

00:03:47.810 --> 00:03:49.960
Give your graphics art
department something to do.

00:03:49.960 --> 00:03:51.880
They can draw all these
PNGs in Photoshop.

00:03:52.000 --> 00:03:55.080
You just have to load them in
and put them on the screen.

00:03:55.590 --> 00:03:57.710
So you want to use subviews
to assemble the content here.

00:03:57.940 --> 00:04:00.520
So if you've got a lot
of sort of complex parts,

00:04:00.630 --> 00:04:04.000
maybe you just need to draw a little bit,
and then you can use another

00:04:04.010 --> 00:04:05.730
view for the remainder.

00:04:06.160 --> 00:04:07.800
You want to use opaque background colors.

00:04:07.800 --> 00:04:09.620
I think it's mentioned in table talk.

00:04:09.670 --> 00:04:11.830
You know, you want to set the
table cell to be opaque,

00:04:12.030 --> 00:04:13.190
other views opaque.

00:04:13.250 --> 00:04:15.770
If you even have an image view,
tell us it's opaque.

00:04:15.830 --> 00:04:20.000
The system can copy stuff to the
screen very fast if it doesn't

00:04:20.000 --> 00:04:24.780
need to blend between the view
content and what's already there.

00:04:25.210 --> 00:04:28.590
If you do need to use DrawRect,
there are a few things to keep in mind.

00:04:28.590 --> 00:04:32.090
What you want to do is make sure that
you only draw what you need to do.

00:04:32.100 --> 00:04:35.480
Don't get too fancy.

00:04:35.480 --> 00:04:37.320
Use images if possible.

00:04:37.320 --> 00:04:40.080
Factor out fixed backgrounds,
as I said before.

00:04:40.080 --> 00:04:43.670
If you've got, for example,
just a small label inside a big view,

00:04:43.670 --> 00:04:44.960
that doesn't change.

00:04:44.960 --> 00:04:46.180
Use a separate view.

00:04:46.180 --> 00:04:48.380
Put the label inside as a sub-view.

00:04:49.400 --> 00:04:51.320
Size the view to the content, of course.

00:04:51.320 --> 00:04:53.020
Each view gets its own buffer.

00:04:53.020 --> 00:04:55.300
So if you're going to
have screen-sized views,

00:04:55.300 --> 00:04:57.260
you're going to have
screen-sized memory allocation,

00:04:57.260 --> 00:04:59.220
and you're going to run
out of room pretty quickly.

00:04:59.220 --> 00:05:01.530
As I said before,
turn on the opaque flag.

00:05:01.530 --> 00:05:04.220
If you're going to fill the
view with opaque color or

00:05:04.350 --> 00:05:07.240
an opaque image or whatever,
tell us it's opaque.

00:05:07.240 --> 00:05:10.280
Turn off clears context before drawing.

00:05:10.310 --> 00:05:14.160
When we give you the context, by default,
it will either be cleared out

00:05:14.160 --> 00:05:16.030
or set to the background color.

00:05:16.040 --> 00:05:18.420
But if you know that you're going
to do some drawing like a fill

00:05:18.430 --> 00:05:21.530
rect... That's just going to set
every bit with something else,

00:05:21.570 --> 00:05:22.030
tell us.

00:05:22.080 --> 00:05:24.430
And then we'll save some time
and we won't do anything.

00:05:24.440 --> 00:05:27.710
We'll give you a context that's got
junk or whatever was there before.

00:05:27.780 --> 00:05:30.830
So you've got a guarantee that
you're going to fill every pixel.

00:05:30.900 --> 00:05:33.130
Use set needs display in rect.

00:05:33.130 --> 00:05:38.150
That will set initial clipping so that
when the call is made to draw rect,

00:05:38.150 --> 00:05:41.760
only the area that's been
dirtied will be drawn to.

00:05:41.870 --> 00:05:44.690
Everything else will be clipped out.

00:05:44.730 --> 00:05:47.160
And the system is very efficient
about not drawing things.

00:05:47.180 --> 00:05:49.120
And use clipping while in the system.

00:05:49.160 --> 00:05:51.160
And you can use the inside drawing,
of course.

00:05:51.160 --> 00:05:53.260
If you're drawing a long string
and you only need to draw the

00:05:53.300 --> 00:05:55.850
first letter or something,
use clipping and the system will

00:05:55.850 --> 00:06:00.160
not spend a lot of time trying to
draw characters that don't appear.

00:06:00.160 --> 00:06:02.160
And don't try to animate.

00:06:02.160 --> 00:06:04.160
All this drawing is
just not that very fast.

00:06:04.350 --> 00:06:08.070
There are other ways to do this
and I'll show you that later.

00:06:09.100 --> 00:06:11.000
So some things to keep in mind.

00:06:11.030 --> 00:06:14.020
I said every rendered view when the
drawback call is given a context.

00:06:14.040 --> 00:06:17.240
This context points to
its own unique buffer.

00:06:17.360 --> 00:06:22.450
So don't assume it's pointing to some
kind of window context or window buffer.

00:06:22.600 --> 00:06:26.080
And this way we can
have views that overlap.

00:06:26.300 --> 00:06:28.660
So you don't need to make them too big.

00:06:28.720 --> 00:06:31.500
Draw Rect as a Set is called first
time the view is shown if the

00:06:31.500 --> 00:06:33.340
Draw Rect method is implemented.

00:06:33.390 --> 00:06:35.840
Also on Set Needs Display or
Set Needs Display in Rect.

00:06:35.900 --> 00:06:42.260
Or if you set the View Content Mode to
Redraw and you've changed the bound size.

00:06:42.330 --> 00:06:43.850
And as I said before,
the context for each

00:06:43.950 --> 00:06:45.370
Draw Rect will be different.

00:06:45.420 --> 00:06:46.860
Don't assume they're shared.

00:06:46.910 --> 00:06:49.490
And don't try to hold onto them either.

00:06:50.900 --> 00:06:52.070
There's a few view content modes.

00:06:52.170 --> 00:06:55.320
Once you've drawn your view or
you used an image and set it,

00:06:55.370 --> 00:06:57.600
you can position the content.

00:06:57.600 --> 00:07:00.380
The standard ones is
the stretching to fill,

00:07:00.450 --> 00:07:02.800
but there's also an aspect
fit and an aspect fill.

00:07:02.890 --> 00:07:06.250
For those of you with widescreen TVs,
you know what that does.

00:07:06.290 --> 00:07:07.110
It'll clip otherwise.

00:07:07.310 --> 00:07:09.640
There's positioning ones where
it won't scale the content,

00:07:09.670 --> 00:07:12.720
but rather position it in the corner
or on the side or in the center.

00:07:12.780 --> 00:07:15.300
And if the view isn't big enough,
it will just clip.

00:07:15.460 --> 00:07:18.180
And finally, there's one special mode,
which is used if your

00:07:18.180 --> 00:07:19.800
view implements DrawRect.

00:07:19.870 --> 00:07:23.320
And that's automatically calling set
needs display whenever the size changes.

00:07:23.430 --> 00:07:26.110
So you don't have to worry about
then going override set frame and go,

00:07:26.220 --> 00:07:30.090
if the frame size changed,
then call set needs display.

00:07:30.840 --> 00:07:35.480
So we give you a few utility functions
if you want to sort of capture drawing in

00:07:35.480 --> 00:07:38.080
order to make this fixed background view.

00:07:38.130 --> 00:07:41.290
We have a special context
that you can create.

00:07:41.590 --> 00:07:45.920
And that will create a bitmap backing
store where you can use all the UI calls

00:07:45.920 --> 00:07:48.490
as well as the CG calls to draw.

00:07:48.810 --> 00:07:50.030
And here's the sample code.

00:07:50.210 --> 00:07:54.080
And the first thing you want to do
is call UIGraphicsBeginImageContext.

00:07:54.110 --> 00:07:56.760
And all you do is pass in a size,
and that's just how big it is.

00:07:56.860 --> 00:08:01.560
The origin is 0, 0 at the top,
just like it is in other drawing.

00:08:01.860 --> 00:08:06.420
You'll just do regular UI drawing,
UI color set, string drawing,

00:08:06.550 --> 00:08:09.300
or you can just get the current context,
which is a CG context graph,

00:08:09.520 --> 00:08:11.720
and use Core Graphics
Context drawing directly.

00:08:11.720 --> 00:08:14.370
At any time, you can ask for an image.

00:08:14.410 --> 00:08:15.820
So you can do this multiple times.

00:08:15.820 --> 00:08:17.490
You can draw a bit, get an image,
draw a bit.

00:08:17.520 --> 00:08:20.430
And you call UI Graphics
Image from image,

00:08:20.540 --> 00:08:23.400
get image from current image context.

00:08:23.480 --> 00:08:25.690
And that will return an
auto-released image you can use.

00:08:25.720 --> 00:08:28.560
And then when you're done,
you can call UI Graphics

00:08:28.600 --> 00:08:29.810
and Image Context.

00:08:30.020 --> 00:08:31.490
That will pop it, release any storage.

00:08:31.800 --> 00:08:33.980
And restore the previous
graphics context.

00:08:34.040 --> 00:08:37.780
And for example, in this code,
I draw a blue box, draw some red text,

00:08:37.810 --> 00:08:41.090
and you get a lovely
blue box with red text.

00:08:42.880 --> 00:08:46.340
We give you the ability to
create stretchable images.

00:08:46.400 --> 00:08:49.300
What you do is you get an
image and then you say,

00:08:49.300 --> 00:08:52.210
give me a stretchable
version of that image.

00:08:52.350 --> 00:08:57.280
You pass in either a top cap
height or a left cap width.

00:08:57.330 --> 00:09:02.380
We assume a one pixel wide fill and
the remainder is the other side.

00:09:02.920 --> 00:09:07.920
This is a new image which you can use
and whenever you call draw and rect,

00:09:07.920 --> 00:09:09.260
it will stretch the content.

00:09:09.260 --> 00:09:12.240
So it will draw the caps fixed
and stretch the middle fill.

00:09:12.240 --> 00:09:15.660
So for a horizontal case,
I've sort of magnified the width there.

00:09:15.660 --> 00:09:17.480
That would be one pixel wide fill.

00:09:17.480 --> 00:09:21.000
It'll just draw the end caps and
then stretch the fill to fit.

00:09:21.860 --> 00:09:23.700
For a vertical case, same thing.

00:09:23.700 --> 00:09:26.530
And you can do sort of a nine-part
image where the center pixel will

00:09:26.700 --> 00:09:29.540
be stretched and then the sides
will be stretched and the top and

00:09:29.540 --> 00:09:33.140
bottom edges will be stretched and
the corners will remain undistorted.

00:09:33.140 --> 00:09:36.330
This is not that fast to draw,
so if you want to sort of draw

00:09:36.340 --> 00:09:40.390
something that's increasing in size,
it will be noticeably slow.

00:09:42.180 --> 00:09:44.280
Some image gotchas
I just wanted to cover.

00:09:44.280 --> 00:09:46.450
PNG is the preferred format, as always.

00:09:47.160 --> 00:09:50.420
You can read in other
formats like JPEG and TIFF.

00:09:50.600 --> 00:09:52.160
We support those, but they are slow.

00:09:52.160 --> 00:09:54.680
There are functions
to write PNG and JPEG,

00:09:54.680 --> 00:09:58.470
and again, they are also very slow,
but they are available if you

00:09:58.530 --> 00:10:02.110
want to capture some drawing
or something and write it out.

00:10:03.160 --> 00:10:06.700
For toolbar and tab bar,
we automatically adjust the image.

00:10:06.850 --> 00:10:09.840
We'll take just the mask and
we'll generate a selected

00:10:10.010 --> 00:10:13.680
and unselected gradient,
for example, in the tab bar.

00:10:13.680 --> 00:10:15.500
And for the toolbar,
we'll just generate a white,

00:10:15.620 --> 00:10:16.320
bezeled image.

00:10:16.320 --> 00:10:20.310
So you'll just need to provide the mask,
no colors and no other

00:10:20.360 --> 00:10:22.210
custom images right now.

00:10:24.000 --> 00:10:27.680
So now I'd like to
talk about Scrollviews,

00:10:27.680 --> 00:10:32.790
another little introduction to a class
that didn't have its own session.

00:10:33.180 --> 00:10:35.600
Here are the basics for the scroll view.

00:10:35.640 --> 00:10:38.280
What you need to give us
first is the content size.

00:10:38.320 --> 00:10:42.110
Unlike some systems, for example,
Mac OS X, where the content size is

00:10:42.110 --> 00:10:48.950
derived off a content subview,
we don't want to require that

00:10:48.950 --> 00:10:51.460
you allocate a really large view.

00:10:51.460 --> 00:10:51.460
Instead, what you do is just
tell us how big it is.

00:10:52.070 --> 00:10:54.330
There are the bounds of the scroll view.

00:10:54.400 --> 00:10:56.980
This is sort of the
visible area of the scroll,

00:10:56.980 --> 00:10:58.540
what the user will see.

00:10:58.580 --> 00:11:01.370
And what's important is
the origin of the bounds,

00:11:01.560 --> 00:11:03.530
and that's what we call
the content offset.

00:11:03.710 --> 00:11:07.410
When you say set content offset,
it's just setting the bounds.

00:11:07.470 --> 00:11:12.280
And so that's sort of the visible
area of the whole content.

00:11:12.400 --> 00:11:36.500
[Transcript missing]

00:11:37.970 --> 00:11:40.140
So now you've got a scroll view.

00:11:40.140 --> 00:11:42.270
Unlike Mac OS X, there's no scroll bar.

00:11:42.360 --> 00:11:45.920
So how do you know to scroll?

00:11:46.180 --> 00:11:48.500
How does-- if the user
clicks on a view inside,

00:11:48.620 --> 00:11:51.810
how do you know if it's
meant to be the click in that

00:11:52.010 --> 00:11:53.550
subview or you want to scroll?

00:11:53.580 --> 00:11:57.070
And what happens if the user puts their
finger down and then starts to scroll,

00:11:57.130 --> 00:11:58.920
like for example in table view?

00:11:58.960 --> 00:12:02.130
So unlike Mac OS X,
you need to have some sort of a little

00:12:02.130 --> 00:12:07.220
bit of communication between the
scrolling system and your application.

00:12:07.220 --> 00:12:09.080
You need to tell us what to do.

00:12:09.130 --> 00:12:10.980
So there are two methods
that are important.

00:12:10.980 --> 00:12:14.360
One is touches should begin
with event in content view.

00:12:14.360 --> 00:12:18.920
And what will happen is after a delay,
the system will-- the scroll view will

00:12:19.200 --> 00:12:23.440
figure out which view you clicked in,
and it will call this function.

00:12:23.440 --> 00:12:27.220
And you can say at this point,
if that view is enabled,

00:12:27.220 --> 00:12:30.700
user interaction enabled is yes,
do you want to scroll?

00:12:30.700 --> 00:12:32.480
In which case you return no.

00:12:32.480 --> 00:12:34.590
Or you want to handle the
event in that subview,

00:12:34.600 --> 00:12:37.700
in which case your subview will
now start getting the same message,

00:12:37.700 --> 00:12:39.920
touches begin and touches moved.

00:12:39.920 --> 00:12:42.300
Now if the user moves
their finger far enough,

00:12:42.300 --> 00:12:44.780
the system goes, well,
did you want to scroll instead?

00:12:44.780 --> 00:12:46.620
Maybe they just paused for a moment.

00:12:46.620 --> 00:12:49.800
And that's where touches should
cancel in content view is called.

00:12:49.800 --> 00:12:53.840
Your content view is-- your
scroll view subclass is asked,

00:12:53.990 --> 00:12:57.560
is it OK to start scrolling instead?

00:12:57.570 --> 00:13:01.500
If you return yes, the subviews,
the content views,

00:13:01.520 --> 00:13:03.420
touches canceled method is called.

00:13:03.450 --> 00:13:06.310
And we just start scrolling from
then on until the finger lifts.

00:13:06.540 --> 00:13:09.860
If you return no,
which is the default for controls,

00:13:09.890 --> 00:13:12.520
then tracking will
continue in your subview,

00:13:12.540 --> 00:13:15.440
and you won't be able to scroll
until the user lifts her finger

00:13:15.440 --> 00:13:17.610
and starts scrolling again.

00:13:18.490 --> 00:13:22.320
So there are some
settings that you can use.

00:13:22.320 --> 00:13:25.070
One is delays content touches.

00:13:25.250 --> 00:13:28.440
And by default,
there's about a .15 second delay

00:13:28.440 --> 00:13:32.530
before we decide that the user
meant to touch in the content,

00:13:32.590 --> 00:13:35.780
one of the subviews
rather than the scroll.

00:13:35.780 --> 00:13:37.270
You can turn that off immediately.

00:13:37.270 --> 00:13:40.430
And so that touch should begin
with event and content view

00:13:40.430 --> 00:13:42.280
will get called immediately.

00:13:42.280 --> 00:13:45.020
And so you can decide at that point
whether or not you want to scroll.

00:13:45.020 --> 00:13:48.360
Maybe they clicked in some area of
the subview that isn't reacting.

00:13:48.410 --> 00:13:52.780
You can disable content view
canceling for everything.

00:13:52.780 --> 00:13:55.400
Instead of overriding the touch,
it should cancel in content view.

00:13:55.470 --> 00:13:57.140
You can just say, no,
you never can cancel.

00:13:57.140 --> 00:13:59.250
And once you start tracking a subview,
that's it.

00:13:59.320 --> 00:14:02.480
And you can just turn off scrolling
completely if you want to do something,

00:14:02.480 --> 00:14:05.960
not allow the user to scroll and just
by setting scrolling enabled to false.

00:14:07.630 --> 00:14:10.190
Another whole host of settings
that you can also change,

00:14:10.250 --> 00:14:11.820
just to quickly review them.

00:14:11.850 --> 00:14:13.670
Bounces is what it says.

00:14:13.670 --> 00:14:16.000
If you're scrolling and it hits the edge,
it will bounce a little

00:14:16.100 --> 00:14:16.920
bit past and come back.

00:14:17.170 --> 00:14:23.050
That also turns on sort
of the rubber banding,

00:14:23.050 --> 00:14:24.390
where if you're already at
the edge and you pull it down,

00:14:24.390 --> 00:14:24.390
it will spring back.

00:14:24.390 --> 00:14:24.390
Otherwise, it will just stop.

00:14:24.920 --> 00:14:29.420
By default, if the bounces are turned on
and the content size is wide

00:14:29.420 --> 00:14:32.320
enough that you can scroll,
we'll bounce.

00:14:32.340 --> 00:14:36.200
But if the content is too small,
we don't know which way you could drag.

00:14:36.230 --> 00:14:37.310
In this case, you can tell us.

00:14:37.370 --> 00:14:39.760
Always bounces vertical or
always bounces horizontal.

00:14:39.790 --> 00:14:43.680
For example, the table view always
bounces vertical turned on.

00:14:43.740 --> 00:14:45.580
So we know no matter how
many cells you've got,

00:14:45.580 --> 00:14:47.940
if you've only got one or two,
you can still pull it down

00:14:47.950 --> 00:14:51.130
past the top or bottom,
but not side to side.

00:14:51.860 --> 00:14:55.300
In Safari, if you've seen,
you've got sort of like a little

00:14:55.300 --> 00:14:59.240
what we call a directional lock,
where if you drag in one direction,

00:14:59.240 --> 00:15:02.320
vertical or horizontal,
it will try to just keep

00:15:02.400 --> 00:15:03.300
dragging in that direction.

00:15:03.300 --> 00:15:05.090
So you can turn that
on for your own views.

00:15:05.130 --> 00:15:09.740
Paging enabled gives you the,
like in the weather app effect,

00:15:09.740 --> 00:15:12.550
where you just go from page to page.

00:15:12.550 --> 00:15:17.040
And you can do this
horizontally or vertically,

00:15:17.040 --> 00:15:18.870
and it will page one scroll
bounds width at a time.

00:15:19.400 --> 00:15:21.380
You can adjust the scroll
indicator positions.

00:15:21.380 --> 00:15:23.340
Let's say you've got
an index down the side.

00:15:23.570 --> 00:15:26.670
You can just move the scroll
indicators over so they don't overlap.

00:15:26.760 --> 00:15:30.180
And you can just by setting, for example,
the right inset.

00:15:30.180 --> 00:15:32.480
And finally, there's one function
you might find useful,

00:15:32.480 --> 00:15:34.080
and that's Flash Scroll Indicators.

00:15:34.110 --> 00:15:36.430
And if you change your content
size or your scroll view is

00:15:36.470 --> 00:15:38.900
shown for the first time,
you'll probably want to show the

00:15:38.970 --> 00:15:40.600
user that there is a scrollable area.

00:15:40.630 --> 00:15:41.660
And that's what this does.

00:15:41.660 --> 00:15:44.080
For about a second or so,
the scroll indicators will appear,

00:15:44.080 --> 00:15:45.720
and then they'll vanish.

00:15:45.720 --> 00:15:49.250
The same-- and they'll appear just
as though the user had clicked.

00:15:51.080 --> 00:15:51.840
Zooming.

00:15:51.910 --> 00:15:55.610
So we have some basic
zooming features in there.

00:15:55.670 --> 00:15:57.510
We wanted to give you that gesture.

00:15:57.570 --> 00:15:59.970
If you want to get fancier,
you can see the code from the

00:16:00.100 --> 00:16:03.020
multi-touch talk from a couple of
days ago that shows you how to do

00:16:03.150 --> 00:16:04.940
sort of arbitrary zooming and panning.

00:16:05.180 --> 00:16:09.360
But this will give you some
simple sort of map style zooming.

00:16:09.710 --> 00:16:12.870
What you do is have a delegate
method that's called View for

00:16:12.870 --> 00:16:14.570
Zooming in Scroll View.

00:16:14.570 --> 00:16:15.270
And you return that.

00:16:15.320 --> 00:16:18.010
And it should be a subview,
not the scroll view itself.

00:16:18.150 --> 00:16:22.400
And as the user pinches,
the transform of that

00:16:22.400 --> 00:16:23.840
scroll view will be changed.

00:16:23.840 --> 00:16:27.520
It'll just call set transform
with a CGF in transform scale.

00:16:27.520 --> 00:16:32.830
And any subviews inside that
view will be magnified or shrunk,

00:16:32.830 --> 00:16:35.780
depending on which way they go.

00:16:35.780 --> 00:16:38.520
There's not too much you
can do while you're zooming,

00:16:38.520 --> 00:16:41.370
which is why we don't sort of keep
telling you what the current scale is.

00:16:41.490 --> 00:16:43.520
But if you really need to,
you can override the set transform

00:16:43.520 --> 00:16:45.030
method and keep track of it that way.

00:16:45.040 --> 00:16:47.720
At the same time,
if you just move your fingers,

00:16:47.720 --> 00:16:53.310
it'll adjust the bounds offset,
set the content offset to keep that in,

00:16:53.320 --> 00:16:56.690
to keep sort of the
content under your fingers.

00:16:56.700 --> 00:17:00.380
And then finally,
when the user releases their fingers,

00:17:00.470 --> 00:17:04.940
you'll get the call scroll view
did end zooming with you at scale.

00:17:04.940 --> 00:17:08.400
And then what you want to do
is probably reset the scale,

00:17:09.480 --> 00:17:12.510
and redraw your content.

00:17:14.040 --> 00:17:19.400
So now you've got a scroll view
and you want to show some content.

00:17:19.420 --> 00:17:21.180
But you've got a lot of content.

00:17:21.270 --> 00:17:25.320
And there's just not enough
room to load it in all at once.

00:17:25.350 --> 00:17:28.100
And so you're going to have to--

00:17:28.200 --> 00:17:45.200
[Transcript missing]

00:17:45.780 --> 00:17:48.620
And as I said,
there are time versus space issues.

00:17:48.680 --> 00:17:49.670
In fact, there are both.

00:17:49.720 --> 00:17:54.540
Easier to expect smooth scrolling,
but there's a limited amount of memory,

00:17:54.640 --> 00:17:56.300
so you can't load in all the tiles.

00:17:56.460 --> 00:17:59.990
And there's a limited CPU,
which means you can't do as much

00:17:59.990 --> 00:18:02.400
drawing as you might want to do.

00:18:02.780 --> 00:18:05.120
So for example, for Maps,
what we do is we just break

00:18:05.120 --> 00:18:06.080
everything up into tiles.

00:18:06.240 --> 00:18:09.460
Square views, they're marked as opaque,
so that's efficient.

00:18:09.490 --> 00:18:12.550
And we only really want to show--

00:18:12.950 --> 00:18:16.080
We don't want to show what's visible.

00:18:16.270 --> 00:18:22.370
So rather than having 10,000 tiles,
we just have maybe 20.

00:18:23.600 --> 00:18:43.200
[Transcript missing]

00:18:44.020 --> 00:18:46.470
So as I said before,
layout subviews is called whenever

00:18:46.470 --> 00:18:49.530
the content size or content offset
changes or the bounds origin

00:18:49.530 --> 00:18:50.860
changes or the size changes.

00:18:50.870 --> 00:18:54.090
So that's the clue that you
need to relay out your content.

00:18:54.240 --> 00:18:57.270
You look at the bounds with the offset,
that's your visible area.

00:18:57.390 --> 00:19:00.540
So a simple, for example,
CG rect intersects rect will tell you

00:19:00.540 --> 00:19:04.560
whether or not the frame of the tile
intersects the frame of the scroll view.

00:19:05.360 --> 00:19:08.030
In your layout subviews,
you'll want to hide or remove any

00:19:08.030 --> 00:19:11.320
views that are no longer visible,
no longer intersect the bounds.

00:19:11.320 --> 00:19:14.840
And you'll want to add
tiles to fill in new areas.

00:19:14.840 --> 00:19:18.250
If you're scrolling,
usually that's sort of an L-shaped area,

00:19:18.250 --> 00:19:21.840
so you can make your calculations
a little bit more efficient.

00:19:24.040 --> 00:19:26.820
So as I said,
keep computation to a minimum.

00:19:26.870 --> 00:19:28.380
Any drawing will slow things down.

00:19:28.510 --> 00:19:31.160
You just do a little bit of drawing,
the user will see it stutter.

00:19:31.280 --> 00:19:33.620
And I'll show you how that looks.

00:19:33.950 --> 00:19:35.850
You want to maintain a
pool of reusable views.

00:19:35.860 --> 00:19:38.140
So don't keep allocating
and deallocating views,

00:19:38.160 --> 00:19:41.370
because it's just going
to take more time.

00:19:41.400 --> 00:19:43.870
Not a lot more time,
but it's just going to slow

00:19:43.870 --> 00:19:47.700
down your scrolling speed,
add to the amount of time per frame.

00:19:47.810 --> 00:19:49.460
So you can use the hidden flag,
for example.

00:19:49.590 --> 00:19:53.300
Just mark the flag as hidden,
keep the view off in a

00:19:53.300 --> 00:19:57.570
separate array or something,
and then it's available for reuse.

00:19:58.840 --> 00:20:00.890
You want to use separate
view for content and changes.

00:20:00.970 --> 00:20:04.650
Just like in a table view,
the background is pretty much the same.

00:20:04.660 --> 00:20:06.280
It's just like the label will change.

00:20:06.430 --> 00:20:08.940
So again, you'll have a UILabel subview.

00:20:08.960 --> 00:20:13.410
That's the only thing that needs to
be modified as you reuse the cell.

00:20:14.490 --> 00:20:18.160
And you want one little sort of
hint is you can also keep the

00:20:18.160 --> 00:20:20.160
recycled views the same size.

00:20:20.190 --> 00:20:23.460
If it needs to redraw the view,
if you're using DrawRect,

00:20:23.470 --> 00:20:27.000
just make it wide enough for
the widest possible content.

00:20:27.000 --> 00:20:28.570
And then it won't need
to allocate new buffers.

00:20:28.660 --> 00:20:31.760
And that'll just add an extra
few percent to your scrolling.

00:20:31.760 --> 00:20:34.890
But you probably need it.

00:20:34.910 --> 00:20:39.740
I'd just like to show a quick demo
of how some of the settings interact.

00:20:43.280 --> 00:20:46.240
So I just got a little demo here.

00:20:46.280 --> 00:20:49.760
And it just draws a
bunch of little squares.

00:20:49.780 --> 00:20:53.510
In this case,
what it's doing is just redrawing every

00:20:53.870 --> 00:20:55.260
time the view needs to be displayed.

00:20:55.470 --> 00:20:58.220
It's still only showing visible views.

00:20:58.310 --> 00:21:00.200
But it has to redraw each one.

00:21:00.200 --> 00:21:02.420
It's removing it and adding it back in.

00:21:02.520 --> 00:21:04.510
And as I scroll--

00:21:05.100 --> 00:21:53.100
[Transcript missing]

00:21:53.800 --> 00:23:00.400
[Transcript missing]

00:23:05.730 --> 00:23:08.290
So I'd like to talk
about resizable controls.

00:23:08.290 --> 00:23:11.530
And this uses sort of the similar
techniques you've seen already with

00:23:11.530 --> 00:23:14.940
the tiles and using efficient drawing.

00:23:15.630 --> 00:23:19.500
UI view animations and draw recto mix,
as I said.

00:23:19.500 --> 00:23:23.200
Once it's drawn, once that view is drawn,
that's the content of that

00:23:23.660 --> 00:23:24.940
layer that's underneath.

00:23:25.030 --> 00:23:28.860
And unless it gets redrawn,
it stays the same.

00:23:28.860 --> 00:23:33.000
If you just change the frame, by default,
it'll size to fit.

00:23:33.100 --> 00:23:35.370
So what you'll see here, for example,
is-- but the default

00:23:35.370 --> 00:23:38.070
mode being scaled to fit,
rather-- if I just,

00:23:38.080 --> 00:23:42.890
in an animation block, say,
change the frame to be wider,

00:23:43.300 --> 00:24:35.700
[Transcript missing]

00:24:35.900 --> 00:25:06.000
[Transcript missing]

00:25:08.020 --> 00:25:11.920
So what we want to do now
is lay out the pieces.

00:25:12.230 --> 00:25:13.890
What we'll do is
override layout subviews,

00:25:13.890 --> 00:25:15.530
which is what you should do.

00:25:15.560 --> 00:25:18.820
And you can position the left
and right caps at the left

00:25:18.820 --> 00:25:20.700
and right edges of the bounds.

00:25:20.720 --> 00:25:24.280
Then you can set the frame
of the fill to the remainder.

00:25:24.330 --> 00:25:26.390
And it will automatically
stretch that one pixel fill

00:25:26.450 --> 00:25:29.280
to cover the whole rectangle.

00:25:29.310 --> 00:25:30.860
And then finally,
you just need to position

00:25:31.200 --> 00:25:33.110
the label in the middle.

00:25:33.650 --> 00:25:36.230
And this is useful to do
even if you're not animating.

00:25:36.240 --> 00:25:40.610
It just lets you localize all
your layout to one function.

00:25:40.770 --> 00:25:43.600
So now we want to animate the
pieces when we resize the button.

00:25:43.600 --> 00:25:45.690
We're going to change the width.

00:25:46.180 --> 00:25:50.310
So what we can do here
is either in a block,

00:25:50.410 --> 00:25:53.120
an animation block,
we can call layout subviews directly.

00:25:53.120 --> 00:25:57.580
Or inside your layout subviews,
you can set an animated flag

00:25:57.710 --> 00:26:00.060
and do the animation there.

00:26:00.060 --> 00:26:03.380
So here, for example,
you'll say set frame animated.

00:26:03.380 --> 00:26:04.120
Set the flag.

00:26:04.120 --> 00:26:05.840
The layout subviews gets called.

00:26:05.840 --> 00:26:07.040
You'll check the flag.

00:26:07.040 --> 00:26:08.770
Begin and end commit animations.

00:26:08.770 --> 00:26:10.580
And just do the layout inside.

00:26:10.580 --> 00:26:13.980
And the button will just
resize nice and smoothly.

00:26:13.980 --> 00:26:15.980
The center fill will be
stretched at all times.

00:26:16.000 --> 00:26:18.160
The system will do that smoothly.

00:26:18.160 --> 00:26:21.280
The caps will be moved out
of the way of the fill.

00:26:21.280 --> 00:26:23.880
And the label will be kept centered.

00:26:25.180 --> 00:26:26.650
You can get pretty fancy with this.

00:26:26.810 --> 00:26:30.140
UISegment and Control does this.

00:26:30.170 --> 00:26:33.540
It's got a three-part background view,
just like you saw.

00:26:33.640 --> 00:26:36.300
It's got three separate image views.

00:26:36.320 --> 00:26:37.370
It's got a set of dividers.

00:26:37.510 --> 00:26:40.830
So if you've got five items,
it'll have four image views.

00:26:40.980 --> 00:26:41.970
They're just simple image views.

00:26:42.040 --> 00:26:43.540
They don't do anything.

00:26:43.540 --> 00:26:45.370
You'll have a selected background.

00:26:45.460 --> 00:26:46.940
And we've got a couple
of different end caps,

00:26:47.000 --> 00:26:50.570
depending whether the selection
is at the beginning or at the end.

00:26:50.820 --> 00:26:53.980
and we've got content which will just be,
you know,

00:26:53.980 --> 00:26:57.780
if you set the label or the image
of the segment that's just stored in

00:26:57.790 --> 00:27:02.470
a UI label or a UI segmented view,
a UI image view.

00:27:05.000 --> 00:27:29.000
[Transcript missing]

00:27:29.320 --> 00:27:32.860
What you want to do is,
if you're adding a segment, for example,

00:27:32.880 --> 00:27:36.680
you'll add a new divider view on
top of the existing divider view.

00:27:36.680 --> 00:27:39.060
You'll add a new image or label view.

00:27:39.060 --> 00:27:41.880
That's your content,
and that will have its alpha set to zero.

00:27:43.400 --> 00:28:01.300
[Transcript missing]

00:28:01.910 --> 00:28:02.940
You can see here.

00:28:02.940 --> 00:28:06.040
And there's actually probably
a little-- I'll show you.

00:28:06.050 --> 00:28:09.770
There's probably a little bit of
delay before the content fades in,

00:28:09.810 --> 00:28:12.800
just to give it time for the
dividers to move out of the way.

00:28:12.810 --> 00:28:14.910
And it looks nice and smooth.

00:28:14.920 --> 00:28:17.800
And at the same time,
if you change the frame,

00:28:17.830 --> 00:28:22.810
it will also relay out those
views for wider or narrower case.

00:28:22.930 --> 00:28:25.020
So you don't have to do anything extra.

00:28:25.030 --> 00:28:29.260
You can do a lot just by, inside a block,
setting the location of

00:28:29.260 --> 00:28:31.780
things where they should be.

00:28:32.730 --> 00:28:36.280
So that's my part of the talk,
and I'd just like to recap.

00:28:36.400 --> 00:28:39.480
So for fast drawing,
you want to work smart.

00:28:39.480 --> 00:28:42.360
You want to do as little
drawing as possible,

00:28:42.360 --> 00:28:45.800
have everything pre-rendered
as much as possible.

00:28:45.800 --> 00:28:47.270
For scroll views, it's a new world.

00:28:47.270 --> 00:28:49.830
You have to--there's more
interaction between you with the

00:28:49.830 --> 00:28:51.620
application and the scroll system.

00:28:51.630 --> 00:28:54.400
You have to tell it when it can scroll,
when it can't scroll.

00:28:56.210 --> 00:29:00.100
As I said with tiling content, recycle,
reuse all the time,

00:29:00.100 --> 00:29:02.100
just the little changes possible.

00:29:02.100 --> 00:29:05.100
Also use opaque views
as much as possible.

00:29:05.100 --> 00:29:10.400
For example, in the contacts list,
only the top header that might have

00:29:10.400 --> 00:29:12.840
some cells underneath it is opaque.

00:29:12.920 --> 00:29:14.850
The ones in the middle are transparent.

00:29:14.860 --> 00:29:16.460
The ones in the middle
are actually opaque.

00:29:16.460 --> 00:29:20.220
So there's literally only a
few little non-transparent,

00:29:20.220 --> 00:29:22.400
non-opaque views when you see it.

00:29:22.410 --> 00:29:24.050
And that's why we can easily get,
you know,

00:29:24.110 --> 00:29:28.480
30 plus frames a second scrolling
a large amount of content.

00:29:28.670 --> 00:29:32.280
and finally with Resizable Controls,
break it up into little parts.

00:29:32.280 --> 00:29:33.540
And then you can move stuff anywhere.

00:29:33.540 --> 00:29:34.330
They can fly off.

00:29:34.440 --> 00:29:35.560
They can fade in and out.

00:29:35.700 --> 00:29:37.800
All our controls do that.

00:29:38.050 --> 00:29:41.140
If you're going to try to override
DrawRect and UI Segmented Control,

00:29:41.160 --> 00:29:45.280
nothing will happen because
we don't do any drawing.

00:29:45.350 --> 00:29:49.910
Now I'll turn the stage over to
Paul to talk about the second half.

00:29:56.370 --> 00:29:56.800
Morning.

00:29:56.800 --> 00:29:57.950
My name is Paul Marcos.

00:29:58.020 --> 00:30:01.550
I'm an engineer on the iPhone apps team.

00:30:01.550 --> 00:30:04.750
And we're going to go through
kind of a variety of topics.

00:30:04.810 --> 00:30:06.370
Andrew focused more on view stuff.

00:30:06.480 --> 00:30:09.000
We're going to kind of jump
around a little bit more here.

00:30:09.000 --> 00:30:11.900
So the first one we're going to talk
about is text entry and table views.

00:30:11.900 --> 00:30:16.200
And this is a question that's
come up a number of times,

00:30:16.200 --> 00:30:16.200
and it's a pretty common thing.

00:30:16.720 --> 00:30:18.620
The example I'm going to
use here is our settings

00:30:18.620 --> 00:30:20.600
application for the mail settings.

00:30:20.680 --> 00:30:23.690
Where you can see we have a
bunch of text fields inside of

00:30:23.790 --> 00:30:25.360
the table view with a label.

00:30:25.450 --> 00:30:27.970
And if you've been to any of the
other table view sessions or you've

00:30:28.070 --> 00:30:31.750
heard in a variety of sessions,
we talk about using sub

00:30:31.750 --> 00:30:33.820
views to compose these cells.

00:30:33.980 --> 00:30:37.480
So in this case we have
a UI label on one side,

00:30:37.480 --> 00:30:38.610
which is static.

00:30:38.720 --> 00:30:40.690
And then on the other side
we have a second sub view,

00:30:40.690 --> 00:30:42.200
which is the text field itself.

00:30:42.260 --> 00:30:44.400
And that's the editable piece.

00:30:44.550 --> 00:30:47.760
So that's the structure of the views.

00:30:48.090 --> 00:30:52.140
If you'd gone to the text session,
you also heard about

00:30:52.140 --> 00:30:53.580
the automatic keyboard.

00:30:53.720 --> 00:30:58.950
And the idea with the automatic keyboard
is that when the user taps in a field,

00:30:58.950 --> 00:31:02.160
they'll indicate that they want
to start editing in that field.

00:31:02.160 --> 00:31:03.500
So the user taps there.

00:31:03.780 --> 00:31:05.760
The field becomes the first responder.

00:31:05.860 --> 00:31:07.510
It gets the insertion cursor.

00:31:07.670 --> 00:31:09.900
And in response to that,
when we notice that the

00:31:09.900 --> 00:31:15.000
first responder has changed,
the automatic keyboard will slide in.

00:31:15.110 --> 00:31:17.540
And then the field is editable.

00:31:17.580 --> 00:31:18.580
And this is great.

00:31:18.580 --> 00:31:21.750
This is kind of the best case
scenario where the user just

00:31:21.750 --> 00:31:23.880
taps and the editing begins.

00:31:23.880 --> 00:31:27.580
If we look at-- there are two other
scenarios I want to look at that

00:31:27.580 --> 00:31:30.650
are a little bit more problematic.

00:31:30.870 --> 00:31:32.410
The second one is-- this is a

00:31:33.200 --> 00:31:50.800
[Transcript missing]

00:31:51.300 --> 00:33:58.800
[Transcript missing]

00:33:59.080 --> 00:34:02.400
So let's look at how you would
actually do that in code.

00:34:02.430 --> 00:34:05.580
When the keyboard is made
visible and is hidden,

00:34:05.580 --> 00:34:11.460
there is a sequence of notifications that
get posted using NS Notification Center.

00:34:11.510 --> 00:34:15.800
The four that are here are the Will Show,
Did Show, and then the Will Hide,

00:34:15.800 --> 00:34:16.560
Did Hide.

00:34:16.620 --> 00:34:20.650
And those are the notifications
you want to pick up on in order

00:34:20.680 --> 00:34:23.500
to adjust the size of your table.

00:34:23.600 --> 00:34:26.460
So to do that, you would add an observer.

00:34:26.460 --> 00:34:28.960
This would likely be a controller,
a view controller.

00:34:28.960 --> 00:34:32.520
That's managing the view
that contains the table view.

00:34:32.600 --> 00:34:37.000
You would add a couple observers
to pick up these notifications.

00:34:37.080 --> 00:34:39.600
And then if we look at, say,
the keyboard will show

00:34:39.600 --> 00:34:43.600
method that we would write,
we have to do a couple things.

00:34:43.600 --> 00:34:46.970
The first is we want to pick
up the geometry of where the

00:34:46.970 --> 00:34:49.770
keyboard actually exists on screen.

00:34:49.800 --> 00:34:52.880
And that's a piece of information
that's carried by the notification

00:34:52.880 --> 00:34:54.600
that gets delivered to the observer.

00:34:54.600 --> 00:34:56.420
So we have to pull that out.

00:34:56.500 --> 00:35:00.340
It's a CG rect value, ultimately,
the bounds that we're looking for.

00:35:00.340 --> 00:35:02.160
It gets wrapped inside of an NS value.

00:35:02.160 --> 00:35:05.360
So we kind of need to unwrap that.

00:35:05.760 --> 00:35:08.830
But we pull that out,
we get the bounds of the keyboard of

00:35:08.870 --> 00:35:14.080
where it will ultimately be displayed,
and then with that piece of information,

00:35:14.080 --> 00:35:16.580
we want to get the
frame of the table view,

00:35:16.650 --> 00:35:23.190
subtract off that height of the keyboard,
and then we reset the frame on the table

00:35:23.190 --> 00:35:26.620
view to make it that shorter height.

00:35:27.090 --> 00:35:32.350
and in the will hide,
you would want to do the opposite

00:35:32.360 --> 00:35:36.590
of adding that height back in
to extend the table view down.

00:35:37.150 --> 00:35:40.900
So this kind of approach of listening
for the notifications and responding it,

00:35:40.910 --> 00:35:44.390
adjusting geometry is pretty common.

00:35:44.850 --> 00:35:47.110
One of the other questions
that comes up in the area of

00:35:47.170 --> 00:35:50.780
editing text in a table view is,
if you have a text field

00:35:51.010 --> 00:35:54.530
that's being edited,
what happens to that if the

00:35:54.660 --> 00:35:58.110
user scrolls that off screen?

00:35:58.230 --> 00:36:00.410
And as you've seen in some
of the table view sessions,

00:36:00.470 --> 00:36:05.080
we're pretty aggressive about reusing
and putting cells that are now

00:36:05.220 --> 00:36:08.750
out of view onto the reuse queue.

00:36:08.980 --> 00:36:12.350
And the question is,
do we do that with the cell that

00:36:12.350 --> 00:36:14.430
the user is currently editing?

00:36:14.790 --> 00:36:16.200
And the answer is no.

00:36:16.270 --> 00:36:20.270
When a cell that contains the first
responder is scrolled out of view,

00:36:20.540 --> 00:36:23.830
that cell actually is left alone,
and it's left in existence

00:36:23.830 --> 00:36:25.100
in the table view.

00:36:25.180 --> 00:36:27.100
The field is still editing.

00:36:27.170 --> 00:36:32.240
The user can continue to type and type
into the field as you would expect.

00:36:32.310 --> 00:36:36.330
As soon as the first responder
goes out of that cell,

00:36:36.410 --> 00:36:38.900
that's when that cell may be taken
and put onto the reuse queue.

00:36:38.900 --> 00:36:42.540
So you want to make
sure when that happens,

00:36:42.630 --> 00:36:45.740
by the time that happens,
you've taken any content out

00:36:45.740 --> 00:36:48.900
of that cell that's of use,
because that cell may

00:36:48.900 --> 00:36:51.190
go away at any time.

00:36:51.410 --> 00:36:55.460
And a couple places that you
can pick up on that happening is

00:36:55.460 --> 00:36:58.630
if you set up a delegate of the
text field that's being edited,

00:36:58.630 --> 00:37:01.670
in the text field did end
editing delegate callback,

00:37:01.730 --> 00:37:03.460
you can grab the contents of the field.

00:37:03.660 --> 00:37:08.800
And that's generally a good idea even for
cells that remain visible just because

00:37:08.800 --> 00:37:13.790
you want to kind of get the content out
as soon as the user is done editing it.

00:37:13.790 --> 00:37:17.910
You can also pick up on the control
action for the field itself,

00:37:17.910 --> 00:37:17.920
UI control event did end,
editing did end.

00:37:18.820 --> 00:37:23.160
So those are just a couple of the issues
surrounding editing in a table view,

00:37:23.370 --> 00:37:24.770
editing text.

00:37:24.880 --> 00:37:29.380
The next topic I wanted to
move to is contextual toolbars.

00:37:29.500 --> 00:37:31.770
And actually before we get
to the contextual part,

00:37:31.800 --> 00:37:34.660
I wanted to talk about just
the toolbar part of it,

00:37:34.690 --> 00:37:39.490
because that really hasn't been covered
in great detail in any other sessions.

00:37:40.690 --> 00:37:46.680
One of the points I wanted to make was
we have a number of bars in the system.

00:37:46.680 --> 00:37:49.250
And we have the
navigation bar at the top,

00:37:49.250 --> 00:37:52.370
and then down at the
bottom we have the tab bar,

00:37:52.790 --> 00:37:54.950
which is used for
switching between views.

00:37:54.950 --> 00:37:57.420
And this is the toolbar
that we're talking about.

00:37:57.420 --> 00:38:03.320
So if you can try to keep
the bars clear in your head.

00:38:03.320 --> 00:38:06.790
The contextual part that I'm going
to talk about is if you look down

00:38:06.900 --> 00:38:11.380
here at the bottom of the screen,
this is an example of a toolbar.

00:38:11.380 --> 00:38:12.620
We have this toolbar with
a couple buttons on it.

00:38:12.620 --> 00:38:15.840
And as the user navigates
the hierarchy above it,

00:38:15.840 --> 00:38:18.330
going from the account
list to the mailbox list,

00:38:18.330 --> 00:38:21.350
down to the message list,
and then into a mailbox,

00:38:21.530 --> 00:38:24.640
you see the contents of the
toolbar kind of changes at

00:38:24.640 --> 00:38:26.170
each level of the hierarchy.

00:38:26.200 --> 00:38:29.140
And that's what we're going
to -- that's what I'm going to

00:38:29.140 --> 00:38:31.180
talk about in just a little bit.

00:38:31.310 --> 00:38:35.910
On the UI toolbars in general topic,
they are similar to the tab bars.

00:38:35.910 --> 00:38:38.430
And I'm going to try and keep
the terminology straight.

00:38:38.510 --> 00:38:40.160
They're similar to the tab bars.

00:38:40.160 --> 00:38:41.760
So the UI toolbars that
show up at the bottom,

00:38:41.760 --> 00:38:43.280
the visual display is a little different.

00:38:43.280 --> 00:38:47.620
The tab bars are typically that black
style that you see in the iPod app

00:38:47.710 --> 00:38:52.010
or YouTube where there's a selected
item that the user has chosen.

00:38:52.140 --> 00:38:53.770
So tab bars are also at the bottom.

00:38:53.930 --> 00:38:54.590
They're blue.

00:38:54.670 --> 00:38:56.980
And there's no notion of a selected item.

00:38:56.980 --> 00:39:01.070
They're just buttons that you
click on and generally perform

00:39:01.160 --> 00:39:03.930
some action or present some view.

00:39:04.050 --> 00:39:09.250
They do share the items that are in the
toolbar are also UI bar button items,

00:39:09.250 --> 00:39:10.940
which is something that you can do.

00:39:10.940 --> 00:39:11.950
And they're also a
little bit more specific.

00:39:11.950 --> 00:39:13.560
They're not just a
little bit more specific.

00:39:13.560 --> 00:39:13.560
They're a little bit more specific.

00:39:13.560 --> 00:39:14.560
So the UI toolbars are similar
to what the tab bar uses.

00:39:14.560 --> 00:39:14.560
And they have titles and images.

00:39:14.560 --> 00:39:16.040
They can show just text.

00:39:16.110 --> 00:39:18.710
Or it can be a custom
view that you provide.

00:39:19.110 --> 00:39:23.880
We have a whole bunch of built-in system
items for some of the common icons,

00:39:23.880 --> 00:39:26.600
the plus button, the magnifying glass
for the search field.

00:39:26.600 --> 00:39:30.040
These are actually all
built-in standard icons.

00:39:30.040 --> 00:39:34.760
So where the functionality is
similar to something we do,

00:39:34.760 --> 00:39:37.570
it would be good just for
consistency to use the same system

00:39:37.570 --> 00:39:42.940
items so the user has a good
understanding of what that icon does.

00:39:42.980 --> 00:39:45.860
And you can configure these
both in Interface Builder.

00:39:45.860 --> 00:39:48.760
It has some great support for laying
these out in a very flexible manner.

00:39:49.110 --> 00:39:51.570
or you can do it in code if you need.

00:39:52.210 --> 00:39:56.440
So a couple examples just to set the
stage of what you might do with these.

00:39:56.640 --> 00:39:59.000
These are how they would
appear in Interface Builder.

00:39:59.000 --> 00:40:03.320
So this is just three items on there with
a couple flexible spaces in the middle.

00:40:03.360 --> 00:40:08.500
And the flexible spaces here work to keep
that camera image centered in the middle.

00:40:08.550 --> 00:40:12.100
And this concept is similar
to toolbars on Mac OS X.

00:40:12.100 --> 00:40:17.260
The idea of a flexible and fixed space
items that you can put into a toolbar.

00:40:17.300 --> 00:40:20.420
Another one just with some text
and a flexible space in the middle.

00:40:20.420 --> 00:40:23.200
So the buttons are kind
of pushed to either side.

00:40:23.260 --> 00:40:26.930
And you notice the items can
either be bordered or not bordered.

00:40:26.940 --> 00:40:29.060
In the top case, they're not bordered.

00:40:29.060 --> 00:40:31.900
In the second case, they are bordered.

00:40:33.110 --> 00:40:36.090
And then the third one shows
a custom view in the middle.

00:40:36.400 --> 00:40:37.960
This is from mail,
so we have a custom view that

00:40:37.970 --> 00:40:39.200
shows the status of an account.

00:40:39.200 --> 00:40:42.300
And then two system items on either end.

00:40:42.340 --> 00:40:45.430
So let's see how you'd
set this up in code.

00:40:45.440 --> 00:40:49.200
The first thing you
would need is an array.

00:40:49.200 --> 00:40:52.080
We hold the items in an array,
so we just create an array.

00:40:52.080 --> 00:40:56.000
And then you would go through
adding UI bar button items to them.

00:40:56.020 --> 00:41:00.050
This is an example of
allocating a system item.

00:41:00.060 --> 00:41:02.200
In this case, the refresh item.

00:41:02.970 --> 00:41:03.760
So you create it.

00:41:03.760 --> 00:41:04.650
It's a control.

00:41:04.860 --> 00:41:06.170
It supports target actions.

00:41:06.210 --> 00:41:08.810
So you specify the target,
the action that should be invoked

00:41:08.820 --> 00:41:09.930
when that item is clicked.

00:41:09.980 --> 00:41:11.560
You add it to the array.

00:41:11.640 --> 00:41:15.300
And then you would probably
add some other number of items.

00:41:15.300 --> 00:41:16.580
And there's another example shortly.

00:41:16.640 --> 00:41:22.720
And then you would, on the toolbar,
just call set items animated yes or no.

00:41:22.780 --> 00:41:27.540
And the animation will basically
crossfade between the two sets of items,

00:41:27.640 --> 00:41:29.570
the old one and the new one.

00:41:32.970 --> 00:41:37.140
So in order to accomplish
the contextual part,

00:41:37.140 --> 00:41:39.010
there's a couple different
ways you could approach that.

00:41:39.220 --> 00:41:44.140
And one fairly natural approach is what
would be the wrong way of doing it.

00:41:44.240 --> 00:41:48.240
And in this case,
the way that these views are structured

00:41:48.300 --> 00:41:50.320
is there are two controllers involved.

00:41:50.360 --> 00:41:54.130
There's a navigation controller,
which is providing a hierarchy that the

00:41:54.380 --> 00:41:56.110
user is navigating left to right in.

00:41:56.140 --> 00:41:59.640
And then there are view controllers
that manage the content at any

00:41:59.640 --> 00:42:01.370
given point in the hierarchy.

00:42:02.240 --> 00:42:05.080
And the area, if we look at kind of what
part of the screen each of

00:42:05.080 --> 00:42:08.920
these controllers is managing,
the navigation controller is managing

00:42:08.920 --> 00:42:12.570
from the navigation bar all the
way to the bottom of the screen.

00:42:12.580 --> 00:42:17.090
And the individual view controller
is just managing the content

00:42:17.090 --> 00:42:19.600
underneath the navigation bar.

00:42:19.600 --> 00:42:24.080
And in this example,
since the navigation bar kind of, sorry,

00:42:24.080 --> 00:42:28.480
the toolbar appears in the
area that the view controller,

00:42:28.480 --> 00:42:31.100
the individual view
controller is responsible for,

00:42:31.560 --> 00:42:34.940
it's very natural to think, oh,
let me just put the toolbar in there.

00:42:34.940 --> 00:42:38.160
And it would actually be
managed by the view controller

00:42:38.160 --> 00:42:39.880
for the individual screen.

00:42:39.940 --> 00:42:45.140
And that would be problematic because
then as the navigation controller

00:42:45.140 --> 00:42:48.310
moved from screen to screen,
the navigation,

00:42:48.310 --> 00:42:50.940
the toolbar would move with it.

00:42:50.940 --> 00:42:53.950
And in this example,
we can see if you kind of keep your

00:42:53.950 --> 00:42:58.940
eyes on the toolbar at the bottom,
as we move from level to level,

00:42:58.940 --> 00:43:00.940
the whole toolbar slides
from side to side.

00:43:00.940 --> 00:43:06.300
And that's definitely not the user
interface that we want to present.

00:43:07.450 --> 00:43:08.230
So how would we do this?

00:43:08.370 --> 00:43:09.800
How would we do it the right way?

00:43:09.900 --> 00:43:11.620
Well, actually,
it's fairly similar to what

00:43:11.640 --> 00:43:16.040
we do with the UI tab bar view
controller that we provide.

00:43:16.040 --> 00:43:19.360
And the idea is you have the same
pieces that we had a minute ago,

00:43:19.360 --> 00:43:23.620
but there's one additional controller
that kind of sits above everything.

00:43:23.620 --> 00:43:28.620
And we basically elevate the toolbar
out of the individual view controllers

00:43:28.620 --> 00:43:33.660
per view up to a higher level that's
managed by this toolbar controller.

00:43:33.660 --> 00:43:38.560
And the toolbar controller is managing
both the navigation controller,

00:43:38.560 --> 00:43:41.700
as well as the toolbar at the bottom.

00:43:41.930 --> 00:43:45.560
And so we've seen the navigation
controller's content has

00:43:45.560 --> 00:43:49.600
effectively been shortened by
the height of the toolbar itself.

00:43:49.670 --> 00:43:52.310
And then the view controller,
each individual view controller at

00:43:52.420 --> 00:43:56.780
the different levels of the hierarchy,
is managing the content between

00:43:56.780 --> 00:43:59.590
the nav bar and the toolbar.

00:44:01.160 --> 00:44:04.640
Then the question becomes, well,
how does the top level toolbar

00:44:04.640 --> 00:44:09.080
controller populate the toolbar
since it's now kind of disassociated

00:44:09.210 --> 00:44:11.600
from the individual view controllers?

00:44:11.670 --> 00:44:15.110
And the idea would be that as
each new view controller gets put

00:44:15.110 --> 00:44:19.740
into the navigation controller,
the top level toolbar would ask

00:44:19.850 --> 00:44:23.500
that incoming view controller,
do you have any toolbar items?

00:44:23.940 --> 00:44:27.750
Where now the items of the
toolbar are really managed by

00:44:27.750 --> 00:44:31.720
the individual view controllers
at each level of the hierarchy,

00:44:31.720 --> 00:44:33.590
not the toolbar itself.

00:44:33.790 --> 00:44:36.740
And we'll see this in code.

00:44:38.520 --> 00:44:44.220
So the individual view controllers
at each level of the hierarchy

00:44:44.350 --> 00:44:48.560
would implement a method that
returns just the toolbar items.

00:44:48.790 --> 00:44:51.990
And similar to the previous
example where we built an array

00:44:51.990 --> 00:44:56.040
that holds the toolbar items,
that's really all this method would do.

00:44:56.120 --> 00:44:58.200
So we create a few toolbar items.

00:44:58.210 --> 00:45:02.600
Here we have a flexible space,
which is one of the system items.

00:45:02.650 --> 00:45:04.890
And then we would add
a compose item to it.

00:45:04.930 --> 00:45:08.230
And then we'd go and add a
couple additional system items.

00:45:08.270 --> 00:45:09.760
These are all system items.

00:45:09.760 --> 00:45:10.980
Or sorry, we would create them.

00:45:10.980 --> 00:45:14.230
We haven't kind of put
the array together yet.

00:45:14.540 --> 00:45:16.830
Once we have that,
we would create an array with

00:45:16.990 --> 00:45:20.030
the items ordered the way we want
them to appear in the toolbar.

00:45:20.040 --> 00:45:22.110
So it would be the
compose item on the left,

00:45:22.200 --> 00:45:25.280
then a flexible space,
then the camera item,

00:45:25.390 --> 00:45:28.220
and then another flexible
space and the action item.

00:45:28.280 --> 00:45:31.800
And that would yield a
toolbar that looks like this.

00:45:32.400 --> 00:45:35.410
So that's all the,
just the items is what the individual

00:45:35.420 --> 00:45:36.720
view controllers would provide.

00:45:36.720 --> 00:45:39.980
And then in the top
level toolbar controller,

00:45:39.980 --> 00:45:43.080
which is the delegate of
the navigation controller,

00:45:43.080 --> 00:45:47.060
it would implement this will
show view controller method,

00:45:47.060 --> 00:45:50.420
which is when the new incoming
view controller is displayed.

00:45:50.420 --> 00:45:53.640
And it would ask first,
do you respond to this toolbar

00:45:53.640 --> 00:45:56.870
items method leveraging the
dynamic nature of Objective-C?

00:45:56.900 --> 00:45:59.290
And if it does,
we would ask for the items.

00:46:00.330 --> 00:46:04.100
And then given those items,
we would set that on the toolbar.

00:46:04.400 --> 00:46:26.900
[Transcript missing]

00:46:29.160 --> 00:46:30.810
So that's contextual toolbars.

00:46:31.040 --> 00:46:34.280
The next topic is launching in landscape.

00:46:35.100 --> 00:47:38.800
[Transcript missing]

00:47:39.030 --> 00:47:43.730
So in order to set the status bar state,
there are a handful of info P list

00:47:43.730 --> 00:47:48.610
entries that you would make in
Xcode directly in your info P list.

00:47:48.860 --> 00:47:52.780
And the three ones typically of interest
are the UI interface orientation,

00:47:52.800 --> 00:47:56.840
where you indicate whether it's
landscape left or landscape right,

00:47:56.860 --> 00:48:00.970
depending if you want the user to
turn the device one way or the other.

00:48:01.190 --> 00:48:03.440
And then also depending on
the UI in your application,

00:48:03.440 --> 00:48:06.250
you may want to set the
UI status bar style.

00:48:06.630 --> 00:48:11.620
If you take over the entire screen,
you might want to set it to-- sorry,

00:48:11.620 --> 00:48:13.340
that was the next point.

00:48:13.340 --> 00:48:16.580
Depending on the content of your view,
it may be best to use the

00:48:16.580 --> 00:48:21.130
default gray status bar or
one of the black status bars,

00:48:21.130 --> 00:48:24.950
either translucent or opaque,
depending if you have content

00:48:24.950 --> 00:48:26.600
under the status bar or not.

00:48:26.670 --> 00:48:28.900
And if you are taking
over the entire screen,

00:48:28.960 --> 00:48:32.800
you might want to just set the status
bar to hidden using the third key,

00:48:32.800 --> 00:48:35.410
UI status bar hidden,
and you set it to true or false.

00:48:35.470 --> 00:48:37.890
The default obviously is false.

00:48:38.150 --> 00:48:40.090
So where you set these is in Xcode.

00:48:40.380 --> 00:48:41.880
You can select your Info.plist.

00:48:41.930 --> 00:48:44.380
That just shows you the
standard plist editor.

00:48:44.450 --> 00:48:47.760
You can add keys to it and then
add the appropriate values.

00:48:47.810 --> 00:48:51.590
And that information is used
at launch time in order to

00:48:51.670 --> 00:48:54.870
configure where the status bar is,
how it kind of animates in,

00:48:54.870 --> 00:48:57.660
whether it's shown, hidden,
what the style is, or whatnot.

00:48:57.810 --> 00:49:00.020
That's why it's done in the
plist as opposed to code,

00:49:00.020 --> 00:49:02.830
because the application
is not running yet.

00:49:03.810 --> 00:49:07.030
and you would just add your keys there.

00:49:07.040 --> 00:49:12.160
So now that you've indicated
the state of the status bar,

00:49:12.190 --> 00:49:16.020
you would want to set your views
up correctly for landscape mode.

00:49:16.030 --> 00:49:19.480
And an easy way of doing this is just
in Interface Builder if you have a view,

00:49:19.520 --> 00:49:22.260
just change the size in
the size inspector to be,

00:49:22.260 --> 00:49:24.280
you know,
whatever the appropriate size is

00:49:24.330 --> 00:49:26.340
depending on the state of the status bar.

00:49:26.340 --> 00:49:32.280
So you'd just set it to wider than tall,
lay out your UI as you would,

00:49:32.320 --> 00:49:35.180
connect an outlet to the view
so that you can access it.

00:49:35.200 --> 00:49:38.600
And then in the application
did finish launching,

00:49:38.610 --> 00:49:41.060
you would want to set
the center of the view,

00:49:41.190 --> 00:49:44.520
set the rotation, transform on the view.

00:49:44.550 --> 00:49:49.250
And an important note here is don't
set the transform on the window itself.

00:49:49.390 --> 00:49:51.740
That's also a very natural thing to do.

00:49:51.740 --> 00:49:53.960
That will not give you the
results that you're looking for.

00:49:53.960 --> 00:49:56.460
That will kind of confuse
some of the event handling.

00:49:56.500 --> 00:50:01.900
So you always want to just rotate or
transform the view inside of the window,

00:50:01.900 --> 00:50:03.020
not the window itself.

00:50:03.020 --> 00:50:04.690
itself.

00:50:05.420 --> 00:50:08.470
So if we look at some code here,
here's an example of application that did

00:50:08.560 --> 00:50:10.180
finish launching where we have a view.

00:50:10.180 --> 00:50:12.070
It's been laid out in landscape mode.

00:50:12.230 --> 00:50:15.280
So we grab the initial
transform of the view.

00:50:15.700 --> 00:50:17.660
And then we have to do some
geometry to kind of figure out,

00:50:17.660 --> 00:50:19.270
you know, where is the status bar?

00:50:19.600 --> 00:50:21.920
Where should the center of my view go?

00:50:21.920 --> 00:50:24.690
Because as the status bar moves
from the top to one of the sides,

00:50:24.690 --> 00:50:28.080
kind of the center position shifts
a little bit up into one side.

00:50:28.140 --> 00:50:31.450
So you can use the geometry of
the status bar frame to do this

00:50:31.450 --> 00:50:36.720
calculation of where is it positioned,
where should my content be positioned?

00:50:37.040 --> 00:50:39.280
And once you've calculated
where the center is,

00:50:39.310 --> 00:50:42.360
you would set the center on the view,
and then you just want to

00:50:42.360 --> 00:50:44.060
rotate it about that center.

00:50:44.130 --> 00:50:46.300
And you just do that by
taking the initial transform,

00:50:46.300 --> 00:50:50.040
applying a rotation transform to it,
and then setting that

00:50:50.040 --> 00:50:51.810
transform back on the view.

00:50:52.710 --> 00:50:54.990
And then lastly,
since we're doing all this before the

00:50:54.990 --> 00:50:57.880
main window has been shown so that
the user doesn't see any of this,

00:50:57.910 --> 00:51:02.000
then you would make the
window visible to the user.

00:51:02.810 --> 00:51:05.740
So that's launching in landscape.

00:51:05.740 --> 00:51:08.880
And then the next topic
is detecting swipes.

00:51:09.060 --> 00:51:13.230
So you've seen in table views
where you can have some content,

00:51:13.230 --> 00:51:16.390
and when the user taps and
swipes their finger to one side,

00:51:16.390 --> 00:51:18.120
we reveal the delete button.

00:51:18.560 --> 00:51:22.150
So if you want to incorporate something
like this into your application,

00:51:22.150 --> 00:51:23.240
it's pretty easy.

00:51:23.240 --> 00:51:26.240
Basically,
what you would do is override touches,

00:51:26.240 --> 00:51:28.660
begin with event,
grab the point where the

00:51:28.670 --> 00:51:31.590
user started the drag,
and then as they moved it,

00:51:31.590 --> 00:51:35.730
you would kind of track where it's being
moved to and answer questions like,

00:51:35.800 --> 00:51:36.890
is it moved far enough?

00:51:36.950 --> 00:51:38.480
Is it in a straight line?

00:51:38.480 --> 00:51:42.540
You might even factor in things
like how fast are they swiping?

00:51:42.540 --> 00:51:47.520
And if the user kind of starts
moving in a direction or in a pattern

00:51:47.520 --> 00:51:48.540
that doesn't look like a swipe,
you can do that.

00:51:48.540 --> 00:51:51.220
You probably want to kind of
stop considering it as a swipe.

00:51:51.230 --> 00:51:54.540
You know, if they move their finger in an
L shape or if they go back and forth,

00:51:54.540 --> 00:51:57.270
you know, that's kind of probably not,
the user's indicating

00:51:57.330 --> 00:52:00.480
they're not swiping,
so you'd probably stop considering it.

00:52:00.520 --> 00:52:03.910
And so here's an example of actually
how the table view would implement this,

00:52:03.910 --> 00:52:06.600
and this is some code that's
actually taken out of UIKit.

00:52:06.600 --> 00:52:09.960
So in the touches begin,
we just grab the starting

00:52:09.960 --> 00:52:13.070
point of the event,
the location in the view,

00:52:13.080 --> 00:52:16.560
and then that's not
particularly interesting.

00:52:16.560 --> 00:52:20.510
Over in touches moved is where the...
the logic really is implemented.

00:52:20.930 --> 00:52:23.450
And we basically grab
the current position,

00:52:23.470 --> 00:52:27.180
we calculate how far has it
moved from the starting point,

00:52:27.320 --> 00:52:31.120
and then in the case of table view,
we just apply some fairly simple

00:52:31.120 --> 00:52:34.880
geometry of have they moved far
enough in the horizontal position

00:52:34.880 --> 00:52:38.880
and yet not too far in the vertical
position to qualify as a swipe?

00:52:38.980 --> 00:52:41.620
And then are they moving to
the left or to the right?

00:52:41.620 --> 00:52:45.050
And then we determine, yes,
it's a swipe and in which direction.

00:52:45.100 --> 00:52:47.510
So this is really, it's very simple.

00:52:47.610 --> 00:52:48.540
It's easily adaptable.

00:52:48.540 --> 00:52:52.690
It's adaptable to vertical swipes
as well if you need to do that.

00:52:52.710 --> 00:52:56.680
And that was where the logic was.

00:52:58.080 --> 00:53:01.030
And now the,
I believe the last topic that I'm going

00:53:01.030 --> 00:53:04.070
to cover is handling interruptions.

00:53:04.250 --> 00:53:06.970
And so on the phone and
even on the iPod Touch,

00:53:07.190 --> 00:53:09.470
there's a number of ways that
your application when it's in

00:53:09.620 --> 00:53:11.170
the front can get interrupted.

00:53:11.270 --> 00:53:15.440
Things like an incoming phone call
or an incoming SMS both on the

00:53:15.590 --> 00:53:19.080
phone and then even on the Touch,
a calendar event may pop

00:53:19.080 --> 00:53:21.660
up an alert for a reminder.

00:53:21.720 --> 00:53:25.550
And so what happens to your application
when one of these interruptions happens?

00:53:25.550 --> 00:53:27.800
Well, right at the time the
interruption happens,

00:53:27.800 --> 00:53:31.300
then some piece of UI is going to
come up on top of your application and

00:53:31.300 --> 00:53:36.720
your application delegate will receive
this application will resign active.

00:53:36.770 --> 00:53:38.480
Your app is still running.

00:53:38.480 --> 00:53:41.780
It's just not,
no longer the active application.

00:53:41.780 --> 00:53:44.530
And the important thing to
do here is that if you are,

00:53:44.530 --> 00:53:48.210
if your app is performing some
action and taking up some CPU,

00:53:48.210 --> 00:53:53.800
you probably want to pause that or
kind of back off on taking up CPU time.

00:53:54.250 --> 00:53:57.400
So, for example, if you're playing a game
or you're writing a game,

00:53:57.400 --> 00:53:59.920
you might want to pause the
game because the user no longer

00:53:59.920 --> 00:54:01.460
is interacting with your game.

00:54:01.460 --> 00:54:04.150
They're interacting with something else.

00:54:04.150 --> 00:54:08.510
Or if you're running an OpenGL app,
you may want to throttle back the

00:54:08.510 --> 00:54:12.320
frame rate that you're updating the
CPU or using the CPU so that the,

00:54:12.750 --> 00:54:15.910
whatever the other interruption,
the UI for the other interruption

00:54:15.910 --> 00:54:17.690
isn't jittery or whatever.

00:54:18.040 --> 00:54:21.770
And in fact, the template for the
OpenGL projects in Xcode,

00:54:21.770 --> 00:54:24.500
you'll see that there is an
implementation of application

00:54:24.500 --> 00:54:27.350
will resign active where we do
actually throttle back the CPU.

00:54:27.420 --> 00:54:29.260
automatically.

00:54:30.370 --> 00:54:33.550
And then given this interruption,
the user has two choices.

00:54:33.600 --> 00:54:36.190
They can either accept the interruption,
in which case we're going

00:54:36.190 --> 00:54:39.990
to take them somewhere else,
to the phone app, to SMS, to calendar,

00:54:39.990 --> 00:54:41.400
to view the invite.

00:54:41.450 --> 00:54:44.640
Or they may decline the interruption,
in which case they'll go

00:54:44.650 --> 00:54:46.240
back to your application.

00:54:46.320 --> 00:54:49.360
So in the first case,
your app will actually get terminated.

00:54:49.360 --> 00:54:51.660
And it's no different than if
the user hit the Home button.

00:54:51.710 --> 00:54:54.420
You'll get an application will terminate.

00:54:54.460 --> 00:54:56.890
You should clean up your state,
save anything,

00:54:56.890 --> 00:54:58.420
and then the app will exit.

00:54:58.450 --> 00:55:02.260
In the second case where
they reject the interruption,

00:55:02.300 --> 00:55:05.660
your app will get application
did become active.

00:55:05.660 --> 00:55:07.200
And then we just go back to your app.

00:55:07.200 --> 00:55:09.450
You come to the front and you can
resume whatever it is you're doing.

00:55:12.890 --> 00:55:19.180
So following down the path of the
user did accept the interruption,

00:55:19.210 --> 00:55:21.290
they could-- let's say
they go to the phone.

00:55:21.440 --> 00:55:24.380
The rest of these are all
kind of in-call scenarios.

00:55:24.440 --> 00:55:28.600
They could go to the phone, menu out,
and go back to your application.

00:55:28.700 --> 00:55:48.200
[Transcript missing]

00:55:48.980 --> 00:55:54.110
In order to do that,
if you are using view controllers,

00:55:54.250 --> 00:55:57.420
they'll kind of account for that
automatically and your view will

00:55:57.420 --> 00:56:00.110
simply be resized to make it shorter.

00:56:00.240 --> 00:56:03.910
If you're not using view controllers,
you may need to pay attention

00:56:03.910 --> 00:56:05.410
to the status bar frame.

00:56:06.920 --> 00:56:09.540
One thing,
one case to watch out for is when the,

00:56:09.540 --> 00:56:12.870
if let's say you're in this call,
you come back to your app,

00:56:12.870 --> 00:56:16.060
you have this beautiful
double high status bar.

00:56:16.060 --> 00:56:19.780
If the call ends on the remote side,
the status bar will actually shrink

00:56:20.080 --> 00:56:23.370
back down to its default state
and your content will be resized

00:56:23.630 --> 00:56:25.480
taller to get those pixels back.

00:56:25.540 --> 00:56:28.150
So you just want to,
this is something you want to kind

00:56:28.230 --> 00:56:31.420
of incorporate into some testing
where you want to make sure you

00:56:31.420 --> 00:56:33.360
account for that space properly.

00:56:33.360 --> 00:56:36.550
And the best way to do that using
view controllers is just rely

00:56:36.550 --> 00:56:39.790
on the springs and struts and
the auto resizing of the views.

00:56:40.150 --> 00:56:42.310
Because then things will
just kind of naturally,

00:56:42.310 --> 00:56:45.560
you know, slide back into place and
it'll look very natural.

00:56:45.560 --> 00:56:51.690
And one last case to keep an eye out for
is not only is there the portrait case,

00:56:51.800 --> 00:56:54.710
but there's also the landscape case where
you have the double high status bar there

00:56:54.710 --> 00:56:56.340
where you've lost that height as well.

00:56:59.900 --> 00:57:03.280
So that's just, that's the list of topics
that we wanted to cover here.

00:57:03.280 --> 00:57:07.360
I think, where's Malcolm?

00:57:07.360 --> 00:57:10.060
We're going to have a,
no presentation is actually

00:57:10.060 --> 00:57:13.350
complete until we have
Malcolm Crawford come up on stage.

00:57:13.350 --> 00:57:16.060
And in this case,
we're going to have Malcolm come

00:57:16.460 --> 00:57:20.070
up and do a demo of configuring
tab bars in Interface Builder.

00:57:20.070 --> 00:57:21.240
Is that right?

00:57:21.240 --> 00:57:21.780
Yes.

00:57:21.780 --> 00:57:22.280
Excellent.

00:57:22.520 --> 00:57:25.900
So a question that's come up
on a couple of occasions during

00:57:26.160 --> 00:57:29.770
the last few days has been,
how do you actually set up the recipes

00:57:29.840 --> 00:57:32.090
example using Interface Builder?

00:57:32.350 --> 00:57:34.060
So just to remind you.

00:57:36.120 --> 00:57:42.980
The Recipes application as it stands
at the moment appears with a tab bar

00:57:43.060 --> 00:57:47.710
controller at the bottom and then
a couple of navigation controllers.

00:57:49.090 --> 00:57:51.800
So that, as you all know,
is currently set up using code.

00:57:51.880 --> 00:57:55.290
So let's see how we actually migrate
that across to Interface Builder.

00:57:55.380 --> 00:57:59.550
So I've got a copy of
the project then that

00:58:00.450 --> 00:58:05.020
has an empty,
the original main window nib

00:58:05.020 --> 00:58:08.010
file with no tab bar controllers.

00:58:08.010 --> 00:58:12.190
If I build and run this,
you'll see then that nothing comes up.

00:58:12.540 --> 00:58:16.420
So to this we have to add the
navigation controllers within

00:58:16.420 --> 00:58:18.650
then the tab bar controllers.

00:58:18.790 --> 00:58:24.460
So if I go back to interface builder,
first of all, I'll drag out into here.

00:58:26.690 --> 00:58:31.710
The Tab Bar Controller and
remind myself then to connect.

00:58:34.300 --> 00:58:36.900
The Recipes application delegate to that.

00:58:36.900 --> 00:58:41.400
Now then we have to configure the tab
bar controller itself and actually put

00:58:41.400 --> 00:58:43.700
those navigation items within that.

00:58:43.830 --> 00:58:47.440
For that, personally I find it easier
to go into the outline view

00:58:47.440 --> 00:58:48.990
mode in Interface Builder.

00:58:49.140 --> 00:58:54.200
We don't now need the
original two view controllers.

00:58:54.200 --> 00:59:01.390
What we do need are the two navigation
controllers in the right place.

00:59:02.100 --> 00:59:25.700
[Transcript missing]

00:59:27.450 --> 00:59:36.960
If I now add a second navigation
item and swap the order and

00:59:36.960 --> 00:59:38.400
inspect its view controller,

00:59:39.970 --> 00:59:46.720
I can set that now to be an instance of
the unit converter table view controller.

00:59:46.840 --> 00:59:50.140
The other thing that I have to
do is as a slight difference in

00:59:50.140 --> 00:59:55.350
this version of the application,
because in the initialization method

00:59:55.350 --> 01:00:01.270
for the first recipe list controller,
we actually passed the recipes controller

01:00:01.270 --> 01:00:03.460
as part of the initialization method.

01:00:03.460 --> 01:00:06.350
In this implementation,
I actually have to connect the recipes

01:00:06.390 --> 01:00:11.410
app delegate now to the recipe list
table view controller so that it can then

01:00:11.540 --> 01:00:13.960
separately pass the recipe controller.

01:00:13.960 --> 01:00:15.840
And I'll show the code
for this afterwards.

01:00:15.940 --> 01:00:21.700
So that should then be all of the code,
all of the actual setup that's required.

01:00:21.760 --> 01:00:24.270
And now I'm back in the
position where I was before.

01:00:26.040 --> 01:00:29.640
So that's setting up then the
interface in Interface Builder.

01:00:29.640 --> 01:00:33.130
I can actually extend that a little
bit further just for the sake of it.

01:00:33.480 --> 01:00:35.840
So if I go back into interface builder,
let's suppose that we're so

01:00:35.980 --> 01:00:40.890
excited by the weight converter
that I actually want to bring that

01:00:40.890 --> 01:00:44.940
up as a view controller by itself.

01:00:44.970 --> 01:00:50.550
I can add that then as the first
item within the tab bar controller

01:00:50.550 --> 01:00:56.820
itself and set the class there.

01:01:10.470 --> 01:01:18.560
Oh, and I've,
and... Just to show that demos

01:01:18.560 --> 01:01:25.750
need to be practiced beforehand,
set the nib file for

01:01:25.750 --> 01:01:25.750
that view controller.

01:01:33.600 --> 01:01:37.200
So that's then illustrated adding a
separate view controller separately to

01:01:37.200 --> 01:01:39.040
the top level in the tab bar controller.

01:01:39.040 --> 01:01:42.180
If we look then at the
differences in the code,

01:01:42.180 --> 01:01:44.660
it's probably actually easiest
to see that in file merge.

01:01:44.660 --> 01:01:47.900
So the most significant
difference is actually in the

01:01:47.900 --> 01:01:50.000
application delegate itself.

01:01:50.000 --> 01:01:52.510
So first of all,
I mentioned that we had a separate

01:01:52.740 --> 01:01:56.220
connection now to the Recipe
List Table View Controller because

01:01:56.220 --> 01:01:58.940
we want to pass the Recipes
Controller to that view.

01:01:58.940 --> 01:02:03.420
All of the code then for actually
creating a navigation controller and

01:02:03.420 --> 01:02:05.040
the separate view controllers is gone.

01:02:05.040 --> 01:02:07.680
That's all managed now
in Interface Builder.

01:02:09.070 --> 01:02:12.980
As far as the other ones are concerned,
the significant difference that may

01:02:13.090 --> 01:02:16.480
have tripped up some people as they're
migrating code to Interface Builder is,

01:02:16.540 --> 01:02:19.920
remember the units that you put into,
or the elements that you put into your

01:02:19.940 --> 01:02:22.080
Interface Builder file are now archived.

01:02:22.160 --> 01:02:24.440
So rather than, oh,
did I hear a few ohs in

01:02:24.440 --> 01:02:26.210
the audience there perhaps?

01:02:26.240 --> 01:02:32.100
So rather now than calling init with the
name to whatever for your initialization,

01:02:32.200 --> 01:02:36.240
you have to implement init with coder,
since these are now

01:02:36.550 --> 01:02:38.150
going to be unarchived.

01:02:38.660 --> 01:02:42.720
So init with coder now in the
recipe list table view controller

01:02:43.270 --> 01:02:45.780
and in the unit converter.

01:02:45.780 --> 01:02:50.420
So for those of you who wanted to know,
that's then how you can convert

01:02:50.420 --> 01:02:54.520
the existing recipes example
to using Interface Builder.

01:02:54.540 --> 01:02:58.340
And can I just quickly
get a show of hands?

01:02:58.390 --> 01:03:01.450
One of the ironies for this for me has
been that for the last decade or two,

01:03:01.450 --> 01:03:04.420
people have been wanting to see how
do you do all that stuff that you're

01:03:04.420 --> 01:03:07.900
doing in Interface Builder actually
in code because it's too abstract.

01:03:08.240 --> 01:03:08.940
and

01:03:09.940 --> 01:03:13.980
So now we're left with this sort
of ironic position where now you

01:03:13.980 --> 01:03:16.900
actually do want to see things in
interface builder rather than in code.

01:03:16.900 --> 01:03:19.280
So quick show of hands please.

01:03:19.280 --> 01:03:26.180
Who would like to see the recipes
example converted to interface builder?

01:03:26.180 --> 01:03:28.770
And who would like it left as it is?

01:03:30.400 --> 01:03:38.460
So, I'll see if we can do both, but okay,
thank you to John Hess then for getting

01:03:38.460 --> 01:03:39.580
most of Interface Builder working.

01:03:39.580 --> 01:03:42.130
The other thing then that...

01:03:48.420 --> 01:03:54.180
The other thing that came up in
the last session was how do you use

01:03:54.430 --> 01:03:58.190
interface builder for table view cells.

01:03:58.190 --> 01:04:01.400
And it just so happens that
I wrote a demo for that as well.

01:04:03.580 --> 01:04:08.900
So let's just first of all
bear in mind the caution that

01:04:08.900 --> 01:04:12.010
Jason gave in the previous session.

01:04:12.310 --> 01:04:18.440
The idea here is to provide you with some
catharsis to show that this can be done.

01:04:18.480 --> 01:04:19.600
You'll see that it can be done.

01:04:19.600 --> 01:04:21.160
Hopefully, that'll satisfy everybody.

01:04:21.160 --> 01:04:22.520
Don't do this at home.

01:04:24.860 --> 01:04:32.920
So the main resource that we
have here is a table view cell.

01:04:34.700 --> 01:04:59.300
[Transcript missing]

01:04:59.840 --> 01:05:03.120
If we have a look at the project then,
there's not an awful

01:05:03.120 --> 01:05:04.420
lot of code in there.

01:05:04.490 --> 01:05:07.970
The principle one,
the principle method is the table view

01:05:07.970 --> 01:05:10.510
cell for row at index path method.

01:05:10.510 --> 01:05:19.700
And whereas typically in this method we
would actually create programmatically

01:05:19.700 --> 01:05:20.810
the instance of the table view cell,
here we'll actually

01:05:20.810 --> 01:05:20.810
just load the nib name.

01:05:21.980 --> 01:05:24.700
TV Cell with Self as Owner.

01:05:24.700 --> 01:05:27.740
That will then point
our instance variable,

01:05:27.740 --> 01:05:32.520
a TV cell instance variable,
at the new cell that's been loaded.

01:05:32.600 --> 01:06:29.600
[Transcript missing]
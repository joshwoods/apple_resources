WEBVTT

00:00:20.500 --> 00:00:21.270
Good morning.

00:00:21.460 --> 00:00:23.100
My name is Julio González.

00:00:23.240 --> 00:00:26.410
I'm the manager of the
talk group at Apple.

00:00:27.130 --> 00:00:32.040
Today, I want to give you a bird's-eye
view of the Text system in Mac OS X.

00:00:32.040 --> 00:00:36.120
It's going to be great for
you if you're new to Mac OS X,

00:00:36.120 --> 00:00:38.450
but I'll also mention some
of the new features that we

00:00:38.450 --> 00:00:41.180
have in Text in Snow Leopard.

00:00:41.180 --> 00:00:45.910
I will talk,
I will try to just touch on the

00:00:45.990 --> 00:00:50.470
APIs that you would commonly use
and areas that might interest you.

00:00:50.480 --> 00:00:55.320
I will not go into very deep details
in each one of the Text systems,

00:00:55.460 --> 00:00:57.710
otherwise this could take far too long.

00:00:57.740 --> 00:01:00.500
I'll also point out some of the
pitfalls that you might run into

00:01:00.500 --> 00:01:03.510
and some special catches when
you deal with the Text system.

00:01:04.950 --> 00:01:06.730
I'll also talk about fonts.

00:01:06.740 --> 00:01:11.290
There are many ways that our users
have to install fonts in the system

00:01:11.910 --> 00:01:13.780
and when to make them available.

00:01:13.850 --> 00:01:17.230
And there are some gotchas, too,
that you might fall into when

00:01:17.240 --> 00:01:19.290
you're dealing with fonts.

00:01:19.810 --> 00:01:24.620
So, up on the slide,
we have all the major text

00:01:24.620 --> 00:01:27.200
subsystems in Mac OS X.

00:01:27.230 --> 00:01:31.920
I want to point out to you that if you
go on the online text documentation,

00:01:31.940 --> 00:01:35.010
or you pick up your favorite book
and programming map for Mac OS X,

00:01:35.100 --> 00:01:38.830
you're going to see other text
or systems that deal with text.

00:01:39.120 --> 00:01:41.140
I strongly encourage you
to stay away from those.

00:01:41.260 --> 00:01:46.870
You have no need to get into those to
write a successful Mac OS X application.

00:01:47.030 --> 00:01:49.820
So, the bottom layer is Quartz.

00:01:49.910 --> 00:01:52.760
Quartz is our glyph rendering engine.

00:01:52.800 --> 00:01:54.500
The middle sits Core Text.

00:01:54.570 --> 00:01:57.350
Core Text does all the
font file management,

00:01:57.490 --> 00:02:01.740
font access,
and Unicode text layout for the system.

00:02:01.780 --> 00:02:03.010
And on top sits Cocoa.

00:02:03.300 --> 00:02:05.030
Cocoa is the whole package.

00:02:05.230 --> 00:02:08.580
If you're dealing with text,
this is where you want to be.

00:02:08.610 --> 00:02:11.720
It covers input, covers layout,
covers everything.

00:02:11.720 --> 00:02:15.380
It can handle everything
automatically for you,

00:02:15.410 --> 00:02:16.920
or it's highly customized.

00:02:16.920 --> 00:02:18.380
possible.

00:02:19.090 --> 00:02:20.660
Now fonts.

00:02:20.740 --> 00:02:24.660
OS X ships with a large amount of,
or collection of fonts.

00:02:24.820 --> 00:02:28.000
Over 100 font families
and 200 font faces.

00:02:28.120 --> 00:02:32.000
This allows us to support the major
writing systems and major languages.

00:02:32.000 --> 00:02:35.100
And we support all the
major font formats:

00:02:35.230 --> 00:02:41.000
TrueType, PostScript, OpenType,
and some legacy font formats as well.

00:02:41.140 --> 00:02:45.470
Now, in OS X, users, as I said before,
have many ways to install

00:02:45.690 --> 00:02:47.000
fonts in the system.

00:02:47.000 --> 00:02:51.000
And this is something you,
as a developer, need to be aware of.

00:02:51.160 --> 00:02:54.180
Because if you deal with
fonts in your application,

00:02:54.180 --> 00:02:58.000
and you have some sort of
font menu that you handle,

00:02:58.000 --> 00:03:01.300
you need to be aware that the
font set that your application

00:03:01.300 --> 00:03:02.820
starts with is not static.

00:03:03.220 --> 00:03:07.510
The user may change this at any time.

00:03:09.020 --> 00:03:11.790
The most common ways for users to
make fonts available to the system

00:03:11.900 --> 00:03:16.510
is to install them in one of the
known font locations to the system.

00:03:16.740 --> 00:03:19.660
At the bottom is the
system font location.

00:03:20.140 --> 00:03:23.370
This location is for fonts
that are fundamental to the OS.

00:03:23.590 --> 00:03:27.520
We strongly discourage any applications
to install fonts here or for the users

00:03:27.520 --> 00:03:30.610
to install fonts in this location,
and especially not remove them.

00:03:30.700 --> 00:03:34.380
The next location is the local location,
library fonts,

00:03:34.730 --> 00:03:38.590
and these fonts are also available
to everybody in the system and

00:03:38.710 --> 00:03:40.880
every process of the system.

00:03:41.370 --> 00:03:45.200
The difference is that this is the
location where we encourage you as an

00:03:45.270 --> 00:03:49.830
application developer to install fonts
that users will use for content creation.

00:03:50.060 --> 00:03:53.920
So it's not only available to your apps,
but it's also available to

00:03:53.920 --> 00:03:57.230
other apps that might need
the font for their content.

00:03:57.410 --> 00:03:59.300
Next is the network location.

00:03:59.360 --> 00:04:02.380
And typically this location is only
available to those users that are in

00:04:02.380 --> 00:04:07.300
a network file system whose network
administrator has enabled this location.

00:04:07.470 --> 00:04:10.680
These fonts are available to everybody,
everybody who has access to

00:04:10.680 --> 00:04:14.260
the network and every process
that is actively using it.

00:04:14.440 --> 00:04:16.300
Finally, there is the user location.

00:04:16.300 --> 00:04:18.300
It's in your home
directory library fonts.

00:04:18.300 --> 00:04:22.450
And this is the location where users
would install fonts that they purchase or

00:04:22.450 --> 00:04:25.300
that otherwise acquire for personal use.

00:04:25.300 --> 00:04:28.630
Now, you as an application developer
might want to install fonts in

00:04:28.730 --> 00:04:32.380
this location if you know that
you're dealing with a setting,

00:04:32.380 --> 00:04:35.630
say a university setting,
where many users will be sharing the

00:04:35.630 --> 00:04:41.230
computer and your font licenses for your
applications do not cover multiple users.

00:04:41.380 --> 00:04:44.300
One thing to note about these locations.

00:04:44.300 --> 00:04:49.300
If, as part of your application
or as sort of your bundle,

00:04:49.300 --> 00:04:52.820
you have what we call a daemon process,
a process that runs outside

00:04:52.970 --> 00:04:55.780
of the user session,
those processes do not have

00:04:55.830 --> 00:04:57.300
access to all the fonts.

00:04:57.300 --> 00:05:01.170
They only have access to the
system and to the local fonts.

00:05:01.300 --> 00:05:03.300
You won't have access to the user fonts.

00:05:03.300 --> 00:05:07.300
Now, if you have a background process
that's what we call an agent,

00:05:07.300 --> 00:05:11.390
runs within the user session,
you have the same fonts,

00:05:11.390 --> 00:05:15.180
access to the same fonts that
the rest of the processes do.

00:05:15.620 --> 00:05:20.500
Another way for users to install fonts
is to use font management applications.

00:05:20.730 --> 00:05:25.050
Typically, users of these applications
will create sets or libraries

00:05:25.060 --> 00:05:29.500
of fonts that they enable or
register and unregister on demand.

00:05:29.500 --> 00:05:32.400
OS X ships with such an application.

00:05:32.500 --> 00:05:32.500
It's called FontBook.

00:05:32.530 --> 00:05:35.740
But there are many third-party
applications that have actually an

00:05:36.120 --> 00:05:41.290
enhanced set or have more features than
FontBook does and do a good job at it.

00:05:42.100 --> 00:05:46.280
Applications may install
their own fonts as well.

00:05:46.500 --> 00:05:49.460
There are APIs that I'll
show you later that allow the

00:05:49.460 --> 00:05:51.500
application to register fonts.

00:05:51.500 --> 00:05:55.260
They can even register them
privately so that it cannot be

00:05:55.350 --> 00:05:57.500
seen by the rest of the system.

00:05:57.500 --> 00:05:59.310
I'll show you an example of that.

00:05:59.500 --> 00:06:04.500
And finally, fonts may be auto-activated
on the user's behalf.

00:06:04.500 --> 00:06:10.500
This is something that has been present
in the OS for many releases now.

00:06:10.510 --> 00:06:14.430
And it was only enabled if you use a
third-party font management application.

00:06:15.110 --> 00:06:19.490
Starting with Snow Leopard,
this is on by default.

00:06:19.530 --> 00:06:22.710
So the way it works,
if Spotlight can find a font

00:06:22.820 --> 00:06:25.800
file in one of your disks,
it will be made available

00:06:25.810 --> 00:06:28.470
to any application or
document that requests this.

00:06:30.670 --> 00:06:33.840
So,
before we get into the text architecture,

00:06:33.840 --> 00:06:36.590
let's just get some
fundamentals out of the way.

00:06:36.920 --> 00:06:40.600
Before we can draw text on the screen,
we need fonts.

00:06:40.640 --> 00:06:43.450
And fonts,
from a high-level point of view,

00:06:43.730 --> 00:06:46.790
is basically a collection of
glyphs that same as similar

00:06:46.790 --> 00:06:48.600
design pattern or purpose.

00:06:48.600 --> 00:06:52.600
A glyph is a graphical
representation of a character.

00:06:52.600 --> 00:06:55.340
So, typically the simple fonts
have one glyph per character,

00:06:55.460 --> 00:06:56.600
typically Western fonts.

00:06:56.630 --> 00:07:00.880
But, that's not to say that the
more complex modern fonts can't

00:07:00.880 --> 00:07:02.600
have multiple representations.

00:07:02.600 --> 00:07:06.540
Up on the slide, we have Zapfino,
and you can see that it has multiple

00:07:06.540 --> 00:07:08.600
glyphs with the capital letter A.

00:07:08.600 --> 00:07:12.700
Now, fonts supporting complex
writing systems such as Arabic,

00:07:12.700 --> 00:07:17.600
it's a must that they have multiple
glyphs that represent a single character.

00:07:19.930 --> 00:07:21.960
Now,
what are the fundamental font types that

00:07:21.970 --> 00:07:23.400
you're going to be dealing with OS X?

00:07:23.460 --> 00:07:25.800
Up on the slide, we have them.

00:07:25.800 --> 00:07:30.600
We have on the top the Cocoa font types
and the bottom the Core Text font types.

00:07:30.650 --> 00:07:34.100
I must warn you again,
if you go to the online documentation

00:07:34.100 --> 00:07:36.900
or you pick up your favorite
book on programming for OS X,

00:07:36.950 --> 00:07:38.800
you will see other font types.

00:07:38.910 --> 00:07:39.680
Stay away from those.

00:07:39.870 --> 00:07:41.190
They're just for legacy.

00:07:41.260 --> 00:07:43.850
You don't need them to program in OS X.

00:07:43.970 --> 00:07:47.400
So, first let's start with the font.

00:07:47.420 --> 00:07:52.200
By the way, these fonts,
the Cocoa fonts and the Core Text fonts,

00:07:52.200 --> 00:07:54.000
are what we call toll-free bridge.

00:07:54.000 --> 00:07:56.050
So,
you can interchange them in either layer.

00:07:56.200 --> 00:07:57.660
So, let's start with the font.

00:07:57.790 --> 00:08:02.400
A font is a concrete font reference,
a strike, if you will,

00:08:02.400 --> 00:08:04.800
into the font family.

00:08:04.800 --> 00:08:08.010
So,
the font is what you will use when you

00:08:08.060 --> 00:08:10.370
need to draw something on the screen.

00:08:10.400 --> 00:08:12.180
It's what you will use
if you need to get,

00:08:12.260 --> 00:08:13.530
say, glyph information.

00:08:13.600 --> 00:08:16.500
You need to get font metrics information.

00:08:16.520 --> 00:08:17.300
You need to get some glyphs.

00:08:17.310 --> 00:08:19.100
You need to get some character mappings.

00:08:19.100 --> 00:08:22.300
That's the reference that you will use.

00:08:22.300 --> 00:08:28.100
A font descriptor is a way for you to
establish what font you want to use.

00:08:28.100 --> 00:08:31.620
It is sort of an abstract
representation of a font.

00:08:31.740 --> 00:08:35.100
If you come from the Windows world,
it's akin to a log font.

00:08:35.100 --> 00:08:38.170
So, you specify a bunch of
attributes that best describe

00:08:38.250 --> 00:08:40.500
the font that we want to use,
that you want to use,

00:08:40.500 --> 00:08:42.550
and the system will get that for you.

00:08:43.800 --> 00:08:50.700
Mac OS X is built entirely using Unicode.

00:08:50.900 --> 00:08:55.700
The fundamental type to represent
Unicode on Mac OS X is using the string.

00:08:55.700 --> 00:09:01.700
CFString if you're using Core Foundation,
NSString if you're using Cocoa.

00:09:01.820 --> 00:09:04.700
And there are many ways that
you can create the strings.

00:09:04.700 --> 00:09:06.580
You can create them
directly by using Unicode,

00:09:06.740 --> 00:09:09.700
UTF-8, 16, 32.

00:09:09.700 --> 00:09:12.700
You can create the strings using
some of the standard encodings.

00:09:12.700 --> 00:09:17.700
There are conversion APIs that
NSString provides for you to use those.

00:09:17.930 --> 00:09:21.060
And also,
there are APIs given to you so that if

00:09:21.060 --> 00:09:25.710
you're dealing with an external file
system or I should say you're dealing

00:09:25.860 --> 00:09:31.330
with another file system or architecture,
you don't need to worry about things

00:09:31.620 --> 00:09:33.700
such as byte order mark or decomposition.

00:09:33.700 --> 00:09:36.540
The APIs will handle this for you.

00:09:36.700 --> 00:09:42.600
Now, our Core Text engine and
Cocoa Text engines use a higher

00:09:42.600 --> 00:09:44.700
level construct to operate.

00:09:44.700 --> 00:09:46.590
And that's the attributed string.

00:09:46.700 --> 00:09:49.700
The attributed string is
basically the base string,

00:09:49.700 --> 00:09:52.700
the Unicode string for
all intents and purposes,

00:09:52.700 --> 00:09:56.540
and a set of attributes that define
what you want to do on that string.

00:09:56.960 --> 00:09:59.700
Think of it as a rich
text representation.

00:09:59.700 --> 00:10:03.700
The neat thing is if
you're at the Cocoa layer,

00:10:03.770 --> 00:10:06.700
you can have a set of APIs that
allow you to construct the strings

00:10:06.700 --> 00:10:10.700
from standard font documents,
such as HTML,

00:10:10.700 --> 00:10:10.700
or I should say file formats, etc.

00:10:10.760 --> 00:10:17.700
And finally,
typically if you are a good programmer,

00:10:17.700 --> 00:10:19.600
a good citizen,
you're not going to be hard coding

00:10:19.690 --> 00:10:21.570
strings into your application.

00:10:21.860 --> 00:10:24.700
You're going to be dealing
with some form of strings file,

00:10:24.700 --> 00:10:28.650
some sort of resource strings
that can be localized.

00:10:28.730 --> 00:10:30.700
So, let's talk about the core code.

00:10:31.930 --> 00:10:34.990
So, let's get into the text architecture.

00:10:35.210 --> 00:10:37.440
At the very bottom is Quartz.

00:10:37.540 --> 00:10:39.540
Quartz, as I said,
is a glyph rendering engine.

00:10:39.690 --> 00:10:42.550
It has no idea about doing text layout.

00:10:42.810 --> 00:10:44.940
What it does is to layout glyphs.

00:10:45.120 --> 00:10:48.850
So, if that's the case,
why should you use Quartz at all?

00:10:49.100 --> 00:10:51.160
And by the way,
you might catch me as lip-syncing.

00:10:51.160 --> 00:10:53.850
Core graphics is the
same thing as Quartz.

00:10:53.930 --> 00:10:56.820
Anyhow.

00:10:56.990 --> 00:10:59.540
You might have some valid
reasons for using Quartz,

00:10:59.540 --> 00:11:03.570
and that is if you have a very
specialized text layout engine,

00:11:03.780 --> 00:11:08.170
you're working outside of the norm,
you're not handling Unicode.

00:11:08.200 --> 00:11:10.650
You might want to be in this space.

00:11:10.700 --> 00:11:13.970
You have a set of code from many,
many years ago where

00:11:13.970 --> 00:11:15.700
you control everything.

00:11:15.760 --> 00:11:18.770
You can then be at the
Quartz level if you need to.

00:11:18.790 --> 00:11:20.760
Another reason might be speed.

00:11:20.760 --> 00:11:23.800
You are at the lowest level
of the text architecture.

00:11:23.920 --> 00:11:25.980
You want to have that speed.

00:11:26.850 --> 00:11:28.140
There might be reasons to be in Quartz.

00:11:28.280 --> 00:11:31.200
Now, I must warn you,
both Core Text and Cocoa are

00:11:31.200 --> 00:11:33.040
highly optimized for speed.

00:11:33.080 --> 00:11:35.650
So unless you want to take
some of the shortcuts that I'll

00:11:35.650 --> 00:11:38.730
mention in the next few slides,
that speed that you might gain

00:11:38.740 --> 00:11:42.970
by using Quartz might not be
necessarily what you want.

00:11:43.450 --> 00:11:47.150
Now, seriously, why shouldn't you use it?

00:11:47.290 --> 00:11:50.080
Well, most of your users are not going
to be feeding glyphs to you.

00:11:50.080 --> 00:11:53.840
You're going to be dealing with text,
and typically Unicode.

00:11:54.110 --> 00:11:58.550
So Quartz has no idea about
how to deal with Unicode text.

00:11:58.740 --> 00:12:01.380
It has no idea how to do layout.

00:12:01.640 --> 00:12:04.740
It just knows how to deal with glyphs.

00:12:04.930 --> 00:12:09.500
Finally, it has no knowledge on how
to do font substitution.

00:12:09.500 --> 00:12:11.830
If you're dealing with a
font and it can't render one

00:12:11.830 --> 00:12:17.480
of the glyphs that you need,
you'll just guess a box for that glyph.

00:12:17.500 --> 00:12:20.840
So, given that,
here are some of the APIs that

00:12:20.920 --> 00:12:23.380
you can use at the Quartz level.

00:12:23.510 --> 00:12:28.500
This first one, CGContextShowTextAtPoint,
is sort of a deceiving API.

00:12:28.500 --> 00:12:31.390
You see this API and you say, "Oh,
I can be drawing text

00:12:31.530 --> 00:12:35.350
using Quartz." Well,
if you take note of the fourth parameter,

00:12:35.470 --> 00:12:36.380
it's a char string.

00:12:36.490 --> 00:12:39.500
It's not a unichar string.

00:12:39.560 --> 00:12:43.500
What it knows how to do is
draw basically ASCII text.

00:12:43.520 --> 00:12:46.330
And, as I'll show you later,
it won't even do a good job at that.

00:12:46.500 --> 00:12:50.710
But now, if you are dealing with...

00:12:50.960 --> 00:12:53.750
You have full knowledge of fonts
and how to get glyphs out of fonts.

00:12:53.930 --> 00:12:57.040
There are some APIs that you
can use to lay out your text,

00:12:57.060 --> 00:13:00.170
and here are two APIs that
you can use to do that.

00:13:00.490 --> 00:13:03.800
So,
let me give you some examples of trying

00:13:03.800 --> 00:13:06.700
to use Quartz for text rendering.

00:13:06.770 --> 00:13:10.340
Here up on the screen,
I have a simple example of drawing the

00:13:10.340 --> 00:13:13.540
word waffle using two different fonts.

00:13:13.600 --> 00:13:17.180
On the top, we have what happens when
you draw it with Quartz,

00:13:17.210 --> 00:13:18.560
and in the bottom,
what happens when you draw

00:13:18.560 --> 00:13:20.810
it with Core Text and Cocoa.

00:13:21.080 --> 00:13:24.660
First thing I want to show
you is Quartz has no idea how

00:13:24.720 --> 00:13:26.560
to properly do any kerning.

00:13:26.630 --> 00:13:31.000
So, you can see how much nicer it
looks when you draw it with Quartz.

00:13:31.030 --> 00:13:37.980
Next thing is Quartz, once again,
has no idea how to deal with ligatures.

00:13:38.130 --> 00:13:40.900
So, both of these fonts
have the FFL ligature,

00:13:40.930 --> 00:13:44.800
and you can see how much nicer
it looks using Quartz and Cocoa.

00:13:45.120 --> 00:13:49.100
This is the way the font designer
intended the text to look.

00:13:49.310 --> 00:13:52.780
Now,
you could say both kerning and ligatures

00:13:52.860 --> 00:13:55.120
are fancy typographical features.

00:13:55.200 --> 00:13:57.200
I really don't need it.

00:13:57.200 --> 00:14:00.190
I want to have all the speed that
I can monster for my application.

00:14:00.200 --> 00:14:03.010
Well, let me give you an example
where that doesn't apply.

00:14:03.500 --> 00:14:06.830
Here I have a French string and
an Arabic string that I'm going

00:14:06.830 --> 00:14:08.200
to use two fonts to draw it with.

00:14:08.200 --> 00:14:13.200
And the first thing you'll notice
is how Quartz doesn't know how

00:14:13.200 --> 00:14:16.120
to properly place the accent
on top of the capital letter E.

00:14:16.200 --> 00:14:19.600
Now, you could say,
"I can live with that." Well,

00:14:19.730 --> 00:14:23.200
if you're dealing with a complex
writing system such as Arabic,

00:14:23.240 --> 00:14:26.390
you can see how horrendously
Core Graphics or Quartz

00:14:26.660 --> 00:14:28.200
does to handle this text.

00:14:28.210 --> 00:14:31.200
You can notice that it doesn't
apply the necessary ligatures.

00:14:31.200 --> 00:14:33.180
And not only that,
if you know how to read Arabic,

00:14:33.280 --> 00:14:37.190
you will notice that those glyphs
are not ordered in the right way.

00:14:37.290 --> 00:14:39.200
They're not ordered right to left.

00:14:39.350 --> 00:14:43.320
Another thing that I want you
to take a cue from this slide is

00:14:43.340 --> 00:14:45.170
that I cheated using this slide.

00:14:45.200 --> 00:14:46.200
If you notice,
I didn't write it in the right order.

00:14:46.200 --> 00:14:48.200
I didn't use the show text at point API.

00:14:48.200 --> 00:14:51.200
I used the show glyphs at point API.

00:14:51.200 --> 00:14:53.040
So how did I get those glyphs?

00:14:53.200 --> 00:14:59.200
I had to go up to Quartz to get those
glyphs to be able to render with them.

00:15:00.820 --> 00:15:03.340
Finally,
here's a sample of font substitution.

00:15:03.550 --> 00:15:07.900
Typically, as a developer,
you're going to be given a stream

00:15:07.910 --> 00:15:10.700
of Unicode or text to render.

00:15:10.700 --> 00:15:14.700
You have no idea what font will
be able to handle that text.

00:15:14.900 --> 00:15:17.700
So you say,
"I'll just pick the system font,

00:15:17.700 --> 00:15:20.530
Lucida Grunt,
to draw it." And you can see what

00:15:20.710 --> 00:15:22.690
Quartz does and what Core Text does.

00:15:22.700 --> 00:15:25.630
Quartz has no idea where
to get the Arabic glyphs.

00:15:25.630 --> 00:15:26.700
Lucida doesn't have it.

00:15:26.700 --> 00:15:31.530
Whereas, Core Text and Cocoa apply the
necessary font substitution.

00:15:33.880 --> 00:15:37.560
Now, you still say, I still want to use
Quartz for my rendering.

00:15:37.560 --> 00:15:39.900
I've got my own layout engine.

00:15:39.900 --> 00:15:44.340
Quartz does provide some ways
for you to access font data,

00:15:44.340 --> 00:15:46.600
so you can get at the glyphs,
get at the metrics.

00:15:46.680 --> 00:15:49.320
So up on the slide,
I have some of the APIs,

00:15:49.390 --> 00:15:52.530
sample of the APIs that
you can find in Quartz.

00:15:52.560 --> 00:15:54.520
There are more in
Quartz that you can use.

00:15:55.140 --> 00:16:00.050
The only thing that I want to warn you
is that these APIs are workable only

00:16:00.160 --> 00:16:02.660
for a subset of the formats out there.

00:16:02.660 --> 00:16:04.000
They work for TrueType fonts.

00:16:04.060 --> 00:16:06.230
They will not work for PostScript fonts.

00:16:06.230 --> 00:16:08.480
You would need to know
how to parse those.

00:16:08.520 --> 00:16:12.590
And even in the case of TrueType,
even though it gives you

00:16:12.590 --> 00:16:16.250
access to the font data,
you still need to know how

00:16:16.360 --> 00:16:18.400
to parse that font data.

00:16:18.400 --> 00:16:21.230
There's no APIs that will
interpret that data for you.

00:16:22.760 --> 00:16:25.620
If you want to be in that
space or not have to do that,

00:16:25.620 --> 00:16:26.850
this is where you want to be.

00:16:27.010 --> 00:16:28.130
You want to be in Core Text.

00:16:28.220 --> 00:16:31.850
Core Text, like I said before,
it provides all the font

00:16:32.120 --> 00:16:33.840
management for the system.

00:16:33.840 --> 00:16:35.640
It provides font access.

00:16:35.730 --> 00:16:38.830
It not only handles all
the font formats out there,

00:16:38.850 --> 00:16:43.080
but it provides APIs that let you get
at the font data and APIs that actually

00:16:43.200 --> 00:16:44.930
interpret the font data for you.

00:16:45.000 --> 00:16:49.410
And finally, it gives you access to,
or it has capabilities of

00:16:49.410 --> 00:16:51.760
doing Unicode text layout.

00:16:51.780 --> 00:16:55.100
It's our base Unicode text
layout engine for the system.

00:16:55.140 --> 00:16:56.220
So.

00:16:57.780 --> 00:17:02.590
Before we start drawing text,
we need to have a font.

00:17:02.670 --> 00:17:07.700
And here is how you can create
a font to use with Core Text.

00:17:07.700 --> 00:17:12.700
Fonts are specific instances,
and if you must create one directly,

00:17:12.700 --> 00:17:17.700
what you need to pass to the
font APIs is a PostScript name.

00:17:17.700 --> 00:17:20.400
Note, do not pass a family name.

00:17:20.780 --> 00:17:22.700
That's a performance degradation.

00:17:22.700 --> 00:17:30.700
The other thing that you need to know
is please pass a proper PostScript name.

00:17:30.700 --> 00:17:33.700
Font names are case sensitive.

00:17:33.700 --> 00:17:37.700
If you pass the wrong font name,
the system is going to try very hard

00:17:37.700 --> 00:17:39.700
to find that font in the system.

00:17:39.930 --> 00:17:43.540
Typically,
when you are dealing with font instances,

00:17:43.760 --> 00:17:46.700
you're in the space of your UI.

00:17:46.950 --> 00:17:51.700
Core Text has a nice API,
the Create UI Font for Language API,

00:17:51.700 --> 00:17:58.620
which allows you to create a font for any
element in the UI that you might need.

00:17:58.700 --> 00:18:01.700
So the first parameter it takes
is the element you can get.

00:18:01.700 --> 00:18:07.530
You can pass a font for a button,
give me the font for a button,

00:18:07.820 --> 00:18:10.530
for drawing a label,
for placing in a menu.

00:18:10.980 --> 00:18:14.810
This API will return the
exact font that you will need

00:18:15.280 --> 00:18:17.620
to use for your application.

00:18:17.700 --> 00:18:19.700
The last parameter is the language.

00:18:19.700 --> 00:18:22.000
Typically, you pass "no" saying,
saying I wanna use the default

00:18:22.110 --> 00:18:25.370
language the user is using.

00:18:25.620 --> 00:18:28.500
And then, if you know exactly the
font that you want to use,

00:18:28.500 --> 00:18:31.230
this is a way that you
can use it or create it.

00:18:31.340 --> 00:18:34.640
You create with name and
pass it a PostScript name.

00:18:34.800 --> 00:18:39.040
And lastly, I have an example of another
API that allows you to convert

00:18:39.270 --> 00:18:40.740
from one face to another.

00:18:40.740 --> 00:18:43.960
In this case,
we're converting from the bold face

00:18:43.960 --> 00:18:47.320
that we had before to an italic face.

00:18:48.200 --> 00:18:49.460
Now, font descriptors.

00:18:49.580 --> 00:18:54.780
This is the recommended way that we
have for you to create font references.

00:18:54.940 --> 00:18:58.480
Once again, these are references that
are abstract in nature.

00:18:58.820 --> 00:19:01.460
You can create a font
reference that says,

00:19:01.510 --> 00:19:02.200
"Give me a font.

00:19:02.220 --> 00:19:04.700
Give me any, say,
italic font in the system.

00:19:04.700 --> 00:19:07.870
That's all I need." Or you can
create a font reference that says,

00:19:07.870 --> 00:19:09.400
you know, it's very specific.

00:19:09.480 --> 00:19:15.620
You specify a family name, a weight,
compression ratio, color,

00:19:15.880 --> 00:19:19.200
any number of attributes,
and the system will provide the

00:19:19.200 --> 00:19:21.540
best matching font for you to use.

00:19:21.600 --> 00:19:24.880
Now, given that,
this is a recommended way that

00:19:24.880 --> 00:19:30.650
we provide for you to store font
references in your documents.

00:19:30.950 --> 00:19:34.670
Given that we create a font
reference from a list of attributes,

00:19:34.940 --> 00:19:38.220
this list of attributes can be
serialized into your documents as well.

00:19:38.340 --> 00:19:39.390
And I'll show you an example.

00:19:39.460 --> 00:19:41.410
I'll show you an example of that later.

00:19:41.420 --> 00:19:46.420
And finally, font substitution is -- you
get for free with Core Text.

00:19:46.420 --> 00:19:47.420
It's on by default.

00:19:47.420 --> 00:19:51.410
But if you need to override it,
there are ways for you to override it.

00:19:51.430 --> 00:19:55.370
And one way to do it is to pass your own
font substitution list or cascade list,

00:19:55.450 --> 00:20:00.420
as we call it, to the descriptor to
override the system behavior.

00:20:00.580 --> 00:20:04.840
So here's an example of -- or the
recommended examples that we have

00:20:04.840 --> 00:20:07.420
for you to create font references.

00:20:07.420 --> 00:20:11.440
If you have a PostScript name,
you can use the first API and

00:20:11.600 --> 00:20:14.430
you pass it a PostScript name,
and it will give you that exact

00:20:14.430 --> 00:20:16.420
font descriptor reference.

00:20:16.570 --> 00:20:19.870
But most of the time,
new developers are dealing with

00:20:19.870 --> 00:20:21.400
font family names and weights.

00:20:21.420 --> 00:20:27.440
This is very typical in the
CSS web space and also typical

00:20:27.440 --> 00:20:32.420
for developers that present ways
to select fonts by their users.

00:20:32.420 --> 00:20:35.420
They typically use a
family name and a weight.

00:20:35.420 --> 00:20:38.350
So this is the way we recommend
that you create your font reference.

00:20:38.420 --> 00:20:43.160
Don't try to create a direct font
reference using a family name.

00:20:43.550 --> 00:20:47.480
Create a font descriptor
using an attribute,

00:20:47.530 --> 00:20:50.420
and the attribute is a dictionary
basically stating what you need.

00:20:50.420 --> 00:20:53.960
And the two attributes that
you need are the family name

00:20:53.960 --> 00:20:56.200
attribute and the face attribute.

00:20:58.330 --> 00:21:04.080
So, up here on the screen is a
more abstract example of how

00:21:04.080 --> 00:21:05.360
to create a font descriptor.

00:21:05.360 --> 00:21:10.200
Say you have a terminal application,
and terminal applications typically

00:21:10.540 --> 00:21:15.420
deal with monospace fonts,
and you want to provide an interface for

00:21:15.420 --> 00:21:20.600
users to pick what font to use in the
case where we need to display some bold

00:21:20.600 --> 00:21:23.440
characters in the terminal application.

00:21:23.440 --> 00:21:27.040
So, you want to create a font
descriptor that basically says,

00:21:27.040 --> 00:21:31.980
"Give me all the fonts that can be
monospaced and can be bold." So,

00:21:32.050 --> 00:21:36.500
the way to create a font descriptor
is first you create your list,

00:21:36.580 --> 00:21:39.120
or let's say dictionary of attributes.

00:21:39.120 --> 00:21:42.130
And in this case,
the dictionary of attributes will only

00:21:42.130 --> 00:21:46.140
have one element that we care about,
and that's a traits attribute.

00:21:46.140 --> 00:21:49.760
The traits attribute in itself is
another dictionary of attributes,

00:21:49.810 --> 00:21:52.240
and the only attribute
that we care about,

00:21:52.390 --> 00:21:54.020
or trait that we care about,
is the subject.

00:21:54.060 --> 00:21:55.020
Symbolic trait.

00:21:55.210 --> 00:21:58.400
And that, in this case,
is a bold and monospace.

00:21:58.400 --> 00:22:02.110
So, once we have our dictionary
defining what we want,

00:22:02.250 --> 00:22:04.790
we can create the font
descriptor with it.

00:22:04.910 --> 00:22:08.730
Now, at this time,
we've just created the font descriptor.

00:22:08.740 --> 00:22:11.840
We haven't resolved the font descriptor.

00:22:11.870 --> 00:22:16.640
If, to make an analogy with SQL,
or SQLite to be precise,

00:22:16.710 --> 00:22:20.500
at this point in time it would
be like if you had executed

00:22:20.600 --> 00:22:22.310
the SQL prepare statement.

00:22:22.380 --> 00:22:23.960
You haven't executed.

00:22:24.030 --> 00:22:25.020
You haven't solved it.

00:22:25.020 --> 00:22:29.720
So, let's say you just want to have one
font that can be monospaced and bold.

00:22:29.720 --> 00:22:35.200
Well, you can get a direct font reference
using the create with font descriptor.

00:22:35.200 --> 00:22:38.050
And now the system will
get you one reference,

00:22:38.050 --> 00:22:41.330
one font that can handle
both of these attributes.

00:22:41.340 --> 00:22:44.270
But like in the example I said,
you want to provide a list

00:22:44.380 --> 00:22:45.850
for your users to pick.

00:22:45.920 --> 00:22:50.970
You can do the same and resolve it
in a way that it gives you a list of

00:22:50.970 --> 00:22:54.010
fonts that can handle both attributes.

00:22:54.100 --> 00:22:56.930
And you can use the create matching
font descriptors to do that.

00:22:57.010 --> 00:23:02.290
It will give you an array of font
descriptors that can handle both

00:23:02.290 --> 00:23:06.020
the monospace and bold in this case.

00:23:06.020 --> 00:23:10.680
Then font descriptors is the
way we recommend that you use

00:23:10.680 --> 00:23:13.220
to store your font references.

00:23:13.220 --> 00:23:17.400
And the reason being, as you can see,
is the font descriptor

00:23:17.600 --> 00:23:20.020
is a list of attributes,
if you will,

00:23:20.180 --> 00:23:22.110
that describe what font you want to use.

00:23:22.120 --> 00:23:25.290
So, once you have the list,
the best way is to grab this

00:23:25.290 --> 00:23:27.640
list and serialize it to this.

00:23:27.640 --> 00:23:31.140
So, if you're starting from a font,
you can always get the best

00:23:31.250 --> 00:23:32.840
descriptor for that font.

00:23:32.840 --> 00:23:36.100
So,
you call the copy font descriptor API.

00:23:36.140 --> 00:23:39.480
Once you have your descriptor,
you can copy the dictionary of

00:23:39.480 --> 00:23:41.680
attributes for that descriptor.

00:23:41.680 --> 00:23:47.130
Now, once you have this dictionary,
you can use any number of

00:23:47.580 --> 00:23:51.780
APIs to serialize or flatten
this data out to this.

00:23:51.780 --> 00:23:54.020
Here, I'm showing you a core foundation.

00:23:54.020 --> 00:23:56.050
You can see that this is a
foundation API that gets -- that

00:23:56.120 --> 00:23:57.510
flattens it out as XML data.

00:23:57.510 --> 00:24:00.590
So, you can write this out to this.

00:24:01.090 --> 00:24:06.140
Now, font substitution, like I said,
is free in Core Text.

00:24:06.140 --> 00:24:08.550
And it's not only free,
it's a pretty sophisticated

00:24:08.620 --> 00:24:09.680
font substitution engine.

00:24:09.680 --> 00:24:13.780
It's not quite lame to say, okay,
my font is missing this glyph,

00:24:13.780 --> 00:24:17.490
just give me any other font
out there that has this glyph.

00:24:17.560 --> 00:24:20.190
No, it is language-specific.

00:24:20.270 --> 00:24:23.650
It takes into account
precedence order of fonts.

00:24:23.690 --> 00:24:25.770
It takes into account traits.

00:24:25.850 --> 00:24:29.060
So if you're dealing with a bold font,
it's going to give you another bold font.

00:24:30.420 --> 00:24:34.070
It looks into things like
compression ratio of the font.

00:24:34.090 --> 00:24:37.150
So if a font is condensed,
it's going to look for another

00:24:37.250 --> 00:24:39.360
font that has similar features.

00:24:39.360 --> 00:24:44.410
So it tries very,
very hard to come up with a font

00:24:44.480 --> 00:24:47.980
that looks very similar to the base
font that you have started with.

00:24:49.730 --> 00:24:54.580
Now, it is on by default,
so if you want to override it, as I said,

00:24:54.620 --> 00:24:59.690
you can do so by passing
your own list of,

00:24:59.690 --> 00:25:03.060
your own cascade list when
you create the descriptor,

00:25:03.060 --> 00:25:05.960
and you use the attribute you
use as a font cascade list

00:25:05.960 --> 00:25:07.970
attribute to define your own list.

00:25:09.280 --> 00:25:11.840
Now,
if you're dealing with Quartz directly,

00:25:11.840 --> 00:25:14.530
and like I said before,
Quartz has no idea how to

00:25:14.530 --> 00:25:17.880
pick up the right font to,
doesn't know how to pick the right

00:25:17.880 --> 00:25:22.290
font to render any appropriate text,
you can come back to Core Text and

00:25:22.610 --> 00:25:26.660
Core Text has an API,
the CT font create for string API,

00:25:26.660 --> 00:25:30.110
that given a range of text,
it'll tell you the best

00:25:30.110 --> 00:25:32.260
font to render the set text.

00:25:35.360 --> 00:25:40.220
Now,
new for OS X Leopard is font management.

00:25:40.520 --> 00:25:43.380
Core Text will now handle all the
font management for the system.

00:25:43.460 --> 00:25:49.590
This replaces legacy functionality
in another text system.

00:25:49.820 --> 00:25:55.420
It provides all the features
that the old legacy system had,

00:25:55.480 --> 00:25:58.860
plus some added functionality that
you developers have been requesting.

00:25:58.890 --> 00:26:01.200
Now, this is not documented elsewhere.

00:26:01.200 --> 00:26:04.960
The only place that we have any
documentation on this is in the header.

00:26:04.960 --> 00:26:07.730
You can find it in the
Core Text framework in the headers,

00:26:07.730 --> 00:26:10.200
ctfontmanager.h.

00:26:10.200 --> 00:26:13.400
So this is the perfect time for you,
if you're interested in font management,

00:26:13.460 --> 00:26:17.460
to peruse what's in the header
and give us any feedback.

00:26:17.560 --> 00:26:22.850
But now I'll talk about the new things
that we provide with font management.

00:26:23.010 --> 00:26:25.940
The first thing is registration APIs.

00:26:25.960 --> 00:26:29.950
Now, what does it mean to register
a font in the system?

00:26:30.030 --> 00:26:34.620
Registering a font means that any of the
font creation APIs that I just showed you

00:26:34.620 --> 00:26:38.270
will be able to get access to that font.

00:26:38.480 --> 00:26:43.180
Or, it means that a user will be able
to see this font in the font picker,

00:26:43.260 --> 00:26:44.340
for example.

00:26:44.340 --> 00:26:44.860
Okay?

00:26:44.860 --> 00:26:48.890
So, there are different ways for
you to make fonts available.

00:26:48.890 --> 00:26:52.660
You can make your fonts available
only to your own process.

00:26:52.780 --> 00:26:55.310
For that, you use the scope process.

00:26:56.280 --> 00:26:59.780
You can make the font available
to every process in the system.

00:26:59.780 --> 00:27:02.680
And for that, you use the scope user.

00:27:02.680 --> 00:27:04.570
And the last one is the same.

00:27:04.570 --> 00:27:08.570
It makes the font available for
every process in the system.

00:27:08.570 --> 00:27:14.000
But once the user logs out or reboots,
the system forgets about that font.

00:27:14.180 --> 00:27:15.400
That's the scope session.

00:27:15.400 --> 00:27:19.310
So, there are two APIs to register fonts.

00:27:19.310 --> 00:27:22.750
The fonts for URL and fonts for URLs.

00:27:22.760 --> 00:27:25.040
The first one takes a font reference.

00:27:25.040 --> 00:27:26.160
Or, a font reference.

00:27:26.220 --> 00:27:27.480
I should say.

00:27:27.480 --> 00:27:29.420
And the scope.

00:27:29.460 --> 00:27:33.560
The second one takes an array
of font file references.

00:27:33.560 --> 00:27:34.740
And the scope.

00:27:38.060 --> 00:27:41.320
Every time a font is
registered with the system,

00:27:41.550 --> 00:27:46.470
the system will notify the processes
that something has changed.

00:27:46.480 --> 00:27:50.700
So you can register with the
distributed notification manager

00:27:50.700 --> 00:27:52.340
to listen to these notifications.

00:27:52.400 --> 00:27:56.510
And this is the string that you would
use to register for notifications.

00:27:56.580 --> 00:28:00.400
Now, as I showed you,
there are two ways to register fonts.

00:28:00.520 --> 00:28:04.790
Every single time a font is registered,
a notification is sent out.

00:28:05.700 --> 00:28:10.330
However, if you use the second
API that I just showed you,

00:28:10.340 --> 00:28:13.780
the Fonts for URL,
only a single notification will be

00:28:13.780 --> 00:28:19.400
sent out when all the fonts that you
pass in the array have been registered.

00:28:19.400 --> 00:28:22.140
Obviously,
there are similar APIs to unregister

00:28:22.140 --> 00:28:23.890
the fonts with similar names.

00:28:23.980 --> 00:28:26.940
Finally,
there is a way for you to enable and

00:28:26.940 --> 00:28:31.590
disable the font descriptors that are
available from each one of the APIs,

00:28:31.600 --> 00:28:34.880
typically something that font
management applications will like to do.

00:28:36.380 --> 00:28:39.000
Now, we have new enumeration APIs.

00:28:39.250 --> 00:28:43.540
Unlike the old legacy APIs,
now you get all the fonts at once.

00:28:43.590 --> 00:28:45.420
No need to create an iterator.

00:28:45.670 --> 00:28:48.100
And also,
the nice thing about this enumeration

00:28:48.100 --> 00:28:54.020
APIs is that the list of font names
that you get is sorted in the same order

00:28:54.150 --> 00:28:58.680
that the font panel has them sorted,
that the system has them sorted.

00:28:58.700 --> 00:29:01.990
Now, let's say that you have your
own family names that are not

00:29:01.990 --> 00:29:04.850
registered with the system,
and you want to present them

00:29:04.920 --> 00:29:08.900
to the user in the same order
fashion that the system provides.

00:29:08.910 --> 00:29:11.480
You can use the
Compare Font Families API to

00:29:11.480 --> 00:29:13.290
do just that.

00:29:13.690 --> 00:29:17.260
There is an API that enumerates
all the font files that are

00:29:17.260 --> 00:29:20.160
registered with the system,
something that font management

00:29:20.160 --> 00:29:22.160
applications typically want to do.

00:29:22.290 --> 00:29:24.160
And this last one, it's a neat API.

00:29:24.160 --> 00:29:26.960
They create font descriptors from URL.

00:29:27.020 --> 00:29:31.600
It enumerates all the descriptors
that a font file can handle.

00:29:31.680 --> 00:29:35.230
Now,
this is typically something that font

00:29:35.640 --> 00:29:40.150
management application might want to use,
but

00:29:40.150 --> 00:29:40.990
It's also neat.

00:29:41.100 --> 00:29:43.560
You might want to use this
API for your own applications.

00:29:43.560 --> 00:29:48.930
The reason is because this is how you
can use a font in your application and

00:29:49.030 --> 00:29:52.390
hide it from the rest of the system,
your own private registration.

00:29:52.460 --> 00:29:55.280
Basically,
you pass it in an arbitrary font file.

00:29:55.280 --> 00:29:58.900
It gives you the font
descriptors that it can handle,

00:29:58.900 --> 00:30:01.110
and you hold on to
those font descriptors,

00:30:01.180 --> 00:30:04.090
and you can pass those font
descriptors to Core Text and

00:30:04.090 --> 00:30:06.760
Cocoa APIs to render text with them.

00:30:07.480 --> 00:30:11.680
If another framework tries to
create or look up for that font,

00:30:11.820 --> 00:30:15.330
it won't find it because it hasn't
been registered with the system.

00:30:17.330 --> 00:30:21.990
Finally,
we have Auto Activation Services.

00:30:22.160 --> 00:30:23.790
This is a new API.

00:30:24.040 --> 00:30:24.890
It's a mouthful.

00:30:25.070 --> 00:30:26.040
"Ct Font Manager.

00:30:26.070 --> 00:30:27.280
Create Font Request.

00:30:27.440 --> 00:30:30.590
Run Loop Source." And this is an
API that you would use if you want to

00:30:30.590 --> 00:30:33.900
implement your own auto activation.

00:30:34.090 --> 00:30:39.530
Notice it takes the new Blocks
API to implement callbacks.

00:30:39.660 --> 00:30:45.760
And I must warn you,
this API is on the developer Snow Leopard

00:30:45.760 --> 00:30:49.340
seed that you received in the conference,
but it's not currently active.

00:30:49.520 --> 00:30:53.730
So just look at it in the
header and provide us any

00:30:53.850 --> 00:30:55.550
feedback that you might have.

00:30:55.600 --> 00:31:04.280
Now, like I said, since Mac OS X Leopard,
auto-activation is on by default.

00:31:04.300 --> 00:31:10.910
And there are ways for you to control the
auto-activation features of the system.

00:31:10.960 --> 00:31:12.350
This is how you go about it.

00:31:12.480 --> 00:31:17.420
You can enable it, disable it,
or prompt the user before the

00:31:17.420 --> 00:31:20.090
auto-activation can take place.

00:31:20.180 --> 00:31:24.360
And you use this API,
the Set Auto-Activation Setting API.

00:31:24.360 --> 00:31:27.790
It takes two parameters,
a bundle identifier and a setting.

00:31:27.800 --> 00:31:32.040
The bundle identifier, typically,
you will pass to your own apps

00:31:32.200 --> 00:31:35.530
bundle identifier and the settings
will only apply to your own app.

00:31:35.580 --> 00:31:37.980
But if you want to turn it
off for the whole system,

00:31:37.980 --> 00:31:42.670
you use the CT font manager bundle
identifier string or identifier to

00:31:43.020 --> 00:31:45.320
apply the setting to the whole system.

00:31:47.870 --> 00:31:50.800
Now, let's get to the exciting part
about Core Text and that's

00:31:50.850 --> 00:31:54.200
its layout capabilities,
the Unicode Text layout capabilities.

00:31:54.380 --> 00:31:59.970
So, like I said, the Core Text takes for
input an attributed string,

00:32:00.080 --> 00:32:03.360
so your base string and a set
of attributes that define it.

00:32:03.490 --> 00:32:07.880
And the first thing that happens is
you deal with two objects that do

00:32:07.880 --> 00:32:10.460
all the heavy lifting in Core Text.

00:32:10.620 --> 00:32:14.100
These are the frame setter
and the type setter.

00:32:14.550 --> 00:32:17.220
The Frame Setter basically
holds all the text,

00:32:17.330 --> 00:32:19.760
and it works in conjunction
with the Type Setter to

00:32:19.760 --> 00:32:23.230
basically position the glyphs,
suggest lines,

00:32:23.230 --> 00:32:27.040
and look at paragraph settings to
just properly lay out the text.

00:32:27.080 --> 00:32:29.250
So how do you go about drawing them?

00:32:29.280 --> 00:32:31.350
It is quite simple using Core Text.

00:32:31.490 --> 00:32:33.140
There's a couple ways.

00:32:33.140 --> 00:32:37.160
You can use a line object or
a frame object or a glyph run.

00:32:37.260 --> 00:32:39.330
The line object is the simplest way.

00:32:39.330 --> 00:32:43.480
You just create a line object
from an attributed string.

00:32:43.910 --> 00:32:46.860
It internally creates a Type Setter,
and it is ready to draw.

00:32:46.880 --> 00:32:52.050
Before you draw, you can apply a set of
calls to it to measure it,

00:32:52.050 --> 00:32:55.210
truncate it, adjust it, in whatever way.

00:32:55.260 --> 00:32:58.650
Now, you can also,
instead of drawing a line,

00:32:58.650 --> 00:33:01.910
you can draw paragraphs,
and that's using a frame.

00:33:02.060 --> 00:33:03.550
And I'll describe that in the next slide.

00:33:03.600 --> 00:33:06.630
And finally,
if you're dealing with Core Graphics or

00:33:06.630 --> 00:33:10.030
Quartz directly to lay out your glyphs,
you have access to the

00:33:10.030 --> 00:33:11.080
position glyph runs.

00:33:11.160 --> 00:33:15.140
So this is one way that you
can... use Core Text and Quartz

00:33:15.200 --> 00:33:17.170
to lay out your text directly.

00:33:17.200 --> 00:33:21.610
So, let me give you an example of
what you would typically do if

00:33:21.610 --> 00:33:23.150
you want to lay out a paragraph.

00:33:23.200 --> 00:33:26.000
First,
you start with your attributed string.

00:33:26.020 --> 00:33:29.640
And the first thing you do is
create a frame setter object.

00:33:29.700 --> 00:33:33.290
The only input to the frame setter
object is your attributed string.

00:33:33.300 --> 00:33:37.720
It internally creates a Type Setter
to help it do all its layout.

00:33:37.800 --> 00:33:42.590
Next, you define a CG path, the shape,
which, by the way,

00:33:42.610 --> 00:33:45.550
we only support rectangles,
that defines where you

00:33:45.550 --> 00:33:46.960
want to lay out your text.

00:33:47.000 --> 00:33:50.570
So, at this point in time,
once it has the rectangle,

00:33:50.820 --> 00:33:54.640
the frame setter and the
Type Setter go to work and start

00:33:54.640 --> 00:33:56.860
doing the appropriate layout.

00:33:57.020 --> 00:34:00.380
The Type Setter positions the glyphs,
does the glyph runs,

00:34:00.890 --> 00:34:03.400
suggests the line breaks,
positions all the lines,

00:34:03.770 --> 00:34:08.480
all taking into account the attributes
that you pass and the attributed

00:34:08.480 --> 00:34:12.500
string to the Find Paragraph settings,
and also takes a look at, you know, say,

00:34:12.600 --> 00:34:15.370
the directionality of the text.

00:34:15.500 --> 00:34:19.880
Now, let's say that you,
this frame did not fit all the

00:34:19.990 --> 00:34:21.030
text that you wanted to draw.

00:34:21.250 --> 00:34:25.700
Well, at that point in time,
you can use the same frame setter object,

00:34:25.700 --> 00:34:30.620
give it another rectangle,
and the process will start all

00:34:30.620 --> 00:34:33.590
over again within the frame
setter and the Type Setter to

00:34:33.590 --> 00:34:35.020
lay out the remaining text.

00:34:35.500 --> 00:34:39.560
Thus, you can chain your frames,
and you can repeat this process

00:34:39.590 --> 00:34:42.000
until you exhaust the text.

00:34:42.600 --> 00:34:46.060
So, how do you go about coding this?

00:34:46.310 --> 00:34:48.390
Let's first start with
the attributed string.

00:34:48.400 --> 00:34:51.690
Like I said, the attributed string is
first your base string.

00:34:51.700 --> 00:34:55.440
Here, up on the slide,
I have what I would call

00:34:55.570 --> 00:34:57.090
a hard coding of a string.

00:34:57.100 --> 00:35:01.880
It's using the CFSCR macro,
and it just takes a Unicode string.

00:35:01.900 --> 00:35:06.990
But typically,
you wouldn't be hard coding strings into

00:35:07.300 --> 00:35:09.100
your apps unless it's for debugging.

00:35:09.100 --> 00:35:11.090
So, typically,
you want to get a localized string.

00:35:11.160 --> 00:35:12.300
So, here, this API, or this string,
is a local string.

00:35:12.630 --> 00:35:16.190
This macro shows you how to get
an appropriate localized string.

00:35:16.200 --> 00:35:20.190
So, once you have your base string,
next thing is you want to define

00:35:20.190 --> 00:35:23.200
the set of attributes that you
want to apply to this string.

00:35:23.210 --> 00:35:27.200
We definitely want a font,
so I'll pick Lucid Grunt 96.

00:35:27.310 --> 00:35:28.800
And we'll just keep it simple.

00:35:28.800 --> 00:35:31.400
That's the only attribute that
we're going to apply to the text,

00:35:31.460 --> 00:35:34.200
but you can well imagine that
you can define other things,

00:35:34.370 --> 00:35:38.380
just such as alignment, line spacing,
and so forth, different paragraph styles.

00:35:38.400 --> 00:35:42.400
So, now, we're going to create our text.

00:35:42.600 --> 00:35:45.960
And we're going to create our dictionary,
which will have all the

00:35:45.970 --> 00:35:46.580
attributes that we need.

00:35:46.770 --> 00:35:48.600
Once again, it's a pretty simple one.

00:35:48.600 --> 00:35:49.430
It's only the font.

00:35:49.660 --> 00:35:52.560
So, once we have our dictionary
and our base string,

00:35:52.700 --> 00:35:55.640
we can create our attributed string.

00:35:55.930 --> 00:36:01.460
So, once we have this attributed string,
it's quite simple to draw with Core Text.

00:36:01.460 --> 00:36:03.890
In this example,
we're just going to draw a line,

00:36:03.900 --> 00:36:05.090
a simple label.

00:36:05.300 --> 00:36:08.580
So, simple call,
create with attributed string,

00:36:08.720 --> 00:36:13.300
create line with attributed string, and

00:36:13.820 --> 00:36:16.400
At this point,
once the line object is created,

00:36:16.410 --> 00:36:20.300
it has internally a typesetter that has
layered all the text in the proper way,

00:36:20.450 --> 00:36:22.430
it is ready to draw.

00:36:22.660 --> 00:36:25.570
Now, one thing that...

00:36:26.130 --> 00:36:28.780
The first thing that you should
always do before you draw any text

00:36:28.890 --> 00:36:33.100
is make sure that your text matrix
and your context is set up properly.

00:36:33.100 --> 00:36:36.100
You don't know how many times
this bites people and they say,

00:36:36.100 --> 00:36:39.190
"Oh, why is my text not drawing?" Well,
somebody has modified the text

00:36:39.280 --> 00:36:41.010
matrix from underneath you.

00:36:41.100 --> 00:36:45.230
So, at this point, like I said,
the line object is ready to draw,

00:36:45.230 --> 00:36:49.430
but you can make any number of
other calls in Core Text that

00:36:49.430 --> 00:36:51.080
allow you to manipulate the line.

00:36:51.100 --> 00:36:53.100
You might want to truncate the line,
for example.

00:36:53.100 --> 00:36:57.030
If not, you just position your line
and you're ready to draw.

00:36:57.250 --> 00:36:59.100
Just draw it.

00:37:00.280 --> 00:37:01.150
Now, drawing frames.

00:37:01.200 --> 00:37:02.200
Simple again.

00:37:02.200 --> 00:37:05.460
You're starting with the
same attributed string.

00:37:05.460 --> 00:37:08.190
The only other thing that you need now is

00:37:14.300 --> 00:37:19.800
[Transcript missing]

00:37:20.090 --> 00:37:22.760
So the first thing you do is
you create a framesetter object.

00:37:22.770 --> 00:37:25.950
It only takes an attributed string.

00:37:27.320 --> 00:37:29.940
Next,
once you have your Framestarter object,

00:37:29.950 --> 00:37:33.660
you pass it in the shape,
the rectangle path that you want to use,

00:37:33.850 --> 00:37:37.040
and the range of text
that you want to lay out.

00:37:37.120 --> 00:37:39.940
In this case,
I'm saying just the whole text.

00:37:40.060 --> 00:37:43.180
Once again, at this point,
you can set up your text matrix,

00:37:43.310 --> 00:37:45.900
or make sure your text
matrix is set up properly.

00:37:45.900 --> 00:37:50.790
And also, there are a lot of calls in
Core Text that can help you adjust

00:37:50.790 --> 00:37:53.390
the layout that we've suggested.

00:37:53.440 --> 00:37:55.970
Once you've done that,
you're ready to draw.

00:37:57.240 --> 00:38:01.610
So now, let me invite up to the stage
Nathan Taylor so he can give you

00:38:01.610 --> 00:38:03.190
a demo of how to use Core Text.

00:38:05.750 --> 00:38:08.370
Thank you, Julio.

00:38:08.630 --> 00:38:11.350
I've got a couple short
demos to show you today.

00:38:11.370 --> 00:38:12.780
I'm going to show you one right now.

00:38:12.780 --> 00:38:15.580
It gives Julio a chance
to catch his breath.

00:38:15.760 --> 00:38:19.470
And this demo is going to show
you drawing of text as Julio

00:38:19.650 --> 00:38:22.620
showed with Core Text in frames.

00:38:22.880 --> 00:38:25.320
And it's in a simple Cocoa application.

00:38:25.350 --> 00:38:27.970
So let me show you the
application real quick.

00:38:28.090 --> 00:38:28.730
All right.

00:38:28.740 --> 00:38:29.340
It's launched.

00:38:29.380 --> 00:38:30.380
You don't see anything.

00:38:30.380 --> 00:38:32.450
I'm going to open up a document.

00:38:34.300 --> 00:38:36.500
Let's make the window a
little bit bigger here.

00:38:36.660 --> 00:38:38.960
You can see that the
text flows automatically,

00:38:39.090 --> 00:38:41.330
and I've got it wired up
so that if we click it,

00:38:41.620 --> 00:38:42.350
add frames.

00:38:42.360 --> 00:38:45.720
So I've got it now in three columns,
and you can see it flow to

00:38:45.720 --> 00:38:47.760
the columns as I resize it.

00:38:48.370 --> 00:38:51.560
And as you can see,
Core Text handles pretty

00:38:51.670 --> 00:38:55.520
much all the same styles that
you can get out of TextEdit.

00:38:55.520 --> 00:38:58.130
We have multiple style text,
multi-language text,

00:38:58.180 --> 00:39:00.490
multiple fonts in this document.

00:39:00.580 --> 00:39:04.800
And Core Text handles it all
within a single attributed string.

00:39:04.820 --> 00:39:07.780
Now, let me show you how we
got this attributed string

00:39:07.790 --> 00:39:09.610
and how we drew the text.

00:39:11.320 --> 00:39:16.620
So this application is an
NSDocument-based application,

00:39:16.620 --> 00:39:23.190
and as such, we have NSDocument subclass,
myDocument, and all we really did is take

00:39:23.280 --> 00:39:28.040
the boilerplate code and set it
up to when reading from a URL to

00:39:28.040 --> 00:39:31.020
create our attributed string.

00:39:31.020 --> 00:39:35.940
So read URL of type error
creates our attributed string,

00:39:35.940 --> 00:39:40.400
and NSDocument handles the open
dialogue and everything we need for us.

00:39:40.490 --> 00:39:43.910
Once we have this attributed string,
we then can pass it

00:39:43.980 --> 00:39:47.910
to our Core Text view,
which does the drawing.

00:39:47.910 --> 00:39:52.750
As you can see, we have drawRect here,
and this gets the graphics port and

00:39:52.800 --> 00:39:56.220
then initializes the frame setter,
and so I'll show you where

00:39:56.280 --> 00:39:57.640
we create it down here.

00:39:57.640 --> 00:40:02.200
CTFrameSetter,
create with attributed string.

00:40:02.750 --> 00:40:05.480
We get our attribute string,
create a frame setter,

00:40:05.480 --> 00:40:06.660
and then we create our columns.

00:40:06.700 --> 00:40:08.700
Let's take a look at those.

00:40:08.920 --> 00:40:12.700
As Julio said, we start by getting
our column rectangles,

00:40:12.980 --> 00:40:16.650
creating our column rectangles,
and then for each rectangle,

00:40:16.730 --> 00:40:21.700
we create a path, add the rectangle,
and insert it to our array.

00:40:21.700 --> 00:40:27.130
And then this is going to be passed back,
and we'll use that to-- oops,

00:40:27.130 --> 00:40:28.700
let me close this here.

00:40:28.700 --> 00:40:30.700
In DrawRect,
once we have our column paths,

00:40:30.700 --> 00:40:35.960
we're gonna iterate over each path,
create a frame from the

00:40:35.960 --> 00:40:38.850
path and the frame setter,

00:40:39.080 --> 00:40:40.850
and draw each frame.

00:40:41.050 --> 00:40:46.000
It's really straightforward to draw
text in frame paragraph styles,

00:40:46.000 --> 00:40:50.040
and Core Text handles all the typical
paragraph styles that you would get

00:40:50.040 --> 00:40:53.440
from NS TextView or--and similar.

00:40:53.570 --> 00:40:56.050
So with that,
I will give the stage back over to

00:40:56.050 --> 00:41:00.560
Julio so he can tell you about Cocoa.

00:41:06.590 --> 00:41:07.500
Thanks, Nathan.

00:41:07.500 --> 00:41:13.300
So you can see how easy it
is to use Core Text to render

00:41:13.300 --> 00:41:15.590
paragraphs or simple lines.

00:41:15.620 --> 00:41:22.100
But the power of Core Text is in
the adjustments that you can make.

00:41:22.170 --> 00:41:27.360
And I invite you to go online and
check out the documentation of

00:41:27.360 --> 00:41:31.690
Core Text so you can see all the
power that Core Text provides for you.

00:41:31.770 --> 00:41:33.450
By the way,
this is the only place where you

00:41:33.520 --> 00:41:35.220
can find documentation of Core Text.

00:41:35.330 --> 00:41:38.430
And at the end of the slides,
I'll provide you a link where

00:41:38.430 --> 00:41:40.480
you can go get the information.

00:41:40.480 --> 00:41:45.870
Now, Core Text, much like Quartz,
is a building block in

00:41:45.960 --> 00:41:48.540
our text architecture.

00:41:48.540 --> 00:41:48.540
So,

00:41:48.770 --> 00:41:52.930
If you're doing low-level text layout,
all you need to do is text layout.

00:41:53.080 --> 00:41:56.000
And especially if you just,
you have to confine yourself to

00:41:56.000 --> 00:42:00.640
doing procedural programming,
Core Text is the place to be.

00:42:00.690 --> 00:42:03.880
Now,
if you're dealing with text in general,

00:42:03.940 --> 00:42:06.400
well, you wanna be,
this is where you wanna be.

00:42:06.470 --> 00:42:08.060
You wanna be in Cocoa.

00:42:08.310 --> 00:42:11.090
And the reason is,
you just get the whole enchilada.

00:42:11.590 --> 00:42:16.520
When you're dealing with text, up to now,
we've just been talking about

00:42:16.520 --> 00:42:18.980
drawing glyphs and laying out text.

00:42:19.370 --> 00:42:20.860
But text is more than that.

00:42:20.860 --> 00:42:24.540
Our users expect text
to be more than that.

00:42:24.990 --> 00:42:28.480
You need a way to actually be
able to interface with your user.

00:42:28.480 --> 00:42:31.440
You need to be able to
handle input of text.

00:42:31.600 --> 00:42:36.040
The users expect you to handle
things such as file formats,

00:42:36.230 --> 00:42:38.210
be able to read and write 'em.

00:42:38.530 --> 00:42:44.240
So Cocoa does this for you,
and it basically handles most of it for

00:42:44.240 --> 00:42:46.180
you so you don't have to worry about it.

00:42:48.250 --> 00:42:53.240
Like the rest of the Cocoa system,
Cocoa Text is built on the

00:42:53.240 --> 00:42:55.800
Model-View-Controller paradigm.

00:42:55.890 --> 00:42:59.990
So the model would be your storage,
your fonts, your paragraphs that

00:42:59.990 --> 00:43:01.670
you want to manipulate.

00:43:01.970 --> 00:43:03.920
The controller would
be your layout manager,

00:43:04.000 --> 00:43:05.720
the glyph setter, the type setter.

00:43:05.770 --> 00:43:09.940
Notice the keen resemblance on
the classes to what Core Text has

00:43:09.940 --> 00:43:15.350
because Coco's layout engine
is built on top of Core Text.

00:43:15.410 --> 00:43:17.780
And finally, View.

00:43:17.850 --> 00:43:21.770
There are many different View classes,
and this is basically where the

00:43:21.940 --> 00:43:24.510
added value to our users is for text.

00:43:24.790 --> 00:43:26.730
It does all the input.

00:43:26.740 --> 00:43:32.550
It does all the dirty work that the
users expect your application to handle.

00:43:33.020 --> 00:43:38.940
So fonts in Cocoa,
the font system in Cocoa is built

00:43:39.290 --> 00:43:40.850
on top of Core Text as well.

00:43:41.040 --> 00:43:43.570
Its type,
as I showed you in a previous slide,

00:43:43.690 --> 00:43:46.900
are toll-free bridge
with the Core Text types,

00:43:47.030 --> 00:43:50.470
so you can use them interchangeably,
and you can expect to be able to

00:43:50.550 --> 00:43:54.170
create them in a similar fashion,
only that you have the advantage

00:43:54.170 --> 00:43:56.190
of you dealing with Objective-C.

00:43:56.490 --> 00:44:00.900
Now, Cocoa also deals or has a feature
called the font collections.

00:44:00.980 --> 00:44:04.790
And collections are groups of fonts,
if you will,

00:44:04.930 --> 00:44:09.840
that you as an application developer
can provide for your users to use,

00:44:09.940 --> 00:44:15.070
or they can create these collections
by themselves using the font panel,

00:44:15.150 --> 00:44:18.260
which is the user interface
for the font system.

00:44:18.340 --> 00:44:20.520
And I'll show you that later.

00:44:21.260 --> 00:44:25.100
Now, at the heart of the font system
in Cocoa is the font manager.

00:44:25.330 --> 00:44:29.080
Let's not confuse the Cocoa font
manager with the Core Text font manager.

00:44:29.100 --> 00:44:34.090
The Core Text font manager manages
all the font files in the system.

00:44:34.170 --> 00:44:38.100
The Cocoa font manager makes fonts,
font descriptors,

00:44:38.100 --> 00:44:43.380
font collections available to the user,
manages those font collections.

00:44:43.380 --> 00:44:47.940
It also manages the font panel,
and it provides font conversion APIs.

00:44:48.100 --> 00:44:52.280
If we were to apply the
Model View Controller to

00:44:52.380 --> 00:44:56.080
the fonts in Cocoa,
your model would be the fonts,

00:44:56.110 --> 00:44:58.020
the descriptors, the collections.

00:44:58.130 --> 00:45:02.370
The controller would be the

00:45:02.600 --> 00:45:07.500
The font manager and the
view would be the font panel.

00:45:07.690 --> 00:45:14.240
So, the font panel is the standard UI in
Mac OS X for users to pick fonts.

00:45:14.350 --> 00:45:17.040
It has a built-in collection
font manager for the user,

00:45:17.040 --> 00:45:21.310
so that's where users can actually
modify collections that are default

00:45:21.310 --> 00:45:25.030
in the system that you might have
created and provided for them or

00:45:25.050 --> 00:45:27.390
that they create on their own.

00:45:28.440 --> 00:45:33.390
But the font manager also provides
the user the ability to create,

00:45:33.880 --> 00:45:35.800
to specify a lot of
things about the fonts,

00:45:35.830 --> 00:45:40.600
not just what font to use and what size,
but apply all sorts of

00:45:40.600 --> 00:45:42.500
different text effects.

00:45:42.500 --> 00:45:46.380
They can specify the opacity,
they can specify a color.

00:45:46.570 --> 00:45:49.760
In essence,
what the user is doing here for us is

00:45:49.890 --> 00:45:52.620
creating a font descriptor for us to use.

00:45:53.610 --> 00:45:57.260
Also, the font panel gives you
access to the typography panel,

00:45:57.410 --> 00:46:03.150
which gives users access to high-end
typography features of the font.

00:46:03.650 --> 00:46:06.510
Finally,
the font panel is very customizable,

00:46:06.510 --> 00:46:08.300
both by the user and the developer.

00:46:08.330 --> 00:46:11.560
The user,
by being able to resize the font

00:46:11.560 --> 00:46:16.100
panel or hide things from the font
panel to get up on the screen whatever

00:46:16.630 --> 00:46:19.420
pieces of the font panel that they
want to use for their workflow.

00:46:19.420 --> 00:46:22.880
But as a developer,
you can create also accessory views that

00:46:22.880 --> 00:46:25.200
can be used inside of the font panel.

00:46:27.330 --> 00:46:29.720
So,
if you're dealing with text in Cocoa and

00:46:29.720 --> 00:46:33.300
you want to draw it or edit it,
which classes, where should you go?

00:46:33.300 --> 00:46:35.970
If you're just drawing
small pieces of text,

00:46:36.140 --> 00:46:39.380
drawing labels,
nothing beats Cocoa for that.

00:46:39.400 --> 00:46:42.750
You can have an NSString or
an NSAttributedString and

00:46:42.750 --> 00:46:44.320
tell it to draw itself.

00:46:44.400 --> 00:46:48.980
No need to create another
object or try to truncate stuff.

00:46:49.110 --> 00:46:50.800
It will do it automatically for you.

00:46:51.720 --> 00:46:54.530
If you're handling small pieces
of text that you want to edit,

00:46:54.530 --> 00:46:57.900
you can use the NSTextField
or there are other controls

00:46:57.960 --> 00:46:58.950
that are similar in fashion.

00:46:58.960 --> 00:47:01.500
Now,
when you want to deal with paragraphs,

00:47:01.510 --> 00:47:03.960
largest pieces of text,
you want to be in the

00:47:04.100 --> 00:47:06.180
NSTextView or use the NSTextView.

00:47:06.180 --> 00:47:09.550
And finally, like I said,
Cocoa can handle every single

00:47:09.550 --> 00:47:11.290
detail of the text for you.

00:47:11.340 --> 00:47:15.520
But if you require precise control
of how the text is to be laid out,

00:47:15.630 --> 00:47:17.580
you can do it within Cocoa.

00:47:17.580 --> 00:47:19.920
You can go directly
to the Layout Manager.

00:47:19.920 --> 00:47:21.700
It builds on top of Core Text.

00:47:21.720 --> 00:47:23.750
So all the functionality
you have in Core Text,

00:47:23.840 --> 00:47:26.960
you can also find inside of
the Layout Manager in Cocoa.

00:47:29.080 --> 00:47:35.970
Now, like Core Text,
Cocoa prefers to deal with attributed

00:47:36.020 --> 00:47:37.340
string for drawing its text.

00:47:37.420 --> 00:47:42.720
And the neat thing about dealing with
attributed strings in Cocoa is that you

00:47:42.720 --> 00:47:45.640
can get attributed strings very easily.

00:47:45.640 --> 00:47:51.320
As Nathan showed you on his demo,
he created his attributed string using

00:47:51.320 --> 00:47:53.630
an RTF document to get a string from.

00:47:53.640 --> 00:47:56.770
He didn't have to go and
code an attributed string

00:47:56.810 --> 00:47:58.630
like I did a few slides ago.

00:47:59.000 --> 00:48:03.410
So, up on the screen shows you some of
the font formats that you can create

00:48:03.410 --> 00:48:06.220
an attributed string easily from.

00:48:06.220 --> 00:48:12.210
But the strings APIs also
provide a way for you,

00:48:12.220 --> 00:48:15.520
so if you have a format
that it doesn't know about,

00:48:15.540 --> 00:48:19.620
you can provide a filter service
so that it converts that format

00:48:19.630 --> 00:48:21.660
into an attributed string.

00:48:24.460 --> 00:48:28.510
Now, string drawing, again,
quite easy with Cocoa.

00:48:28.590 --> 00:48:31.280
If you have an NSString or
an NSAttributedString,

00:48:31.340 --> 00:48:34.070
there are different methods
that you can use to draw itself.

00:48:34.200 --> 00:48:36.610
Here are a couple of examples.

00:48:36.620 --> 00:48:39.920
The second one,
the bounding rect with size, for example,

00:48:39.980 --> 00:48:43.760
if you specify a bounding rect,
it will draw the string in there

00:48:44.070 --> 00:48:47.820
and it will automatically apply any
truncation that needs to be applied.

00:48:47.870 --> 00:48:52.240
No reason for you to create a
different object to handle this.

00:48:52.430 --> 00:48:56.120
Now, it is quite easy,
and one of the things that I must

00:48:56.290 --> 00:49:02.080
caution you when using the string APIs is
that anything that is in the context,

00:49:02.090 --> 00:49:04.970
in the graphics context,
is overridden by what you

00:49:04.970 --> 00:49:07.210
supply in the attributed string.

00:49:07.320 --> 00:49:11.730
So if your context was set to use Optima,
say, but your attributed string says

00:49:11.800 --> 00:49:14.150
that it wants to use Arial,
it will draw using Arial.

00:49:14.230 --> 00:49:16.960
It will draw using every
single attribute that you had.

00:49:17.000 --> 00:49:19.900
Now, if you're dealing with a
string which has no attributes,

00:49:19.930 --> 00:49:24.250
what Cocoa will do is will use
the default font for the system,

00:49:24.400 --> 00:49:26.860
which is Helvetica, to draw.

00:49:28.810 --> 00:49:37.380
Now, this class is sort of the nice
feature for you as a developer

00:49:37.470 --> 00:49:41.190
because what this class is,
the NS TextView class,

00:49:41.240 --> 00:49:45.070
is essentially a very
powerful basic word processor,

00:49:45.150 --> 00:49:45.690
if you will.

00:49:45.700 --> 00:49:48.910
If you're familiar with
the TextEdit application,

00:49:48.910 --> 00:49:51.840
anything that the TextEdit
application can do,

00:49:51.840 --> 00:49:53.550
the NS TextView can do.

00:49:53.910 --> 00:49:55.930
By the way,
for those of you that don't know,

00:49:56.010 --> 00:49:59.240
you can find the source code to the
TextEdit application in the examples

00:49:59.390 --> 00:50:02.440
directory in developer examples Cocoa.

00:50:02.440 --> 00:50:05.570
All the source code for the
TextEdit application is there.

00:50:05.580 --> 00:50:09.190
Now,
NS TextView does all the heavy lifting.

00:50:09.220 --> 00:50:10.240
It does all your input.

00:50:10.260 --> 00:50:13.980
It manages or handles all the input
managers for different languages.

00:50:13.980 --> 00:50:19.690
It does all your cut, cut and paste,
manages undo, drag and drop.

00:50:19.760 --> 00:50:22.620
It handles all the complex formatting.

00:50:23.020 --> 00:50:29.510
So, if you want to have lists, tables,
rulers, if you want to have attachments,

00:50:29.540 --> 00:50:33.110
you want to put some media into
it such as a movie or a graphic,

00:50:33.110 --> 00:50:34.500
it handles that for you.

00:50:34.620 --> 00:50:39.220
It also has some form of detection
like link URL detection and provides

00:50:39.470 --> 00:50:42.280
tool tips to those links automatically.

00:50:42.460 --> 00:50:46.850
A lot of things that users come to expect
for you to handle when dealing with text.

00:50:47.080 --> 00:50:52.160
It also has utilities such as spell
checking and grammar checking built in.

00:50:52.400 --> 00:50:57.420
Now, new in Snow Leopard,
some new features for NS TextView.

00:50:57.420 --> 00:51:03.130
Again, I want to caution you that
these are available in the seed,

00:51:03.130 --> 00:51:08.120
in the headers,
but they're not active in the seed.

00:51:08.120 --> 00:51:10.110
So, you won't be able to take
advantage of them right away.

00:51:10.140 --> 00:51:12.440
The first one is data detectors.

00:51:13.060 --> 00:51:17.440
So,
what it will do is it will look at your

00:51:17.440 --> 00:51:22.890
text and it will be able to identify
pieces of text such as email addresses,

00:51:23.320 --> 00:51:25.020
normal addresses.

00:51:25.020 --> 00:51:28.850
And what you can expect
to happen is that we will,

00:51:29.090 --> 00:51:32.920
the Cocoa text system will be
able to hook up automatically

00:51:33.020 --> 00:51:35.150
with the appropriate framework,
say the address book,

00:51:35.280 --> 00:51:40.020
so that users can directly add
contacts to their address book.

00:51:40.330 --> 00:51:43.900
It will also have auto-correction
for misspelled text,

00:51:43.900 --> 00:51:46.200
smart dashes, and text replacement.

00:51:46.200 --> 00:51:48.660
So you can imagine,
like I show in this example,

00:51:48.720 --> 00:51:52.700
you're typing open paren, C,
and close paren, and it'll turn that

00:51:52.760 --> 00:51:54.040
into a copyright sign.

00:51:54.300 --> 00:51:57.810
Something useful for our users
that don't know how to go about

00:51:57.810 --> 00:52:03.490
using the option keys or the nice
hidden keyboard control panel.

00:52:03.830 --> 00:52:09.130
So with that, Nathan,
we'll give you a demo on use in Cocoa.

00:52:13.740 --> 00:52:16.230
So I'm going to show you the
second of my two demos here.

00:52:16.530 --> 00:52:20.700
And again, this is drawing with
Core Text in a Cocoa application.

00:52:20.700 --> 00:52:23.440
If you were at last year's
hands-on Core Text talk,

00:52:23.540 --> 00:52:25.970
you may have recognized this application.

00:52:26.100 --> 00:52:27.660
It's the Core Text ArcView.

00:52:27.660 --> 00:52:30.640
But I've translated it from
a Carbon application into a

00:52:30.640 --> 00:52:33.320
Cocoa document-based application.

00:52:33.320 --> 00:52:36.700
And this application draws
text on an arc using Core Text,

00:52:36.700 --> 00:52:40.690
but interfaces through the
standard Cocoa mechanism with

00:52:40.690 --> 00:52:42.740
the font panel and the UI.

00:52:42.950 --> 00:52:45.690
So I have, you know, live update.

00:52:47.310 --> 00:52:51.750
and I can control the font styles
from some check boxes here.

00:52:51.750 --> 00:52:54.200
And it respects what the
font's capabilities are,

00:52:54.200 --> 00:52:56.200
which is something that
you should do with your UI.

00:52:56.200 --> 00:52:58.390
So let me open up the font panel.

00:52:58.390 --> 00:53:02.180
And we can see we have DDoS select,
and it only has italic and bold faces.

00:53:02.250 --> 00:53:06.470
So if I choose bold, I get bold,
and italic, italic, but I can't do bold,

00:53:06.470 --> 00:53:07.200
italic.

00:53:07.350 --> 00:53:10.420
So let me bring up a new window,
and I'll change the font

00:53:10.420 --> 00:53:15.040
in this window to Cochin,
where we can now do bold and italic

00:53:15.040 --> 00:53:17.060
and go back with the font panel.

00:53:17.200 --> 00:53:22.200
And so what I will show you in the
code is how we did the drawing,

00:53:22.240 --> 00:53:25.450
but more importantly,
how I interacted with the

00:53:25.450 --> 00:53:27.200
font panel and other controls.

00:53:27.200 --> 00:53:30.180
Because if you have your own custom
view that you want to display a font,

00:53:30.200 --> 00:53:33.260
you're going to want to be
able to support multiple fonts,

00:53:33.260 --> 00:53:34.150
and this may be of interest to you.

00:53:34.220 --> 00:53:37.820
So let's take a look at the project.

00:53:38.480 --> 00:53:39.400
Here we go.

00:53:39.400 --> 00:53:43.050
And I'm going to first start
off by giving you a quick

00:53:43.080 --> 00:53:44.870
overview of the drawing.

00:53:44.970 --> 00:53:46.600
This is the Core Text Arc view.

00:53:46.650 --> 00:53:52.400
It does all the drawing here in DrawRect,
and it's pretty straightforward.

00:53:52.450 --> 00:53:54.840
I have an attributed string,
which I create a line from.

00:53:54.970 --> 00:53:58.400
I then process the line,
extracting glyph information.

00:53:58.510 --> 00:54:00.670
I create my arc.

00:54:00.790 --> 00:54:05.910
And then through mathematical
processes and transforms,

00:54:05.960 --> 00:54:10.930
I draw each glyph along the
line with a CT run draw.

00:54:10.940 --> 00:54:15.730
Let me go down and just quickly
show you that right here.

00:54:15.950 --> 00:54:21.680
So let's take a look at how we
interface with the font panel and the

00:54:21.680 --> 00:54:24.400
user interface and deal with fonts.

00:54:24.590 --> 00:54:29.230
So the first thing I want
to show you is when--

00:54:29.670 --> 00:54:31.330
The font panel changes the font.

00:54:31.560 --> 00:54:36.880
The message is sent to the
first responder to change font,

00:54:36.880 --> 00:54:38.360
which I have selected here.

00:54:38.360 --> 00:54:42.600
And my document, my NSDocument subclass,
is the Windows delegate.

00:54:42.600 --> 00:54:44.190
So it eventually comes to my document.

00:54:44.200 --> 00:54:46.100
Here's where I handle it.

00:54:46.140 --> 00:54:50.140
I will convert the font
from the font panel,

00:54:50.140 --> 00:54:52.610
which is the sender,
using the old font and assign it

00:54:52.750 --> 00:54:54.350
back to the ArcView as the new font.

00:54:54.620 --> 00:54:57.600
And then I'm going to update my display,
which is probably what you'll need to do.

00:54:57.600 --> 00:55:00.600
When I switch windows,
toggle between windows,

00:55:00.600 --> 00:55:06.270
what I do is I tell the font
manager that this window,

00:55:06.270 --> 00:55:08.600
this controller is the
new target for events.

00:55:08.600 --> 00:55:12.280
And I'm going to set the font
for the font panel so that the

00:55:12.380 --> 00:55:16.590
font panel is updated live as the
user switches between windows.

00:55:16.600 --> 00:55:19.060
So if you noticed,
the checkboxes were kind

00:55:19.060 --> 00:55:20.470
of respecting the font.

00:55:20.470 --> 00:55:23.540
And what they did is they
looked at the font that we had,

00:55:23.820 --> 00:55:27.830
looked at what it was capable of,
and then would set their

00:55:28.410 --> 00:55:30.600
state respectively.

00:55:30.600 --> 00:55:34.600
So first let's look at what we did
when I clicked the bold checkbox.

00:55:34.600 --> 00:55:36.600
This made a font bold.

00:55:36.600 --> 00:55:42.850
And what I'm doing here in toggle
bold is using the NSFontManager to

00:55:42.920 --> 00:55:46.590
convert the font to have the trait or,
when I'm unchecking it,

00:55:46.710 --> 00:55:47.600
to not have the trait.

00:55:47.760 --> 00:55:50.810
And I'm asking for the bold trait here.

00:55:51.350 --> 00:55:57.080
Now, how did I determine whether this
should be enabled or not is...

00:55:57.260 --> 00:56:00.580
I implemented an NSFont category method.

00:56:00.580 --> 00:56:02.920
You can use however you want.

00:56:02.920 --> 00:56:03.580
CanToggleTrait.

00:56:03.670 --> 00:56:07.910
And what this does is it attempts
to toggle the trait and then checks,

00:56:07.970 --> 00:56:12.320
you know, so I convert the font again,
and then I take my test

00:56:12.320 --> 00:56:17.460
font and I'm going to take a
look at its symbolic traits,

00:56:17.470 --> 00:56:20.490
compare it to the
desired symbolic traits,

00:56:20.490 --> 00:56:20.490
and make sure that it is only
different by my desired trait.

00:56:20.970 --> 00:56:24.410
At the end, that's how we can control
the user interface elements,

00:56:24.610 --> 00:56:27.660
you know, menu items, check boxes,
if we want to have specific

00:56:27.750 --> 00:56:30.960
font controls so that they stay
in sync with the font panel.

00:56:31.000 --> 00:56:36.170
If you're curious about how you can
manipulate text in Cocoa directly,

00:56:36.260 --> 00:56:42.280
I want to point you to
the Circle View example.

00:56:42.280 --> 00:56:47.770
It's in Developer, Examples, App Kit.

00:56:48.460 --> 00:56:49.300
CircleView.

00:56:49.300 --> 00:56:52.240
And this draws text on
a circle using Cocoa.

00:56:52.250 --> 00:56:56.230
So with that, I'll give the stage back to
Julio so he can finish up.

00:57:03.320 --> 00:57:04.340
Thanks, Nathan.

00:57:04.480 --> 00:57:08.140
So that sort of concludes what
I wanted to talk to you about,

00:57:08.190 --> 00:57:09.740
the high-level view of the tech system.

00:57:09.740 --> 00:57:12.560
So before I'm done,
I want to leave you with some

00:57:12.690 --> 00:57:18.490
pointers that you might need while
you're developing for Mac OS X.

00:57:18.630 --> 00:57:21.690
So the first has to do with storage.

00:57:21.940 --> 00:57:24.860
Typically,
all our strings are based on Unicode,

00:57:24.910 --> 00:57:29.460
and definitely that's what we recommend,
that you store all your documents as,

00:57:29.500 --> 00:57:32.520
and some, you know,
with Unicode as some form.

00:57:32.680 --> 00:57:36.560
So if you look at the
NSString APIs in Cocoa,

00:57:36.620 --> 00:57:42.860
there are various calls that you can have
in there or that you have available to

00:57:42.860 --> 00:57:45.910
you that do a lot of the work for you.

00:57:46.240 --> 00:57:49.430
First, if you're reading from it,
look-- if you know that you're

00:57:49.430 --> 00:57:55.280
dealing with files that you might be
working with other systems that might

00:57:55.280 --> 00:57:58.240
have a different representation,
say a byte order or

00:57:58.250 --> 00:58:01.920
Unicode decomposition,
look for APIs such as this one,

00:58:01.920 --> 00:58:05.920
create external representation,
and these are APIs that will handle

00:58:05.920 --> 00:58:08.500
all these automatically for you.

00:58:08.500 --> 00:58:12.040
Now, when you go store fonts,
like I said before,

00:58:12.160 --> 00:58:15.260
store the font descriptor attributes.

00:58:15.260 --> 00:58:17.690
Don't store a font reference.

00:58:17.700 --> 00:58:21.530
The reason being is this way you're
guaranteed that you have all the

00:58:21.770 --> 00:58:28.180
attributes that the user was actually
using when displaying the font.

00:58:28.180 --> 00:58:31.280
Like Nathan showed you,
typically the way the UI,

00:58:31.280 --> 00:58:34.780
for the user to create font references,
is using the font panel.

00:58:34.780 --> 00:58:38.070
And the font panel has many
ways for the user to tinker with

00:58:38.070 --> 00:58:39.840
the representation of the font.

00:58:39.960 --> 00:58:45.070
So by you getting the descriptor,
you get every single

00:58:45.210 --> 00:58:48.150
one of those attributes,
and it's easy to flatten them out.

00:58:48.200 --> 00:58:52.100
In fact, if you use Cocoa,
Cocoa has some nice

00:58:52.100 --> 00:58:54.550
serialization APIs for you.

00:58:55.100 --> 00:58:58.410
And finally, if you're just storing
plain text documents,

00:58:58.740 --> 00:59:00.640
starting in Leopard,
we could tag plain text in there.

00:59:00.640 --> 00:59:08.760
So if you look at the NSString APIs,
the write to file API, I believe,

00:59:08.890 --> 00:59:12.060
will allow you to,
will automatically tag the

00:59:12.060 --> 00:59:14.910
document with the right encoding.

00:59:16.810 --> 00:59:18.640
Core Text,
if you need to be in this space,

00:59:18.760 --> 00:59:21.850
you're in procedural programming,
you're doing procedural programming,

00:59:21.850 --> 00:59:24.630
and you're laying out your text,
I want to encourage you

00:59:24.730 --> 00:59:25.980
to use the right objects.

00:59:26.160 --> 00:59:32.080
If you're dealing with paragraphs,
use a frame setter.

00:59:32.190 --> 00:59:35.620
You could do paragraphs in any
other ways because Core Text has

00:59:35.620 --> 00:59:37.420
many APIs that give you control.

00:59:37.520 --> 00:59:42.870
But we encourage you to use the APIs that
are designed for the particular task.

00:59:43.350 --> 00:59:46.060
We use the objects,
especially the typesetter

00:59:46.060 --> 00:59:46.840
and the framesetter.

00:59:46.860 --> 00:59:50.640
These are the objects
that do the heavy lifting,

00:59:50.650 --> 00:59:51.510
all the layout.

00:59:51.620 --> 00:59:54.060
So hold on to them as long as possible.

00:59:54.090 --> 00:59:56.670
And finally,

00:59:57.450 --> 00:59:59.680
The text matrix,
setting up the text matrix.

00:59:59.800 --> 01:00:01.300
I can't mention this enough.

01:00:01.300 --> 01:00:03.870
This, I'm sure if you're new,
it will bite you at some point.

01:00:03.990 --> 01:00:06.550
As soon as you don't
see text on your screen,

01:00:06.710 --> 01:00:08.500
that's the first thing that
you should come to mind.

01:00:08.570 --> 01:00:10.300
I didn't set up my text matrix.

01:00:10.420 --> 01:00:10.880
So do that.

01:00:10.960 --> 01:00:14.890
And finally, don't make any character
to glyph assumptions.

01:00:14.890 --> 01:00:17.820
Let the layout engine,
let Core Text handle that

01:00:18.050 --> 01:00:19.560
for you using its APIs.

01:00:22.100 --> 01:00:24.350
And Cocoa.

01:00:24.510 --> 01:00:29.380
It is our recommended layer or API of
choice if you're dealing with text.

01:00:29.500 --> 01:00:33.930
Reason being is because it handles
every single aspect of text for you.

01:00:34.020 --> 01:00:37.070
It is built on top of
Quartz and Core Text,

01:00:37.240 --> 01:00:41.200
so it has all the capabilities
of these layers and more.

01:00:41.220 --> 01:00:45.760
So unless you have some particular needs,
such as doing procedural programming,

01:00:45.760 --> 01:00:48.100
you should be in the Cocoa space.

01:00:49.170 --> 01:00:54.220
So just a little reminder of what you
need to look for in for text in Cocoa.

01:00:54.280 --> 01:00:56.810
If you're doing some custom
drawing and you just want

01:00:56.810 --> 01:01:00.170
to display some small label,
you might want to use an

01:01:00.170 --> 01:01:03.820
NSText field because with that you
get text editing for free as well.

01:01:03.870 --> 01:01:07.220
If you need any text editing and
you're just looking for speed,

01:01:07.220 --> 01:01:09.450
well, use these string APIs for that.

01:01:09.500 --> 01:01:13.170
And again, if you want to do some
really customized layout,

01:01:13.170 --> 01:01:16.650
you need some precise measurements,
you always have access

01:01:16.650 --> 01:01:17.790
to the Layout Manager.

01:01:18.740 --> 01:01:21.660
And finally, for text input,
use the NSText view or

01:01:21.660 --> 01:01:23.210
an editable control.

01:01:23.220 --> 01:01:28.150
And this is one area that we recommend
that you don't typically override.

01:01:28.260 --> 01:01:33.270
The reason being is once you
start writing text editing,

01:01:33.290 --> 01:01:36.060
it opens up all sorts of
kind of worms for you.

01:01:36.060 --> 01:01:41.160
And basically, you might break existing
features that we have.

01:01:41.160 --> 01:01:44.390
Or in the future,
if we come up with some new features,

01:01:44.460 --> 01:01:46.000
you might not be able
to take advantage of.

01:01:46.130 --> 01:01:48.280
So don't reinvent the wheel
when it comes to text.

01:01:48.380 --> 01:01:49.720
to text input.

01:01:51.560 --> 01:01:53.630
And finally, fonts.

01:01:53.770 --> 01:01:58.430
Fonts should be quite simple to use,
and they are for the most part,

01:01:58.480 --> 01:02:03.660
but we do provide a lot of flexibility
in OS X when it comes to fonts.

01:02:03.700 --> 01:02:09.450
And the first thing that hits our
users is the precedence order.

01:02:09.480 --> 01:02:12.720
So as you saw before in this slide,
there are many places where

01:02:12.720 --> 01:02:15.740
users can install fonts or
even make them available.

01:02:15.740 --> 01:02:20.160
So the lowest precedent, surprisingly,
is the system location.

01:02:20.840 --> 01:02:23.160
And the highest precedent
is the application.

01:02:23.270 --> 01:02:25.590
By the way,
auto-activated fonts have the same

01:02:25.600 --> 01:02:27.430
precedence as application fonts.

01:02:27.600 --> 01:02:31.940
So the closer you are to the user,
the higher the precedence.

01:02:32.220 --> 01:02:34.810
Typically,
where users run into trouble is when

01:02:34.810 --> 01:02:38.510
they go in and install a font that
overwrites one of the system fonts or

01:02:38.510 --> 01:02:40.820
your application fonts that you ship.

01:02:41.450 --> 01:02:44.600
Unfortunately, there is not much that
we can do about that.

01:02:44.680 --> 01:02:49.110
But you as an application developer,
especially if you're installing fonts,

01:02:49.270 --> 01:02:51.780
there is something that you
at least need to be aware of.

01:02:52.100 --> 01:02:56.070
If you have an installer
application to install fonts,

01:02:56.070 --> 01:03:01.530
your application must look first to see
if any fonts that you're about to install

01:03:02.310 --> 01:03:06.220
are going to overwrite either an older
version or a newer version of the font.

01:03:06.280 --> 01:03:08.850
If you don't do this,
you're just asking yourself for

01:03:08.850 --> 01:03:10.520
trouble for you and your users.

01:03:12.150 --> 01:03:14.500
Creating font references.

01:03:14.500 --> 01:03:15.990
I alluded to this earlier.

01:03:16.120 --> 01:03:21.710
If you are dealing with font
family names and weights,

01:03:21.960 --> 01:03:24.000
please create a font descriptor.

01:03:24.000 --> 01:03:28.110
Do not attempt to create a font
from a direct font reference

01:03:28.200 --> 01:03:29.540
using a font family name.

01:03:29.560 --> 01:03:31.440
It's a performance issue.

01:03:31.800 --> 01:03:37.700
On the same performance issue, again,
font names are case sensitive.

01:03:37.900 --> 01:03:40.890
Don't use the correct font name.

01:03:40.890 --> 01:03:44.940
The reason being is, like I said,
since OS X Leopard,

01:03:45.040 --> 01:03:47.230
auto-activation is on by default.

01:03:47.260 --> 01:03:52.700
If you pass the wrong font name,
first we're going to look in our...

01:03:52.780 --> 01:03:54.830
database, if you will,
of fonts that are registered,

01:03:54.980 --> 01:03:55.780
look for that font.

01:03:55.790 --> 01:03:58.000
If it's not there,
we're going to dig through the

01:03:58.120 --> 01:03:59.080
fonts and try to find them.

01:03:59.140 --> 01:04:01.790
And even if we can't find them there,
then we're going to go try

01:04:01.790 --> 01:04:04.670
to hit Spotlight or hit the
third-party font management

01:04:04.670 --> 01:04:06.500
utility to try to find that font.

01:04:06.510 --> 01:04:12.000
We really want to provide a good user
experience for our users and have the

01:04:12.000 --> 01:04:14.940
fonts available whenever they are.

01:04:14.940 --> 01:04:18.240
So once again,
make sure you use the proper font names.

01:04:18.370 --> 01:04:21.250
That way,
you don't get this performance hit.

01:04:21.910 --> 01:04:24.290
And finally, font substitution.

01:04:24.290 --> 01:04:28.400
Font substitution is great for
us developers and for our users.

01:04:28.400 --> 01:04:31.360
We don't have to worry
about what font to use.

01:04:31.840 --> 01:04:33.310
However, you can abuse it.

01:04:33.390 --> 01:04:38.120
And the way you can abuse it is, say,
you have your application and you

01:04:38.270 --> 01:04:42.590
specify a font that you want to use,
and font substitution kicks in

01:04:42.590 --> 01:04:46.810
and picks up a glyph that is not
on the font that you specified.

01:04:46.810 --> 01:04:50.640
And typically,
this is the case for developers when they

01:04:50.640 --> 01:04:51.060
want to use a font that they want to use.

01:04:51.060 --> 01:04:55.240
So if you want to use some symbol or
dingbat to show on their user interface,

01:04:55.340 --> 01:04:58.370
well, be aware,
the user can override your fonts.

01:04:58.440 --> 01:05:01.260
So if they override your fonts,
they can potentially override

01:05:01.260 --> 01:05:02.880
the font substitution mechanism.

01:05:02.980 --> 01:05:06.350
So if you want a glyph to
be displayed on the screen,

01:05:06.350 --> 01:05:10.450
make sure that you specify
that font that uses that glyph.

01:05:10.450 --> 01:05:13.760
Otherwise,
if you depend on font substitution,

01:05:13.860 --> 01:05:16.200
you're going to be out of luck.

01:05:16.300 --> 01:05:19.510
So that concludes my talk.

01:05:20.240 --> 01:05:23.550
If you want to leave,
I want to point at you this link

01:05:23.550 --> 01:05:28.300
at the bottom where you can get all
information about text and fonts.

01:05:28.330 --> 01:05:32.040
This is the only place where you're
going to find core text documentation

01:05:32.120 --> 01:05:33.580
other than on the headers.

01:05:33.640 --> 01:05:38.150
There will be some sessions
later on today related to text,

01:05:38.240 --> 01:05:43.740
internationalizing your software,
and text input on the iPhone.

01:05:43.740 --> 01:05:47.460
And luckily for you guys,
you're going to be able to hit

01:05:47.460 --> 01:05:50.110
us with questions multiple times.

01:05:50.120 --> 01:05:50.220
So if you have any questions,
please feel free to reach out to us.

01:05:50.230 --> 01:05:53.190
There's three labs where you'll
be able to find some of us,

01:05:53.190 --> 01:05:54.320
or if not most of us.

01:05:54.670 --> 01:05:56.760
Later on this afternoon,
some of us will be there at

01:05:56.760 --> 01:05:58.410
the internationalization lab.

01:05:58.420 --> 01:06:02.200
Tomorrow, there'll be a Cocoa open lab
where Cocoa engineers will

01:06:02.200 --> 01:06:05.930
be there to help answer any
questions you have with Cocoa text.

01:06:06.000 --> 01:06:09.450
And they might even be able to help you
with some core text questions as well.

01:06:09.460 --> 01:06:13.380
And then on Friday,
we'll have a core text lab where you'll

01:06:13.380 --> 01:06:18.710
be able to hit us for core text questions
or cords or even Cocoa text questions.
WEBVTT

00:00:21.180 --> 00:00:22.100
So good afternoon.

00:00:22.100 --> 00:00:25.130
Thanks for coming to
Advances in Modern OpenGL.

00:00:25.280 --> 00:00:28.010
My name is Kent Miller, and, uh,

00:00:28.630 --> 00:00:30.430
Let's just dive right in.

00:00:30.560 --> 00:00:32.710
As a way to kind of frame
our discussion today,

00:00:32.710 --> 00:00:35.590
spend a second talking about past OpenGL.

00:00:35.600 --> 00:00:41.190
So, past OpenGL, you know, early '90s,
kind of looked like this.

00:00:41.360 --> 00:00:48.600
Immediate mode,
multiple calls per vertex,

00:00:49.420 --> 00:00:54.130
and allowed you to do neat
things like lit shaded whales.

00:00:55.290 --> 00:01:01.050
At that point,
a lot of the OpenGL pipeline

00:01:01.470 --> 00:01:06.010
was implemented in software.

00:01:06.190 --> 00:01:13.180
A lot of the real-time
bottleneck was spent doing

00:01:13.180 --> 00:01:13.180
computation on the incoming data,
vertex transformation, lighting.

00:01:13.770 --> 00:01:15.150
All that kind of stuff.

00:01:15.350 --> 00:01:23.700
Contrasted to today, all that computation
is more or less free.

00:01:23.700 --> 00:01:28.410
And the way applications use OpenGL is
to just bombard the card with data.

00:01:28.930 --> 00:01:37.090
Big textures, lots of them,
lots of geometry.

00:01:37.090 --> 00:01:37.090
Sometimes the textures and
geometry change per frame.

00:01:37.490 --> 00:01:41.030
So the bottlenecks really moved
to becoming a data management

00:01:41.110 --> 00:01:45.140
problem to get the best performance
out of the graphics system.

00:01:46.740 --> 00:01:52.550
So we just talked about immediate mode,
but today a well-performing application

00:01:52.600 --> 00:02:02.270
will use vertex buffer objects and
vertex arrays to use little function

00:02:02.270 --> 00:02:02.270
calls to specify the vertex data

00:02:02.740 --> 00:02:10.280
And instead of fixed function OpenGL,
modern apps are using shaders.

00:02:10.360 --> 00:02:14.120
All the current graphics hardware,
when you use fixed function OpenGL,

00:02:14.120 --> 00:02:17.750
it just internally makes a
shader out of your state anyway.

00:02:17.850 --> 00:02:23.280
So a lot of times it's more
straightforward and executes

00:02:23.280 --> 00:02:29.260
quicker on the graphics card to
just make your own shader to do

00:02:29.260 --> 00:02:29.700
exactly what you want it to do.

00:02:30.520 --> 00:02:32.710
Many function calls to change state.

00:02:32.710 --> 00:02:36.630
So instead of doing that,
a modern application will use buffer

00:02:36.630 --> 00:02:41.530
objects and all the other types of
objects in the system that allow

00:02:41.770 --> 00:02:44.240
you to change state in batches.

00:02:44.310 --> 00:02:51.090
And programs allow you to switch,
you know, from one complete transform

00:02:51.090 --> 00:02:53.290
state to another one.

00:02:53.290 --> 00:02:54.710
And instead of making multiple calls
to change the fixed function state.

00:02:55.860 --> 00:02:59.700
Instead of blocking calls for pixel data,
so to specify or get something

00:02:59.700 --> 00:03:03.120
back from the graphics card,
modern applications use pixel buffer

00:03:03.120 --> 00:03:05.080
objects to do that asynchronously.

00:03:05.120 --> 00:03:07.510
We'll talk about that a little bit.

00:03:08.500 --> 00:03:13.060
Then an old way to do off-screen
drawing was to use P buffers,

00:03:13.060 --> 00:03:16.590
which were platform-specific and
worked differently on OS X than

00:03:16.590 --> 00:03:18.910
it worked on other platforms.

00:03:19.030 --> 00:03:26.190
But today,
OpenGL provides framebuffer objects,

00:03:26.190 --> 00:03:26.190
which allow you to do a lot of the
same things in a cross-platform way.

00:03:28.670 --> 00:03:31.740
So, in this session,
we're going to talk about keeping

00:03:31.880 --> 00:03:41.040
the graphics cards busy and a
couple different ways to do that.

00:03:41.040 --> 00:03:46.260
The Buffer Object API will cover
to allow you to manage your

00:03:46.260 --> 00:03:46.260
memory in the graphics system and

00:03:46.480 --> 00:03:53.730
provide updates to your data in a way
that doesn't block the drawing pipeline.

00:03:53.730 --> 00:03:59.770
We're going to talk about how to
generate data using the graphics card,

00:03:59.770 --> 00:03:59.770
capture intermediate results,
and feed them back into the system.

00:04:00.190 --> 00:04:03.800
And then we're going to talk about
some more new OpenGL APIs that allow

00:04:03.800 --> 00:04:08.270
you to manipulate the intermediate
results on the graphics card

00:04:08.270 --> 00:04:10.970
without any round trips to the CPU.

00:04:11.330 --> 00:04:16.500
And then I'm going to show a little
example of using OpenGL with OpenCL,

00:04:16.740 --> 00:04:21.540
using OpenCL compute kernels
to generate some data and then

00:04:21.540 --> 00:04:23.930
using OpenGL to visualize it.

00:04:27.100 --> 00:04:31.450
So here we go with buffer objects.

00:04:31.530 --> 00:04:35.610
So first let's talk about
vertex buffer objects.

00:04:35.980 --> 00:04:39.650
Vertex buffer objects
encapsulates vertex state,

00:04:39.830 --> 00:04:41.390
vertex array state.

00:04:41.600 --> 00:04:47.220
And it allows you to do two things
that you really can't do any other way.

00:04:47.220 --> 00:04:51.130
One is that it allows you
to tell OpenGL when you're

00:04:51.130 --> 00:04:52.530
going to change the data.

00:04:52.560 --> 00:04:55.540
If OpenGL doesn't know when
the data in your vertex array

00:04:55.540 --> 00:04:58.150
is going to be modified,
it really has no choice but

00:04:58.150 --> 00:05:00.620
to use it in place every time.

00:05:00.640 --> 00:05:03.900
And that's not good for performance.

00:05:03.900 --> 00:05:07.670
And then it also has a
memory management policy,

00:05:07.710 --> 00:05:10.880
APIs that allow you to hint to
OpenGL how you're going to use

00:05:10.890 --> 00:05:15.070
that vertex buffer object so it
can store it in an optimal place.

00:05:15.070 --> 00:05:19.960
Also allows you to update your
data in a non-blocking way.

00:05:21.790 --> 00:05:24.420
So when you start to
think about the computer,

00:05:24.420 --> 00:05:28.320
so it's a diagram,
simple diagram of the computer.

00:05:28.320 --> 00:05:32.770
There's a bus between the CPU through
the system controller to the RAM,

00:05:32.820 --> 00:05:37.000
and CPU to the GPU,
and GPU to GPU memory.

00:05:37.000 --> 00:05:40.130
But, you know,
there's -- you can't directly access

00:05:40.200 --> 00:05:41.970
the RAM from the -- from the GPU.

00:05:41.970 --> 00:05:44.590
You have to go through
the system controller.

00:05:44.700 --> 00:05:49.000
So that leads to a trade-off depending
on what you want to do with your data.

00:05:49.050 --> 00:05:51.620
If you store the data right
there in the system RAM,

00:05:51.780 --> 00:05:54.240
then it's great for
your program to access.

00:05:54.260 --> 00:05:58.860
It can quickly manipulate
anything it wants to there.

00:05:58.860 --> 00:06:02.260
But the drawback to that is the
GPU doesn't have direct access to it.

00:06:02.260 --> 00:06:04.650
It has to go through the
system controller and either,

00:06:04.680 --> 00:06:07.190
you know,
directly access the data in small

00:06:07.190 --> 00:06:12.260
chunks or make a copy up to the
-- up to the GPU to use that data.

00:06:12.340 --> 00:06:15.680
On the other hand, if you store the data
in the graphics card,

00:06:15.760 --> 00:06:17.810
that's great for the GPU,
but if you want to

00:06:17.810 --> 00:06:18.880
modify it with the CPU,
then that's not going to be a good idea.

00:06:18.910 --> 00:06:21.220
But if you store the data
in the graphics card,

00:06:21.220 --> 00:06:24.290
and the GPU is in the graphics card,
then it takes more time.

00:06:24.460 --> 00:06:26.640
You either have to update
it and copy it or do,

00:06:26.650 --> 00:06:29.730
you know, slower writes through the
GPU to the GPU memory.

00:06:30.000 --> 00:07:52.500
[Transcript missing]

00:07:52.910 --> 00:07:57.620
And if you want to update the
data in a vertex buffer object,

00:07:57.720 --> 00:07:59.720
there's really three ways to do it.

00:07:59.720 --> 00:08:02.240
We're going to go over
some code with this.

00:08:02.240 --> 00:08:04.320
So just spend a second here.

00:08:04.320 --> 00:08:08.420
You can use the map and
un-map buffer pair together.

00:08:08.420 --> 00:08:14.250
Buffer sub data allows you with one
call to pass a small amount of data

00:08:14.310 --> 00:08:20.840
into the system and it will update your
buffer in place and do all that for you.

00:08:20.840 --> 00:08:24.550
And then Apple has an
OS 10 specific extension,

00:08:24.650 --> 00:08:28.900
flush buffer range,
which allows you to take responsibility

00:08:28.900 --> 00:08:32.860
for telling GL which part of
your vertex data you modified.

00:08:32.860 --> 00:08:38.220
And that allows it to copy just
little bits of it and send that

00:08:38.220 --> 00:08:42.440
to the graphics card as opposed to
the entire vertex buffer object.

00:08:42.440 --> 00:08:46.870
And it can have a good
effect on performance,

00:08:46.870 --> 00:08:49.880
which we'll show in a second.

00:08:50.370 --> 00:08:53.090
If you want to think about this,
just why do you have to

00:08:53.160 --> 00:08:55.680
use a vertex buffer object?

00:08:55.710 --> 00:08:59.170
The OpenGL standard allows you
with the vertex array usage,

00:08:59.310 --> 00:09:02.980
so the same vertex array that's
been in forever in OpenGL,

00:09:02.980 --> 00:09:06.610
you can really just change the
data at any point and GL is

00:09:06.620 --> 00:09:07.720
expected to pick up the change.

00:09:07.720 --> 00:09:13.050
So in this little piece of code there,
you call drawArrays to a set of data

00:09:13.050 --> 00:09:17.480
you defined and then your program
is going to go off and modify it.

00:09:17.600 --> 00:09:20.330
And then when you call drawArrays again,
OpenGL is expected to

00:09:20.330 --> 00:09:21.650
get your modifications.

00:09:21.700 --> 00:09:25.390
So what that leads to is that
OpenGL really has to read your

00:09:25.620 --> 00:09:28.960
data every time it needs access
to any particular piece of it,

00:09:29.150 --> 00:09:30.810
you know, the X vertex for this point.

00:09:30.890 --> 00:09:34.330
It's got to read it out of memory again.

00:09:34.500 --> 00:09:41.720
So, this chart was a little data that
we took to show the difference.

00:09:41.720 --> 00:09:45.240
The previous slide said that draw
arrays was fancy immediate mode and

00:09:45.250 --> 00:09:47.280
this slide really illustrates that.

00:09:47.310 --> 00:09:50.250
So,
you can see the yellow and red line on

00:09:50.250 --> 00:09:53.610
the chart are similar performance curves.

00:09:53.800 --> 00:09:56.680
The yellow line is just
using immediate mode.

00:09:56.690 --> 00:10:01.570
So, even at the largest batch sizes,
you can see that it behaves similarly

00:10:01.570 --> 00:10:04.440
in performance to the draw arrays call.

00:10:04.460 --> 00:10:08.370
The blue line is using static VBOs.

00:10:08.370 --> 00:10:13.510
So, the data was able to be
copied to the graphics card.

00:10:13.760 --> 00:10:17.790
GL was assured that the data wasn't
going to be modified when you used it.

00:10:17.850 --> 00:10:20.580
And so,
it was able to not make any copies and

00:10:20.600 --> 00:10:24.720
just read straight from its cache copy,
which allows the performance

00:10:25.210 --> 00:10:29.430
as the batch sizes get big to
really have some legs there.

00:10:30.910 --> 00:10:34.560
So this is a simple code,
simple piece of code,

00:10:34.560 --> 00:10:38.330
and I'm showing it to contrast
it to using flush buffer range,

00:10:38.510 --> 00:10:40.780
but really just updating your VBO.

00:10:40.780 --> 00:10:42.870
This is the simple way
to call mat buffer.

00:10:42.870 --> 00:10:44.730
Then you modify your data.

00:10:44.790 --> 00:10:47.590
Mat buffer returns a pointer to the data.

00:10:47.820 --> 00:10:49.700
So you use that pointer
to update the data.

00:10:49.700 --> 00:10:52.480
And then you call unmat
buffer when you're finished.

00:10:52.600 --> 00:10:56.680
And then the pointer that it
returned to you becomes invalid and

00:10:56.680 --> 00:10:59.630
any changes to it are undefined.

00:10:59.870 --> 00:11:04.300
Crash, my crash, might at least,
very least not get noticed

00:11:04.300 --> 00:11:05.440
by the graphics card.

00:11:06.760 --> 00:11:12.470
The Flush Buffer Range extension, though,
allows you to update a portion of the

00:11:12.560 --> 00:11:15.710
VBO data and you to tell GL what changed.

00:11:15.850 --> 00:11:19.060
So in the prefix example
with map and then un-map,

00:11:19.060 --> 00:11:22.620
GL's going to be forced to
copy your entire buffer when

00:11:22.790 --> 00:11:27.060
it needs to put it back on the
graphics card for fast access.

00:11:27.060 --> 00:11:31.030
And this extension relieves of
that responsibility because your

00:11:31.030 --> 00:11:34.660
app's going to tell exactly just
which specific pieces of the

00:11:34.730 --> 00:11:36.700
vertex data that it changed.

00:11:37.110 --> 00:11:42.880
And the code for that
just looks like this.

00:11:42.880 --> 00:11:42.880
So step one is

00:11:43.360 --> 00:11:51.490
A promise to OpenGL that you are going
to manually flush your modified data.

00:11:51.490 --> 00:11:51.490
So, I'm

00:11:51.670 --> 00:11:53.100
Then step two is just the same.

00:11:53.100 --> 00:11:55.240
Map buffer it, returns a pointer.

00:11:55.330 --> 00:11:56.480
Step three is the same.

00:11:56.570 --> 00:11:58.830
Modify the VBO.

00:11:59.120 --> 00:12:03.050
Step 4 is where you flush,
explicitly flush what you modified.

00:12:03.050 --> 00:12:08.480
So if you had a megabyte of
vertex data and you changed,

00:12:08.480 --> 00:12:12.320
you know, 256 bytes of it,
and you just flush that,

00:12:12.360 --> 00:12:14.310
then OpenGL can absorb
that change very quickly,

00:12:14.310 --> 00:12:17.170
you know, transfer it to the graphics
card for caching or whatever

00:12:17.170 --> 00:12:19.990
it's going to do with it,
and then when you call unmap buffer,

00:12:20.040 --> 00:12:22.800
that's not going to do anything
because you already manually

00:12:22.800 --> 00:12:24.440
flushed what you were going to do.

00:12:24.440 --> 00:12:26.980
So what does that do
for your performance?

00:12:26.980 --> 00:12:33.360
So this chart shows the yellow
line is the performance of --

00:12:33.750 --> 00:12:47.840
So, we took this data from
updating 0% of the data up to,

00:12:47.870 --> 00:12:50.730
you know,
90%. At 100%, you kind of expect

00:12:50.790 --> 00:12:51.930
the two things to converge.

00:12:51.960 --> 00:12:52.600
And the red line, curiously,
shows the performance of buffer sub-data,

00:12:52.600 --> 00:12:53.160
which really shows that that's not
a very optimal way to integrate

00:12:53.160 --> 00:12:53.600
the 3D graphics pipeline.

00:12:53.600 --> 00:12:59.450
And the red line, curiously,
shows the performance of buffer sub-data,

00:12:59.450 --> 00:13:06.300
which really shows that that's not a
very optimal way to update your data.

00:13:06.630 --> 00:13:16.300
So, I have to mention at this point
that this kind of performance tuning

00:13:17.090 --> 00:13:22.020
can be sensitive to many things.

00:13:22.020 --> 00:13:22.020
It can be sensitive to
your data alignment,

00:13:22.020 --> 00:13:22.020
interleaving,

00:13:22.270 --> 00:13:24.190
Data size.

00:13:24.210 --> 00:13:29.610
So it's really, you know,
if you remember the code that we saw,

00:13:29.610 --> 00:13:33.630
it's easy enough to just try the
different techniques inside your code to

00:13:33.630 --> 00:13:36.120
see what's the best performance for you.

00:13:36.120 --> 00:13:44.270
But I think in our experience,
map and map used with flush buffer range,

00:13:44.270 --> 00:13:44.270
you know, pretty much always
provides the best answer.

00:13:45.340 --> 00:13:52.480
So vertex buffer objects allow
you to capture and manipulate,

00:13:52.480 --> 00:13:59.180
switch quickly between
vertex array state.

00:13:59.330 --> 00:14:01.130
Pixel buffer objects accomplish
the same thing for image data.

00:14:01.290 --> 00:14:04.100
This shares the API,
a lot of API with the

00:14:04.120 --> 00:14:05.930
VertexBuffer object.

00:14:06.000 --> 00:14:10.100
It uses the same memory
management hints with the static,

00:14:10.120 --> 00:14:11.980
dynamic and stream.

00:14:11.980 --> 00:14:16.380
The same call to map and unmap
to get access to the data,

00:14:16.440 --> 00:14:19.090
same calls to specify the data.

00:14:19.110 --> 00:14:24.970
It's also possible to overlap the
internal storage for PBO and VBO.

00:14:25.240 --> 00:14:29.960
And what that allows you to do is,
you know, generate some data with one

00:14:29.960 --> 00:14:32.240
and consume it with another.

00:14:32.240 --> 00:14:35.840
So you can generate image data,
copy that to a PBO and then reuse

00:14:35.940 --> 00:14:40.980
that as Vertex data without incurring
a round trip through the CPU.

00:14:40.980 --> 00:14:42.870
And we have some sample
code that shows that.

00:14:42.930 --> 00:14:45.620
I think we had a demo of this last year.

00:14:45.670 --> 00:14:47.920
But it's interesting and
if you're interested,

00:14:47.920 --> 00:14:49.320
you should check that out.

00:14:50.250 --> 00:14:56.150
So, Pixelbuffer objects provide
cross-platform way to implement

00:14:56.290 --> 00:15:02.280
some things that we've provided
platform specific thing -- platform

00:15:02.280 --> 00:15:04.780
specific ways to do before.

00:15:04.780 --> 00:15:08.380
Pixelbuffer objects encompass
some of the functionality of

00:15:08.380 --> 00:15:11.260
texture range and client storage.

00:15:11.260 --> 00:15:15.360
And it also is a supported
cross-platform API to use to get

00:15:15.360 --> 00:15:20.380
non-blocking read pixels behavior,
which we'll see in a minute.

00:15:20.420 --> 00:15:24.200
And you can use a Pixelbuffer object
with any API that uses images,

00:15:24.200 --> 00:15:29.050
takes images from the GL entries,
draw pixels, read pixels,

00:15:29.050 --> 00:15:33.950
any of the texture entry points,
anything that takes an image.

00:15:34.140 --> 00:15:42.280
So the read pixels thing,
this is how you call read pixels.

00:15:42.280 --> 00:15:44.560
So this has the disadvantage
of -- when you call this,

00:15:44.560 --> 00:15:47.440
the graphics card has queued up commands.

00:15:47.440 --> 00:15:52.060
So it's working ahead and your
app is running ahead of it.

00:15:52.090 --> 00:15:56.660
So when you call read pixels,
you force the whole queued up buffer

00:15:56.660 --> 00:16:01.850
stream to -- or command buffer stream
to get consumed and then the result

00:16:01.880 --> 00:16:03.830
to get read back into your pointer.

00:16:04.050 --> 00:16:09.270
And so it will not only bring the
-- not return until that's finished,

00:16:09.390 --> 00:16:13.260
but it also completely flushes out
the graphics system and then you're

00:16:13.260 --> 00:16:16.490
going the next time you want to
render to try to get ahead of it.

00:16:17.420 --> 00:16:21.480
With pixel buffer objects,
you can do this in a way that won't stop

00:16:21.840 --> 00:16:25.020
the command stream from getting executed.

00:16:25.190 --> 00:16:27.820
It won't force it to finish.

00:16:27.830 --> 00:16:33.880
The way you do this is you bind a pixel
buffer object as the pixel pack buffer.

00:16:33.890 --> 00:16:37.120
Pack is for OpenGL giving you data.

00:16:37.120 --> 00:16:39.320
Unpack is for OpenGL taking
data from you.

00:16:39.380 --> 00:16:41.870
So pack buffer.

00:16:42.440 --> 00:16:44.270
And then you call read_pixels.

00:16:44.290 --> 00:16:49.630
Instead of sending read_pixels a pointer,
when you're using a pixel buffer object,

00:16:49.630 --> 00:16:50.840
you send it an offset.

00:16:50.840 --> 00:16:52.630
So we set offset to zero.

00:16:52.640 --> 00:16:57.720
So we set write this to the
beginning of my pixel buffer object.

00:16:57.790 --> 00:17:03.090
And then the important part of this
is that you have to do other work.

00:17:03.360 --> 00:17:07.300
So the read_pixels command
will get queued up.

00:17:07.340 --> 00:17:09.540
And then you want to go off
and do some other things.

00:17:09.570 --> 00:17:12.620
And then when you call map_buffer,
this is the call that will either

00:17:12.620 --> 00:17:20.450
return immediately if the buffer got
cleared out and the read came back.

00:17:20.620 --> 00:17:21.560
This will return immediately.

00:17:21.560 --> 00:17:26.260
Otherwise, it'll block here waiting
on that to happen.

00:17:26.330 --> 00:17:30.380
And then when you're finished that,
you call unmap_buffer telling

00:17:30.380 --> 00:17:32.800
GL you're done with the pointer
that it returned to you.

00:17:32.800 --> 00:17:38.840
And then that should go off
into to be undefined again.

00:17:38.870 --> 00:17:43.370
And you're done with accessing any of
the kind of data that it put in there.

00:17:44.200 --> 00:17:49.140
So just to kind of finish
off the BufferObjects here,

00:17:49.140 --> 00:17:56.990
it allows you to do some things that
we had OS X specific extensions to do.

00:17:57.100 --> 00:18:01.560
I mentioned the Pixel BufferObject
to do asynchronous read pixels.

00:18:01.590 --> 00:18:06.170
We used to suggest using copy text
and get text image to do that.

00:18:06.170 --> 00:18:10.600
Pixel BufferObjects is cross
platform and well supported.

00:18:10.600 --> 00:18:15.010
Apple vertex array range was an
extension that we used to have to

00:18:15.010 --> 00:18:19.820
allow you to specify some things about
your vertex array to OpenGL like,

00:18:19.870 --> 00:18:23.690
okay, I want you to map this into the
GPU space and then you had to

00:18:23.690 --> 00:18:26.380
manually flush when you changed it.

00:18:26.380 --> 00:18:29.500
And vertex BufferObjects
accomplished the same thing.

00:18:29.500 --> 00:18:38.800
Axle -- Apple Pixel Buffers were the --
was the API to do off screen drawing.

00:18:38.800 --> 00:18:41.110
And Frame BufferObjects
provides the same thing.

00:18:41.210 --> 00:18:43.090
We'll talk about that in a minute.

00:18:43.110 --> 00:18:46.080
But Frame BufferObjects has
other advantages for sharing

00:18:46.080 --> 00:18:47.880
objects and things like that.

00:18:47.880 --> 00:18:52.340
And then the text range
extension is somewhat encompassed

00:18:52.340 --> 00:18:54.580
by Pixel BufferObjects.

00:18:54.590 --> 00:18:54.590
So, I

00:18:54.810 --> 00:18:58.250
If you haven't learned everything
you want to know about this now,

00:18:58.430 --> 00:19:02.400
the ARB specifications for these
extensions are really good.

00:19:02.400 --> 00:19:08.390
They include pseudo-sample
code that is illustrative.

00:19:08.560 --> 00:19:12.880
The FlushBuffer range extension
is posted on developer.apple.com.

00:19:13.060 --> 00:19:16.410
Also, I believe,
with some sample code in it to show you,

00:19:16.410 --> 00:19:19.940
you know,
everything you want to know about that.

00:19:20.300 --> 00:19:24.520
And the code I mentioned to do the
overlapped PBO and VBO behavior

00:19:24.520 --> 00:19:27.500
is up on developer.apple.com.

00:19:27.500 --> 00:19:31.410
And then NVIDIA's developer
Web site has a paper that kind

00:19:31.410 --> 00:19:35.190
of dives into the details of the
differences between string draw,

00:19:35.190 --> 00:19:38.750
static draw, and, you know,
stream copy and those different things.

00:19:38.750 --> 00:19:41.570
So if you are interested in that topic,
that's a good place to

00:19:41.570 --> 00:19:42.600
go for that information.

00:19:44.590 --> 00:19:50.690
Okay, so buffer objects allow you to get
some asynchronous behavior going.

00:19:50.740 --> 00:19:54.430
So, you know,
allow the GPU to keep working and reduce

00:19:54.430 --> 00:19:59.720
the amount of data that gets copied
from system memory to GPU memory and

00:19:59.840 --> 00:20:03.080
reduces the number of stalls in the pipe.

00:20:03.080 --> 00:20:07.480
So we're going to talk about another way
to keep the graphics card humming along.

00:20:07.510 --> 00:20:10.570
And we titled this
section data recycling.

00:20:10.600 --> 00:20:14.580
But what we really mean by this is
using the GPU to generate some data,

00:20:14.590 --> 00:20:18.480
capturing that data on the GPU,
and then sending it back into the

00:20:18.690 --> 00:20:23.310
system in subsequent rendering
and avoiding the round trips to

00:20:23.320 --> 00:20:28.140
the CPU enhances your performance,
keeps the card busy.

00:20:29.120 --> 00:20:31.830
So the first thing is
framebuffer objects.

00:20:31.840 --> 00:20:34.980
So this is the encapsulation
of a render target.

00:20:34.980 --> 00:20:41.580
And what that means is you can render
to some data that stays on the GPU and

00:20:41.580 --> 00:20:47.110
then you can reuse that as source data,
perhaps in a texture,

00:20:47.360 --> 00:20:50.640
in other rendering that follows.

00:20:50.640 --> 00:20:54.250
So one of the nice things about
framebuffer objects over pbuffers is

00:20:54.300 --> 00:20:56.960
that there's no context switch overhead.

00:20:56.960 --> 00:21:00.060
So the FBOs all live in
the same OpenGL context.

00:21:00.060 --> 00:21:03.630
So you make one context
and all your objects,

00:21:03.630 --> 00:21:09.610
textures and programs, et cetera,
are shared there without having

00:21:09.640 --> 00:21:14.910
to go to all the pain that I'm
sure some of you have to share

00:21:14.910 --> 00:21:20.280
data between multiple GL contexts.

00:21:20.280 --> 00:21:22.990
And we mentioned that it
was cross-platform array for

00:21:23.000 --> 00:21:28.290
off-screen drawing and simple,
you and easy to use as a texture.

00:21:28.590 --> 00:21:35.840
and I'm gonna go through just a
brief code sample on the slide here.

00:21:35.840 --> 00:21:40.200
This is the simple code you
execute to create an FBO.

00:21:40.200 --> 00:21:45.230
You can attach a -- as the drawable you
can attach a render buffer or a texture.

00:21:45.230 --> 00:21:47.540
In this example,
we're going to create a texture.

00:21:47.680 --> 00:21:50.890
This is just the same as creating
any other texture in GL except

00:21:51.020 --> 00:21:55.260
we're specifying null as the
storage for the texture because it's

00:21:55.260 --> 00:21:57.740
gonna use the FBO as the storage.

00:21:57.740 --> 00:21:59.060
So we created the texture.

00:21:59.100 --> 00:22:03.300
And then this call binds the
texture as an attachment to the FBO.

00:22:03.300 --> 00:22:09.390
So drawing to this FBO as the drawable
is going to get captured in the texture.

00:22:10.700 --> 00:22:13.200
So now we're going to
draw something in it.

00:22:13.200 --> 00:22:17.340
So we're going to draw a duck.

00:22:17.340 --> 00:22:21.600
Any rendering that you do here will
go into the current draw buffer,

00:22:21.600 --> 00:22:23.700
which is the FBO at this point.

00:22:23.710 --> 00:22:28.780
But now we're going to go
back to the system draw,

00:22:28.780 --> 00:22:31.870
so the normal color buffer.

00:22:31.870 --> 00:22:33.540
Call blind frame buffer zero.

00:22:33.540 --> 00:22:33.540
It takes you back to the
default system drawable.

00:22:34.300 --> 00:22:39.180
And then we're going to bind
texture to the texture and use

00:22:39.180 --> 00:22:43.100
it to draw into the color buffer.

00:22:43.100 --> 00:22:44.940
So that's interesting.

00:22:44.960 --> 00:22:51.860
Hopefully you use the results graph lots
of times to save you some rendering time.

00:22:52.360 --> 00:22:57.020
Before we leave FBOs,
I should mention that you can

00:22:57.020 --> 00:23:02.900
have in FBOs per context and
switch between them at will.

00:23:02.900 --> 00:23:11.530
And you can also--each FBO can
have depth stencil attachments

00:23:11.620 --> 00:23:13.670
as well as color attachments.

00:23:13.670 --> 00:23:13.670
And so it's a full functioning drawable.

00:23:14.480 --> 00:23:18.550
So right now,
I'm going to bring Alex Eddy up here,

00:23:18.550 --> 00:23:23.820
and he's going to take you through
even more ways to capture intermediate

00:23:23.820 --> 00:23:29.180
rendering results and reuse them
in hopefully an interesting way.

00:23:38.200 --> 00:23:40.640
Okay, thanks, Kent.

00:23:40.640 --> 00:23:42.960
So continuing on with the
theme of generating data on

00:23:43.000 --> 00:23:46.680
the GPU and recycling it,
I want to talk in particular about

00:23:46.680 --> 00:23:51.340
two modern OpenGL extensions,
Transform Feedback and Geometry Shaders.

00:23:51.390 --> 00:23:57.910
And I'll finish up with a
little demo demonstrating how

00:23:57.910 --> 00:23:57.910
to combine those two things.

00:23:57.910 --> 00:23:57.910
So first up is Transform Feedback.

00:23:58.410 --> 00:24:00.460
So this extension,
ext transform feedback,

00:24:00.460 --> 00:24:03.460
is really like a modern version of
the feedback mode that's been built

00:24:03.470 --> 00:24:05.460
into OpenGL since the very beginning.

00:24:05.460 --> 00:24:06.740
But what is feedback?

00:24:06.830 --> 00:24:07.760
What does that mean?

00:24:07.760 --> 00:24:10.180
Well, we're talking about recycling data.

00:24:10.320 --> 00:24:13.160
This is really a way to get at
the intermediate results of the

00:24:13.180 --> 00:24:14.920
vertex transformation stage.

00:24:14.920 --> 00:24:18.700
If you think about the pipeline,
you're passing in vertex positions,

00:24:18.700 --> 00:24:22.840
for example, and you might do a model of
your matrix times that position.

00:24:22.840 --> 00:24:26.900
And normally that result is sent on to
be -- turns to a triangle or an asterisk.

00:24:27.000 --> 00:24:29.590
But this is a way to get
that intermediate result of

00:24:29.590 --> 00:24:33.420
that vertex transformation
and get it back to the CPU.

00:24:33.420 --> 00:24:35.100
The big difference here with
this extension is that instead

00:24:35.100 --> 00:24:38.140
of sending the data to the CPU,
you can write it directly

00:24:38.140 --> 00:24:39.890
into a buffer object.

00:24:40.910 --> 00:24:45.480
So once you have data in a buffer object,
you can really use it any way you like.

00:24:45.490 --> 00:24:47.690
It's up to you,
depending on how your data

00:24:47.690 --> 00:24:49.500
flow wants to be structured.

00:24:54.630 --> 00:24:56.080
If you want to,
you can cache that data and

00:24:56.090 --> 00:24:57.470
then reuse it multiple times.

00:24:57.490 --> 00:24:59.510
And typically,
you're going to feed it into another

00:24:59.510 --> 00:25:01.380
shader for additional processing.

00:25:01.840 --> 00:25:04.510
So, buffer objects are really flexible,
and you have several different

00:25:04.660 --> 00:25:07.930
choices of how you feed data into
additional shaders to that point.

00:25:07.960 --> 00:25:11.000
You could treat that data in the
buffer as vertex attributes and

00:25:11.000 --> 00:25:12.790
use it as a vertex buffer object.

00:25:12.860 --> 00:25:16.390
Or you could use it as a pixel
buffer object and call techimage

00:25:16.390 --> 00:25:20.130
using that buffer object as the
data source and feed that data in

00:25:20.130 --> 00:25:22.320
as pixels and a texture to a shader.

00:25:22.320 --> 00:25:25.340
There's also a new extension,
extbinaluniform,

00:25:25.340 --> 00:25:29.360
which will let you pass that buffer
object in as an arbitrary array of

00:25:29.360 --> 00:25:31.170
data in a uniform to a new shader.

00:25:31.900 --> 00:25:34.750
This extension also has a
switch which allows you to

00:25:34.750 --> 00:25:37.220
optionally discard rasterization.

00:25:37.230 --> 00:25:41.740
So instead of capturing the data from
transfer feedback into a buffer and

00:25:41.740 --> 00:25:46.510
not seeing any result on the screen,
you can simultaneously capture

00:25:46.760 --> 00:25:51.850
it to a buffer and rasterize
it as triangles on the screen.

00:25:51.850 --> 00:25:53.330
So depending, again,
what you want to do with your data flow,

00:25:53.330 --> 00:25:53.330
one or the other might be
a better choice for you.

00:25:53.570 --> 00:25:56.060
I also want to point out that
we've been shipping this extension

00:25:56.060 --> 00:25:58.810
for a little while now in Leopard,
but the specification was

00:25:58.810 --> 00:26:00.200
just recently posted online.

00:26:00.200 --> 00:26:02.740
So if you're trying to find it,
it's now up there on opengl.org.

00:26:02.860 --> 00:26:05.450
You can go there and
check out all the details.

00:26:06.200 --> 00:26:09.130
So there are a lot of different
ways to use this in an application,

00:26:09.130 --> 00:26:12.380
but to give an illustration of
one concrete data flow here,

00:26:12.390 --> 00:26:16.510
this is kind of the standard pipeline
of how data moves through the screen.

00:26:16.560 --> 00:26:18.930
You start out with some data
in a buffer object here,

00:26:18.930 --> 00:26:22.780
let's say it's vertex positions again,
and you feed that to your vertex shader.

00:26:22.840 --> 00:26:25.650
You use some transformations
like you multiply with the

00:26:25.690 --> 00:26:28.630
Model-View projection matrix,
maybe you do some lighting,

00:26:28.630 --> 00:26:30.080
whatever you're going to do there.

00:26:30.080 --> 00:26:32.090
And normally those vertices come
out and they're assembled into

00:26:32.090 --> 00:26:33.380
primitives like lines or triangles.

00:26:33.380 --> 00:26:37.360
They go to the rasterizer,
get rasterized by the fragment shader,

00:26:37.440 --> 00:26:39.760
and the results are into the display.

00:26:39.960 --> 00:26:43.000
Well, with transfer feedback now you can
get a tap into that pipeline right

00:26:43.000 --> 00:26:44.940
after the Vertex Shader executes.

00:26:44.950 --> 00:26:46.940
You can write those results,
all the variants that are

00:26:46.940 --> 00:26:49.220
coming out of the Vertex Shader,
directly into a buffer object.

00:26:49.220 --> 00:26:52.120
Like I was saying then,
you typically are going to

00:26:52.170 --> 00:26:54.140
pass this on to another shader.

00:26:54.140 --> 00:26:56.400
And you can see how now you can
build up a loop in the pipeline

00:26:56.400 --> 00:26:58.260
here internally on the GPU.

00:26:58.420 --> 00:27:00.960
And repeat that as
many times as you like.

00:27:00.960 --> 00:27:03.380
Transforming some data with a shader,
get it into a buffer object,

00:27:03.460 --> 00:27:06.780
transform it again in a different way,
get it into another buffer object.

00:27:06.780 --> 00:27:09.880
Maybe you cache it and
reuse it several times.

00:27:09.880 --> 00:27:13.160
So this is pretty flexible.

00:27:13.180 --> 00:27:17.720
And let me jump into some code here
to show how to set it up and use it.

00:27:19.000 --> 00:27:23.900
The first thing I'm doing here is
defining a constant array of strings.

00:27:23.900 --> 00:27:27.180
These are the literal names of
the variants in Unreal Associated

00:27:27.180 --> 00:27:28.660
that you want to capture.

00:27:28.800 --> 00:27:32.110
You send that array into this new API,
transfer feedback variances,

00:27:32.120 --> 00:27:34.220
along with a mode parameter.

00:27:34.240 --> 00:27:37.850
And the mode parameter here is either
going to be interleaved or separate.

00:27:37.860 --> 00:27:40.270
So in this example,
I'm only capturing one variant,

00:27:40.270 --> 00:27:41.520
the position.

00:27:41.520 --> 00:27:44.340
So it doesn't really make any difference
if I use interleaved or separate.

00:27:44.370 --> 00:27:46.960
But if you're capturing multiple things,
you have a choice of writing all

00:27:46.960 --> 00:27:49.790
those variances in interleaved
order into one buffer object.

00:27:49.890 --> 00:27:52.230
Or if it suits your data flow better,
you could write each individual

00:27:52.230 --> 00:27:54.320
variant into a separate buffer.

00:27:54.330 --> 00:27:56.120
It's up to you.

00:27:56.340 --> 00:28:04.080
After you've told OpenGL which variants
you're interested in capturing,

00:28:04.100 --> 00:28:07.370
you need to link the program.

00:28:07.370 --> 00:28:09.890
And also, at that point,
you would gen some buffer objects and

00:28:09.890 --> 00:28:09.890
be sure to call buffer data allocating
enough space to capture all of the

00:28:09.890 --> 00:28:09.890
vertices you're going to be capturing.

00:28:10.280 --> 00:28:13.420
So a little later on at draw time,
you would set up drawing like usual,

00:28:13.480 --> 00:28:16.850
binding a source buffer and setting
the pointers for all the attributes

00:28:16.850 --> 00:28:19.820
that you're going to be using,
and also bind this new transform

00:28:19.820 --> 00:28:23.440
feedback target with the destination
buffer you're going to be writing into.

00:28:23.600 --> 00:28:27.110
Once the source and destination pointers
are all set up for OpenGL to draw,

00:28:27.110 --> 00:28:29.510
you bracket your drawing
with these two new calls,

00:28:29.510 --> 00:28:32.180
beginTransformFeedback
and endTransformFeedback.

00:28:32.180 --> 00:28:35.640
Everything that you draw in between
that will be processed by the shader,

00:28:35.640 --> 00:28:38.260
and the results will be written
down to the buffer object

00:28:38.260 --> 00:28:38.800
for use however you like.

00:28:39.460 --> 00:28:41.810
So there are a couple more
details here which you can

00:28:41.880 --> 00:28:44.540
look up in the specification,
but that's really about it.

00:28:44.540 --> 00:28:46.440
It's pretty easy to
set this up and use it.

00:28:46.440 --> 00:28:48.670
You don't need very much code at all.

00:28:50.410 --> 00:28:54.160
So moving on to an example of
something you might be interested in

00:28:54.190 --> 00:28:59.290
capturing with transfer of feedback,
we have geometry shaders.

00:29:00.580 --> 00:29:03.000
So what is a Geometer shader?

00:29:03.000 --> 00:29:06.870
This is actually a really interesting
and kind of powerful new development in

00:29:06.870 --> 00:29:09.060
the hardware that OpenGL is exposing.

00:29:09.060 --> 00:29:12.520
And it's a completely new stage in the
pipeline that happens in between the

00:29:12.520 --> 00:29:14.810
vertex shader and the fragment shader.

00:29:14.810 --> 00:29:18.610
And so for the first time now,
you can process entire primitives

00:29:18.650 --> 00:29:20.980
like a line segment or a triangle.

00:29:20.980 --> 00:29:25.100
There's also some new adjacency modes
which allow you to process the vertices

00:29:25.100 --> 00:29:28.190
around a line or around a triangle,
which really enables you to

00:29:28.190 --> 00:29:31.230
do much more complicated types
of algorithms on the GPU.

00:29:31.320 --> 00:29:33.260
Once you have more than
one vertex to work on,

00:29:33.260 --> 00:29:35.820
you can do things like calculate
the area of a triangle or the

00:29:35.820 --> 00:29:39.800
face number of a triangle,
or you can start to look at the curvature

00:29:39.800 --> 00:29:42.860
of a line or the curvature of a 3D mesh.

00:29:44.100 --> 00:29:47.290
So inside the shader you have an array
of inputs and all the vertices are

00:29:47.310 --> 00:29:49.730
available for you to look at there.

00:29:51.440 --> 00:29:54.280
A geometry shader also has the
ability to dynamically create

00:29:54.290 --> 00:29:56.420
new vertices during execution.

00:29:56.420 --> 00:30:00.390
So inside of your shader,
you have full flow control ability,

00:30:00.410 --> 00:30:03.190
so you can build up new
primitives depending on any kind

00:30:03.190 --> 00:30:05.000
of logic that you want to write.

00:30:05.000 --> 00:30:11.530
And the output of the
geometry shader is vertices,

00:30:11.530 --> 00:30:12.710
which are then assembled as usual into
points or lines or triangle strips.

00:30:13.930 --> 00:30:18.390
So this kind of generalizes
to a one-in-and-out problem,

00:30:18.430 --> 00:30:23.880
which, as I said,
is really a lot more powerful

00:30:23.880 --> 00:30:23.880
than the old pipeline where you're
working on one vertex at a time.

00:30:24.400 --> 00:30:26.200
So diving in a little bit,
we're going to cover

00:30:26.200 --> 00:30:28.840
some key points here.

00:30:28.840 --> 00:30:33.760
There are a couple of new functions
added to the GLSL Shading Language.

00:30:33.810 --> 00:30:36.730
And most important there is
this emit vertex function.

00:30:36.780 --> 00:30:39.300
So to explain that,
I'm going to draw a parallel

00:30:39.330 --> 00:30:41.010
with how vertex shaders work.

00:30:41.090 --> 00:30:43.510
In a vertex shader,
you're setting all of the

00:30:43.540 --> 00:30:45.280
variants that you care about.

00:30:45.280 --> 00:30:48.000
Like you might output the
position and the color,

00:30:48.000 --> 00:30:49.940
maybe some texture coordinates.

00:30:49.960 --> 00:30:52.490
And the vertex shader is done executing,
a vertex pops out and it's done.

00:30:52.940 --> 00:30:56.360
The geometry shader works the same way,
except that you can explicitly

00:30:56.360 --> 00:30:59.210
create a vertex by calling
this emit vertex function.

00:30:59.300 --> 00:31:05.170
After that point,
you're free to then set a new position

00:31:05.170 --> 00:31:12.090
or a new color or a modified texture
coordinate and emit another vertex,

00:31:12.090 --> 00:31:12.090
and so on and so on,
building up as much as you like

00:31:12.090 --> 00:31:12.090
within some reasonable hardware limit.

00:31:13.100 --> 00:31:17.210
So another key language difference
here is that all of the outputs from

00:31:17.210 --> 00:31:21.990
the vertex shader are visible as
arrays of input in the geometry shader.

00:31:22.040 --> 00:31:23.880
Because you're going to be
working on multiple vertices,

00:31:23.880 --> 00:31:28.020
like three vertices in a triangle,
you can access them with

00:31:28.020 --> 00:31:29.630
this array notation.

00:31:29.690 --> 00:31:32.960
So if I was up in positions
in the vertex shader,

00:31:32.960 --> 00:31:37.080
those are visible as position
in with this array notation,

00:31:37.090 --> 00:31:38.720
and I access 0 and 1 and 2 elements to
get all three vertices in a triangle.

00:31:39.930 --> 00:31:43.110
The other new API here
is Program Parameter,

00:31:43.110 --> 00:31:46.760
which you need in order to
tell OpenGL what type of

00:31:46.790 --> 00:31:48.890
geometry shader this is.

00:31:48.940 --> 00:31:52.110
Since you're working on an array here,
the geometry shader has to work

00:31:52.110 --> 00:31:53.780
on a specific type of primitive.

00:31:53.780 --> 00:31:56.660
And this is how you do that.

00:31:56.660 --> 00:32:01.470
You need to tell OpenGL what
is the input type.

00:32:01.470 --> 00:32:01.850
Are you going to be processing points or
lines or triangles or adjacency modes?

00:32:02.800 --> 00:32:05.460
and also tell OpenGL what the output
type is so that it knows how to

00:32:05.460 --> 00:32:15.340
assemble the vertices that you're
creating inside the geometry shader.

00:32:15.340 --> 00:32:15.340
There's also this limit,
max vertices out, and...

00:32:17.100 --> 00:32:21.190
You need to tell OpenGL what is the
maximum number of vertices that you're

00:32:21.190 --> 00:32:23.840
going to be generating during one
execution of the geometry shader.

00:32:23.850 --> 00:32:27.860
So there is a hardware-specific
limit to that number,

00:32:27.860 --> 00:32:31.590
but in general,
you want to try to keep that as low as

00:32:31.590 --> 00:32:37.660
possible to allow maximum efficiency to
get as many hardware threads executing in

00:32:37.660 --> 00:32:39.970
your shader simultaneously as possible.

00:32:39.970 --> 00:32:39.970
After you've told
OpenGL these parameters,

00:32:39.970 --> 00:32:39.970
you need to link your program.

00:32:40.630 --> 00:32:43.940
And then later on at draw time,
you draw like usual using a primitive

00:32:44.040 --> 00:32:47.910
mode that matches the input type of the
geometry shader that you've specified.

00:32:48.950 --> 00:32:53.790
So looking at a very simple
shader here as an example.

00:32:53.910 --> 00:32:56.610
Here this shader is working
on points coming in,

00:32:56.680 --> 00:33:00.020
and it converts every point
to a triangle going out.

00:33:00.020 --> 00:33:01.960
So you can see here that I'm
taking the position that was

00:33:01.960 --> 00:33:04.290
written by the vertex shader,
and it's being accessed

00:33:04.290 --> 00:33:06.360
through this array,
position in.

00:33:06.360 --> 00:33:08.880
Since I'm working on points,
I'm only looking at the 0-th element,

00:33:08.880 --> 00:33:12.190
and it's just adding a very simple,
hard coded offset in

00:33:12.190 --> 00:33:14.300
the x and y directions.

00:33:14.300 --> 00:33:17.020
So this is emitting the
same vertex three times,

00:33:17.020 --> 00:33:20.470
and it's of splatting a
triangle around that point.

00:33:21.730 --> 00:33:25.200
Not very useful,
but it's an illustration.

00:33:25.200 --> 00:33:33.640
So you can check out the extension
specification online for all

00:33:33.670 --> 00:33:34.520
the rest of the details here.

00:33:34.520 --> 00:33:34.520
And I want to spend a little time
talking about some of the things

00:33:34.520 --> 00:33:34.520
you can do with this technology now.

00:33:35.330 --> 00:33:37.320
So here's a simple
example to start out with.

00:33:37.320 --> 00:33:42.470
I mentioned that you have access
to the tessellation-- or sorry,

00:33:42.470 --> 00:33:44.700
you have access to the
curvature of your mesh.

00:33:44.700 --> 00:33:46.440
You pass in data with adjacency.

00:33:46.490 --> 00:33:49.160
So it's possible to do
tessellation now on the GPU,

00:33:49.200 --> 00:33:53.780
so a very simple, paper doll stick figure
mesh going into the shader.

00:33:53.810 --> 00:33:57.200
And you can calculate a kind of
bicubic spline running through all

00:33:57.200 --> 00:34:00.800
those points and then dynamically
generate as many line shapes as

00:34:00.800 --> 00:34:02.500
you feel like to make it look good.

00:34:02.500 --> 00:34:04.860
And you also have flow
control in the shader,

00:34:04.860 --> 00:34:07.860
so you can conditionally deform or
move or warp or whatever you feel

00:34:07.860 --> 00:34:11.600
like specific line segments just
depending on any logic you want.

00:34:11.600 --> 00:34:16.380
So in this case, I'm growing hair only on
the head of that model.

00:34:17.170 --> 00:34:20.670
So looking at a little
more complicated example,

00:34:20.680 --> 00:34:25.040
it's also possible now to accelerate
some algorithms that we've had for a

00:34:25.040 --> 00:34:27.190
while but had to be executed on the CPU.

00:34:27.220 --> 00:34:33.160
So a good example here is
Shadow Vauln Extrusion,

00:34:33.160 --> 00:34:33.160
which you've probably seen
in some games like Doom 3.

00:34:34.030 --> 00:34:36.280
this type of algorithm,
you need to know really the

00:34:36.400 --> 00:34:38.770
topology of the model that you're
looking at in order to figure

00:34:38.870 --> 00:34:42.490
out something like the silhouette
from the light's point of view.

00:34:42.550 --> 00:34:45.930
So in the geometry shader you can figure
that out because you have access to the

00:34:46.000 --> 00:34:48.300
triangle and the adjacent triangles.

00:34:48.300 --> 00:34:51.260
So with any given triangle you
can figure out the face normal,

00:34:51.260 --> 00:34:56.400
and if you take the dot product of the
face normal with the light position,

00:34:56.400 --> 00:35:00.320
you can figure out if a given triangle is
facing towards the light and the adjacent

00:35:00.320 --> 00:35:03.050
triangle is facing away from the light,
then you know you're

00:35:03.050 --> 00:35:04.260
at the silhouette edge.

00:35:04.290 --> 00:35:06.510
Once you find the

00:35:06.610 --> 00:35:11.290
You can then dynamically generate
in the Jumper Shader new triangles

00:35:11.350 --> 00:35:15.180
only for triangles that have an
edge of the silhouette and project

00:35:15.270 --> 00:35:17.580
a volume away from the light source.

00:35:17.660 --> 00:35:24.130
You can write that into the
stencil buffer and end up with

00:35:24.130 --> 00:35:24.130
nice self-shadowing characters
like in video games now.

00:35:24.790 --> 00:35:27.250
So there's really an infinite number
of things that you could do here.

00:35:27.330 --> 00:35:29.730
This is a couple simple examples.

00:35:29.760 --> 00:35:34.390
And to give you one more idea trying to
combine this with transfer of feedback,

00:35:34.390 --> 00:35:37.110
I'm going to move over
to the demo machine.

00:35:51.030 --> 00:35:57.010
So I have here an everyday,
ordinary wine glass.

00:35:58.360 --> 00:36:03.320
And I was working together with my
coworker John Rososco on this demo,

00:36:03.320 --> 00:36:07.000
and we were trying to come up with a
visually interesting way to combine

00:36:07.000 --> 00:36:08.790
a couple of these extensions.

00:36:09.550 --> 00:36:15.160
And John had the good idea of trying
to simulate what happens to glass

00:36:15.250 --> 00:36:19.350
as you heat it up to melting point.

00:36:19.470 --> 00:36:24.310
So, in addition to the wine glass,
I have a virtual blowtorch.

00:36:25.760 --> 00:36:30.740
Which I can rub over the
glass and start to heat it up.

00:36:30.810 --> 00:36:33.250
And it'll start to melt and deform.

00:36:33.340 --> 00:36:35.280
And it's always going to move
down towards the bottom of

00:36:35.280 --> 00:36:37.410
the screen due to gravity.

00:36:37.600 --> 00:36:42.230
So if I heat it up a little bit,
I can kind of rotate it around like this.

00:36:42.290 --> 00:36:45.430
You can watch it kind of melt
and deform and fold into itself,

00:36:45.430 --> 00:36:46.130
right?

00:36:47.080 --> 00:36:51.340
So if I'm really clever,
I can kind of set up a little

00:36:51.340 --> 00:36:56.150
virtual glass blowing kit here,
if I get the spin right on this thing.

00:36:56.200 --> 00:36:59.470
And I can, you know,
heat up the rim maybe.

00:37:00.340 --> 00:37:03.510
Over time,
the heat will dissipate and the stem

00:37:03.510 --> 00:37:07.060
now is kind of fused into a new,
deformed position.

00:37:07.060 --> 00:37:10.270
And then you heat up the RAM,
flip it up like this,

00:37:10.270 --> 00:37:13.060
watch it kind of melt on top of itself.

00:37:13.060 --> 00:37:14.410
Right?

00:37:14.420 --> 00:37:16.100
Pretty cool, right?

00:37:16.570 --> 00:37:20.850
So this is kind of neat looking,
but how is this working?

00:37:20.900 --> 00:37:23.820
What's going on here?

00:37:23.820 --> 00:37:26.730
So to break this down,
let me turn off all the

00:37:26.730 --> 00:37:28.590
eye candy for a second.

00:37:30.450 --> 00:37:35.270
And what you can see here is that I'm
starting out with a really simple,

00:37:35.340 --> 00:37:38.290
coarsely tessellated input mesh.

00:37:39.430 --> 00:37:42.390
And there are basically two stages in
this algorithm that make this work.

00:37:42.420 --> 00:37:46.480
The first stage is dealing with
heating up the vertices and

00:37:46.480 --> 00:37:48.670
deforming them into a new shape.

00:37:48.740 --> 00:37:52.270
The second stage is using an enjompto
shader to tessellate that result into

00:37:52.270 --> 00:37:54.770
a higher polygon version of itself.

00:37:55.600 --> 00:37:58.220
So looking at the first
stage really briefly,

00:37:58.300 --> 00:38:01.780
there's a vertex shader which,
for every vertex in this mesh,

00:38:01.990 --> 00:38:04.310
figures out how close is the heat source.

00:38:04.420 --> 00:38:10.460
And if it's close enough,
it'll start to inject heat into it.

00:38:10.630 --> 00:38:16.070
And there's a gravity vector which
pulls all the hot vertices downwards.

00:38:16.070 --> 00:38:16.070
So what you're looking at
here is a visualization of

00:38:16.070 --> 00:38:16.070
the heat at every vertex.

00:38:16.470 --> 00:38:19.460
So the results of this shader execution
are being captured with transfer

00:38:19.560 --> 00:38:22.830
feedback into a buffer object.

00:38:22.970 --> 00:38:28.900
And so what's going on
here is that each frame,

00:38:28.900 --> 00:38:32.650
the input mesh is fed into the shader and
it's melted and deformed a little bit.

00:38:32.650 --> 00:38:32.650
And the good thing about this
is I have a reset button.

00:38:34.030 --> 00:38:37.740
And the deformed shape is
captured back into a buffer.

00:38:37.740 --> 00:38:40.470
And then the next frame,
we feed that buffer into the same shader,

00:38:40.550 --> 00:38:43.080
and we warp and deform
it a little bit more.

00:38:43.470 --> 00:38:46.760
So we're basically tracking the
current state of the mesh at

00:38:46.760 --> 00:38:49.500
all times in a buffer object,
which can be kept in

00:38:49.500 --> 00:38:50.770
video memory on the GPU.

00:38:50.860 --> 00:38:52.340
So there's no round trip of data here.

00:38:52.430 --> 00:38:54.850
It's all fast and local.

00:38:56.760 --> 00:39:00.470
So this same shader also deals
with recalculating the normals

00:39:00.520 --> 00:39:03.060
on every vertex in every frame.

00:39:03.150 --> 00:39:06.990
And this is done by feeding that
same BufferObject in as a texture to

00:39:06.990 --> 00:39:09.340
the shader using PixelBufferObject.

00:39:09.450 --> 00:39:12.920
And I can do a couple texture samples
around the vertex to figure out all

00:39:12.920 --> 00:39:14.860
the connectivity of the mesh there.

00:39:14.860 --> 00:39:16.400
And I can calculate a
bunch of face normals.

00:39:16.400 --> 00:39:19.200
I can average those into a vertex normal.

00:39:19.260 --> 00:39:23.630
So I need to do this in order to keep
the normals accurate regardless of

00:39:23.730 --> 00:39:26.020
how much the mesh has been distorted.

00:39:26.020 --> 00:39:29.140
I need this for the next step,
which is tessellation.

00:39:30.900 --> 00:39:39.560
So to explain tessellation a little bit,
let me jump to a very simple example,

00:39:39.580 --> 00:39:41.610
just one triangle.

00:39:44.340 --> 00:39:49.400
So every triangle has a face normal,
which here are in purple.

00:39:49.400 --> 00:39:52.740
And you can calculate the average
vertex normals like I just described,

00:39:52.740 --> 00:39:54.140
which here are in yellow.

00:39:54.140 --> 00:40:00.460
So once you have those vertex normals,
if you imagine those interpolating

00:40:00.620 --> 00:40:07.490
across the face of this main triangle,
you can kind of reconstruct an idealized

00:40:07.550 --> 00:40:08.490
curved surface that fits the curvature
of this local area with the mesh.

00:40:08.930 --> 00:40:12.020
And inside the geometry shader,
you can then emit a bunch of triangles

00:40:12.020 --> 00:40:15.120
to try to approximate that ideal
curved surface by displacing the

00:40:15.120 --> 00:40:17.140
triangle in the direction of the normal.

00:40:17.140 --> 00:40:20.390
And you can do that at some arbitrary
level of detail as long as you stay

00:40:20.430 --> 00:40:23.020
within a reasonable hardware limit.

00:40:23.020 --> 00:40:25.090
So there are a couple of different
ways to do this tessellation,

00:40:25.100 --> 00:40:27.820
but this particular
version is called NPatches.

00:40:27.850 --> 00:40:31.650
And ATI has a white paper written
up about it if you're interested.

00:40:31.650 --> 00:40:33.660
It's up on the AMD website now.

00:40:34.310 --> 00:40:36.200
So that's tessellation on one triangle.

00:40:36.240 --> 00:40:41.360
You apply the same algorithm then to
every triangle in this input mesh.

00:40:41.850 --> 00:40:48.390
And I start out with a pretty coarse,
chunky-looking thing.

00:40:48.560 --> 00:40:52.400
Tessellation might take it from a
couple hundred input vertices to tens

00:40:52.410 --> 00:40:55.340
of thousands of output vertices here.

00:40:56.370 --> 00:41:07.110
So we've got a deformation shader,
plus normal recalculation,

00:41:07.110 --> 00:41:07.110
plus a jump shader
doing tessellation here.

00:41:07.210 --> 00:41:09.340
Then you combine that
with a fragment shader,

00:41:09.340 --> 00:41:10.100
which is here.

00:41:10.100 --> 00:41:14.960
It's using a cubic environment map to
simulate reflection and refraction.

00:41:15.190 --> 00:41:17.430
And actually here,

00:41:17.730 --> 00:41:20.940
The refraction is doing a little bit
of a dispersive chromatic effect.

00:41:20.940 --> 00:41:23.090
So, you know,
there's a separate ray for the red,

00:41:23.090 --> 00:41:23.690
green, and blue.

00:41:23.690 --> 00:41:32.240
I can play around with the index
refraction here if I want to.

00:41:32.240 --> 00:41:34.650
So combine all these things
together and you get a kind of

00:41:34.650 --> 00:41:34.650
good-looking eye candy demo.

00:41:34.650 --> 00:41:34.650
So what do you think?

00:41:41.700 --> 00:41:44.410
So I'll just let this go
for a little bit maybe.

00:41:44.440 --> 00:41:46.710
It's fun to play around with.

00:41:47.200 --> 00:41:49.810
So in general,
I think the message here is

00:41:49.910 --> 00:41:52.970
that you're not really limited
to the old fixed-solution

00:41:52.970 --> 00:41:54.470
pipeline in any way anymore.

00:41:54.470 --> 00:41:57.100
GLSL and shaders have kind
of blown all that away.

00:41:57.100 --> 00:41:59.980
And now, additionally,
there's enough flexibility in the

00:42:00.060 --> 00:42:03.730
way you use the pipeline that you can
build up really complicated multi-stage

00:42:03.730 --> 00:42:05.630
algorithms and keep them all on the GPU.

00:42:05.790 --> 00:42:08.220
So generate some data,
stick it in a buffer object,

00:42:08.260 --> 00:42:11.160
do a second pass on it, cache it,
use it ten different times,

00:42:11.160 --> 00:42:13.450
ten different ways,
whatever you feel like.

00:42:13.450 --> 00:42:16.660
You can implement really more
advanced algorithms this way now.

00:42:17.750 --> 00:42:19.900
So that's about it.

00:42:19.900 --> 00:42:21.840
I just encourage you all to go
check out the specifications,

00:42:21.840 --> 00:42:25.060
get the details, and really start playing
around with the stuff yourself.

00:42:25.110 --> 00:42:25.420
So that's it.

00:42:25.420 --> 00:42:27.450
I'm going to hand it back to Kent now.

00:42:39.730 --> 00:42:44.500
So now we go from a cool spinning
melting wine glasses back to slides.

00:42:44.520 --> 00:42:46.160
That'll go well.

00:42:46.640 --> 00:42:52.770
Okay, so we're going to talk about some
more ways to sound the GPU now.

00:42:53.020 --> 00:42:58.920
There are some new features of
GLSL that allow you to implement more

00:42:58.920 --> 00:43:00.860
classes of algorithms on the GPU.

00:43:00.860 --> 00:43:08.440
So I'm gonna talk about GPU Shader 4
for a second along with Texture Integer.

00:43:08.480 --> 00:43:14.500
But GPU Shader 4 is an extension
to GLSL that allows you to do full

00:43:14.500 --> 00:43:16.740
integer operations in a shader.

00:43:16.740 --> 00:43:23.050
You can do ands, shifts, you know, knots,
all that fun binary stuff.

00:43:23.240 --> 00:43:29.490
And the Texture Integer extension,
the distinction of that between the

00:43:29.490 --> 00:43:32.820
regular integer data that you could
already pass in OpenGL is that the data

00:43:32.820 --> 00:43:35.800
is left intact with no conversions.

00:43:35.910 --> 00:43:38.910
If you use the GLN data type,

00:43:39.060 --> 00:43:45.110
That really signals to OpenGL that
you've passed it a color that is,

00:43:45.250 --> 00:43:53.470
you know, that the value of zero is 0.0
and FFFFF is 1.0 color data.

00:43:53.790 --> 00:44:03.240
But the texture-injury extension
destroys that implicit conversion

00:44:03.630 --> 00:44:03.630
that might happen otherwise.

00:44:03.630 --> 00:44:03.630
So,

00:44:03.700 --> 00:45:50.800
[Transcript missing]

00:45:51.770 --> 00:45:59.300
Another extension that we
are just adding support for,

00:45:59.300 --> 00:46:03.420
it's going to be in Snow Leopard,
but it also started to appear in 10.5.3,

00:46:03.420 --> 00:46:04.630
is FrameBuffer_Blit.

00:46:04.660 --> 00:46:08.980
So this extension has two tricks,
basically.

00:46:09.090 --> 00:46:12.390
It separates the draw
and read framebuffers,

00:46:12.390 --> 00:46:16.720
so now you can have a separate
framebuffer that's going to be read

00:46:16.920 --> 00:46:21.860
from with all the read operations,
and then the draw operations will

00:46:22.020 --> 00:46:25.200
take effect on the draw framebuffer.

00:46:25.200 --> 00:46:27.220
It also adds the Blit
framebuffer function,

00:46:27.220 --> 00:46:33.360
which is a fast copy
between framebuffer objects.

00:46:33.360 --> 00:46:42.700
So this is kind of like a 2D Blit API,
a stretch Blit or copy bits or whatever.

00:46:42.700 --> 00:46:45.210
I kind of think of it like copy bits.

00:46:45.210 --> 00:46:50.200
Anyway,
so it not only can copy straight away,

00:46:50.200 --> 00:46:51.380
it can also scale.

00:46:51.420 --> 00:46:53.980
It can also copy depth
and stencil buffers,

00:46:53.980 --> 00:46:59.620
any of the attachments to
the framebuffer object.

00:46:59.620 --> 00:47:01.760
And you can also specify a filter.

00:47:01.760 --> 00:47:04.730
When you use,
when you're copying depth and stencil,

00:47:04.780 --> 00:47:07.450
the nearest filter is all that applies.

00:47:07.450 --> 00:47:14.020
But in this next example, if you,
if you're just copying color,

00:47:14.100 --> 00:47:17.720
you can apply a linear filter to
that and you'll get some nice,

00:47:17.720 --> 00:47:19.060
you know, linear style.

00:47:19.220 --> 00:47:22.370
So you can see that
interpolation on the source data.

00:47:22.730 --> 00:47:25.470
And also in this example,
it's inverting the data,

00:47:25.470 --> 00:47:30.080
so it's flipping it, I guess,
left or right in this one.

00:47:30.080 --> 00:47:33.460
So it scales it down
and it's flipping it.

00:47:33.460 --> 00:47:38.180
So this might be an interesting way if
you wanted to use it to address some,

00:47:38.180 --> 00:47:41.700
you know, there's a problem with
flipped data in OpenGL.

00:47:41.700 --> 00:47:44.310
It kind of reads it upside down
from what you might expect.

00:47:44.320 --> 00:47:48.300
This might be something you could
do to try to program around that.

00:47:49.200 --> 00:47:55.980
Frame Buffer Multi-Sample is an extension
that allows you to create off-screen,

00:47:55.980 --> 00:48:01.180
multi-sampled FBOs.

00:48:01.180 --> 00:48:06.150
So it's an extension to the
Render Buffer Storage API,

00:48:06.150 --> 00:48:10.750
which is the type of attachment
we didn't show before,

00:48:10.750 --> 00:48:13.130
we showed a texture attachment.

00:48:13.130 --> 00:48:16.570
But this will create a multi-sampled FBO.

00:48:16.570 --> 00:48:22.900
And it basically is just like the
other Render Buffer Storage API,

00:48:22.900 --> 00:48:26.420
but you pass in the number
of samples that you want.

00:48:26.470 --> 00:48:29.300
This example passes in four.

00:48:29.300 --> 00:48:32.200
You can pass in, you know,
any number the card supports

00:48:32.200 --> 00:48:35.310
or you can pass in one,
which is a special value that means,

00:48:35.310 --> 00:48:39.330
you know, give me any multi-sample
format you support.

00:48:40.810 --> 00:48:44.460
So there's one more API that
was new in Leopard and that's

00:48:44.460 --> 00:48:46.170
the object purgeable extension.

00:48:46.290 --> 00:48:49.490
So I don't believe we
talked about this last year,

00:48:49.630 --> 00:48:52.660
but this is an OX10 specific extension.

00:48:52.780 --> 00:48:59.540
And basically what it allows you to
do is promise GL that on this object,

00:48:59.680 --> 00:49:02.800
say a texture,
that you are not going to require

00:49:02.800 --> 00:49:04.940
that GL retains the storage right now.

00:49:05.030 --> 00:49:08.660
So this is great if you want to really
bombard the system with textures.

00:49:08.730 --> 00:49:11.660
That you don't know if you're
going to use all of them or not.

00:49:11.770 --> 00:49:16.420
Or you might create something and
then want to allow GL to throw it away

00:49:16.420 --> 00:49:18.220
if it needs the space for something.

00:49:18.220 --> 00:49:23.460
If you're working in a constrained
memory space or whatever

00:49:23.460 --> 00:49:25.950
reason you'd want to do that.

00:49:26.370 --> 00:49:30.130
So in this case, if GL does decide to
throw away the storage,

00:49:30.130 --> 00:49:35.220
it's still going to retain the
state and the name of the texture.

00:49:35.270 --> 00:49:37.810
Everything associated with
it except for the storage.

00:49:37.860 --> 00:49:38.610
So this probably will work.

00:49:38.620 --> 00:49:43.560
It's going to be a little bit easier to
look at if you just look at the code.

00:49:43.770 --> 00:49:46.480
What this does is this code
is going to create a texture.

00:49:46.500 --> 00:49:51.860
So maybe you're starting
up a photo application.

00:49:51.890 --> 00:49:54.640
So it's going to kind of chug
through your library in the

00:49:54.710 --> 00:49:57.190
background and maybe create textures.

00:49:57.440 --> 00:49:58.720
Big textures.

00:49:58.730 --> 00:50:01.080
But instead of loading
the system up with it,

00:50:01.080 --> 00:50:03.650
it's going to make them all
purgeable as it loads them.

00:50:03.680 --> 00:50:05.490
So object purgeable apple.

00:50:05.610 --> 00:50:06.410
Volatile apple.

00:50:06.420 --> 00:50:08.560
So that's a promise
from your application.

00:50:08.590 --> 00:50:11.560
Before you use the texture,
you're going to check to see if

00:50:11.590 --> 00:50:13.730
it needs to redefine the storage.

00:50:13.830 --> 00:50:17.040
So in step two,
time has passed and you've decided

00:50:17.040 --> 00:50:21.570
that lo and behold you do want
to use that object that you made.

00:50:21.600 --> 00:50:28.180
So you call object unpurgable
with retained apple as the flag.

00:50:28.210 --> 00:50:29.870
So this is going to do two things.

00:50:29.960 --> 00:50:32.140
First of all,
it's going to return to you a value

00:50:32.180 --> 00:50:35.940
that indicates whether it kept that
texture around or not or that object

00:50:35.940 --> 00:50:37.740
around in this case a texture.

00:50:37.740 --> 00:50:43.690
But -- And then the second thing
it's going to do is it's going to

00:50:43.720 --> 00:50:47.340
make this object unpurgable again.

00:50:47.340 --> 00:50:50.100
So when you call this,
then it's not going to

00:50:50.100 --> 00:50:51.900
purge this object anymore.

00:50:52.140 --> 00:50:55.600
So it returns -- if it returns,
if it does not return retain,

00:50:55.600 --> 00:50:57.900
then you need to recreate the object.

00:50:57.950 --> 00:51:00.730
If it returns retain, you don't have to.

00:51:00.740 --> 00:51:04.240
So then after that, you draw.

00:51:04.650 --> 00:51:08.720
And then later on,
if you're finished with the object and

00:51:08.720 --> 00:51:12.590
you want to go back to that state where
you want GL to throw it away if it can,

00:51:12.600 --> 00:51:16.560
you just call object purgeable
again with the volatile flag.

00:51:17.870 --> 00:51:22.440
So,
brings us to using OpenGL with OpenCL.

00:51:22.690 --> 00:51:28.880
So, we've talked about asynchronous
behavior using vertex buffer objects,

00:51:28.950 --> 00:51:30.820
pixel buffer objects.

00:51:30.970 --> 00:51:36.230
We talked about generating
data with geometry shaders,

00:51:36.230 --> 00:51:36.230
so new data.

00:51:36.230 --> 00:51:41.600
We talked about using transform
feedback and framebuffer objects

00:51:41.670 --> 00:51:44.340
to capture intermediate results.

00:51:44.340 --> 00:51:49.160
And this is another way that we have
to generate some data in the system.

00:51:49.340 --> 00:51:57.390
So since OpenGL and OpenCL are obviously
running on the same graphics card,

00:51:57.390 --> 00:52:02.180
one of the major advantages we have is
that the storage objects can be shared.

00:52:02.180 --> 00:52:02.180
So

00:52:02.610 --> 00:52:06.830
you can share OpenCL vertex
buffer objects with OpenCL arrays

00:52:06.830 --> 00:52:10.120
and I didn't realize when I was
preparing this that this was

00:52:10.250 --> 00:52:13.950
actually before the OpenCL sessions,
but -- so I'll try to take

00:52:14.070 --> 00:52:18.800
that into account here,
but the vertex buffer objects

00:52:18.800 --> 00:52:26.060
-- so OpenCL array is a 1D
piece of memory to OpenCL.

00:52:26.060 --> 00:52:30.660
Textures and render buffers can be images
and that's kind of self-explanatory.

00:52:30.660 --> 00:52:34.340
It's a 2D array or 3D array in OpenCL.

00:52:35.810 --> 00:52:41.310
All the commands that deal with
using GL and CL objects together

00:52:42.060 --> 00:52:47.570
are included in the CL framework,
OpenCL framework, in that file,

00:52:47.570 --> 00:52:49.240
OpenCL_GL.h.

00:52:49.240 --> 00:52:53.670
So, and this is just a small piece
of code that allows you to create

00:52:53.860 --> 00:52:58.110
a--create a CL context that shares
objects with the GL context,

00:52:58.150 --> 00:53:05.280
so with a pre-existing GL context,
which you might have got CGL context from

00:53:05.280 --> 00:53:09.930
calling maybe CGL get current context,
or maybe you saved it earlier,

00:53:09.930 --> 00:53:14.330
but--so you call CL create
device group from CGL context,

00:53:14.330 --> 00:53:19.710
and that returns a group of cards,
which will be the same group that

00:53:19.710 --> 00:53:22.520
you created your GL context on.

00:53:22.520 --> 00:53:26.760
And then you pass that
in to CL create context,

00:53:26.760 --> 00:53:30.800
and then you've got it
set up to share objects.

00:53:31.650 --> 00:53:35.100
So this is kind of how that would work.

00:53:35.330 --> 00:53:41.260
So you make a buffer object,
a vertex buffer object,

00:53:41.370 --> 00:53:45.250
just with standard GL API there.

00:53:45.300 --> 00:53:47.980
Genbuffers, bindbuffer,
and GL buffer data.

00:53:48.040 --> 00:53:53.150
So to make the object sharing
work well between GL and CL,

00:53:53.150 --> 00:53:56.750
then we're going to
use a static draw VBO.

00:53:56.820 --> 00:53:58.670
So we're going to give it
the static draw hint there.

00:53:58.980 --> 00:54:04.180
And then in step two there,
we're creating a CL array.

00:54:04.250 --> 00:54:06.770
So the important thing
there is in orange,

00:54:06.770 --> 00:54:10.260
the mem alloc reference,
which tells CL that the storage

00:54:10.260 --> 00:54:14.110
for this object is going to come
from another object instead of,

00:54:14.200 --> 00:54:16.810
you know, having to allocate its own.

00:54:17.320 --> 00:54:19.850
Then when we're ready
to use that together,

00:54:19.860 --> 00:54:24.880
we're going to attach the
array and VBO together.

00:54:24.880 --> 00:54:29.160
So seal attach deal buffer,
compute context, array to VBO.

00:54:29.160 --> 00:54:33.960
So then they internally get references
to the same storage object on the card,

00:54:33.960 --> 00:54:35.640
storage object on the card.

00:54:35.640 --> 00:54:40.990
And those two calls are,
I'll go over with some code here

00:54:40.990 --> 00:54:45.560
in a second on the demo machine,
but that's how you execute a seal kernel.

00:54:46.360 --> 00:54:49.840
And then sometime later,
before you dispose everything,

00:54:49.840 --> 00:54:52.080
you don't have to do it right
after you execute the kernel,

00:54:52.080 --> 00:54:56.280
but that detaches the array
from the other storage object.

00:54:56.300 --> 00:54:58.730
And then you can use the storage object.

00:55:01.250 --> 00:55:07.980
So, I have some code over here on the
demo machine that illustrates this.

00:55:19.400 --> 00:55:20.400
Wow, that's neat.

00:55:20.400 --> 00:55:21.760
Let's open it like this.

00:55:21.760 --> 00:55:23.840
Okay.

00:55:23.840 --> 00:55:28.130
So this is a short program.

00:55:28.520 --> 00:55:33.380
You know,
it's just maybe 100 lines or 150.

00:55:33.380 --> 00:55:36.990
There's two parts to this
I wanted to point out.

00:55:37.140 --> 00:55:41.850
This is more or less the same piece of
code that we just looked at on the slide,

00:55:41.850 --> 00:55:47.920
but this is how simple it is
to attach a VBO to a CL array.

00:55:47.920 --> 00:55:52.040
It uses the same flags,
the static draw VBO to the MIM-alloc

00:55:52.040 --> 00:55:55.980
reference CL array that we saw before.

00:55:55.980 --> 00:55:59.300
And then we're going to
attach them right away.

00:56:00.090 --> 00:56:02.700
And then the other thing
that's interesting here,

00:56:02.700 --> 00:56:08.040
and I guess since we haven't
looked at any CL code before,

00:56:08.040 --> 00:56:13.800
probably,
this is the routine in this program

00:56:13.800 --> 00:56:15.560
that executes the CL kernel.

00:56:15.610 --> 00:56:22.540
So, you know,
you set up an array of sizes of the data,

00:56:22.680 --> 00:56:28.320
and then you set the values for
that data in the values array,

00:56:28.540 --> 00:56:31.840
and then you call setKernelArgs.

00:56:32.070 --> 00:56:37.960
And real quickly,
I'll show you the CL kernel

00:56:37.960 --> 00:56:41.980
itself for this example.

00:56:42.020 --> 00:56:44.480
And so...

00:56:45.850 --> 00:56:52.380
You can see here that the kernel
args end up being the arguments

00:56:52.380 --> 00:56:55.830
to the CL kernel that it executes.

00:56:55.830 --> 00:57:00.600
So that's how you pass data
into the OpenCL function.

00:57:00.600 --> 00:57:08.510
It's kind of, I guess,
I've drawn analogous to me to using

00:57:08.510 --> 00:57:08.510
uniforms passing into a shader.

00:57:08.700 --> 00:57:14.930
So that is-- so you set the KernelArgs,
and then you execute the kernel.

00:57:15.000 --> 00:57:19.590
And then the results of that
get written into the VBO.

00:57:19.670 --> 00:57:23.620
And then in the DisplayRoutine here,
we're just calling updateMesh,

00:57:23.770 --> 00:57:28.070
and then we're calling drawRays
to just get the data out.

00:57:28.100 --> 00:57:37.060
And the result of that is this little,
neat, geometric point cloud thing.

00:57:37.170 --> 00:57:40.580
So, you know, every frame,
the CL kernel is running and

00:57:40.710 --> 00:57:45.200
transforming the data from the
previous state to the next state.

00:57:45.280 --> 00:57:48.170
And then when it's finished,
then we're just calling

00:57:48.170 --> 00:57:51.800
drawRays on the VBO,
on the bound VBO,

00:57:51.880 --> 00:57:54.610
and getting the point results out.

00:57:57.850 --> 00:58:02.300
Can we switch back to slides, please?

00:58:02.550 --> 00:58:05.030
So...

00:58:06.790 --> 00:58:16.000
For any more information about
CL or anything we talked about,

00:58:16.000 --> 00:58:18.280
Alan Schaffer is our evangelist.

00:58:18.280 --> 00:58:18.280
And his email is actually
not email@apple.com.

00:58:20.100 --> 00:58:21.100
Maybe it is.

00:58:21.100 --> 00:58:25.240
I don't think it is.

00:58:25.240 --> 00:58:29.520
If you need to contact Alan seriously,
you can talk to me afterwards and

00:58:29.520 --> 00:58:32.280
I'll get you his correct address.

00:58:32.280 --> 00:58:36.610
The Mac OpenGL mailing list,
myself and most of my engineers

00:58:36.610 --> 00:58:38.690
are pretty active on that list.

00:58:38.690 --> 00:58:42.350
At least we do, I think,
read every message that comes across,

00:58:42.360 --> 00:58:44.990
even though we might not
have an immediate answer.

00:58:45.100 --> 00:58:48.350
We do at least see it and
we'll answer if we can.

00:58:48.410 --> 00:58:52.320
If we know the answer,
it's not that we can't,

00:58:52.320 --> 00:58:54.860
but we may not know.

00:58:54.860 --> 00:59:00.560
And then there's documentation on
the developer.apple.com website.

00:59:00.560 --> 00:59:05.060
We have a pretty good OpenGL and
OS X programming guide that

00:59:05.900 --> 00:59:10.560
explains some of these offscreen
rendering techniques as well as,

00:59:10.680 --> 00:59:15.180
you know, a lot of platform things
for working on OS X.

00:59:15.180 --> 00:59:19.340
There's extension documentation up
there for most of the extensions

00:59:19.360 --> 00:59:24.860
that we support and all of the
Apple specific extensions that we have.

00:59:24.860 --> 00:59:27.290
And there's also a sample code,
the sample code we mentioned,

00:59:27.360 --> 00:59:28.420
as well as some others up there.
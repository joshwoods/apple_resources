WEBVTT

00:00:21.530 --> 00:00:24.730
Hello and welcome to Integrating
and Extending Quartz Composer.

00:00:24.730 --> 00:00:27.280
My name is Troy and I'm here with the
rest of the Quartz Composer team to

00:00:27.280 --> 00:00:30.870
give you a sneak peek at what we've
been working on in Snow Leopard.

00:00:33.180 --> 00:00:35.240
So today we're going to
talk about Quartz Composer,

00:00:35.240 --> 00:00:35.640
obviously.

00:00:35.780 --> 00:00:37.650
I'm going to start with
a brief introduction.

00:00:37.750 --> 00:00:40.330
We don't have a lot of time today,
so it's going to be brief.

00:00:40.330 --> 00:00:42.700
And if this is your first
interaction with Quartz Composer,

00:00:42.760 --> 00:00:45.630
I invite you to just sit back and relax,
enjoy the show,

00:00:45.630 --> 00:00:48.320
and afterwards take a look
at one of the many getting

00:00:48.320 --> 00:00:50.340
started materials found online.

00:00:50.360 --> 00:00:56.950
Also, we're having a lab session
after this session,

00:00:56.950 --> 00:00:57.160
so you can come and ask
us any questions you have.

00:00:57.580 --> 00:01:00.020
So then I'm going to talk about
some reuse in Quartz Composer and

00:01:00.020 --> 00:01:03.440
how you can get the most out of
the workflows in Quartz Composer.

00:01:03.440 --> 00:01:05.910
And I'm going to talk about some
of the performance improvements

00:01:06.000 --> 00:01:07.380
we were making in Snow Leopard.

00:01:07.410 --> 00:01:09.620
Then I'm going to have Alessandro
come up on stage and talk

00:01:09.620 --> 00:01:12.520
about the new interaction
model we have in Quartz Composer.

00:01:12.770 --> 00:01:16.860
And Kevin is going to wrap things up
with integration with OpenCL and how

00:01:16.860 --> 00:01:21.560
Quartz Composer is the best environment
for you to create those OpenCL kernels.

00:01:22.830 --> 00:01:24.400
So what is Quartz Composer?

00:01:24.460 --> 00:01:28.420
Quartz Composer is a visual programming
environment which is embedded

00:01:28.530 --> 00:01:30.890
in the system in the framework.

00:01:31.370 --> 00:01:34.760
It's also the name of an editor that we
ship with the developer tools for free.

00:01:34.840 --> 00:01:36.530
So you might be confused
if you think that,

00:01:36.530 --> 00:01:38.400
oh,
I don't have a Quartz Composer editor,

00:01:38.400 --> 00:01:41.110
I can't show my compositions to my users.

00:01:41.220 --> 00:01:44.220
But that's not the case because
it ships with the operating

00:01:44.220 --> 00:01:48.130
system and you can view it in many
different places across the system.

00:01:48.330 --> 00:01:52.180
For example, here is a composition
embedded directly in Keynote.

00:01:52.180 --> 00:01:56.330
This is a very practical use of Quartz
Composer because it was the basis

00:01:56.330 --> 00:02:00.900
for Time Machine and it's also really
great for hypnotizing developers.

00:02:02.070 --> 00:02:05.900
This composition was created
with this set of patches.

00:02:05.960 --> 00:02:10.080
Now a patch is a functional block
which is used to define a composition.

00:02:10.120 --> 00:02:12.510
And as you can see,
we're working on updating the UI to make

00:02:12.510 --> 00:02:14.050
it more functional and easier to use.

00:02:14.170 --> 00:02:16.420
So we hope that you guys enjoy that.

00:02:19.320 --> 00:02:22.790
Quartz Composer is a patch-based
abstraction of developer APIs.

00:02:22.890 --> 00:02:25.500
What that means is there's
all these things in the system

00:02:25.500 --> 00:02:28.550
that you want to get access to,
and Quartz Composer is your way to

00:02:28.700 --> 00:02:30.600
use them without writing any code.

00:02:30.770 --> 00:02:37.070
So for example, we have graphics
technologies like Core Image,

00:02:37.070 --> 00:02:41.260
QuickTime, and it's all based on OpenGL.

00:02:41.500 --> 00:02:43.000
We also have communication type
technologies such as networking and XML.

00:02:43.180 --> 00:02:47.940
And we have patches which talk directly
to the input devices in the computer,

00:02:47.940 --> 00:02:51.060
such as the keyboard, the mouse,
and the video input.

00:02:51.140 --> 00:02:53.260
So this makes it really easy
for you to create compositions

00:02:53.260 --> 00:02:55.700
because we have so many patches.

00:02:58.400 --> 00:03:01.590
Now, when you create these compositions,
they become a file format.

00:03:01.670 --> 00:03:02.530
We call them compositions.

00:03:02.540 --> 00:03:04.240
They end in .qtz.

00:03:04.290 --> 00:03:07.980
And that allows you to integrate them
easily within the operating system.

00:03:08.220 --> 00:03:12.660
Here at Apple, we've been hard at work
integrating them in a lot of

00:03:12.660 --> 00:03:15.080
applications that Apple writes.

00:03:15.080 --> 00:03:17.280
And there's a lot of third-party
development that's going

00:03:17.330 --> 00:03:18.540
on in Quartz Composer also.

00:03:18.540 --> 00:03:23.250
I'd like to point out, like, for example,
Podcast Producer is really,

00:03:23.250 --> 00:03:26.940
really useful for universities
and institutions to apply their

00:03:27.230 --> 00:03:31.220
branding to podcasts before they
get distributed in iTunes U,

00:03:31.220 --> 00:03:31.770
for example.

00:03:33.130 --> 00:03:36.240
Another application you might
be familiar with is Photo Booth.

00:03:36.240 --> 00:03:38.280
It's a really fun example
of Quartz Composer,

00:03:38.280 --> 00:03:41.850
but some of the most useful examples
of Quartz Composer being used are

00:03:41.850 --> 00:03:45.740
the ones that are being developed
by developers like yourselves.

00:03:45.900 --> 00:03:51.240
So we have companies today that are using
Quartz Composer for image processing,

00:03:51.240 --> 00:03:54.730
for example, Photo Booth type effects
in their applications.

00:03:54.740 --> 00:03:57.390
Also,
there's broadcast television stations

00:03:57.760 --> 00:04:02.750
using Quartz Composer to process their
images before they're distributed.

00:04:03.410 --> 00:04:06.300
We also have medical and
scientific applications that

00:04:06.310 --> 00:04:09.800
are using Quartz Composer to
display large amounts of data.

00:04:09.800 --> 00:04:13.720
We have medical companies and we
have schools that are using Quartz

00:04:13.720 --> 00:04:17.890
Composer for scientific uses like
astrology and that kind of stuff.

00:04:18.540 --> 00:04:21.780
Quartz Composer is also really
great for motion graphics.

00:04:21.780 --> 00:04:25.370
We have VJs using Quartz Composer
for their live performances in clubs

00:04:25.370 --> 00:04:28.990
because Quartz Composer has a really
great real-time rendering system.

00:04:29.330 --> 00:04:37.370
Also, you might be aware of Apple stores
which use Quartz Composer in their

00:04:37.370 --> 00:04:37.370
digital signage to tell you when
Genius is ready for your appointment.

00:04:38.190 --> 00:04:40.570
Also,
you should notice that Quartz Composer is

00:04:40.590 --> 00:04:44.590
not only for real-time graphics because
you can use it as a processing engine,

00:04:44.780 --> 00:04:50.330
either to process your images and create
offline representations of those images,

00:04:50.460 --> 00:04:55.310
or you can just process data
and not even use the rendering

00:04:55.310 --> 00:04:55.310
pipeline of Quartz Composer at all.

00:04:58.290 --> 00:05:02.860
So let's talk about what Quartz Composer
can do for you in reusing the various

00:05:03.040 --> 00:05:06.190
components that you tend to write.

00:05:10.440 --> 00:05:14.240
As you may know, reuse is very important,
whether you're an artist and

00:05:14.320 --> 00:05:18.040
you want to reuse components in
your various artistic designs,

00:05:18.210 --> 00:05:21.320
or you want -- if you're
a computer programmer,

00:05:21.320 --> 00:05:23.780
you know that reuse is important for
your frameworks and your classes.

00:05:23.840 --> 00:05:27.180
So Quartz Composer is good for that too.

00:05:27.180 --> 00:05:30.360
And one of the base functionalities
of Quartz Composer is the patches,

00:05:30.360 --> 00:05:34.090
and we've written over 250 patches
for you to use in your compositions.

00:05:34.100 --> 00:05:36.700
That's code that you don't have
to write because we've already

00:05:36.700 --> 00:05:40.920
done the hard work of writing,
testing, and implementing those patches.

00:05:40.990 --> 00:05:44.430
And if that's not enough for you,
we also provide a QC plugin API which

00:05:44.440 --> 00:05:49.180
shipped on Leopard which allows you
to write your own custom QC plugins.

00:05:51.070 --> 00:05:55.000
There's also, for some of the stylistic
effects that you want to reuse,

00:05:55.000 --> 00:05:58.570
there's Composition Loader,
which allows you to load at runtime

00:05:58.610 --> 00:06:01.840
a composition which you may not
know the path to when you're

00:06:01.840 --> 00:06:03.900
developing your application.

00:06:03.970 --> 00:06:06.880
And we also have the
QC Composition Repository,

00:06:06.970 --> 00:06:11.430
which allows you to get access to a
lot of effects that Apple has written

00:06:11.440 --> 00:06:16.650
and also some effects that you guys are
writing and installing on the computers.

00:06:16.650 --> 00:06:19.280
So that's a really good way to
have reuse in your applications.

00:06:19.490 --> 00:06:22.040
And finally,
for development time reusability,

00:06:22.040 --> 00:06:23.160
there's virtual patches.

00:06:23.230 --> 00:06:29.040
And these are small patches
which reference external

00:06:29.040 --> 00:06:34.000
compositions in a way that's more
functional rather than stylistic.

00:06:34.090 --> 00:06:36.450
So to give you an example
how virtual patches work,

00:06:36.550 --> 00:06:40.390
because it is pretty abstract,
I'm going to go to a demo.

00:06:44.420 --> 00:06:46.930
So on your Leopard
machines or Snow Leopard,

00:06:47.050 --> 00:06:59.270
we're going to have a lot of
examples in the developer examples.

00:06:59.270 --> 00:06:59.270
So let's go ahead and go
to your developer examples

00:06:59.270 --> 00:06:59.270
inside Quartz Composer.

00:06:59.660 --> 00:07:03.430
We have a compositions directory,
and inside that is a conceptual

00:07:03.430 --> 00:07:05.100
compositions directory.

00:07:05.160 --> 00:07:07.790
I'm going to choose Image TV.

00:07:15.160 --> 00:07:17.800
Now even though we have most of
these compositions on your computer,

00:07:17.910 --> 00:07:21.380
we don't have a lot of time for
hands-on demonstrations this year.

00:07:21.380 --> 00:07:24.980
So go ahead and just pay attention
up here and you can go back to those

00:07:24.980 --> 00:07:27.190
compositions later on your own time.

00:07:28.110 --> 00:07:29.450
Now that this composition
is fully loaded,

00:07:29.450 --> 00:07:33.790
you can see that it's a wall of images
which is used to replicate the effect

00:07:34.140 --> 00:07:36.200
of Apple TV when it first starts up.

00:07:36.250 --> 00:07:38.100
It's a pretty neat effect, I think.

00:07:38.100 --> 00:07:41.650
But what I'm really interested in
today is this progress bar because

00:07:41.710 --> 00:07:46.110
it's a fairly modular component and it
can be reused in other compositions.

00:07:46.530 --> 00:07:51.760
So as an example of composition
that could be reused in,

00:07:51.760 --> 00:07:58.110
let's go back to the conceptual
examples and open up Image Flow.

00:08:04.270 --> 00:08:07.440
Now this composition you may also be
familiar with because it replicates

00:08:07.530 --> 00:08:09.780
the effect of CoverFlow in the system.

00:08:09.950 --> 00:08:13.360
CoverFlow is using OpenGL but Quartz
Composer is based on OpenGL so there's

00:08:13.360 --> 00:08:16.990
no reason you can't implement an effect
as cool as that in Quartz Composer.

00:08:17.000 --> 00:08:20.300
But as you can see,
even though it loads images from

00:08:20.300 --> 00:08:25.160
the desktop pictures folder,
there's no progress bar in this.

00:08:25.250 --> 00:08:26.250
So let's go ahead and add one.

00:08:26.480 --> 00:08:31.120
First of all, let's take a look at this,
the image TV composition and

00:08:31.620 --> 00:08:33.170
figure out how to read it.

00:08:37.910 --> 00:08:40.300
First thing I always do when I look
at a composition is figure out where

00:08:40.300 --> 00:08:43.990
the renderers are because that's
actually what's doing the hard work

00:08:44.390 --> 00:08:46.180
and pushing pixels to the screen.

00:08:46.500 --> 00:08:50.050
So the renderers now in
Snow Leopard are drawn in blue.

00:08:50.270 --> 00:08:52.960
And they are usually on the
right side of the composition

00:08:52.960 --> 00:08:56.440
because input goes from patches.

00:08:56.440 --> 00:08:58.840
They're inputs into the left side
and outputs on the right side.

00:08:58.840 --> 00:09:03.230
So for a renderer that has no outputs,
all the inputs are on the

00:09:03.230 --> 00:09:05.060
left side of the patch.

00:09:05.130 --> 00:09:08.330
So let's go ahead and zoom
in on one of these renderers.

00:09:09.620 --> 00:09:11.780
First thing a composition does
is clears the composition.

00:09:11.950 --> 00:09:15.070
This provides the black background
that you see and kind of makes

00:09:15.070 --> 00:09:17.490
sure there's no graphic corruption.

00:09:18.380 --> 00:09:21.300
After that,
we render a 3D transformation.

00:09:21.390 --> 00:09:24.390
Now, we don't know actually how the wall
is drawn because that's not important.

00:09:24.560 --> 00:09:26.870
It's encapsulated inside
this 3D transformation.

00:09:27.020 --> 00:09:30.090
And all we know is we have this block,
this blob on screen.

00:09:30.470 --> 00:09:36.080
Whatever is inside is rendering can
be animated by using -- by connecting

00:09:36.460 --> 00:09:43.100
these rotation translation inputs to,
for example, this Timelines patch.

00:09:43.100 --> 00:09:45.560
And so the Timelines are what
drive the whole composition.

00:09:46.460 --> 00:09:48.870
On layer three,
we have a sprite which provides

00:09:48.870 --> 00:09:51.220
the fade-in effect at the
beginning of the composition.

00:09:51.390 --> 00:09:55.430
And just below that is this macro
patch which contains all the necessary

00:09:55.430 --> 00:09:57.590
components for the progress bar.

00:09:57.590 --> 00:10:01.580
I'm going to go ahead and double
click on the macro patch and

00:10:01.620 --> 00:10:03.800
see what patches are inside.

00:10:04.490 --> 00:10:06.900
You can see it's composed of two sprites.

00:10:06.950 --> 00:10:10.050
The sprite renders a rectangle on screen.

00:10:10.160 --> 00:10:13.710
The lower sprite renders
just a gray square.

00:10:14.130 --> 00:10:18.050
And the upper sprite renders
with a width that is determined

00:10:18.050 --> 00:10:20.400
by the number of images loaded.

00:10:20.420 --> 00:10:23.740
So if I go back to the root macro patch
by clicking on the navigation bar,

00:10:23.840 --> 00:10:28.360
you can see once again this macro patch,
which has square corners because

00:10:28.570 --> 00:10:32.940
that's how we denote patches
which contain other patches.

00:10:34.090 --> 00:10:37.090
New in Snow Leopard,
we can unencapsulate this macro

00:10:37.090 --> 00:10:41.160
patch and make it all those internal
patches right here on the root level.

00:10:41.240 --> 00:10:43.780
And that's done by selecting the patch,
holding down the

00:10:43.910 --> 00:10:47.880
Control key and clicking,
and you can choose Explode Macro.

00:10:48.150 --> 00:10:52.770
That should make it really easy for you
to refactor your compositions because you

00:10:52.770 --> 00:10:56.960
can see all the connections are recreated
and you can now select a different

00:10:56.960 --> 00:10:59.050
set of patches to create a macro from.

00:11:00.840 --> 00:11:03.890
Now, I said I wanted to use this
progress bar in another composition,

00:11:03.960 --> 00:11:07.140
so that sounds like an excellent
chance to use a virtual patch.

00:11:07.240 --> 00:11:11.140
And a virtual patch will package
these patches up like a macro,

00:11:11.210 --> 00:11:14.660
but it will save it to my library
folder and allow me to insert

00:11:14.660 --> 00:11:16.570
it into other compositions.

00:11:16.920 --> 00:11:20.960
So I'm going to choose the editor menu,
say Create Virtual Patch,

00:11:21.020 --> 00:11:23.000
and name it Progress Bar.

00:11:25.680 --> 00:11:28.170
Now Quartz Composer has
gone behind the scenes,

00:11:28.170 --> 00:11:32.300
saved all those patches to my library
folder and replaced it with this patch,

00:11:32.390 --> 00:11:35.840
which no longer has rounded corners
because this is no longer a macro.

00:11:35.840 --> 00:11:38.930
It's actually a real patch as far
as Quartz Composer is concerned.

00:11:39.020 --> 00:11:44.520
And it's completely separated
from the system as far as

00:11:44.520 --> 00:11:47.420
the subgraph is concerned.

00:11:47.770 --> 00:11:53.310
So all you have to know is that this
is a real patch now in the composition.

00:11:54.170 --> 00:11:56.100
I'm going to close this down.

00:11:56.140 --> 00:11:59.860
It's still going to be open over here.

00:11:59.860 --> 00:12:03.500
And I'm going to open up
the image flow once again.

00:12:05.970 --> 00:12:08.700
Now when I want to insert a patch,
all I need to do is

00:12:08.820 --> 00:12:11.890
open the Patch Creator,
type in progress bar,

00:12:11.890 --> 00:12:15.370
and hit return and it will
insert into the workspace.

00:12:16.220 --> 00:12:19.990
This macro here is what does all
the heavy lifting of downloading

00:12:19.990 --> 00:12:21.860
and processing the images.

00:12:21.860 --> 00:12:25.320
For example, in this composition,
it processed a second copy of the

00:12:25.450 --> 00:12:28.780
image to create the reflection,
but that's all done under the hood

00:12:28.800 --> 00:12:32.040
because it's a macro and we don't
have to worry about the details.

00:12:32.400 --> 00:12:38.520
All we need to know is the
download progress output of this

00:12:38.520 --> 00:12:39.710
macro patch can be connected to
the input of this progress bar.

00:12:40.290 --> 00:12:43.280
Now when I go to full
screen and reload it,

00:12:43.280 --> 00:12:47.170
you can see that the images load and
the progress bar fills at the same time.

00:12:53.600 --> 00:12:55.540
Now to show you the real
power of a virtual patch,

00:12:55.590 --> 00:12:59.290
I'm going to open up that
previously opened image,

00:12:59.490 --> 00:13:01.810
Image TV composition.

00:13:02.350 --> 00:13:06.880
and show you how I can change
the virtual patch in one place

00:13:07.200 --> 00:13:11.130
and have that modification
affect all the open compositions.

00:13:11.130 --> 00:13:14.480
So I'm going to go to my preferences.

00:13:14.480 --> 00:13:16.340
Virtual patches are managed
in the Clips Manager.

00:13:16.340 --> 00:13:18.150
We still have clips,
but they have slightly

00:13:18.210 --> 00:13:19.170
different meanings.

00:13:19.290 --> 00:13:23.700
So I'm going to open up the progress
bar here in the Clips Manager.

00:13:23.700 --> 00:13:27.060
And down here are all those patches that
we've been using over and over again.

00:13:30.530 --> 00:13:34.010
Before the session,
I prepared a small asset,

00:13:34.060 --> 00:13:37.660
which is just a small little image
that provides an Aqua gradient.

00:13:37.750 --> 00:13:40.730
So I'm going to go ahead and
aquify all these progress bars.

00:13:46.720 --> 00:13:51.110
I've drag and dropped an image from
the finder into the workspace and that

00:13:51.110 --> 00:13:53.080
creates an image importer automatically.

00:13:53.140 --> 00:13:56.000
So that's a pretty easy way to
get images in your composition.

00:13:56.050 --> 00:14:00.040
Now I just need to click on an image,
connect it to the image input of

00:14:00.040 --> 00:14:04.820
the sprite which draws the progress
bar and save this virtual patch.

00:14:04.870 --> 00:14:11.080
And you'll notice the two
open compositions will

00:14:11.080 --> 00:14:11.080
automatically have their

00:14:12.710 --> 00:14:18.370
will automatically have their progress
bars updated to this Aqua look.

00:14:18.490 --> 00:14:22.600
Now when I restart, the progress bar is
automatically aquified.

00:14:22.650 --> 00:14:25.330
That's pretty good instant
savings right there.

00:14:27.800 --> 00:14:30.820
It's important to notice that
compositions that have virtual

00:14:30.850 --> 00:14:32.460
patches are like any other assets.

00:14:32.570 --> 00:14:36.300
So you do need to save those--you need to
distribute those with your composition.

00:14:36.300 --> 00:14:40.100
If you have, for example,
movies or downloaded images,

00:14:40.100 --> 00:14:42.330
it's going to be the same story.

00:14:42.460 --> 00:14:48.130
So make sure that you have
all your assets with your

00:14:48.130 --> 00:14:49.360
composition when you distribute it.

00:14:49.360 --> 00:14:49.360
So let's go ahead and
go back to the slides.

00:14:55.770 --> 00:14:58.820
We really think that that will save a
lot of time for creating compositions,

00:14:58.880 --> 00:15:02.090
but what are we going to do for your
compositions once they're created?

00:15:02.210 --> 00:15:05.210
Well, we've been working really hard in
Snow Leopard to make performance

00:15:05.210 --> 00:15:07.060
our number one priority,
and we think we've

00:15:07.060 --> 00:15:08.180
done a pretty good job.

00:15:08.340 --> 00:15:13.860
So all the compositions
that we've been writing,

00:15:14.220 --> 00:15:16.560
or that we've been testing, are faster,
as fast or faster,

00:15:16.560 --> 00:15:16.560
than their Leopard counterparts.

00:15:16.760 --> 00:15:19.790
and with some compositions such
as high iteration compositions

00:15:19.910 --> 00:15:21.520
that are up to eight times faster.

00:15:21.520 --> 00:15:23.090
So that's quite a bit of savings.

00:15:24.790 --> 00:15:28.260
We also have a certain
class of compositions,

00:15:28.260 --> 00:15:30.570
which,
when they're embedded in applications,

00:15:30.670 --> 00:15:33.730
are really useful, and those are the
event-driven compositions,

00:15:33.830 --> 00:15:36.610
because Quartz Composer was
initially designed as an

00:15:36.610 --> 00:15:40.340
animated graphics technology,
and so it's really good at that,

00:15:40.530 --> 00:15:43.690
but your applications
don't always animate,

00:15:43.790 --> 00:15:48.290
so Quartz Composer has developed a
system which allows Quartz Composer to

00:15:48.350 --> 00:15:52.290
analyze the graph and figure out when
the composition doesn't need to render,

00:15:52.320 --> 00:15:54.250
and we call that Idle State Detection.

00:15:54.260 --> 00:15:57.950
And to show how that works,
I'm going to go to

00:15:57.950 --> 00:16:00.600
another demo real quick.

00:16:05.730 --> 00:16:11.360
So I've created a composition which
is arbitrarily hard on the GPU because

00:16:11.360 --> 00:16:15.460
the teapot's object in Quartz
Composer is not optimized in any way.

00:16:15.460 --> 00:16:18.950
So just because this is
showing high CPU usage,

00:16:19.010 --> 00:16:20.500
that's by design.

00:16:20.550 --> 00:16:25.360
When I click on this and rotate it,
I can get the composition to animate.

00:16:25.480 --> 00:16:28.310
To help me out,
I've created this small application,

00:16:28.310 --> 00:16:31.610
which, by the way,
uses Quartz Composer as the visualization

00:16:32.030 --> 00:16:37.640
to give a CPU monitor with large
types so that you guys can all see it.

00:16:37.640 --> 00:16:40.430
So I spin this around,
you can see that the CPU process

00:16:40.430 --> 00:16:46.980
power for Quartz Composer is hovering
around 81%. But when it stops,

00:16:47.010 --> 00:16:49.450
the CPU power drops almost to nothing.

00:16:49.450 --> 00:16:54.650
And that's because of the idle state
detection that we've been implementing.

00:16:56.460 --> 00:16:58.730
It's important to notice that
Quartz Composer is doing all

00:16:58.730 --> 00:17:01.780
the analyzing in the background,
so you don't have to do

00:17:01.780 --> 00:17:03.580
anything special to set that up.

00:17:03.830 --> 00:17:06.330
And to prove that,
I'm going to open up the composition

00:17:06.360 --> 00:17:10.230
we were working with earlier,
this image flow composition,

00:17:10.230 --> 00:17:14.020
which is exactly the same as
the one on your Leopard machine,

00:17:14.020 --> 00:17:16.710
so we haven't done any
work to optimize it,

00:17:16.710 --> 00:17:19.970
and show you that it is
exactly the same story here.

00:17:19.970 --> 00:17:24.150
It's perfectly performant and
responds nicely to the keyboard.

00:17:24.150 --> 00:17:26.400
And when I open up the CPU meter,

00:17:29.950 --> 00:17:33.670
You can see that the processing
power required when it's

00:17:33.760 --> 00:17:36.360
animating is about 15% of the CPU.

00:17:36.460 --> 00:17:39.820
When I take my hands off the
keyboard and let it sit for a second,

00:17:40.090 --> 00:17:43.400
it drops down to about 0.4% of the CPU.

00:17:43.400 --> 00:17:45.380
So that's pretty good savings.

00:17:49.790 --> 00:17:53.220
This is going to come for free when
you're using QC view as we are in the

00:17:53.220 --> 00:17:57.320
editor because we control the timers and
we tell the composition when to animate.

00:17:57.510 --> 00:18:01.350
But what are you going to do if you
have a lower level API like QC Renderer?

00:18:01.440 --> 00:18:05.760
If I can go back to slides,
I'll explain how that works.

00:18:08.620 --> 00:18:11.200
So this is completely
optional because QCRenderer,

00:18:11.200 --> 00:18:15.530
as you know, just asks Quartz Composer to
render a frame and it gives

00:18:15.530 --> 00:18:17.400
you the rendered results.

00:18:17.510 --> 00:18:19.580
But if you want to check,
if you want to ask the composition

00:18:19.580 --> 00:18:23.240
if it needs to render right now,
you can ask it this question,

00:18:23.240 --> 00:18:25.880
next recommended time for time.

00:18:26.020 --> 00:18:28.780
And if the time it returns is now,
then you go ahead and render that --

00:18:28.860 --> 00:18:30.820
you call the render at time method.

00:18:30.820 --> 00:18:33.680
But if that time it returns
back is in the future,

00:18:34.020 --> 00:18:37.610
then you can forgo rendering
for this iteration of your

00:18:37.630 --> 00:18:41.200
timer loop or your display link,
whatever you're using.

00:18:41.250 --> 00:18:44.650
And so that provides you with
the optimum performance for

00:18:44.650 --> 00:18:46.890
those idle state opportunities.

00:18:47.260 --> 00:18:50.800
Now, I said that QuartzComposer analyzes
the graph and asks all the patches

00:18:50.800 --> 00:18:52.480
how -- if it needs to render.

00:18:52.480 --> 00:18:55.330
So if you're a patch writer,
you may also want to respond.

00:18:55.560 --> 00:18:57.490
So there's a new API for that as well.

00:18:57.490 --> 00:19:01.130
If you override this method
on your time-dependent patches

00:19:01.510 --> 00:19:05.550
and tell the renderer that,
yes, you do want to render this time,

00:19:05.600 --> 00:19:07.670
you can return the current time.

00:19:07.670 --> 00:19:10.210
But if you don't want
to render at this frame,

00:19:10.350 --> 00:19:13.660
then you can return infinity
and QuartzComposer will take

00:19:13.670 --> 00:19:17.400
that into consideration when
it's analyzing the graph.

00:19:17.500 --> 00:19:20.010
Now, please note that this
is completely optional.

00:19:20.010 --> 00:19:23.000
So if you don't implement this,
none of your patches are going to break.

00:19:23.000 --> 00:19:25.100
They're going to work
exactly the same as before.

00:19:25.210 --> 00:19:29.440
And this is also completely
unnecessary if your patch just

00:19:29.440 --> 00:19:33.350
depends on the inputs because it's
going to do the right thing anyway.

00:19:33.350 --> 00:19:36.000
This is only if, for example,
you're writing a network-dependent

00:19:36.000 --> 00:19:39.070
patch that checks the Internet once
per minute or something.

00:19:39.160 --> 00:19:43.080
So the time you return could be that
time remaining until that minute is up.

00:19:43.080 --> 00:19:44.470
it up.

00:19:45.280 --> 00:19:46.760
So this is really easy
for you to implement.

00:19:46.830 --> 00:19:48.100
And in most cases,
you're not going to need

00:19:48.100 --> 00:19:49.640
to do any work at all.

00:19:49.700 --> 00:19:54.270
And this is really great for your
event-driven applications because not

00:19:54.300 --> 00:19:58.080
only does it save processing time,
it'll save batteries--

00:19:58.080 --> 00:20:01.200
battery time as well,
which is really important

00:20:01.200 --> 00:20:03.100
for those Apple portables.

00:20:03.100 --> 00:20:06.440
So to tell you how to take
advantage of this new API and

00:20:06.440 --> 00:20:10.600
the new idle state optimization,
we're going to get Alessandro up

00:20:10.600 --> 00:20:10.600
here to talk about the interaction
model in Quartz Composer.

00:20:16.930 --> 00:20:20.060
Hey, thanks Troy.

00:20:20.100 --> 00:20:21.960
Alright, so as Troy mentioned,
I'm going to talk a little bit about

00:20:22.030 --> 00:20:23.460
interaction in Quartz Composer.

00:20:23.490 --> 00:20:26.210
So one of the reasons that we started
to look at interaction in Quartz

00:20:26.210 --> 00:20:29.500
Composer is that we found that a lot
of developers were creating these rich,

00:20:29.500 --> 00:20:32.960
interactive, media-based compositions.

00:20:32.970 --> 00:20:36.060
A lot of them being full-screen
compositions wherein you'd actually have

00:20:36.060 --> 00:20:40.460
to create these on-screen type controls
and it was actually rather difficult.

00:20:40.510 --> 00:20:43.080
So what we did is we went
ahead and created two modes of

00:20:43.110 --> 00:20:45.730
interaction in Quartz Composer,
the first one being

00:20:45.750 --> 00:20:46.900
interactive placement.

00:20:46.920 --> 00:20:49.100
And what this is,
is this is an actual rendering mode

00:20:49.100 --> 00:20:52.100
and it allows you to just quickly
and easily set up your compositions,

00:20:52.160 --> 00:20:54.850
place a bunch of images and get going.

00:20:55.110 --> 00:20:57.040
And then the next type of
interaction that we added

00:20:57.040 --> 00:20:58.870
was interactive compositions.

00:20:59.100 --> 00:21:00.600
In this case, this interaction patch.

00:21:00.630 --> 00:21:03.020
And what that allows you
to do is actually make your

00:21:03.020 --> 00:21:04.520
compositions interactive.

00:21:04.610 --> 00:21:08.710
So I can sit up here and
talk about interaction,

00:21:08.710 --> 00:21:09.440
or I could just show you.

00:21:09.540 --> 00:21:12.170
So in this case,
what we're going to end up

00:21:12.170 --> 00:21:16.180
building is this interactive
photo browsing composition.

00:21:16.180 --> 00:21:17.590
If I can go to Demo.

00:21:22.240 --> 00:21:24.240
All right, so I'll just get set up here.

00:21:24.240 --> 00:21:30.960
So the first thing that we'll
look at is interactive placement.

00:21:31.270 --> 00:21:32.960
And again,
this is just a quick and easy way

00:21:32.960 --> 00:21:36.440
to get your compositions set up.

00:21:39.700 --> 00:21:41.400
Okay.

00:21:41.420 --> 00:21:44.940
So, you know, as usual,
we'll clear the screen.

00:21:44.940 --> 00:21:48.710
And the next thing I'm going to
do is I'm just going to grab three

00:21:48.710 --> 00:21:52.780
images here and drag them from
the Finder into the workspace.

00:21:52.780 --> 00:21:58.750
We'll create three image importer nodes.

00:21:58.750 --> 00:22:03.120
And I'll just use a
billboard to display these.

00:22:03.120 --> 00:22:03.120
So here I have my first image.

00:22:05.810 --> 00:22:09.650
My second image and my third image.

00:22:09.650 --> 00:22:17.750
And you'll notice that these images are
all stacked one on top of the other.

00:22:17.750 --> 00:22:18.170
So traditionally in Quartz Composer,
what I could do is I can

00:22:18.170 --> 00:22:18.170
inspect one of these billboards.

00:22:19.930 --> 00:22:21.800
And I would have to
independently position them

00:22:21.800 --> 00:22:23.880
in the X and the Y dimension.

00:22:23.910 --> 00:22:25.780
So in this case, like this.

00:22:25.810 --> 00:22:26.680
And you can do it.

00:22:26.740 --> 00:22:30.110
And you've probably seen some pretty
great examples of some of the things

00:22:30.110 --> 00:22:33.480
that you can do in Quartz Composer,
but it's not necessarily optimal.

00:22:33.480 --> 00:22:36.610
So what we did is we added this new
interactive placement rendering mode,

00:22:36.610 --> 00:22:39.870
which you can see up here
as this little cross.

00:22:39.910 --> 00:22:42.130
So if I just click on that,
now I can go ahead and actually

00:22:42.130 --> 00:22:44.370
just position these as I want.

00:22:49.100 --> 00:22:51.200
So, you know, I mean,
kind of an obvious thing,

00:22:51.200 --> 00:22:53.100
but you'll notice that
as I move them around,

00:22:53.100 --> 00:22:55.060
the X and the Y position
actually changes.

00:22:55.060 --> 00:22:58.790
So what I can do is I can just stop,
restart the composition, save, reopen,

00:22:58.790 --> 00:23:01.380
they get re-serialized
into the composition.

00:23:01.380 --> 00:23:03.800
So again, you know,
just a quick and easy way of kind

00:23:03.830 --> 00:23:05.610
of setting up your compositions.

00:23:05.630 --> 00:23:08.340
But, you know,
when your compositions are actually

00:23:08.340 --> 00:23:12.280
being executed within whatever
environment they're being executed in,

00:23:12.280 --> 00:23:13.900
this isn't going to work.

00:23:14.020 --> 00:23:15.250
This is really just for getting set up.

00:23:15.370 --> 00:23:16.240
It's an editor feature.

00:23:16.240 --> 00:23:19.020
What you want to do is you want to
then leverage the interaction patch.

00:23:19.100 --> 00:23:21.800
So I've gone back to here to
the normal rendering mode.

00:23:21.800 --> 00:23:24.420
I'll just get cleaned
up here a little bit,

00:23:24.580 --> 00:23:26.580
and I'm going to add our
new interaction patch.

00:23:30.210 --> 00:23:31.490
So here's the interaction patch.

00:23:31.500 --> 00:23:37.400
And what I'm going to do is just
connect the new interaction port,

00:23:37.400 --> 00:23:40.540
which is going to get data back
and forth between the billboard

00:23:40.550 --> 00:23:43.360
and the interaction patch to do
a little bit of hit detection,

00:23:43.360 --> 00:23:44.300
stuff like that.

00:23:44.320 --> 00:23:47.580
And I can just connect the x
position and the y position of

00:23:47.580 --> 00:23:49.820
my interaction patch to my image.

00:23:49.820 --> 00:23:52.240
You'll notice that it actually
snaps into a certain place.

00:23:52.250 --> 00:23:56.210
And the reason why is because
the initial position for the

00:23:56.270 --> 00:23:58.160
interaction patch is going to be at 0,
0.

00:23:58.160 --> 00:24:01.490
And if I wanted to actually set
up my interaction patch or the

00:24:01.490 --> 00:24:04.120
components of my composition,
which are going to be interactive,

00:24:04.120 --> 00:24:06.290
I could just change the offset.

00:24:08.030 --> 00:24:09.150
So now this is interactive.

00:24:09.170 --> 00:24:11.730
I can just grab it and move it around.

00:24:11.880 --> 00:24:14.760
The idea here being, if I stop,
restart my composition,

00:24:14.760 --> 00:24:17.120
it's going to snap back
to that original offset.

00:24:17.280 --> 00:24:21.310
So you then use the offset to
kind of position your objects.

00:24:25.900 --> 00:24:28.640
So the thing that's really powerful
here is we could have just made

00:24:28.810 --> 00:24:32.620
interaction work in the same way that
we do for the interactive placement,

00:24:32.820 --> 00:24:36.140
but by adding this patch,
we really kind of have created

00:24:36.140 --> 00:24:39.020
a new type of interaction model.

00:24:39.020 --> 00:24:41.330
So just like in Quartz
Composer with everything else,

00:24:41.330 --> 00:24:44.110
you can actually modulate
these values in line.

00:24:44.120 --> 00:24:45.820
So here I have my X position
and my Y position.

00:24:45.820 --> 00:24:46.760
They're going into my billboard.

00:24:46.820 --> 00:24:50.680
I can just stick patches in
between to change that behavior.

00:24:50.680 --> 00:24:52.940
So as an example,
why would you want to do that?

00:24:53.080 --> 00:24:57.140
Okay, so a very simple example is one of
the features that we added to the

00:24:57.140 --> 00:25:01.660
interaction patch is the ability
to make these things throwable.

00:25:01.660 --> 00:25:04.900
So I can just make this throwable,
grab it, and throw it away.

00:25:04.900 --> 00:25:07.810
So now it's gone, right?

00:25:08.080 --> 00:25:10.760
That's great,
except somebody might not have

00:25:10.760 --> 00:25:13.160
wanted that to have been thrown away.

00:25:13.240 --> 00:25:17.170
So what you can do is you can
stop and restart your application,

00:25:17.540 --> 00:25:19.100
which nobody's going to do.

00:25:19.160 --> 00:25:22.400
Or you can actually, say,
set the range of these values

00:25:22.470 --> 00:25:24.800
coming out of the interaction patch.

00:25:24.820 --> 00:25:27.480
And you do that with a range patch.

00:25:27.490 --> 00:25:29.410
So here I have a range.

00:25:29.460 --> 00:25:36.640
I can just set the range min to
minus 0.5 and the range max to 0.5.

00:25:36.650 --> 00:25:37.630
Just duplicate that.

00:25:38.620 --> 00:25:43.770
And I'll modulate these x and y values
coming out of the interaction patch.

00:25:45.060 --> 00:25:47.620
Set those into the billboard.

00:25:47.660 --> 00:25:49.160
And now you'll notice
that it snapped back.

00:25:49.370 --> 00:25:52.240
Now I can throw this,
but it'll be pinned.

00:25:52.310 --> 00:25:54.710
So that's just a very simple
example of how you can modulate

00:25:54.710 --> 00:25:56.330
interaction in Quartz Composer.

00:25:56.340 --> 00:26:02.390
But obviously, you can do some pretty
advanced things with it.

00:26:02.390 --> 00:26:07.560
And to give you an example,
I'm going to build that photo

00:26:07.560 --> 00:26:10.650
browsing application for you.

00:26:10.650 --> 00:26:15.000
All right,
I'll just get set up here again.

00:26:24.180 --> 00:26:26.820
So in that photo browsing application,
the first thing that we're going to do is

00:26:26.820 --> 00:26:29.550
just kind of get our environment set up.

00:26:29.550 --> 00:26:34.080
So I'm just going to paint the
background with a simple gradient.

00:26:34.110 --> 00:26:36.580
To do that, I'm going to use a billboard.

00:26:36.580 --> 00:26:40.750
Oops.

00:26:40.860 --> 00:26:42.780
Let's try that again.

00:26:54.720 --> 00:26:56.890
And for this,
I've just prepared a simple gradient that

00:26:56.890 --> 00:27:00.010
I made in my favorite image editing tool.

00:27:03.810 --> 00:27:05.720
And so in this case,
I actually want the gradient to be sized

00:27:05.780 --> 00:27:08.950
to the view or the rendering destination.

00:27:08.960 --> 00:27:11.820
So to do that,
I'm just going to set my billboard

00:27:11.820 --> 00:27:14.060
to have some custom dimensions.

00:27:17.000 --> 00:27:20.370
And I'll just use the rendering
destination dimensions.

00:27:20.500 --> 00:27:23.200
And the reason that I want to
do this is because when I'm

00:27:23.200 --> 00:27:25.900
creating this composition,
I can actually just go

00:27:25.900 --> 00:27:27.110
ahead and manually size it.

00:27:27.120 --> 00:27:29.360
But the thing is I don't know where
it's actually going to be shown.

00:27:29.360 --> 00:27:31.940
So it could be shown on my MacBook,
or it can be shown on

00:27:31.940 --> 00:27:35.630
somebody's 30-inch monitor,
in which case I want the gradient

00:27:35.630 --> 00:27:38.310
to be sized to whatever destination
it's actually displayed on.

00:27:38.350 --> 00:27:39.970
So in this case,
if I then go ahead and resize

00:27:40.030 --> 00:27:42.500
the viewer or go full screen,
you'll notice that it

00:27:42.500 --> 00:27:43.940
scales appropriately.

00:27:44.610 --> 00:27:48.170
So I'm just going to pick these
patches and I'm going to create a macro

00:27:48.170 --> 00:27:50.340
and I'll just call that background.

00:27:50.460 --> 00:27:52.020
Again,
it's always a good idea when creating

00:27:52.020 --> 00:27:58.190
these compositions to constantly
refactor and keep things kind of clean.

00:27:58.580 --> 00:28:01.920
The next thing I'm going to do
is I'm just going to display this

00:28:01.920 --> 00:28:04.860
other image here along the bottom.

00:28:04.860 --> 00:28:08.020
This is going to be the image
bar at the bottom that's going

00:28:08.020 --> 00:28:09.790
to hold each one of my images.

00:28:09.860 --> 00:28:12.320
Again, I'll just use a billboard.

00:28:13.510 --> 00:28:15.450
Connect my image.

00:28:15.880 --> 00:28:18.960
I'll set a custom size for that as well.

00:28:21.700 --> 00:28:24.770
So I'll make it, I don't know, 0.3 high.

00:28:24.770 --> 00:28:28.340
And I'm going to make it really wide,
and that'll be apparent in a minute.

00:28:28.350 --> 00:28:30.460
So let's say like 15 or something.

00:28:30.780 --> 00:28:32.460
So in this case,
now I have it and it's just sitting

00:28:32.460 --> 00:28:33.960
there and I want to anchor to the bottom.

00:28:34.060 --> 00:28:36.290
So I'll just use an anchor patch.

00:28:36.320 --> 00:28:37.880
Anchor position.

00:28:37.900 --> 00:28:39.660
In this case,
I'll tell the anchor position that

00:28:39.660 --> 00:28:44.330
the height is 0.3 and I will use
that to pin the Y position by setting

00:28:44.330 --> 00:28:46.360
the anchor point to bottom center.

00:28:46.450 --> 00:28:47.830
So again, resolution independent.

00:28:47.860 --> 00:28:49.520
I want this always pinned at the bottom.

00:28:49.550 --> 00:28:55.260
I can now redrag and change
the size of my viewer,

00:28:55.260 --> 00:28:55.780
go full screen,
the bars are at the bottom.

00:28:57.800 --> 00:28:59.000
Clean up a little bit.

00:28:59.000 --> 00:29:01.340
OK, so the next thing that I want to
do is now that I have this little

00:29:01.340 --> 00:29:03.980
image bar here at the bottom,
I want to get a bunch of

00:29:03.990 --> 00:29:05.540
images and display them.

00:29:06.920 --> 00:29:11.110
So to do that, I'm going to use a similar
macro to what Troy used,

00:29:11.150 --> 00:29:12.660
which is download and process images.

00:29:12.730 --> 00:29:16.320
But in this case,
I've actually changed it a little

00:29:16.320 --> 00:29:18.560
bit to apply some different
effects to these images.

00:29:18.560 --> 00:29:23.600
And what this does is it simply goes
out to the Finder and grabs a directory

00:29:23.600 --> 00:29:28.490
of images and then iterates over that
list of image paths and downloads

00:29:28.490 --> 00:29:33.070
those images and applies a CI filter
to add a little bit of a border,

00:29:33.070 --> 00:29:34.120
a shadow,
and then stores them in a structure.

00:29:35.060 --> 00:29:39.190
Okay, so considering that
they're now in a structure,

00:29:39.190 --> 00:29:41.640
what I need to do is use an
iterator to display them.

00:29:41.740 --> 00:29:44.470
So I'll just make sure
that my directory...

00:29:44.650 --> 00:29:45.260
is set.

00:29:45.260 --> 00:29:47.590
I have a bunch of images
here on my desktop.

00:29:47.610 --> 00:29:49.780
I'm going to use an iterator.

00:29:50.020 --> 00:29:52.370
You'll notice that the iterator
is non-consuming for those of

00:29:52.370 --> 00:29:54.120
you that are familiar with it.

00:29:54.200 --> 00:29:56.870
An iterator,
all that it's going to do is it's going

00:29:56.960 --> 00:29:59.170
to iterate a certain number of times.

00:30:00.780 --> 00:30:02.630
So it'll loop over some data.

00:30:02.670 --> 00:30:03.820
So in this case,
what I'm going to have it do

00:30:03.820 --> 00:30:07.730
is I'm going to have it draw a
billboard a certain number of times.

00:30:09.140 --> 00:30:10.790
I'm going to grab a
structure index member,

00:30:10.790 --> 00:30:14.270
which I can use to look
up into a structure,

00:30:14.270 --> 00:30:18.370
publish that structure port,
set the index using

00:30:18.370 --> 00:30:22.840
the iterator variables,
which is a special patch which

00:30:22.910 --> 00:30:25.860
can be used inside of an iterator.

00:30:25.860 --> 00:30:28.870
In this case,
I'm going to get the current index.

00:30:28.870 --> 00:30:28.870
And that's going to give me the
current index of the current iteration.

00:30:28.870 --> 00:30:28.870
I'll connect that to my image.

00:30:29.830 --> 00:30:31.220
Clean up.

00:30:31.840 --> 00:30:34.890
Now I can just connect the image
structure to my structure here.

00:30:34.900 --> 00:30:37.810
And you'll notice it'll
load a bunch of dog images.

00:30:37.810 --> 00:30:41.950
You'll also notice that they each have
a little bit of a black background.

00:30:41.950 --> 00:30:45.490
That's because I didn't set the
blending mode of my billboard.

00:30:45.490 --> 00:30:49.490
I'll just go inside the iterator,
set the blending mode, in this case,

00:30:49.490 --> 00:30:50.080
to over.

00:30:50.080 --> 00:30:53.300
And I have a bunch of images
laid on top of one or the other.

00:30:53.300 --> 00:30:55.520
It's also a good idea
to set the loop count,

00:30:55.520 --> 00:30:55.520
the number of iterations that
you perform within your iterator.

00:30:55.700 --> 00:30:58.480
So I can just use a structure count.

00:30:58.530 --> 00:31:00.400
So in this case,
if I just hover over the image structure,

00:31:00.400 --> 00:31:03.940
you'll see that there's 24 members,
but I'm only doing 10 iterations.

00:31:03.940 --> 00:31:07.110
So right now,
I only have 10 images being displayed.

00:31:07.210 --> 00:31:09.540
So now I can just set that to be dynamic.

00:31:09.540 --> 00:31:11.040
In this case, now it'll be 24.

00:31:11.040 --> 00:31:14.640
So again, I have 24 images just overlaid
one on top of the other.

00:31:14.640 --> 00:31:18.490
So what I want to do next is make
these images a little bit smaller

00:31:18.490 --> 00:31:22.550
and kind of arrange them so that
they're offset each in space.

00:31:22.800 --> 00:31:25.980
So to make them smaller,
I can just go in and change the width.

00:31:25.980 --> 00:31:29.430
And this width is going to apply to every
single one of these iterations because

00:31:29.430 --> 00:31:31.240
I have not differentiated it in any way.

00:31:31.410 --> 00:31:34.190
I'll just set them to be 0.25.

00:31:34.270 --> 00:31:37.710
And that's just a little less than
that bar height that we set so

00:31:37.710 --> 00:31:39.720
that they'll sit within that bar.

00:31:39.790 --> 00:31:41.960
And now we want to spread them out.

00:31:44.260 --> 00:31:46.000
So the question is,
is how do we differentiate

00:31:46.000 --> 00:31:48.800
these images or their positions?

00:31:48.880 --> 00:31:51.040
And we can do that just
with the current index.

00:31:51.080 --> 00:31:54.150
And that's really an identifier or
a means by which to differentiate

00:31:54.180 --> 00:31:55.150
items within your iterator.

00:31:55.160 --> 00:31:57.310
So in this case,
I'm just going to say take some value,

00:31:57.310 --> 00:32:00.360
which is going to be something like a
little bit more than their actual size.

00:32:00.390 --> 00:32:01.890
So I have a little bit of a border.

00:32:01.890 --> 00:32:05.000
So I'm going to take something like
0.3 and use that to multiply by,

00:32:05.000 --> 00:32:05.840
say, the index.

00:32:05.840 --> 00:32:07.370
So it'll be 0.3 times 0.

00:32:07.380 --> 00:32:09.010
So that'll be 0.3 times 1.

00:32:09.010 --> 00:32:11.650
That'll be 0.3, 0.6, so on and so forth.

00:32:13.060 --> 00:32:16.390
So I can just use a simple
mathematical expression.

00:32:19.580 --> 00:32:24.640
And I will change the
expression to be exactly that.

00:32:24.640 --> 00:32:31.590
So it'll just be 0.3 times index.

00:32:36.300 --> 00:32:39.060
And now you'll notice that
they're arranged independently.

00:32:39.060 --> 00:32:42.180
Each one is offset.

00:32:42.220 --> 00:32:43.620
So in this case,
I also kind of want to slide

00:32:43.630 --> 00:32:46.130
them a little bit over,
make this a little bit

00:32:46.200 --> 00:32:47.750
bigger so you can see.

00:32:48.170 --> 00:32:52.100
I want to slide them over to the left and
then I'm also going to slide them down.

00:32:52.100 --> 00:32:54.780
So to slide them over to the left,
I can just add a little

00:32:54.780 --> 00:32:56.100
bit of an offset here.

00:32:56.100 --> 00:33:00.100
So say, I don't know,
plus the start position.

00:33:00.100 --> 00:33:05.540
And, you know, I don't know what that is,
but I can just eyeball it,

00:33:05.540 --> 00:33:06.780
which is kind of nice.

00:33:08.520 --> 00:33:11.300
So we'll just move it over here.

00:33:11.300 --> 00:33:13.620
And now in order to move down,
I can do the same thing.

00:33:13.750 --> 00:33:16.510
But like I said,
we're kind of creating this so it'll

00:33:16.510 --> 00:33:20.960
work in resolution independent modes or
in resolution independent environments.

00:33:20.980 --> 00:33:23.220
So instead of just eyeballing
it and sliding it down,

00:33:23.220 --> 00:33:27.970
I'll just publish the Y position
here and use the position that we've

00:33:28.010 --> 00:33:32.160
generated from our anchor position
to position that bar at the bottom

00:33:32.160 --> 00:33:34.020
to anchor our images at the bottom.

00:33:34.020 --> 00:33:35.920
So now if I resize this
and go full screen,

00:33:35.920 --> 00:33:38.960
you'll notice that they're always
pinned there at the bottom.

00:33:39.600 --> 00:33:41.800
So that's basically the
layout for our composition.

00:33:41.800 --> 00:33:45.800
All we did is we just positioned a
gradient there at the background,

00:33:45.920 --> 00:33:49.220
bar at the bottom, and then a bunch of
images using an iterator.

00:33:52.670 --> 00:33:55.620
The next step is to add some
interactivity to each of these

00:33:55.620 --> 00:33:58.820
little billboards so that we can go
ahead and drag them around and kind

00:33:58.820 --> 00:34:02.280
of position them and create some
kind of photo browsing narrative.

00:34:02.330 --> 00:34:07.060
And to do that,
I'm going to use the interaction patch.

00:34:09.510 --> 00:34:13.940
I'll just grab the interaction patch,
connect that to my billboard,

00:34:14.080 --> 00:34:16.200
and then I'll connect
the X and the Y position.

00:34:16.200 --> 00:34:19.840
But you'll notice that I already have
these X and Y positions connected.

00:34:19.990 --> 00:34:23.420
So again, if you'll recall,
I can just input these positions

00:34:23.470 --> 00:34:27.050
and use the interaction patch
to actually modulate the initial

00:34:27.050 --> 00:34:28.800
position of all of my images.

00:34:28.800 --> 00:34:31.190
So I'll just connect the X position.

00:34:32.300 --> 00:34:45.800
[Transcript missing]

00:34:46.460 --> 00:34:49.020
So what that'll do is that'll
refactor my composition,

00:34:49.020 --> 00:34:51.850
put this input splitter in here
that has its port published and

00:34:51.950 --> 00:34:54.090
connected to the level above.

00:34:54.150 --> 00:34:58.360
And now I can just connect that
to my interaction patch and the

00:34:58.890 --> 00:35:01.400
interaction patch to my billboard.

00:35:01.580 --> 00:35:04.730
Again, I'll just clean up a little bit.

00:35:04.730 --> 00:35:08.170
Now if I go full screen,
you'll notice I can

00:35:08.170 --> 00:35:10.390
just drag these images.

00:35:17.710 --> 00:35:20.090
One thing you'll notice is that
I've arranged these images at

00:35:20.100 --> 00:35:22.880
the bottom and there happen to
be 24 and this one's cut off.

00:35:22.900 --> 00:35:26.410
So there's a whole bunch of images
that keep going off into the distance.

00:35:26.440 --> 00:35:30.420
So what I can do is actually make this
bar here at the bottom draggable and

00:35:30.420 --> 00:35:33.700
then use that position to offset the
positions of each one of my images.

00:35:33.700 --> 00:35:38.570
So again, it's just an interaction patch.

00:35:38.620 --> 00:35:43.800
Here's that image bar,
which I can just relabel

00:35:43.800 --> 00:35:45.850
so you guys know.

00:35:48.700 --> 00:35:50.210
And in this case,
all I need to do is be able

00:35:50.250 --> 00:35:51.880
to move it in the X dimension.

00:35:52.040 --> 00:35:53.860
There's nothing special that
you have to do other than

00:35:53.860 --> 00:35:56.360
just connect the X position.

00:35:56.400 --> 00:35:58.710
So now I have my X position.

00:35:59.550 --> 00:36:02.970
And I'm going to just say
add another offset to the

00:36:02.970 --> 00:36:06.660
positioning of the offset X.

00:36:07.040 --> 00:36:08.900
I have my individual
images within the iterator.

00:36:09.050 --> 00:36:11.590
So we'll say bar position.

00:36:11.590 --> 00:36:15.950
And I'll just publish that.

00:36:17.030 --> 00:36:19.580
And connect the X position
here to my bar position.

00:36:19.640 --> 00:36:25.840
So now I can literally just grab my bar,
move it around, and continue on.

00:36:25.860 --> 00:36:28.510
I can even say make that throwable.

00:36:29.000 --> 00:36:32.180
You'll notice I'll get into the same
situation whereby I can end up kind

00:36:32.180 --> 00:36:34.290
of sliding this off into the distance.

00:36:34.290 --> 00:36:38.500
Here you'll see the edge of my bar,
not necessarily super clean.

00:36:38.580 --> 00:36:40.240
Again,
we can just apply the same principle.

00:36:40.300 --> 00:36:43.380
We can just range.

00:36:43.470 --> 00:36:45.790
I'll just range that value.

00:36:47.890 --> 00:36:50.120
Again, I can just kind of eyeball it.

00:36:50.350 --> 00:36:54.390
So in this case, my exposition is...

00:36:57.200 --> 00:37:03.960
Let's see, for my last image,
negative 5.2, you know,

00:37:03.960 --> 00:37:06.730
and at the start it'll actually be zero.

00:37:07.510 --> 00:37:11.400
So the min will be negative 5.2.

00:37:11.410 --> 00:37:14.300
The max will be 0.

00:37:14.300 --> 00:37:16.710
And I'll just put that in line.

00:37:19.320 --> 00:37:24.710
So now I can just kind of throw it to
the end there and nothing will pop off.

00:37:33.270 --> 00:37:38.720
Okay, so for the last thing is I want to
make these images actually kind of

00:37:38.720 --> 00:37:41.200
grow so that when I place them up top,
what I'm doing is, again,

00:37:41.200 --> 00:37:42.530
I'm kind of creating this narrative.

00:37:42.540 --> 00:37:46.100
And I'd actually like the model
here to be that I have a bunch of

00:37:46.120 --> 00:37:50.240
images at the bottom that represent,
say, my library of images,

00:37:50.240 --> 00:37:52.650
and then at the top,
some selects that I've chosen.

00:37:54.460 --> 00:37:56.660
So what I can do is in
order to make these,

00:37:56.660 --> 00:38:01.020
say, grow when I drag them up,
is I can just test the position of the

00:38:01.020 --> 00:38:06.310
actual image against some value and then
say if it is larger than that value in y,

00:38:06.350 --> 00:38:08.620
I can just switch the sizes.

00:38:08.670 --> 00:38:12.920
So why don't we go and do that?

00:38:12.980 --> 00:38:15.550
So in order to do that,
what I'm going to do is I'm just going

00:38:15.550 --> 00:38:17.500
to use a conditional to test the value.

00:38:18.550 --> 00:38:21.670
And I'm going to be
testing the Y position.

00:38:21.710 --> 00:38:25.940
And I want to say if that Y position
is greater than-- in this case,

00:38:25.940 --> 00:38:28.440
we have the Y position of our bar,
which again is always going

00:38:28.440 --> 00:38:31.310
to change and always be pinned
to the bottom of our view.

00:38:31.410 --> 00:38:33.910
And that's actually going to be
this little line here in the middle,

00:38:33.910 --> 00:38:35.900
which represents the
middle of our bar image.

00:38:35.900 --> 00:38:38.780
So I want it to be a little
bit above so that it doesn't

00:38:38.780 --> 00:38:40.640
just pop as soon as I grab it.

00:38:41.370 --> 00:38:43.800
So I'll just grab a little math patch.

00:38:43.840 --> 00:38:46.600
You'll notice we've actually
made it a little bit smaller,

00:38:46.630 --> 00:38:48.900
which is nice and easier to work with.

00:38:48.900 --> 00:38:52.690
And I'll say, I don't know,
add a .2 to that.

00:38:53.670 --> 00:38:57.790
So now if my Y position is greater
than the bar position plus 0.2,

00:38:57.840 --> 00:39:01.140
I want to use that to
switch between two values.

00:39:01.240 --> 00:39:04.200
And to do that in Quartz Composer,
we have a multiplexer.

00:39:04.200 --> 00:39:07.470
For those of you familiar
with DSP tech terminology,

00:39:07.470 --> 00:39:09.210
it's basically a switch.

00:39:09.800 --> 00:39:11.860
And I'll change the type,
which is generally an important

00:39:11.860 --> 00:39:13.540
thing to do in Quartz Composer.

00:39:13.540 --> 00:39:15.930
And the reason why,
particularly in this case,

00:39:16.010 --> 00:39:18.700
is because I want to put
values on the input ports.

00:39:18.700 --> 00:39:21.800
So I'll set the type to number,
and then I can go ahead

00:39:21.800 --> 00:39:23.180
and just set the value.

00:39:23.200 --> 00:39:27.280
So for this particular example,
I'm saying if the Y position is

00:39:27.290 --> 00:39:30.460
greater than some other position,
then in that case it'll be true

00:39:30.460 --> 00:39:32.500
and it'll use source number one.

00:39:32.520 --> 00:39:38.490
So I want that to be a value of one
and the current size to be 0.25.

00:39:38.900 --> 00:39:42.800
And now if I connect that to my width,
you'll notice that those images up

00:39:42.900 --> 00:39:46.940
top just kind of get larger and the
ones at the bottom stay smaller.

00:39:46.970 --> 00:39:49.480
So I can just drag these back down.

00:39:52.300 --> 00:39:54.000
And then you have a pretty
simple way of kind of switching

00:39:54.000 --> 00:39:58.340
between two values based on the
interactive value of the Y position.

00:40:03.300 --> 00:40:05.900
So that's what makes it really
easy and nice to kind of,

00:40:05.960 --> 00:40:08.730
in this case,
just kind of place a bunch of images.

00:40:08.730 --> 00:40:11.200
That guy's hair is just crazy.

00:40:11.200 --> 00:40:16.250
This guy's pretty cool.

00:40:18.300 --> 00:40:22.700
The monkey riding the dog.

00:40:22.700 --> 00:40:24.650
But you'll notice that when
I do pull them up from the

00:40:24.650 --> 00:40:26.010
bottom that it's discontinuous.

00:40:26.030 --> 00:40:27.090
It'll just pop in size.

00:40:27.130 --> 00:40:30.590
As soon as I break that value,
somewhere right around there,

00:40:30.590 --> 00:40:33.850
it just instantly switches
between these two values.

00:40:34.730 --> 00:40:37.640
So, probably won't be
pleasing to most of you,

00:40:37.640 --> 00:40:41.160
so what we can do is we can just
smooth that value out over time.

00:40:43.360 --> 00:40:45.940
And to do that,
we'll just use the smooth patch.

00:40:46.010 --> 00:40:48.630
So I'll just grab a smooth patch.

00:40:51.870 --> 00:40:58.710
Connect that value,
I'll set the duration to be 0.2 and

00:40:58.710 --> 00:41:01.710
the type to be sinusoidal in and out.

00:41:04.830 --> 00:41:07.680
Connect that to my width.

00:41:07.740 --> 00:41:09.910
So now if I go full screen,

00:41:10.920 --> 00:41:12.680
You'll notice that when
I drag them from the bottom,

00:41:12.680 --> 00:41:16.300
they smoothly interpolate
between those two values.

00:41:21.300 --> 00:41:24.720
So that should give you an idea
of what it would be like to

00:41:24.720 --> 00:41:26.840
kind of build an interactive
composition in Quartz Composer.

00:41:26.900 --> 00:41:29.170
If we could go back to slides, please.

00:41:34.510 --> 00:41:36.660
So what we talked about
is interactive placement.

00:41:36.830 --> 00:41:37.700
Kind of an obvious thing.

00:41:37.700 --> 00:41:40.300
Just a quick and easy way
to set up your compositions.

00:41:40.420 --> 00:41:42.840
And then finally,
hopefully you guys get a little bit

00:41:42.840 --> 00:41:46.160
of an idea of some of the power that
you get from the interactive model

00:41:46.160 --> 00:41:47.580
that we've added to Quartz Composer.

00:41:47.700 --> 00:41:48.870
Again, it's just another patch.

00:41:48.900 --> 00:41:49.900
And it seems very simple.

00:41:49.900 --> 00:41:52.780
But in that case, for example,
just to move in one dimension,

00:41:52.780 --> 00:41:55.220
it's just a matter of just
connecting that dimension.

00:41:55.350 --> 00:41:57.200
So certain things are
just kind of obvious.

00:41:57.200 --> 00:42:00.340
And if you want to then play
with those values over time,

00:42:00.470 --> 00:42:02.530
it takes all that
information into account.

00:42:02.540 --> 00:42:05.060
And you can really start to
create some very powerful and

00:42:05.210 --> 00:42:07.640
expressive interactive models.

00:42:07.700 --> 00:42:09.270
So we're really excited about it.

00:42:09.280 --> 00:42:10.940
We've started creating
some really cool stuff.

00:42:10.940 --> 00:42:14.320
And we're looking forward to some of
the stuff that you guys will create.

00:42:14.330 --> 00:42:15.500
So next I'm going to bring up Kevin.

00:42:15.500 --> 00:42:19.290
And he's going to talk a little bit about
OpenCL integration in Quartz Composer.

00:42:24.230 --> 00:42:24.600
All right.

00:42:24.600 --> 00:42:25.760
Thanks, Alessandro.

00:42:25.760 --> 00:42:26.840
So it's pretty crazy.

00:42:26.840 --> 00:42:29.380
It's pretty amazing what you
can do in 20 minutes right now.

00:42:29.380 --> 00:42:30.000
So, these days.

00:42:30.000 --> 00:42:33.560
Alessandro, from scratch,
has been building an interactive

00:42:33.560 --> 00:42:37.550
for the browser that leverages
both OpenCL and Core Animation.

00:42:37.670 --> 00:42:42.000
So interactive that is pretty functional,
so you can just take the composition

00:42:42.000 --> 00:42:46.340
and putting in Xcode and have an
application that you can ship.

00:42:46.340 --> 00:42:48.620
And so this with no
code and in 20 minutes.

00:42:48.720 --> 00:42:52.620
So imagine what you can do in one day,
or maybe two days, maybe a week.

00:42:52.660 --> 00:42:55.310
So lots of potential there.

00:42:55.330 --> 00:42:59.680
So these with just one patch,
the interaction patch.

00:43:00.120 --> 00:43:04.060
And so with the idle state
improvements that we've been

00:43:04.140 --> 00:43:09.010
making in Quartz Composer,
the application that you would ship will

00:43:09.410 --> 00:43:12.850
also be very efficient on all hardware.

00:43:12.850 --> 00:43:16.480
And what it means is that Quartz
Composer will automatically analyze

00:43:16.510 --> 00:43:20.570
the graph to understand its time
dependency so that only what needs to be

00:43:20.570 --> 00:43:23.720
executed is executed when it needs to.

00:43:23.820 --> 00:43:26.250
So if nothing happens, for instance,
if you're in your photo

00:43:26.450 --> 00:43:28.980
browser and nothing moves,
nothing will get executed.

00:43:28.980 --> 00:43:29.930
The graph will be skipped.

00:43:30.150 --> 00:43:31.380
The display won't be flushed.

00:43:31.500 --> 00:43:33.340
The CPU won't do anything.

00:43:33.340 --> 00:43:34.860
And the GPU won't do anything.

00:43:34.860 --> 00:43:37.980
So it makes a very good solution
and a very powerful solution to

00:43:37.980 --> 00:43:42.000
create a very stunning interactive
visualization that works all across

00:43:42.050 --> 00:43:45.300
the hardware and are very efficient,
in particular on laptops.

00:43:45.380 --> 00:43:47.470
So just with one patch,
the interaction patch that

00:43:47.490 --> 00:43:48.770
we added to Quartz Composer.

00:43:48.960 --> 00:43:53.800
Another very important patch that we're
adding first in the lab is OpenCL.

00:43:53.910 --> 00:43:59.340
So OpenCL is this open specification
and programming language that is

00:43:59.340 --> 00:44:04.540
built to leverage the the huge
computational powers of the GPUs.

00:44:04.830 --> 00:44:09.980
And so we added an OpenCL patch in
Quartz Composer that is similar to

00:44:10.110 --> 00:44:16.000
the other programmable patches that
you've seen in Quartz Composer.

00:44:16.000 --> 00:44:19.420
So meaning that you have the patch
and you can edit the settings

00:44:19.430 --> 00:44:20.980
and write up your OpenCL kernel.

00:44:20.980 --> 00:44:24.100
And Quartz Composer will
automatically parse the code to

00:44:24.110 --> 00:44:26.190
find input ports and output ports.

00:44:26.200 --> 00:44:30.640
And so as for other programmable patches,
compilations will be made in

00:44:30.710 --> 00:44:32.700
the background at runtime.

00:44:32.700 --> 00:44:34.200
You have error feedback.

00:44:34.200 --> 00:44:38.240
So it's a very nice and very easy
way to bring the computational

00:44:38.240 --> 00:44:41.080
power of OpenCL in Quartz Composer,
but also much more.

00:44:41.340 --> 00:44:47.630
But before going to that,
I'm going to show you a demo

00:44:47.650 --> 00:44:51.160
of what this patch can do.

00:44:51.160 --> 00:44:51.160
Can I go to demo machine, please?

00:44:55.260 --> 00:44:57.690
So I'm going to show you a demo
that I've been showing in the

00:44:57.690 --> 00:45:00.130
OpenCL session this morning,
but I'm going to go more in details

00:45:00.470 --> 00:45:02.620
into what's behind this composition.

00:45:02.680 --> 00:45:04.000
So here's the NBody simulation.

00:45:04.000 --> 00:45:10.040
So 16,384 particles surrounding
here in cross-composer.

00:45:10.040 --> 00:45:11.750
Here's the composition.

00:45:11.930 --> 00:45:15.020
And so what we've been doing,
we have an OpenCL kernel patch

00:45:15.060 --> 00:45:20.640
here that if we inspect a setting,
we see that this is just this code,

00:45:20.640 --> 00:45:22.980
this OpenCL kernel,
that we've been-- so we haven't

00:45:22.980 --> 00:45:25.020
been doing any OpenCL programming.

00:45:25.020 --> 00:45:27.560
We just took this kernel that
is available for other demos.

00:45:27.560 --> 00:45:29.000
We pasted it in here.

00:45:29.000 --> 00:45:32.720
And then you just need to connect the
output of this patch to some renderer

00:45:32.720 --> 00:45:36.880
here that does the point drawing.

00:45:36.880 --> 00:45:37.350
And so that's it.

00:45:37.500 --> 00:45:41.790
So you already immediately can
visualize what this OpenCL kernel does.

00:45:41.940 --> 00:45:44.860
And so to show you the power
of the real time compilation,

00:45:44.900 --> 00:45:48.340
I've commented here a line that
multiplying the time set by five,

00:45:48.340 --> 00:45:51.220
so I can increase that time set
and the simulation picks it up,

00:45:51.460 --> 00:45:53.660
comment it out,
the simulation picks it up.

00:45:53.660 --> 00:45:57.620
I can also put some error and
the simulation picks it up,

00:45:57.720 --> 00:46:01.040
second step,
and we start again where we were.

00:46:01.040 --> 00:46:04.610
So it's a great way to understand what's
going on and to iterate very quickly.

00:46:04.620 --> 00:46:07.460
But because you're in Quark's Composer
you also have access to the power of

00:46:07.460 --> 00:46:09.230
Quark's Composer for visualizations.

00:46:09.240 --> 00:46:13.190
And in particular, it's very easy,
and I'm going to show you how,

00:46:13.300 --> 00:46:17.060
to add some motion blur here.

00:46:17.090 --> 00:46:19.800
So let's say 100 trails.

00:46:19.830 --> 00:46:22.430
So that is three dimensional,
so you can rotate and see

00:46:22.430 --> 00:46:25.880
how the simulation evolves
over time in a very nice way.

00:46:25.880 --> 00:46:29.400
And to do that with Quark's Composer,
it's very easy.

00:46:29.430 --> 00:46:31.670
So we just feed up the
result of that kernel into,

00:46:31.770 --> 00:46:33.620
so here, three transformations.

00:46:33.620 --> 00:46:37.010
So here we just have CI to
generate the little texture that

00:46:37.010 --> 00:46:39.040
is applied on each of the dots.

00:46:39.040 --> 00:46:40.700
And here we have a QPatch.

00:46:40.730 --> 00:46:45.410
So QPatch will stack up whatever
results have been given for

00:46:45.510 --> 00:46:47.640
the last number of times.

00:46:47.680 --> 00:46:51.640
So here we have, we can set that time
here in the parameters.

00:46:51.670 --> 00:46:53.560
So here for instance, 110 times.

00:46:53.560 --> 00:46:56.500
So it's going to stack up 110 results.

00:46:56.500 --> 00:47:00.740
And then just iterator,
we simply iterate over the structure

00:47:00.740 --> 00:47:04.630
and draw each of these set of
points with an alpha that deems

00:47:04.630 --> 00:47:08.860
over time to generate this nice,
you know, 3D visualization.

00:47:08.860 --> 00:47:10.720
So with no code at all.

00:47:10.720 --> 00:47:13.250
And Quark's Composer has
a strong and very powerful

00:47:13.250 --> 00:47:16.160
OpenCL pipeline and is going to
cache everything in the background.

00:47:16.160 --> 00:47:18.580
You don't have to worry about
doing OpenGL attachment,

00:47:18.580 --> 00:47:21.740
vertex buffer object,
all these things will be cached by

00:47:21.750 --> 00:47:24.780
Quark's Composer and reused optimally.

00:47:24.780 --> 00:47:27.690
So here for instance, you have 100.

00:47:27.810 --> 00:47:29.160
So, 200 now.

00:47:29.160 --> 00:47:30.680
And let me start again.

00:47:30.860 --> 00:47:31.160
Up.

00:47:31.160 --> 00:47:33.380
To show you because it's nice.

00:47:33.380 --> 00:47:37.160
Here you have -- so, 200 times,
16,000 points being

00:47:37.160 --> 00:47:38.770
drawn by Quartz Composer.

00:47:38.770 --> 00:47:41.600
It's still smooth and
responsive and very nice.

00:47:41.600 --> 00:47:43.420
You can also interact with it.

00:47:43.420 --> 00:47:45.020
You can zoom in, zoom out.

00:47:45.020 --> 00:47:48.510
So, it's very simple to get from
something very simple and to put

00:47:48.660 --> 00:47:50.720
it very far using Quartz Composer.

00:47:50.720 --> 00:47:54.830
In particular, this brand-new and very
exciting OpenCL technology.

00:47:54.830 --> 00:47:57.580
So, let me go back to slides, please.

00:48:01.100 --> 00:48:04.080
Thanks.

00:48:04.260 --> 00:48:07.200
But so OpenGL is not only for scientists.

00:48:07.200 --> 00:48:08.860
And so it means a lot for Cross Composer.

00:48:08.860 --> 00:48:10.910
It's very important for Cross Composer.

00:48:10.910 --> 00:48:12.480
I'm going to try to tell you how.

00:48:12.480 --> 00:48:17.730
So it's a great complement of the
programmable patches that we had so far.

00:48:17.810 --> 00:48:21.210
And so programmable patches, I mean,
so we had GLSL that is good

00:48:21.210 --> 00:48:25.320
for doing -- so rendering time,
vertex and fragment processing,

00:48:25.360 --> 00:48:26.250
so in OpenGL.

00:48:26.250 --> 00:48:30.430
CoreImage that is great for doing
-- and very great for doing image

00:48:30.430 --> 00:48:35.790
processing on the GPU or on the CPU and
that handles filter chains very well,

00:48:35.800 --> 00:48:37.920
does concatenation and
does color syncing.

00:48:37.920 --> 00:48:39.900
So it's very good for image processing.

00:48:39.900 --> 00:48:41.880
But it's not good for
other sorts of data,

00:48:41.880 --> 00:48:45.480
so other sorts of tasks, for instance,
general data computation,

00:48:45.580 --> 00:48:47.260
because it's not built for that.

00:48:47.260 --> 00:48:50.620
And so for these sorts of tasks
where you just have arrays of number,

00:48:50.620 --> 00:48:54.940
you want to do some processing on them,
some computation, get the maximum,

00:48:54.990 --> 00:48:56.740
sort them, that sort of things.

00:48:56.740 --> 00:49:00.300
So you had to roll back onto
JavaScript in Cross Composer that

00:49:00.300 --> 00:49:04.570
-- so you have the overhead of the
language and it's not -- so it's

00:49:04.720 --> 00:49:08.610
very much faster in Snow Leopard,
but still it's not the optimal

00:49:08.630 --> 00:49:13.120
way to deal with large amounts
of data -- large amounts of data.

00:49:13.120 --> 00:49:16.270
And so what OpenCL brings
to Cross Composer is this

00:49:16.290 --> 00:49:21.010
ability for any kind of object
that Cross Composer handles,

00:49:21.160 --> 00:49:23.700
and by objects I mean
images or structure,

00:49:23.700 --> 00:49:27.860
to do the expensive computation
to offload it on the GPU.

00:49:27.860 --> 00:49:32.880
So -- and that's -- and that's a great
match for Cross Composer because the

00:49:32.880 --> 00:49:38.000
big advantage and the great quality
of Cross Composer has always been to

00:49:38.000 --> 00:49:41.980
be able to have this graph piling that
runs on the CPU and that leverages

00:49:41.980 --> 00:49:46.800
the GPU for OpenCL -- for OpenGL,
sorry, for core image whenever it can.

00:49:46.810 --> 00:49:50.010
And so there was still missing parts
that it couldn't fulfill on the GPU,

00:49:50.090 --> 00:49:54.460
but now OpenCL is going to allow you
to offload all the expensive stuff,

00:49:54.620 --> 00:49:58.430
all the expensive
computation onto the GPU.

00:49:58.440 --> 00:50:02.520
And then the CPU remains for handling,
you know, events, networking and so on,

00:50:02.520 --> 00:50:03.630
or interaction.

00:50:03.730 --> 00:50:07.980
So the cheap stuff, the threaded stuff,
all these things can be on the CPU,

00:50:07.980 --> 00:50:11.160
and the GPU can be leveraged
whenever it makes sense.

00:50:11.170 --> 00:50:14.320
And so that's a great marriage and
that's a great dual solution that

00:50:14.350 --> 00:50:19.650
you have here to leverage both the
system very optimally and very simply.

00:50:20.010 --> 00:50:24.680
And so you can process images now,
but you can process now geometry,

00:50:24.700 --> 00:50:26.740
so structures,
and do some effects on them.

00:50:26.740 --> 00:50:30.330
So we added a new mesh patch
that takes some set of points.

00:50:30.400 --> 00:50:33.520
And so we show that in the NBody demo,
but that can also draw

00:50:33.840 --> 00:50:35.900
triangles or triangle strips.

00:50:35.900 --> 00:50:42.230
And so I'm going to show you the
sort of things we can do with this

00:50:42.230 --> 00:50:42.230
new pipeline in Quartz Composer.

00:50:43.010 --> 00:50:45.170
So let me go back to demo machine.

00:50:45.230 --> 00:50:48.460
Thank you.

00:50:52.560 --> 00:50:55.220
So that's also some demo I showed
this morning in the OpenCL session,

00:50:55.220 --> 00:50:57.290
but I'm going to go more in
detail to understand what's

00:50:57.290 --> 00:50:58.740
behind that presentation.

00:50:58.750 --> 00:51:03.480
Here you have a cloth simulated
in real time via OpenCL.

00:51:03.480 --> 00:51:04.500
So all on the GPU.

00:51:04.500 --> 00:51:05.220
There's no download.

00:51:05.310 --> 00:51:07.380
So all the computation is on the GPU.

00:51:07.380 --> 00:51:10.480
The CPU is doing pretty
much nothing in here.

00:51:10.570 --> 00:51:13.160
So you can play with it,
and it's kind of fun.

00:51:13.160 --> 00:51:14.830
So it's kind of elastic,
and you can move it

00:51:14.840 --> 00:51:15.980
around and everything.

00:51:16.090 --> 00:51:17.760
But because you're in Quartz Composer,
so first of all,

00:51:17.760 --> 00:51:21.420
you can bring in images very easily
to texture map on that cloth.

00:51:21.420 --> 00:51:26.240
But you can also apply some
core image effect on that image,

00:51:26.270 --> 00:51:29.170
and it's alpha blended on the background.

00:51:29.590 --> 00:51:33.340
OK,
so that was the cloud simulation demo.

00:51:36.070 --> 00:51:41.710
And so to summarize, so we tried,
I believe you see where we're trying to

00:51:41.800 --> 00:51:44.530
go and the problem we're trying to solve.

00:51:44.540 --> 00:51:49.340
So we tried to make QC be a
very fantastic tool for doing

00:51:49.340 --> 00:51:53.450
stunning new sorts of very
innovative data visualization and

00:51:53.450 --> 00:51:55.550
interactive data visualizations.

00:51:55.560 --> 00:51:59.920
So and this works very well with this
idle state so that we'll make that

00:51:59.920 --> 00:52:04.610
visualization very efficient over
multiple broad range of hardware and

00:52:04.700 --> 00:52:09.880
the interaction that allows you to
very innovative and very novel ways

00:52:10.070 --> 00:52:13.430
interact very easily with that UI.

00:52:13.600 --> 00:52:18.300
And then OpenCL is there to help
you leveraging the GPU whenever it

00:52:18.300 --> 00:52:22.460
needs to bring the whole compute
power of the GPU to your competition

00:52:22.460 --> 00:52:24.890
to broaden your range of processing.

00:52:24.890 --> 00:52:27.190
So you can process mesh,
you can do simulations,

00:52:27.200 --> 00:52:29.440
you can do a lot of things,
rigid body and so on.

00:52:29.580 --> 00:52:35.990
You can take these kernels,
bring it into Quartz Composer and

00:52:35.990 --> 00:52:37.490
start doing fun stuff with the rest
of Quartz Composer at your hands.

00:52:37.650 --> 00:52:42.880
And so reusability then is very
important because a lot of people

00:52:42.970 --> 00:52:45.910
use Quartz Composer and they
don't have to be scientists.

00:52:46.110 --> 00:52:53.020
So they can be a graphic artist
or they can be regular developers.

00:52:53.020 --> 00:52:53.020
And so

00:52:53.190 --> 00:52:56.530
They might not want to do
some OpenCL simulations

00:52:56.530 --> 00:52:58.630
because it's still some code,
and you might not want to design

00:52:58.630 --> 00:53:00.940
that pipeline because you might
look a little complicated,

00:53:00.940 --> 00:53:03.980
or you just don't want
to bother about it.

00:53:03.980 --> 00:53:08.040
So what you can do with the
Quartz Composer metaphor is

00:53:08.040 --> 00:53:11.880
that you can actually wrap
that up inside a virtual patch,

00:53:11.880 --> 00:53:13.990
and then you can ask
somebody else to do it,

00:53:14.110 --> 00:53:16.780
or you can get it on the Internet,
get a virtual patch that

00:53:16.780 --> 00:53:19.390
does whatever you want,
that leverages the CPU with

00:53:19.390 --> 00:53:22.580
OpenCL very efficiently,
so it creates stunning

00:53:22.580 --> 00:53:25.810
new sorts of interactions,
and you can bring it into your

00:53:25.810 --> 00:53:28.020
application and do whatever
you want to do with it.

00:53:28.020 --> 00:53:30.840
So if you're a novice,
you can just do some very

00:53:30.840 --> 00:53:34.920
nice artistic applications,
artistic visualizations.

00:53:34.920 --> 00:53:38.120
And so to show you
what I'm talking about,

00:53:38.590 --> 00:53:42.510
well, that's -- I'm going to -- to
show you what I'm talking about,

00:53:42.550 --> 00:53:44.940
I'm going to talk to you about
this code simulation patch.

00:53:44.940 --> 00:53:48.730
So we just took the code simulation
and put it within a virtual patch.

00:53:48.860 --> 00:53:52.470
And we exposed the necessary parameters,
so input ports and output ports,

00:53:52.470 --> 00:53:56.520
so that code simulation
virtual patch is taking a mesh,

00:53:56.520 --> 00:54:01.420
and we exposed some X and Y position,
some parameters for the width

00:54:01.420 --> 00:54:04.620
and the resolution of the mesh,
and it returns from

00:54:04.620 --> 00:54:08.400
that non-transform mesh,
it returns a close simulated mesh.

00:54:08.400 --> 00:54:10.380
And so if you're an artist,
you don't need to know the internals,

00:54:10.380 --> 00:54:12.650
you need to know all the stuff
I just showed you before.

00:54:12.700 --> 00:54:15.040
Just get that patch,
put it into whatever you add, and,

00:54:15.160 --> 00:54:17.940
you know, start playing with it and start
putting that to new limits.

00:54:17.960 --> 00:54:18.820
All right.

00:54:18.860 --> 00:54:25.360
And so that's an example that I want
to show you now in this latest demo,

00:54:25.360 --> 00:54:27.350
in this last

00:54:42.000 --> 00:54:43.000
OK.

00:54:43.000 --> 00:54:47.080
So here is this composition that
Alessandro has been doing for you,

00:54:47.080 --> 00:54:50.460
demonstrating-- so creating
in front of you in 20 minutes.

00:54:50.460 --> 00:54:53.720
And so we added some OpenCL,
so we added this virtual

00:54:53.720 --> 00:54:55.320
patch within that composition.

00:54:55.320 --> 00:54:57.820
So very simply,
just put the patch and insert it.

00:54:57.820 --> 00:55:00.290
And then you can do some fun stuff.

00:55:00.320 --> 00:55:01.720
You can just drag this thing around.

00:55:01.720 --> 00:55:03.370
And they have the close
simulation going on here,

00:55:03.410 --> 00:55:06.370
so you can move it around, play with it,
drag it.

00:55:06.380 --> 00:55:08.860
It's kind of elastic.

00:55:08.860 --> 00:55:10.270
But you know, it's sort of fun.

00:55:10.370 --> 00:55:15.980
So you realize that OpenCL can bring
to your application some new source

00:55:15.980 --> 00:55:19.630
and some new way to interact with it
and some new control and new power.

00:55:19.830 --> 00:55:23.950
So you can take that thing,
you can bring that up and drag it around,

00:55:23.950 --> 00:55:26.120
you can take that other thing,
drag it around.

00:55:26.120 --> 00:55:27.940
You can also do real page curl.

00:55:27.950 --> 00:55:28.620
And that's what is cool.

00:55:28.620 --> 00:55:30.880
You can just take that thing and say, oh,
I want to review what's below.

00:55:30.950 --> 00:55:32.600
I can do real page curl.

00:55:32.600 --> 00:55:34.440
I can just want to see the other things.

00:55:34.440 --> 00:55:36.860
So you don't need to worry about
what's the function I need to do so

00:55:36.930 --> 00:55:39.500
that the page curl looks right in 2D.

00:55:39.500 --> 00:55:40.340
You can just have that.

00:55:40.340 --> 00:55:41.600
You have this paper simulation.

00:55:41.600 --> 00:55:43.820
And then it's even simpler,
because you have the close.

00:55:43.820 --> 00:55:46.530
You just drag the two corners,
which is only what you need to do,

00:55:46.580 --> 00:55:49.670
just drag the corner, pull them up,
and that makes you a real,

00:55:49.780 --> 00:55:52.970
physically simulated page curl.

00:55:53.150 --> 00:55:56.860
And you can drag stuff around and
everything and play with them.

00:55:56.860 --> 00:55:59.240
And yeah, again, so I say, oh,
I want to see my dog.

00:55:59.240 --> 00:56:00.250
And you can see a dog.

00:56:00.250 --> 00:56:01.790
And then you can reveal your dog.

00:56:01.790 --> 00:56:02.060
So OK.

00:56:02.340 --> 00:56:05.490
So you see, lots of potential.

00:56:05.510 --> 00:56:07.900
That's a part of there.

00:56:07.900 --> 00:56:12.920
Thanks to Quartz Composer,
that can really bring all

00:56:13.260 --> 00:56:16.300
these technologies together.

00:56:16.300 --> 00:56:16.970
And in particular,
OpenCL is going to give you much.

00:56:16.970 --> 00:56:16.970
So thanks.

00:56:23.200 --> 00:56:24.650
So that was it.

00:56:24.700 --> 00:56:28.030
So to know more about Quartz Composer,
Alan Schaeffer is our

00:56:28.030 --> 00:56:29.280
graphics evangelist.

00:56:29.280 --> 00:56:30.650
So please email him.

00:56:30.760 --> 00:56:32.200
Please also come to our lab.

00:56:32.200 --> 00:56:33.940
Right after this session,
we're going to be downstairs,

00:56:33.940 --> 00:56:36.920
be able to answer any
questions you might have.

00:56:37.000 --> 00:56:39.720
So documentation is available.

00:56:39.720 --> 00:56:42.760
You also have a very strong
and very good mailing list.

00:56:42.760 --> 00:56:44.360
We are very active,
so a lot of people can ask

00:56:44.360 --> 00:56:45.720
questions and get it answered.

00:56:45.720 --> 00:56:48.280
So it's a very good place to look at.

00:56:48.280 --> 00:56:49.830
But right now, of course,
everything we discuss here

00:56:49.830 --> 00:56:51.540
is still confidential.

00:56:51.540 --> 00:56:55.780
And so the editor is also going to
help when you choose a very convenient.

00:56:55.780 --> 00:56:56.840
OK, well, thank you.

00:56:56.840 --> 00:56:58.070
And so we're going to have some Q&A now.
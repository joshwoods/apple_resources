WEBVTT

00:00:21.650 --> 00:00:24.960
Welcome to iPhone for Mac Developers.

00:00:25.030 --> 00:00:26.100
My name's Corbin Dunn.

00:00:26.250 --> 00:00:29.570
I'm a Cocoa software engineer,
and I work on the Cocoa team.

00:00:29.850 --> 00:00:34.040
Specifically, I work on the Cocoa user
interface framework,

00:00:34.040 --> 00:00:36.440
some of the UI elements,
and I've also had the opportunity

00:00:36.440 --> 00:00:39.710
to work on the iPhone,
work on UIKit.

00:00:40.440 --> 00:00:44.710
So iPhone for Mac developers,
this talk is geared towards the

00:00:44.770 --> 00:00:47.700
Cocoa AppKit Mac developers.

00:00:47.700 --> 00:00:51.340
And we expect you to have a
basic understanding of Cocoa.

00:00:51.360 --> 00:00:54.170
And what that means is we
hope you're familiar with

00:00:54.170 --> 00:00:58.970
the basics like Innes arrays,
CFArrays, Innes dictionary, Innes string,

00:00:58.970 --> 00:00:59.840
et cetera.

00:00:59.840 --> 00:01:02.860
You understand our AppKit design
paradigms so you know what

00:01:02.860 --> 00:01:04.420
Model View Controller is.

00:01:04.420 --> 00:01:06.680
You know how to work
with the responder chain.

00:01:06.720 --> 00:01:13.360
You understand our common AppKit names,
behaviors, and the way we do things.

00:01:13.410 --> 00:01:16.500
You're also familiar with Innes
views and how to do drawing.

00:01:16.530 --> 00:01:20.760
And you probably are familiar with
hooking up target actions of controls.

00:01:20.820 --> 00:01:22.650
In addition,
you probably have some experience

00:01:22.740 --> 00:01:25.580
with tables and working with cells.

00:01:26.500 --> 00:01:27.980
So what are we going to do in this talk?

00:01:28.210 --> 00:01:29.900
What are our goals and expectations?

00:01:30.000 --> 00:01:32.290
Well, if you don't know by now,
the iPhone counterpart

00:01:32.390 --> 00:01:34.450
to AppKit is UIKit.

00:01:34.450 --> 00:01:38.570
And we're hoping that you can take
your existing AppKit and Cocoa skills

00:01:39.030 --> 00:01:41.630
and migrate them over to the iPhone.

00:01:41.690 --> 00:01:44.200
What we're going to do is we're going
to cover a lot of classes that are

00:01:44.200 --> 00:01:46.360
very similar to what's in AppKit.

00:01:46.440 --> 00:01:50.200
We're going to compare and
contrast them and in particular

00:01:50.200 --> 00:01:53.110
highlight differences so you know
what to do and what not to do.

00:01:53.110 --> 00:01:57.350
Things that we aren't going to do,
we aren't going to cover any new classes

00:01:57.350 --> 00:01:59.770
that are very specific to the iPhone.

00:02:00.700 --> 00:02:03.840
Overall, what we're going to cover, well,
first, we're going to talk a little bit

00:02:03.840 --> 00:02:05.030
about application architecture.

00:02:05.040 --> 00:02:07.490
Second,
we're going to talk about drawing.

00:02:07.490 --> 00:02:10.370
Third,
we're going to cover views and controls.

00:02:10.370 --> 00:02:12.620
And fourth, we're going to cover events.

00:02:14.300 --> 00:02:18.240
So let's get right into it and talk
about application architecture.

00:02:18.300 --> 00:02:21.950
Inside here,
we'll cover application design and

00:02:21.950 --> 00:02:25.000
see how to actually develop your
applications and lay them out.

00:02:25.040 --> 00:02:27.320
We'll talk a little about
controllers and the class hierarchy.

00:02:27.320 --> 00:02:31.100
And then we'll move on and do a quick
demo inside of Xcode and Airface Builder

00:02:31.100 --> 00:02:32.950
to see how it all works together.

00:02:32.950 --> 00:02:36.910
Let's jump right in
with application design.

00:02:37.200 --> 00:02:39.700
Let's take a look at the architecture
of the Mac and the iPhone.

00:02:39.700 --> 00:02:41.880
You should already hopefully
be familiar with this.

00:02:41.880 --> 00:02:44.640
So at the bottom level there,
you have the core operating system.

00:02:44.640 --> 00:02:48.140
On top of that,
the core services like core foundation,

00:02:48.210 --> 00:02:51.260
CF network, address book,
and other core frameworks.

00:02:51.260 --> 00:02:54.180
On top of that,
we have our media frameworks.

00:02:54.270 --> 00:02:57.630
Things like OpenGL, Core Animation,
Quartz Core,

00:02:57.630 --> 00:02:59.750
and all the core graphics stuff.

00:02:59.820 --> 00:03:03.940
If you're building your Mac applications,
you'll be using Cocoa.

00:03:03.980 --> 00:03:06.000
And that consists of
AppKit and Foundation.

00:03:07.060 --> 00:03:09.270
And the iPhone counterpart
is Cocoa Touch,

00:03:09.370 --> 00:03:11.270
which is UIKit and Foundation.

00:03:14.250 --> 00:03:20.240
So the iPhone operating system is very
similar to the Mac operating system.

00:03:20.300 --> 00:03:24.520
And what we did is we took all
the modern parts of the Leopard

00:03:24.620 --> 00:03:28.230
64-bit operating system and just
brought them over to the iPhone.

00:03:28.390 --> 00:03:29.920
So we have things like exceptions.

00:03:30.160 --> 00:03:35.660
They're fully C++ compatible,
just like they are on 64-bit on the Mac.

00:03:35.700 --> 00:03:39.500
But you need to keep in mind that
throwing exceptions still has a cost,

00:03:39.550 --> 00:03:42.640
and you should be aware of that.

00:03:42.870 --> 00:03:46.640
Of course, the iPhone doesn't actually
have a 64-bit processor.

00:03:46.690 --> 00:03:51.890
We have full Objective-C 2.0 support,
so the iPhone takes advantage

00:03:51.920 --> 00:03:53.640
of the app property syntax.

00:03:53.650 --> 00:03:57.580
And if you look at the UI kit headers,
you'll see app property used throughout.

00:03:57.890 --> 00:04:01.720
takes advantage of 4N
and fast enumeration.

00:04:02.860 --> 00:04:05.620
We also use optional
for formal protocols.

00:04:05.620 --> 00:04:08.830
So you see all our delegate and data
source methods using formal protocols

00:04:08.830 --> 00:04:11.560
with add optional or at required methods.

00:04:11.560 --> 00:04:16.990
One other note, garbage collection is not
available on the iPhone.

00:04:17.620 --> 00:04:20.560
So let's talk a little bit
about application design.

00:04:20.560 --> 00:04:23.750
You're going to design your iPhone
applications in ways that are

00:04:23.750 --> 00:04:27.410
also very similar to what you're
doing on the Mac operating system.

00:04:27.540 --> 00:04:31.840
You're gonna basically use nibs,
layout your application,

00:04:31.910 --> 00:04:34.710
gonna hook up your target
actions inside of it.

00:04:34.780 --> 00:04:39.740
You're gonna add controllers in the nib,
and you're gonna design it that way.

00:04:40.110 --> 00:04:43.260
Let's look at an example of how
you would be doing it on the Mac.

00:04:43.800 --> 00:04:46.370
So you have something like your main nib.

00:04:46.700 --> 00:05:02.500
[Transcript missing]

00:05:03.810 --> 00:05:07.840
Now, you're probably using
NS document-based applications and

00:05:07.840 --> 00:05:10.630
have a document for each window.

00:05:10.680 --> 00:05:12.790
You could have one document,
you could have two documents,

00:05:12.840 --> 00:05:14.980
you could have a multiple
layer of documents.

00:05:15.020 --> 00:05:17.710
Let's take a quick look at one of them.

00:05:17.980 --> 00:05:21.400
Your document may or may not
be using an NSWindowController.

00:05:21.430 --> 00:05:24.000
Behind the scenes, it really is using it.

00:05:24.020 --> 00:05:26.800
And the WindowController is the
thing that references the window nib,

00:05:26.820 --> 00:05:30.250
which in turn contains the window itself.

00:05:30.530 --> 00:05:33.840
Inside of Leopard we introduced
NSViewController which allows

00:05:33.840 --> 00:05:37.430
you to easily manage a view
nib of loading it and whatnot.

00:05:37.690 --> 00:05:39.440
And that references the view.

00:05:39.540 --> 00:05:40.900
It's optional to use a view controller.

00:05:40.900 --> 00:05:43.600
You may have other ways
of loading your views.

00:05:43.740 --> 00:05:46.830
Inside of the view itself,
you'll probably hook up things

00:05:46.900 --> 00:05:50.030
using target action and you'll
probably have bindings that

00:05:50.130 --> 00:05:52.280
actually does a lot of your UI work.

00:05:53.160 --> 00:06:13.700
: The iPhone application architecture.

00:06:13.700 --> 00:06:13.700
So what does that look like?

00:06:13.700 --> 00:06:13.700
You have a main nib,
just like you're used to.

00:06:13.700 --> 00:06:13.700
Do you have a main menu?

00:06:13.700 --> 00:06:13.700
Well, the answer is no,
because there aren't menus on the iPhone.

00:06:13.700 --> 00:06:13.700
Do you have an NS application?

00:06:13.700 --> 00:06:13.700
Well, yes, but it's a UI application,
because the UI kit framework

00:06:13.700 --> 00:06:13.700
uses the UI prefix.

00:06:13.850 --> 00:06:17.640
You also will have an application
controller just like you normally would,

00:06:17.640 --> 00:06:20.700
and it will probably also be
the delegate to the application.

00:06:20.760 --> 00:06:23.800
But a key difference,
you probably will have a single

00:06:23.800 --> 00:06:26.240
window referenced in the main nib.

00:06:26.290 --> 00:06:29.040
This is the main window
for your application.

00:06:29.080 --> 00:06:32.510
Unlike the desktop where you
would have multiple windows,

00:06:32.580 --> 00:06:35.360
your iPhone application will
probably have one window,

00:06:35.420 --> 00:06:40.420
and you will place the screenfuls
of content using different views.

00:06:40.880 --> 00:06:43.120
In addition,
the application controller will

00:06:43.190 --> 00:06:45.910
probably reference that window itself.

00:06:47.340 --> 00:06:50.060
Do you have an NS document
inside the iPhone?

00:06:50.080 --> 00:06:51.120
Well, the answer is no.

00:06:51.210 --> 00:06:53.680
You really don't have document-based
applications on the iPhone.

00:06:53.680 --> 00:06:55.820
You're working with
smaller subsets of data.

00:06:55.820 --> 00:06:58.200
Do you have an NS window controller?

00:06:58.200 --> 00:07:00.720
Well, again, the answer is no,
because you generally

00:07:00.810 --> 00:07:03.240
only have one window,
so it's not really needed.

00:07:03.240 --> 00:07:05.120
Do you have an NS view controller?

00:07:05.200 --> 00:07:07.570
The answer is yes,
and it plays an important

00:07:07.570 --> 00:07:08.730
role on the iPhone.

00:07:08.730 --> 00:07:11.420
And, of course,
it's a UI view controller.

00:07:11.420 --> 00:07:14.230
So the view controller will
be hooked up to a view nib,

00:07:14.230 --> 00:07:16.340
which will then contain your view.

00:07:16.340 --> 00:07:19.370
Your view will have
typical target action,

00:07:19.370 --> 00:07:22.860
just like you're familiar with,
but you actually don't have bindings.

00:07:22.870 --> 00:07:25.240
And even though we don't have bindings,
we found that we haven't

00:07:25.270 --> 00:07:26.920
really missed them,
because you're working with

00:07:26.930 --> 00:07:28.350
a smaller screen of data.

00:07:28.350 --> 00:07:31.780
Even though it's not there,
you do have KVO, key value observing,

00:07:31.780 --> 00:07:35.740
and KVC, key value coding,
available for you.

00:07:36.220 --> 00:07:39.240
So you may have one view
controller controlling a view,

00:07:39.260 --> 00:07:42.980
and you may have another one and
another one to replace that screen

00:07:42.980 --> 00:07:45.500
of content that you're seeing.

00:07:46.030 --> 00:07:50.340
Let's dive into it a little bit more
to really understand how it works.

00:07:50.540 --> 00:07:53.540
So here's a sample
application screenshot.

00:07:53.610 --> 00:07:58.790
Your application controller will
probably reference the window itself.

00:07:59.320 --> 00:08:02.100
You'll probably have a main view
controller that controls the

00:08:02.100 --> 00:08:03.940
main view that you're seeing.

00:08:04.040 --> 00:08:07.280
So that view controller
will control that main view.

00:08:07.300 --> 00:08:11.070
The main view itself will
have other sub views.

00:08:12.320 --> 00:08:15.270
So we just covered a little bit
about application design and

00:08:15.350 --> 00:08:17.500
briefly touched on controllers.

00:08:17.560 --> 00:08:19.720
Let's talk a little bit
more about controllers,

00:08:19.940 --> 00:08:24.070
view controllers, and a little bit about
the class hierarchy.

00:08:24.990 --> 00:08:27.500
So view controllers inside of UIKit.

00:08:27.550 --> 00:08:30.300
Another difference inside of
UIKit is that we have lots of

00:08:30.300 --> 00:08:34.420
subclasses of UIViewController that
provides a lot of canned code for

00:08:34.420 --> 00:08:36.340
you to instantly and quickly use.

00:08:36.380 --> 00:08:38.740
There's things like a
UINavigationController,

00:08:38.780 --> 00:08:41.940
which we'll quickly show in a moment,
a TableViewController,

00:08:41.950 --> 00:08:44.760
PickerViewController, TabBar, et cetera.

00:08:44.820 --> 00:08:46.400
There's more of these,
and we highly recommend

00:08:46.400 --> 00:08:47.970
you check into them.

00:08:48.170 --> 00:08:51.650
Some special
UIKit differences from AppKit.

00:08:51.880 --> 00:08:56.670
Well, UIViewController does not
manage the top level objects.

00:08:56.800 --> 00:08:58.280
So what does this mean?

00:08:58.340 --> 00:09:00.740
If you have top level
objects in your nib,

00:09:00.740 --> 00:09:02.860
you are required to release them.

00:09:02.900 --> 00:09:06.000
This is an important
difference from the desktop.

00:09:06.250 --> 00:09:10.100
For more information on view controllers,
I recommend going on and

00:09:10.100 --> 00:09:13.980
seeing Understanding iPhone
View Controllers later today at 2 p.m.

00:09:15.980 --> 00:09:19.800
Let's take a quick look at one
commonly used view controller,

00:09:19.890 --> 00:09:22.050
the UI navigation controller.

00:09:22.160 --> 00:09:25.550
So the navigation controller
would be hooked up where,

00:09:25.570 --> 00:09:27.920
again, you have your main
application controller.

00:09:27.920 --> 00:09:29.920
It's going to reference
your main view controller.

00:09:29.920 --> 00:09:33.810
In this case,
it's the UI navigation controller.

00:09:34.130 --> 00:09:37.910
And that's going to manage
that main view here.

00:09:38.260 --> 00:09:42.490
In addition, it's going to manage that
UI navigation bar you see at the top.

00:09:42.560 --> 00:09:45.810
And that adds things like
the forward and back buttons.

00:09:46.000 --> 00:09:49.830
And the way it does it is you have
your sub view controller inside of it.

00:09:49.830 --> 00:09:52.350
In this case,
it's using a table view controller

00:09:52.350 --> 00:09:54.670
to manage that table you see there.

00:09:54.670 --> 00:09:58.970
And what you can do with the navigation
controller is it works like a stack.

00:09:58.970 --> 00:10:02.550
You can stack other view
controllers and other views onto it.

00:10:02.550 --> 00:10:06.030
So you can push another table
view controller onto the stack and

00:10:06.030 --> 00:10:08.180
have it show and replace it with
another table view controller.

00:10:08.200 --> 00:10:10.770
that content easily.

00:10:12.390 --> 00:10:16.800
Let's talk a little bit about AppKit and
how you work with modal windows.

00:10:16.960 --> 00:10:20.290
So AppKit has modal run loops,
which you're probably familiar with.

00:10:20.450 --> 00:10:23.960
You can easily do them by doing
NS application run modal for window,

00:10:24.230 --> 00:10:27.200
and you'd have your base
window relative to it,

00:10:27.220 --> 00:10:29.890
and you'd show another one modally.

00:10:31.020 --> 00:10:32.570
So how do you do this in UIKit?

00:10:32.780 --> 00:10:34.200
Because you don't have multiple windows.

00:10:34.200 --> 00:10:36.660
You really only have one main window.

00:10:36.740 --> 00:10:41.770
Well, the UI view controller is there
to allow you to do modal views.

00:10:42.060 --> 00:10:43.640
So take a look at this screenshot.

00:10:43.680 --> 00:10:47.310
Let's say you want to hit one of
those buttons and have an image picker

00:10:47.540 --> 00:10:52.160
come up over it modally so the user
can't interact with anything else.

00:10:52.220 --> 00:10:56.940
And what you would do to have
that other one slide up above it

00:10:57.160 --> 00:11:00.100
You create your new
controller you want to show.

00:11:00.160 --> 00:11:04.250
In this case, it's another example of a
pre-canned one that we provide,

00:11:04.490 --> 00:11:06.550
the UI image picker controller.

00:11:06.650 --> 00:11:07.860
So we allocate it.

00:11:08.470 --> 00:11:10.740
The main controller,
which was the first one you saw,

00:11:10.930 --> 00:11:13.540
calls present modal view
controller animated.

00:11:13.540 --> 00:11:18.020
And that will actually slide
up the other one with the view

00:11:18.020 --> 00:11:20.270
in relation to it modally.

00:11:20.270 --> 00:11:21.790
Very easy to do.

00:11:22.230 --> 00:11:24.020
General application design tips.

00:11:24.020 --> 00:11:26.090
Awake from Nib.

00:11:26.090 --> 00:11:29.370
Well,
since you're using view controllers,

00:11:29.770 --> 00:11:33.590
you probably want to use view
to load over awake from Nib.

00:11:33.590 --> 00:11:37.220
And the reason for that is that
UI view controller does more things

00:11:37.220 --> 00:11:39.010
for you than you would expect.

00:11:39.080 --> 00:11:41.480
For example,
you might have other views that

00:11:41.480 --> 00:11:45.190
you aren't seeing on screen anymore
and the view controller may release

00:11:45.320 --> 00:11:47.090
the views for memory reasons.

00:11:47.090 --> 00:11:49.180
So it may reload them at a later time.

00:11:49.180 --> 00:11:52.080
Subsequently, you might get awake
from Nib more than once.

00:11:52.100 --> 00:11:57.300
To deal with that problem,
we recommend using view to load to set up

00:11:57.300 --> 00:12:02.020
the view each time the view is actually
loaded instead of using awake from Nib.

00:12:04.010 --> 00:12:07.200
In addition, if you have one-time setup
for your application,

00:12:07.340 --> 00:12:09.740
you probably want to use
application did finish launching

00:12:09.740 --> 00:12:10.810
instead of awake from nib.

00:12:10.810 --> 00:12:13.710
This is similar in AppKit where
it's preferred to use that.

00:12:13.760 --> 00:12:16.630
It's good for performance reasons.

00:12:16.910 --> 00:12:19.790
One other important difference,
the file's owner will

00:12:19.790 --> 00:12:21.230
not get a wake from nib.

00:12:21.230 --> 00:12:25.260
It's a huge difference from inside of
AppKit and something to be aware of.

00:12:25.320 --> 00:12:27.980
Auto release,
we recommend following the best

00:12:27.980 --> 00:12:31.810
practices for AppKit and not really
overusing auto release to fill up

00:12:31.810 --> 00:12:33.860
the auto release pools too much.

00:12:35.010 --> 00:12:37.640
The C++ conceptions,
as we briefly touched on them before,

00:12:37.670 --> 00:12:40.890
although they are C++ compatible,
they really only should be used

00:12:40.890 --> 00:12:44.130
to indicate any programming errors
that you have in your code and

00:12:44.130 --> 00:12:48.210
they not should be used for any
flow control or anything else.

00:12:48.740 --> 00:12:50.910
Let's take a quick look at
the AppKit class hierarchy.

00:12:51.000 --> 00:12:53.040
This is a small subset of it.

00:12:53.080 --> 00:12:55.500
You're probably familiar with
you have NSObject up at the top.

00:12:55.520 --> 00:12:57.580
You have a responder beneath it.

00:12:57.610 --> 00:13:00.840
You have your views, your windows,
and your view controllers.

00:13:00.870 --> 00:13:04.950
You have controls, tables, buttons,
scroll views.

00:13:05.090 --> 00:13:07.800
comparing it to a subset of
the UI kit class hierarchy.

00:13:07.830 --> 00:13:10.400
Well, NSObject is still the
parent for everything.

00:13:10.440 --> 00:13:13.680
You do have a UI responder,
just like you have an app kit,

00:13:13.730 --> 00:13:15.190
and you do have the UI view.

00:13:15.410 --> 00:13:17.030
You have a UI view controller.

00:13:17.190 --> 00:13:20.020
Some important differences,
the window actually

00:13:20.020 --> 00:13:21.450
descends from the view.

00:13:21.780 --> 00:13:25.460
So the window's a full-fledged
view and not just a responder.

00:13:25.480 --> 00:13:28.000
We'll discuss this a
little bit more later.

00:13:28.010 --> 00:13:30.680
Another subtle difference,
the table view descends

00:13:30.740 --> 00:13:32.160
directly from the scroll view.

00:13:32.450 --> 00:13:36.850
So the table view is no longer a
subset or a subclass of UI control.

00:13:37.090 --> 00:13:39.740
Instead,
it subclasses the scroll view itself.

00:13:39.770 --> 00:13:42.880
We'll talk about that a
little bit more later too.

00:13:44.230 --> 00:13:48.740
So we just covered some view
controllers and some class hierarchy.

00:13:48.760 --> 00:13:53.470
Let's take a quick demo and see how
this all fits together inside of Xcode.

00:14:01.510 --> 00:14:05.090
Inside of Xcode here,
I'm going to go ahead

00:14:05.090 --> 00:14:10.920
and create a new project,
just a regular view-based application.

00:14:10.920 --> 00:14:13.270
And we're going to call it My App.

00:14:14.850 --> 00:14:19.790
So some things that are done by
default for you is you'll see

00:14:19.800 --> 00:14:24.390
there's an application delegate
automatically created for you.

00:14:24.920 --> 00:14:30.600
There is a UI view controller subclass
that is automatically created for you.

00:14:30.620 --> 00:14:33.200
And then there's two nibs,
or actually zibs,

00:14:33.230 --> 00:14:35.200
which will get compiled to nibs.

00:14:35.280 --> 00:14:36.740
First of all,
you have your main window one,

00:14:36.740 --> 00:14:38.200
which you're familiar with.

00:14:38.220 --> 00:14:41.090
And then you have one
for your view controller.

00:14:41.200 --> 00:14:47.080
If we take a look at the main window nib,
we can see inside of it that we have--

00:14:48.220 --> 00:14:53.760
Our app view controller
is one instance in here.

00:14:53.800 --> 00:14:57.540
And we also have the main
window that we're referencing.

00:14:59.400 --> 00:15:04.610
If we go back to Xcode and open
up the View Controller nib,

00:15:08.460 --> 00:15:12.940
We can see we have our single view where
we can actually start adding content.

00:15:13.030 --> 00:15:18.590
So let's go ahead and just
add a button down here.

00:15:18.590 --> 00:15:22.410
And just quickly show how
easy it is to hook things up.

00:15:24.750 --> 00:15:29.910
We can go back inside of Xcode and
add some code to the view controller.

00:15:32.320 --> 00:15:34.960
So if we want to hook up
a typical target action,

00:15:34.960 --> 00:15:36.300
it's very easy to do.

00:15:36.330 --> 00:15:42.290
You're familiar with your IB action
signature where it's the method name and

00:15:42.300 --> 00:15:45.380
then the first parameter is the sender.

00:15:45.430 --> 00:15:47.360
But inside of UIKit,
we went a little further

00:15:47.360 --> 00:15:49.670
than what AppKit did,
and we allow you to optionally

00:15:49.680 --> 00:15:51.160
have the sender parameter.

00:15:51.160 --> 00:15:55.140
So you could have button touch
up inside without the sender.

00:15:55.440 --> 00:16:00.170
And we took it another step further,
and we also allow you to have the

00:16:00.170 --> 00:16:02.730
event to be passed along with it.

00:16:02.830 --> 00:16:05.570
So I'm going to go ahead and quickly

00:16:06.170 --> 00:16:10.960
: Go to the implementation.

00:16:10.960 --> 00:16:11.520
And I'm going to skip over some of
the code that we create by default

00:16:11.520 --> 00:16:15.530
for you to allow it to fill in more
information for your application.

00:16:15.640 --> 00:16:19.240
And I'm going to quickly add an
implementation for each of these actions.

00:16:19.290 --> 00:16:22.860
And what it's going to do here is
it's going to create a UI alert view.

00:16:23.000 --> 00:16:27.140
So UI alert view is just very
similar to NS alert on AppKit.

00:16:27.140 --> 00:16:30.400
It allows you to create
an alert with a title,

00:16:30.440 --> 00:16:32.710
a message, and some buttons.

00:16:32.710 --> 00:16:34.700
So we're just going to
have an okay button.

00:16:37.190 --> 00:16:42.130
Now if I go back over
to Interface Builder,

00:16:42.150 --> 00:16:46.670
we can easily hook up this button

00:16:47.270 --> 00:16:50.500
is going to be our view controller.

00:16:50.500 --> 00:16:57.600
You can see here it's tiny font.

00:16:58.590 --> 00:16:58.590
The My App view controller
is the actual files owner.

00:16:58.760 --> 00:17:02.610
If we click on the button and
select the button connections,

00:17:02.610 --> 00:17:05.140
a key difference here is instead
of having one target action,

00:17:05.140 --> 00:17:08.120
we have multiple potential events.

00:17:08.120 --> 00:17:11.810
So multiple potential actions that
you can hook up for a given button.

00:17:11.810 --> 00:17:15.490
Things like touch down,
touch down repeat, touch drag,

00:17:15.520 --> 00:17:17.600
touch drag inside, outside.

00:17:17.600 --> 00:17:21.660
So we can just go ahead and drag
from the touch up inside over

00:17:21.660 --> 00:17:24.120
to our files owner and let go.

00:17:24.190 --> 00:17:28.010
And we can see that we have the three
different method signatures we had.

00:17:28.030 --> 00:17:35.960
But we can also have multiple
different targets that you can have.

00:17:35.960 --> 00:17:41.900
So I can repeat this action and hook
it up again to the other methods.

00:17:41.900 --> 00:17:43.750
And I can repeat it again.

00:17:44.910 --> 00:17:47.470
And if we take a look at it in
the button connections here,

00:17:47.470 --> 00:17:50.880
we see that in very tiny font,
you have three different hookups

00:17:50.980 --> 00:17:53.560
for each of the target actions.

00:17:53.980 --> 00:17:58.340
So I should be able to go
back in the X code and compile

00:17:58.340 --> 00:18:00.180
and run the application.

00:18:00.180 --> 00:18:02.160
And we'll start in the simulator.

00:18:02.160 --> 00:18:04.580
I can click on Hello World,
and it will throw up

00:18:04.790 --> 00:18:06.960
three different alerts,
one after another.

00:18:06.980 --> 00:18:10.500
And the way the user interface
works is that you click one,

00:18:10.520 --> 00:18:12.750
and the others then pop back up.

00:18:13.090 --> 00:18:17.800
This is a quick and easy way to see
how an application is built and works.

00:18:17.800 --> 00:18:20.710
OK, let's go back to slides.

00:18:25.790 --> 00:18:27.450
So that was a quick
demo of the application

00:18:27.450 --> 00:18:29.360
architecture and how it works.

00:18:29.390 --> 00:18:31.110
Let's move on to drawing.

00:18:31.300 --> 00:18:33.020
So what are we going to cover in drawing?

00:18:33.060 --> 00:18:34.300
Well, first of all,
we're going to talk a little

00:18:34.300 --> 00:18:36.200
bit about core animation.

00:18:36.230 --> 00:18:39.580
We're going to talk about drawing,
actually, and some views.

00:18:39.630 --> 00:18:42.100
And then we're going
to discuss animations.

00:18:42.180 --> 00:18:45.730
So let's jump right into it and
start talking about core animation.

00:18:46.350 --> 00:18:51.000
How does Core Animation work
with NSViews inside of AppKit?

00:18:51.000 --> 00:18:57.110
Well, NSView optionally allows a
Core Animation layer to back it.

00:18:57.130 --> 00:18:59.220
and you have to opt into it.

00:18:59.370 --> 00:19:03.700
So in other words, you have to do view,
set wants layer, yes,

00:19:03.780 --> 00:19:06.760
to get a layer backing for your view.

00:19:07.170 --> 00:19:11.830
The layer can also be directly set,
and there's a method, viewSetLayer,

00:19:12.000 --> 00:19:13.870
to custom set a layer.

00:19:14.220 --> 00:19:18.020
So you may have a CALayer subclass
that does some custom stuff you want,

00:19:18.260 --> 00:19:21.770
and you want to interact with the
view and be the view's contents,

00:19:21.770 --> 00:19:23.990
so you call viewSetLayer to do that.

00:19:24.190 --> 00:19:28.260
You can also take that views layer and
add custom sub layers to it and work

00:19:28.340 --> 00:19:33.370
with the layer hierarchy directly and not
the NS view hierarchy if so you choose.

00:19:33.790 --> 00:19:37.280
So how does this work with
UIView inside of UIKit?

00:19:37.320 --> 00:19:43.640
Well, UIView always has a core animation
CA layer for every view you see.

00:19:43.670 --> 00:19:47.640
In essence, you can think of the view's
contents as the actual layer.

00:19:48.070 --> 00:19:50.130
So if you take a look at
this little screenshot here,

00:19:50.370 --> 00:19:52.080
this is a UI image view.

00:19:52.120 --> 00:19:56.650
And you can sort of think of it as the
CA layer is kind of backing the view.

00:19:56.740 --> 00:20:00.770
It's always there,
and it is the contents for the view.

00:20:01.770 --> 00:20:06.500
So a little bit more about UIView and
how it interacts with the CAA layer.

00:20:06.540 --> 00:20:09.840
Well, the layer property is read only,
which is different from MapKit,

00:20:09.890 --> 00:20:13.540
which then begs the question of, well,
how do you actually customize it?

00:20:13.590 --> 00:20:16.490
And the way you do that is
you would subclass UIView and

00:20:16.490 --> 00:20:20.730
override the class method,
layer class, to provide your custom

00:20:21.080 --> 00:20:22.870
layer class subclass.

00:20:23.380 --> 00:20:24.550
Some interesting notes.

00:20:24.820 --> 00:20:28.860
Well, the UI view is always
the CA layers delegate.

00:20:28.990 --> 00:20:30.440
You probably don't want to change that.

00:20:30.650 --> 00:20:32.700
That will mess up things like drawing.

00:20:32.790 --> 00:20:35.890
But you can also take advantage
of it and subclasses can

00:20:36.040 --> 00:20:40.060
optionally implement CA layer
delegate methods if they need to.

00:20:40.910 --> 00:20:46.070
Another note is layer properties
are directly reflected in the view.

00:20:46.110 --> 00:20:49.500
So if you change something like
the frame on the actual view,

00:20:49.560 --> 00:20:54.500
it's actually changing the frame
in the layer itself and vice versa.

00:20:54.890 --> 00:20:58.580
Other properties that do this
are like the background color.

00:20:59.540 --> 00:21:01.730
just like in AppKit,
you can go ahead and directly

00:21:01.770 --> 00:21:06.810
add CA layers to the sublayer of
the layer itself and not interact

00:21:06.930 --> 00:21:10.500
with the UI view hierarchy,
if so you choose.

00:21:10.880 --> 00:21:14.200
Some notes about UIView
and the frame and bounds.

00:21:14.270 --> 00:21:17.630
Well, the origin for the view
is always the top left.

00:21:17.760 --> 00:21:20.120
So if you look at this
little screenshot of Safari,

00:21:20.180 --> 00:21:23.380
the origin of the web view
is always that top left.

00:21:23.430 --> 00:21:24.220
What's that mean?

00:21:24.220 --> 00:21:27.680
Well,
UIView doesn't have an isFlip property.

00:21:27.730 --> 00:21:31.430
But a special warning,
if you create a custom

00:21:31.450 --> 00:21:35.920
CG context for some reason,
the origin is still the bottom left,

00:21:35.970 --> 00:21:40.490
which is the same on the desktop if
you're creating a custom CG context.

00:21:41.940 --> 00:21:43.860
CG geometry and UI kit.

00:21:44.150 --> 00:21:45.440
What does this mean?

00:21:45.760 --> 00:21:50.450
UI kit went ahead and did what
core animation did by exposing

00:21:50.450 --> 00:21:52.740
core graphics geometric types.

00:21:52.740 --> 00:21:57.290
In English that basically means that
we use CG rect instead of NS rect.

00:21:57.370 --> 00:21:59.360
We use CG point instead of NS point.

00:21:59.360 --> 00:22:03.140
But then how do you convert these
to common things like strings?

00:22:03.140 --> 00:22:08.090
We provide a custom header, uigeometry.h,
that allows you to convert

00:22:08.150 --> 00:22:11.880
those things to common other
types like NSString from C.

00:22:11.940 --> 00:22:16.990
There's a category on NS value
and NSCoder to encode and read

00:22:16.990 --> 00:22:21.250
the values for CG geometric types.

00:22:21.720 --> 00:22:24.460
Speaking of which,
so here's a quick coding tip.

00:22:24.470 --> 00:22:28.030
UIKit is designed to work well
with Xcode code completion.

00:22:28.030 --> 00:22:29.690
Now what does this mean?

00:22:29.690 --> 00:22:33.260
We took the time to make
sure that all enums,

00:22:33.260 --> 00:22:35.760
function names,
and classes share a common

00:22:35.800 --> 00:22:37.620
prefix when it's necessary.

00:22:37.620 --> 00:22:40.760
For example,
in that last little bit that we saw,

00:22:40.760 --> 00:22:43.450
if you type in a string
from and type escape,

00:22:43.520 --> 00:22:48.100
then you're going to see all the
things that start with that prefix.

00:22:48.100 --> 00:22:52.650
So it's very easy to not have to remember
a bunch of methods and names and just

00:22:52.650 --> 00:22:54.620
instead remember a common prefix.

00:22:54.620 --> 00:22:56.920
So you type in a string from,
see a huge list,

00:22:56.990 --> 00:22:58.960
arrow down to what you want,
and hit enter.

00:22:58.960 --> 00:23:00.180
And you get in your code.

00:23:00.710 --> 00:23:02.780
Very fast and easy.

00:23:03.950 --> 00:23:06.600
So we just discussed Core Animation.

00:23:06.650 --> 00:23:09.610
Let's talk a little bit
more about drawing and views

00:23:09.870 --> 00:23:12.040
and how they work together.

00:23:12.340 --> 00:23:15.220
First, a little history on how
it works with AppKit.

00:23:15.440 --> 00:23:19.750
In AppKit, if you call set needs display,
it's going to redraw all the contents

00:23:19.750 --> 00:23:22.990
from that region that needs to
display and everything below it.

00:23:22.990 --> 00:23:26.110
In this images,
you can actually lock focus on

00:23:26.260 --> 00:23:28.010
this image and draw into it.

00:23:28.010 --> 00:23:32.720
Overlapping sibling views are
okay on Leopard and higher.

00:23:34.420 --> 00:23:37.800
Now inside of UIKit with UIView.

00:23:37.920 --> 00:23:41.960
Well, UIKit caches the resulting
image from DrawRect.

00:23:42.430 --> 00:23:45.240
Overlapping sibling views are also okay.

00:23:45.320 --> 00:23:48.490
And similar in AppKit,
you would use ordering to basically

00:23:48.510 --> 00:23:52.600
have one be appearing in front
of another if they are siblings.

00:23:53.400 --> 00:23:56.400
All the views,
since the UI kit is caching

00:23:56.530 --> 00:23:59.720
the image from DrawRect,
where actual core animation is,

00:23:59.990 --> 00:24:03.000
the views are composited together
in the end to generate the

00:24:03.100 --> 00:24:04.530
final image you see on screen.

00:24:04.750 --> 00:24:07.760
And I'll discuss a little
bit more on this in a bit.

00:24:08.540 --> 00:24:09.620
A little bit more on drawing.

00:24:09.620 --> 00:24:13.260
Well, drawing is available on UIKit with
familiar classes that you're

00:24:13.400 --> 00:24:16.740
probably already going to easily be
able to move over and start using.

00:24:16.740 --> 00:24:21.000
UI image is there,
and it's a very lightweight

00:24:21.000 --> 00:24:23.160
and immutable object.

00:24:23.240 --> 00:24:27.240
Simple things to draw the
image like draw at point.

00:24:27.260 --> 00:24:30.300
Now, it's immutable,
so you can't actually lock

00:24:30.300 --> 00:24:31.860
focus and draw into it.

00:24:31.960 --> 00:24:36.030
We do have methods and ways of
creating a bitmap image context

00:24:36.040 --> 00:24:38.280
to draw into an image context.

00:24:38.670 --> 00:24:41.270
And I recommend reading the
documentation or contacting

00:24:41.270 --> 00:24:42.480
us later for more information.

00:24:44.100 --> 00:24:46.820
UI string drawing,
we have to have a way of drawing strings.

00:24:47.180 --> 00:24:50.030
There's a special category on
strings I like to do common

00:24:50.460 --> 00:24:51.980
string drawing operations.

00:24:52.000 --> 00:24:56.000
How do you specify
what font to draw with?

00:24:56.000 --> 00:24:59.990
We have a UI font object,
probably just what you would expect.

00:25:00.210 --> 00:25:03.870
There's a UIGraphics.h which
does simple graphic things like

00:25:03.980 --> 00:25:08.290
UIRECTFILL and UIRECFRAME and whatnot.

00:25:09.090 --> 00:25:11.930
So UIView and redrawing.

00:25:12.090 --> 00:25:18.470
Requesting a parent or an overlapping
sibling will not redisplay the children.

00:25:18.690 --> 00:25:20.410
says, "The reverse is also true.

00:25:20.700 --> 00:25:24.590
Redrawing a non-opaque child
will not redraw the parent." Now,

00:25:24.590 --> 00:25:26.590
both those statements
are a little confusing.

00:25:26.810 --> 00:25:30.180
So here's an example screenshot.

00:25:30.390 --> 00:25:33.350
If you're going to
redraw that button there,

00:25:33.370 --> 00:25:35.900
like if you want the background
color to be something else,

00:25:35.930 --> 00:25:39.120
any call set needs a splant to redraw it.

00:25:39.440 --> 00:25:43.060
That will not redraw that
label view that's on it.

00:25:43.150 --> 00:25:45.780
The label view already has
its contents drawn and cached,

00:25:45.780 --> 00:25:48.770
and there's no need for it to redraw.

00:25:50.370 --> 00:25:53.240
So that begs the question of
core animation and redrawing

00:25:53.240 --> 00:25:55.820
and how does it actually work?

00:25:55.850 --> 00:25:59.840
So you have that view there,
that basic button cell,

00:26:00.130 --> 00:26:02.400
and it was the view that's redrawn.

00:26:02.480 --> 00:26:06.260
So what happens is that view's contents,
which was redrawn, is taken and added to

00:26:06.260 --> 00:26:09.020
the other two subviews,
which weren't redrawn,

00:26:09.020 --> 00:26:12.610
and they're composited together
to generate a final result.

00:26:12.610 --> 00:26:13.420
It's very simple.

00:26:15.460 --> 00:26:16.800
drawing and performance.

00:26:16.820 --> 00:26:19.000
Well, first of all,
I have to explain what

00:26:19.000 --> 00:26:20.490
does expensive mean.

00:26:20.500 --> 00:26:25.960
And expensive means it takes more time,
uses more CPU, uses more battery life,

00:26:26.000 --> 00:26:27.110
et cetera.

00:26:27.690 --> 00:26:31.990
Overriding draw rect isn't
necessarily needed in all cases.

00:26:32.080 --> 00:26:37.270
If you take a regular UI view,
you can use it for a container as

00:26:37.570 --> 00:26:40.510
something to hold other views and
place them where you need them.

00:26:40.510 --> 00:26:44.620
And by not overriding draw rect,
we have special optimizations

00:26:44.620 --> 00:26:48.180
we did in UIKit to make it very
fast to have such a view exist.

00:26:48.180 --> 00:26:53.190
So it's very cheap to have a plain
view and something to be aware of.

00:26:53.630 --> 00:26:57.080
It's also very cheap to set the
background color because doing

00:26:57.180 --> 00:27:00.210
a solid fill is very simplistic.

00:27:00.630 --> 00:27:02.840
Now, non-opaque views are expensive.

00:27:02.870 --> 00:27:07.600
So if you have a view which has something
that looks partially transparent,

00:27:07.600 --> 00:27:09.090
it's going to be an expensive view.

00:27:09.090 --> 00:27:13.900
So if your view looks opaque,
you should strive to make it be opaque.

00:27:13.900 --> 00:27:17.390
So if you have a label which
is on a white background,

00:27:17.510 --> 00:27:21.190
don't make the label have
a transparent background.

00:27:21.190 --> 00:27:24.440
Instead, make it actually have a white
background color and be opaque

00:27:24.540 --> 00:27:25.960
for performance reasons.

00:27:25.960 --> 00:27:28.450
Of course,
if you have an alpha value that's less

00:27:28.450 --> 00:27:30.810
than 1.0 and you really need that,
well,

00:27:30.810 --> 00:27:35.140
it has to be non-opaque and therefore it
has to be a little bit more expensive.

00:27:35.160 --> 00:27:39.040
For more information,
I highly recommend attending Optimizing

00:27:39.040 --> 00:27:44.180
Performance in iPhone Applications
in Presidio Thursday at 3.30 p.m.

00:27:46.960 --> 00:27:50.940
So we just took a second to
discuss drawing and views.

00:27:50.940 --> 00:27:54.960
Now let's take a little bit of
time to talk about animations.

00:27:56.060 --> 00:27:58.660
How do you do animations
inside of AppKit?

00:27:58.730 --> 00:28:03.990
Well, NSView implements
NSAnimatablePropertyContainer

00:28:04.200 --> 00:28:06.000
to do animations.

00:28:06.000 --> 00:28:07.200
And this is something new to Leopard.

00:28:07.200 --> 00:28:12.760
There's an animator proxy object
which is used to animate properties.

00:28:12.760 --> 00:28:16.680
The animations can optionally
be done by core animation if

00:28:16.680 --> 00:28:18.980
you're using CLA or back views.

00:28:19.010 --> 00:28:22.790
In addition,
there's a NSAnimationContext that

00:28:22.790 --> 00:28:26.960
allows you to do things like control
the grouping and the duration.

00:28:26.960 --> 00:28:30.020
So here's a little code snippet,
which you may or may not be familiar

00:28:30.020 --> 00:28:32.770
with because it's a new Leopard feature.

00:28:32.770 --> 00:28:36.020
You do NSAnimationContext,
begin a grouping,

00:28:36.020 --> 00:28:39.170
grab that current context,
set some properties like the duration,

00:28:39.170 --> 00:28:42.370
here it's setting it to two seconds,
and then you're going to set

00:28:42.510 --> 00:28:46.310
the frame to be some new frame
using the animator proxy object.

00:28:46.310 --> 00:28:50.440
So the view.animator.frame
is set to a new frame.

00:28:50.440 --> 00:28:53.360
And after the two seconds,
the animation would complete.

00:28:53.360 --> 00:28:57.420
So something as simple as
animating a button is really to do.

00:28:58.240 --> 00:29:00.040
UI view and animations.

00:29:00.120 --> 00:29:06.350
So UI view essentially has a
mode that -- or a way of putting

00:29:06.350 --> 00:29:07.940
it into an animation mode.

00:29:08.280 --> 00:29:11.280
And once you change any
animatable property,

00:29:11.480 --> 00:29:15.120
it will automatically
be animated for you.

00:29:15.170 --> 00:29:19.040
You don't actually have to go through
an animator proxy call to do it.

00:29:19.090 --> 00:29:21.400
So here's some example code.

00:29:21.440 --> 00:29:23.640
UI view begin animations.

00:29:23.700 --> 00:29:27.290
And the begin animations actually takes
a parameter that lets you identify

00:29:27.290 --> 00:29:29.780
the animation for later reasons.

00:29:29.840 --> 00:29:32.380
And an optional context
so you can refer to it.

00:29:32.670 --> 00:29:36.550
And the reason it does this is there are
other things behind the scenes you can

00:29:36.560 --> 00:29:41.300
set to receive when the animation has
ended and do certain other operations

00:29:41.300 --> 00:29:43.960
like chaining animations together.

00:29:44.290 --> 00:29:47.610
There's another class method,
set animation duration,

00:29:47.620 --> 00:29:51.100
and there's other ones to control
other animation things like the curves.

00:29:51.190 --> 00:29:52.970
Here it sets it for two seconds.

00:29:53.060 --> 00:29:54.250
Then you just set the property.

00:29:54.470 --> 00:29:56.300
So the view.frame is
set to the new frame.

00:29:56.300 --> 00:29:58.920
And in this case,
if you're doing that for the button,

00:29:58.920 --> 00:30:01.640
the button will go ahead
and animate in two seconds.

00:30:01.640 --> 00:30:03.340
Very simple and easy to do.

00:30:03.360 --> 00:30:09.280
So some tips and tricks
for doing animations.

00:30:10.200 --> 00:30:13.960
Well, UIView is going to always
use core animation.

00:30:13.990 --> 00:30:21.410
UIView animates by not calling drawrect
along each step of the animation.

00:30:21.560 --> 00:30:23.820
So instead,
it's just taking the views where it has

00:30:23.890 --> 00:30:28.410
the cache contents and recompositing
them again and again as needed to

00:30:28.420 --> 00:30:30.920
generate the animation on screen.

00:30:31.030 --> 00:30:33.290
Animating in this way is very fast.

00:30:33.480 --> 00:30:38.190
Animating using drawrect and
drawrect in each call is very slow.

00:30:38.510 --> 00:30:40.960
So some special considerations
that you have to take when

00:30:40.960 --> 00:30:41.800
you're doing animations.

00:30:41.800 --> 00:30:46.440
If they're changing the frame size,
then the contents of the frame may need

00:30:46.560 --> 00:30:48.840
to stretch or grow or potentially redraw.

00:30:48.840 --> 00:30:51.140
And we have a UI view
content mode property,

00:30:51.180 --> 00:30:54.270
which I recommend looking up
in the documentation for more

00:30:54.340 --> 00:30:56.410
information on how to control that.

00:30:56.460 --> 00:30:59.910
In addition, session 446,
how do I do that?

00:31:00.220 --> 00:31:03.760
Tips and tricks for iPhone
application development.

00:31:03.760 --> 00:31:08.380
And Friday at 1030,
we'll cover more about doing animations.

00:31:08.400 --> 00:31:10.840
inside of UIKit.

00:31:12.250 --> 00:31:15.040
So views and controls.

00:31:15.050 --> 00:31:17.730
We just finished talking about drawing.

00:31:17.730 --> 00:31:21.440
And now let's move on to talking
about some views and controls.

00:31:21.510 --> 00:31:24.800
First,
we're going to discuss some common views.

00:31:24.850 --> 00:31:27.880
Then we're going to talk a
little bit about scroll views.

00:31:27.900 --> 00:31:31.220
And finally, we're going to talk a
bit about table views.

00:31:31.220 --> 00:31:35.170
Let's jump right into it and start
talking about some common views.

00:31:36.640 --> 00:31:41.300
So some common views and controls in
AppKit and the counterparts for UIKit.

00:31:41.300 --> 00:31:48.120
We have buttons, sliders, text fields,
search fields, the UI search field,

00:31:48.280 --> 00:31:51.300
or sorry, it's a UI search bar instead
of a UI search field.

00:31:51.300 --> 00:31:53.760
So sometimes the names of
things change a little bit.

00:31:53.870 --> 00:31:56.210
You have progress indicators.

00:31:56.210 --> 00:31:59.630
Now in AppKit, a progress indicator has
two different styles.

00:31:59.630 --> 00:32:02.200
It has the bar style
and the spinny style.

00:32:02.250 --> 00:32:06.410
The spinny style inside of UIKit is
a special subclass called the

00:32:06.690 --> 00:32:09.390
UI activity in the care of you.

00:32:09.760 --> 00:32:14.280
The NS button inside of
App Kit has a checkbox style.

00:32:14.500 --> 00:32:16.670
Inside of UI Kit,
we don't have checkboxes,

00:32:17.030 --> 00:32:20.060
but we do have UI switches
that let you do that on and off

00:32:20.450 --> 00:32:23.610
mode and work like a checkbox.

00:32:24.700 --> 00:32:27.990
NSDatePicker, well,
the NSDatePicker looks different

00:32:28.030 --> 00:32:32.060
inside UIKit as the UIDatePicker,
and it's the big swirly wheels

00:32:32.060 --> 00:32:33.540
that you've probably seen and used.

00:32:33.620 --> 00:32:38.300
NSPopupButton, there aren't any popup
buttons on the iPhone.

00:32:38.300 --> 00:32:44.120
Instead, you can use the UIPickerView to
do a popup type of style control.

00:32:44.120 --> 00:32:47.560
The PickerView also lets you
do more things instead of just

00:32:47.580 --> 00:32:49.230
picking one item from the list.

00:32:49.240 --> 00:32:51.520
It lets you have multiple
different columns,

00:32:51.520 --> 00:32:55.420
so you could have one column
and another column and create

00:32:55.420 --> 00:32:58.000
combinations of results.

00:32:59.170 --> 00:33:02.260
So we briefly talked
about some common views.

00:33:02.260 --> 00:33:05.060
Let's discuss scroll views.

00:33:05.120 --> 00:33:09.270
First of all, how do scroll views
work inside of AppKit?

00:33:09.450 --> 00:33:15.790
Here's a quick screenshot of the
bookmarks table view inside a Safari.

00:33:16.140 --> 00:33:19.540
So the scroll view there,
let's say it has a frame of width of

00:33:19.650 --> 00:33:22.940
400 and a height of 400 for simplicity.

00:33:23.630 --> 00:33:29.000
It has sub views like the scroller on
the side and the header up at the top.

00:33:30.280 --> 00:33:32.720
In addition,
it has the table view inside of it.

00:33:32.800 --> 00:33:35.800
Now,
the table view's frame is a lot larger

00:33:35.800 --> 00:33:38.500
than the actual scroll view's frame.

00:33:38.500 --> 00:33:40.910
So its height is like 600,
and it would exceed the

00:33:40.910 --> 00:33:42.390
height of what you're seeing.

00:33:42.390 --> 00:33:43.760
So how is it clipping it?

00:33:43.760 --> 00:33:47.100
Well, probably most of you know that
there's an NS Clip view that

00:33:47.100 --> 00:33:48.900
actually does the clipping.

00:33:48.900 --> 00:33:53.920
So it has its Y frame a little bit lower
because it's below the table header.

00:33:53.920 --> 00:33:57.360
And it has a height of
400 to clip the height.

00:33:57.360 --> 00:34:00.180
It has a bounds Y offset.

00:34:00.200 --> 00:34:04.310
to control the origin of the
contents that you're seeing.

00:34:05.200 --> 00:34:09.790
So how does clipping work with
a UI view inside a UI kit?

00:34:09.840 --> 00:34:13.730
Essentially,
any UI view can become a clip view.

00:34:13.780 --> 00:34:19.130
So here's a basic view,
this turquoise-ish rectangle view.

00:34:19.320 --> 00:34:23.440
If you go ahead and see the
default property for clips

00:34:23.510 --> 00:34:26.730
to bounds is set to no,
which means that if

00:34:26.790 --> 00:34:29.700
you add two sub views,
they won't be clipped.

00:34:29.740 --> 00:34:33.150
They can appear outside
the bounds of that view.

00:34:33.340 --> 00:34:38.690
If you set clips to balance to be yes,
it will start clipping those other views.

00:34:38.820 --> 00:34:43.520
So UI scroll view by default has clips
to balance set to yes to clip out

00:34:43.610 --> 00:34:46.310
content that you don't want to see.

00:34:47.100 --> 00:34:49.230
So taking a look at UI Scroll View.

00:34:49.350 --> 00:34:51.180
So here's a typical one.

00:34:51.220 --> 00:34:53.320
The frame,
let's say for simplicity's sake,

00:34:53.320 --> 00:34:55.900
it's like a width of
200 and a height of 400.

00:34:55.940 --> 00:34:59.980
It really wouldn't be that because
that's not the actual screen size.

00:35:01.160 --> 00:35:06.110
Inside of it, the scroll view will have a
content size which is higher,

00:35:06.330 --> 00:35:09.290
like 400, than what you're seeing.

00:35:09.720 --> 00:35:13.600
The way that you control the content
offset is just like in its clip view.

00:35:13.660 --> 00:35:18.810
You set the bounds.origin, the Y,
to something like 50 to

00:35:18.840 --> 00:35:19.790
control what you're seeing.

00:35:20.240 --> 00:35:24.620
And it's clipping the height
with only a height of 400.

00:35:24.760 --> 00:35:27.840
So to make it easy to control
the offset of what you're seeing,

00:35:27.910 --> 00:35:30.600
there's a property called the
content offset that basically

00:35:30.600 --> 00:35:33.300
mimics that bounds.origin.

00:35:33.400 --> 00:35:35.770
So working with a scroll view.

00:35:36.710 --> 00:35:39.980
The way you would work with a scroll
view is you would go ahead and

00:35:39.980 --> 00:35:43.510
directly subclass UI scroll view.

00:35:43.770 --> 00:35:46.840
and the rest of the team
at UITableView do this.

00:35:46.840 --> 00:35:51.590
And they go ahead and manage when the
actual content changes and do special

00:35:51.740 --> 00:35:54.510
things like bring table cells into view.

00:35:54.990 --> 00:35:59.080
You can go ahead and add
subviews directly to it.

00:35:59.180 --> 00:36:03.850
One difference is you don't actually
have a document view property.

00:36:04.550 --> 00:36:09.300
Now, when you have a scroll view,
and let's say it has a button on it,

00:36:09.350 --> 00:36:13.380
there's a dilemma which is
not present inside of AppKit.

00:36:13.440 --> 00:36:16.740
If you have that button and you
touch on it inside of a scroll view,

00:36:16.800 --> 00:36:20.440
well, is it going to actually scroll
when you move your finger?

00:36:20.790 --> 00:36:22.770
Or when you hit the
button with your finger,

00:36:22.770 --> 00:36:24.210
is it going to track that button?

00:36:24.530 --> 00:36:26.580
Or in other words, a UI control?

00:36:26.670 --> 00:36:27.480
So what should it do?

00:36:27.480 --> 00:36:31.310
It's a dilemma,
and we need a way of solving that.

00:36:32.180 --> 00:36:36.570
The way you do this is we have a
set of APIs on UI School View to

00:36:36.570 --> 00:36:38.620
control that behavior.

00:36:38.920 --> 00:36:42.110
Here they are,
and I'm going to briefly talk about them.

00:36:42.230 --> 00:36:46.800
There's delays content touches to
delay the touches to the actual view.

00:36:46.800 --> 00:36:50.700
You can't cancel content touches,
and we'll describe a little bit

00:36:50.710 --> 00:36:52.200
about cancellation in a bit.

00:36:52.250 --> 00:36:55.860
There's some methods on
UI Scroll View that you can override.

00:36:55.860 --> 00:36:59.260
Touches should begin with
an event in a content view,

00:36:59.260 --> 00:37:02.260
and touches should
cancel in content view.

00:37:02.260 --> 00:37:05.350
I'm not really going to cover these,
but it's important to be

00:37:05.390 --> 00:37:06.740
aware of that dilemma.

00:37:06.740 --> 00:37:11.560
For more information,
I recommend attending How Do I Do That?

00:37:11.620 --> 00:37:15.090
Tips and Tricks for iPhone
Application Development,

00:37:15.090 --> 00:37:17.110
Friday at 10:30 a.m.

00:37:20.040 --> 00:37:22.900
So we just discussed scroll views.

00:37:22.940 --> 00:37:26.490
Let's move on and talk a
little bit about table views.

00:37:26.630 --> 00:37:30.290
First of all,
NS Table View compared to UI Table View.

00:37:30.310 --> 00:37:33.790
We'll both have a data source,
both have a delegate,

00:37:33.860 --> 00:37:39.750
both represent rows of data,
but the app kit NS Table View can

00:37:39.750 --> 00:37:43.760
have multiple different columns,
which you're probably familiar with.

00:37:43.790 --> 00:37:48.320
The UI Table View only allows one column,
and although it only allows one column,

00:37:48.330 --> 00:37:52.950
you could mock up multiple columns by
adding separate sub views that make

00:37:53.050 --> 00:37:55.780
it look like it has multiple columns.

00:37:56.340 --> 00:38:03.090
supports sectioning data so it allows
you to have different sections of

00:38:03.100 --> 00:38:05.580
data that you can expand and collapse.

00:38:05.620 --> 00:38:14.420
The UI table view by default
always supports sectioning of data.

00:38:14.420 --> 00:38:14.850
And we'll talk a little bit
more about how it works with

00:38:14.850 --> 00:38:14.850
UI table view in a second.

00:38:15.930 --> 00:38:19.990
Inside of App Kit, you can have multiple
selection in tables,

00:38:19.990 --> 00:38:22.880
but inside of UI Kit,
you really only have

00:38:22.960 --> 00:38:24.690
one selection at a time.

00:38:24.800 --> 00:38:28.200
Selection is more of a
temporary thing on the iPhone.

00:38:28.340 --> 00:38:30.740
So if you go ahead and
select a row and let go,

00:38:30.800 --> 00:38:34.420
it will probably do some action
like slide another view into screen,

00:38:34.420 --> 00:38:37.900
and then after the view goes away,
the selection will go away.

00:38:38.140 --> 00:38:41.010
So the selection is very temporary.

00:38:41.850 --> 00:38:46.800
Inside of AppKit, you're probably used to
using NSLs to do the drawing.

00:38:46.850 --> 00:38:49.710
Well, inside of UIKit,
we went ahead and used UI views

00:38:49.860 --> 00:38:52.290
to actually do the full drawing.

00:38:54.250 --> 00:38:57.460
So what does a UI table view look like?

00:38:57.580 --> 00:39:00.480
Here's one style which you're
probably familiar with and have seen.

00:39:00.690 --> 00:39:03.740
It's what we call the
UI table view style plane.

00:39:03.810 --> 00:39:08.880
It's your basic contact list
with multiple sections there.

00:39:09.040 --> 00:39:11.440
In addition,
we provide out of the box for

00:39:11.440 --> 00:39:15.510
you a UI table view style grouped
that allows that group style.

00:39:15.690 --> 00:39:19.610
So it's taking the sections and
combining them together with different

00:39:19.610 --> 00:39:22.060
little button looking like rows.

00:39:22.150 --> 00:39:25.510
These styles can be
set in the initializer.

00:39:25.740 --> 00:39:26.650
I'm not going to cover that.

00:39:26.760 --> 00:39:27.710
It's easy to use.

00:39:28.030 --> 00:39:32.080
You just allocate the table with the
particular style you're interested

00:39:32.080 --> 00:39:34.080
in and that's the way you get it.

00:39:35.180 --> 00:39:38.840
Some more details on how
the table is laid out.

00:39:38.910 --> 00:39:42.300
Again, the table is broken
into multiple sections.

00:39:42.430 --> 00:39:47.830
So you can see that the sections
could optionally have a header.

00:39:48.580 --> 00:39:52.260
Inside of each row is
a UI table view cell.

00:39:52.330 --> 00:39:54.470
It's a full-fledged view.

00:39:54.600 --> 00:39:56.350
So that view can have subviews.

00:39:56.620 --> 00:40:00.130
So by default, we provide a UI image
subview inside of it,

00:40:00.130 --> 00:40:05.220
and you can easily set that
image by doing cell.image equals

00:40:05.220 --> 00:40:07.690
some UI image that you load.

00:40:07.930 --> 00:40:09.960
There's also a label subview.

00:40:10.080 --> 00:40:16.330
So you can also easily change that label
text by doing cell.text equals some text.

00:40:16.490 --> 00:40:18.220
Very easy to use.

00:40:18.380 --> 00:40:22.750
Now, these views are lazily created
and added to the view hierarchy,

00:40:22.850 --> 00:40:24.260
so you don't have to use them at all.

00:40:24.420 --> 00:40:28.910
And if you don't use them,
there's no cost to having them there.

00:40:29.910 --> 00:40:32.000
The table view in sections.

00:40:32.120 --> 00:40:35.950
So you've seen that the table view
is broken into multiple sections.

00:40:36.070 --> 00:40:38.240
So the first thing it's going
to ask the data source is,

00:40:38.520 --> 00:40:40.190
well, how many sections do I have?

00:40:40.420 --> 00:40:43.300
So it says data source,
number of sections in table view,

00:40:43.300 --> 00:40:45.430
and then you would return the sections.

00:40:45.430 --> 00:40:47.900
Now,
a common programming error is to say, oh,

00:40:47.900 --> 00:40:50.240
I don't want any sections,
so I return zero.

00:40:50.240 --> 00:40:54.080
Well, you should return at least one
because you always need one section.

00:40:54.080 --> 00:40:57.780
By default, if you don't implement this,
you will get one section.

00:40:59.700 --> 00:41:01.360
So how is a row specified?

00:41:01.420 --> 00:41:04.610
Because you've seen that we
have rows inside of a section,

00:41:04.750 --> 00:41:07.400
and we need a way of identifying that.

00:41:08.060 --> 00:41:12.510
So the way we did it is we
use NSIndexPath to represent

00:41:12.740 --> 00:41:16.330
the section and the row,
and we add a category to

00:41:16.330 --> 00:41:17.590
make it easy to use that.

00:41:17.600 --> 00:41:22.490
So this is the category that
UI TableView applies to NSIndexPath.

00:41:22.500 --> 00:41:27.500
There's a simple initializer,
index path for row and section,

00:41:27.500 --> 00:41:31.890
and there are some properties on it
to access the section and the row.

00:41:32.840 --> 00:41:35.770
Behind the scenes,
all this is really doing is it's creating

00:41:35.770 --> 00:41:37.770
an index path with two indexes in it.

00:41:37.800 --> 00:41:39.670
The first index is
going to be the section,

00:41:39.670 --> 00:41:41.480
and the next one is going to be the row.

00:41:41.480 --> 00:41:44.820
But it's very easy to just
use the initializer and the

00:41:44.940 --> 00:41:47.040
properties that we provided.

00:41:49.000 --> 00:41:50.310
requires data source methods.

00:41:50.470 --> 00:41:52.700
You're probably familiar with
NS table view and AppKit.

00:41:52.700 --> 00:41:55.810
You have to implement
certain methods to get data.

00:41:55.900 --> 00:41:57.850
The same is the case on the phone.

00:41:57.960 --> 00:42:01.160
And of course, you need to know how many
rows are in a section.

00:42:01.420 --> 00:42:02.480
So it's very simple.

00:42:02.700 --> 00:42:06.370
Table view, number of rows in section,
and you return your row count.

00:42:07.090 --> 00:42:11.070
Now, the cells are the next piece of
information you need to know.

00:42:11.220 --> 00:42:14.760
So comparing the app
kit to the UI kit cells.

00:42:14.850 --> 00:42:18.430
Well, a cell, of course,
is used for the row column inside

00:42:18.430 --> 00:42:20.440
of app kit and NS table view.

00:42:20.440 --> 00:42:26.040
Essentially what the NS table view
does is it takes the same cell and

00:42:26.040 --> 00:42:31.950
it just kind of stamps it out along
each row to get the desired result.

00:42:32.750 --> 00:42:34.370
The cell itself is not a view.

00:42:34.670 --> 00:42:39.310
It just descends from in its object
and does the drawing for you.

00:42:39.540 --> 00:42:42.060
Now in UIKit, it also uses cells.

00:42:42.120 --> 00:42:45.740
And there is one cell,
in particular a UITableView cell,

00:42:45.810 --> 00:42:49.540
for each visible row
that you see on screen.

00:42:50.500 --> 00:43:06.390
The actual cell is a full-fledged view.

00:43:06.390 --> 00:43:06.390
So it goes ahead and
descends from UIView.

00:43:06.390 --> 00:43:06.390
And again, you really only have the views
for what you see on screen.

00:43:06.390 --> 00:43:06.390
So there are not cells for what's
not on screen because that would

00:43:06.390 --> 00:43:06.390
not be good for performance.

00:43:07.000 --> 00:43:11.480
So that begs the question of, well,
how do you load those cells and

00:43:11.480 --> 00:43:14.080
load them to what you see on screen?

00:43:14.140 --> 00:43:18.100
And then what is the concept of
reusing those cells for performance?

00:43:18.160 --> 00:43:20.580
So here's an example screenshot.

00:43:20.620 --> 00:43:22.580
Let's say that you take your
finger and you want to go

00:43:22.580 --> 00:43:24.810
ahead and scroll this view up.

00:43:24.940 --> 00:43:28.820
So old cells are going to move
off screen in the gray area above.

00:43:28.860 --> 00:43:34.670
And the new cells are going to move from
down below into that bluish area below.

00:43:35.030 --> 00:43:39.800
Taking a look at that, well,
those top non-visible table view cells,

00:43:39.800 --> 00:43:45.240
the table view is going to just take
them and remove them from the super view.

00:43:45.380 --> 00:43:50.000
It's going to add them to a
reuse queue inside of itself.

00:43:50.540 --> 00:43:54.330
Then the data source can go
and grab one of those cells,

00:43:54.360 --> 00:43:57.410
if there's one available,
and give it back to the table view

00:43:57.640 --> 00:44:00.120
for it to go ahead and reuse them.

00:44:01.130 --> 00:44:06.000
So in essence, the table view data source
is what returns a cell.

00:44:06.040 --> 00:44:09.480
This is a little different from NS table
view because the data source is the

00:44:09.480 --> 00:44:11.190
thing that actually returns you the cell.

00:44:11.190 --> 00:44:16.390
And it's going to either reuse one
or it's going to create another one.

00:44:16.880 --> 00:44:18.560
takes a look at some of the
code to actually go ahead

00:44:18.560 --> 00:44:21.340
and create it and do it.

00:44:21.450 --> 00:44:23.990
TableView, cell for row at index path.

00:44:23.990 --> 00:44:29.400
So again, we had spoken earlier about the
way to uniquely identify a section

00:44:29.510 --> 00:44:31.980
and a row is with an index path.

00:44:31.980 --> 00:44:34.070
So it's passed into you.

00:44:35.000 --> 00:44:38.050
First, you should try and find
a cell you can reuse.

00:44:38.050 --> 00:44:40.700
And the way you do that
is you ask the table view,

00:44:40.700 --> 00:44:43.070
dequeue reusable cell with identifier.

00:44:43.070 --> 00:44:45.700
So you're saying, hey,
I have this identifier

00:44:45.700 --> 00:44:46.790
for a type of cell.

00:44:46.900 --> 00:44:49.090
Is it already there and can I reuse it?

00:44:49.110 --> 00:44:53.630
If it didn't because there's none there,
it might be the first time.

00:44:53.640 --> 00:44:58.020
Then you go ahead and use UI table view,
cell alloc init with frame.

00:44:58.020 --> 00:45:03.380
And now the initializer has an additional
parameter called the reuse identifier.

00:45:03.380 --> 00:45:04.880
So this lets you designate
a cell with a identifier.

00:45:04.900 --> 00:45:07.860
And then you can designate a type
of cell that you can reuse later on.

00:45:07.860 --> 00:45:11.120
After that, you'll set common properties.

00:45:11.120 --> 00:45:14.110
If it was a reused cell,
you'll just be redrawing

00:45:14.120 --> 00:45:15.850
and reoverriding them.

00:45:17.260 --> 00:45:20.870
So some key points about it, as we said,
it's a full-fledged view.

00:45:21.380 --> 00:45:24.560
Things you probably don't want to do,
we don't want to override draw

00:45:24.560 --> 00:45:26.260
rect on the UI table view cell.

00:45:26.620 --> 00:45:30.570
Instead, we have those default views
that you can use with properties

00:45:30.920 --> 00:45:34.670
that we allow you to set,
like the image and the text.

00:45:35.060 --> 00:45:37.960
You can actually add other
subviews to it that do the

00:45:37.960 --> 00:45:40.520
specific drawing that you want.

00:45:41.220 --> 00:45:43.760
And something that you really
want to do for performance,

00:45:43.780 --> 00:45:45.510
you always want to reuse cells.

00:45:45.790 --> 00:45:47.910
Otherwise,
your scoring performance in your

00:45:47.910 --> 00:45:49.730
application will not be good.

00:45:49.800 --> 00:45:52.760
For more information,
I recommend attending Mastering

00:45:52.780 --> 00:45:55.580
iPhone Table Views Friday at 9:00 AM.

00:45:55.650 --> 00:45:57.880
And what they're going to
cover is more advanced things,

00:45:57.910 --> 00:46:00.750
like doing the animations
to insert and delete cells,

00:46:00.840 --> 00:46:04.420
doing the animations to show
the delete buttons on the side,

00:46:04.430 --> 00:46:06.080
and whatnot.

00:46:07.430 --> 00:46:10.700
So text views, fields, and labels.

00:46:10.740 --> 00:46:14.240
Well, the iPhone has typical
text entry as you've seen.

00:46:14.280 --> 00:46:17.630
There's a basic UI label class
to provide simple read-only text.

00:46:17.630 --> 00:46:22.040
There's a UI text view, which is a big,
huge text area.

00:46:22.040 --> 00:46:25.660
A UI text field to do
editable text entry.

00:46:25.660 --> 00:46:28.340
They're all fairly easy to
use and straightforward.

00:46:28.340 --> 00:46:31.330
And I recommend attending
text input on the iPhone,

00:46:31.330 --> 00:46:33.690
Russian Hill, Wednesday at 5 p.m.

00:46:33.690 --> 00:46:35.290
for more information.

00:46:38.050 --> 00:46:41.380
is the founder of Drupal,
and he's the founder of Windows.

00:46:41.380 --> 00:46:43.610
We just discussed views and controls.

00:46:43.640 --> 00:46:46.000
Let's move on and talk about some events.

00:46:46.000 --> 00:46:50.170
So first we'll discuss Windows,
then discuss respond or event handling,

00:46:50.180 --> 00:46:52.380
and finally control event handling.

00:46:52.380 --> 00:46:54.890
Let's jump right into it with Windows.

00:46:55.230 --> 00:46:58.540
In both AppKit and UIKit,
all events are filtered through the

00:46:58.540 --> 00:47:00.580
window through a send event method.

00:47:00.900 --> 00:47:04.500
AppKit uses NSEvent, UIKit uses UIEvent.

00:47:04.640 --> 00:47:09.240
The actual window in AppKit, again,
is just a responder inside of AppKit,

00:47:09.350 --> 00:47:12.400
but in UIKit,
it's actually a full-fledged view.

00:47:12.550 --> 00:47:16.400
So this means that you can
do things like add subviews,

00:47:16.500 --> 00:47:20.880
there's a hidden property on the
view to make a window be visible,

00:47:20.880 --> 00:47:21.850
et cetera.

00:47:22.470 --> 00:47:26.900
Now, you've seen on the phone,
and there aren't ways to resize windows,

00:47:26.960 --> 00:47:30.250
there is no close buttons, and hence,
there's actually no

00:47:30.250 --> 00:47:32.060
delegate for the UI window.

00:47:32.410 --> 00:47:34.180
In AppKit,
the main reason that we have the

00:47:34.180 --> 00:47:38.030
delegate is for all those operations
for you to control and override.

00:47:38.220 --> 00:47:41.080
There is a need for that inside of UIKit.

00:47:41.710 --> 00:47:46.080
The UI window doesn't have the
concept of make key and order front.

00:47:46.470 --> 00:47:50.870
Instead, basically the window is a view,
and you just make that view not be

00:47:50.980 --> 00:47:54.200
hidden to make it actually be visible.

00:47:54.480 --> 00:47:58.490
You can control the window
level to actually do ordering.

00:47:58.490 --> 00:48:01.540
And we do have one simple method
that lets you do it all at once.

00:48:01.700 --> 00:48:04.370
And I recommend using and
reading the UIV documentation

00:48:04.420 --> 00:48:06.490
for information on that.

00:48:06.910 --> 00:48:10.030
Of course, the biggest difference
in Windows is that,

00:48:10.030 --> 00:48:14.860
well, the UI window deals with
touches instead of mouse events.

00:48:15.760 --> 00:48:17.730
We briefly talked about Windows.

00:48:17.810 --> 00:48:20.780
Let's go ahead and talk about
responder event handling,

00:48:20.830 --> 00:48:24.080
particularly how to do
it inside of AppKit,

00:48:24.150 --> 00:48:27.150
and then we'll talk about
how to do it inside of UIKit.

00:48:27.680 --> 00:48:31.270
In AppKit, you're probably familiar
with two different ways to

00:48:31.270 --> 00:48:34.510
do dragging event processing.

00:48:34.940 --> 00:48:38.000
The first way we call the
three method approach.

00:48:38.200 --> 00:48:43.030
So you would override mouse down,
probably set up some state or whatnot.

00:48:43.160 --> 00:48:46.030
Override mouse, drag,
do some logic like drawing lines

00:48:46.030 --> 00:48:47.330
or whatever you want to do.

00:48:47.330 --> 00:48:51.630
And then override mouse
up to stop your logic.

00:48:52.110 --> 00:48:54.990
There's also the mouse
tracking loop approach.

00:48:55.100 --> 00:48:59.880
So you would override mouse down, loop,
go to NS application,

00:48:59.960 --> 00:49:03.780
extract events that you're interested in,
and then stop looping once you do

00:49:03.780 --> 00:49:05.770
something like process and mouse up.

00:49:05.960 --> 00:49:09.160
That's all done within an
override of mouse down.

00:49:09.330 --> 00:49:11.580
Something that does this
is like NS table view,

00:49:11.630 --> 00:49:16.890
which overrides that and passes
the tracking onto the cell itself.

00:49:17.280 --> 00:49:20.100
We don't recommend doing this
approach inside of UIKit,

00:49:20.100 --> 00:49:23.540
and we'll discuss the proper
way to do it in just a minute.

00:49:23.650 --> 00:49:28.070
First, we need to have a basic
understanding of what a touch is.

00:49:28.800 --> 00:49:31.960
If you take your finger down
and put it on the phone,

00:49:31.960 --> 00:49:33.620
you're going to get a touch began.

00:49:33.870 --> 00:49:36.250
So the phase began.

00:49:36.600 --> 00:49:40.120
If you move it, you're going to go ahead
and get a touch moved.

00:49:40.460 --> 00:49:46.970
So the same touch has its phase and
location changed to being moved.

00:49:47.070 --> 00:49:49.020
If you remove your
finger from the screen,

00:49:49.040 --> 00:49:51.210
you're going to get a touch ended.

00:49:51.960 --> 00:49:53.290
Now, multiple touches.

00:49:53.560 --> 00:49:55.880
So let's say you take two
fingers and stick them down.

00:49:55.920 --> 00:49:58.000
You're going to get two touch begans.

00:49:58.030 --> 00:50:01.140
Overall, you have all touches of two.

00:50:01.340 --> 00:50:04.400
If you put a third finger down, well,
those two touches,

00:50:04.600 --> 00:50:07.180
they stay the same instance,
and they just change their

00:50:07.180 --> 00:50:08.140
phase to be stationary.

00:50:08.140 --> 00:50:12.390
The third touch, you get a touch began.

00:50:12.740 --> 00:50:16.500
If you move one of those first ones,
well, it gets a touch moved and the other

00:50:16.500 --> 00:50:18.470
stays stationary as their phase.

00:50:18.470 --> 00:50:21.070
Then you remove all
three fingers at once,

00:50:21.070 --> 00:50:23.820
and all at once you
get three touch-ended.

00:50:26.060 --> 00:50:32.110
It's important to note that multi-touch
is opt-in and you have to set a

00:50:32.180 --> 00:50:36.930
property view.multipletouchenabled
to get multiple touches.

00:50:36.990 --> 00:50:38.940
If you don't do this and you're
confused as to why you're

00:50:38.940 --> 00:50:42.570
not getting multiple touches,
this is the reason why.

00:50:43.450 --> 00:50:45.490
So touches and cancellation.

00:50:45.820 --> 00:50:50.560
Cancellation is a new thing that's on
the iPhone that you have to worry about.

00:50:51.150 --> 00:50:53.720
Take your finger and you put it
down and you get a touch began.

00:50:53.720 --> 00:50:55.740
You get your touch moved.

00:50:55.830 --> 00:50:58.460
Now let's say something
like a phone call comes up.

00:50:58.460 --> 00:51:03.220
Well, you have to get a touch canceled
to cancel that touch event.

00:51:03.220 --> 00:51:06.730
We'll talk a little bit more about
this later and how to deal with it.

00:51:09.240 --> 00:51:12.600
So now that we know what touches are,
how do you actually handle

00:51:12.600 --> 00:51:15.170
events with UI Responder?

00:51:15.480 --> 00:51:18.440
We recommend you always use
that three method approach and

00:51:18.440 --> 00:51:19.950
implement the cancellation.

00:51:20.190 --> 00:51:22.480
So it's really more of
a four method approach.

00:51:22.530 --> 00:51:25.790
And the four methods are
touches began with event,

00:51:26.030 --> 00:51:29.960
touches moved with event,
touches ended with event, and of course,

00:51:30.060 --> 00:51:31.690
touches canceled with event.

00:51:31.720 --> 00:51:35.220
It's passing in a set of touches
that cause that thing to happen,

00:51:35.220 --> 00:51:37.890
and then an event that
has some more information,

00:51:38.010 --> 00:51:40.040
which we will describe in a second.

00:51:42.310 --> 00:51:48.480
So how is a UI event and a
UI touch represented and related?

00:51:48.600 --> 00:51:52.910
So the UI touch is actually an instance
in a class that you interact with.

00:51:53.200 --> 00:51:57.110
The UI event itself has a
timestamp for when it happened.

00:51:57.480 --> 00:52:00.100
The event contains a touch.

00:52:00.150 --> 00:52:05.500
Well, you could have multiple touches,
so it contains one or other touches.

00:52:05.570 --> 00:52:08.790
Inside of each touch is a timestamp.

00:52:09.540 --> 00:52:12.350
But more importantly,
there's a location and a

00:52:12.480 --> 00:52:15.160
previous location for that touch.

00:52:15.190 --> 00:52:18.240
An important difference from inside of
AppKit is the location is actually in

00:52:18.240 --> 00:52:21.590
the touch and not in the event itself.

00:52:22.000 --> 00:52:25.340
The touch also has other information
like the view that it occurred in

00:52:25.340 --> 00:52:27.150
and the window that the view is in.

00:52:27.150 --> 00:52:29.040
And it has a phase.

00:52:29.070 --> 00:52:35.650
So the phase is something like began,
moved, ended, etc.

00:52:37.290 --> 00:52:39.470
So let's take a look at one
of those methods and follow

00:52:39.470 --> 00:52:42.070
it along just a little bit.

00:52:42.210 --> 00:52:45.470
First of all,
touchesBegin passes in a set

00:52:45.710 --> 00:52:50.230
of touches that actually made
that touchesBegin happen.

00:52:50.510 --> 00:52:54.860
Inside of each touch is where
you would find the location.

00:52:55.600 --> 00:53:00.260
The event itself has a
reference to all touches.

00:53:00.370 --> 00:53:02.860
So of course,
all touches is going to reference those

00:53:02.930 --> 00:53:06.330
other touches that you already got,
but there may be other

00:53:06.330 --> 00:53:09.560
ones that were stationary,
and this is the way you

00:53:09.560 --> 00:53:11.370
would access those ones.

00:53:11.780 --> 00:53:14.740
Some more notes about
UI Event and UI Touch.

00:53:14.890 --> 00:53:19.600
Well, how do you actually get
touches for a UI Event?

00:53:19.720 --> 00:53:21.800
You can use all touches.

00:53:21.930 --> 00:53:25.780
You can use touches for view
and some other methods which

00:53:25.780 --> 00:53:28.620
we briefly discussed before.

00:53:29.520 --> 00:53:34.520
The important thing is that the
UI touch contains the actual point and

00:53:34.520 --> 00:53:38.030
you access it via location and view.

00:53:39.900 --> 00:53:43.800
The touch instances
actually remain the same.

00:53:43.880 --> 00:53:48.180
So they are the thing that
has their properties change,

00:53:48.220 --> 00:53:52.800
like the location, the previous location,
and the phase.

00:53:52.840 --> 00:53:58.160
Those things, those properties change,
but the instance does not change itself.

00:53:58.540 --> 00:54:01.400
Another thing to note is the
responder chain is slightly different.

00:54:01.510 --> 00:54:02.640
So what does this mean?

00:54:02.850 --> 00:54:06.100
Well, inside of AppKit,
you can call setNextResponder

00:54:06.240 --> 00:54:09.340
to actually change the responder
and it's saved for you.

00:54:09.530 --> 00:54:12.480
Inside of UIKit,
there is no setter for the responder.

00:54:12.630 --> 00:54:15.150
Instead, you would have to override
the next responder.

00:54:15.320 --> 00:54:19.730
By default,
it just goes up the view hierarchy

00:54:19.760 --> 00:54:23.800
chain and also works with
view controllers a little bit.

00:54:24.170 --> 00:54:27.920
For more information on touches,
I recommend session 380,

00:54:28.290 --> 00:54:32.760
iPhone multi-touch events and gestures,
Wednesday at 3.30 in Mission.

00:54:35.640 --> 00:54:39.840
So we just discussed
responder event handling.

00:54:39.890 --> 00:54:44.000
Let's move on and talk about
controls and event handling.

00:54:44.770 --> 00:54:47.640
How do you handle events with UI control?

00:54:47.670 --> 00:54:51.560
Well, first of all,
control tracks the first

00:54:51.640 --> 00:54:53.570
touch and ignores the others.

00:54:53.570 --> 00:54:57.280
Now, this is important for things
like control subclasses,

00:54:57.280 --> 00:54:59.990
buttons,
sliders and switches and whatnot.

00:55:00.010 --> 00:55:02.660
And if you think about it,
it makes sense.

00:55:02.710 --> 00:55:04.380
If you take one finger
and put in a button,

00:55:04.430 --> 00:55:06.860
then you take another finger
and put in a button and you

00:55:07.290 --> 00:55:08.560
release that second finger,
well,

00:55:08.560 --> 00:55:12.400
you're still holding your first finger
down and you don't want that other

00:55:12.400 --> 00:55:14.520
finger to actually do the action.

00:55:14.520 --> 00:55:17.110
You don't want to do the
action until your first finger

00:55:17.110 --> 00:55:18.860
is removed from the screen.

00:55:18.860 --> 00:55:22.310
So control is good to track the
first touch that happened and

00:55:22.310 --> 00:55:24.360
that's what it's designed for.

00:55:24.360 --> 00:55:28.710
So it disables multi-touch by calling
control multiple touch enabled equals no,

00:55:28.710 --> 00:55:32.310
which is actually the
default for a UI view.

00:55:32.990 --> 00:55:37.100
So how do you actually override
and subclass a UI control?

00:55:37.130 --> 00:55:40.080
Well, you're probably familiar with
how to do it inside of NSLs,

00:55:40.100 --> 00:55:41.620
and it's very similar.

00:55:41.660 --> 00:55:45.460
There's a set of methods on
UI control that you can override.

00:55:45.490 --> 00:55:48.620
Begin tracking with touch with event.

00:55:48.670 --> 00:55:51.000
Continue tracking with touch with event.

00:55:51.040 --> 00:55:52.880
End tracking with touch with event.

00:55:52.910 --> 00:55:56.900
And of course, cancellation you also have
to consider and probably stop

00:55:56.900 --> 00:55:58.560
whatever action you were doing.

00:55:58.640 --> 00:56:01.310
So cancel tracking with event.

00:56:02.900 --> 00:56:05.200
So UI control and target action.

00:56:05.250 --> 00:56:08.830
As we already know,
you can hook up usually one target and

00:56:08.840 --> 00:56:12.560
one action per control inside of AppKit.

00:56:12.950 --> 00:56:14.600
But UIKit is different.

00:56:14.640 --> 00:56:19.500
You can have multiple different targets
and multiple different actions like

00:56:19.500 --> 00:56:21.290
we saw at the demo at the beginning.

00:56:21.860 --> 00:56:23.800
Now, how do you represent those?

00:56:23.880 --> 00:56:28.930
Well, there's a bit set called
UI Control Events that lets you

00:56:28.930 --> 00:56:31.950
control the different events
you want to actually handle.

00:56:31.950 --> 00:56:35.530
So there's ones like
UI Control Event Touchdown,

00:56:35.530 --> 00:56:38.910
UI Control Event Touch Up Inside,
et cetera.

00:56:38.910 --> 00:56:40.120
There's lots of these.

00:56:40.120 --> 00:56:44.010
Also notice that they all have that
common prefix I was talking about before.

00:56:44.010 --> 00:56:46.270
So inside of Xcode,
you could type UI Control Event,

00:56:46.270 --> 00:56:48.870
hit escape, and see a list of all of
them that are available.

00:56:48.870 --> 00:56:51.770
Very easy to do, and you don't have to
memorize them all the time.

00:56:51.800 --> 00:56:53.220
all.

00:56:54.180 --> 00:56:59.240
So now you know how to actually get
the actions and what are available.

00:56:59.240 --> 00:57:01.220
How do you actually register a target?

00:57:01.220 --> 00:57:02.900
Well, there's a simple method.

00:57:02.900 --> 00:57:07.200
Add target, action, four control events.

00:57:07.200 --> 00:57:11.240
So you can have an orbit set of
the actual control events you want

00:57:11.240 --> 00:57:15.790
to handle with your target and the
selector you want to have called.

00:57:15.790 --> 00:57:18.300
Again,
it's not a one-to-one relationship,

00:57:18.300 --> 00:57:21.830
so you can call this multiple times
again and again with different

00:57:21.840 --> 00:57:23.790
targets and different actions.

00:57:24.100 --> 00:57:25.260
Thank you.

00:57:25.620 --> 00:57:28.690
There are three different
signatures as we saw before.

00:57:28.880 --> 00:57:32.250
There's one signature which
doesn't have any parameters.

00:57:32.530 --> 00:57:36.300
A signature which has a sender
just like inside of AppKit.

00:57:36.400 --> 00:57:44.690
And then a signature which has the sender
and the UI event that made it happen.

00:57:44.690 --> 00:57:44.690
You get to choose.

00:57:45.580 --> 00:57:50.420
So in summary, we talked a bit about
application architecture.

00:57:50.440 --> 00:57:53.180
We talked a bit about views and controls.

00:57:53.200 --> 00:57:55.800
Then we went on and talked about drawing.

00:57:55.810 --> 00:57:58.810
And finally, we also talked about events.

00:57:59.490 --> 00:58:02.840
For more information,
come find us in the labs,

00:58:02.890 --> 00:58:05.700
the iPhone Controls, Views,
and Animation Lab,

00:58:05.730 --> 00:58:08.760
the iPhone Multitouch and
Events and Gestures Lab,

00:58:08.760 --> 00:58:11.960
the iPhone View Controllers Lab,
and get more information and

00:58:11.960 --> 00:58:13.380
help with your applications.

00:58:15.270 --> 00:58:18.190
For more information,
you can contact Derek Horn,

00:58:18.190 --> 00:58:22.890
our Application Frameworks Evangelist,
and look at our excellent documentation.

00:58:22.890 --> 00:58:26.070
Go to the iPhone Dev Center.
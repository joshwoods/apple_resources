WEBVTT

00:00:21.700 --> 00:00:28.800
[Transcript missing]

00:00:29.650 --> 00:00:30.600
Good.

00:00:30.600 --> 00:00:34.240
Well, I'm pretty tired, too.

00:00:34.240 --> 00:00:36.460
So welcome to the last
session of the week,

00:00:36.670 --> 00:00:38.670
Accessing Contacts and
Calendars on Leopard.

00:00:38.740 --> 00:00:40.230
My name is Matt Drance.

00:00:40.440 --> 00:00:44.100
I'm the Sharing Technologies Evangelist
here at Apple,

00:00:44.100 --> 00:00:46.600
and it is my pleasure to play us out.

00:00:46.600 --> 00:00:49.680
I don't know what that means,
play us out.

00:00:49.760 --> 00:00:51.800
Does it mean end the show?

00:00:51.800 --> 00:00:51.800
I don't know.

00:00:52.980 --> 00:00:53.480
Somebody got it.

00:00:53.620 --> 00:00:55.780
Thank you.

00:00:56.090 --> 00:01:00.170
So we're going to be talking about two
really critical frameworks to providing

00:01:00.170 --> 00:01:04.170
an excellent user experience on Mac OS X:
the Address Book framework and

00:01:04.170 --> 00:01:06.400
the Calendar Store framework.

00:01:06.880 --> 00:01:08.860
These two frameworks are
important to you as a developer,

00:01:08.910 --> 00:01:12.280
but they're also important to the
applications that Apple writes to,

00:01:12.280 --> 00:01:14.210
and you've seen their
effect in multiple places.

00:01:14.220 --> 00:01:18.340
The address book framework helps you
add personal contacts to data that would

00:01:18.660 --> 00:01:21.120
otherwise be arbitrary and confusing.

00:01:21.120 --> 00:01:24.750
Here's a screenshot of iChat with
a bunch of random screen names.

00:01:24.840 --> 00:01:28.700
And iChat uses the address book framework
to take this overwhelming data and

00:01:28.700 --> 00:01:32.690
turn it into something that an average
person can immediately recognize.

00:01:32.700 --> 00:01:34.740
First name and last name, picture.

00:01:35.690 --> 00:01:38.510
Now I just take one glance at
this window and I immediately

00:01:38.510 --> 00:01:40.520
know really what I'm looking at.

00:01:41.070 --> 00:01:47.450
Likewise,
the Calendar Store framework allows you

00:01:47.540 --> 00:01:54.880
to take pieces of data that are around in
the system and give the user an effective

00:01:54.880 --> 00:01:54.880
hook into the Calendar Store framework
that's used by iCal and a bunch of

00:01:54.880 --> 00:01:54.880
other applications on the system.

00:01:55.120 --> 00:01:58.650
So, Mail is one of these clients,
and Mail's got some pretty clever data

00:01:59.000 --> 00:02:02.930
detectors that will allow you to just
create an event right out of the blue.

00:02:04.460 --> 00:02:08.270
And you also get a lot of additional
perks by working with these frameworks.

00:02:08.410 --> 00:02:12.540
All of the data that you read
and write using Calendar Store or

00:02:12.550 --> 00:02:17.260
Address Book are automatically
synced to MobileMe and before that,

00:02:17.260 --> 00:02:18.140
.Mac.

00:02:18.160 --> 00:02:23.020
And of course, all of this data also is
synchronized to the iPhone.

00:02:25.530 --> 00:02:28.100
And like I said,
working with this data is

00:02:28.100 --> 00:02:30.970
important to providing a consistent
user experience on the Mac,

00:02:31.100 --> 00:02:32.920
particularly because the
standard has been set,

00:02:33.020 --> 00:02:35.180
the bar has been set by
the Apple applications.

00:02:35.260 --> 00:02:36.180
These are just a few.

00:02:36.180 --> 00:02:41.850
Dashboard, iChat, Safari, iPhoto, iTunes,
and Mail.

00:02:41.860 --> 00:02:45.600
Pretty much every application
on the system has some hook into

00:02:45.600 --> 00:02:49.860
Address Book and iCal so users can
stay connected and stay informed.

00:02:49.860 --> 00:02:54.490
And it's a challenge for you as
a developer to make sure that

00:02:54.490 --> 00:02:57.120
you're doing the same thing,
that you're living up to that standard.

00:02:57.120 --> 00:02:58.330
I mean, this is really the difference.

00:02:58.380 --> 00:03:00.690
Anybody can put a window
on the screen and launch an

00:03:00.690 --> 00:03:06.140
app and work with some data,
but it's stuff like this that propels you

00:03:06.140 --> 00:03:09.740
to popularity in the community and things
like winning an Apple Design Award.

00:03:09.740 --> 00:03:11.690
There's a lot that goes into
winning an Apple Design Award,

00:03:11.700 --> 00:03:16.070
but personalization and familiarity
and consistency with other areas on

00:03:16.070 --> 00:03:17.710
the platform are a big part of that.

00:03:19.480 --> 00:03:22.300
So let's go ahead and get
started with contacts.

00:03:22.300 --> 00:03:26.250
And as I already said,
contacts are provided by

00:03:26.250 --> 00:03:27.680
the address book framework.

00:03:27.700 --> 00:03:30.800
And the first thing the address book
framework gets you is free persistence.

00:03:30.880 --> 00:03:36.340
So if you're writing an application
that does contact management or project

00:03:36.340 --> 00:03:43.400
management and has either a trivial or
critical connection with contact data,

00:03:43.400 --> 00:03:45.780
if you use the address book framework,
you don't need to worry about

00:03:45.790 --> 00:03:46.990
persisting that information.

00:03:47.040 --> 00:03:48.340
It's all taken care of for you.

00:03:48.340 --> 00:03:51.240
And we worry about scale and
performance and redundancy

00:03:51.240 --> 00:03:53.570
and consistency and all that.

00:03:54.590 --> 00:03:57.000
And most importantly,
it gives you integration with

00:03:57.000 --> 00:03:59.700
the Address Book application,
which is more than just the

00:03:59.700 --> 00:04:02.210
double-clickable app that
you see on the file system,

00:04:02.270 --> 00:04:04.490
but additional related
services like Spotlight.

00:04:04.950 --> 00:04:11.890
If you write contact information
using the Address Book framework,

00:04:12.300 --> 00:04:17.150
those contacts are now
searchable in the Spotlight menu.

00:04:17.150 --> 00:04:17.150
Likewise, the Address Book Dashboard
widget has that data.

00:04:17.810 --> 00:04:21.790
And again,
applications like Mail and iChat.

00:04:21.910 --> 00:04:28.130
Also use this data whenever it's
available for a better user experience.

00:04:29.310 --> 00:04:31.390
So the details of the
Address Book framework.

00:04:31.420 --> 00:04:34.300
We're going to stay pretty high
level here because we've got two

00:04:34.300 --> 00:04:36.020
frameworks to cover in one hour.

00:04:36.130 --> 00:04:39.080
So I'm going to give you an
overview of the object model.

00:04:39.240 --> 00:04:45.960
Specifically,
there are two main types of data that you

00:04:45.960 --> 00:04:45.960
work with in the Address Book framework,
people and groups.

00:04:46.320 --> 00:04:49.870
We've got structured search elements
that you put together when you're

00:04:49.870 --> 00:04:53.370
looking for specific pieces of data
and you want to get a real person,

00:04:53.470 --> 00:04:54.390
a vCard out of that.

00:04:54.740 --> 00:05:04.110
And we also have a reusable UI element
that you can use to provide a really

00:05:04.110 --> 00:05:04.110
consistent experience from what you
see in Mail and iChat and Address Book.

00:05:04.890 --> 00:05:06.720
So the object model is very simple.

00:05:06.760 --> 00:05:09.490
There is a base class called
AB Record that has the

00:05:09.760 --> 00:05:12.400
core pieces of information,
like a unique ID,

00:05:12.400 --> 00:05:16.960
as well as a hash of properties and keys
and values for things like first name,

00:05:16.960 --> 00:05:18.620
last name, birthday.

00:05:19.330 --> 00:05:24.590
And then the stuff that you'll
actually be working with,

00:05:24.590 --> 00:05:30.450
you're not going to be really
working with AB record directly,

00:05:30.450 --> 00:05:34.850
is AB Person, which is a subclass,
of course,

00:05:34.850 --> 00:05:35.490
and it has more things that are
attributed to people as opposed

00:05:35.490 --> 00:05:35.490
to records in the database,
like an image, as well as groups that

00:05:35.490 --> 00:05:35.490
the person belongs to.

00:05:53.450 --> 00:05:53.560
And we also have groups.

00:05:53.560 --> 00:05:53.560
And if you want to just go ahead and
launch the Address Book application,

00:05:53.560 --> 00:05:53.560
you can see what we're talking about.

00:05:53.560 --> 00:05:53.560
The groups are on the left,
people are on the right.

00:05:53.560 --> 00:05:53.560
And groups are straightforward.

00:05:53.560 --> 00:05:53.560
They've got a list of members
and a list of subgroups,

00:05:53.560 --> 00:05:53.560
so we can have hierarchical
groups in the Address Book.

00:05:53.560 --> 00:05:53.560
And you have access to all of
this stuff through the framework.

00:05:54.190 --> 00:05:56.510
So because we're limited on time,
we're going to concentrate

00:05:56.510 --> 00:05:58.380
on people today,
and I think that's probably what

00:05:58.380 --> 00:05:59.500
most people are interested in.

00:05:59.930 --> 00:06:01.570
Anyway.

00:06:03.490 --> 00:06:06.520
So the A/B Person class gives you most
of this personal information that's

00:06:06.520 --> 00:06:08.410
going to be used in various places.

00:06:08.600 --> 00:06:13.080
And these are all stored as keys
in that key value dictionary.

00:06:13.190 --> 00:06:18.970
So we've got things like first name,
last name, the person's birthday,

00:06:19.010 --> 00:06:25.570
email addresses, AIM or Jabber IDs,
home pages, as well as physical address.

00:06:25.590 --> 00:06:27.690
And those are just a few.

00:06:27.690 --> 00:06:30.150
There's tons of information
available to you through A/B Person.

00:06:31.280 --> 00:06:32.150
So let's get into the code.

00:06:32.240 --> 00:06:34.240
It's really straightforward.

00:06:34.280 --> 00:06:36.460
To read information
out of a given person,

00:06:36.500 --> 00:06:39.080
you start by importing the
Address Book framework.

00:06:39.300 --> 00:06:46.410
So those of you who are
new to the platform,

00:06:46.410 --> 00:06:47.510
you either drag or add a
framework to the project.

00:06:47.510 --> 00:06:47.510
In this case, it's Address Book.

00:06:47.780 --> 00:06:49.910
You import the Address Book header.

00:06:50.020 --> 00:06:51.510
You get the shared Address Book.

00:06:51.600 --> 00:06:57.360
This is a singleton instance that
does most of the work for you.

00:06:57.830 --> 00:06:59.090
And then we go ahead and get a person.

00:06:59.100 --> 00:07:00.890
And there are a bunch
of ways to get a person.

00:07:00.990 --> 00:07:03.240
In the interest of simplicity,
on this slide,

00:07:03.240 --> 00:07:07.200
we're doing it using a unique ID that
presumably was stored somewhere else.

00:07:07.200 --> 00:07:09.800
And we'll go over searching
in a little while.

00:07:09.840 --> 00:07:14.180
And then we just start
getting the information.

00:07:14.290 --> 00:07:18.570
Very straightforward key
value sort of coding.

00:07:18.570 --> 00:07:19.900
And you've probably seen this if
you've gone to other Cocoa sessions,

00:07:19.900 --> 00:07:19.900
like Core Data or Bindings.

00:07:20.110 --> 00:07:23.620
You do value for property,
and these constants are defined

00:07:24.140 --> 00:07:27.400
in the Address Book headers as
well as in the documentation.

00:07:27.400 --> 00:07:32.220
So properties like first name,
last name are very straightforward.

00:07:34.790 --> 00:07:37.860
And then writing that information
is pretty much the same code.

00:07:37.870 --> 00:07:41.020
Instead of value for property,
you say set value for property

00:07:41.020 --> 00:07:43.320
using the same constants as before.

00:07:43.320 --> 00:07:44.580
Now, this is very important.

00:07:44.580 --> 00:07:47.550
When you're done writing
information in the address book,

00:07:47.630 --> 00:07:50.120
whatever information it is,
you need to remember to call

00:07:50.180 --> 00:07:53.680
save on the address book
instance that you got before.

00:07:53.680 --> 00:07:56.680
If you don't do this,
the data that you wrote is just going

00:07:56.780 --> 00:07:58.200
to disappear as soon as you quit.

00:07:58.380 --> 00:08:01.800
So at the time that you're setting,
when you set values on a person,

00:08:01.800 --> 00:08:03.730
you're just setting values
on something in memory.

00:08:03.990 --> 00:08:06.500
So the save is what commits it to disk.

00:08:07.590 --> 00:08:09.600
So first name and last name,
very straightforward.

00:08:09.620 --> 00:08:10.340
They're just strings.

00:08:10.390 --> 00:08:12.440
You go ahead and get the property,
you get a string.

00:08:12.520 --> 00:08:14.650
You pass in the property,
you get a string back.

00:08:14.720 --> 00:08:20.450
But there are a lot of other
pieces of information that can be

00:08:20.570 --> 00:08:26.570
redundant and have multiple values,
like phone numbers, or addresses,

00:08:26.570 --> 00:08:26.570
or email addresses.

00:08:26.570 --> 00:08:26.570
A lot of the things that we use for
communication have multiple values.

00:08:27.240 --> 00:08:29.400
So how's this data handled?

00:08:29.490 --> 00:08:33.030
It's handled with a special
data type called AB Multivalue.

00:08:34.100 --> 00:08:35.720
These are basically typed collections.

00:08:35.860 --> 00:08:39.000
You can think of it as a
dictionary if you want.

00:08:39.090 --> 00:08:40.600
But the keyword is typed.

00:08:40.750 --> 00:08:44.960
So we have string-based multivalues
for things like phone numbers,

00:08:45.080 --> 00:08:47.700
IM, handles, email addresses, etc.

00:08:48.100 --> 00:08:50.990
Multi-string is the
prominent type of multivalue.

00:08:51.050 --> 00:08:54.860
We've got multi-dictionaries
for things like addresses,

00:08:54.860 --> 00:08:57.880
because an address has
multiple lines to it.

00:08:57.880 --> 00:09:01.800
So each address is a dictionary,
and the address property is

00:09:01.800 --> 00:09:02.860
a multi-dictionary value.

00:09:03.270 --> 00:09:06.340
And of course, things like dates for
anniversaries or birthdays,

00:09:06.340 --> 00:09:09.400
although I'm pretty sure most
people only have one birthday.

00:09:12.210 --> 00:09:15.030
And every value inside that
multi-value has a label for

00:09:15.030 --> 00:09:17.540
things like work and home,
and you can see that

00:09:17.540 --> 00:09:18.920
up here on the screen.

00:09:19.030 --> 00:09:23.090
It's also got a unique identifier,
and this is handy for when

00:09:23.090 --> 00:09:27.300
you're doing fast enumeration
on the values that you get out,

00:09:27.300 --> 00:09:29.480
as well as for persistence.

00:09:29.500 --> 00:09:32.070
So if you want to save a
reference to a specific value,

00:09:32.070 --> 00:09:35.230
you go ahead and you iterate through,
and you've decided that you

00:09:35.230 --> 00:09:38.210
found the value you want,
you can save that identifier and just

00:09:38.280 --> 00:09:40.050
go pull it right back out next time.

00:09:40.050 --> 00:09:40.700
You don't have to iterate again.

00:09:41.900 --> 00:09:43.570
So how do you get at these multivalues?

00:09:43.650 --> 00:09:45.340
How do you know what
you're coding before?

00:09:45.340 --> 00:09:52.420
Because like I said,
you can have multi-string,

00:09:52.420 --> 00:09:52.420
multi-dictionary, multi-dates.

00:09:55.400 --> 00:09:56.740
So how do you negotiate this?

00:09:56.860 --> 00:09:58.850
Because there's only
one AB multivalue class.

00:09:58.860 --> 00:10:02.740
Well, basically,
you have to just look through the pieces,

00:10:02.740 --> 00:10:06.700
the information that we provide in
our documentation in SDK to find out

00:10:06.700 --> 00:10:08.020
what you're going to be working with.

00:10:08.130 --> 00:10:10.520
So first thing you do is look
up the property and the type,

00:10:10.640 --> 00:10:13.540
and you can do this in
the abglobals.h header.

00:10:13.540 --> 00:10:16.900
So in this case,
we're looking at the email property,

00:10:16.900 --> 00:10:19.010
which, like I said before,
is a multi-string.

00:10:19.020 --> 00:10:21.760
So the comments in the
headers will tell you that.

00:10:21.820 --> 00:10:24.650
You can also look in our documentation,
which is a little more

00:10:24.940 --> 00:10:25.660
friendly on the eyes.

00:10:25.720 --> 00:10:29.920
The AB person class reference has
a clean list of all the different

00:10:29.920 --> 00:10:33.930
properties that we provide by default
and what kind of multivalue they are,

00:10:34.020 --> 00:10:37.230
whether it be multi-string, multi-date,
multi-dictionary, etc.

00:10:37.250 --> 00:10:41.300
So the first thing you need to do is find
out what data you're going to get at,

00:10:41.680 --> 00:10:46.190
and that will then tell you what kind
of multivalue you're dealing with.

00:10:46.300 --> 00:10:49.640
Now, once you've done that,
it's time to write some code.

00:10:52.140 --> 00:10:54.880
Again, everything in AB Person is
just value for property,

00:10:54.980 --> 00:10:57.820
and what you get back changes
based on what the property is.

00:10:58.050 --> 00:11:00.480
So in this case,
we've got the email property,

00:11:00.550 --> 00:11:02.660
and it's going to be an AB Multi-Value.

00:11:02.960 --> 00:11:05.660
So I mentioned before those identifiers.

00:11:05.690 --> 00:11:08.830
I'm just going to iterate through
all of the values that I get

00:11:08.830 --> 00:11:10.590
back until I find the one I want.

00:11:10.590 --> 00:11:12.960
In this case,
I want somebody's work email.

00:11:13.080 --> 00:11:15.520
So I check the label,
and I check it against the

00:11:15.520 --> 00:11:17.040
constant for the work label.

00:11:17.140 --> 00:11:17.990
And there we go.

00:11:18.190 --> 00:11:20.840
I go ahead and store it,
and I break out of the loop,

00:11:20.850 --> 00:11:22.050
and I move on.

00:11:23.430 --> 00:11:25.240
So that's great,
and you've seen I'm using

00:11:25.240 --> 00:11:27.850
this nebulous unique ID here,
and where did that come from?

00:11:27.850 --> 00:11:29.030
So that's not really realistic.

00:11:29.120 --> 00:11:31.510
Most of the time,
when you're dealing with

00:11:31.510 --> 00:11:34.600
the Address Book framework,
you're going to have some

00:11:34.600 --> 00:11:37.280
piece of information,
like an email address,

00:11:37.440 --> 00:11:39.690
and a ton of contacts
in the Address Book.

00:11:39.690 --> 00:11:43.260
And how do you go ahead and find
that one person that corresponds

00:11:43.260 --> 00:11:45.070
to that piece of information?

00:11:45.100 --> 00:11:47.220
This is what searching is all about.

00:11:47.230 --> 00:11:49.910
And when you're working
with the Address Book,

00:11:49.910 --> 00:11:50.080
most of you are probably
going to be doing searches.

00:11:51.700 --> 00:11:55.310
So you do that using these
AB Search Element objects.

00:11:55.420 --> 00:11:57.360
And it's pretty straightforward.

00:11:57.380 --> 00:12:05.430
You just call this Search Element for
Property method on the property

00:12:05.430 --> 00:12:10.540
type that you're interested in,
so in this case, the KAB email property.

00:12:10.540 --> 00:12:10.540
So we're going to search for
somebody's email address.

00:12:26.030 --> 00:12:26.100
And you set the label and key,
usually you're going to set these to nil.

00:12:26.100 --> 00:12:26.100
Before, like I said, we have work, home,
mobile, labels.

00:12:26.100 --> 00:12:26.100
In this case, if you set those to nil,
it'll basically search all of

00:12:26.100 --> 00:12:26.100
the values in the property.

00:12:27.300 --> 00:12:29.270
And the key, of course,
is for multi-dictionary.

00:12:29.440 --> 00:12:31.510
So in the case of email,
email is just a multi-string.

00:12:31.510 --> 00:12:32.800
Key doesn't matter anyway.

00:12:32.840 --> 00:12:35.800
And then you specify the value
that you're searching for,

00:12:35.860 --> 00:12:39.430
and go ahead and look at abtypedefs.h,
and that will tell you these

00:12:39.430 --> 00:12:40.800
constants for all the comparisons.

00:12:40.800 --> 00:12:43.300
Here we've got ab=caseinsensitive.

00:12:43.410 --> 00:12:47.420
I believe we've got
prefix and case sensitive.

00:12:47.800 --> 00:12:51.310
You know, the standard matches,
standard compare types that you

00:12:51.460 --> 00:12:53.750
would expect in a search like this.

00:12:53.970 --> 00:12:55.530
So that's searching.

00:12:55.610 --> 00:12:57.770
The ability to pluck out
exactly what you're looking for.

00:12:57.780 --> 00:13:01.380
But there's some additional
nuances to using search that

00:13:01.380 --> 00:13:03.140
you need to be aware of.

00:13:03.150 --> 00:13:05.570
And there's a huge
performance win here as well,

00:13:05.690 --> 00:13:07.900
obviously because you
don't have to loop through.

00:13:07.940 --> 00:13:09.730
So in the brute force sense,
you don't need to do it,

00:13:09.730 --> 00:13:12.700
but there's a lot going on here
that you should know about.

00:13:12.740 --> 00:13:16.780
So this is the brute force approach.

00:13:16.780 --> 00:13:19.660
I wanted to get all the emails
and all the phone numbers

00:13:19.660 --> 00:13:23.020
and all the aim properties,
all the aim names out of

00:13:23.020 --> 00:13:25.060
everybody the address book.

00:13:25.320 --> 00:13:29.000
So if I was going to do this
in a very straightforward way,

00:13:29.080 --> 00:13:32.490
I would just get all the
people in the Address Book,

00:13:32.890 --> 00:13:36.720
which is hitting the disk
initially to get all the records.

00:13:36.720 --> 00:13:42.580
Then I go ahead and I ask each
person for -- go through each person,

00:13:42.930 --> 00:13:47.320
ask them for the email property,
the phone number,

00:13:47.420 --> 00:13:49.960
as well as their instant message ID.

00:13:49.960 --> 00:13:49.960
And you notice that we
got a list of people,

00:13:49.960 --> 00:13:49.960
but

00:13:51.710 --> 00:13:56.830
Hi, I'm Matt Drance,
and I'm the founder of

00:13:56.830 --> 00:13:59.740
the Leopard platform.

00:13:59.740 --> 00:14:05.990
I'm a member of the Leopard team,
and I'm going to talk

00:14:05.990 --> 00:14:09.600
about the Leopard platform.

00:14:09.600 --> 00:14:10.230
I'm going to talk about
the Leopard platform,

00:14:10.230 --> 00:14:10.230
and I'm going to talk
about how to use it.

00:14:10.720 --> 00:14:14.100
This is a serious scalability problem
if you're dealing with a large address

00:14:14.230 --> 00:14:18.050
book or a networked address book
that has some latency tied to it.

00:14:18.460 --> 00:14:22.000
So search is a really good
way to get around this.

00:14:22.160 --> 00:14:25.220
So rather than iterating through
and just pulling the properties out,

00:14:25.220 --> 00:14:28.460
we're going to construct a compound
search element to go pull this data.

00:14:28.690 --> 00:14:31.200
So I'm going to do one
for the email property,

00:14:31.280 --> 00:14:32.990
one for the phone property.

00:14:33.830 --> 00:14:35.440
And for the instant message property.

00:14:35.440 --> 00:14:39.370
And you notice what we're doing here,
we're doing a not equal to nil.

00:14:39.610 --> 00:14:42.870
Basically,
anybody who's got an email address

00:14:42.870 --> 00:14:45.990
or a phone number or an AIM name,
give those back to me.

00:14:46.120 --> 00:14:49.500
Now, this is not just a search where
we're going to get those people back,

00:14:49.520 --> 00:14:53.010
because the Address Book framework
uses these search elements as a hint.

00:14:53.230 --> 00:14:57.430
So the framework now knows that
this is the data you're looking for.

00:14:57.430 --> 00:15:01.220
So we're going to go ahead and
preload all of that stuff when we

00:15:01.220 --> 00:15:01.250
return the matching records to you.

00:15:02.500 --> 00:15:05.300
And there's one last step,
which is to actually combine-- right

00:15:05.300 --> 00:15:08.760
now we have three search elements,
and we need to combine them into one.

00:15:08.880 --> 00:15:14.370
So we put them in an array,
and we create a conjunction

00:15:14.490 --> 00:15:20.880
between those search elements
with a type of KAB search and.

00:15:20.880 --> 00:15:21.720
And we also have search or.

00:15:21.720 --> 00:15:21.720
So you can construct some
pretty complicated search

00:15:21.720 --> 00:15:21.720
elements if you need to.

00:15:24.360 --> 00:15:26.300
So now what happens?

00:15:26.300 --> 00:15:29.320
Now instead of getting a list of
all the people in the Address Book,

00:15:29.610 --> 00:15:32.300
regardless of who they are and
what they have in their records,

00:15:32.330 --> 00:15:37.480
we pass-- we call records matching
search element with that search

00:15:37.870 --> 00:15:40.340
element we just constructed.

00:15:40.350 --> 00:15:46.050
And this is the one time that the
framework is going to hit the disk now,

00:15:46.050 --> 00:15:46.690
because it's got all the information,
all the requests it needs.

00:15:46.690 --> 00:15:46.690
And then when we-- excuse me.

00:15:48.850 --> 00:15:50.840
I was expecting another
disk icon to show up,

00:15:50.980 --> 00:15:52.080
but that's the whole point.

00:15:52.150 --> 00:15:54.230
There's no step two.

00:15:54.860 --> 00:15:57.660
When the search element returns,
we've already got all

00:15:57.660 --> 00:15:59.110
the data pre-populated.

00:15:59.120 --> 00:16:01.820
So when we go ahead and we
start looping through them,

00:16:01.820 --> 00:16:02.970
there's no more I/O.

00:16:03.070 --> 00:16:04.230
We've got everything we need in memory.

00:16:04.240 --> 00:16:12.580
So this is significantly faster,
especially when you start to scale out,

00:16:12.580 --> 00:16:14.630
like I said before.

00:16:14.630 --> 00:16:14.630
So that's search.

00:16:14.630 --> 00:16:14.630
Search is something you're going
to want to get to know very well.

00:16:15.940 --> 00:16:20.740
I kept using the word
"personalization" in the introduction.

00:16:20.740 --> 00:16:23.270
So to that end,
the address book framework, of course,

00:16:23.380 --> 00:16:24.230
has image data.

00:16:24.310 --> 00:16:28.230
You've got pictures of the people
of the friends and family that the

00:16:28.230 --> 00:16:30.270
person has in their address book.

00:16:30.350 --> 00:16:33.540
And you can get at this using the
framework using one of two methods.

00:16:33.620 --> 00:16:37.930
The first one is AB Person image data,
which gives you an NSData reference

00:16:37.990 --> 00:16:41.500
representing the bitmap image for
that person in the address book.

00:16:41.720 --> 00:16:43.900
Now, this is a blocking call.

00:16:43.900 --> 00:16:48.320
So we also have an asynchronous method,
begin loading image data for client,

00:16:48.550 --> 00:16:51.980
that you specify a callback for
when the image data is done.

00:16:51.980 --> 00:16:54.590
And this is probably the way
you want to go because if you're

00:16:54.670 --> 00:16:58.040
dealing with a long list of people,
you don't want to block the event thread.

00:16:58.040 --> 00:17:01.050
You want to just have that stuff,
wait until it's ready, particularly if,

00:17:01.050 --> 00:17:04.150
like I said, if you have a long list,
and if you're dealing with something

00:17:04.410 --> 00:17:06.710
like a networked address book,
which you probably don't

00:17:06.710 --> 00:17:07.780
know as the developer.

00:17:07.780 --> 00:17:10.490
The user probably knows that they've
got a networked address book,

00:17:10.490 --> 00:17:13.860
but by then it's too late because
you've already written the application.

00:17:13.860 --> 00:17:15.670
So use the asynchronous method.

00:17:15.780 --> 00:17:18.560
It's not that much -- it's
not more complicated at all.

00:17:18.560 --> 00:17:19.900
And you notice this is an NSData.

00:17:20.000 --> 00:17:23.100
It's not an NSImage,
but we have a constructor for NSImage

00:17:23.100 --> 00:17:26.020
that takes NSData as an argument,
so very straightforward.

00:17:26.120 --> 00:17:28.210
It's just one extra line of code.

00:17:28.710 --> 00:17:31.490
And of course,
not every person has a picture-- not

00:17:31.490 --> 00:17:35.610
everybody has a picture for every
single person in their Address Book.

00:17:35.740 --> 00:17:38.300
So just to add a little
bit more customization,

00:17:38.300 --> 00:17:41.940
a little more personalization,
you can go ahead and fall back to

00:17:41.940 --> 00:17:46.490
something like the default NSUserImage
that we provide to you as part of Cocoa.

00:17:46.490 --> 00:17:48.750
So go ahead and try
to get the person out,

00:17:48.750 --> 00:17:51.560
search for them by name,
and get the image data.

00:17:51.640 --> 00:17:54.780
If it's nil, just go ahead and throw
that NSUserImage up.

00:17:54.780 --> 00:17:58.600
And let's show you what
that looks like right now.

00:18:09.490 --> 00:18:13.460
So to make this interesting,
I did not write this application.

00:18:13.460 --> 00:18:17.710
This is actually a Core Data example,
that you can find in

00:18:17.730 --> 00:18:19.080
Developer Examples Core Data.

00:18:19.080 --> 00:18:21.720
It was written for Tiger,
when Core Data was introduced.

00:18:21.760 --> 00:18:24.840
And luckily, it has context and
calendar information in it.

00:18:24.910 --> 00:18:27.770
So what we're going to do today is we're
just going to wire this application up

00:18:27.770 --> 00:18:31.240
to the Address Book and iCal Frameworks,
which I think is more interesting,

00:18:31.330 --> 00:18:32.740
anyway,
because there might be people in the

00:18:32.880 --> 00:18:36.630
crowd who have already written something
and are just looking at Address Book and

00:18:36.730 --> 00:18:37.850
Calendar Stores and Afterthought.

00:18:38.040 --> 00:18:39.920
So I'm going to show you that
it's pretty easy to do this,

00:18:39.920 --> 00:18:41.810
even if you didn't think of it initially.

00:18:41.830 --> 00:18:43.830
Let's go over here to People.

00:18:46.390 --> 00:18:51.610
And, you know, I don't think I need to
demo this too extensively.

00:18:52.720 --> 00:18:54.360
You create a list of
people in this application.

00:18:54.360 --> 00:18:58.100
They're saved out in the document using
Core Data and NS Persistent Document.

00:18:58.150 --> 00:19:00.100
But this is not very personal.

00:19:00.100 --> 00:19:01.890
It's pretty bland, actually.

00:19:02.130 --> 00:19:06.100
But it's meant to be a technology
demonstration for Core Data.

00:19:06.100 --> 00:19:09.100
Let's turn it into something
a little more personal.

00:19:09.100 --> 00:19:11.100
So this is the new Event Manager.

00:19:11.100 --> 00:19:14.100
That looks the same, of course.

00:19:14.100 --> 00:19:16.220
But you'll see that I've
added this image column,

00:19:16.230 --> 00:19:19.090
and I did that in Interface
Builder beforehand.

00:19:20.420 --> 00:19:21.890
And like I said,
if you have somebody that

00:19:22.000 --> 00:19:23.860
doesn't match the Address Book,
you should use that

00:19:23.860 --> 00:19:24.830
default NS user image.

00:19:25.000 --> 00:19:27.000
So we start there with that.

00:19:27.070 --> 00:19:32.710
And let me bring up
Address Book real quick,

00:19:32.710 --> 00:19:32.710
just so you can believe me.

00:19:33.520 --> 00:19:37.400
There's John,
our good friend John Appleseed.

00:19:37.540 --> 00:19:40.780
Let's change the name
here and see what happens.

00:19:41.030 --> 00:19:45.250
So I've written the name,
and now I've got a picture of John.

00:19:45.500 --> 00:19:51.310
So maybe if I know 10
people named John Appleseed,

00:19:51.310 --> 00:19:51.310
I can make sure which one it is.

00:19:51.360 --> 00:19:54.100
But this immediately adds some
additional flavor to the application.

00:19:54.100 --> 00:19:56.040
It's not just a gray and
white window anymore.

00:19:56.040 --> 00:19:59.860
Now we've got people,
personal information here.

00:19:59.910 --> 00:20:00.740
How did we do that?

00:20:00.740 --> 00:20:06.330
It's pretty straightforward.

00:20:06.330 --> 00:20:06.330
First, as you saw,

00:20:08.200 --> 00:20:13.260
Let me open up the nib here.

00:20:13.260 --> 00:20:15.300
As you saw,
I added a column to the table.

00:20:15.330 --> 00:20:19.810
I'm not going to walk through this
because we do have a lot to cover.

00:20:24.400 --> 00:20:27.300
I think I've opened the wrong project.

00:20:27.410 --> 00:20:30.280
So let's just go right over to the code.

00:20:39.300 --> 00:20:45.980
So Core Data has pretty much a
codeless data persistence system.

00:20:45.980 --> 00:20:48.100
The idea here is that you don't
have to write a lot of code.

00:20:48.100 --> 00:20:51.380
And you'll see here-- you can tell here
by the names of the files that a lot of

00:20:51.380 --> 00:20:52.770
this stuff is things that I've added.

00:20:52.780 --> 00:20:54.940
And we'll get to the calendar
store additions later.

00:20:54.970 --> 00:21:00.370
But what I've done is I've created this
special subclass of NSManageObject.

00:21:00.460 --> 00:21:02.750
And I don't want to have to
teach you guys Core Data,

00:21:02.870 --> 00:21:03.020
too.

00:21:03.020 --> 00:21:06.460
I want to stick to two frameworks,
not three.

00:21:06.490 --> 00:21:10.780
But what I've basically done here is I'm
paying attention to whenever the first

00:21:10.780 --> 00:21:13.540
or last name changes in the application.

00:21:13.560 --> 00:21:17.280
And when that happens,
I go ahead and I produce a search

00:21:17.800 --> 00:21:20.090
element for the first and last name.

00:21:22.950 --> 00:21:29.820
Hi, I'm Matt Drance,
and I'm here to talk about

00:21:29.820 --> 00:21:34.850
the CASE-insensitive search.

00:21:34.850 --> 00:21:34.850
I'm a CASE-insensitive searcher,
and I'm going to talk about

00:21:34.850 --> 00:21:34.850
the CASE-insensitive search.

00:21:35.120 --> 00:21:38.520
And I populate a list of Address
Book matches based on the name that

00:21:38.520 --> 00:21:41.200
currently exists in the person.

00:21:41.850 --> 00:21:46.790
And then this method, Image,
is what the image column in

00:21:46.800 --> 00:21:49.610
the interface is bound to.

00:21:49.730 --> 00:21:51.290
So you notice there's no GUI code here.

00:21:51.300 --> 00:21:58.500
This is just data code,
and that's because I'm using

00:21:58.500 --> 00:21:58.500
Cocoa bindings on the other
side to just pluck the image

00:21:58.500 --> 00:21:58.500
right out from the interface.

00:21:59.080 --> 00:22:02.600
So those people who are new or
not familiar with Cocoa bindings,

00:22:02.600 --> 00:22:04.300
we'll make this sample available.

00:22:04.300 --> 00:22:05.310
You can see how it works.

00:22:05.390 --> 00:22:07.960
But we've got some great
tutorial on bindings.

00:22:07.980 --> 00:22:09.220
And this is it.

00:22:09.240 --> 00:22:12.700
And you notice I construct
an image from the data.

00:22:12.770 --> 00:22:15.680
So you see here I'm getting
the image data from the person.

00:22:15.680 --> 00:22:19.020
And then I call NSImageInItWithData.

00:22:19.040 --> 00:22:22.430
And if the image does not exist,
I go ahead and I return

00:22:22.430 --> 00:22:24.660
that NSImageNamedNsUser.

00:22:24.660 --> 00:22:27.800
This is literally the code pretty
much right out of the slides.

00:22:27.850 --> 00:22:29.100
So this is really straightforward.

00:22:29.100 --> 00:22:32.760
This code is the entirety of what we
had to write to hook that stuff up.

00:22:32.760 --> 00:22:35.650
There wasn't a whole lot of property
listening or playing around that

00:22:35.660 --> 00:22:37.140
we had to do to get into that code.

00:22:37.140 --> 00:22:38.980
And again,
this was written three years ago.

00:22:38.980 --> 00:22:39.840
I just pulled this out.

00:22:39.840 --> 00:22:41.380
Actually, I did this this morning.

00:22:41.380 --> 00:22:43.380
You might choose to believe me or not.

00:22:43.700 --> 00:22:45.850
Two weeks, I think,
has been the popular amount

00:22:45.850 --> 00:22:47.090
of time for demos this week.

00:22:47.240 --> 00:22:49.570
But actually,
this took me about two hours,

00:22:49.670 --> 00:22:51.600
including the calendar part of it.

00:22:51.660 --> 00:22:52.860
So very straightforward.

00:22:52.900 --> 00:22:54.490
Couple of minutes of work,
a couple of lines of code,

00:22:54.490 --> 00:22:57.400
and we've immediately
added faces to names.

00:22:57.450 --> 00:22:59.860
Can we go back to the slides, please?

00:23:15.300 --> 00:23:18.720
So you notice that that was
a document-based application.

00:23:18.720 --> 00:23:21.840
I didn't save the document out,
but this begs the question of

00:23:21.910 --> 00:23:25.400
if I'm going to link myself
to the Address Book framework,

00:23:25.460 --> 00:23:29.140
and I have documents that are
moving around the file system,

00:23:29.140 --> 00:23:33.050
and maybe they're moving between
machines where there may or may

00:23:33.050 --> 00:23:34.930
not be the same Address Book.

00:23:34.930 --> 00:23:36.440
It may not be consistent.

00:23:36.600 --> 00:23:38.150
How do I negotiate that?

00:23:38.310 --> 00:23:40.790
How do I make sure that the user
experience is not completely broken

00:23:40.790 --> 00:23:40.790
with this document when it moves around?

00:23:42.640 --> 00:23:45.190
So I've got some pretty
straightforward advice for you.

00:23:45.320 --> 00:23:52.290
First of all,
you want to save the unique ID you get.

00:23:52.290 --> 00:23:55.780
When you find a person,
get that unique ID and save that,

00:23:55.780 --> 00:23:55.780
because that's just a string.

00:23:55.780 --> 00:23:55.780
It's a really lightweight way
of hooking back to that person.

00:23:57.080 --> 00:24:00.300
But you also want to save the data
that's really critical and important

00:24:00.300 --> 00:24:02.150
to providing that info to the user.

00:24:02.270 --> 00:24:07.860
So maybe it's just first and last name,
like in the case of this.

00:24:08.160 --> 00:24:11.710
Maybe it's also email,
or maybe it's a phone number.

00:24:11.770 --> 00:24:13.960
But just little pieces of data.

00:24:14.040 --> 00:24:18.190
You don't need to save everything out,
like the image or other

00:24:18.250 --> 00:24:21.950
pieces of information,
like their 10 addresses and their

00:24:21.950 --> 00:24:21.950
birthday and the name of their
best friend from high school.

00:24:24.190 --> 00:24:25.350
And then go ahead and fetch the rest.

00:24:25.550 --> 00:24:28.380
Whatever else, whatever additional
flavor you want to add,

00:24:28.380 --> 00:24:30.950
such as the picture,
you can go ahead and pull that back

00:24:30.950 --> 00:24:32.800
when the document's loaded again.

00:24:33.160 --> 00:24:40.270
Now, if the ID is invalid,
maybe the user deleted the

00:24:40.380 --> 00:24:47.370
person from the Address Book,
or maybe they moved the document

00:24:47.370 --> 00:24:47.370
from one machine to another where the
ID may be different due to syncing

00:24:47.370 --> 00:24:47.370
or other inconsistent changes.

00:24:48.840 --> 00:24:50.490
Obviously,
you construct a search element,

00:24:50.490 --> 00:24:55.550
and you would fall back to
that data that you saved.

00:24:55.700 --> 00:24:59.800
So the stuff that's important to you,
both for displaying it on the screen,

00:24:59.800 --> 00:24:59.800
as well as

00:24:59.900 --> 00:25:14.400
[Transcript missing]

00:25:17.040 --> 00:25:23.460
And there's one other thing that we want
to talk about with the Address Book data,

00:25:23.460 --> 00:25:23.460
and that's notifications.

00:25:23.690 --> 00:25:26.230
Because this is a framework,
any other number of running apps

00:25:26.320 --> 00:25:36.230
can go ahead and be modifying this
database while you're a client of it.

00:25:36.230 --> 00:25:37.480
And the Address Book application
itself could be one of them.

00:25:37.480 --> 00:25:37.480
So you want to register for
notifications to these changes.

00:25:39.120 --> 00:25:43.820
So we have notifications that
include lists of updated contacts,

00:25:43.910 --> 00:25:46.630
contacts that were added,
new contacts that were added,

00:25:46.630 --> 00:25:48.940
as well as contacts that were
removed from the database.

00:25:48.940 --> 00:25:52.740
And this follows the standard
Cocoa pattern of notifications.

00:25:52.840 --> 00:25:54.880
So you just use the standard
notification center,

00:25:54.880 --> 00:25:58.310
and you go ahead and register
for external changes using the

00:25:58.440 --> 00:26:00.460
constants that we provided.

00:26:00.460 --> 00:26:04.500
But make sure you understand this is
not the distributed notification center,

00:26:04.500 --> 00:26:06.940
for those of you new to
Cocoa or not new to Cocoa.

00:26:07.440 --> 00:26:12.580
The distributed notification center
is what you traditionally use to get

00:26:12.890 --> 00:26:14.980
notifications from outside your process.

00:26:15.000 --> 00:26:16.720
But in this case,
because it's really coming from a

00:26:16.720 --> 00:26:19.430
framework that you've linked against,
you always use the regular

00:26:19.430 --> 00:26:21.720
notification center,
regardless of where the

00:26:21.730 --> 00:26:23.060
change actually came from.

00:26:25.680 --> 00:26:27.650
So that's it for data access,
and I mentioned before that

00:26:27.720 --> 00:26:30.220
there's a reusable UI that
we provide to you as well,

00:26:30.520 --> 00:26:34.580
and this is called the People Picker,
the AB People Picker View Class.

00:26:34.580 --> 00:26:37.490
And this basically gives you an
address book view that looks very

00:26:37.600 --> 00:26:40.800
similar to the application as well
as the other applications that

00:26:40.800 --> 00:26:47.010
you've seen like iChat and Mail,
just to name a few.

00:26:47.350 --> 00:26:51.190
And it has a free search field,
it has access to all of the groups that

00:26:51.300 --> 00:26:54.990
you see normally in the address book,
and it also gives you the

00:26:54.990 --> 00:26:59.380
ability to specify which
properties you want to be visible.

00:27:02.610 --> 00:27:05.920
So this view is actually
accessible from Interface Builder.

00:27:06.140 --> 00:27:08.000
You don't have to write a lot
of code to make this work.

00:27:08.100 --> 00:27:11.510
You can drag it right out of
IB and right into your window.

00:27:12.510 --> 00:27:14.860
It's also fully
configurable from within IB.

00:27:14.860 --> 00:27:17.510
So I mentioned before,
you can choose to just show

00:27:17.510 --> 00:27:20.030
a number of properties,
like the phone number and the email.

00:27:20.040 --> 00:27:24.100
Otherwise, you'll have a huge list of
all the properties that are

00:27:24.100 --> 00:27:25.330
available in the address book.

00:27:25.340 --> 00:27:29.940
And things like allowing multiple
selection and what the default

00:27:30.960 --> 00:27:32.690
displayed property would be.

00:27:32.930 --> 00:27:37.170
All of it's configurable from within
Interface Builder or from inside code.

00:27:37.200 --> 00:27:42.710
And you can also set up a callback for
when the user double-clicks on a value.

00:27:42.720 --> 00:27:45.520
So you go ahead and, obviously,
this is a people picker.

00:27:45.520 --> 00:27:47.080
You want to know when the
person picked something.

00:27:47.080 --> 00:27:49.320
So you register a callback
to get that information,

00:27:49.320 --> 00:27:50.180
and you're done.

00:27:53.400 --> 00:27:54.980
So that's it for the Address Book.

00:27:55.030 --> 00:27:58.670
Again, the Address Book is
really the way you want
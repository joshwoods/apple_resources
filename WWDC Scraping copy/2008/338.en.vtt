WEBVTT

00:00:20.970 --> 00:00:21.590
Welcome.

00:00:21.830 --> 00:00:22.890
I'm Chris Peak.

00:00:23.180 --> 00:00:24.540
And I'm Shantonu Sen.

00:00:24.610 --> 00:00:27.010
And this afternoon we're going to
be talking about the architecture

00:00:27.600 --> 00:00:33.890
of and the Keck's transition
to the Mac OS X 64-bit kernel.

00:00:44.600 --> 00:00:52.730
So you might have heard that this
disk contains a new exciting addition,

00:00:52.750 --> 00:00:57.420
a 64-bit kernel, which we call K64.

00:00:57.420 --> 00:00:58.920
And what's more, it's all here.

00:00:58.920 --> 00:01:02.610
You don't have to send
away for a 64-bit addition.

00:01:08.060 --> 00:01:12.140
But I have to remind you, of course,
that the Leopard kernel and

00:01:12.140 --> 00:01:17.400
indeed the default kernel for
Snow Leopard is still 32-bit.

00:01:18.290 --> 00:01:21.440
Which may be confusing to some
because we keep on saying that

00:01:21.910 --> 00:01:26.510
Mac OS X is 64-bit from top to bottom.

00:01:26.630 --> 00:01:29.380
And that's certainly true
for the application stack,

00:01:29.380 --> 00:01:32.960
but the kernel has its own stack,
as you know.

00:01:32.970 --> 00:01:35.170
And it's still 32-bit.

00:01:36.250 --> 00:01:40.360
OS X is unique amongst mainstream
operating systems in providing 64-bit

00:01:40.450 --> 00:01:46.690
application support but retaining
a 32-bit kernel and 32-bit drivers.

00:01:48.790 --> 00:01:51.260
So if that's all wonderful, why K64?

00:01:51.260 --> 00:01:52.850
Why 64-bit now?

00:01:53.040 --> 00:01:56.120
I'll be trying to explain
that this afternoon.

00:01:56.700 --> 00:01:59.160
But perhaps the most pressing
question that you might have is,

00:01:59.250 --> 00:02:01.780
how does this affect me?

00:02:01.850 --> 00:02:04.780
Well, I've got very good news if
you develop applications.

00:02:04.850 --> 00:02:08.180
There is nothing to worry about.

00:02:08.230 --> 00:02:10.060
K64 is application transparent.

00:02:10.180 --> 00:02:14.810
Applications neither know nor
care that they're running on K64.

00:02:15.520 --> 00:02:19.740
Applications, be they 32-bit or 64-bit,
they run the same binary.

00:02:19.810 --> 00:02:22.310
They link against the same libraries.

00:02:22.520 --> 00:02:24.200
Nothing has changed.

00:02:24.220 --> 00:02:25.330
In fact, it's even better than that.

00:02:25.580 --> 00:02:29.240
They may actually run faster,
particularly if they're 32-bit.

00:02:29.870 --> 00:02:35.050
If, however, you develop KEXTs,
you must be aware that

00:02:35.160 --> 00:02:38.880
K64 requires 64-bit KEXTs.

00:02:40.400 --> 00:02:45.100
That is, if you have a KEXT,
you have to port it to 64-bit.

00:02:45.230 --> 00:02:49.940
However, we at Apple have got a number
of KEXTs that we develop,

00:02:50.050 --> 00:02:52.580
and we found that

00:02:53.450 --> 00:02:59.200
It's not as difficult as you might
immediately think to port to 64-bit.

00:02:59.220 --> 00:03:02.830
And this afternoon,
we hope to give you some insights and

00:03:02.830 --> 00:03:07.380
show you some tools and techniques
so that the transition for your kecks

00:03:07.450 --> 00:03:10.480
can be as easy as it has been for us.

00:03:11.700 --> 00:03:14.810
So what are you going
to learn this afternoon?

00:03:15.150 --> 00:03:20.020
Well, I'll point out the differences
between the 32-bit kernel,

00:03:20.020 --> 00:03:25.020
which we call K32 these days, and K64,
the 64-bit kernel.

00:03:25.240 --> 00:03:28.420
And we'll see how these two
kernels coexist and how they're

00:03:28.840 --> 00:03:31.180
integrated into OS X in general.

00:03:31.680 --> 00:03:35.560
Shantonu will show you
how to boot into K64.

00:03:35.560 --> 00:03:39.150
There's some sorcery involved here,
so pay attention.

00:03:39.810 --> 00:03:44.820
And Shantonu will go through the
whole development process to show

00:03:44.820 --> 00:03:48.210
you how to port your KEXTs to 64-bit.

00:03:48.540 --> 00:03:54.610
He'll go over some best coding practices
which will allow you to prepare your KEXT

00:03:54.820 --> 00:03:58.420
For the transition,
he will show you how to compile and link

00:03:58.420 --> 00:04:02.180
and show you which checkboxes to use.

00:04:03.170 --> 00:04:06.700
He'll show you how to load
and run and test and debug all

00:04:06.700 --> 00:04:11.270
the familiar stuff because,
say again, you have to port your kecks

00:04:11.320 --> 00:04:15.700
to 64-bit to run on K64.

00:04:17.450 --> 00:04:19.540
So why K64?

00:04:19.640 --> 00:04:26.340
Well, what I want to do to provide some
context for this is to look back through

00:04:26.350 --> 00:04:30.310
Time Machine over the last few years,
the development,

00:04:30.310 --> 00:04:35.790
and see what machines have been released
and to look at the development of the

00:04:35.790 --> 00:04:41.480
kernel over that time so that you can
see the direction that we're headed in.

00:04:43.040 --> 00:04:50.190
So let's go back first to WWDC three
years ago and the Intel transition.

00:04:50.700 --> 00:04:55.680
We released the developer transition kit,
which was a machine that outwardly

00:04:55.680 --> 00:05:05.340
was disguised as a G5 Mac,
but inside it has a 3.6 gigahertz

00:05:05.460 --> 00:05:09.920
Pentium 4 Intel processor,
the Prescott microarchitecture.

00:05:10.590 --> 00:05:17.730
It supported a gigabyte of RAM,
and although it was 64-bit capable,

00:05:17.730 --> 00:05:17.730
ironically,

00:05:17.870 --> 00:05:21.100
We only ran it in 32-bit mode,
and obviously its intention was

00:05:21.210 --> 00:05:29.320
for you to port your applications
and your KEXTs from PPC to i386,

00:05:29.320 --> 00:05:35.590
which is the identification for the
32-bit Intel architecture that we use.

00:05:36.520 --> 00:05:40.900
So let's look internally at
the virtual memory layout.

00:05:40.970 --> 00:05:44.650
With a 32-bit machine, as you're aware,
you've got

00:05:45.350 --> 00:05:48.100
Four gigabytes to play with.

00:05:48.130 --> 00:05:57.740
And in the initial developer release,
we adopted a 3-1 shared address split.

00:05:58.580 --> 00:06:05.920
3 gigabytes for the user and just
2 gigs for kernel and kex combined.

00:06:06.690 --> 00:06:10.680
And being one shared space,
it is convenient.

00:06:10.680 --> 00:06:12.700
It uses one set of page tables.

00:06:12.800 --> 00:06:20.740
And the transition from kernel to user,
user to kernel, is relatively fast.

00:06:22.200 --> 00:06:25.770
If you're familiar with Linux,
this is the default 32-bit configuration

00:06:25.800 --> 00:06:29.640
for most Linux distributions,
probably all.

00:06:29.730 --> 00:06:32.460
If you're familiar with Windows,
of course, it's not the default

00:06:32.460 --> 00:06:33.720
Windows configuration.

00:06:33.750 --> 00:06:37.020
Windows has a 2:2 split,
although you may be aware of a

00:06:37.020 --> 00:06:42.510
slightly obscure 3GB boot option which
allows you to get this configuration.

00:06:43.600 --> 00:06:49.800
[Transcript missing]

00:06:50.410 --> 00:06:53.540
The first Intel machines were released.

00:06:53.590 --> 00:06:57.530
At first, the iMac and MacBook Pro.

00:06:57.950 --> 00:07:03.820
and later the Mini and other machines.

00:07:03.910 --> 00:07:09.010
Initially, this was powered by a
2 gigahertz core duo,

00:07:09.010 --> 00:07:11.380
Yonah microarchitecture.

00:07:11.440 --> 00:07:16.710
It supported 2 gigabytes of
RAM and was only 32 bits.

00:07:17.780 --> 00:07:20.980
Now at this time,
we took the opportunity to align the

00:07:20.980 --> 00:07:25.860
memory layout to be consistent with PPC.

00:07:25.930 --> 00:07:28.770
And we adopted a 4:4 split.

00:07:30.300 --> 00:07:34.120
separate address spaces
for kernel and user,

00:07:34.120 --> 00:07:40.340
which has the advantage that they
each have four gigabytes to play with.

00:07:40.400 --> 00:07:44.880
But there's a slight penalty in
transitioning between user and

00:07:45.330 --> 00:07:47.830
kernel on interrupt or system call.

00:07:50.050 --> 00:07:56.880
There is, in fact,
a shared high area which is the

00:07:56.880 --> 00:07:59.540
portal between these spaces.

00:07:59.580 --> 00:08:01.370
It performs a kind of a high wire act.

00:08:01.470 --> 00:08:08.990
It's a delicate process
to switch address spaces.

00:08:08.990 --> 00:08:09.000
Up there are

00:08:09.140 --> 00:08:13.490
positioned the trap handlers,
the interrupt and exception routines,

00:08:13.530 --> 00:08:15.080
the trampolines.

00:08:15.090 --> 00:08:20.040
And they're responsible for
switching between user and kernel,

00:08:20.040 --> 00:08:24.260
or back again, like that.

00:08:27.630 --> 00:08:33.440
Okay, moving ahead, WWDC two years ago,
the Mac Pro was released.

00:08:33.440 --> 00:08:41.120
A fine 3 GHz Core 2 Duo,
the Marone microarchitecture.

00:08:41.240 --> 00:08:44.360
This machine supported 16 gigs.

00:08:45.690 --> 00:08:51.940
and had 64 bits,
which we identify as X86-64.

00:08:52.020 --> 00:08:54.970
There are other acronyms
available from Intel,

00:08:54.970 --> 00:08:57.110
which we use occasionally.

00:08:57.220 --> 00:09:01.040
We don't, however,
use the contraction X64.

00:09:01.140 --> 00:09:06.450
Neither do we use AMD64,
and certainly not IA64, of course,

00:09:06.470 --> 00:09:08.570
which is Itanium.

00:09:09.820 --> 00:09:15.980
So this provided an extra long
mode to give you the 64-bit.

00:09:15.980 --> 00:09:20.890
I prefer to think of it as
width rather than length.

00:09:21.170 --> 00:09:24.130
You've got double the number
of general purpose registers,

00:09:24.210 --> 00:09:27.300
double the number of XMM registers.

00:09:27.750 --> 00:09:31.290
Some new instructions,
all sorts of goodies,

00:09:31.290 --> 00:09:34.250
some subtle and some not.

00:09:34.380 --> 00:09:37.600
But really, the key thing here,
especially for those of you

00:09:37.870 --> 00:09:41.650
programming in a high-level
language in C or C++ in the kernel,

00:09:41.770 --> 00:09:45.100
the important thing is the 64 bits.

00:09:45.210 --> 00:09:47.790
You don't see the extra registers.

00:09:47.870 --> 00:09:51.830
It's the LP64,
the longs and pointers being 64,

00:09:51.830 --> 00:09:54.400
which is how it manifests itself.

00:09:54.510 --> 00:09:58.830
Now,
in addition to the 64-bit capability,

00:09:59.480 --> 00:10:03.490
This architecture has a
32-bit compatibility mode,

00:10:03.490 --> 00:10:08.200
which is a sub-mode of 64-bit,
which allows you to run 32-bit

00:10:08.480 --> 00:10:12.130
code at full native speed,
although you only have the

00:10:12.140 --> 00:10:15.400
eight registers and 32 bits,
and you can only run in the

00:10:15.400 --> 00:10:18.790
bottom four gigs of memory,
of virtual memory.

00:10:22.030 --> 00:10:29.000
But the all-important factor here
is the 64-bit memory management.

00:10:29.740 --> 00:10:36.570
Take a bit of a deep dive into
what the 64-bit space gives us.

00:10:37.150 --> 00:10:40.120
Now, as programmers,
we tend to have our own mental

00:10:40.120 --> 00:10:44.980
models of how address spaces work,
and sometimes we draw diagrams,

00:10:44.980 --> 00:10:48.680
but they're rarely to scale,
as I've already demonstrated.

00:10:49.340 --> 00:10:53.890
So let's just take this dull gray box,
this 32-bit address space,

00:10:53.900 --> 00:10:59.690
and let's imagine it as a linear space,
a single dimension,

00:10:59.690 --> 00:11:03.620
with 2 to the 32 points in it.

00:11:03.700 --> 00:11:09.420
And let's stretch this
from the sun to the earth.

00:11:10.550 --> 00:11:11.260
Which is a long way.

00:11:11.260 --> 00:11:15.330
It's one astronomical unit, technically.

00:11:15.470 --> 00:11:18.840
But 2 to the 32 is also a big number.

00:11:18.910 --> 00:11:25.300
So it turns out that points in this
space are separated by roughly 100 feet.

00:11:25.370 --> 00:11:27.390
Just over 100 feet.

00:11:27.650 --> 00:11:30.960
Or if you will,
a bit every about 10 feet.

00:11:31.080 --> 00:11:34.940
So you can kind of visualize that,
a bit every 10 feet from

00:11:35.170 --> 00:11:38.570
the sun to the earth.

00:11:41.300 --> 00:11:43.360
So how does this change
when we go to 64-bit?

00:11:43.580 --> 00:11:46.720
Well, of course,
that gets expanded to 2 to

00:11:46.720 --> 00:11:49.600
the 32 astronomical units.

00:11:49.710 --> 00:11:51.750
So how far is that?

00:11:52.120 --> 00:11:53.790
Outside the solar system?

00:11:53.840 --> 00:11:55.300
Easily.

00:11:55.460 --> 00:11:57.630
To the nearest star?

00:11:58.270 --> 00:12:00.250
Yup, easy too.

00:12:00.550 --> 00:12:01.470
Give you a clue.

00:12:01.580 --> 00:12:08.560
2 to the 16 astronomical units
is 65,000 astronomical units.

00:12:08.630 --> 00:12:10.810
That's one light year, almost exactly.

00:12:10.820 --> 00:12:12.720
It's quite surprising.

00:12:14.250 --> 00:12:20.340
So, 2 to the 32 astronomical
units is 65,000 light years.

00:12:20.340 --> 00:12:24.540
And coincidentally,
65,000 light years is the

00:12:24.840 --> 00:12:27.790
radius of the Milky Way galaxy.

00:12:31.770 --> 00:12:37.940
So, the 64-bit address space may
not be the final frontier.

00:12:37.940 --> 00:12:40.700
It may not be cosmic in scale.

00:12:40.700 --> 00:12:42.700
It may not even be universal, dare I say.

00:12:42.700 --> 00:12:46.090
But it's certainly galactic.

00:12:47.300 --> 00:12:51.880
So let's bring you back to
Earth and talk about how the chip

00:12:51.960 --> 00:12:54.200
designers have implemented 64-bits.

00:12:54.200 --> 00:12:59.190
In its first implementation,
we don't get to play with

00:12:59.190 --> 00:13:01.200
the full galactic space.

00:13:01.200 --> 00:13:06.450
We're left with only 48 bits of
virtual space and less than that,

00:13:06.470 --> 00:13:08.570
40 bits of physical space.

00:13:09.630 --> 00:13:14.130
So let's look at how the
machine translates the virtual

00:13:14.130 --> 00:13:16.530
address to a physical address.

00:13:16.680 --> 00:13:18.710
This tends to make
people's eyes glaze over,

00:13:18.710 --> 00:13:21.710
but I'll go briefly through this.

00:13:22.990 --> 00:13:29.660
Hardware Register CR3 points
physically to the base page table.

00:13:29.690 --> 00:13:37.020
The top nine bits of our 48-bit usable
virtual address space selects one of 512

00:13:37.070 --> 00:13:42.540
entries in the first level page table,
which provides the physical

00:13:42.720 --> 00:13:46.780
address of the next level,
and so on down through the page tables.

00:13:46.780 --> 00:13:51.180
And finally,
we add the 12-bit page offset to

00:13:51.180 --> 00:13:55.090
find the physical 40-bit address.

00:13:55.410 --> 00:13:57.310
Okay,
I've left out lots of details there.

00:13:57.500 --> 00:13:59.700
The things to remember,
there's just two things.

00:13:59.700 --> 00:14:03.640
Firstly, note there's four levels
of page tables here,

00:14:03.800 --> 00:14:07.780
which is one more than the
three-level page table that we used

00:14:07.780 --> 00:14:11.280
for 32-bit address translation.

00:14:11.280 --> 00:14:13.920
And the second thing to note

00:14:14.360 --> 00:14:20.020
is these top 16 bits play
no part of that translation.

00:14:20.710 --> 00:14:25.640
But they're subject to a rule
that the hardware enforces.

00:14:25.660 --> 00:14:28.120
All those bits must be identical,
must be the same,

00:14:28.120 --> 00:14:31.510
and they must be equal to the 47th bit.

00:14:32.370 --> 00:14:35.260
You can't just have
any old pattern there.

00:14:35.280 --> 00:14:39.390
In fact, if you do,
the machine will throw an exception.

00:14:39.800 --> 00:14:43.280
The result is, rather curiously,
that you get this hole,

00:14:43.280 --> 00:14:47.090
this region of invalid addresses,
or non-canonical addresses

00:14:47.110 --> 00:14:49.200
as they're called,
right in the middle

00:14:49.200 --> 00:14:51.280
of your address space.

00:14:51.720 --> 00:14:53.700
Now, of course,
it's actually bigger than that.

00:14:53.790 --> 00:14:55.350
It's 2 to the 16 times.

00:14:55.360 --> 00:14:59.400
It's 65,000 times the
size of the valid space.

00:14:59.520 --> 00:15:01.960
So the picture is more like that.

00:15:03.500 --> 00:15:06.910
So you're rather curiously left
with these islands of valid space,

00:15:06.940 --> 00:15:10.680
128 terabytes each,
one at the bottom and one at

00:15:11.000 --> 00:15:13.310
the top of the address space.

00:15:13.980 --> 00:15:21.380
So our galactic scale has been
reduced to two half light years.

00:15:23.200 --> 00:15:26.940
So bearing this in mind,
the kernel that we

00:15:26.940 --> 00:15:35.890
implemented at Tiger 10.4.7,
which we called the

00:15:35.890 --> 00:15:35.890
compatibility mode kernel,

00:15:36.590 --> 00:15:40.480
was a 32-bit kernel again, 32-bit KEXTs.

00:15:40.520 --> 00:15:46.610
If you boot them on a 32-bit machine,
like the original iMac and MacBook Pro,

00:15:48.020 --> 00:15:49.660
We'd use the same 4/4 split.

00:15:49.660 --> 00:15:53.490
Everything would proceed as before.

00:15:53.650 --> 00:15:59.480
But if you boot on a
machine with 64-bit capable,

00:15:59.650 --> 00:16:02.550
then we enable 64-bit mode.

00:16:03.790 --> 00:16:06.200
And at that point,
we enter compatibility mode.

00:16:06.230 --> 00:16:11.120
We're running 32 bits in the
bottom 4 gigs of address space.

00:16:12.020 --> 00:16:18.780
We install the four level page
tables and 64-bit memory management.

00:16:18.930 --> 00:16:25.020
And then we map the entire kernel,
double map it, up into the top region,

00:16:25.160 --> 00:16:30.130
based at 512 gigabytes down from the top.

00:16:31.980 --> 00:16:37.230
And we install new interrupt
and exception handlers,

00:16:37.360 --> 00:16:42.070
64-bit code, up in that region.

00:16:43.210 --> 00:16:46.900
So what happens when an interrupt
or an exception occurs is if we

00:16:46.900 --> 00:16:50.820
happen to be in 32-bit user space,
the machine automatically

00:16:50.820 --> 00:16:52.660
switches to 64-bits.

00:16:52.740 --> 00:17:00.280
And we vector into the small amount of
64-bit code up there in the top space.

00:17:00.360 --> 00:17:04.660
That switches address space,
much like we did with the 4/4 split.

00:17:05.810 --> 00:17:10.540
jumps down into the lower portion of
memory and back to compatibility mode.

00:17:10.660 --> 00:17:14.380
So at that point,
the kernel is running 32-bit code.

00:17:14.500 --> 00:17:16.380
Kecks are running 32 bits.

00:17:16.490 --> 00:17:21.890
They know nothing about the 64-bit
machine that they're running on.

00:17:25.110 --> 00:17:29.360
And at WWDC '06,
we also added support for 64-bit users.

00:17:29.460 --> 00:17:31.140
That was the point.

00:17:32.290 --> 00:17:39.060
The way this works is at exact time,
if the kernel spots a 64-bit slice,

00:17:39.060 --> 00:17:45.700
an x86-64 architecture
as part of the Mac OS,

00:17:45.700 --> 00:17:45.700
then

00:17:46.100 --> 00:17:50.340
A 64-bit address space up
to 128 terabytes is created,

00:17:50.410 --> 00:17:54.410
and 64-bit lib system is mapped there.

00:17:55.200 --> 00:18:00.790
And the entire space is loaded
by default at 4 gigabytes.

00:18:01.550 --> 00:18:04.880
And below that,
there's a 4-gigabyte page zero,

00:18:04.880 --> 00:18:07.550
which has two interesting properties.

00:18:07.680 --> 00:18:11.980
Number one,
it allows us to trap truncated pointers.

00:18:12.090 --> 00:18:14.740
So if you've got a 64-bit pointer,
which you've somehow derived

00:18:14.740 --> 00:18:20.250
from a 32-bit quantity,
you'll have chopped off the top 32 bits,

00:18:20.260 --> 00:18:23.020
and you get left with a pointer
into this bottom region,

00:18:23.020 --> 00:18:24.590
and that traps.

00:18:24.710 --> 00:18:27.400
So that's useful for
application development.

00:18:27.530 --> 00:18:34.620
But we also have the ability to have
the kernel mapped into that portion,

00:18:34.760 --> 00:18:38.640
so that once again,
the kernel and 64-bit users

00:18:38.940 --> 00:18:42.150
are shared in a shared space.

00:18:42.280 --> 00:18:46.130
And that means faster kernel
transitions to and from.

00:18:48.400 --> 00:18:55.470
But we retain 32-bit KEXTs,
which do now need to be aware that

00:18:55.560 --> 00:19:01.290
their clients may be 64-bit entities,
as indeed the kernel has to.

00:19:03.020 --> 00:19:07.060
OK, winding forward to last
October and subsequently,

00:19:07.220 --> 00:19:10.700
Leopard provides all platform support.

00:19:11.020 --> 00:19:17.420
At the top end, we're now up to a 3.2
gigahertz Core 2 Duo pen/rim.

00:19:18.120 --> 00:19:23.310
The top of the line
Mac Pro supports 32 gigs.

00:19:24.120 --> 00:19:30.200
And Leopardy is a universal install,
PPC and i386.

00:19:31.400 --> 00:19:39.480
But still, there's a 32-bit Intel kernel
support for 32-bit KECSTs.

00:19:40.160 --> 00:19:44.660
And through the method I've described,
we support either 32-bit original

00:19:44.660 --> 00:19:47.790
machines or 64-bit newer machines.

00:19:47.920 --> 00:19:51.680
In user space,
there's now 64-bit libraries

00:19:51.680 --> 00:19:53.480
for all frameworks.

00:19:53.590 --> 00:19:57.950
So nothing really changed
architecturally for Leopard.

00:20:00.610 --> 00:20:01.540
So why 64-bit?

00:20:01.540 --> 00:20:04.500
So you might have seen what's been
changing the most over this time.

00:20:04.500 --> 00:20:08.240
It's the amount of memory.

00:20:08.900 --> 00:20:14.170
We've gone from 1 gig to 32 gigs
in the space of three years.

00:20:15.320 --> 00:20:22.140
Physical RAM has been increasing,
but the kernel's 32-bit

00:20:22.370 --> 00:20:26.780
virtual address space,
it's 4 gigabytes, hasn't been increasing.

00:20:26.780 --> 00:20:29.690
It's running out, running out fast.

00:20:31.260 --> 00:20:37.590
To give you an example,
we need in the kernel 64 bytes or more to

00:20:37.620 --> 00:20:42.010
describe each 4K page of physical memory.

00:20:43.410 --> 00:20:50.300
So on a 64-gigabyte system,
we'd need one gigabyte or more-- that's

00:20:50.300 --> 00:20:54.640
a quarter of the available space-- just
to describe the memory in the system.

00:20:54.670 --> 00:20:57.310
That's let alone do anything with it.

00:20:57.560 --> 00:21:01.490
Before we have a process or
a file or any networking,

00:21:01.490 --> 00:21:04.430
anything, and of course frame buffers,
yeah.

00:21:06.450 --> 00:21:09.480
So there's no two ways about it.

00:21:09.550 --> 00:21:12.630
The kernel requires a
64-bit address space.

00:21:13.390 --> 00:21:20.080
And that will provide space for
faster and more advanced devices.

00:21:21.560 --> 00:21:25.860
Graphics, as we know,
has got a prodigious appetite for memory.

00:21:25.860 --> 00:21:30.970
Storage and networking as it gets faster.

00:21:31.630 --> 00:21:36.700
And this, of course,
will mean performance scaling also.

00:21:36.700 --> 00:21:40.880
And this trend for memory to go on
increasing is likely to accelerate

00:21:40.880 --> 00:21:46.060
because Intel's next generation platform,
the Nehalem architecture,

00:21:46.060 --> 00:21:49.310
advertises scalable memory.

00:21:49.590 --> 00:21:53.800
Each processor has its own
integrated memory controller.

00:21:54.400 --> 00:21:57.000
with multi-channel capability.

00:21:57.060 --> 00:22:00.950
And processors are interconnected
by a high bandwidth,

00:22:01.060 --> 00:22:04.430
point-to-point, quick path interconnect.

00:22:04.550 --> 00:22:07.800
So memory scales with processors.

00:22:10.190 --> 00:22:17.280
So, this week, the Snow Leopard preview
includes an extra slice,

00:22:17.380 --> 00:22:19.500
a 64-bit,

00:22:19.930 --> 00:22:29.140
The booter selects which slice.

00:22:30.020 --> 00:22:33.380
It defaults to 32 bits,
but it can be requested

00:22:33.600 --> 00:22:36.600
to boot the 64-bit slice.

00:22:38.840 --> 00:22:42.830
Once booted,
the KEXT management code will select

00:22:43.430 --> 00:22:47.010
KEXTs which have a matching slice.

00:22:47.360 --> 00:22:53.370
So only 64-bit KEXTs will load and run.

00:22:53.780 --> 00:22:58.500
There's user space transparency,
so the entire application

00:22:58.500 --> 00:23:00.990
suite is unchanged.

00:23:01.720 --> 00:23:04.930
And you need to bear in mind,
K64 is not a new kernel.

00:23:04.940 --> 00:23:07.100
It's a port of the existing kernel.

00:23:07.100 --> 00:23:09.440
It's built from the same source.

00:23:09.440 --> 00:23:13.560
It's bug-compatible with K32.

00:23:16.110 --> 00:23:20.010
We've ported most foundation kegs,
that is the basic kegs,

00:23:20.130 --> 00:23:22.940
the disk drivers and families.

00:23:24.380 --> 00:23:30.950
And the preview allows you
to boot between K32 and K64.

00:23:32.760 --> 00:23:38.610
So looking at the memory,
the memory layout is--

00:23:39.220 --> 00:23:40.880
A little different.

00:23:40.960 --> 00:23:44.400
We've used the LP64
model inside the kernel,

00:23:44.400 --> 00:23:45.960
of course.

00:23:46.070 --> 00:23:51.460
It's got 128 terabytes of virtual
address space available to it.

00:23:51.720 --> 00:23:54.750
And we're back to a shared address space.

00:23:55.560 --> 00:23:57.820
And that means, again,
faster transitions to

00:23:57.840 --> 00:24:00.400
and from the kernel.

00:24:00.490 --> 00:24:04.670
And there's no mode switching in and out
of compatibility mode inside the kernel,

00:24:04.670 --> 00:24:07.400
only at kernel user boundary.

00:24:08.530 --> 00:24:11.400
The syscall interface
is completely unchanged.

00:24:11.590 --> 00:24:17.100
Applications neither know nor care
what kernel they're running on.

00:24:17.790 --> 00:24:22.630
Inside the kernel,
the KPIs have been minimally changed,

00:24:22.630 --> 00:24:27.690
weasel words, but we've introduced 64-bit
types only when necessary.

00:24:27.910 --> 00:24:33.030
There's actually,
because of our 64-bit work on Tiger,

00:24:33.390 --> 00:24:38.490
most I/O Kit KPIs are
already 64-bit clean.

00:24:39.810 --> 00:24:44.900
We've taken the opportunity to
remove deprecated interfaces,

00:24:45.100 --> 00:24:49.290
but only 64-bit KEXTs.

00:24:51.090 --> 00:24:53.160
So now I'm going to hand over to
Shantonu who's going to give you

00:24:53.160 --> 00:24:58.990
the practical details of developing
your kecks for the new kernel.

00:25:05.120 --> 00:25:06.340
Thank you, Chris.

00:25:06.350 --> 00:25:10.630
Let's talk about how you
actually port your kecks to K64.

00:25:11.230 --> 00:25:13.480
As Chris mentioned,
for most users and most

00:25:13.480 --> 00:25:18.140
application developers,
K64 is completely transparent.

00:25:18.350 --> 00:25:23.020
However, some of your products do rely
on KEXT for proper operation,

00:25:23.180 --> 00:25:26.740
such as network adapters, file systems,
mass storage devices,

00:25:27.050 --> 00:25:28.640
and other peripherals.

00:25:28.780 --> 00:25:31.990
It's essential that you port
your KEXT to K64 so that the

00:25:31.990 --> 00:25:36.630
transition is as transparent
as possible for your customers.

00:25:38.750 --> 00:25:42.300
Your text is probably already
building universal for Leopard,

00:25:42.420 --> 00:25:45.340
both 32-bit PowerPC and Intel.

00:25:45.360 --> 00:25:50.790
At a fundamental level, for Snow Leopard,
we're talking about moving to 32 64-bit

00:25:50.850 --> 00:25:54.180
universal to support the K64 kernel.

00:25:54.210 --> 00:25:58.090
We'll talk about some of these
build settings in just a moment.

00:25:58.780 --> 00:26:02.610
The K64 development cycle can be
broken down into a few phases:

00:26:02.740 --> 00:26:06.980
preparing, building, booting, debugging,
and validating.

00:26:07.060 --> 00:26:09.790
You can iterate on this
process as you make changes,

00:26:09.790 --> 00:26:13.380
and if you have additional kecks,
you can start at preparing again.

00:26:13.430 --> 00:26:16.200
We'll also wrap up with a few
notes on some of the porting

00:26:16.200 --> 00:26:21.290
issues you may run into and best
practices for your K64 port.

00:26:22.860 --> 00:26:26.490
You can start today
preparing your K64 port.

00:26:26.860 --> 00:26:29.560
First of all,
start with the Snow Leopard preview.

00:26:29.620 --> 00:26:32.000
It has all of the developer
tools you need to start

00:26:32.000 --> 00:26:35.620
building your text for 32-bit,
definitely.

00:26:35.670 --> 00:26:40.100
You'll notice that GCC 4.2 is
the default system compiler.

00:26:40.160 --> 00:26:44.770
It is stricter about certain C++ syntax,
which may require some source change.

00:26:44.860 --> 00:26:49.800
It's also much better at flagging
potential 64-bit incompatibilities.

00:26:49.990 --> 00:26:53.980
This is also a great opportunity to
replace calls to deprecated APIs or

00:26:54.060 --> 00:27:00.710
classes because those APIs and classes
are most likely not available for K64.

00:27:02.110 --> 00:27:04.840
You should also take the time
to enable and resolve as many

00:27:04.840 --> 00:27:07.310
compiler warnings as you can.

00:27:07.480 --> 00:27:11.240
WL will add the most number
of warnings and flag the most

00:27:11.240 --> 00:27:13.860
number of potential issues.

00:27:14.080 --> 00:27:19.460
We found that W-shorten-64-to-32 catches
many types of pointer truncation issues,

00:27:19.540 --> 00:27:23.850
such as assigning a 64-bit
pointer to a 32-bit variable.

00:27:24.520 --> 00:27:28.530
If you don't have prototypes in scope,
you may run into a different kind of

00:27:28.530 --> 00:27:33.400
truncation because the compiler will
truncate to an int type by default.

00:27:33.400 --> 00:27:38.400
W implicit function declaration
will warn you of this.

00:27:38.400 --> 00:27:42.610
Finally, adding W format is important to
make sure your logging code is

00:27:42.610 --> 00:27:46.470
logging what you expect it to,
which can be important

00:27:46.470 --> 00:27:48.390
for resolving bugs.

00:27:48.880 --> 00:27:52.320
This is also a good opportunity to
add 64-bit user space support to

00:27:52.320 --> 00:27:55.300
your existing 32-bit KEXT on Leopard.

00:27:55.300 --> 00:27:57.390
As Chris mentioned, in Leopard,
most of the framework

00:27:57.460 --> 00:28:00.880
stack is 64-bit capable,
and you may already need

00:28:00.880 --> 00:28:02.980
to handle 64-bit clients.

00:28:03.000 --> 00:28:07.200
We found that this is a great step in
making your KEXT 64-bit safe because

00:28:07.200 --> 00:28:12.440
many of the code locations that require
changes for 64-bit user space support are

00:28:12.440 --> 00:28:17.340
the same places where you need to make
changes for your 64-bit kernel extension.

00:28:18.550 --> 00:28:22.050
Xcode does take care of passing
off the appropriate compiler flags,

00:28:22.050 --> 00:28:24.400
but if you do have a
very specialized product,

00:28:24.410 --> 00:28:31.040
make sure you're using fAppleText
for C++ code and -mkernel for C code.

00:28:33.150 --> 00:28:35.380
So what do you do to build
your kernel extension?

00:28:35.380 --> 00:28:38.850
Well, there's a few settings
which are fundamental.

00:28:39.060 --> 00:28:43.400
Of course, you'll be adding x86-64 to
your architectures list.

00:28:43.460 --> 00:28:47.400
Xcode has a shorthand for this
called 32-64-bit Universal,

00:28:47.480 --> 00:28:50.710
which will add x86-64 for you.

00:28:51.180 --> 00:28:58.070
Your base SDK must be pointing to either
the current Mac OS or to the 10.6 SDK.

00:28:58.570 --> 00:29:03.000
If you have a complex project where some
targets must build 64-bit and others not,

00:29:03.060 --> 00:29:06.160
you may be taking advantage of
the valid architecture setting.

00:29:06.460 --> 00:29:12.060
In this case, go ahead and add x86-64
to your kex targets.

00:29:12.300 --> 00:29:17.300
Finally, GCC 4.2 is required for K64.

00:29:17.310 --> 00:29:21.050
If you do need to support multiple
OS revisions and multiple architectures,

00:29:21.110 --> 00:29:25.260
you can do that with Xcode and
per-architecture build settings.

00:29:25.260 --> 00:29:29.240
This is discussed in more detail in the
session Maximizing Platform Compatibility

00:29:29.240 --> 00:29:32.000
of I/O Kit Drivers on Friday.

00:29:32.050 --> 00:29:36.260
For now, we'll be talking just
about K64 and Snow Leopard.

00:29:37.110 --> 00:29:40.390
Outside of your build settings inspector,
make sure to update your

00:29:40.390 --> 00:29:44.880
Info.plist to only use
com.apple.kpi-style dependencies.

00:29:45.070 --> 00:29:47.400
These were introduced in Tiger and
should have everything you

00:29:47.400 --> 00:29:50.820
need to port your KEXT to K64.

00:29:51.590 --> 00:29:54.540
In the Snow Leopard preview,
most I/O Kit families and

00:29:54.540 --> 00:29:59.310
most kernel KPIs are K64 safe,
so most of you can start working

00:29:59.310 --> 00:30:01.260
on your ports immediately.

00:30:01.300 --> 00:30:05.940
The notable exceptions to this are
the Audio family and 802.11 family.

00:30:05.990 --> 00:30:08.370
However,
do note that this is a developer preview,

00:30:08.370 --> 00:30:11.360
and not all KPIs and
families are finalized,

00:30:11.450 --> 00:30:14.150
so there may be some changes required.

00:30:14.630 --> 00:30:18.590
How do you boot K64?

00:30:18.750 --> 00:30:23.600
Well, for the seed, K64 is supported on
two hardware platforms.

00:30:23.640 --> 00:30:27.770
There's the early 2008 MacBook Pro,
including both the 15-inch

00:30:27.770 --> 00:30:32.280
and 17-inch models,
and the early 2008 Mac Pro.

00:30:32.720 --> 00:30:36.290
These are the Penron-based
models of each.

00:30:39.080 --> 00:30:41.400
As Chris mentioned,
the booter is the actual piece

00:30:41.400 --> 00:30:45.800
of code that selects which slice
of the universal kernel to load.

00:30:45.850 --> 00:30:50.020
It can be instructed to
load the x86-64 slice.

00:30:50.150 --> 00:30:53.350
For the preview,
you can hold down 6 and 4 during boot,

00:30:53.350 --> 00:30:57.810
and that will instruct the
booter to load the x86-64 slice.

00:30:58.090 --> 00:31:02.930
If you'd like to make this persistent,
you can set NVRAM and add the

00:31:02.930 --> 00:31:06.250
arch equals x86-64 setting.

00:31:06.650 --> 00:31:09.140
When you're done with this,
you can unset it by holding down

00:31:09.140 --> 00:31:13.120
Command Option PR at boot to reset NVRAM.

00:31:13.790 --> 00:31:15.940
You can go ahead and do this if
you have one of the supported

00:31:16.010 --> 00:31:18.700
configurations using your install DVD.

00:31:18.740 --> 00:31:22.080
You can boot the install DVD to K64.

00:31:22.590 --> 00:31:25.560
How can you tell if you're
actually booted to K64?

00:31:25.610 --> 00:31:27.440
Well,
that's a question I'll leave to you.

00:31:27.490 --> 00:31:30.190
We do have a lab following
this session at 3:30.

00:31:30.430 --> 00:31:34.010
If you have creative answers to this,
come by, and you will have the

00:31:34.010 --> 00:31:36.220
opportunity to win a prize.

00:31:36.360 --> 00:31:39.770
So creativity is rewarded in this case.

00:31:41.060 --> 00:31:44.440
Now that you've built your KEXT for K64,
how do you start loading

00:31:44.440 --> 00:31:45.640
and debugging it?

00:31:45.690 --> 00:31:47.540
Well,
it turns out that it's mostly the same

00:31:47.540 --> 00:31:50.560
as your 32-bit KEXT development process.

00:31:50.610 --> 00:31:54.100
Most of the logging APIs are
available just like 32-bit,

00:31:54.110 --> 00:31:57.330
such as I/O log, printf,
and firewire kprintf,

00:31:57.450 --> 00:32:00.640
if you have a second machine
and a firewire cable.

00:32:01.360 --> 00:32:04.400
There's also interactive
GDB debugging using either the

00:32:04.400 --> 00:32:08.380
Ethernet or FireWire transports,
just like 32-bit.

00:32:08.420 --> 00:32:10.610
There's also the live
kernel debugger for use,

00:32:10.660 --> 00:32:13.740
which was introduced at last year's WWDC.

00:32:13.790 --> 00:32:16.960
This allows you to do read-only
introspection of your running kernel

00:32:17.050 --> 00:32:21.390
if you set the appropriate boot args,
which is KM equals 1.

00:32:22.490 --> 00:32:27.910
Do note that GDB defaults to
the x86-64 kernel when you

00:32:27.910 --> 00:32:31.930
invoke it with default options,
so you may need to pass -ai-386

00:32:31.980 --> 00:32:36.350
if you want to do standard
32-bit Intel kernel development.

00:32:37.450 --> 00:32:41.170
Another change in Snow Leopard is
that there's a new tool for doing

00:32:41.170 --> 00:32:44.180
.Sim file generation called kextutil.

00:32:44.220 --> 00:32:46.500
This will be taking over much
of the developer functionality

00:32:46.500 --> 00:32:48.440
of kextload from Leopard.

00:32:48.540 --> 00:32:52.010
For more information on this,
there's a session on Friday called

00:32:52.090 --> 00:32:55.070
Kernel Extension Management,
which discusses more of

00:32:55.070 --> 00:32:56.580
the changes in detail.

00:32:56.640 --> 00:33:01.200
You can do most of these today because
the kernel development kit has been

00:33:01.200 --> 00:33:03.960
posted for the Snow Leopard preview.

00:33:04.060 --> 00:33:06.900
It's available at connect.apple.com.

00:33:07.880 --> 00:33:11.800
Here's an example of what you might
see with the kernel debug kit.

00:33:12.110 --> 00:33:14.800
This is an example of
the live kernel debugger.

00:33:14.850 --> 00:33:20.450
You'll notice that the kernel was built
for the release configuration for x86-64,

00:33:20.450 --> 00:33:25.270
and also that all pointers have
been increased to their 64-bit size.

00:33:27.900 --> 00:33:30.790
So now that you've gotten some
basic operation out of your kecks,

00:33:30.890 --> 00:33:34.130
it's time to start
validating more code paths.

00:33:34.290 --> 00:33:38.760
For Snow Leopard, this is the test matrix
you'll need to validate.

00:33:38.780 --> 00:33:42.600
The kernel can be
either 32-bit or 64-bit.

00:33:42.610 --> 00:33:47.150
Data coming in from user space
can originate from either a 32-bit

00:33:47.290 --> 00:33:49.380
process or a 64-bit process.

00:33:49.420 --> 00:33:53.440
It can also come from a 32-bit
PowerPC process via Rosetta.

00:33:53.460 --> 00:33:58.130
The distinction there is that data
coming in may be Indian swapped.

00:33:58.600 --> 00:34:01.950
There's a few communication channels,
which are the primary mechanisms of

00:34:01.950 --> 00:34:06.300
getting data into your kernel extension.

00:34:06.700 --> 00:34:09.410
If you're an I/O Kit KEXT and
you use I/O User Client,

00:34:09.430 --> 00:34:13.360
you may be passing structures or
scalers in and out of the kernel.

00:34:13.470 --> 00:34:17.900
That's one of the areas where you
will need to validate your inputs.

00:34:18.000 --> 00:34:21.400
If you're more of a BSD-style
KEXT and you publish syscadls

00:34:21.470 --> 00:34:25.410
or a custom DevFS node,
you may also need to validate your

00:34:25.490 --> 00:34:29.370
structures that are coming in,
especially if you have iOctls

00:34:29.460 --> 00:34:34.180
or for file system developers,
you may support the fscuddle interface.

00:34:34.850 --> 00:34:38.220
Finally, if you're an I/O Kit KEXT and
you use I/O Registry for

00:34:38.220 --> 00:34:41.700
getting and setting properties,
there's good news for you.

00:34:41.740 --> 00:34:44.970
No work is required for you because
the I/O Kit user space framework

00:34:45.030 --> 00:34:50.180
and kernel side do correctly marshal
data in and out of the kernel.

00:34:52.040 --> 00:34:54.990
Let's talk about some of the porting
best practices for minimizing the

00:34:54.990 --> 00:34:58.280
amount of effort for your K64 port.

00:34:58.940 --> 00:35:01.000
There's quite a bit of existing
documentation available

00:35:01.000 --> 00:35:03.200
on developer.apple.com.

00:35:03.430 --> 00:35:07.400
Primarily, you'll be interested in the
64-bit transition guide,

00:35:07.640 --> 00:35:10.190
which was published a few years ago.

00:35:10.850 --> 00:35:13.260
When reading that document,
any time you see a reference

00:35:13.390 --> 00:35:17.700
to file format compatibility,
the issues that they're describing

00:35:17.800 --> 00:35:21.840
are basically the same as shared
user space kernel structures.

00:35:21.900 --> 00:35:26.030
Some of the best practices,
such as using XML as your file format,

00:35:26.030 --> 00:35:27.470
also apply to K64.

00:35:27.760 --> 00:35:31.190
For example,
you can use the built-in libkern

00:35:31.190 --> 00:35:35.080
XML parser to pass plists
in and out of the kernel.

00:35:35.290 --> 00:35:38.610
When reading that document,
anytime you see a reference to IPC,

00:35:38.610 --> 00:35:42.620
it's very analogous to user
space kernel communication.

00:35:43.270 --> 00:35:49.320
This is a good opportunity to define your
structures using fixed-width C99 types.

00:35:49.410 --> 00:35:54.540
For instance, in 16T instead of the
fundamental short type,

00:35:54.590 --> 00:35:57.960
UN32 instead of unsigned long, usually.

00:35:58.010 --> 00:36:01.410
This is actually a tricky case
because your existing text may be

00:36:01.410 --> 00:36:06.420
using unsigned long as a shorthand
for a 32-bit integer type.

00:36:06.490 --> 00:36:09.260
However, if it's using unsigned
long to store a pointer,

00:36:09.310 --> 00:36:12.880
you may instead want to
be using a UN64T type,

00:36:12.950 --> 00:36:18.010
which can hold pointers for
both 32-bit and 64-bit tasks.

00:36:18.330 --> 00:36:20.710
This is also a good opportunity
to reorder some of your

00:36:20.720 --> 00:36:23.830
structures to minimize implicit
changes by the compiler.

00:36:24.190 --> 00:36:27.790
We'll give an in-depth example
of this in just one second.

00:36:28.360 --> 00:36:30.520
Finally,
make sure you use fields that are wide

00:36:30.520 --> 00:36:33.260
enough to hold any type of pointer.

00:36:33.300 --> 00:36:36.980
There is the Mach type available
called mach_vm_address_t

00:36:37.030 --> 00:36:38.270
if you're an I/O Kit KEXT.

00:36:38.530 --> 00:36:43.460
You can also use the C99 type, uint64t.

00:36:44.340 --> 00:36:46.970
There's also the Universal Binary
Programming Guidelines,

00:36:46.990 --> 00:36:51.150
which has a few tips for general code
portability and specifically talks

00:36:51.150 --> 00:36:55.010
about issues such as ndns and alignment.

00:36:56.600 --> 00:36:59.230
Let's dive into one specific
porting issue which we've

00:36:59.270 --> 00:37:01.260
run into frequently at Apple.

00:37:01.340 --> 00:37:04.540
Let's start with this C structure
that's defined on the left.

00:37:04.620 --> 00:37:08.130
It's fairly straightforward how
the 32-bit compiler will translate

00:37:08.170 --> 00:37:10.060
this into a memory layout.

00:37:10.170 --> 00:37:12.940
All of the fields are laid
out contiguously in memory,

00:37:13.030 --> 00:37:16.910
and the sizes are what you'd
expect based on the C definition.

00:37:17.050 --> 00:37:21.330
What does this look like
for a 64-bit process?

00:37:21.420 --> 00:37:24.020
It's quite a bit more complicated.

00:37:24.100 --> 00:37:27.020
A tag starts out being the same.

00:37:27.190 --> 00:37:31.620
B pointer expands to an 8-byte field,
which is what you would expect since

00:37:31.620 --> 00:37:34.440
we're using an LP64 data model.

00:37:34.500 --> 00:37:37.940
However,
what's this pad field that's been added?

00:37:37.960 --> 00:37:41.320
It turns out that our system
ABI requires that 8-byte values

00:37:41.320 --> 00:37:45.480
are aligned on an 8-byte boundary,
which means that implicit padding

00:37:45.480 --> 00:37:48.720
must be added between the two fields.

00:37:48.780 --> 00:37:51.560
CLAN as much as you would expect.

00:37:51.590 --> 00:37:54.880
D flags remains an 8-byte field.

00:37:54.910 --> 00:37:57.180
E flags, too, is the same as before.

00:37:57.220 --> 00:37:59.010
But again,
padding has been added at the end

00:37:59.010 --> 00:38:03.900
of the structure so that the overall
structure is a multiple of 8 bytes.

00:38:03.920 --> 00:38:07.060
You can see that compared to
the C structure at the left,

00:38:07.080 --> 00:38:10.820
the 64-bit layout has
many unexpected things,

00:38:10.890 --> 00:38:14.520
such as implicit pad slots and
fields that have grown in width.

00:38:14.550 --> 00:38:19.190
Well, the fields growing,
you might expect, for a 64-bit.

00:38:19.660 --> 00:38:21.220
Can we improve on this?

00:38:21.270 --> 00:38:24.740
Certainly, because in the worst case,
your kernel extension,

00:38:24.760 --> 00:38:28.260
your 32-bit extension and
your 64-bit kernel extension,

00:38:28.290 --> 00:38:31.520
would need to interpret
either of these structures.

00:38:31.580 --> 00:38:36.750
So you may have to maintain up to four
code paths in your kernel extension.

00:38:37.460 --> 00:38:41.600
We're going to improve on this by
reordering some of our structure fields.

00:38:41.640 --> 00:38:44.370
In this example, A tag is as before.

00:38:44.470 --> 00:38:47.470
However, we've moved up C LAN so that
it occupies what would have

00:38:47.480 --> 00:38:50.190
been a pad slot otherwise.

00:38:50.870 --> 00:38:52.800
There's two new things about bpointer.

00:38:52.810 --> 00:38:57.480
It's unconditionally an 8-byte field so
that it can hold pointers from either

00:38:57.480 --> 00:39:01.280
a 32-bit user space process or 64-bit.

00:39:01.280 --> 00:39:06.520
And since CLend was moved up,
there's no implicit padding

00:39:06.650 --> 00:39:09.030
between a tag and bpointer.

00:39:09.170 --> 00:39:13.870
Dflags remains unchanged,
and we've expanded Eflags2 to take up

00:39:13.870 --> 00:39:18.260
64 bits so that there's no implicit
padding at the end of our structure.

00:39:18.540 --> 00:39:21.430
Although this may waste a few
bits that we might not be using,

00:39:21.750 --> 00:39:24.040
this drastically simplifies
the amount of code you need to

00:39:24.040 --> 00:39:26.260
maintain in your kernel extension.

00:39:26.440 --> 00:39:31.110
Now there's only one code path in your
kernel extension to support both K32,

00:39:31.170 --> 00:39:36.930
K64, and data coming in from 32-bit
or 64-bit user processes.

00:39:38.090 --> 00:39:42.290
Another issue which you may
run into has to do with types.

00:39:42.750 --> 00:39:50.280
The Uint32 type is an unsigned long
for K32 but an unsigned int for K64.

00:39:50.560 --> 00:39:56.360
This is done for binary
compatibility of C++ keks for K32.

00:39:56.390 --> 00:40:00.000
In both cases,
the type is a 32-bit integer,

00:40:00.050 --> 00:40:02.900
but the fundamental C type has changed.

00:40:02.940 --> 00:40:04.210
This has a few implications.

00:40:04.350 --> 00:40:08.860
For example,
when printing out variables of this type,

00:40:08.900 --> 00:40:12.240
it's not clear what
format specifier to use.

00:40:12.250 --> 00:40:14.830
Our best recommendation for
now is to stick to treating it

00:40:14.920 --> 00:40:20.160
as a lowercase uint32t type,
the C99 type, and cast appropriately,

00:40:20.160 --> 00:40:25.140
which will both print out the right
thing and cause no loss of precision.

00:40:25.170 --> 00:40:31.440
Most I/O Kit KPIs do use
the capital Uint32 type,

00:40:31.510 --> 00:40:34.210
so you will see this quite frequently.

00:40:34.420 --> 00:40:39.430
Also, be sure to match the types of
your superclasses methods when

00:40:39.430 --> 00:40:42.090
attempting to override them.

00:40:42.230 --> 00:40:46.300
For example, in this case, under K32,
it may have worked accidentally

00:40:46.300 --> 00:40:49.110
because a UN32 wasn't unsigned long.

00:40:49.280 --> 00:40:51.540
Under K64, it won't work.

00:40:51.720 --> 00:40:56.120
So make sure you revisit
what you are overriding.

00:40:56.970 --> 00:41:01.120
Another issue which causes the
most number of panics has to

00:41:01.120 --> 00:41:03.550
do with pointer truncation.

00:41:03.780 --> 00:41:08.810
Make sure that when you use APIs,
for instance, for mapping device memory,

00:41:08.810 --> 00:41:11.360
that you store the result
of getVirtualAddress in an

00:41:11.360 --> 00:41:13.820
appropriately sized variable.

00:41:13.870 --> 00:41:18.020
W short 64 to 32 is very
valuable to catch this type of

00:41:18.130 --> 00:41:20.460
thing and will flag this error.

00:41:21.180 --> 00:41:23.810
As Chris mentioned,
the kernel is linked at a high address

00:41:23.810 --> 00:41:26.460
starting with six Fs and eight zero.

00:41:26.610 --> 00:41:31.460
So anytime you see a pattern like that,
you know it's probably a kernel address.

00:41:32.040 --> 00:41:35.740
If you do get panic reports from
your customers where CR2 register,

00:41:35.810 --> 00:41:39.880
which is the faulting address,
looks like it's less than 4 gigabytes,

00:41:39.900 --> 00:41:42.800
it may be because of pointer truncation.

00:41:42.850 --> 00:41:45.320
However,
that's not always the case because also,

00:41:45.440 --> 00:41:48.720
as Chris mentioned,
we do use a shared virtual address space.

00:41:48.910 --> 00:41:52.080
So if you do have pointer truncation,
you may dereference memory,

00:41:52.080 --> 00:41:57.600
which is valid in a 32-bit user process,
which is mapped at the same time.

00:41:57.640 --> 00:42:03.200
You can turn off this optimization by
using the -no-shared-cr3 boot argument.

00:42:03.240 --> 00:42:08.440
This effectively gives you a 128-terabyte
page zero for your kernel extension,

00:42:08.480 --> 00:42:13.070
which will make sure you
find and get reports on any

00:42:13.070 --> 00:42:16.000
potential truncation issues.

00:42:16.030 --> 00:42:19.020
One thing to note is that the
kernel debug kit does ship with

00:42:19.020 --> 00:42:20.840
a debug configuration kernel.

00:42:20.890 --> 00:42:24.480
This defaults to having
the no-shared CR3 flag set.

00:42:24.690 --> 00:42:27.480
So that debug kernel is
obviously very helpful in

00:42:27.480 --> 00:42:30.290
debugging your kernel extension.

00:42:31.370 --> 00:42:34.920
Even though your device may only
support 32 bits of physical addressing,

00:42:34.940 --> 00:42:40.060
your kernel extension must support
a full 64-bit virtual address space.

00:42:41.170 --> 00:42:44.140
Finally,
another case of pointer truncation may

00:42:44.150 --> 00:42:48.900
be because of either implicit prototypes
which default to int in the compiler,

00:42:48.900 --> 00:42:54.600
or if you legitimately call
APIs that only take ints.

00:42:56.920 --> 00:43:03.200
How much effort can you
expect for your K64 port?

00:43:03.220 --> 00:43:05.120
Well, all projects are different,
so we can only give

00:43:05.170 --> 00:43:07.120
some rough guidelines.

00:43:07.180 --> 00:43:10.180
K64 does use the standard
I/O Kit architecture,

00:43:10.210 --> 00:43:15.800
same as K32, so your drivers will remain
essentially unchanged.

00:43:15.810 --> 00:43:17.480
You will be doing this
on stable hardware,

00:43:17.480 --> 00:43:21.840
and you can boot into K32 at
any time for regression testing.

00:43:21.870 --> 00:43:24.560
We've seen some keks
require minimal effort,

00:43:24.610 --> 00:43:28.320
such as cross-platform file systems,
which were already using fixed-width

00:43:28.670 --> 00:43:33.440
data types for on-disk data
structures and control messages.

00:43:33.440 --> 00:43:37.350
If you have an I/O Kit keks which
uses proper family abstractions or

00:43:37.350 --> 00:43:42.080
ones where you already added 64-bit
user space support for Leopard,

00:43:42.090 --> 00:43:45.480
we found that those usually
require the least amount of effort.

00:43:45.500 --> 00:43:49.480
Typically, the changes only are to
in-kernel data structures,

00:43:49.520 --> 00:43:53.880
for instance, those that reflect a
piece of device memory.

00:43:53.900 --> 00:43:58.680
In those cases, it may be as easy as just
pressing the checkbox.

00:43:59.090 --> 00:44:05.800
We've also seen some porting
take a larger amount of effort.

00:44:06.000 --> 00:44:09.500
For instance,
those that have complex iOctils,

00:44:09.670 --> 00:44:12.840
projects which have a large
number of existing warnings,

00:44:12.880 --> 00:44:16.000
because it's difficult to
tell what are the new warnings

00:44:16.020 --> 00:44:18.000
because of your K64 port.

00:44:18.500 --> 00:44:21.350
and KEX,
which must support multiple OS versions.

00:44:21.350 --> 00:44:24.080
Again,
there's a session on Friday dedicated

00:44:24.230 --> 00:44:27.400
to telling you the best way to do this.

00:44:30.210 --> 00:44:34.790
Let me describe the state of
K64 in the Snow Leopard preview.

00:44:34.910 --> 00:44:36.460
Quite a bit works.

00:44:36.540 --> 00:44:39.180
These sections I described
earlier on booting,

00:44:39.350 --> 00:44:44.110
developing, and debugging can all
be done on a K64 system.

00:44:44.340 --> 00:44:46.840
Standard user applications like Safari,
Mail,

00:44:46.840 --> 00:44:50.300
and Xcode do work properly under K64.

00:44:50.320 --> 00:44:55.000
You'll note that Mail and Xcode
do default to 64-bit user space,

00:44:55.080 --> 00:44:59.110
so that is a well-exercised code path,
and Safari can optionally

00:44:59.110 --> 00:45:01.560
be run as a 64-bit program.

00:45:01.590 --> 00:45:04.140
Most internal devices are supported.

00:45:04.180 --> 00:45:09.920
Most file systems are supported,
such as ZFS for the Mac OS X server.

00:45:10.410 --> 00:45:14.860
There's also some things that don't work,
such as there's no audio, as I mentioned,

00:45:14.860 --> 00:45:19.000
no wireless network,
and currently no accelerated graphics.

00:45:19.160 --> 00:45:22.430
There's no sleep or hibernation support,
so those code paths in your kernel

00:45:22.430 --> 00:45:25.500
extension cannot be currently exercised.

00:45:25.590 --> 00:45:28.520
And finally, there's no D-trace support,
so some of the developer

00:45:28.560 --> 00:45:30.980
tools for profiling,
such as instruments,

00:45:31.060 --> 00:45:35.290
and also some of the tools like Shark,
do not currently work.

00:45:35.380 --> 00:45:37.810
With that, I'll hand it back to Chris.

00:45:46.270 --> 00:45:51.020
So related sessions have all
been crowded together on Friday.

00:45:51.030 --> 00:45:56.380
There's the Getting Started with I/O Kit,
and for advanced users,

00:45:56.380 --> 00:46:01.300
the Maximizing Platform Compatibility,
which Shantonu has mentioned.

00:46:01.320 --> 00:46:06.480
And there will be some sample code,
including an x86-64 KEXT.

00:46:07.320 --> 00:46:11.440
And finally,
the new kernel extension framework

00:46:11.440 --> 00:46:15.770
will be explained in detail.

00:46:16.970 --> 00:46:21.720
And right after this
session at 3:30 downstairs,

00:46:21.790 --> 00:46:24.620
we are having a 64-bit kernel lab.

00:46:24.700 --> 00:46:28.780
So you can come down and try
out some ideas for the prize.

00:46:28.780 --> 00:46:33.150
So in summary.

00:46:34.610 --> 00:46:36.960
So RAM is ever increasing.

00:46:37.120 --> 00:46:41.340
And to cope with that,
we need a 64-bit kernel address space.

00:46:41.340 --> 00:46:45.950
And a 64-bit kernel means 64-bit KEXTs.

00:46:47.920 --> 00:46:52.450
The development process
is quite straightforward.

00:46:52.650 --> 00:46:58.380
As simple as just that checkbox, ideally,
honestly.

00:46:58.650 --> 00:47:01.490
And the development process
is completely unchanged.

00:47:02.560 --> 00:47:06.640
The KPIs have been minimally updated.

00:47:06.790 --> 00:47:11.800
There's some reference
documentation on the developer site.

00:47:12.850 --> 00:47:18.800
and come to the lab and test
drive K64 this afternoon.

00:47:18.830 --> 00:47:26.240
Or use your own current model
laptop with the Preview DVD.

00:47:26.240 --> 00:47:28.990
And start porting your kegs tomorrow.
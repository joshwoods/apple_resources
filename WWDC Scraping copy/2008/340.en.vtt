WEBVTT

00:00:20.720 --> 00:00:22.620
Good afternoon and welcome.

00:00:22.810 --> 00:00:25.400
I'm happy to see that all of you
could make it to this session on

00:00:25.400 --> 00:00:28.500
how to create secure applications
for iPhone and Mac OS X.

00:00:28.500 --> 00:00:32.840
My name is David Remahl and I'm a
software security engineer at Apple.

00:00:32.840 --> 00:00:35.830
So let's get started.

00:00:36.780 --> 00:00:40.930
I'll start by talking about
the context that we operate in,

00:00:41.100 --> 00:00:45.200
some of the motivation and
background for security work.

00:00:45.270 --> 00:00:48.460
And then I'll go on to talk
about the security mechanisms

00:00:48.500 --> 00:00:50.100
that exist on our platform.

00:00:50.160 --> 00:00:54.530
And for the second part of the talk,
Braden Thomas will give you some

00:00:54.700 --> 00:00:59.160
concrete coding tips that you
can apply to your applications.

00:01:00.350 --> 00:01:03.200
So let's look at the security landscape.

00:01:03.230 --> 00:01:06.950
Well, we have three separate groups
that I'll talk briefly about.

00:01:06.960 --> 00:01:11.660
We have the attackers,
the hackers that want our platform

00:01:12.150 --> 00:01:17.100
to be insecure and they develop
various attacks against it.

00:01:17.270 --> 00:01:24.160
One thing we've seen is that attacks,
web-based attacks where files get

00:01:24.160 --> 00:01:30.190
downloaded to a user's system and
cause the users to run malicious

00:01:30.190 --> 00:01:32.200
software have been on the increase.

00:01:32.200 --> 00:01:37.180
And this can happen even through trusted
websites like CNN or whatever website

00:01:37.180 --> 00:01:41.850
you're visiting through advertising that
happens to be malicious or compromised.

00:01:42.140 --> 00:01:48.140
We've also been seeing a continued focus
on fuzzing attacks and for those of

00:01:48.140 --> 00:01:54.090
you who didn't attend last year's talk,
fuzzing attacks are where legitimate

00:01:54.160 --> 00:02:00.020
file types are fed with malicious
software with corrupt data,

00:02:00.020 --> 00:02:03.960
purposefully corrupt data,
which will cause your

00:02:03.960 --> 00:02:06.760
application to misbehave.

00:02:06.790 --> 00:02:09.570
And this is a common method
for finding flaws in,

00:02:09.710 --> 00:02:12.180
for example, image codecs.

00:02:12.230 --> 00:02:18.460
And we've also seen attacks against local
networks and the domain name system.

00:02:18.460 --> 00:02:22.880
And we'll talk about some methods
for countering those attacks.

00:02:23.610 --> 00:02:29.600
So, now I want to talk some about what
Apple is doing to counter these issues.

00:02:29.600 --> 00:02:37.340
We've been working on adding protection
to the compiler and to the system that

00:02:37.350 --> 00:02:42.460
apply to all applications on the system,
thereby increasing the overall security.

00:02:43.520 --> 00:02:47.710
A technology we introduced in
Leopard is called Quarantine,

00:02:47.720 --> 00:02:52.200
which protects users against downloaded
files and warns them if they're

00:02:52.200 --> 00:02:55.820
about to execute something that
could have unexpected side effects,

00:02:55.820 --> 00:02:57.760
such as a Trojan horse.

00:02:57.760 --> 00:03:02.160
And we're also investing,
continuing to invest in security

00:03:02.160 --> 00:03:07.720
frameworks like Keychain and FileVault
and other user-level features.

00:03:07.720 --> 00:03:14.230
And finally, you,
all of you out there who... are here

00:03:14.230 --> 00:03:17.420
to attend this presentation to learn
about what you can do to increase

00:03:17.470 --> 00:03:19.120
the security of your applications.

00:03:19.120 --> 00:03:23.050
We believe that you should
take advantage of the hardening

00:03:23.050 --> 00:03:25.770
technologies that we've developed.

00:03:25.780 --> 00:03:29.270
And just... Often this means
just toggling a switch and

00:03:29.270 --> 00:03:31.160
enabling some hardening options.

00:03:31.160 --> 00:03:37.100
We hope that you use our frameworks
to secure your user data.

00:03:37.100 --> 00:03:41.020
And we hope that you test proactively,
since the attackers will be

00:03:41.020 --> 00:03:42.780
using fuzzing techniques.

00:03:43.480 --> 00:03:47.240
And we hope that you should also be
using the same techniques to find the

00:03:47.280 --> 00:03:49.700
bugs before you deploy your application.

00:03:51.290 --> 00:03:54.920
It's important to know the
platform you're developing for in

00:03:54.920 --> 00:03:57.680
order to produce secure products.

00:03:57.850 --> 00:04:03.200
So I'll start by going over the
differences and similarities between

00:04:03.200 --> 00:04:08.470
the desktop security model and
what we have on the mobile devices.

00:04:10.040 --> 00:04:15.650
So this diagram of
desktop computer system,

00:04:15.650 --> 00:04:19.060
and I'll show you some of the
trust boundaries that exist.

00:04:19.110 --> 00:04:22.500
Probably the most important
and the most obvious one is the

00:04:22.560 --> 00:04:23.950
trust boundary to the network.

00:04:23.990 --> 00:04:26.480
We don't want attackers,
remote attackers to be

00:04:26.480 --> 00:04:27.940
able to access your system.

00:04:27.970 --> 00:04:31.570
And we enforce this
through secure services,

00:04:31.570 --> 00:04:34.730
firewalling, and things like that.

00:04:35.770 --> 00:04:39.830
Another important security boundary
that exists in the system is the

00:04:39.880 --> 00:04:45.000
separation between the regular users
of the system and the operating system,

00:04:45.000 --> 00:04:51.310
the kernel and the slash system,
for example.

00:04:51.720 --> 00:04:55.810
Since Mac OS X is inherently
a multi-user system,

00:04:55.940 --> 00:04:59.100
we have strong boundaries between users.

00:04:59.130 --> 00:05:04.650
It's important to make sure that
one user can't mess with files

00:05:04.650 --> 00:05:07.940
created and owned by another user.

00:05:08.020 --> 00:05:14.510
The strong Unix foundation makes
sure that we have that security.

00:05:16.780 --> 00:05:20.280
We also have some separation
between applications,

00:05:20.280 --> 00:05:21.320
as I'm sure you're aware.

00:05:21.320 --> 00:05:23.260
We have virtual memory, protected memory.

00:05:23.260 --> 00:05:26.140
So processes are
separated from each other.

00:05:26.140 --> 00:05:31.200
But in fact, if you look at the processes
running as one particular user,

00:05:31.200 --> 00:05:36.280
they can often interfere with each
other if they're truly malicious.

00:05:36.280 --> 00:05:41.120
They can install plugins and use
various methods of getting into

00:05:41.140 --> 00:05:46.460
another process address space and
cause harm to that application.

00:05:46.700 --> 00:05:48.360
So that's something we
don't protect against.

00:05:48.360 --> 00:05:54.040
There's also a very weak boundary
between the system and the kernel.

00:05:54.040 --> 00:05:59.360
So let's compare this to
what we have on OS X iPhone.

00:06:01.630 --> 00:06:05.640
We obviously have the same separation to
the network and it's probably even more

00:06:05.640 --> 00:06:10.250
important since iPhones and iPod Touches,
they move around a lot,

00:06:10.270 --> 00:06:16.470
get used on malicious networks like
probably what we have in here today.

00:06:18.410 --> 00:06:24.360
And we have the same separation
between the processes running on

00:06:24.360 --> 00:06:28.600
the iPhone and the operating system.

00:06:30.320 --> 00:06:35.070
Since the iPhone is a single user system,
most phones have a single

00:06:35.070 --> 00:06:37.160
individual using them.

00:06:37.300 --> 00:06:43.260
We don't have separations between
various user-created users,

00:06:43.270 --> 00:06:47.650
but instead we have a separation
between the user data and the

00:06:47.760 --> 00:06:51.310
applications run by the single user.

00:06:52.350 --> 00:06:56.390
We've also hardened the
separation between applications

00:06:56.480 --> 00:06:57.630
running on the phone.

00:06:57.780 --> 00:07:01.780
So the intent is for,
if one application gets compromised,

00:07:01.780 --> 00:07:04.840
it shouldn't be able to
compromise another application

00:07:04.880 --> 00:07:06.330
running on the same system.

00:07:06.510 --> 00:07:12.080
So if a malicious third party application
would get installed on your system,

00:07:12.110 --> 00:07:16.040
it ideally shouldn't be able to
compromise your mail program,

00:07:16.040 --> 00:07:17.190
for example.

00:07:19.440 --> 00:07:25.000
The separation between the kernel and the
operating system has also been hardened.

00:07:25.110 --> 00:07:29.280
So even if an attacker would be able
to get root access to your system,

00:07:29.330 --> 00:07:33.170
he wouldn't necessarily be
able to compromise the kernel.

00:07:33.450 --> 00:07:37.430
On the desktop,
this is obviously possible since root

00:07:37.540 --> 00:07:42.880
can load kernel extensions and does get
code to run within the kernel space.

00:07:43.500 --> 00:07:48.410
You might notice from this
image that the applications they

00:07:48.640 --> 00:07:50.940
actually need to get to the data.

00:07:51.110 --> 00:07:55.150
So for this purpose,
we have services that

00:07:55.150 --> 00:07:57.450
negotiate this access.

00:07:57.570 --> 00:08:01.810
And that means that you should
access the user data through APIs,

00:08:01.810 --> 00:08:06.820
and they will take care of fetching
the data securely from disk.

00:08:08.940 --> 00:08:14.040
So next, let's review some of the
architectural hardening that we

00:08:14.040 --> 00:08:17.800
have on the phone and on Mac OS X.

00:08:17.840 --> 00:08:21.060
And there are some differences,
and I'll go over those.

00:08:21.390 --> 00:08:24.820
One important hardening feature
that was added to Leopard

00:08:25.190 --> 00:08:26.710
was the non-executable stack.

00:08:26.760 --> 00:08:30.280
And in case you're not
aware what this means,

00:08:30.280 --> 00:08:37.580
it's a technique for making exploitation
of buffer overflows more difficult.

00:08:37.580 --> 00:08:43.670
A common way of exploiting a stack
buffer overflow is to redirect the

00:08:43.800 --> 00:08:49.840
flow of execution onto some code
that you've placed on the stack.

00:08:50.640 --> 00:08:54.010
And thanks to this CPU feature,
that attack will fail and

00:08:54.040 --> 00:08:56.000
the program will just crash.

00:08:59.370 --> 00:09:05.240
On the phone and the x86-64 platforms,
we also have a non-executable heap.

00:09:05.240 --> 00:09:11.000
This means that if you allocate
memory anywhere using malloc,

00:09:11.000 --> 00:09:17.860
you will not be able to
run code in that space.

00:09:17.860 --> 00:09:22.500
And this further increases
the difficulty of exploiting

00:09:22.500 --> 00:09:24.700
a stack or heap of Roboflow.

00:09:26.770 --> 00:09:30.940
Another feature that we added to
Leopard was library randomization.

00:09:30.940 --> 00:09:36.800
And all of the system frameworks
are moving around in memory

00:09:36.800 --> 00:09:38.520
when you start your application.

00:09:38.520 --> 00:09:42.630
And it's also opt-in,
so you can make your application move

00:09:42.630 --> 00:09:45.380
around to random addresses in memory.

00:09:45.380 --> 00:09:52.530
And the intent of this is to make it more
difficult for an attacker to find some

00:09:52.580 --> 00:09:56.600
particular piece of exploitable memory.

00:09:56.700 --> 00:09:59.780
And on the phone,
we're not supporting library

00:09:59.780 --> 00:10:02.830
randomization at this point,
but it's certainly something

00:10:02.830 --> 00:10:03.620
we're looking into.

00:10:03.620 --> 00:10:04.770
Thank you.

00:10:05.910 --> 00:10:09.490
Code signing,
if you've looked at the SDK and

00:10:09.490 --> 00:10:13.960
maybe joined the developer program,
you know that code signing is

00:10:13.970 --> 00:10:16.420
an integral part of the iPhone.

00:10:16.420 --> 00:10:19.920
And the iPhone won't
run a non-signed code.

00:10:19.940 --> 00:10:24.040
And we also support code signing
on Mac OS X since Leopard.

00:10:24.040 --> 00:10:27.760
And I'll talk some more about that later.

00:10:30.880 --> 00:10:36.040
So yeah, on the phone you don't have
an option but to sign it.

00:10:36.060 --> 00:10:40.280
And in the future,
we're looking into how to use

00:10:40.330 --> 00:10:45.190
code signing better on the
desktop or more completely.

00:10:47.260 --> 00:10:52.990
Sandboxing, another Leopard technology,
allows a sandbox to be

00:10:53.010 --> 00:10:55.820
applied to a process.

00:10:55.820 --> 00:11:01.700
And this sandbox limits the actions that
a process can take beyond those that

00:11:01.860 --> 00:11:04.230
would normally be permitted by Unix.

00:11:04.240 --> 00:11:08.890
So certain system calls can be
disallowed and you can limit access

00:11:08.900 --> 00:11:12.240
to files on a per-path basis,
for example.

00:11:12.800 --> 00:11:15.440
And on the phone,
most of the applications

00:11:15.540 --> 00:11:17.260
are running in a sandbox.

00:11:17.260 --> 00:11:20.330
And this includes every
third-party application.

00:11:20.340 --> 00:11:27.600
And I'll talk some about what this means
to you developing for that platform.

00:11:27.600 --> 00:11:30.140
And I'm sure there will be
other sessions on that as well.

00:11:30.140 --> 00:11:35.510
In Mac OS X, we've just been sandboxing
certain services.

00:11:35.520 --> 00:11:41.560
And applications can currently
not run in a sandbox on Mac OS X.

00:11:44.120 --> 00:11:48.140
Finally, we've worked on reducing the
number of set UID binaries.

00:11:48.160 --> 00:11:54.100
Set UID binaries are binaries
with special privileges.

00:11:54.100 --> 00:11:59.430
They run as the user who owns them,
which is most commonly root.

00:11:59.560 --> 00:12:04.440
And because the user who starts the
application controls the environment,

00:12:04.440 --> 00:12:08.610
this is a very significant
attack surface,

00:12:08.620 --> 00:12:13.600
which we've often seen exploited
for local privilege escalation.

00:12:14.000 --> 00:12:18.130
And on the iPhone,
we have zero set UID binaries,

00:12:18.130 --> 00:12:21.420
and we're working hard on
reducing the number on Mac OS X.

00:12:21.420 --> 00:12:25.410
And we hope that if your
application uses a set UID binary,

00:12:25.410 --> 00:12:30.020
that you move to using launchD instead,
because that gives you control over

00:12:30.050 --> 00:12:34.600
the environment instead of the user who
happens to be starting here executable.

00:12:34.600 --> 00:12:41.600
So let's look at some of the technologies
used specifically on the phone.

00:12:41.600 --> 00:12:42.810
Here we go.

00:12:45.460 --> 00:12:47.960
It only runs signed code.

00:12:47.980 --> 00:12:52.960
And due to the non-executable
stack and heap,

00:12:52.960 --> 00:12:55.480
code generation is prevented.

00:12:55.500 --> 00:13:01.720
And this makes it significantly harder
for an attacker to move from finding

00:13:01.840 --> 00:13:07.150
an exploit to actually getting the
system to execute arbitrary code.

00:13:09.500 --> 00:13:13.490
But you should always remember
that attacks get better and if

00:13:13.490 --> 00:13:17.720
you have memory corruption in
your program such as in Overflow,

00:13:17.960 --> 00:13:22.360
it's very likely to be
exploitable in some manner.

00:13:22.360 --> 00:13:28.090
But these technologies significantly
raise the threshold for attack.

00:13:30.690 --> 00:13:33.400
The applications are
shielded from each other,

00:13:33.400 --> 00:13:37.440
and the way this works is that the
shared data is accessed through APIs.

00:13:37.440 --> 00:13:40.370
And we're extending this support.

00:13:40.400 --> 00:13:43.800
Currently,
some frameworks directly access

00:13:43.800 --> 00:13:48.140
data on disk instead of going
through a launchd service.

00:13:48.140 --> 00:13:54.080
But this might change in the future,
and when the framework changes,

00:13:54.080 --> 00:13:58.160
your application will break if it
tries to access the data directly

00:13:58.160 --> 00:13:59.780
without going through the API.

00:14:02.960 --> 00:14:07.760
About the sandbox, Mail and Safari,
two very full-featured

00:14:07.760 --> 00:14:10.830
applications on the phone,
are running in a sandbox that's very,

00:14:10.830 --> 00:14:13.680
very similar to what your
applications will be running in.

00:14:13.680 --> 00:14:17.960
And every third-party application
runs in the same sandbox,

00:14:17.960 --> 00:14:23.480
and it's not possible to remove nor
add restrictions to that sandbox.

00:14:25.060 --> 00:14:30.330
And you should think about the
application container in which your

00:14:30.330 --> 00:14:32.780
application lives as your home directory.

00:14:32.780 --> 00:14:37.340
It has the same subdirectories
like documents and library,

00:14:37.340 --> 00:14:39.290
and that's where you
should store your data.

00:14:41.880 --> 00:14:46.120
The approved locations for writing
specifically are temp inside

00:14:46.120 --> 00:14:49.720
of the application container,
slash library, and slash documents.

00:14:51.680 --> 00:14:54.980
And as I mentioned,
some other parts of the file

00:14:54.980 --> 00:14:57.640
system may be accessible.

00:14:57.660 --> 00:15:01.840
The sandbox may allow you access,
but the sandbox might get tighter

00:15:01.840 --> 00:15:05.350
in the future and your application
would break in that case.

00:15:07.040 --> 00:15:12.110
Keychain is a framework that many of
you are familiar with from Mac OS X.

00:15:12.120 --> 00:15:16.400
And it exists on the phone,
but it's somewhat different

00:15:16.480 --> 00:15:20.360
due to the single-user nature
of the iPhone and iPod Touch.

00:15:20.360 --> 00:15:24.650
It's automatically unlocked
when the system starts,

00:15:24.650 --> 00:15:27.380
and that means you don't
have to enter your password.

00:15:27.380 --> 00:15:30.940
You might ask,
what's the point of encrypting it

00:15:30.940 --> 00:15:36.660
if the key is on the device and it's
automatically unlocked when it starts?

00:15:36.930 --> 00:15:42.540
And one of the reasons that this is a
good idea is that backups will remain.

00:15:42.540 --> 00:15:48.500
So if someone steals a backup of a phone,
he won't have access to the data.

00:15:48.500 --> 00:15:52.410
We've also,
the key that's used is unique to

00:15:52.410 --> 00:15:55.530
each device and stored on a chip.

00:15:55.560 --> 00:16:01.080
So it's pretty difficult for an
attacker to extract this key without

00:16:01.080 --> 00:16:04.200
completely compromising a phone.

00:16:06.180 --> 00:16:09.260
If your application stores
some data in the keychain,

00:16:09.260 --> 00:16:12.060
you can rest assured that
other applications will not

00:16:12.180 --> 00:16:13.820
be able to access that data.

00:16:16.480 --> 00:16:20.300
The security framework is also
different from Mac OS X to the iPhone.

00:16:20.300 --> 00:16:23.490
And we have a framework
called Certificates,

00:16:23.490 --> 00:16:28.770
Key and Trust Services,
which provide many useful security

00:16:28.770 --> 00:16:32.360
services such as certificates,
signatures and encryption.

00:16:32.360 --> 00:16:35.800
Common Crypto,
which you know from Mac OS X is there.

00:16:35.800 --> 00:16:40.010
And there's a randomization library,
which you can use if you need access to

00:16:40.030 --> 00:16:42.860
cryptographically secure random data.

00:16:42.860 --> 00:16:45.530
And there's the keychain,
which I already talked about.

00:16:48.030 --> 00:16:51.620
Some things are missing from the phone,
and this includes secure

00:16:51.720 --> 00:16:53.150
transport or open SSL.

00:16:53.280 --> 00:16:56.540
So if you need to make secure
socket layer connections,

00:16:56.550 --> 00:17:02.860
you should use CF network or
NSURL request to make those connections.

00:17:02.880 --> 00:17:08.310
And Braden will show you some sample code
on how to do that later in the session.

00:17:08.580 --> 00:17:11.550
Since it's a single user system,
there's no way of escalating

00:17:11.630 --> 00:17:16.590
privileges and this means that there
are no authentication dialogues or

00:17:16.590 --> 00:17:20.880
authorization and there's obviously
no interface for that either,

00:17:20.880 --> 00:17:23.660
so those frameworks are missing.

00:17:25.890 --> 00:17:30.640
And now let's move on to some specifics
about the Mac OS X technologies.

00:17:30.640 --> 00:17:39.050
I mentioned quarantine,
which is a warning that a user gets

00:17:39.050 --> 00:17:42.900
if he tries to start an application
that was downloaded from the internet.

00:17:42.900 --> 00:17:48.690
And it shows the source of the file
and tells him what kind of file it is,

00:17:48.770 --> 00:17:51.400
if it's a web application
or an application.

00:17:52.070 --> 00:17:55.710
And hopefully helps the user to
make an educated decision about

00:17:55.710 --> 00:17:57.920
whether to run that program or not.

00:17:59.210 --> 00:18:03.610
And the Apple's application,
Apple's applications automatically

00:18:03.610 --> 00:18:06.670
apply quarantine information
to the files they download.

00:18:06.670 --> 00:18:09.460
And we hope that your applications
will do the same thing.

00:18:09.460 --> 00:18:13.720
So if your application downloads
information from the internet,

00:18:13.870 --> 00:18:16.460
we think that you should use these APIs.

00:18:16.460 --> 00:18:17.840
And they're pretty simple.

00:18:17.840 --> 00:18:23.220
It's like three or five functions
that you need to worry about.

00:18:23.220 --> 00:18:27.840
And if your needs are very simple,
then you might even get along with

00:18:27.840 --> 00:18:29.080
just setting up a security application.

00:18:29.140 --> 00:18:37.580
And you might wonder how does
that affect preference files,

00:18:37.580 --> 00:18:39.740
for example.

00:18:39.740 --> 00:18:44.450
And the fact is that if the user...

00:18:45.850 --> 00:18:48.950
If the user doesn't go through
the finder and open a file,

00:18:48.950 --> 00:18:51.800
then the quarantine bits
don't do anything really.

00:18:51.800 --> 00:18:55.700
So it shouldn't cause any
problems for your application.

00:18:55.700 --> 00:18:59.280
And you can even combine
these technologies,

00:18:59.280 --> 00:19:05.310
the info property list and the functions,
to annotate the downloads, for example,

00:19:05.350 --> 00:19:06.800
with the source URL.

00:19:09.410 --> 00:19:11.500
Code signing exists on the desktop.

00:19:11.500 --> 00:19:16.200
It was initially available
on the desktop in Leopard,

00:19:16.200 --> 00:19:21.340
and we hope that you continue to sign
your applications if you already started,

00:19:21.340 --> 00:19:24.580
or that you start to sign your
applications with your own key.

00:19:25.060 --> 00:19:29.930
And this is useful for end users,
since technologies such as Keychain

00:19:29.930 --> 00:19:36.460
take advantage of code signing to
present fewer dialogues to the user,

00:19:36.460 --> 00:19:40.940
bothering him less
often for his password.

00:19:40.940 --> 00:19:45.430
And it's also useful for
institutional customers who want

00:19:45.430 --> 00:19:49.530
to enforce policy on their network,
for example.

00:19:52.280 --> 00:19:56.440
Finally, I want to talk about
file system permissions.

00:19:56.440 --> 00:20:01.700
They're sort of the last line of
defense of the operating system.

00:20:01.700 --> 00:20:07.020
If someone has compromised the
system and started to run code on it,

00:20:07.020 --> 00:20:10.340
he'll likely want to escalate privileges.

00:20:10.340 --> 00:20:15.330
And insecure file system permissions
might be one way of doing that.

00:20:15.480 --> 00:20:20.960
So to reduce that risk,
we want to tighten the default

00:20:21.030 --> 00:20:23.360
permissions on the system.

00:20:23.370 --> 00:20:27.560
And if you want to
cooperate with this effort,

00:20:27.590 --> 00:20:32.300
we hope that you follow some
pretty simple guidelines.

00:20:32.320 --> 00:20:35.890
We've, ever since 10.0,
we've been telling you to not

00:20:35.890 --> 00:20:40.640
modify the application bundle
inside of the /applications folder.

00:20:40.650 --> 00:20:45.280
And this obviously remains true
that you shouldn't do that.

00:20:45.280 --> 00:20:49.890
We're considering tightening
the restrictions on

00:20:49.890 --> 00:20:52.780
/applications and /library.

00:20:52.930 --> 00:20:55.740
So if you need to write
to those locations,

00:20:55.740 --> 00:21:00.740
do it during install when
you're writing files as root.

00:21:02.350 --> 00:21:06.880
We also hope that you avoid using the
world writable locations on the system,

00:21:06.880 --> 00:21:11.400
and these include /library/caches/temp.

00:21:11.410 --> 00:21:16.920
And we have API for getting other
directories that can be used to store

00:21:16.920 --> 00:21:22.580
temporary files or caches that Braden
will go into more detail about.

00:21:23.480 --> 00:21:26.260
So with that,
I want to hand over to Braden Thomas,

00:21:26.260 --> 00:21:28.960
who will present the
second part of this talk.

00:21:35.660 --> 00:21:38.700
Hi, my name is Braden Thomas,
and I'm a product security

00:21:38.700 --> 00:21:39.800
engineer at Apple.

00:21:39.840 --> 00:21:43.600
And today I'm going to show you some
secure coding tips that you can use to

00:21:43.600 --> 00:21:46.220
improve the security of your application.

00:21:46.990 --> 00:21:50.730
So I'm going to show you three
scenarios in which you can apply

00:21:50.730 --> 00:21:54.640
these secure coding tips to improve
the security of your application.

00:21:54.640 --> 00:21:57.420
The first is synchronization
between multiple components.

00:21:57.520 --> 00:22:03.090
Today, your application may have a server
back-end or multiple components or even

00:22:03.090 --> 00:22:08.880
have a peer-to-peer synchronization,
and you want to securely synchronize

00:22:08.890 --> 00:22:12.010
data between those components,
and I'm going to show you how to do that.

00:22:12.080 --> 00:22:16.200
Second, all your data might not
come from a server back-end.

00:22:16.430 --> 00:22:19.730
You might be accepting data from
the user or from the network,

00:22:19.770 --> 00:22:26.160
and so to process this user-created data,
I'm going to tell you how to handle

00:22:26.570 --> 00:22:31.360
untrusted data properly and also how
to interact with the file system,

00:22:31.360 --> 00:22:34.920
which may itself be untrusted,
and how to do so securely.

00:22:34.920 --> 00:22:37.750
And finally,
I'm going to give you some simple

00:22:37.750 --> 00:22:41.220
security hardening measures that
you can add to your application very

00:22:41.220 --> 00:22:46.360
easily to secure your application
with very little effort by you.

00:22:46.400 --> 00:22:51.410
So first,
let's begin with data synchronization.

00:22:53.020 --> 00:22:57.700
So the iPhone especially has
platform constraints such as disk

00:22:57.700 --> 00:23:01.790
space and processing constraints
that may encourage you to have

00:23:01.790 --> 00:23:03.520
multiple like a server back end.

00:23:03.540 --> 00:23:06.000
Additionally,
it's a highly mobile platform

00:23:06.000 --> 00:23:09.400
and as David mentioned,
because of the security landscape,

00:23:09.400 --> 00:23:11.980
you should expect man in the
middle attacks between your

00:23:11.980 --> 00:23:13.900
application and your server back end.

00:23:13.920 --> 00:23:19.610
You can't trust DNS and so instead you
should rely on cryptographic security to

00:23:19.610 --> 00:23:22.920
ensure that the communication is secure.

00:23:22.920 --> 00:23:25.910
I'll show you how to do that in a minute.

00:23:26.260 --> 00:23:29.830
Additionally, as the mobile device will
increasingly have private data on it,

00:23:29.940 --> 00:23:34.900
such as data returned by core location,
you should adopt a stringent

00:23:35.110 --> 00:23:39.710
privacy policy to always ask
first before transmitting this

00:23:39.710 --> 00:23:42.170
data to your back end server.

00:23:43.790 --> 00:23:46.480
So let's look at an application,
an example application,

00:23:46.560 --> 00:23:49.350
in this case a shopping list application.

00:23:49.450 --> 00:23:52.560
So this shopping list is
acquired from a back-end server,

00:23:52.600 --> 00:23:56.160
but it's also accessible to the
user via a web page where they

00:23:56.160 --> 00:23:57.700
can review their shopping list.

00:23:57.970 --> 00:24:00.590
Clearly this is a very simple example.

00:24:00.930 --> 00:24:04.200
But for this data
synchronization strategy,

00:24:04.240 --> 00:24:06.300
you need to consider three aspects.

00:24:06.590 --> 00:24:10.040
The first is authentication,
how your applications are

00:24:10.040 --> 00:24:11.760
authenticating to your backend server.

00:24:11.810 --> 00:24:15.800
Second, the integrity of the data being
returned to your applications.

00:24:15.830 --> 00:24:20.760
And third, encryption of the data being
communicated across all channels.

00:24:22.210 --> 00:24:25.590
The concern with authentication
is a brute force attack whereby

00:24:25.590 --> 00:24:28.960
a hacker provides a dictionary
of passwords to your server

00:24:29.470 --> 00:24:33.390
and if one of them is correct,
gets valid user data back.

00:24:33.390 --> 00:24:37.200
Let's look at how you can prevent that.

00:24:37.590 --> 00:24:40.180
We recommend the use of client-side
certificates because we have

00:24:40.260 --> 00:24:42.200
the support built into the APIs.

00:24:42.540 --> 00:24:45.870
It provides improved security because
client-side certificates are far

00:24:45.870 --> 00:24:49.670
harder to brute force than passwords
because as much as we want our

00:24:49.670 --> 00:24:54.840
users to create secure passwords,
it's very rare that they actually do.

00:24:54.960 --> 00:24:58.630
Second, if the user changes
passwords on one platform,

00:24:58.630 --> 00:25:01.000
as they generally do when
they're using platforms,

00:25:01.180 --> 00:25:03.600
they have to go through that
annoying process of synchronizing

00:25:03.600 --> 00:25:06.620
all those passwords manually
on their various systems.

00:25:06.620 --> 00:25:09.040
And if they use client-side certificates,
they can just stick with

00:25:09.120 --> 00:25:09.940
that one certificate.

00:25:10.060 --> 00:25:13.160
So let's look at how you would
do that with iPhone APIs.

00:25:13.160 --> 00:25:17.130
First, you need to generate and sign
that certificate on the server.

00:25:18.670 --> 00:25:26.400
Second, you transmit that certificate in
the form of a PKCS12 blob down to

00:25:26.400 --> 00:25:28.450
your iPhone in an encrypted format.

00:25:28.460 --> 00:25:35.860
Then you import the data from that
PKCS12 blob and get out a Sec Identity.

00:25:35.860 --> 00:25:39.340
Finally, when you're actually doing the
communication that requires

00:25:39.410 --> 00:25:43.650
authentication to the server,
you want to use that Sec Identity

00:25:43.650 --> 00:25:48.490
as a SSL certificate's
property in your CF Readstream.

00:25:48.600 --> 00:25:52.540
And so that's how you
handle authentication.

00:25:52.540 --> 00:25:56.490
Let's consider the next aspect
of data synchronization,

00:25:56.870 --> 00:25:58.470
which is integrity.

00:25:58.480 --> 00:26:01.630
Now the concern here is that an
attacker can insert himself in the

00:26:01.770 --> 00:26:06.620
middle of your communication and return
malicious data to your applications.

00:26:06.620 --> 00:26:10.780
So as you can see in our example here,
you might be buying a Plasma TV,

00:26:10.830 --> 00:26:13.690
which you didn't want to buy,
but the attacker made you think you did.

00:26:13.820 --> 00:26:18.500
Or you could be running malicious
JavaScript in a web browser.

00:26:19.220 --> 00:26:24.450
So, to perform integrity checking,
all you need to do is use an

00:26:24.450 --> 00:26:30.760
NSURL connection with an HTTPS URL or
a CF read stream with an HTTPS URL.

00:26:30.760 --> 00:26:35.280
Now, the difference between the two is
that with the foundation layer,

00:26:35.280 --> 00:26:39.130
you need to use a trusted certificate,
whereas with the CF layer,

00:26:39.130 --> 00:26:41.360
you don't need to use
a trusted certificate.

00:26:41.430 --> 00:26:46.820
You may want to consider and weigh
the pros and cons of both approaches.

00:26:47.580 --> 00:26:50.710
Now, obviously,
a trusted certificate is going to cost

00:26:50.710 --> 00:26:55.020
you some money since you'll need to pay
a CA to sign that certificate for you.

00:26:56.290 --> 00:26:58.190
However,
it won't provide you any cryptographic

00:26:58.190 --> 00:27:02.490
benefit because at the end of the day,
the same cryptography is occurring.

00:27:02.500 --> 00:27:07.240
But Foundation is probably a simpler
implementation for your application,

00:27:07.240 --> 00:27:10.970
and that same certificate can be
shared with a web interface where the

00:27:10.990 --> 00:27:14.560
user requires a trusted certificate
to be able to view the details on

00:27:14.620 --> 00:27:18.740
your website and verify that they're
connecting to the correct site.

00:27:21.390 --> 00:27:23.700
If you do choose to use
a non-trust certificate,

00:27:23.840 --> 00:27:29.120
which may be right for your application,
there's a couple steps you need to take.

00:27:29.180 --> 00:27:33.200
First, before connecting,
you need to disable chain validation.

00:27:33.280 --> 00:27:37.440
And you do this by setting the
SSL validates chain property to false.

00:27:37.440 --> 00:27:39.550
And then you go ahead
and do the connection,

00:27:39.550 --> 00:27:40.800
reading out the data.

00:27:40.820 --> 00:27:44.250
After you read the data and
have performed the connection,

00:27:44.320 --> 00:27:47.280
before processing it,
to verify the peer trust,

00:27:48.080 --> 00:27:52.460
You pull out the SSL peer trust property.

00:27:52.990 --> 00:27:57.000
And then you set your own anchor
certificate to whatever you want

00:27:57.000 --> 00:28:00.790
your anchor certificate to be,
if it's maybe your own

00:28:00.790 --> 00:28:03.340
CA embedded in the application.

00:28:03.340 --> 00:28:09.340
And you evaluate the trust to verify that
you're receiving a valid certificate.

00:28:12.080 --> 00:28:12.840
So that's integrity.

00:28:12.840 --> 00:28:14.260
Let's look next at encryption.

00:28:14.260 --> 00:28:17.860
Of course,
the standard attack for encryption is

00:28:18.120 --> 00:28:22.700
an attacker is on your local network
or some node on the way to your server

00:28:22.700 --> 00:28:24.520
and is able to read user private data.

00:28:24.560 --> 00:28:27.450
So you, of course,
get this for free if you're

00:28:27.600 --> 00:28:29.250
using an HTTPS server.

00:28:29.260 --> 00:28:32.970
And this works with
NSURL connection or CFREAD stream

00:28:33.080 --> 00:28:35.430
as shown in the prior example.

00:28:36.160 --> 00:28:38.910
This is most critical when
you're transmitting any kind of

00:28:39.160 --> 00:28:42.130
personally identifiable data,
such as a user's location.

00:28:44.750 --> 00:28:49.500
So, as I mentioned before, all your data,
of course, isn't going to come from

00:28:49.830 --> 00:28:50.690
your server back end.

00:28:50.700 --> 00:28:52.920
Some of that data may come
from the user himself.

00:28:55.400 --> 00:28:57.900
Here's your application,
and you want to receive this

00:28:57.920 --> 00:29:00.780
user-created data over the
network or if you're running on

00:29:00.780 --> 00:29:02.510
the desktop via the file system.

00:29:02.520 --> 00:29:04.910
You have to consider things
like buffer overflows,

00:29:05.050 --> 00:29:07.630
integer overflows,
format string vulnerabilities.

00:29:07.660 --> 00:29:11.530
These are your standard memory
management corruption vulnerabilities.

00:29:11.560 --> 00:29:14.580
However,
if you're receiving untrusted data,

00:29:14.580 --> 00:29:17.640
you also need to consider
if that data is HTML.

00:29:17.640 --> 00:29:19.950
So let's look at this closer.

00:29:20.740 --> 00:29:24.410
Additionally, when you're interacting
with the file system,

00:29:24.410 --> 00:29:27.810
if you're on a desktop system,
you have to consider that the file

00:29:27.810 --> 00:29:30.760
system itself could be untrusted
if there's local attackers

00:29:30.760 --> 00:29:32.360
potentially on that system.

00:29:32.360 --> 00:29:34.510
So we need to consider race conditions.

00:29:37.080 --> 00:29:38.560
So first, let's look at buffer overflows.

00:29:38.600 --> 00:29:43.840
Buffer overflows, as you probably know,
are when data is copied into

00:29:43.840 --> 00:29:45.140
a buffer that's too small.

00:29:45.140 --> 00:29:49.660
And this commonly occurs when you're
using unsafe string functions.

00:29:49.680 --> 00:29:54.400
We recommend using the following
string functions as opposed to

00:29:54.550 --> 00:29:59.290
the strcat and strcopy or the
strcat and strcopy functions.

00:29:59.300 --> 00:30:00.750
We recommend the L variety.

00:30:00.760 --> 00:30:03.390
Or the sprintf vsprintf.

00:30:03.520 --> 00:30:05.860
We recommend the snprintf and vsprintf.

00:30:06.480 --> 00:30:09.800
And finally,
you should never use the gets function.

00:30:09.920 --> 00:30:13.640
So, string functions will
only help you so far.

00:30:13.640 --> 00:30:17.100
If you're doing manual memory
copying from one buffer to another,

00:30:17.100 --> 00:30:19.670
you need to perform your
own sanity checking.

00:30:19.820 --> 00:30:22.980
But let's look closer at
these string functions.

00:30:24.420 --> 00:30:26.670
Here you have a destination
buffer that's five bytes,

00:30:26.670 --> 00:30:30.150
and you're copying in a string
that's six characters long with

00:30:30.230 --> 00:30:34.290
a null termination that's seven
bytes into the smaller buffer.

00:30:34.330 --> 00:30:36.890
If you use stir copy,
you're going to get a simple buffer

00:30:37.050 --> 00:30:40.720
overflow overriding uninitialized
memory past the size of the buffer.

00:30:40.820 --> 00:30:43.980
This is probably exploitable
for code execution.

00:30:44.270 --> 00:30:46.220
We don't recommend this
for obvious reasons.

00:30:46.220 --> 00:30:50.790
Next, if you use the stir in copy,
you're not going to overwrite

00:30:51.100 --> 00:30:55.000
the uninitialized data past
the destination buffer size.

00:30:55.000 --> 00:30:59.800
However, you do have to be concerned
because no null termination of your

00:30:59.810 --> 00:31:01.140
destination buffer has occurred.

00:31:01.140 --> 00:31:05.340
So if you're later using
this destination buffer,

00:31:05.340 --> 00:31:09.770
whether it's an insecure string function,
or if you're trying to

00:31:09.780 --> 00:31:13.850
determine the length,
you've lost that length value.

00:31:13.860 --> 00:31:17.100
It's no longer a C string,
null terminate C string,

00:31:17.100 --> 00:31:20.500
so it's more difficult for you to
determine the length of that buffer.

00:31:22.100 --> 00:31:25.230
This could possibly lead to your
application crashing by reading

00:31:25.230 --> 00:31:27.690
into uninitialized memory.

00:31:28.290 --> 00:31:31.680
So instead,
we recommend using the strlcopy function.

00:31:31.700 --> 00:31:37.350
This will null terminate the destination
buffer and not perform a buffer overflow.

00:31:37.770 --> 00:31:41.690
However, you still have to consider what
sort of application-specific

00:31:42.520 --> 00:31:46.370
consequences occurred by truncating
whatever data is being copied.

00:31:46.380 --> 00:31:49.070
And that really just needs
to be handled in code,

00:31:49.070 --> 00:31:52.470
and you can check the return
value of the strlcopy function to

00:31:52.550 --> 00:31:54.810
determine if truncation has occurred.

00:31:58.090 --> 00:31:59.080
So that's buffer overflows.

00:31:59.190 --> 00:32:03.340
Let's look at another very
common memory corruption issue,

00:32:03.360 --> 00:32:04.840
integer overflows.

00:32:04.870 --> 00:32:08.180
An integer overflow occurs when
you're performing an arithmetic

00:32:08.190 --> 00:32:14.320
operation and the integer that
you're performing that operation on

00:32:14.570 --> 00:32:20.080
exceeds or goes under the size of
the data type that that integer is.

00:32:20.250 --> 00:32:25.930
For example, on a 32-bit platform,
an int would be 32 bits, where on 64-bit,

00:32:25.930 --> 00:32:27.960
it would be 64 bits.

00:32:28.020 --> 00:32:32.280
So here's a common code
pattern that we commonly see

00:32:32.280 --> 00:32:34.260
integer overflows occurring in.

00:32:34.310 --> 00:32:36.590
And I'm going to walk you through it.

00:32:36.820 --> 00:32:39.720
First, we define a binary data structure.

00:32:39.970 --> 00:32:45.540
And this binary data structure defines
data that is a number of entries followed

00:32:45.640 --> 00:32:50.580
by memory allocated for those entries.

00:32:50.770 --> 00:32:55.300
Entry itself is a structure with a
static size that I don't show here.

00:32:55.340 --> 00:33:00.120
So we're reading data
in as this data blob.

00:33:00.180 --> 00:33:05.480
We're then going to copy this
data blob into another data blob.

00:33:05.480 --> 00:33:09.390
And what we do is we first allocate the
destination by multiplying the number

00:33:09.390 --> 00:33:11.860
of entries by the size of each entry.

00:33:11.860 --> 00:33:13.540
And that's pretty intuitive.

00:33:15.440 --> 00:33:19.010
We then step through each
entry and we copy them one

00:33:19.060 --> 00:33:21.270
by one into our destination.

00:33:21.380 --> 00:33:26.080
But the highlighted code here has a
problem and it's an integer overflow.

00:33:26.530 --> 00:33:30.000
So when we multiply the number of
entries by the size of each entry,

00:33:30.000 --> 00:33:33.360
the resulting value could
potentially overflow and allocate

00:33:33.360 --> 00:33:34.810
less memory than we thought.

00:33:34.840 --> 00:33:39.440
When we then do the one-by-one copy,
it would result in a heap overflow,

00:33:39.440 --> 00:33:41.470
leading to code execution.

00:33:42.160 --> 00:33:44.540
So for example,
if the size of an entry is

00:33:44.570 --> 00:33:48.040
10 bytes and an attacker
passes in a number of entries,

00:33:48.090 --> 00:33:52.240
which is 1-9999-A,
the resulting multiplication

00:33:52.680 --> 00:33:56.280
would overflow the one
past the 32 bits available,

00:33:56.350 --> 00:33:59.810
and the 32-bit type would
be truncated to four.

00:33:59.830 --> 00:34:03.180
So we'd only have four bytes
allocated for our destination,

00:34:03.180 --> 00:34:06.440
and when we did the one-by-one copy,
we would overflow that

00:34:06.460 --> 00:34:07.920
buffer very quickly.

00:34:11.490 --> 00:34:15.100
So we introduced in
Leopard the CheckInt.h API,

00:34:15.100 --> 00:34:19.180
which is a header file containing
macros you can use to prevent integer

00:34:19.180 --> 00:34:21.570
overflows in your application.

00:34:22.770 --> 00:34:26.660
To show how this would solve
the problem in the example,

00:34:26.790 --> 00:34:29.130
first we include the checkint.h header.

00:34:29.130 --> 00:34:34.590
Then, when we perform the multiplication,
we actually use the check

00:34:34.610 --> 00:34:37.930
unsigned int 32 multiply macro.

00:34:38.430 --> 00:34:40.600
The first two arguments are
the two values that we're

00:34:40.600 --> 00:34:42.660
going to multiply together.

00:34:42.860 --> 00:34:45.800
The third argument is a
pointer to an integer.

00:34:45.880 --> 00:34:49.000
And this integer is an error value.

00:34:49.140 --> 00:34:54.270
If that value is ORed with an error,
then when we return,

00:34:54.280 --> 00:34:56.500
we know that an integer
overflow has occurred.

00:34:56.710 --> 00:35:00.540
So check this integer value after
you perform the multiplication.

00:35:00.640 --> 00:35:03.370
If there's no error,
then you can go on through your code and

00:35:03.370 --> 00:35:06.580
you know that you're safe to do the copy.

00:35:08.500 --> 00:35:11.000
So a next common type of
memory vulnerability is a

00:35:11.000 --> 00:35:12.380
format string vulnerability.

00:35:12.400 --> 00:35:16.560
This occurs when you take a format
string function like printf and you

00:35:16.600 --> 00:35:18.830
don't pass a format specifier string.

00:35:18.840 --> 00:35:22.710
A format specifier string is just
the percent s or the percent d that

00:35:22.710 --> 00:35:24.720
you see in this printf example.

00:35:24.720 --> 00:35:28.540
If you don't do this,
you open yourself up to code execution.

00:35:28.540 --> 00:35:31.720
So while you may know about
this in terms of printf,

00:35:31.720 --> 00:35:35.420
you might not have known that
all these other functions exist

00:35:35.500 --> 00:35:37.660
that also take format strings.

00:35:38.400 --> 00:35:42.390
And you should be very careful when
using any one of these functions to

00:35:42.470 --> 00:35:47.580
ensure that you're not causing format
string vulnerability in your application.

00:35:47.750 --> 00:35:53.510
We recently saw a lot of exploitation
with the month of Apple bugs with the

00:35:53.510 --> 00:35:58.970
NS alert and alert methods because
people weren't entirely certain that

00:35:58.970 --> 00:36:01.190
these actually accepted format strings.

00:36:04.400 --> 00:36:09.990
So let's look at what an attacker can do
with such a format string vulnerability.

00:36:10.340 --> 00:36:15.300
So this simple program just copies
an argument from the command line

00:36:15.300 --> 00:36:16.840
into a buffer and then prints it out.

00:36:16.900 --> 00:36:21.240
Now the copy is safe because we're
using the STOREL copy and passing

00:36:21.340 --> 00:36:24.200
the size of the destination buffer,
but the printf is unsafe

00:36:24.200 --> 00:36:27.580
because it doesn't contain
a format specifier string.

00:36:29.680 --> 00:36:34.100
So the attacker will first
try and run this with,

00:36:34.210 --> 00:36:36.700
say, 4% Xs.

00:36:36.700 --> 00:36:40.010
Now,
because the parameter area occurs before

00:36:40.020 --> 00:36:44.350
the local variable area in the stack,
these 4% Xs,

00:36:44.350 --> 00:36:48.400
which would normally just print out the
hex value of arguments to the printf,

00:36:48.420 --> 00:36:51.270
since there's no arguments to
the printf aside from the buffer,

00:36:51.420 --> 00:36:54.780
this will just print out data
that occurs next on the stack.

00:36:54.840 --> 00:36:58.840
So you see we have this
BFF92D sum data on the stack,

00:36:58.880 --> 00:37:04.340
followed by 400, followed by 0,
followed by this 41414141.

00:37:04.340 --> 00:37:10.740
This value is special because it
is the hex equivalent of this AAAA.

00:37:10.750 --> 00:37:15.780
Now, what that tells the attacker is that
he has now hit the local variable area,

00:37:15.810 --> 00:37:20.870
because he's printing out this AAAA,
which is existing in this buffer

00:37:20.870 --> 00:37:23.870
allocated in the local variable area.

00:37:25.280 --> 00:37:29.500
Now, what the attacker can now
do is use the %n specifier.

00:37:29.800 --> 00:37:32.040
Now,
this is rarely used by modern programs,

00:37:32.180 --> 00:37:36.360
but what it does is it writes the number
of bytes printed by a printf function

00:37:36.670 --> 00:37:40.750
into a variable stored in that argument.

00:37:40.980 --> 00:37:43.950
Because there's no arguments here,
we've replaced the last percent X,

00:37:44.000 --> 00:37:47.450
which corresponded to the 41, 41, 41,
with this percent in.

00:37:47.460 --> 00:37:52.280
So we now know that we're going to be
writing some value into this address.

00:37:52.280 --> 00:37:56.300
And if you can see here,
GDB showed that we crashed trying

00:37:56.830 --> 00:37:59.110
to write into that address.

00:37:59.200 --> 00:38:03.280
And this 41, 41, 41,
41 is just used as an example,

00:38:03.280 --> 00:38:06.440
but an attacker could specify
any arbitrary address here.

00:38:08.010 --> 00:38:09.620
So we know what he's writing into.

00:38:09.620 --> 00:38:10.500
What is he writing?

00:38:10.520 --> 00:38:17.140
So if you use the percent 100,000X,
this will print out a

00:38:17.140 --> 00:38:19.840
whole bunch of values,
artificially increasing the number

00:38:19.840 --> 00:38:21.360
of bytes that have been printed.

00:38:21.360 --> 00:38:25.140
So the attacker can kind of
indirectly specify what data is

00:38:25.250 --> 00:38:27.770
going to be written into that value.

00:38:28.240 --> 00:38:32.680
And as you can see in GDB,
the instruction is trying to write this

00:38:32.720 --> 00:38:37.510
32-bit value into the address 41414141.

00:38:37.510 --> 00:38:39.940
And what it's trying to write,
as you can see,

00:38:39.940 --> 00:38:45.000
is 100,000 and some change because
that's what the attacker has specified.

00:38:45.000 --> 00:38:49.280
And so he can use this write what
where to attack your application

00:38:49.350 --> 00:38:51.780
and easily cause code execution.

00:38:51.780 --> 00:38:55.580
And so that's why you have to be very
careful with format string functions.

00:38:58.400 --> 00:39:02.770
So those are common memory
handling vulnerabilities.

00:39:02.780 --> 00:39:04.880
Let's look at some other untrusted data.

00:39:04.900 --> 00:39:08.880
One type of untrusted data that
you might be receiving is HTML.

00:39:08.880 --> 00:39:12.580
So on Mac OS X,
if you were displaying HTML that

00:39:12.580 --> 00:39:15.250
you received off the network,
you could use web preferences

00:39:15.250 --> 00:39:18.850
to turn off JavaScript and
plugins in your application.

00:39:18.860 --> 00:39:22.520
But on iPhone, we don't support the web
preferences currently.

00:39:22.520 --> 00:39:26.900
So you have to be very careful
with HTML that's loaded from

00:39:26.900 --> 00:39:28.140
the local zone from a file.

00:39:28.300 --> 00:39:33.180
This might hit you if you're
using some kind of HTML template

00:39:33.180 --> 00:39:36.580
where you have the HTML already,
and then you're formatting

00:39:36.580 --> 00:39:37.760
in user-supplied data.

00:39:37.780 --> 00:39:44.040
So what an attacker could do is he could
supply his own data to inject malicious

00:39:44.050 --> 00:39:49.830
JavaScript into the HTML displayed,
for example, in your UI web view,

00:39:49.840 --> 00:39:54.260
and cause undesired effects,
or potentially he could read

00:39:54.620 --> 00:39:58.600
arbitrary files off the system,
so anyway,

00:39:58.600 --> 00:40:03.380
you want to avoid using these kind
of HTML templates unless you're

00:40:03.520 --> 00:40:06.420
very certain that your application
won't be subject to these kind

00:40:06.570 --> 00:40:07.920
of cross-site scripting attacks.

00:40:09.780 --> 00:40:11.990
Finally, I also want to mention
the NS Archiver format.

00:40:12.000 --> 00:40:14.760
Now, this format is commonly
used in nib files,

00:40:14.780 --> 00:40:19.410
and some people might even use
it as a simple document type.

00:40:19.490 --> 00:40:23.670
But it really acts as frozen code,
and it's not intended for

00:40:23.850 --> 00:40:28.280
use as a generic document,
because if an attacker can supply

00:40:28.280 --> 00:40:32.670
arbitrary data to NS Unarchiver,
he can unarchive any number of

00:40:32.800 --> 00:40:37.230
classes that you're not expecting,
and he can probably use

00:40:37.230 --> 00:40:40.780
that to get code execution.

00:40:40.920 --> 00:40:43.750
So instead,
we recommend using property lists,

00:40:43.750 --> 00:40:48.680
whether you're using NS property list
serialization or one of the convenience

00:40:48.680 --> 00:40:52.400
functions in foundation classes,
like write to file.

00:40:55.550 --> 00:40:57.480
So that's untrusted data.

00:40:57.480 --> 00:41:02.310
Let's look at untrusted file
systems very briefly in terms of

00:41:02.310 --> 00:41:04.360
a Mac OS X desktop application.

00:41:04.360 --> 00:41:10.130
So what we have here is a pretty common
example of how an application might

00:41:10.130 --> 00:41:13.990
read or might delete an old cache
file and then create a new cache file.

00:41:14.000 --> 00:41:18.140
This operation probably occurs in the
course of a few milliseconds where

00:41:18.140 --> 00:41:22.420
he's removing the old cache and then
opening and writing the new cache.

00:41:22.970 --> 00:41:26.660
However, in the meantime,
an attacker could create a symlink there.

00:41:26.660 --> 00:41:31.460
The result is when the new cache
file is opened and written,

00:41:31.460 --> 00:41:36.250
the data is actually sent to
the attacker-supplied path.

00:41:36.340 --> 00:41:39.440
This could overwrite
user-created documents,

00:41:39.490 --> 00:41:40.840
causing data loss.

00:41:40.840 --> 00:41:43.680
It could even potentially
decode execution.

00:41:43.680 --> 00:41:48.050
So to prevent this on iPhone,
this is very easy.

00:41:48.050 --> 00:41:49.820
You just stay in your
application container.

00:41:49.820 --> 00:41:51.400
You don't have to worry
about any of this stuff.

00:41:51.480 --> 00:41:52.900
On Mac OS X, you don't have to worry
about any of this stuff.

00:41:52.900 --> 00:41:56.350
On Mac OS X, as David mentioned earlier,
you need to avoid /tmp and

00:41:56.400 --> 00:41:59.620
/library/caches since they're
world-writable locations and

00:41:59.620 --> 00:42:01.520
you're subject to this attack.

00:42:01.580 --> 00:42:05.240
You should really only use these
locations if it's absolutely

00:42:05.360 --> 00:42:09.570
critical that your application share
data that's writable by multiple

00:42:09.710 --> 00:42:12.170
processes that have multiple users.

00:42:12.200 --> 00:42:15.670
But if you're only sharing
data amongst one user,

00:42:15.670 --> 00:42:20.480
you should instead use the protected
var folders alternative because

00:42:20.480 --> 00:42:22.880
this is a per-user location.

00:42:22.880 --> 00:42:27.600
So in Cocoa, to do this,
you use the NSTemporaryDirectory API.

00:42:27.630 --> 00:42:33.100
And this will get you a directory that
you're probably already using this API.

00:42:33.100 --> 00:42:37.740
It will give you a directory that is safe
to use on a per-user basis and won't be

00:42:37.770 --> 00:42:40.350
subject to race conditions like /tmp.

00:42:40.440 --> 00:42:44.880
If you're operating at a lower level,
you can use the CAPI compster.

00:42:44.880 --> 00:42:48.010
If you pass in the
DarwinUserTempter constant,

00:42:48.020 --> 00:42:51.940
you'll get out the same value
as NSTemporaryDirectory.

00:42:52.900 --> 00:42:55.620
If you pass in the
DarwinUserCaster constant,

00:42:55.660 --> 00:43:00.110
you'll get out a cache directory that's
per-user that's constant across boot.

00:43:00.120 --> 00:43:03.370
And we really recommend you use this
instead of /library slash caches.

00:43:03.400 --> 00:43:07.050
And if you're interested in what
one of these locations looks like,

00:43:07.170 --> 00:43:10.410
you can use the shell tool, gitconf,
and you can pass in like

00:43:10.510 --> 00:43:12.980
DarwinUserTempter or
DarwinUserCaster to see what one

00:43:13.120 --> 00:43:14.870
of these locations looks like.

00:43:14.920 --> 00:43:17.580
And as you can see,
they're very unique per-user

00:43:17.800 --> 00:43:20.110
because of the UUID that's in there.

00:43:22.320 --> 00:43:24.320
So that's managing untrusted data.

00:43:24.320 --> 00:43:27.420
Let's look at what you can
do in your application to

00:43:27.550 --> 00:43:29.760
harden it against attackers.

00:43:29.760 --> 00:43:31.900
Some of these are very easy.

00:43:31.920 --> 00:43:35.590
So first of all,
we recommend the use of privilege

00:43:35.590 --> 00:43:38.190
separation where applicable.

00:43:38.200 --> 00:43:41.760
A privilege separation involves
factoring your application

00:43:41.760 --> 00:43:43.490
into multiple components.

00:43:43.540 --> 00:43:46.710
And when you do that,
each component has less code

00:43:46.900 --> 00:43:48.860
and reduces attack surface.

00:43:48.860 --> 00:43:52.050
But you have to ask,
where do you do this factoring?

00:43:52.100 --> 00:43:55.740
So you want to factor out things
that are extremely high risk,

00:43:55.740 --> 00:43:56.590
for example.

00:43:56.660 --> 00:44:00.220
And these high risk components can
be easily sandboxed or they can

00:44:00.220 --> 00:44:02.170
be run with reduced privileges.

00:44:02.200 --> 00:44:04.580
And I'll give you an
example use case for that.

00:44:04.640 --> 00:44:07.210
And with these privilege
separated helpers,

00:44:07.210 --> 00:44:10.190
you're probably going to
be doing communication over

00:44:10.190 --> 00:44:12.200
CF message port or local socket.

00:44:12.200 --> 00:44:17.360
Additionally, in Snow Leopard,
we're introducing a service management

00:44:17.380 --> 00:44:22.070
API that makes adding jobs and
privileged helpers much easier.

00:44:22.080 --> 00:44:24.330
Because you can just use API.

00:44:24.560 --> 00:44:27.600
Previously,
you had to use an authorization execute

00:44:27.600 --> 00:44:31.950
with privileges trampoline to install
a P list directly into launch day.

00:44:32.350 --> 00:44:34.500
And you no longer need to
do that in Snow Leopard.

00:44:34.650 --> 00:44:38.240
However, you will need to opt into code
signing because the application has

00:44:38.340 --> 00:44:41.420
to trust which job it's starting
and the job has to trust which

00:44:41.420 --> 00:44:43.690
application it's communicating with.

00:44:43.700 --> 00:44:48.200
So both of those processes
need to be code signed.

00:44:48.750 --> 00:44:51.240
Additionally,
you will need to still obtain

00:44:51.240 --> 00:44:53.740
rights to add a helper.

00:44:53.980 --> 00:44:56.740
And that is the add privilege
job authorization right.

00:44:56.740 --> 00:45:00.740
And the application would pre-authorize
then call the service management API.

00:45:02.890 --> 00:45:06.320
So let's look at a couple of use
cases that are very commonly used

00:45:06.780 --> 00:45:10.640
where privilege separation would
help you in your application.

00:45:10.750 --> 00:45:12.580
The first is authorized tasks.

00:45:12.750 --> 00:45:15.980
If you currently have an authorized task,
you may be using authorization

00:45:16.070 --> 00:45:17.340
execute with privileges.

00:45:17.490 --> 00:45:20.050
You may be using a set
UID or self-repairing tools.

00:45:20.390 --> 00:45:22.560
We don't recommend that
you do that because,

00:45:22.630 --> 00:45:25.090
as David mentioned,
especially with set UIDs,

00:45:25.090 --> 00:45:30.100
that's generally very difficult to do
correctly and often will lead to security

00:45:30.100 --> 00:45:32.680
vulnerabilities in your application.

00:45:32.820 --> 00:45:34.860
So instead,
we recommend using one of these

00:45:35.040 --> 00:45:39.130
privileged helpers and sending an
authorization ref in external form over

00:45:39.450 --> 00:45:41.820
a CF message port or over a local socket.

00:45:41.820 --> 00:45:44.760
And if you want,
you can look at the better authorization

00:45:44.760 --> 00:45:49.370
sample on developer.apple.com,
which uses a local Unix socket to pass

00:45:49.770 --> 00:45:52.560
over a serialized authorization ref.

00:45:52.640 --> 00:45:55.140
And you can just grab that
source and use it right there.

00:45:56.720 --> 00:45:59.750
So additionally,
another common use case for

00:45:59.750 --> 00:46:02.540
privilege separation is if,
for example,

00:46:02.540 --> 00:46:06.990
you have a really complex media
format or document format and you're

00:46:07.030 --> 00:46:08.540
a little nervous about your code.

00:46:08.540 --> 00:46:17.080
You're not sure that it's 100% secure
against any kind of corrupted data.

00:46:17.360 --> 00:46:22.240
So, for example,
we use this internally on H.264 decoding,

00:46:22.240 --> 00:46:26.910
and we have this thing called
the SBX Profile Pure Computation.

00:46:26.910 --> 00:46:31.380
And you can pass this in Sandbox init,
and it will create a sandbox

00:46:31.910 --> 00:46:36.560
for that helper that will only
be used for pure computation.

00:46:36.560 --> 00:46:41.040
And file system and network
access is not allowed.

00:46:41.050 --> 00:46:44.070
And in such a case,
you would receive the raw data,

00:46:44.070 --> 00:46:47.340
maybe off the network or
from the main application.

00:46:47.340 --> 00:46:51.290
And you would return these
parsed and vetted structures.

00:46:51.290 --> 00:46:55.810
Basically, the meat of the decoding
occurs in this helper tool.

00:46:59.100 --> 00:47:01.900
So now let's look at some security
hardening compiler flags that

00:47:02.260 --> 00:47:04.380
David briefly mentioned earlier,
and these provide you

00:47:04.380 --> 00:47:05.550
with some free security.

00:47:05.560 --> 00:47:09.060
So the first is defortify
source equals two.

00:47:09.060 --> 00:47:13.400
Now, this converts some certain insecure
string functions like the ones

00:47:13.400 --> 00:47:15.960
I showed earlier into a secure variant.

00:47:15.960 --> 00:47:21.980
Now, this isn't a silver bullet because
the compiler needs to determine

00:47:22.100 --> 00:47:25.790
at compile time what the size
of the destination buffer is.

00:47:26.460 --> 00:47:30.470
And the compiler is not as intelligent
as the developer who wrote the code is,

00:47:30.470 --> 00:47:33.380
so not all of these
uses will be converted.

00:47:33.380 --> 00:47:39.300
So we're actually planning to implement
this by default in Snow Leopard,

00:47:39.300 --> 00:47:42.560
but it's a good idea for you
to use it now to work out any

00:47:42.660 --> 00:47:44.950
possible issues you should have.

00:47:46.570 --> 00:47:49.760
Second, there's the fstackprotector
compiler flag.

00:47:49.780 --> 00:47:52.400
This will add stack
canaries to your code,

00:47:52.400 --> 00:47:56.560
and what a stack canary does is it
sits like a little canary right before

00:47:56.680 --> 00:47:58.090
the return address on the stack.

00:47:58.180 --> 00:48:01.410
And if an attacker manages
to overwrite the stack and

00:48:01.430 --> 00:48:04.570
overwrite that return address,
the canary dies.

00:48:04.680 --> 00:48:07.230
And when the canary dies,
the program dies.

00:48:07.240 --> 00:48:11.130
We're also planning on implementing
this by default in Snow Leopard,

00:48:11.140 --> 00:48:15.970
and again, we recommend using it now to
make sure that there aren't

00:48:15.980 --> 00:48:17.980
any issues with your program.

00:48:17.980 --> 00:48:22.460
For example, in Snow Leopard,
when we turned these things on,

00:48:22.460 --> 00:48:26.210
in one or two applications,
we found that we actually had a latent

00:48:26.210 --> 00:48:32.650
overflow that occurred that we were
able to fix because we turned this on.

00:48:34.570 --> 00:48:37.740
Next, there's the linker flag
for position independence.

00:48:37.740 --> 00:48:40.490
David mentioned this briefly.

00:48:40.530 --> 00:48:43.000
It's the PI flag,
and it will randomize the

00:48:43.000 --> 00:48:46.440
load address of an executable,
your executable.

00:48:46.440 --> 00:48:51.770
And currently, by default,
all system libraries will be randomized.

00:48:52.010 --> 00:48:57.530
However, you're executable,
and whatever libraries that you load

00:48:57.530 --> 00:49:01.480
on the fly or whatever libraries
you supply won't be randomized.

00:49:01.480 --> 00:49:06.050
So by turning this on,
you improve library randomization,

00:49:06.170 --> 00:49:10.150
and that makes it much more
difficult for an attacker to use

00:49:10.660 --> 00:49:15.980
these return to libc attacks,
where he jumps into known code

00:49:15.980 --> 00:49:22.050
that performs some operation
he can use to his benefit.

00:49:23.940 --> 00:49:27.040
Finally, there's a warning flag,
W Format Security.

00:49:27.080 --> 00:49:30.210
And this warning flag just
provides additional warnings at

00:49:30.210 --> 00:49:35.620
compile time that will warn you if
you're maybe using format string

00:49:35.620 --> 00:49:37.180
functions in an insecure manner.

00:49:41.780 --> 00:49:45.040
So to summarize what Dave and
I talked about today,

00:49:45.040 --> 00:49:48.100
the security of OS X and iPhone
is continually improving.

00:49:48.100 --> 00:49:52.710
And if your applications opt in early,
they can get the benefit of these

00:49:52.710 --> 00:49:56.650
improvements and ease the process.

00:49:58.180 --> 00:50:00.820
Additionally,
if your application is receiving files,

00:50:00.820 --> 00:50:04.540
we recommend that you turn on quarantine,
whether programmatically

00:50:04.550 --> 00:50:06.610
or via the Info.plist.

00:50:07.320 --> 00:50:09.440
Especially with iPhone
and mobile devices,

00:50:09.440 --> 00:50:11.560
you should expect a malicious network.

00:50:11.620 --> 00:50:14.900
So never trust DNS.

00:50:14.980 --> 00:50:17.560
Rely on cryptographically
secure communication.

00:50:19.130 --> 00:50:21.540
If you're handling
untrusted data or files,

00:50:21.540 --> 00:50:23.710
be sure to avoid things
like buffer overflows,

00:50:23.790 --> 00:50:25.700
integer overflows,
format string vulnerabilities.

00:50:25.700 --> 00:50:29.260
And if you can,
use privilege separation to put the meat

00:50:29.550 --> 00:50:34.820
of your processing code in a separate
process and sandbox that process.

00:50:34.820 --> 00:50:37.240
Finally,
we showed you some compiler flags

00:50:37.240 --> 00:50:41.390
you can use to provide additional
security hardening for your application

00:50:41.510 --> 00:50:43.810
with very little effort by you,
the developer.

00:50:47.020 --> 00:50:51.170
Here's some contact information that you
can use to get additional information.

00:50:52.880 --> 00:50:53.950
We recommend these sessions.

00:50:53.960 --> 00:50:58.680
You might want to see them
if you're really interested

00:50:58.680 --> 00:50:59.640
in security on the iPhone.

00:51:01.490 --> 00:51:04.970
And we're going to be,
especially in the Mac OS X security labs,

00:51:05.010 --> 00:51:06.740
we recommend these security labs.
WEBVTT

00:00:21.210 --> 00:00:22.340
Howdy.

00:00:22.390 --> 00:00:25.440
I'm Daniel Delwood,
and this is Getting Started with

00:00:25.440 --> 00:00:26.520
Instruments.

00:00:26.650 --> 00:00:30.420
So today we're going to talk about
instruments and try to take you

00:00:30.480 --> 00:00:34.260
from zero to 60 with using the
tool so that you can go out and

00:00:34.260 --> 00:00:38.800
improve your existing Mac and iPhone
applications and really get the best

00:00:38.800 --> 00:00:41.590
performance and efficiency out of them.

00:00:43.160 --> 00:00:45.430
So starting off,
what are we going to talk about today?

00:00:45.430 --> 00:00:48.740
Well, first of all, what is instruments?

00:00:48.890 --> 00:00:50.350
We'll talk about when to use it.

00:00:50.350 --> 00:00:54.290
And then we'll go on to talk about
some key examples or key elements in

00:00:54.290 --> 00:00:57.020
instruments that you need to understand.

00:00:57.020 --> 00:01:01.410
And then we'll use those in
an example workflow demo.

00:01:01.740 --> 00:01:06.360
And then we'll go on to actually
diagnose an existing performance

00:01:06.360 --> 00:01:08.940
problem using sampling technologies.

00:01:08.990 --> 00:01:12.580
And then finally, Lynn will come up to
talk about memory tools,

00:01:12.620 --> 00:01:15.490
analyzing dispatch,
and some other features we don't

00:01:15.490 --> 00:01:17.180
have time to fully cover today.

00:01:17.630 --> 00:01:20.620
So first of all, what is Instruments?

00:01:20.720 --> 00:01:22.880
Well, Instruments is a powerful,
convenient,

00:01:23.060 --> 00:01:29.140
and flexible meta-analysis tool
with the simplicity of an IAP.

00:01:29.260 --> 00:01:31.840
Now, I know that sounds like
a lot of a mouthful,

00:01:31.990 --> 00:01:34.960
but what I want you to understand
is that it's an analysis tool,

00:01:35.130 --> 00:01:37.000
not just a performance tool.

00:01:37.110 --> 00:01:39.990
So you can look into the
behavior of your application,

00:01:40.150 --> 00:01:45.290
as well as gather performance
metrics such as CPU usage,

00:01:45.290 --> 00:01:47.450
memory usage, etc.

00:01:47.670 --> 00:01:50.470
Now, by simplicity,
what we've tried to do is put a

00:01:50.470 --> 00:01:57.070
unifying user interface on top of
analyzing both the Mac and the iPhone.

00:01:57.330 --> 00:02:02.630
And so, while we're going to talk
exclusively about Mac in these sets,

00:02:02.630 --> 00:02:06.890
in these examples, in these demos,
everything we talk about today is

00:02:06.890 --> 00:02:14.300
directly applicable to the iPhone,
and will be necessary for understanding

00:02:14.300 --> 00:02:16.270
lots of the stuff later on this
week in the iPhone-specific talks.

00:02:16.620 --> 00:02:19.940
So first of all,
when would you use Instruments?

00:02:20.070 --> 00:02:22.600
Well,
if your application is performing badly,

00:02:22.600 --> 00:02:25.060
if it's spinning,
you may want to find out

00:02:25.060 --> 00:02:29.230
what's taking the time,
what part of your code is responsible.

00:02:29.840 --> 00:02:32.620
What files is your application
accessing during an operation?

00:02:32.790 --> 00:02:35.340
This is a behavioral question
that you can also ask.

00:02:35.380 --> 00:02:36.510
Maybe it's when you click a button.

00:02:36.620 --> 00:02:39.570
Maybe you're interested in
files accessed on launch.

00:02:39.570 --> 00:02:42.410
Is your application leaking memory?

00:02:42.630 --> 00:02:44.660
When or how much is your method called?

00:02:44.660 --> 00:02:47.140
Again, it's also about behavior analysis.

00:02:47.250 --> 00:02:50.610
Is your application causing
lots of paging on the system?

00:02:50.620 --> 00:02:55.080
Or maybe it's just time to optimize
and you want to get that low-hanging

00:02:55.080 --> 00:02:58.980
fruit to get your performance
up and a better running app.

00:03:00.490 --> 00:03:04.280
So Instruments can help with these
because of the following characteristics.

00:03:04.340 --> 00:03:07.160
First of all,
it's got event-driven profiling.

00:03:07.220 --> 00:03:10.360
And this is where you really sort
of cast out your net and say,

00:03:10.410 --> 00:03:12.290
I'm interested in certain events.

00:03:12.350 --> 00:03:17.250
And instead of polling for those events,
Instruments waits for them to happen

00:03:17.580 --> 00:03:19.980
and reports them instantly to you.

00:03:21.000 --> 00:03:23.570
There's live analysis,
which allows you to both run

00:03:23.570 --> 00:03:27.460
instruments and your target
application at the same time,

00:03:27.460 --> 00:03:29.060
and really interact with both.

00:03:29.060 --> 00:03:33.300
So if you want to click a button and
see what happens and analyze the data,

00:03:33.300 --> 00:03:34.460
you can do that.

00:03:34.670 --> 00:03:38.160
We've got time correlation,
so you can see different types

00:03:38.160 --> 00:03:43.680
of data in time and see when they
happened corresponding to each other.

00:03:44.930 --> 00:03:52.450
We've got many powerful data
mining abilities for you to

00:03:52.450 --> 00:03:52.450
really dig in and find out what
part of your code is responsible.

00:03:53.340 --> 00:03:57.030
And the whole goal of all of this is to
streamline your workflow so that you can

00:03:57.140 --> 00:04:02.480
very quickly move from editing in Xcode,
building, analyzing,

00:04:02.630 --> 00:04:06.470
finding out what your problems are,
and fixing, and really just completing

00:04:06.470 --> 00:04:07.720
the cycle there.

00:04:08.210 --> 00:04:11.180
Lastly, Instruments harnesses
the power of DTrace.

00:04:11.180 --> 00:04:12.870
And you may have heard
of this technology.

00:04:12.980 --> 00:04:14.600
It was introduced in Leopard.

00:04:14.710 --> 00:04:17.440
And it's a very, very cool thing.

00:04:17.600 --> 00:04:20.320
Now, what is DTrace?

00:04:20.810 --> 00:04:25.000
Well, it's a dynamic tracing
framework originally developed

00:04:25.000 --> 00:04:26.700
by our friends at Sun.

00:04:26.740 --> 00:04:29.410
Now, by dynamic,
this means that you don't

00:04:29.410 --> 00:04:30.780
have to recompile your code.

00:04:30.780 --> 00:04:33.900
You can instrument any running code.

00:04:33.910 --> 00:04:37.900
So this can be debug, release, anything.

00:04:38.440 --> 00:04:43.040
The idea is that DTrace
is based on probes.

00:04:43.210 --> 00:04:46.140
And these probes you can
specify at different points,

00:04:46.400 --> 00:04:49.440
whether that's a system call
or the beginning of a function

00:04:49.520 --> 00:04:51.080
or the end of a function.

00:04:51.080 --> 00:04:52.700
Very flexible.

00:04:52.700 --> 00:04:55.840
And when the event occurs,
these probes fire.

00:04:57.720 --> 00:05:00.820
When they fire,
they execute script actions,

00:05:00.840 --> 00:05:05.290
and these can be very powerful
things like gathering a backtrace.

00:05:05.290 --> 00:05:08.680
You can find out the parameters to
the function that you're probing.

00:05:08.680 --> 00:05:11.850
And it's just overall very powerful.

00:05:11.850 --> 00:05:15.000
And what we've tried to do is
bring that to you in Instruments,

00:05:15.040 --> 00:05:19.360
letting you use the power of DTrace
without having to understand descripting.

00:05:19.360 --> 00:05:21.380
Although if you do
understand descripting,

00:05:21.380 --> 00:05:24.260
you can build your own custom
instruments and go from there.

00:05:24.610 --> 00:05:27.180
If you'd like to learn more
about DTrace on Mac OS X,

00:05:27.180 --> 00:05:29.250
there's a session later on this week.

00:05:31.140 --> 00:05:33.260
So let's talk about some instrumentation.

00:05:33.310 --> 00:05:36.540
Well, first of all,
built on top of the Darwin Foundation,

00:05:36.570 --> 00:05:41.080
we've got lots of instruments
built on the OS X framework,

00:05:41.110 --> 00:05:44.600
such as lots of memory tools,
which we'll talk about later,

00:05:44.600 --> 00:05:49.210
sampling tools to find out where your
application is spending its time.

00:05:49.650 --> 00:05:54.310
And then very specific tools,
such as the OpenGL driver monitor or

00:05:54.310 --> 00:05:57.810
the user interface event recorder.

00:05:58.190 --> 00:05:59.960
And then finally,
on top of the power of DTrace,

00:06:00.130 --> 00:06:03.330
there's a lot of tools
such as file activity,

00:06:03.360 --> 00:06:07.390
instruments, garbage collection,
statistics that you can get, and also,

00:06:07.390 --> 00:06:11.660
like I said, you can build your own
DTrace-based instruments.

00:06:12.460 --> 00:06:15.440
I've been talking a lot
about what instruments is.

00:06:15.440 --> 00:06:18.460
What are some of the key elements you
should understand before using this?

00:06:18.670 --> 00:06:22.130
When you start up instruments,
the first thing you'll see

00:06:22.270 --> 00:06:23.780
is the trace templates.

00:06:23.780 --> 00:06:26.100
These are task starting points.

00:06:26.240 --> 00:06:29.030
So the idea is when you
usually launch this tool,

00:06:29.120 --> 00:06:33.000
you've got a question,
an idea in mind that you want to solve.

00:06:33.100 --> 00:06:35.780
If you're looking for leaks,
there's a trace template for that.

00:06:35.980 --> 00:06:38.920
And maybe you're just curious
about the performance of core

00:06:38.920 --> 00:06:40.450
data in your application.

00:06:40.570 --> 00:06:44.720
So these are very targeted templates
to give you a starting point to

00:06:44.850 --> 00:06:47.590
the questions you may want to ask.

00:06:47.960 --> 00:06:52.010
I've mentioned an instrument many times,
and what is it?

00:06:52.150 --> 00:06:54.600
Well, it's really a tool
that just gathers data.

00:06:54.670 --> 00:06:57.580
Now, this is analogous to a
doctor's stethoscope,

00:06:57.770 --> 00:07:01.620
which you'd use to find out the
behavior and really diagnose

00:07:01.620 --> 00:07:03.960
what's going on with your heart.

00:07:04.670 --> 00:07:06.990
And in Instruments,
we've got lots of things,

00:07:07.150 --> 00:07:10.540
such as this file activity instrument,
which records open, close,

00:07:10.540 --> 00:07:14.200
and stat operations,
and lets you dig into those.

00:07:14.200 --> 00:07:16.400
Now, where do you get the instruments?

00:07:16.400 --> 00:07:19.200
We've got a library,
and this lists all of

00:07:19.200 --> 00:07:20.940
our instrumentation.

00:07:20.940 --> 00:07:24.310
So if you're interested in sampling,
there's tools for that.

00:07:24.400 --> 00:07:25.930
There's memory tools.

00:07:25.990 --> 00:07:29.030
And with the search field,
you can quickly filter down

00:07:29.030 --> 00:07:30.880
to what you're interested in.

00:07:30.900 --> 00:07:33.880
Say you're interested in everything
that has to do with files.

00:07:34.290 --> 00:07:35.010
You can find those.

00:07:35.080 --> 00:07:37.480
And finally, they're sorted by category.

00:07:37.480 --> 00:07:40.040
So if you're not exactly sure
what the instrument's called,

00:07:40.040 --> 00:07:43.040
and you need to take a look
at the categories and see what

00:07:43.390 --> 00:07:46.620
type of data you're looking for,
you can find those too.

00:07:49.470 --> 00:07:50.800
So, all right.

00:07:50.800 --> 00:07:55.820
The trace document is where all your
instruments and data really gets stored.

00:07:55.890 --> 00:07:58.130
And so,
as with most document-based applications,

00:07:58.130 --> 00:08:01.870
this is the thing that you will
spend most of your time dealing with,

00:08:01.870 --> 00:08:03.930
that you can save,
that you can mail off to

00:08:03.930 --> 00:08:05.280
your fellow developers.

00:08:05.280 --> 00:08:08.530
And there's a couple parts
of it I'd like to call out.

00:08:09.370 --> 00:08:12.910
First of all, the track view, which,
like I said earlier,

00:08:12.910 --> 00:08:17.220
gives you time-correlated data,
sort of a high-level overview over

00:08:17.370 --> 00:08:19.910
what type of data you're gathering.

00:08:19.920 --> 00:08:23.240
And then if you're really
trying to dive in and analyze,

00:08:23.240 --> 00:08:25.810
there's the detail views at the bottom.

00:08:25.830 --> 00:08:29.890
And this is where all of the data is
organized in three different views,

00:08:29.890 --> 00:08:33.440
the table view, the outline view,
and the diagram view.

00:08:35.790 --> 00:08:38.090
So, all right, I've told you about lots
of the key elements.

00:08:38.300 --> 00:08:41.530
Let's see these together
in just an example workflow

00:08:41.570 --> 00:08:43.500
demo and put them together.

00:08:43.640 --> 00:08:46.830
So,
I'm going to go over to the demo machine.

00:08:50.500 --> 00:08:59.770
And I'm just going to
fire up Instruments.

00:08:59.770 --> 00:08:59.770
So -- oh, other one.

00:09:09.450 --> 00:09:12.670
So I just launched Instruments,
and you can see the

00:09:12.780 --> 00:09:14.050
template chooser comes up.

00:09:14.180 --> 00:09:15.670
And there's a bunch of
different things I can choose.

00:09:15.720 --> 00:09:18.000
I can choose leaks or core data.

00:09:18.080 --> 00:09:19.910
And there's also
iPhone-specific templates,

00:09:19.970 --> 00:09:24.720
such as the core animation template
and the OpenGL ES template.

00:09:25.000 --> 00:09:26.560
And you can create your
own user templates.

00:09:26.660 --> 00:09:30.910
But for now, I'm just going to select
blank and hit choose.

00:09:31.400 --> 00:09:34.040
And I'm at a blank trace document.

00:09:34.070 --> 00:09:35.820
Well,
what's the first thing I want to do?

00:09:35.840 --> 00:09:38.390
I want to ask myself what
data I'm interested in,

00:09:38.580 --> 00:09:42.260
and in this case,
I'm just going to start recording Sketch.

00:09:42.330 --> 00:09:45.400
I'm interested in how
Sketch saves its documents.

00:09:45.400 --> 00:09:47.520
Does it use the AppKit document model?

00:09:47.520 --> 00:09:50.250
Maybe I just want to backtrace.

00:09:50.260 --> 00:09:54.420
So, starting from here,
I'm going to start by going to

00:09:54.420 --> 00:10:01.470
the toolbar and selecting the
library and typing in "file."

00:10:02.210 --> 00:10:04.860
So here are all the instruments
that deal with files.

00:10:04.890 --> 00:10:08.240
I'll bring the file activity instrument
and apply it to my trace document.

00:10:08.430 --> 00:10:10.030
Drag and drop.

00:10:10.390 --> 00:10:13.060
But since we can record
multiple types of data at once,

00:10:13.130 --> 00:10:16.640
I'll also select the CPU monitor,
which is a lot like what

00:10:16.640 --> 00:10:18.860
you'd see in Activity Monitor.

00:10:18.860 --> 00:10:19.860
Oops.

00:10:20.100 --> 00:10:21.800
All the way.

00:10:22.600 --> 00:10:28.740
And I'll go ahead and look
for user interface recorder.

00:10:28.880 --> 00:10:32.420
Now, this will allow me to find out
when the file activities happened

00:10:32.420 --> 00:10:37.080
while viewing at the same time
what I did in the user interface.

00:10:37.080 --> 00:10:39.660
All right,
so I've answered the first question,

00:10:39.660 --> 00:10:41.100
what do I want to record?

00:10:41.100 --> 00:10:44.040
Second question is,
where do I want to get the data from?

00:10:44.560 --> 00:10:47.140
Now, from the toolbar,
there's this target chooser,

00:10:47.140 --> 00:10:49.110
and I can either attach
to a running process,

00:10:49.110 --> 00:10:51.240
or I can launch an executable.

00:10:51.240 --> 00:10:53.180
In this case, I'll launch Sketch.

00:10:56.230 --> 00:10:58.800
So I hit record.

00:10:58.800 --> 00:11:03.040
And Sketch immediately launches an
instrument and starts recording data.

00:11:03.040 --> 00:11:06.530
I'm going to move Sketch over
so you can see that it's already

00:11:06.530 --> 00:11:07.840
gathering data in the background.

00:11:08.750 --> 00:11:13.240
And I'm just going to do something
interesting by drawing two rectangles.

00:11:13.280 --> 00:11:14.500
Fun.

00:11:14.500 --> 00:11:16.490
And I'll hit command S.

00:11:16.560 --> 00:11:19.660
And you'll notice in the background
that my command S was recorded

00:11:19.670 --> 00:11:21.490
by the user interface recorder.

00:11:22.310 --> 00:11:27.190
I'll type in test, save it to my desktop,
and replace.

00:11:28.810 --> 00:11:31.080
And there we go.

00:11:31.180 --> 00:11:34.780
So I'll go ahead and quit my
application and take a look at the data.

00:11:34.780 --> 00:11:37.410
And first off,
you can see in the track view

00:11:37.410 --> 00:11:39.860
when the file activities occurred.

00:11:40.070 --> 00:11:42.890
And so I'll go ahead and
click on file activity.

00:11:43.060 --> 00:11:47.070
And you can see in the detail view
that the data is updated to show

00:11:47.070 --> 00:11:52.140
me a lot of detailed information,
such as when I open info P lists,

00:11:52.410 --> 00:11:55.560
and if I'm interested in even
more data about a specific event,

00:11:55.730 --> 00:11:59.190
I can bring in the extended
detail view from the toolbar.

00:12:00.500 --> 00:12:08.500
[Transcript missing]

00:12:08.820 --> 00:12:12.490
Now, since I'm interested in, well,
the test document I saved out,

00:12:12.490 --> 00:12:17.850
I'm going to go to the filter box
in the bottom and type in test.

00:12:18.050 --> 00:12:22.230
And it immediately filters
down to the saving of my file.

00:12:22.340 --> 00:12:24.090
And if we take a look
at the stack trace here,

00:12:24.140 --> 00:12:27.440
we see, well, first at the top,
that the file descriptor is 19.

00:12:27.580 --> 00:12:31.300
And it looks like we are using
the NSDocumentController model.

00:12:31.480 --> 00:12:33.130
Very cool.

00:12:34.200 --> 00:12:35.100
All right.

00:12:35.100 --> 00:12:38.040
So we've looked at some of the
behavior of our application.

00:12:38.040 --> 00:12:41.500
But sometimes it's not
necessarily that simple.

00:12:41.500 --> 00:12:44.260
You may have a bug that
reproduces one in five times,

00:12:44.430 --> 00:12:47.770
or you may want to go back,
change your code, and then run the same

00:12:48.040 --> 00:12:49.760
trace document against it.

00:12:50.560 --> 00:12:54.510
Well, the user interface recorder
doesn't just record what I did,

00:12:54.570 --> 00:12:56.800
but it allows me to play them back.

00:12:56.800 --> 00:12:59.490
So if you've noticed that the
record button in the top left

00:12:59.490 --> 00:13:01.690
now says drive and record,
I can click it,

00:13:01.690 --> 00:13:05.240
and it's going to repeat what I did,
even though I'm not actually

00:13:05.240 --> 00:13:06.720
touching the machine.

00:13:06.720 --> 00:13:10.680
So it goes over,
it's going to draw my boxes for me.

00:13:12.280 --> 00:13:15.560
And it's gathering other
data in the background,

00:13:15.640 --> 00:13:18.270
the file activity in the CPU monitor.

00:13:19.220 --> 00:13:24.010
All the while,
my user interface recorder is replaying

00:13:24.030 --> 00:13:26.200
the events from the first run.

00:13:28.320 --> 00:13:29.040
So there we go.

00:13:29.040 --> 00:13:31.520
The idea is really to
simplify your workflow.

00:13:31.720 --> 00:13:37.090
I'm gonna go ahead and
go back to the slides.

00:13:41.300 --> 00:13:42.800
So what are we talking about here?

00:13:42.820 --> 00:13:47.550
Well, the idea is really to get you
familiar with setting up a trace

00:13:47.550 --> 00:13:51.390
document and using instruments by
first asking what data do you want?

00:13:51.430 --> 00:13:55.010
This helps you decide what type
of instrumentation you want

00:13:55.010 --> 00:13:59.120
to use and really filter down
to exactly that problem set.

00:14:00.210 --> 00:14:02.310
Second, what are you going to target?

00:14:02.310 --> 00:14:05.320
This, in our case, was Sketch,
but this gives you the

00:14:05.390 --> 00:14:09.240
context for your trace,
whether it's all processes on the system,

00:14:09.240 --> 00:14:13.220
a single launch process,
or a process that's already running.

00:14:14.640 --> 00:14:17.230
And finally,
the goal of all this is just to simplify

00:14:17.580 --> 00:14:22.850
your workflow by giving you this record,
iterate, and repeat model.

00:14:23.320 --> 00:14:27.900
The whole goal, to take you from this,
a blank template, to this,

00:14:27.900 --> 00:14:30.570
where all your data is right
at your fingertips and you

00:14:30.570 --> 00:14:31.930
can solve your problem.

00:14:32.490 --> 00:14:36.540
So cool, we did a workflow demo,
and you saw how to use Instruments,

00:14:36.540 --> 00:14:39.750
but let's use it to solve an
existing performance problem.

00:14:40.220 --> 00:14:43.960
So for sampling,
this is a very common technology to use

00:14:43.970 --> 00:14:49.690
to find out why an application is running
slow and where it's spending its time.

00:14:49.810 --> 00:14:52.380
So I'm going to go back
to the demo machine here.

00:14:53.780 --> 00:14:59.450
and open up a project
called Image Enhance.

00:14:59.860 --> 00:15:03.780
And so I'll just build and run
this and explain what it does.

00:15:03.780 --> 00:15:07.360
The idea here is that you've got
a lot of low contrast images,

00:15:07.360 --> 00:15:09.410
and you'd like to improve them.

00:15:09.410 --> 00:15:12.060
And I'll just select some images.

00:15:12.060 --> 00:15:14.400
You can see that they're
not all that great.

00:15:14.400 --> 00:15:16.880
The rail in the bottom
left is hardly visible.

00:15:16.880 --> 00:15:18.240
This one's just horrible.

00:15:18.240 --> 00:15:20.030
And they really could be improved.

00:15:20.030 --> 00:15:23.360
And so you've heard of
histogram equalization.

00:15:23.360 --> 00:15:26.460
It's a two-pass algorithm
that's very common.

00:15:27.570 --> 00:15:30.760
And while you could use
preexisting implementations of it,

00:15:30.810 --> 00:15:33.140
you'd like to try
implementing it yourself,

00:15:33.170 --> 00:15:36.320
perhaps make some modifications,
and see how fast it runs.

00:15:36.420 --> 00:15:41.420
Unfortunately, in this case,
it runs really ridiculously slow.

00:15:42.010 --> 00:15:45.770
So let's go ahead and sample this
and figure out what's going on.

00:15:46.060 --> 00:15:49.560
So right with an Xcode,
instead of just running,

00:15:49.560 --> 00:15:52.580
I can go up to the Run menu,
and there's a Start with

00:15:52.580 --> 00:15:53.840
Performance tool item.

00:15:53.900 --> 00:15:56.640
And this allows me to choose any of the
Instruments templates that I've created.

00:15:56.640 --> 00:16:01.760
So I'll use the CPU Sampler template,
and my application launches

00:16:01.760 --> 00:16:03.830
right into Instruments.

00:16:03.920 --> 00:16:06.880
It starts recording, and here it is.

00:16:07.110 --> 00:16:10.540
And I'll go ahead and get it
processing so we can see some data.

00:16:11.490 --> 00:16:14.120
So right as I opened the files,
you could see there was a spike in

00:16:14.120 --> 00:16:17.230
CPU usage as it loaded all those files.

00:16:17.720 --> 00:16:22.000
And I can hit enhance and
it starts chugging away.

00:16:22.100 --> 00:16:24.510
So I'll just leave
that in the background.

00:16:24.870 --> 00:16:31.380
So, Sampler, in the track view,
shows me the CPU usage of

00:16:31.380 --> 00:16:34.200
this one single application.

00:16:34.200 --> 00:16:36.730
And in the detail view,
it shows me lots of the

00:16:36.750 --> 00:16:38.580
sample data I've collected.

00:16:38.580 --> 00:16:43.760
And what Sampler does is it takes
backtraces of your application,

00:16:43.760 --> 00:16:47.540
of all the threads,
and it then aggregates these

00:16:47.750 --> 00:16:52.160
so that you can find out
what's spending the most time.

00:16:52.920 --> 00:16:56.200
So, in this case,
I've got a call tree that's showing

00:16:56.200 --> 00:16:59.570
me that most of the time I'm just
sitting in a Mach message trap.

00:16:59.600 --> 00:17:01.920
Well, that's interesting,
but I really want to see

00:17:01.920 --> 00:17:03.950
sort of the top-down,
high-level view of what

00:17:03.950 --> 00:17:05.390
my application's doing.

00:17:05.400 --> 00:17:08.160
So, I'll go ahead and choose
to uninvert the call tree,

00:17:08.400 --> 00:17:11.240
and I'll talk a little bit more
about what this does later.

00:17:11.240 --> 00:17:15.880
But there's a lot of options on the left,
and really geared toward

00:17:15.880 --> 00:17:17.720
data mining your data.

00:17:19.060 --> 00:17:21.840
So here you can see that we're taking
samples of every single thread.

00:17:21.840 --> 00:17:27.180
And since I'm really interested
in focusing on the operations

00:17:27.250 --> 00:17:32.280
that are running on the CPU and
getting my CPU usage down,

00:17:32.280 --> 00:17:34.800
I'm going to select running
sample times instead of sample

00:17:34.800 --> 00:17:36.180
counts from my perspective.

00:17:36.180 --> 00:17:38.670
And again, we'll talk a bit more
about what this does later.

00:17:38.680 --> 00:17:43.080
But it shows that my enhanced operations,
in this case we're using

00:17:43.170 --> 00:17:47.110
NSOperationQueue to do our work,
my enhanced operations are

00:17:47.110 --> 00:17:49.120
taking the majority of the time.

00:17:49.150 --> 00:17:54.110
And if I want to see exactly how,
I can bring in the extended detail

00:17:54.110 --> 00:17:56.690
view to take a look at the stack.

00:17:57.620 --> 00:17:58.210
So here we go.

00:17:58.400 --> 00:17:59.940
We've got a bunch of frames.

00:18:00.060 --> 00:18:04.720
It says that NSOperationStart is
calling EnhanceOperationMain.

00:18:04.860 --> 00:18:09.720
And I'm just going to stop the app,
give our poor little computer a break.

00:18:10.490 --> 00:18:12.880
So main is calling enhance.

00:18:12.930 --> 00:18:15.960
Enhance is calling gather pixel counts.

00:18:16.800 --> 00:18:20.910
And that's calling into
NSBitmap image rep,

00:18:21.050 --> 00:18:22.390
git pixel at xy.

00:18:22.640 --> 00:18:26.550
So I can go ahead and select my code,
and I can even double click

00:18:26.560 --> 00:18:28.000
to go directly there in Xcode.

00:18:28.100 --> 00:18:32.980
And so here's my gather pixel
counts for image rep function.

00:18:33.050 --> 00:18:36.110
And it looks like what we're doing
is the first pass in our two pass

00:18:36.250 --> 00:18:40.290
algorithm by looping through all the
pixels and getting the brightness value.

00:18:40.650 --> 00:18:46.140
However, when we call git pixel at xy,
it seems to be quite slow.

00:18:46.160 --> 00:18:47.500
Why is that?

00:18:47.530 --> 00:18:51.370
Well, instruments from this trace,
we can see that we're

00:18:51.370 --> 00:18:54.750
gathering an app kit lock,
a recursive lock every single

00:18:54.760 --> 00:18:56.470
time we make this call.

00:18:57.090 --> 00:19:01.300
Since our usage case here is that we're
looping through every single pixel,

00:19:01.300 --> 00:19:02.990
we can probably do better.

00:19:03.000 --> 00:19:07.140
So I'm going to open up some
code so I don't actually have

00:19:07.140 --> 00:19:09.470
to write it for you on stage.

00:19:11.390 --> 00:19:18.760
And what we're going to do here is we're
going to gather our raw bitmap data right

00:19:18.760 --> 00:19:23.350
before the loop by calling bitmap data.

00:19:23.350 --> 00:19:27.680
And then, instead of gathering the
brightness by calling getPixelAtXY,

00:19:29.980 --> 00:19:36.490
We will use that data that we
gathered just a minute ago.

00:19:38.350 --> 00:19:45.240
All right, so we save,
go up to the Build menu,

00:19:45.320 --> 00:19:45.330
and select Build and Go.

00:19:46.180 --> 00:19:48.240
And what it does is it launches
right back into the same

00:19:48.240 --> 00:19:49.980
document we were working with.

00:19:50.050 --> 00:19:52.290
Again, to simplify the workflow.

00:19:52.480 --> 00:19:57.490
So I'll choose images,
I'll say enhance them.

00:19:57.710 --> 00:19:58.190
Whoa!

00:19:58.580 --> 00:20:00.600
The first half was very, very fast.

00:20:00.640 --> 00:20:01.640
And that's what we're looking for.

00:20:01.640 --> 00:20:04.100
But the second half is still slow.

00:20:04.200 --> 00:20:09.280
And so this is all about really
iterating and finding the performance

00:20:09.400 --> 00:20:12.480
problems that are taking the most time.

00:20:12.630 --> 00:20:18.520
So if I go back to Instruments,
we can take a look at the sample here.

00:20:18.800 --> 00:20:23.500
Again, it looks like we're
calling git pixel at xy.

00:20:23.560 --> 00:20:26.600
Well,
we're actually calling color at xy first,

00:20:26.880 --> 00:20:29.550
and that calls git pixel at xy.

00:20:29.670 --> 00:20:30.800
Where is this?

00:20:30.870 --> 00:20:35.160
If I double click on the frame,
it takes me directly to the code.

00:20:35.460 --> 00:20:38.380
And I can see this is the second
part of the 2Pass algorithm.

00:20:38.500 --> 00:20:41.090
Well,
I should probably do the same thing.

00:20:41.740 --> 00:20:46.840
So from here,
I simply get the raw image data.

00:20:47.920 --> 00:20:52.470
And instead of calculating
the new color like that,

00:20:52.650 --> 00:20:55.640
I'll use the new data.

00:20:55.970 --> 00:20:58.100
This data pointer right here.

00:20:58.990 --> 00:21:07.920
Okay, so I save, go up, build and go,
and launch it back into the

00:21:08.380 --> 00:21:11.300
same Instruments template.

00:21:11.470 --> 00:21:13.160
So let's see how we did.

00:21:13.310 --> 00:21:15.280
Choose some images.

00:21:17.250 --> 00:21:19.540
Hit enhance, and wow, there we go.

00:21:19.550 --> 00:21:23.110
In fact, we'll probably even get to see
some better contrast images here.

00:21:23.260 --> 00:21:25.230
So that one's much better.

00:21:25.470 --> 00:21:27.340
You can see the bar on the lower left.

00:21:27.390 --> 00:21:29.000
And this, this is a whole lot better.

00:21:29.000 --> 00:21:32.340
So we've succeeded in
improving our performance.

00:21:32.380 --> 00:21:37.070
All right, so back to the slides.

00:21:42.270 --> 00:21:46.200
So let's talk a little
bit more about sampling.

00:21:46.200 --> 00:21:49.780
First off, like I said,
it's a technique to gather

00:21:50.030 --> 00:21:54.280
backtraces for all of your
threads at a given time interval.

00:21:54.280 --> 00:21:57.780
And it gets all of the threads
that are in your application.

00:21:57.800 --> 00:22:02.560
The idea is it's a statistical profiling,
not a function profiling.

00:22:02.570 --> 00:22:07.090
And so if you have very short calls or
calls that you make very infrequently,

00:22:07.100 --> 00:22:09.640
they may not show up
in the sample because,

00:22:09.640 --> 00:22:12.080
well,
they're not taking your application.

00:22:12.280 --> 00:22:12.960
So you can't do that.

00:22:12.960 --> 00:22:14.760
So we're going to talk about
how you can use this tool to

00:22:14.800 --> 00:22:17.120
gather backtraces for all of your
threads at a given time interval.

00:22:17.130 --> 00:22:18.550
The idea is to find
hot spots in your code.

00:22:18.710 --> 00:22:21.750
And the whole goal here is to tell what
your application spends its time doing.

00:22:21.860 --> 00:22:24.220
Or possibly what it's not doing.

00:22:24.370 --> 00:22:30.560
And so if you're in blocking reads
or perhaps you're waiting on a lock,

00:22:30.580 --> 00:22:34.210
you can find out what threads
are waiting on and really

00:22:34.210 --> 00:22:36.510
trace that back to its source.

00:22:38.040 --> 00:22:41.370
So all right, there are a lot of
options there on the left.

00:22:41.460 --> 00:22:45.740
Let's talk about a couple of
them that are the most useful.

00:22:46.530 --> 00:22:49.130
First of all,
if we've got a sample here of, let's say,

00:22:49.330 --> 00:22:51.510
your application Sketch,

00:22:51.840 --> 00:22:56.170
You can see that a lot of the frames
are from AppKit and from HIToolbox,

00:22:56.240 --> 00:22:59.200
and you're kind of
interested in your code.

00:22:59.200 --> 00:23:03.790
So one frame here is
NSApplicationHandleKeyEquivalent,

00:23:04.230 --> 00:23:06.400
which probably is going
to call into your code,

00:23:06.400 --> 00:23:09.390
but it'd take a little
bit of digging to find.

00:23:10.310 --> 00:23:13.380
And SKTGraphicViewMouseDown is your code.

00:23:13.380 --> 00:23:14.770
This is the sort of thing
you're interested in.

00:23:14.790 --> 00:23:18.710
So by using the data mining
abilities of Hyde system libraries,

00:23:18.710 --> 00:23:23.720
you can get those all out of your way and
go directly to what you're looking for.

00:23:26.370 --> 00:23:28.540
So, sample perspective.

00:23:28.600 --> 00:23:30.950
Now,
I toggled this from all sample counts

00:23:31.080 --> 00:23:33.800
to running sample times during the demo.

00:23:33.840 --> 00:23:35.570
What does it do?

00:23:35.790 --> 00:23:38.160
Like I said,
sampling gets backtraces of all

00:23:38.240 --> 00:23:41.650
the threads in your application,
whether they're running on the

00:23:41.790 --> 00:23:43.540
CPU or whether they're not.

00:23:43.800 --> 00:23:49.640
So if you're interested in finding
out where your thread states are,

00:23:49.640 --> 00:23:51.440
then you probably want
to leave it that way.

00:23:51.440 --> 00:23:53.170
You want to have all sample counts on.

00:23:53.200 --> 00:23:56.820
So if you have six threads,
and these four are blocked,

00:23:56.820 --> 00:24:01.600
and these two are running on your cores,
then it'll show you all six,

00:24:01.680 --> 00:24:04.730
and you can see where they're blocked.

00:24:06.160 --> 00:24:08.480
Now, if you're interested only
in the two that are running,

00:24:08.480 --> 00:24:11.500
and you really want to optimize the
time that you're spending on your CPU,

00:24:11.500 --> 00:24:13.940
you can switch this over
to running sample times.

00:24:14.040 --> 00:24:17.650
And the idea is that you
can find out which ones are

00:24:17.650 --> 00:24:20.170
executing and optimize there.

00:24:21.240 --> 00:24:24.040
Again,
the idea is blocked versus running.

00:24:24.320 --> 00:24:29.340
Counts for blocked threads,
set it to running sample

00:24:29.410 --> 00:24:32.230
times for running threads.

00:24:32.910 --> 00:24:34.670
Okay, so what does that look like?

00:24:34.850 --> 00:24:40.920
Well, with this example sketch
sample that we have here,

00:24:42.060 --> 00:24:46.900
You can see that SKT Graphic View,
mouse down, and SKT Graphic View,

00:24:46.900 --> 00:24:49.450
draw rect,
took about the same wall clock time.

00:24:49.450 --> 00:24:56.200
They had about 160, 170 samples.

00:24:56.200 --> 00:24:56.200
So this means that

00:24:56.470 --> 00:25:00.240
From the perspective of Sampler,
they were about the same.

00:25:00.370 --> 00:25:04.640
However, when we switched this
to running sample times,

00:25:04.710 --> 00:25:09.100
we quickly see that draw_rect
spent about three times running

00:25:09.140 --> 00:25:11.540
on the CPU that mouse_down did.

00:25:11.760 --> 00:25:14.880
So this means mouse_down was blocked
a bit more and that draw_rect

00:25:15.110 --> 00:25:16.390
really was doing more work.

00:25:16.560 --> 00:25:20.270
This is probably where we want to
spend our first time optimizing.

00:25:21.870 --> 00:25:24.590
Last thing, call tree inversion.

00:25:24.600 --> 00:25:27.640
Let's talk about call trees a little bit.

00:25:27.640 --> 00:25:31.080
You've got your function
that does something.

00:25:31.190 --> 00:25:33.960
And it takes 800 milliseconds.

00:25:33.960 --> 00:25:38.180
Well, the call tree shows what your
application -- or excuse me,

00:25:38.180 --> 00:25:40.940
what that doing something frame called.

00:25:40.940 --> 00:25:43.870
And you can see how the
time is broken down.

00:25:45.340 --> 00:25:47.520
And it's sort of the top-down view.

00:25:47.590 --> 00:25:49.480
So when you have call
tree and version off,

00:25:49.550 --> 00:25:54.750
you're asking where was overall time
spent and what did my code call?

00:25:54.920 --> 00:25:57.900
Now, if we're interested in sort
of the hotspots in your code,

00:25:58.240 --> 00:26:03.230
perhaps what should I optimize first,
you can see in this example that the

00:26:03.740 --> 00:26:09.580
red circles are taking a lot of time,
and if we added them together,

00:26:09.580 --> 00:26:09.580
we'd probably see that we
wanted to look at them first.

00:26:09.690 --> 00:26:14.840
Well, we can turn Caltree Inversion on
and flip all of that upside down.

00:26:15.450 --> 00:26:19.600
It coalesces the leaf frames
and allows you to find the

00:26:19.780 --> 00:26:23.620
individual hotspots in your code,
and also ask the question,

00:26:23.650 --> 00:26:25.700
what called those hotspots?

00:26:26.030 --> 00:26:28.300
So let's have a concrete example of this.

00:26:28.450 --> 00:26:32.870
Again, with the sketch example we had,
with inversion on,

00:26:32.870 --> 00:26:37.300
you can quickly see at top that
SKT Graphic View Draw Contents in View,

00:26:37.300 --> 00:26:39.770
at least for this sample,
was taking the most

00:26:39.770 --> 00:26:43.110
time running on our CPU,
1,450 milliseconds.

00:26:43.130 --> 00:26:48.510
And also interesting is that right
below it is SKT Graphic View Draw Rect,

00:26:48.510 --> 00:26:52.520
which was where it was
called from most of the time.

00:26:52.800 --> 00:26:54.300
So, all right, that's sampling.

00:26:54.320 --> 00:26:57.880
I'd like to ask Lynn to come
up to talk about memory tools.

00:27:06.120 --> 00:27:07.100
Thank you, Daniel.

00:27:07.190 --> 00:27:10.500
So now that we've seen how to use
Sampler to find hotspots in our

00:27:10.570 --> 00:27:14.470
code in order to optimize them,
let's move on and let's talk about

00:27:14.810 --> 00:27:19.100
a new type of performance problem,
namely memory management.

00:27:19.130 --> 00:27:21.850
Now,
regardless of whether you're programming

00:27:21.850 --> 00:27:25.400
for the iPhone or for the Mac,
memory is a limited resource.

00:27:25.590 --> 00:27:29.300
And as such, it's very important to
manage it efficiently.

00:27:29.360 --> 00:27:33.260
But you might find yourself faced
with some common memory issues

00:27:33.530 --> 00:27:35.730
that prevent you from doing that.

00:27:36.080 --> 00:27:38.160
First is leaked memory.

00:27:38.170 --> 00:27:42.390
This occurs when your program
unintentionally fails to free a region

00:27:42.390 --> 00:27:44.800
of memory when it's done using it.

00:27:44.850 --> 00:27:49.780
Now, as regions of leaked memory accrue,
this could reduce your performance

00:27:49.780 --> 00:27:51.930
due to paging to your disk.

00:27:52.440 --> 00:27:56.500
Second is having a
large memory footprint.

00:27:56.500 --> 00:27:58.910
Now,
your goal when you're doing efficient

00:27:58.950 --> 00:28:03.290
memory management is to keep the
working set of your memory down in order

00:28:03.300 --> 00:28:08.180
to increase the performance of your
application and prevent paging to disk,

00:28:08.330 --> 00:28:11.220
which would, in fact,
reduce this performance.

00:28:11.220 --> 00:28:15.370
And that's why you should avoid
having a large memory footprint.

00:28:15.780 --> 00:28:17.930
Third of all is pointers
to freed objects.

00:28:18.080 --> 00:28:20.600
This can cause many problems.

00:28:20.600 --> 00:28:25.320
For example, your system crashing or your
application crashing when you

00:28:25.320 --> 00:28:27.790
send a message to a freed object.

00:28:28.510 --> 00:28:30.780
Fourth,
and this is a more subtle problem,

00:28:30.880 --> 00:28:32.550
is dynamic memory usage.

00:28:32.550 --> 00:28:38.200
Now, allocating and deallocating
small regions of memory,

00:28:38.200 --> 00:28:42.270
or just allocating and deallocating,
incurs a certain overhead.

00:28:42.270 --> 00:28:45.780
And if you're doing this continuously,
so you're allocating and

00:28:45.880 --> 00:28:50.460
deallocating small regions of memory,
this overheads can accrue and

00:28:50.590 --> 00:28:53.170
cause performance problems.

00:28:53.170 --> 00:28:56.330
What you really want to be doing is
allocating a large region of memory

00:28:56.370 --> 00:28:58.200
and then freeing it when you're done.

00:28:58.400 --> 00:28:59.430
Amen.

00:29:00.060 --> 00:29:06.380
And finally, for garbage collected code,
your garbage collector might fail to

00:29:06.380 --> 00:29:10.500
collect a certain object in a timely
fashion if it has a lot of unnecessary

00:29:10.510 --> 00:29:12.860
references to it from other objects.

00:29:13.020 --> 00:29:19.090
And this is called over-rootedness,
and you want to try to avoid that.

00:29:20.110 --> 00:29:21.590
Five memory problems.

00:29:21.750 --> 00:29:24.900
Three of these are very
pertinent to the iPhone.

00:29:24.920 --> 00:29:27.920
Since you're working
with a smaller memory,

00:29:27.980 --> 00:29:32.460
leaked memory, large footprint,
and dynamic memory usage become

00:29:32.460 --> 00:29:36.880
very noticeable on the iPhone,
so you want to try to avoid them.

00:29:36.920 --> 00:29:38.500
All right.

00:29:38.500 --> 00:29:43.440
So we've talked about all these problems,
and your question is, well,

00:29:43.490 --> 00:29:45.610
since finding these
problems is non-trivial,

00:29:45.690 --> 00:29:48.280
how do you go about finding
them in the first place?

00:29:48.280 --> 00:29:51.600
Well, Instruments tries to simplify
that process for you by providing

00:29:52.000 --> 00:29:53.600
you with the necessary tools.

00:29:53.620 --> 00:29:57.360
First of all,
we have the object alloc instrument.

00:29:57.360 --> 00:30:01.040
And this is a very powerful instrument
in the sense that it tracks all

00:30:01.040 --> 00:30:04.940
of the memory allocations that
are performed by your application.

00:30:04.940 --> 00:30:06.920
And it keeps detailed addresses.

00:30:06.920 --> 00:30:11.850
And it's useful for finding programs
with a large memory footprint

00:30:11.850 --> 00:30:17.300
and which objects are responsible
for causing this large footprint.

00:30:17.320 --> 00:30:22.780
And it helps you find pointers to freed
objects and why your -- whether your

00:30:22.950 --> 00:30:26.360
application is using memory dynamically.

00:30:26.430 --> 00:30:29.370
You can also use it to find
things such as over-released

00:30:29.370 --> 00:30:31.030
or over-retained objects.

00:30:32.640 --> 00:30:35.540
Second is the Leaks Instrument,
which does precisely

00:30:35.540 --> 00:30:39.210
what its name suggests,
which is checking for unreferenced

00:30:39.210 --> 00:30:41.130
memory blocks in your code.

00:30:41.780 --> 00:30:46.000
Now, if you're interested in higher
level statistics for your processes,

00:30:46.020 --> 00:30:49.380
like for example,
the size of the virtual and real

00:30:49.380 --> 00:30:53.340
memories or when your process
is paging in and paging out,

00:30:53.390 --> 00:30:57.370
you will need to use the
memory monitor instrument.

00:30:59.160 --> 00:31:03.080
And since you are more intimately
knowledgeable about your code,

00:31:03.210 --> 00:31:06.410
you might have that one
particular memory problem that

00:31:06.410 --> 00:31:08.440
you're trying to find and solve.

00:31:08.550 --> 00:31:11.060
Now,
Instruments is powerful in a sense that

00:31:11.060 --> 00:31:15.480
it allows you to create your own custom
DTrace instruments that are tailored for

00:31:15.480 --> 00:31:17.810
finding that particular memory problem.

00:31:17.990 --> 00:31:19.940
For example,
you can create a custom DTrace

00:31:19.950 --> 00:31:23.690
instrument that will tell you
when NS Auto Release Pools

00:31:23.690 --> 00:31:25.220
are created or freed.

00:31:25.260 --> 00:31:28.660
And you can also create an instrument
that will tell you when certain

00:31:28.680 --> 00:31:34.100
regions of data are mapped and unmapped
from your process address space.

00:31:35.760 --> 00:31:40.110
Finally, and this is new in Xcode 3.1,
we've introduced the

00:31:40.160 --> 00:31:41.740
Object Graph Instrument.

00:31:41.740 --> 00:31:45.550
Now, for garbage collected code,
it helps you visualize directed cyclic

00:31:45.550 --> 00:31:47.940
graphs of memory block references.

00:31:47.940 --> 00:31:50.880
What this means is that it helps
you find those objects that have

00:31:50.880 --> 00:31:53.880
unnecessary references to them
that will prevent them from getting

00:31:53.880 --> 00:31:56.690
garbage collected in a timely manner.

00:31:57.480 --> 00:31:58.400
All right.

00:31:58.400 --> 00:32:01.640
Let's talk a little bit more
about the ObjectAlloc instrument.

00:32:01.700 --> 00:32:04.640
So ObjectAlloc doesn't only
keep track of objects that

00:32:04.670 --> 00:32:08.880
your application has allocated,
but all regions of memory that have

00:32:08.880 --> 00:32:11.440
been allocated by your application.

00:32:11.440 --> 00:32:13.390
It also keeps track of pointer histories.

00:32:13.440 --> 00:32:20.880
For example, it keeps track of when an
object has been malloc'd,

00:32:20.880 --> 00:32:20.880
freed, retained, released,
or auto-released.

00:32:21.450 --> 00:32:25.080
And it also keeps track of higher
level statistics about certain types

00:32:25.100 --> 00:32:27.320
and certain classes of objects.

00:32:27.440 --> 00:32:31.490
For example, for the class NSString,
it will tell you about all the

00:32:31.510 --> 00:32:35.180
NSString objects that have been
allocated by your application

00:32:35.630 --> 00:32:39.270
versus the net objects that
have been allocated and freed.

00:32:39.370 --> 00:32:43.880
It also keeps track of call trees for
when your objects have been allocated,

00:32:43.880 --> 00:32:46.790
retained, and freed,
and it works with garbage

00:32:46.790 --> 00:32:48.660
collected applications.

00:32:49.750 --> 00:32:52.070
A little bit more about leaks.

00:32:52.250 --> 00:32:55.540
Now,
leaks is a static memory analysis tool,

00:32:55.580 --> 00:32:59.070
which means it's going to suspend your
process and it's going to go through

00:32:59.390 --> 00:33:03.560
all the memory regions in order to find
the ones which have been unreferenced,

00:33:03.590 --> 00:33:06.120
in order to find the
unreferenced memory regions.

00:33:06.160 --> 00:33:09.450
And it works alongside the
ObjectAlloc instrument,

00:33:09.650 --> 00:33:14.090
because ObjectAlloc provides leaks
with the necessary pointer histories

00:33:14.090 --> 00:33:17.700
so that you can find the harder,
more insidious leaks in your code.

00:33:17.830 --> 00:33:20.500
And this is not for garbage collection.

00:33:20.500 --> 00:33:23.850
So, now that we've talked
about what these tools are,

00:33:23.850 --> 00:33:25.540
let's see them in action.

00:33:25.540 --> 00:33:29.560
Switch over to the demo machine.

00:33:30.910 --> 00:33:34.420
All right, so I'm going to actually use
my leaks instrument to try to

00:33:34.420 --> 00:33:37.360
find leaks in my application,
Image Enhance.

00:33:37.490 --> 00:33:40.200
First of all,
I'm going to launch it from Xcode.

00:33:41.580 --> 00:33:44.440
I'll just open it up in Xcode.

00:33:44.710 --> 00:33:48.920
And then I'm going to go
down and start Instruments.

00:33:49.880 --> 00:33:52.390
So the first thing I see, once again,
is the template chooser.

00:33:52.520 --> 00:33:55.540
And what I want to do
is I want to go up here,

00:33:55.600 --> 00:33:58.880
select the leaks template,
and hit Choose.

00:33:59.570 --> 00:34:01.790
Now, as you can see,
the leaks template added two

00:34:01.790 --> 00:34:05.890
instruments to my trace document,
the ObjectAlloc instrument and leaks.

00:34:06.070 --> 00:34:09.090
And as I've said before,
ObjectAlloc is needed to provide

00:34:09.090 --> 00:34:12.230
you with pointer histories
about the leaked objects.

00:34:12.330 --> 00:34:16.420
So up here,
I'm going to choose my target process.

00:34:16.440 --> 00:34:22.920
I'm going to choose executable,
and I'm going to go back and

00:34:22.920 --> 00:34:25.990
find my target application.

00:34:27.420 --> 00:34:29.870
Which I'm guessing hasn't been built yet.

00:34:29.880 --> 00:34:33.540
All right, let me go to Xcode and
launch it from there.

00:34:36.040 --> 00:34:38.740
Okay, so from Xcode,
I'm going to hit Run and

00:34:38.740 --> 00:34:40.400
start with Performance Tool.

00:34:40.420 --> 00:34:43.160
I'm going to select the Leaks template.

00:34:43.500 --> 00:34:45.050
And there we go.

00:34:45.100 --> 00:34:47.940
So here's my application, Image Enhance.

00:34:47.960 --> 00:34:51.010
And let me talk about what you can
see over here in the trace document

00:34:51.410 --> 00:34:53.150
for the object alloc instrument.

00:34:53.340 --> 00:34:56.130
Up here in the track view,
I'm plotting the total objects

00:34:56.140 --> 00:34:59.400
that have been allocated,
sorry, the total bytes that have been

00:34:59.400 --> 00:35:00.780
allocated by my application.

00:35:00.950 --> 00:35:05.510
And in this case,
it's been about 776 kilobytes.

00:35:06.360 --> 00:35:09.170
Down here in my detail views,
the first detail view I'm

00:35:09.170 --> 00:35:10.560
looking at is the table view.

00:35:10.720 --> 00:35:13.710
And as you can see,
it shows me certain statistics

00:35:13.710 --> 00:35:16.150
about my different types of classes.

00:35:16.310 --> 00:35:20.670
For example, for CFString,
I can see the net bytes allocated versus

00:35:20.670 --> 00:35:25.750
the net bytes in proportion to the
overall bytes that have been allocated.

00:35:26.140 --> 00:35:29.090
Down here I'm going to switch over
to my call tree view by clicking

00:35:29.090 --> 00:35:30.680
the icon in the bottom left.

00:35:30.680 --> 00:35:34.020
And the call tree view shows me
all the objects that have been

00:35:34.100 --> 00:35:38.120
allocated and their backtraces
for when these allocations occur.

00:35:38.120 --> 00:35:41.020
And finally,
my diagram view shows me all the

00:35:41.020 --> 00:35:45.290
objects that have been allocated
and their pointer histories.

00:35:45.310 --> 00:35:49.320
For example, if I choose, let's say,
an NSLock and I click

00:35:49.320 --> 00:35:52.930
this arrow right here,
it tells me precisely when the

00:35:52.930 --> 00:35:55.700
NSLock has been allocated in memory.

00:35:56.080 --> 00:35:57.330
All right.

00:35:57.460 --> 00:36:00.800
Well, let's run our application and
see whether we can actually

00:36:00.800 --> 00:36:02.600
use these tools to find leaks.

00:36:02.650 --> 00:36:07.960
I'm going to bring it up here and
I'm going to hit choose images.

00:36:08.130 --> 00:36:10.090
And I'm going to hit open.

00:36:12.310 --> 00:36:16.240
So let's forget about Lease for a second,
and it seems like we have a

00:36:16.240 --> 00:36:19.890
large memory spike over here
in our Object Alloc Instrument.

00:36:20.000 --> 00:36:22.430
So it seems like a more
pressing issue than Lease,

00:36:22.540 --> 00:36:26.200
and let's go in and
investigate it in more detail.

00:36:26.210 --> 00:36:31.010
So I'm going to stop my application,
and I'm going to take a look

00:36:31.010 --> 00:36:33.190
at why this is occurring.

00:36:33.570 --> 00:36:36.350
So, first of all, I'm going to zoom in.

00:36:36.560 --> 00:36:39.380
And as you can see, my working set,
my working memory set

00:36:39.400 --> 00:36:42.390
is about 21 megabytes.

00:36:42.640 --> 00:36:47.730
But in this region over here,
it seems that I'm accumulating a bunch

00:36:47.730 --> 00:36:54.420
of allocated objects that are pushing
my memory up to about 100 megabytes,

00:36:54.450 --> 00:36:59.150
which might reduce my performance if
my application starts paging to disk.

00:36:59.880 --> 00:37:02.100
So if I want to investigate
this in more detail,

00:37:02.100 --> 00:37:04.460
I want to do something
called time filtering.

00:37:04.460 --> 00:37:07.170
And to do that,
I'm going to hit the option key,

00:37:07.200 --> 00:37:13.220
I'm going to click and drag around
the area that I want to investigate.

00:37:13.220 --> 00:37:18.900
If I switch back to my table view,
you realize that the data has been

00:37:18.900 --> 00:37:25.220
refiltered and redrawn to show me
just the data that I've filtered for.

00:37:25.390 --> 00:37:29.790
Now, I want to find which objects are
responsible for this large memory spike.

00:37:29.950 --> 00:37:32.270
And to do that,
I'm actually going to go ahead

00:37:32.330 --> 00:37:34.000
and go to the call tree view.

00:37:34.290 --> 00:37:36.890
And see where these objects
have been allocated.

00:37:36.990 --> 00:37:39.830
So I'm going to hit All Allocations.

00:37:39.950 --> 00:37:41.680
I'm going to click the arrow.

00:37:41.900 --> 00:37:47.510
I'm going to bring up the extended detail
view by clicking the icon in the bottom.

00:37:48.360 --> 00:37:51.790
So if you can see,
it seems that most of my

00:37:51.830 --> 00:37:57.610
objects have been allocated from
this method call in my code.

00:37:57.730 --> 00:38:01.510
Enhanced controller,
thumbnail image for path with size.

00:38:01.870 --> 00:38:05.190
And what this does,
it's creating an image from

00:38:05.190 --> 00:38:09.570
the contents of a file,
and the NS image is going ahead and

00:38:09.570 --> 00:38:12.360
creating an NS bitmap image rep.

00:38:12.910 --> 00:38:17.070
So now we found out that NSBitmap
image reps are responsible

00:38:17.700 --> 00:38:21.670
for about 100 megabytes worth
of allocations in my code.

00:38:21.740 --> 00:38:24.400
So these are the objects
responsible for the spike.

00:38:24.530 --> 00:38:27.590
Now, let's see what I'm doing in my
code to actually cause this spike.

00:38:27.590 --> 00:38:29.780
I'm going to go back to this frame.

00:38:30.000 --> 00:38:31.990
I'm going to double click it.

00:38:32.390 --> 00:38:35.720
And as you can see, this is my thumbnail
image for path method.

00:38:35.760 --> 00:38:39.820
And what it's doing is I'm
loading my original image,

00:38:39.820 --> 00:38:41.940
my large image from file.

00:38:41.940 --> 00:38:46.860
I'm using that large image over
here to create a thumbnail image.

00:38:47.000 --> 00:38:48.860
And after I'm done creating
that thumbnail image,

00:38:48.860 --> 00:38:50.200
I'm releasing my large image.

00:38:50.200 --> 00:38:51.990
All right.

00:38:52.250 --> 00:38:54.040
So I'm releasing this large image.

00:38:54.210 --> 00:38:59.750
Why am I getting the large memory spike,
even though I'm releasing

00:38:59.750 --> 00:39:01.460
the NSBitBap image rep?

00:39:01.580 --> 00:39:04.380
To answer that question,
let's go back to Instruments

00:39:04.380 --> 00:39:08.520
and move to the diagram view.

00:39:08.710 --> 00:39:13.000
And find all the NSBitmap image reps that
have been allocated by my application.

00:39:13.110 --> 00:39:18.640
So down here in the search field,
I'm going to type in NSBitmap image rep.

00:39:18.680 --> 00:39:21.640
I'm going to find the one that
has been allocated from my code,

00:39:21.730 --> 00:39:24.780
or any NSBitmap image rep
allocated from my code,

00:39:24.880 --> 00:39:26.610
such as this one, for example.

00:39:26.690 --> 00:39:28.350
I'm going to hit the arrow.

00:39:28.460 --> 00:39:32.920
Now, as you can see in this view,
this is the pointer history

00:39:32.920 --> 00:39:34.910
for NSBitmap image rep.

00:39:35.000 --> 00:39:37.520
You can see where it's been allocated.

00:39:38.230 --> 00:39:40.970
And if we scroll back up,
you can see when it's allocated,

00:39:41.000 --> 00:39:43.600
it has a retain count of one.

00:39:43.930 --> 00:39:46.800
And you can see when it's been retained,
released.

00:39:46.900 --> 00:39:49.900
And this is when it's released
right before it's freed.

00:39:49.900 --> 00:39:56.340
Now, as you can see,
the NSBitmap image rep is released

00:39:56.340 --> 00:40:01.140
in an NSAutoReleasePool context,
which means that

00:40:01.400 --> 00:40:04.120
When it's created,
it's placed in an NS auto release pool,

00:40:04.120 --> 00:40:09.380
but as my application is running,
my run loop isn't flushing this

00:40:09.380 --> 00:40:12.730
auto release pool in time for me to
get rid of that large memory spike.

00:40:12.760 --> 00:40:16.590
So this is a very easy fix in order
to prevent the spike from happening.

00:40:16.590 --> 00:40:24.430
If I go back to my code,
so if I go back over here, take this out.

00:40:26.190 --> 00:40:28.100
Go back to my code by
double-clicking this frame.

00:40:28.100 --> 00:40:33.710
I can fix this easily by encapsulating
or surrounding where I allocate

00:40:33.710 --> 00:40:38.140
my large image or load it from
file with an NS auto-release pool

00:40:38.140 --> 00:40:40.810
creation and release at the end.

00:40:41.830 --> 00:40:43.720
So I'm going to save.

00:40:43.720 --> 00:40:46.340
I'm going to build.

00:40:46.350 --> 00:40:48.480
And I'm going to start
my application again.

00:40:48.480 --> 00:40:50.560
So I'm going to hit record.

00:40:50.890 --> 00:40:54.200
All right, let's see whether my memory
spike happens this time around.

00:40:54.280 --> 00:40:59.310
I'm going to choose images, hit open.

00:41:01.670 --> 00:41:05.280
So we've seen this
large memory allocation,

00:41:05.280 --> 00:41:07.930
but let's compare it to the
previous run where we had our spike.

00:41:07.990 --> 00:41:11.350
So if I go back to Instruments,
I'm actually going to stop

00:41:11.370 --> 00:41:13.240
the application right now.

00:41:13.240 --> 00:41:16.460
And in order to see your previous run,
all you need to do is pull

00:41:16.500 --> 00:41:18.380
down this triangle right here.

00:41:18.380 --> 00:41:22.820
And I'm going to actually zoom out so
you can see both runs on the same scale.

00:41:22.820 --> 00:41:25.110
So do you see the large
memory spike over here?

00:41:25.110 --> 00:41:26.790
And now it's been eliminated.

00:41:26.800 --> 00:41:27.780
All right.

00:41:28.000 --> 00:41:33.170
So now we've used the ObjectAlloc
instrument to tell us about

00:41:33.350 --> 00:41:36.840
our memory working set,
and we used it to eliminate

00:41:36.840 --> 00:41:38.440
this large memory spike.

00:41:38.580 --> 00:41:47.800
But if we look down here,
it seems that we have a bunch of leaks.

00:41:47.800 --> 00:41:47.800
My leaks instrument tells me that I'm
leaking a whole load of NSStrings.

00:41:48.250 --> 00:41:51.200
So I want to find out where
I'm leaking the strings from.

00:41:51.210 --> 00:41:53.960
So to do that,
I'm going to go back here and

00:41:54.010 --> 00:41:56.320
click on my call tree view.

00:41:56.500 --> 00:42:00.160
In my call tree view,
if I click on this frame right here,

00:42:00.290 --> 00:42:04.640
it shows me that all of my leaked
strings that I've seen are being

00:42:04.640 --> 00:42:07.910
leaked from this method call.

00:42:08.140 --> 00:42:11.000
And it's Enhance, Control,
or Choose Images.

00:42:11.120 --> 00:42:13.000
So let's investigate this in our code.

00:42:13.190 --> 00:42:14.910
We double click.

00:42:15.250 --> 00:42:19.510
You can see that what I'm doing
is I'm allocating a string,

00:42:19.610 --> 00:42:22.300
but I'm never releasing it,
and this is causing my leak.

00:42:22.500 --> 00:42:26.230
And the string here is just the
path name for the thumbnail.

00:42:26.540 --> 00:42:29.720
So, in order to fix this problem,
all I need to do is

00:42:29.720 --> 00:42:31.550
auto-release my string.

00:42:33.900 --> 00:42:41.190
Save, hit Run,
start with Performance Tool, Weeks.

00:42:42.100 --> 00:42:43.360
And here we go.

00:42:43.380 --> 00:42:47.340
So, I'm going to open up
my application again.

00:42:47.400 --> 00:42:52.080
Choose Images, hit Open,
and let's just wait for it and

00:42:52.080 --> 00:42:53.440
see whether any leaks occur.

00:42:53.440 --> 00:42:59.430
All right, so it seems that we
fixed our leaks problem.

00:43:01.900 --> 00:43:05.490
And... or not.

00:43:05.570 --> 00:43:07.160
It seems like I've just
built the wrong project.

00:43:07.290 --> 00:43:11.490
Anyway, if... let's go see what sort
of leaks we have this time.

00:43:11.490 --> 00:43:13.550
It seems we're still
leaking some strings,

00:43:13.550 --> 00:43:17.060
but we've reduced the amount of strings
that we've leaked in the first time,

00:43:17.060 --> 00:43:18.920
which was one problem we've solved.

00:43:19.980 --> 00:43:25.220
Finding leaks is an iterative process.

00:43:25.220 --> 00:43:28.450
So you could fix one leak and find
more leaks and keep iterating and

00:43:28.500 --> 00:43:31.960
continuing to find all the leaks
that your application incurs.

00:43:31.980 --> 00:43:33.860
All right.

00:43:34.040 --> 00:43:37.490
So now that we've seen that how
to use the object alloc instrument

00:43:37.490 --> 00:43:40.980
and the leaks instrument to find
some memory management issues,

00:43:40.980 --> 00:43:44.900
if we could switch back to the slides,
please.

00:43:53.050 --> 00:43:58.080
Let's talk about how Instruments can help
you analyze and leverage new technologies

00:43:58.080 --> 00:44:00.480
that have emerged in Snow Leopard.

00:44:01.520 --> 00:44:04.920
So, as you all know,
the number of cores in

00:44:04.920 --> 00:44:06.740
our devices is increasing.

00:44:06.800 --> 00:44:10.120
And if you want to write
better performing applications,

00:44:10.240 --> 00:44:12.780
your goal is to keep
all these cores busy.

00:44:12.900 --> 00:44:15.370
And to do that,
you need to write applications with

00:44:15.370 --> 00:44:17.180
a higher degree of concurrency.

00:44:17.260 --> 00:44:20.210
The current way to do
that is to use threads.

00:44:20.810 --> 00:44:24.190
But as those of you who have
written multi-threaded code in

00:44:24.190 --> 00:44:27.580
the past should agree with me,
threading is hard.

00:44:27.580 --> 00:44:33.400
It's hard because explicit thread
management is difficult because you have

00:44:33.400 --> 00:44:35.940
no knowledge of the underlying hardware.

00:44:36.060 --> 00:44:39.440
And you might fall into the
trap of underutilizing your CPUs

00:44:39.440 --> 00:44:43.120
because you don't know how many
threads to create that will scale

00:44:43.230 --> 00:44:45.460
between one CPU versus eight CPUs.

00:44:45.850 --> 00:44:50.580
If you're dealing with shared data,
you might face synchronization issues,

00:44:50.580 --> 00:44:53.390
such as deadlocks and race conditions.

00:44:53.440 --> 00:44:58.610
Finally, if you're dealing with threads,
you might face problems with blocking

00:44:58.610 --> 00:45:01.940
API and contended memory access,
when two threads are trying to

00:45:01.940 --> 00:45:05.170
read and write from the same
cache line at the same time.

00:45:05.390 --> 00:45:08.770
So, if threading is hard,
and since you have no knowledge

00:45:08.770 --> 00:45:12.060
of the underlying hardware,
but your system does,

00:45:12.130 --> 00:45:15.680
then why can't your system
deal with threads for you?

00:45:16.120 --> 00:45:18.870
While in Snow Leopard, it can.

00:45:18.880 --> 00:45:22.660
As you've seen from Bertrand's talk,
Snow Leopard introduces a new

00:45:22.740 --> 00:45:27.840
concurrency-oriented programming
model called Grand Central Dispatch.

00:45:27.980 --> 00:45:33.140
This is in essence a new infrastructure
that provides you with simple API that

00:45:33.140 --> 00:45:37.560
works with the operating system to
provide you with concurrency without the

00:45:37.560 --> 00:45:40.120
previous obstacles that we talked about.

00:45:41.190 --> 00:45:41.980
So how does it work?

00:45:41.980 --> 00:45:45.410
Well,
it's based on the notion of a queue,

00:45:45.580 --> 00:45:48.770
where a queue is an asynchronous
unit of concurrency.

00:45:49.600 --> 00:45:51.820
What you need to do is you
need to divide your code up

00:45:51.900 --> 00:45:54.810
into work units or work items.

00:45:56.550 --> 00:45:58.800
And then add these work
items to the queue.

00:45:58.800 --> 00:46:05.000
And then GCD goes ahead and executes
these items concurrently and assigns

00:46:05.140 --> 00:46:09.080
the necessary threads that will
perform these actions without

00:46:09.190 --> 00:46:10.960
you having to worry about them.

00:46:12.780 --> 00:46:16.360
And with Instruments,
we've introduced a new

00:46:16.470 --> 00:46:18.680
GCD instrument in Snow Leopard.

00:46:18.820 --> 00:46:23.960
The GCD instrument records queue events,
such as the creation of a queue

00:46:24.040 --> 00:46:26.110
and when a queue is deleted.

00:46:26.220 --> 00:46:29.680
It also records when an item
has been added to a queue and

00:46:29.680 --> 00:46:33.870
when it's been popped off and
when its work has been executed.

00:46:34.010 --> 00:46:39.280
And it also keeps track of the number of
queues that are active versus inactive.

00:46:39.280 --> 00:46:43.120
Now, active queues are defined as
queues that currently have items

00:46:43.120 --> 00:46:45.850
on them that are executing,
versus inactive queues,

00:46:45.940 --> 00:46:50.430
which are queues that have items on them,
but they aren't executing at this time.

00:46:50.440 --> 00:46:55.270
In essence, the GCD instrument tells you
about the interaction of dispatch

00:46:55.270 --> 00:46:57.470
queues with your application.

00:46:57.470 --> 00:47:02.980
So let's take a look at the
GCD instrument in action.

00:47:04.480 --> 00:47:09.050
If we switch over to the demo machine,
and I'm actually going

00:47:09.050 --> 00:47:10.180
to switch over to the

00:47:11.650 --> 00:47:12.440
There we go.

00:47:12.440 --> 00:47:13.700
All right.

00:47:13.800 --> 00:47:18.270
So, I'm going to bring out, bring,
launch Instruments, and as you can see,

00:47:18.370 --> 00:47:22.490
I'm going to select the Dispatch
Instrument from my template chooser.

00:47:22.790 --> 00:47:24.780
I'm going to hit choose.

00:47:25.810 --> 00:47:30.980
And my target application over here,
I'm going to launch

00:47:30.980 --> 00:47:34.110
GCD Mandelbrot and hit record.

00:47:36.360 --> 00:47:40.400
So Mandelbrot is really a
fractal drawing application.

00:47:40.580 --> 00:47:43.340
And the way it works
is that for each row,

00:47:43.340 --> 00:47:45.140
I'm creating a new queue.

00:47:45.170 --> 00:47:50.060
And for that queue, I'm pushing on items
that are 10 by 10 cells.

00:47:50.070 --> 00:47:55.120
And GCD is taking care of rendering
these 10 by 10 cells for me.

00:47:55.310 --> 00:47:59.530
So what I can do is I can zoom in,
and it re-renders.

00:48:00.600 --> 00:48:03.300
Over here, I'll zoom in again.

00:48:03.300 --> 00:48:05.780
And as you can see in the background,

00:48:05.910 --> 00:48:10.090
I'm recording the active versus inactive
cues as my application is running.

00:48:10.230 --> 00:48:13.600
So in the track view,
you can see the active cues in

00:48:13.630 --> 00:48:15.470
red versus the inactive cues.

00:48:15.570 --> 00:48:18.370
Let me just do it again.

00:48:18.370 --> 00:48:18.370
Here we go.

00:48:19.200 --> 00:48:24.210
Now let's go back, and this is what you
see in your track view.

00:48:24.510 --> 00:48:29.440
If you take a look at your detail view,
it shows you all the queue

00:48:29.440 --> 00:48:30.610
events that are occurring.

00:48:30.680 --> 00:48:32.920
Like for example,
when you're creating queues,

00:48:33.020 --> 00:48:35.920
when you're pushing items onto queue,
et cetera.

00:48:36.030 --> 00:48:39.350
Now I could filter for,
I'm going to actually

00:48:39.420 --> 00:48:45.720
stop my application first,
and I'm going to filter for queue create.

00:48:48.540 --> 00:48:51.520
And you can see all the places
where my queues have been created.

00:48:51.680 --> 00:48:55.900
For example, here I've created my
render at y equals 0 queue.

00:48:55.960 --> 00:48:59.430
And down here I've created
my render at y equals 220.

00:48:59.670 --> 00:49:01.740
Let me clear the filter.

00:49:02.110 --> 00:49:05.010
And if I scroll down,
you can also see when Q work

00:49:05.010 --> 00:49:07.100
items have been completed.

00:49:07.230 --> 00:49:09.430
For example,
I've completed a work item at

00:49:09.430 --> 00:49:14.100
Y equals 310 before I completed
a work item at Y equals 390.

00:49:14.100 --> 00:49:18.090
And finally,
if you go to your call tree view,

00:49:18.370 --> 00:49:22.440
And I'm going to select
separate by thread.

00:49:22.440 --> 00:49:27.060
And you can see all the threads that
have been created by GCD in order to take

00:49:27.060 --> 00:49:29.710
care of rendering this manual for you.

00:49:29.830 --> 00:49:32.370
So this is an eight core machine,
and you can see that GCD has

00:49:32.370 --> 00:49:34.070
created a whole bunch of threads.

00:49:34.170 --> 00:49:38.750
And you see that some of the
threads made 308 calls versus

00:49:38.750 --> 00:49:41.720
some threads that made 26 calls.

00:49:41.900 --> 00:49:46.460
So we just saw how to use the
GCD instrument on Snow Leopard.

00:49:46.460 --> 00:49:49.000
If we switch back to slides, please.

00:49:53.880 --> 00:49:57.030
So now we've seen how
Instruments can simplify the

00:49:57.130 --> 00:49:59.300
performance analysis for you.

00:49:59.310 --> 00:50:03.720
And let's talk about how it integrates
seamlessly into your workflow.

00:50:03.750 --> 00:50:06.520
So as you've seen,
I can run Instruments directly from

00:50:06.520 --> 00:50:11.160
Xcode by selecting the Run menu and
then selecting Start Performance Tool.

00:50:11.180 --> 00:50:15.550
And then I can select any one of these
templates to start Instruments with.

00:50:16.460 --> 00:50:20.700
You can also launch Instruments
from using Quick Start Keys.

00:50:20.790 --> 00:50:24.400
Now, sometimes you might face performance
problems that are transient,

00:50:24.550 --> 00:50:26.740
which appear and disappear suddenly.

00:50:26.770 --> 00:50:30.510
And with Quick Start Keys,
Instruments does not have to be running.

00:50:30.510 --> 00:50:34.600
All you need to do is to place
your cursor over that application,

00:50:34.600 --> 00:50:38.230
hit a Quick Start Key,
and Instruments would launch with

00:50:38.230 --> 00:50:42.940
the selected template that you've
assigned for that Quick Start Key.

00:50:42.940 --> 00:50:45.840
And you can assign these
Quick Start Keys in the

00:50:45.920 --> 00:50:48.270
Preferences pane of Instruments.

00:50:48.830 --> 00:50:52.240
Third way you can launch Instruments
is from the command line.

00:50:52.400 --> 00:50:55.860
All you need to do is specify
the template to use and the

00:50:56.070 --> 00:51:00.600
target PID or application and
launch Instruments right away.

00:51:02.430 --> 00:51:06.840
And in addition to integrating
seamlessly into your workflow,

00:51:06.990 --> 00:51:10.320
you can also customize
instruments as well.

00:51:10.320 --> 00:51:12.440
You can create your own custom templates.

00:51:12.530 --> 00:51:15.510
For example,
you've selected a group of instruments

00:51:15.510 --> 00:51:18.640
you want to use together and you
want to save that for later use.

00:51:18.640 --> 00:51:22.940
You can go to the File menu
and hit Save as Template,

00:51:23.040 --> 00:51:26.630
and you'll be prompted
with a save dialog,

00:51:26.630 --> 00:51:29.850
and you can save that template
that you've chosen for later use.

00:51:30.590 --> 00:51:32.500
You can also run
Instruments in mini mode,

00:51:32.500 --> 00:51:36.190
which will save you the overhead
of the graphical interface.

00:51:36.870 --> 00:51:39.390
Finally,
you can use multiple graph styles

00:51:39.390 --> 00:51:41.520
to plot the data in the track view.

00:51:41.520 --> 00:51:43.730
In this case,
you see the block graph style,

00:51:43.920 --> 00:51:47.610
the point graph style,
and the filled line graph style.

00:51:48.550 --> 00:51:51.680
The bottom line is,
Instruments simplifies your performance

00:51:51.680 --> 00:51:55.600
analysis because it integrates
seamlessly into your workflow.

00:51:55.930 --> 00:51:58.650
Now, even though it's simple,
it still retains the breadth and

00:51:58.650 --> 00:52:02.630
depth that allows you to write
competitive and compelling apps.

00:52:02.730 --> 00:52:05.910
And with that,
I hope you all enjoyed this session.

00:52:06.600 --> 00:52:08.830
If you have any questions,
please don't hesitate to

00:52:08.830 --> 00:52:10.050
email Michael Jurwitz.

00:52:10.110 --> 00:52:11.700
He's our developer tools evangelist.

00:52:11.700 --> 00:52:15.940
For more information about Instruments
and Instrument documentation,

00:52:15.940 --> 00:52:18.740
that can be found in
the Xcode documentation.

00:52:18.750 --> 00:52:20.890
And finally,
for more information about DTrace,

00:52:20.910 --> 00:52:23.840
you should go ahead and
check out Sun's website.

00:52:23.840 --> 00:52:26.440
It has a comprehensive guide to DTrace.

00:52:28.600 --> 00:52:32.570
Now, if you're really interested in GCD,
I really recommend the session

00:52:32.570 --> 00:52:35.600
right after this in North Beach.

00:52:35.670 --> 00:52:38.840
And I believe the title on this is wrong,
but it's session 382.

00:52:38.840 --> 00:52:42.300
And if you're interested in how
to use Instruments to debug and

00:52:42.350 --> 00:52:46.320
profile iPhone applications,
I also really recommend the session

00:52:46.350 --> 00:52:49.140
at 10.30 on Thursday in Presidio.

00:52:49.140 --> 00:52:52.390
And there are two more sessions about
DTrace that you can see up there.

00:52:54.090 --> 00:52:56.430
And finally,
we'd like you to come talk to us

00:52:56.430 --> 00:52:59.500
and tell us about your problems,
and we will help you with

00:52:59.590 --> 00:53:02.890
your performance problems
and how to use Instruments.

00:53:02.940 --> 00:53:08.040
We're going to be in the labs right
after this in OS X Foundation Lab C.

00:53:08.040 --> 00:53:12.500
We're also going to be in labs
tomorrow at the time shown.
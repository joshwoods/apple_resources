WEBVTT

00:00:20.120 --> 00:00:23.300
So here, because it's so simple,
at least to begin with,

00:00:23.310 --> 00:00:24.110
there's not much in it.

00:00:25.000 --> 00:00:27.470
It has the draw rect,
which does the drawing,

00:00:27.570 --> 00:00:32.820
and then it also has an accessor pair
set up for storing and getting the color,

00:00:32.820 --> 00:00:34.030
which it wants to put up.

00:00:34.170 --> 00:00:35.360
So we're going to talk
about both of these,

00:00:35.440 --> 00:00:36.100
at least briefly.

00:00:36.100 --> 00:00:38.660
I'm going to start with the drawing,
even though really the accessors are

00:00:38.660 --> 00:00:40.720
where I'm going to spend more time,
believe it or not.

00:00:41.950 --> 00:00:43.080
So let's look at this first.

00:00:43.080 --> 00:00:45.010
So is there anything
interesting about this?

00:00:45.010 --> 00:00:47.120
Well, yeah, a little bit.

00:00:47.340 --> 00:00:50.140
So for drawing, what are we doing?

00:00:50.140 --> 00:00:52.100
First,
we're setting a color into the context.

00:00:52.190 --> 00:00:55.010
The way graphics works on Mac OS X is
that there's a state machine,

00:00:55.010 --> 00:00:56.890
which is called the graphics context.

00:00:56.920 --> 00:01:01.790
You set attributes like the fill color
or the stroke style or things like that,

00:01:01.910 --> 00:01:05.030
kinds of joins, and then you draw,
and the drawing is always

00:01:05.030 --> 00:01:07.100
through a suspect to the
current state of the machine.

00:01:07.100 --> 00:01:09.370
So the first line is setting
a color into the machine,

00:01:09.370 --> 00:01:11.900
and then the second line is
using it to fill a rectangle.

00:01:11.920 --> 00:01:14.380
And what's interesting,
maybe the first thing is that, yes,

00:01:14.430 --> 00:01:15.090
it's a rect fill.

00:01:15.320 --> 00:01:16.260
That part makes sense.

00:01:16.380 --> 00:01:18.620
But what's this compositing operation,
composite source over?

00:01:18.620 --> 00:01:20.260
Well, let's talk about that briefly.

00:01:20.260 --> 00:01:26.730
So compositing operations are
ways of combining drawing.

00:01:26.740 --> 00:01:29.960
So we talk about there being
a destination and a source

00:01:29.960 --> 00:01:32.250
whenever we're doing new drawing.

00:01:32.260 --> 00:01:34.720
And what that refers to is that
the source is whatever is new,

00:01:34.790 --> 00:01:37.580
the new pixels, and the destination is
what was already there.

00:01:37.580 --> 00:01:40.550
And compositing operations tell
you about how to combine them,

00:01:40.550 --> 00:01:41.680
what formula to use.

00:01:41.920 --> 00:01:46.300
So the normal mode is called
composite source over,

00:01:46.300 --> 00:01:48.220
and it's just exactly what you expect.

00:01:48.300 --> 00:01:50.680
It just looks like draw it,
and it just looks completely normal.

00:01:50.680 --> 00:01:54.030
And that's going to be the main
theme for this little tip is just

00:01:54.370 --> 00:01:56.060
normal is composite source over.

00:01:56.060 --> 00:01:56.610
That's what it means.

00:01:56.640 --> 00:01:58.610
Some of the more
abnormal modes like this,

00:01:58.610 --> 00:02:01.390
this is the kind of thing you
see if you use something else.

00:02:01.520 --> 00:02:03.970
This is what you see if
you see destination atop.

00:02:04.080 --> 00:02:07.090
Fairly obvious that while
you can come up with cases,

00:02:07.210 --> 00:02:11.090
certainly, and interesting operations
where you can make cases,

00:02:11.150 --> 00:02:11.160
you can also make cases where
you can make a destination.

00:02:11.160 --> 00:02:11.160
So this is what you see if
you see destination atop.

00:02:11.160 --> 00:02:11.230
Okay.

00:02:11.300 --> 00:02:11.870
So this is what you see if
you see destination atop.

00:02:12.030 --> 00:02:14.300
good use of these extra modes,
for the most part,

00:02:14.300 --> 00:02:15.100
that's not what you want.

00:02:15.210 --> 00:02:17.340
For the most part,
you always want to be using

00:02:17.340 --> 00:02:18.390
composite source over.

00:02:18.390 --> 00:02:21.000
So if you ever see a compositing
operation argument and you

00:02:21.000 --> 00:02:23.340
don't know what to pass,
you almost certainly

00:02:23.340 --> 00:02:24.740
want to pass source over.

00:02:24.770 --> 00:02:26.700
Okay, so take it to heart.

00:02:26.860 --> 00:02:30.960
And one of the reasons I want to
bring this up is because a somewhat

00:02:30.960 --> 00:02:34.150
attractive method that you might
want to use instead of NSRectFill

00:02:34.150 --> 00:02:35.910
using operation is NSRectFill.

00:02:35.920 --> 00:02:37.610
It looks simpler, right?

00:02:37.610 --> 00:02:41.130
Well, it is, I suppose,
but it very likely doesn't do what

00:02:41.130 --> 00:02:44.380
you want because it actually is the
same as NSRectFill using operation,

00:02:44.430 --> 00:02:45.600
but it passes copy mode.

00:02:45.620 --> 00:02:46.990
And copy mode is not source over.

00:02:46.990 --> 00:02:47.740
It's not normal.

00:02:47.740 --> 00:02:48.560
What does it do?

00:02:48.560 --> 00:02:53.200
Well, copy mode completely replaces
what was already in the context,

00:02:53.200 --> 00:02:56.200
in the destination,
with the new source pixels,

00:02:56.200 --> 00:02:58.350
including the opacity information.

00:02:58.350 --> 00:03:01.100
So what you see is something like this.

00:03:01.340 --> 00:03:06.420
Wherever your new drawing is transparent,
the context actually becomes

00:03:06.420 --> 00:03:09.730
transparent rather than just
showing through what was there.

00:03:11.000 --> 00:06:32.500
[Transcript missing]

00:06:32.810 --> 00:06:36.250
So let's just a quick, quick,
quick rundown of what key value

00:06:36.320 --> 00:06:39.070
observing is for people who
may not have used it too much.

00:06:39.180 --> 00:06:41.600
So it's a way of getting
property change notifications.

00:06:41.640 --> 00:06:45.660
So when you hook up a controller layer,
say, and you say,

00:06:45.690 --> 00:06:49.890
I'd like to observe the color
property of some model object,

00:06:49.890 --> 00:06:53.600
you can receive a notification
every time it changes,

00:06:53.730 --> 00:06:54.860
like here.

00:06:54.860 --> 00:06:57.100
And then when you receive
this notification,

00:06:57.100 --> 00:06:58.860
you can just do whatever you want.

00:06:59.000 --> 00:07:00.650
So for example,
you might update some view.

00:07:01.600 --> 00:07:04.840
And then after that happens,
control returns back to the caller.

00:07:05.100 --> 00:07:06.040
It's all synchronous.

00:07:06.050 --> 00:07:08.550
That's something that some
people don't always realize.

00:07:08.620 --> 00:07:09.780
It's not like this happens later.

00:07:09.780 --> 00:07:14.380
All of the changes by observers are
made before the method even returns.

00:07:14.420 --> 00:07:18.350
Okay, but now we want to actually
use this to fix our problem.

00:07:18.350 --> 00:07:20.370
So what is it that we want to do?

00:07:20.370 --> 00:07:23.320
Well,
we're going to keep a list of those keys,

00:07:23.380 --> 00:07:28.310
those properties, which when they change,
we want to update our display.

00:07:29.600 --> 00:07:55.600
[Transcript missing]

00:07:56.400 --> 00:07:59.500
So the method where you receive those
notifications that I was mentioning

00:07:59.500 --> 00:08:04.060
whenever a key value pair changes
is observed value for key path.

00:08:04.060 --> 00:08:08.580
And what you want to do,
often the implementation of

00:08:08.580 --> 00:08:11.460
this method is not quite right
the way people look at it.

00:08:11.460 --> 00:08:13.340
In particular,
you see how the first line here,

00:08:13.340 --> 00:08:15.960
what I'm doing is I'm checking if
the context is one I recognize.

00:08:15.960 --> 00:08:18.880
If the context is color
view needs display context,

00:08:18.880 --> 00:08:21.940
then I'm going ahead and
invalidating the display.

00:08:21.940 --> 00:08:23.800
Otherwise, I'm calling super.

00:08:24.130 --> 00:08:26.550
This is important,
and this is something that

00:08:26.630 --> 00:08:29.960
people don't always get right,
that the KVO context is

00:08:29.960 --> 00:08:31.780
a non-optional argument.

00:08:31.800 --> 00:08:35.020
It's the only way you can distinguish
your observation from observations

00:08:35.480 --> 00:08:38.180
that somebody else is doing,
which is unusual in Cocoa.

00:08:38.180 --> 00:08:40.910
Usually a context is optional,
and it's usually just something you

00:08:40.910 --> 00:08:44.090
pass in and you receive back later that
you can do whatever you want with it.

00:08:44.200 --> 00:08:46.460
But here, the issue is that if NSObject,
say,

00:08:46.460 --> 00:08:49.860
was observing some particular key path,
and it happened to be the same

00:08:49.860 --> 00:08:55.850
key path you were observing,
you need to not block those observations.

00:08:55.860 --> 00:08:57.940
You need to make sure that all
of your superclasses are also

00:08:58.040 --> 00:09:00.540
getting a hold of the notifications
they expect to be receiving,

00:09:00.540 --> 00:09:02.310
or else you might break the system.

00:09:02.320 --> 00:09:05.170
And the way that you
need to do that is this.

00:09:05.180 --> 00:09:07.770
This is the way to do it,
is you check the context argument.

00:09:07.780 --> 00:09:09.910
So I suggest you pass that in.

00:09:10.080 --> 00:09:12.410
Okay.

00:09:12.420 --> 00:09:16.290
So something that makes this a little
bit easier is that Xcode these days,

00:09:16.290 --> 00:09:21.000
I think just in 3.1,
if you type the beginning of the...

00:09:21.770 --> 00:09:24.620
the word observe out in the gutter
right where you would want to implement

00:09:24.620 --> 00:09:27.560
the observe value for key path method,
well, it'll actually complete it,

00:09:27.710 --> 00:09:28.930
and it'll give you the right form.

00:09:28.940 --> 00:09:32.100
And then if you fill it in,
then you'll be good.

00:09:32.380 --> 00:09:33.760
So that's nice.

00:09:33.840 --> 00:09:35.150
And...

00:09:40.520 --> 00:09:44.350
So that's what our observe value
for keypath method looks like.

00:09:44.350 --> 00:09:47.230
What we do when we notify,
we also need to actually

00:09:47.330 --> 00:09:48.790
set up the observances.

00:09:48.920 --> 00:09:50.930
That's what this would look like.

00:09:50.930 --> 00:09:54.170
Let's just go straight down
the page and look at it.

00:09:54.570 --> 00:09:56.510
First is just a little
aside a little bit.

00:09:56.510 --> 00:09:58.560
So what is this pound pragma mark line?

00:09:58.660 --> 00:10:02.000
This is a way of just organizing
your source code and Xcode.

00:10:02.000 --> 00:10:04.730
What it does is that
in the function pop-up,

00:10:04.730 --> 00:10:07.600
you'll see a bold separator,
which is nice.

00:10:07.600 --> 00:10:10.480
It really helps you to
see what's going on.

00:10:10.500 --> 00:10:12.370
It really helps when you've just got it,
especially in large classes where

00:10:12.450 --> 00:10:13.200
you've got a lot of methods.

00:10:13.200 --> 00:10:14.210
Okay, but moving on.

00:10:14.210 --> 00:10:16.030
Okay,
so now we have this context argument

00:10:16.030 --> 00:10:17.600
that I was talking about before.

00:10:17.600 --> 00:10:19.840
We just made it a static NSString global.

00:10:19.860 --> 00:10:23.020
There's just a single one of it,
and it has a unique name.

00:10:23.030 --> 00:10:25.440
It has something, well,
unique in that it's unlikely

00:10:25.440 --> 00:10:28.150
anybody else in the system would
try to use the same context for

00:10:28.180 --> 00:10:31.370
anything because we called it,
we prefixed it with our class name.

00:10:31.380 --> 00:10:33.710
So we wrote it color view
needs display context.

00:10:33.710 --> 00:10:34.800
Seems reasonable.

00:10:34.800 --> 00:10:40.480
Okay, then when it comes time to actually
set up the start of the system,

00:10:40.480 --> 00:10:46.070
we would call self at observer
key path with the property and the

00:10:46.070 --> 00:10:48.150
context is the needs display context.

00:10:48.150 --> 00:10:51.730
And you see here I'm calling a method
to return the list of properties,

00:10:51.730 --> 00:10:55.320
which I want to invalidate display,
which I've called more or less key

00:10:55.320 --> 00:10:57.580
paths for values affecting display.

00:10:57.580 --> 00:10:59.010
However, I gave it a prefix.

00:10:59.020 --> 00:11:00.480
Why did I give it a prefix?

00:11:00.540 --> 00:11:02.080
Well, it's too generic.

00:11:02.190 --> 00:11:05.020
The problem is that this is
a sufficiently useful method,

00:11:05.080 --> 00:11:08.030
I think, that, for example,
AppKit might actually end up

00:11:08.140 --> 00:11:10.450
supplying it for you someday,
possibly.

00:11:10.460 --> 00:11:16.540
So, and it would be bad if you defined a
method that did something like this,

00:11:16.540 --> 00:11:18.310
and we defined a method that
did something like this,

00:11:18.390 --> 00:11:20.240
but they actually had
slightly different semantics.

00:11:20.310 --> 00:11:21.940
Or if we wanted you to call
super or something like that,

00:11:21.950 --> 00:11:23.400
it could end up breaking
your application.

00:11:23.400 --> 00:11:25.890
So the suggestion is when
you're implementing something

00:11:25.890 --> 00:11:28.850
that's really generic,
that's not specific to your application,

00:11:28.990 --> 00:11:30.890
that you try to do some
prefixing or something to

00:11:30.980 --> 00:11:32.410
keep it out of our namespace.

00:11:32.430 --> 00:11:36.120
Or to keep us from, excuse me,
I shouldn't call it our namespace.

00:11:36.120 --> 00:11:39.130
To keep it from conflicting.

00:11:39.140 --> 00:11:43.820
So a good example of that is,
when the setHidden method was added,

00:11:43.820 --> 00:11:45.940
I don't remember if it
was either 10.3 or 10.4,

00:11:45.940 --> 00:11:49.140
that really caused a lot of trouble,
because it turned out a lot of people had

00:11:49.140 --> 00:11:51.730
tried to define setHidden on its view,
which did something,

00:11:51.730 --> 00:11:53.330
wasn't quite the same thing as ours.

00:11:53.350 --> 00:11:55.500
So there was some hacking
actually necessary to make sure

00:11:55.500 --> 00:11:56.710
that we didn't break people.

00:11:56.710 --> 00:12:00.380
Okay, I don't want to get
too caught up on that.

00:12:00.820 --> 00:12:10.420
So that's why we do our setup.

00:12:10.420 --> 00:12:10.420
We also need to do teardown, of course.

00:12:10.420 --> 00:12:10.420
That's pretty straightforward.

00:12:10.420 --> 00:12:10.420
You just remove the observer,
which is self in this case.

00:12:10.420 --> 00:12:10.420
Okay, that's great.

00:12:10.420 --> 00:12:11.660
However,
we haven't actually called them anywhere.

00:12:11.670 --> 00:12:13.090
Those were just convenience
methods I set up.

00:12:13.200 --> 00:12:14.570
Where might we want to call them?

00:12:14.570 --> 00:12:16.030
Well, we can call them in init.

00:12:16.190 --> 00:12:16.880
That's a possibility.

00:12:16.880 --> 00:12:20.890
So because this is a view class,
I'm overriding init with frame,

00:12:20.890 --> 00:12:23.440
and I'm overriding init
with coder to do the setup.

00:12:23.440 --> 00:12:27.720
So that whenever my properties change
for the entire lifetime of the object,

00:12:27.790 --> 00:12:30.110
the setNeedsDisplay call will happen.

00:12:30.110 --> 00:12:32.140
So why particularly these two methods?

00:12:32.140 --> 00:12:34.680
Why did I do it in init with
coder and init with frame?

00:12:34.690 --> 00:12:36.800
Why didn't I override init, for example?

00:12:36.800 --> 00:12:39.440
Well,
these are the designated initializers.

00:12:39.490 --> 00:12:43.990
And this is something that
people sort of know about,

00:12:44.080 --> 00:12:45.900
but don't seem to quite
have the right idea on.

00:12:46.310 --> 00:12:49.780
So with designated initializers,
first of all, a class has not one

00:12:49.780 --> 00:12:51.240
designated initializer,
but any number of

00:12:51.240 --> 00:12:52.110
designated initializers.

00:12:52.110 --> 00:12:58.230
And the contract that they adhere to is
that every object that gets initialized

00:12:58.370 --> 00:13:02.360
is going to go through one and only
one of the designated initializers

00:13:02.360 --> 00:13:04.140
at each level of the class hierarchy.

00:13:04.140 --> 00:13:04.980
Okay?

00:13:04.980 --> 00:13:08.990
Which means that if you want to

00:13:10.620 --> 00:13:23.260
To do initialization,
you need to override all of

00:13:23.260 --> 00:13:23.270
the designated initializers
of your superclass.

00:13:23.600 --> 00:13:27.020
Here's an issue that people
run into and why this fixes it.

00:13:27.390 --> 00:13:30.580
Interface builder will create objects
in a variety of different ways.

00:13:30.690 --> 00:13:33.220
Under some circumstances it
will use a NIT with frame.

00:13:33.280 --> 00:13:35.220
Under some circumstances it
will use a NIT with coder.

00:13:35.220 --> 00:13:38.140
Under some circumstances
it will use a NIT.

00:13:38.200 --> 00:13:41.700
These situations are actually documented
and you can learn them if you want.

00:13:41.760 --> 00:13:43.580
You know, I mean, I suppose it's always
good to know things.

00:13:43.640 --> 00:13:47.480
But if you override all of
your designated initializers,

00:13:47.520 --> 00:13:50.520
it doesn't matter how the object
was created because it's always

00:13:50.580 --> 00:13:51.310
going to go through one of them.

00:13:51.460 --> 00:13:52.850
That's the contract.

00:13:52.870 --> 00:13:54.230
So I suggest you do that.

00:13:54.300 --> 00:13:56.780
And this pops up on the
mailing list sometimes.

00:13:56.820 --> 00:13:57.340
Okay.

00:13:57.400 --> 00:13:59.720
We also need to...

00:14:00.780 --> 00:14:06.880
This is a little bit of a difference
from the NS Notification Center.

00:14:06.980 --> 00:14:13.460
You may know that if you're using
NS Notification Center notifications,

00:14:13.560 --> 00:14:18.380
you do not need to unregister
yourself and finalize.

00:14:18.380 --> 00:14:21.220
It will sort of happen anyway.

00:14:21.260 --> 00:14:23.640
That's not true with KVO.

00:14:23.640 --> 00:14:26.630
You need to do it explicitly.

00:14:26.700 --> 00:14:30.550
Okay, but then there's something
else I want to do here,

00:14:30.550 --> 00:14:33.950
which is that you may have heard
that it's not really a good

00:14:33.980 --> 00:14:36.990
idea to have a lot of code in
DLAC or especially in finalize.

00:14:37.000 --> 00:14:39.050
And that's true for a variety of reasons.

00:14:39.060 --> 00:14:42.360
But let me get to those in a minute.

00:14:42.500 --> 00:14:45.440
For now, I want to say from almost from
a performance point of view,

00:14:45.440 --> 00:14:47.340
I mean,
display doesn't really make a lot of

00:14:47.360 --> 00:14:49.480
sense unless you're actually in a window.

00:14:49.480 --> 00:14:53.190
So instead of doing it with DLAC,
something we can do is we can implement

00:14:53.200 --> 00:14:56.580
the method viewWillMoveToWindow,
which is a method of NS View.

00:14:56.640 --> 00:14:58.990
It's very useful.

00:14:59.000 --> 00:15:01.850
And we can just say, well,
we -- so we're being told

00:15:01.850 --> 00:15:03.600
that we're moving to a window.

00:15:03.800 --> 00:15:06.890
We're going into a window that
exists if the new window is non-nil.

00:15:07.000 --> 00:15:09.390
We're already in a window
if when we call self-window,

00:15:09.390 --> 00:15:10.740
we get something non-nil.

00:15:10.900 --> 00:15:12.710
And we only need observations
when we're in a window.

00:15:12.870 --> 00:15:15.400
So if we're currently not in a
window and we're going into one,

00:15:15.400 --> 00:15:17.200
then we need to set up the observation.

00:15:17.200 --> 00:15:19.450
And if we're coming out of a window,
we need to tear it down.

00:15:19.500 --> 00:15:24.240
And this is nice because, yes,
we do get to remove the Niala code.

00:15:24.390 --> 00:15:26.500
But it's also, like I said,
good because we're not going

00:15:26.500 --> 00:15:26.500
to have to do it again.

00:15:26.500 --> 00:15:27.860
And we're going to be
able to do it again.

00:15:27.900 --> 00:15:27.900
And we're going to be
able to do it again.

00:15:27.900 --> 00:15:27.900
And we're going to be
able to do it again.

00:15:27.900 --> 00:15:27.900
And we're going to be
able to do it again.

00:15:27.910 --> 00:15:27.980
And we're going to be
able to do it again.

00:15:27.980 --> 00:15:28.100
And we're going to be
able to do it again.

00:15:28.330 --> 00:15:32.150
Because DLAC is -- DLAC and
especially Finalize are --

00:15:32.400 --> 00:18:06.000
[Transcript missing]

00:18:07.280 --> 00:18:09.810
So up at the top,
we have the part of the code that

00:18:09.810 --> 00:18:11.100
I was claiming that we care about.

00:18:11.100 --> 00:18:13.230
So the draw rect,
the key paths for values

00:18:13.240 --> 00:18:16.040
affecting display,
and then the synthesize attribute.

00:18:16.060 --> 00:18:17.670
Then we have some stuff that I'm
skipping because I'm going to

00:18:17.710 --> 00:18:18.790
come back and do that in a minute.

00:18:18.900 --> 00:18:20.900
And then we have the infrastructure part.

00:18:21.070 --> 00:18:24.990
So we have the declaration
of the new context.

00:18:25.370 --> 00:18:27.700
We have the part where we
set up the auto display.

00:18:27.700 --> 00:18:29.030
So actually, let's just count them first.

00:18:29.130 --> 00:18:31.390
So it's just four methods,
and all of them are pretty short.

00:18:31.450 --> 00:18:32.950
None of them are more
than six lines of code.

00:18:32.960 --> 00:18:38.620
And they're really only six lines because
the spacing on the screen is so funny.

00:18:38.620 --> 00:18:41.620
So we set up the observation.

00:18:41.640 --> 00:18:43.920
We tear down the observation
with removeObserver,

00:18:43.920 --> 00:18:46.060
and then when the view's
moving to the window,

00:18:46.060 --> 00:18:48.310
we want to do the setup sometimes,
tear down sometimes,

00:18:48.320 --> 00:18:51.510
and then we have to actually
implement the method that gets

00:18:51.640 --> 00:18:54.280
called when the values change,
check the context,

00:18:54.280 --> 00:18:55.800
and actually invalidate the display.

00:18:55.800 --> 00:18:56.700
Okay, so that's that.

00:18:56.860 --> 00:18:59.690
And that should work,
so I'm going to run it.

00:18:59.830 --> 00:19:00.860
Gorgeous, eh?

00:19:00.860 --> 00:19:02.500
Woo.

00:19:02.500 --> 00:19:03.800
Okay.

00:19:05.400 --> 00:19:08.650
We didn't save a whole lot here, right?

00:19:08.650 --> 00:19:11.880
Because, I mean,
we didn't have to implement an accessor.

00:19:11.880 --> 00:19:12.950
Instead, we implemented four methods.

00:19:12.980 --> 00:19:14.010
That doesn't seem like a huge win.

00:19:14.170 --> 00:19:19.040
But the win... The nice thing
is that they're totally generic.

00:19:19.040 --> 00:19:23.160
So now if we want to change things,
we can do that pretty quickly.

00:19:23.160 --> 00:19:24.370
So I'm just going to comment this out.

00:19:24.390 --> 00:19:27.170
Let's say we wanted to draw a
gradient in the window instead,

00:19:27.180 --> 00:19:27.600
okay?

00:19:27.600 --> 00:19:30.870
So we would need to,
instead of having just a single color,

00:19:30.900 --> 00:19:33.320
we want to have a top
color for the gradient,

00:19:33.320 --> 00:19:35.350
a bottom color for the gradient.

00:19:35.450 --> 00:19:37.040
Let's put a title in
the middle of the thing,

00:19:37.040 --> 00:19:37.400
too.

00:19:37.430 --> 00:19:40.440
Then I don't want that attribute.

00:19:40.440 --> 00:19:44.400
Excuse me.

00:19:44.400 --> 00:19:44.400
I want these three instead.

00:19:45.000 --> 00:19:51.570
I'm going to comment out this
chunk of code and instead I'm going

00:19:51.570 --> 00:19:54.700
to say okay I want to synthesize
those three new properties.

00:19:54.700 --> 00:19:57.310
Excuse me, synthesize.

00:19:57.310 --> 00:20:00.660
And I want to say that whenever
any of them changes I would like

00:20:00.750 --> 00:20:01.910
my display to be invalidated.

00:20:01.910 --> 00:20:03.700
So there they are just written in a list.

00:20:03.700 --> 00:20:06.940
And then I want to
actually draw my drawing,

00:20:06.940 --> 00:20:08.900
write my drawing code.

00:20:08.900 --> 00:20:10.810
And this is longer but the
whole point of this is that,

00:20:10.810 --> 00:20:12.300
I mean this is what the
view is supposed to do.

00:20:12.300 --> 00:20:15.400
This is the part that I hope you're
somewhat interested to actually write

00:20:15.400 --> 00:20:17.090
because this is what you're doing.

00:20:17.150 --> 00:20:19.810
I mean we're getting the
bounding rectangle for the view.

00:20:19.970 --> 00:20:24.570
We're creating a gradient using
the top color and the bottom color.

00:20:24.900 --> 00:20:42.900
[Transcript missing]

00:20:43.100 --> 00:20:45.960
And then we're going to center
it more or less in the view,

00:20:45.960 --> 00:20:49.820
but because the centering can
cause it to be non pixel aligned,

00:20:49.820 --> 00:20:52.180
we're going to use this
method centerScanRect,

00:20:52.640 --> 00:20:58.470
which will align the box that you've
just made to the two pixels in the view.

00:20:58.480 --> 00:21:01.560
And this is particularly interesting
because it works well at high resolution.

00:21:01.560 --> 00:21:04.440
If you're aware that we're
trying to get things working for

00:21:04.510 --> 00:21:07.810
resolution independence so that
we can run our displays at higher

00:21:07.810 --> 00:21:11.320
scale factors so things look just
take more pixels on the screen.

00:21:11.320 --> 00:21:13.870
So if you're used to
just rounding and saying,

00:21:13.870 --> 00:21:16.900
if you want to make things integral
and make them look snapped in

00:21:16.900 --> 00:21:19.250
the right place on the screen,
that's not going to

00:21:19.520 --> 00:21:22.560
work right at high DPI,
but centerScanRect will.

00:21:22.560 --> 00:21:24.900
So and it's actually not
really necessary for text.

00:21:24.960 --> 00:21:26.480
In fact,
it's probably better if you don't do it,

00:21:26.510 --> 00:21:27.440
but I'm just demonstrating.

00:21:27.700 --> 00:21:30.900
So that's that.

00:21:31.060 --> 00:21:32.020
So we can do all that.

00:21:32.220 --> 00:21:32.670
We run it.

00:21:32.670 --> 00:21:35.410
And again,
now we find that we have a gradient.

00:21:35.420 --> 00:21:39.640
The top and the bottom
color can be changed.

00:21:39.640 --> 00:21:50.100
So we can do all that.

00:21:50.190 --> 00:21:50.190
We run it.

00:21:50.190 --> 00:21:50.190
And again,
now we find that we have a gradient.

00:21:50.190 --> 00:21:50.190
The top and the bottom
color can be changed.

00:21:54.600 --> 00:23:47.000
[Transcript missing]

00:23:47.800 --> 00:24:12.700
[Transcript missing]

00:24:12.940 --> 00:24:15.650
Last, I did just want to point out
center-scan-rect because I don't

00:24:15.650 --> 00:24:16.900
think it's very well known.

00:24:16.900 --> 00:24:19.260
It's been in the operating
system since 10.0,

00:24:19.260 --> 00:24:21.460
but nobody's had a reason
to use it until recently.

00:24:21.460 --> 00:24:23.430
So,
you might want to take a look at that.

00:24:23.770 --> 00:24:26.360
Okay, that is most of what
I have to say about that,

00:24:26.430 --> 00:24:29.190
but I would like to take a
little moment here to talk about

00:24:29.540 --> 00:24:31.490
some garbage collection issues.

00:24:31.490 --> 00:24:34.740
So, in particular,
when we were using that KVO context,

00:24:34.740 --> 00:24:37.450
the context is typed void star,
all right?

00:24:38.340 --> 00:24:40.370
And what we passed in
was not a void star,

00:24:40.430 --> 00:24:41.490
but it was a string.

00:24:41.530 --> 00:24:43.310
It was a static string.

00:24:43.310 --> 00:24:47.390
So,
this is going to have some repercussions

00:24:47.390 --> 00:24:53.600
because our garbage collector does
not scan through all of memory and

00:24:53.600 --> 00:24:56.780
keep every single object alive.

00:24:56.820 --> 00:24:59.370
That would be a conservative collector.

00:24:59.370 --> 00:25:02.600
What ours does is that it
knows how things are laid out,

00:25:02.600 --> 00:25:06.140
and it only looks for possible
objects within variables that

00:25:06.290 --> 00:25:08.100
are typed to be object type.

00:25:08.280 --> 00:25:12.030
So, when you have this void star,
if you're passing something in there,

00:25:12.030 --> 00:25:15.650
our system is not going to know that
that's an object if it is an object,

00:25:15.730 --> 00:25:19.150
and we're not going to keep it alive,
which makes it unsafe to pass

00:25:19.150 --> 00:25:23.110
objects there unless you take extra
care to make sure that it is safe.

00:25:23.240 --> 00:25:25.610
So, what are the various different
ways you can make it safe?

00:25:25.610 --> 00:25:28.700
Well, you can use something that you're
pretty sure is not going to go away.

00:25:28.730 --> 00:25:30.600
So,
in the case of the static and a string,

00:25:30.600 --> 00:25:32.900
there are two reasons why
it's not going to go away.

00:25:32.900 --> 00:25:35.420
First of all,
it's stored in a static global variable.

00:25:35.420 --> 00:25:36.360
That's enough.

00:25:36.560 --> 00:25:37.580
Another reason it's not going to go
away is because it's not going to be

00:25:37.580 --> 00:25:38.320
stored in a static global variable.

00:25:38.320 --> 00:25:40.480
The other reason it's not going to go
away is because it's just constant.

00:25:40.480 --> 00:25:44.090
I mean, at quoted strings,
unless you're doing something

00:25:44.630 --> 00:25:47.710
fancy with bundle unloading,
never go away.

00:25:47.890 --> 00:25:50.680
One thing people sometimes
try to do is they want to pass

00:25:50.690 --> 00:25:52.400
self-class as the context.

00:25:52.400 --> 00:25:53.600
I suggest you not do that.

00:25:53.730 --> 00:25:54.720
That is too generic.

00:25:54.840 --> 00:25:57.920
It's important when you choose
the string to choose something

00:25:57.920 --> 00:26:01.640
that nobody else might try to
use as an observation context.

00:26:01.640 --> 00:26:05.160
And your class maybe doesn't
satisfy that property.

00:26:05.160 --> 00:26:08.490
And also, even if you do self-class,
that's not getting your class,

00:26:08.500 --> 00:26:11.240
that's getting whatever
class is currently active.

00:26:11.240 --> 00:26:12.920
I mean, it might be a subclass,
basically,

00:26:12.920 --> 00:26:14.500
if somebody has subclassed your code.

00:26:14.520 --> 00:26:15.680
So that's not very useful.

00:26:15.680 --> 00:26:18.320
Another thing you can do,
and this is the part that

00:26:18.320 --> 00:26:21.130
I really want to talk about,
is you can CF retain it.

00:26:21.360 --> 00:26:25.030
Because under garbage collection,
what CF retain means is it means, hey,

00:26:25.540 --> 00:26:27.640
garbage collector,
something outside of the scope

00:26:27.730 --> 00:26:30.090
of the things that you know
about is using this object.

00:26:30.150 --> 00:26:32.300
So you cannot destroy it.

00:26:32.300 --> 00:26:35.410
It's a hard retain.

00:26:35.710 --> 00:26:42.600
What I want to say about this is that
it is harder to get right than it looks.

00:26:42.600 --> 00:26:44.240
First of all,
something which you may or may not

00:26:44.240 --> 00:26:46.730
realize is that when you're not
running with garbage collection,

00:26:46.820 --> 00:26:50.760
cf.retain, which is the
core_foundation.retain function,

00:26:50.760 --> 00:26:55.600
is absolutely interchangeable with
the retain message in foundation.

00:26:55.650 --> 00:26:59.820
To the point where you
can take any cf object,

00:26:59.820 --> 00:27:04.600
say a ct font-raft,
a core text font descriptor,

00:27:04.600 --> 00:27:07.600
which is not bridged to
any Objective-C type,

00:27:07.600 --> 00:27:09.600
you can auto-release that if it's useful.

00:27:09.770 --> 00:27:12.460
Because it will eventually end up
sending out the release message,

00:27:12.480 --> 00:27:15.590
and the release message is equivalent
to the cf.release function.

00:27:15.600 --> 00:27:17.590
So they're completely the same
thing when you're not running

00:27:17.600 --> 00:27:18.600
with garbage collection.

00:27:18.600 --> 00:27:21.050
However, when you are running
with garbage collection,

00:27:21.050 --> 00:27:22.600
like I said, they are different.

00:27:22.600 --> 00:27:23.530
You can't mix them.

00:27:23.590 --> 00:27:25.600
You need to keep them
balanced independently.

00:27:25.600 --> 00:27:27.530
And it has subtleties.

00:27:27.630 --> 00:27:29.600
So suppose you have something like this.

00:27:29.600 --> 00:27:33.600
Suppose you have a little object network
of objects referencing each other.

00:27:33.680 --> 00:27:35.600
Well, under garbage collection,
this is fine.

00:27:35.670 --> 00:27:37.600
If nobody else is referencing
the little network,

00:27:37.600 --> 00:27:41.530
then it will be seen to be unreachable,
and all of the objects will

00:27:41.650 --> 00:27:42.520
eventually be destroyed.

00:27:42.600 --> 00:27:45.300
Now,
suppose that you replace one of those

00:27:45.660 --> 00:27:50.600
references that you think of as being,
you know, I'm using this thing,

00:27:50.610 --> 00:27:51.490
with a cf.retain.

00:27:51.600 --> 00:27:53.530
Well, suddenly you have a problem.

00:27:53.660 --> 00:27:55.590
This is not going to work.

00:27:55.600 --> 00:27:57.600
This section of the
graph is going to leak.

00:27:57.600 --> 00:28:00.600
And a good way to think of
this is that the cf.retain,

00:28:00.600 --> 00:28:02.570
it's not directed.

00:28:02.630 --> 00:28:04.640
The system does not know
that it's this thing,

00:28:04.650 --> 00:28:06.510
cf.retaining, this other object.

00:28:06.630 --> 00:28:10.600
It's just this global reference
that says keep it alive.

00:28:10.600 --> 00:28:13.320
And so you're in this kind of
situation where the collector is

00:28:13.440 --> 00:28:16.600
not going to be able to tell that
the object needs to be destroyed.

00:28:16.600 --> 00:28:19.600
And in particular,
cf.release and finalize,

00:28:19.760 --> 00:28:21.600
that's when it's going to get
you into this kind of problem.

00:28:21.610 --> 00:28:24.000
Because finalize is never going
to run because the collector

00:28:24.000 --> 00:28:24.550
never collects your object.

00:28:25.600 --> 00:28:27.600
So when is it okay?

00:28:27.600 --> 00:28:29.600
It's not like you can't use it.

00:28:29.600 --> 00:28:33.600
It's okay if you're pretty sure
the cf.release is going to happen.

00:28:33.600 --> 00:28:35.600
So if the cf.release is not in finalize.

00:28:35.600 --> 00:28:37.360
So, for example,
if you have a block of code and

00:28:37.400 --> 00:28:41.740
at the top you cf.retain it,
some object, then you pass the object off

00:28:41.740 --> 00:28:45.180
somewhere in code that you feel
like is not necessarily going

00:28:45.190 --> 00:28:46.600
to keep it alive or whatever,
I don't know.

00:28:46.600 --> 00:28:49.180
And then the bottom of the
method you cf.release it,

00:28:49.180 --> 00:28:52.600
that's fine because you're sure
that cf.release is going to run.

00:28:52.600 --> 00:28:53.600
It's also okay if you can be sure
that the cf.release is going to run.

00:28:53.600 --> 00:28:54.600
It's also okay if you can be sure
that the cf.release is going to run.

00:28:54.600 --> 00:28:57.260
sure that there aren't going
to be any cycles created,

00:28:57.260 --> 00:29:00.480
meaning that if the object that
you're CF retaining does not

00:29:00.530 --> 00:29:05.740
have any references back up into
arbitrary parts of your object graph.

00:29:05.820 --> 00:29:09.980
If it does,
you're really asking for trouble.

00:29:09.980 --> 00:29:14.110
And leaks in garbage collection
are kind of bad because they tend

00:29:14.110 --> 00:29:17.190
to leak really large parts of the
application graph because almost

00:29:17.560 --> 00:29:19.380
everything is a strong reference.

00:29:19.380 --> 00:29:23.340
So it is going to cause leaks if you
have your CF retained and finalized.

00:29:24.020 --> 00:29:27.570
And if the CF retained object is
too complicated to understand,

00:29:27.570 --> 00:29:30.390
if you don't know what it is,
if people are passing arbitrary objects,

00:29:30.390 --> 00:29:33.160
you really don't want to be CF retaining
them and CF releasing them and finalize.

00:29:33.160 --> 00:29:33.820
Okay.

00:29:33.820 --> 00:29:37.830
Let's go back and just,
that's all I have to say

00:29:37.840 --> 00:29:39.440
about garbage collection,
but let's crystallize what we said.

00:29:39.450 --> 00:29:42.580
So first of all, a static and a string
that you use a fairly,

00:29:42.580 --> 00:29:45.000
you know,
you use something that's specific to

00:29:45.000 --> 00:29:47.380
your situation makes a good KVO context.

00:29:47.380 --> 00:29:48.710
I suggest you do that.

00:29:48.710 --> 00:29:50.020
Secondly, CF retain.

00:29:51.500 --> 00:30:15.200
[Transcript missing]

00:30:15.300 --> 00:30:17.260
happens in a more determined order.

00:30:17.280 --> 00:30:19.720
If you have some tree of objects
that are being deallocated,

00:30:19.740 --> 00:30:22.300
you can be sure that the root of the tree
will be deallocated before the leaves

00:30:22.400 --> 00:30:24.360
if it's releasing the leaves as it goes.

00:30:24.500 --> 00:30:25.810
With garbage detection, that's not true.

00:30:25.840 --> 00:30:30.880
The whole tree is found to be on
reference at the same time and they'll

00:30:30.880 --> 00:30:32.720
get finalized in some arbitrary order.

00:30:32.760 --> 00:30:36.250
And you shouldn't be trying to
message those other objects that

00:30:36.250 --> 00:30:37.960
are being finalized at that point.

00:30:37.960 --> 00:30:40.940
And particularly,
if you accidentally store one and two,

00:30:40.940 --> 00:30:42.260
you'll start getting resurrection errors.

00:30:42.260 --> 00:30:45.860
If you see in your code that things are
complaining about being resurrected,

00:30:45.860 --> 00:30:49.900
it's very likely because you've got code
and finalized that's too complicated.

00:30:49.920 --> 00:30:52.000
Okay, that's enough.

00:30:52.410 --> 00:30:55.500
So we talked about key value
observing with this color property.

00:30:55.540 --> 00:30:58.500
Now I'd actually like to go back
and talk about making it bindable.

00:30:58.500 --> 00:31:00.550
Okay, so what do I mean by this?

00:31:00.580 --> 00:31:02.460
So what's bindings again?

00:31:02.500 --> 00:31:07.900
Bindings is a way of establishing a
two-directional connection between say,

00:31:07.900 --> 00:31:10.400
a view and a model, okay?

00:31:10.470 --> 00:31:13.860
And what you do is you say,
I'd like to bind some property

00:31:13.860 --> 00:31:14.740
of the view to the model.

00:31:14.840 --> 00:31:18.580
And what it does is yes, same as before,
the view is going to observe the model.

00:31:18.620 --> 00:31:22.520
And whenever the model changes,
the view is going to get updated.

00:31:22.550 --> 00:31:25.680
But instead of receiving a
notification of the update,

00:31:25.680 --> 00:31:27.640
that's, it's true,
it does receive a notification.

00:31:27.640 --> 00:31:29.560
But do you think of bindings
as being from the outside?

00:31:29.590 --> 00:31:31.220
It actually does something
with the notification.

00:31:31.220 --> 00:31:33.910
In this case, it would update its view,
okay?

00:31:34.150 --> 00:31:36.240
So you see we're almost there, right?

00:31:36.240 --> 00:31:39.180
But then you also think of bindings
as being a two-way connection.

00:31:39.250 --> 00:31:42.940
So that if the user comes along
and changes the color in the view,

00:31:42.960 --> 00:31:44.420
which in our code is
not actually possible,

00:31:44.460 --> 00:31:48.200
because we haven't
implemented anything for that,

00:31:48.220 --> 00:31:52.640
then it gets pushed down, oh, excuse me,

00:31:55.900 --> 00:32:07.900
The two-directional
connection that uses KVO.

00:32:07.900 --> 00:32:10.620
In our case,
it's fairly clear that it would be nice

00:32:10.620 --> 00:32:12.900
if this color property were bindable.

00:32:12.900 --> 00:32:15.450
What's going to be involved
in implementing a custom

00:32:15.450 --> 00:32:16.900
binding for this object?

00:32:16.900 --> 00:32:18.890
It turns out that nothing is involved.

00:32:18.890 --> 00:32:20.900
This is already bindable.

00:32:20.900 --> 00:32:23.890
We've already written all
the code we have to write.

00:32:23.990 --> 00:32:26.220
So that's worth noting because
custom bindings are sometimes

00:32:26.220 --> 00:32:27.900
thought of as being difficult.

00:32:27.900 --> 00:32:28.820
And there are cases
where they're difficult,

00:32:28.910 --> 00:32:30.900
but there are also
cases where they aren't.

00:32:30.900 --> 00:32:32.960
And during this talk,
I'm going to discuss the easy case,

00:32:32.970 --> 00:32:35.900
and I'm also going to discuss
one step up from the easy case.

00:32:35.900 --> 00:32:38.840
And show that really writing custom
bindings is not such a big deal.

00:32:39.180 --> 00:32:43.900
But first, so let's just see how you
end up using the binding.

00:32:43.900 --> 00:32:45.900
Okay, well this is what we might do.

00:32:45.900 --> 00:32:48.900
We might take our color view,
we'd bind the color binding,

00:32:48.900 --> 00:32:51.900
that's what we define,
to the user defaults controller.

00:32:51.900 --> 00:32:59.590
And then we're going to use the key path,
which is the key path that's specific

00:32:59.590 --> 00:33:03.870
to the way user defaults works.

00:33:04.150 --> 00:33:08.740
And then we have a transformer,
keyed on our archive from data

00:33:08.740 --> 00:33:11.900
transformer name that we're passing
as an option for the binding.

00:33:11.900 --> 00:33:13.900
What does that mean?

00:33:13.900 --> 00:33:15.840
Well,
the only object you can store in defaults

00:33:15.900 --> 00:33:19.900
are of six different P list types,
I think.

00:33:19.900 --> 00:33:23.880
So you can store a number, array,
dictionary, date, and data.

00:33:24.140 --> 00:33:25.830
And that's it, NSData.

00:33:26.060 --> 00:33:29.630
But, and a color is not any of those,
so you cannot directly store a

00:33:29.830 --> 00:33:31.870
color in the preferences database.

00:33:31.980 --> 00:33:36.330
However, it's fairly easy to transform a
color to a data using the fact that

00:33:36.560 --> 00:33:38.900
it conforms to the coding protocol.

00:33:38.900 --> 00:33:40.870
So if you put it through
a keyed archiver,

00:33:40.950 --> 00:33:43.000
what this code is doing is it
says every time you need to

00:33:43.010 --> 00:33:44.770
update the model from the view,
first run it through the

00:33:44.770 --> 00:33:46.690
keyed archiver to make data,
and every time you're

00:33:46.690 --> 00:33:51.070
pulling data out of defaults,
run it through the keyed unarchiver

00:33:51.070 --> 00:33:53.900
to produce the actual color.

00:33:54.140 --> 00:33:55.600
Okay, great.

00:33:55.600 --> 00:33:59.900
Oh, right,
so I was saying that some people

00:33:59.900 --> 00:34:01.900
think of implementing custom
bindings as being difficult.

00:34:01.900 --> 00:34:04.400
Well, the converse of that is that some
people before they looked at it

00:34:04.410 --> 00:34:07.900
very much also think of custom
bindings as being extremely easy.

00:34:07.900 --> 00:34:09.750
Because they think it works like this.

00:34:10.190 --> 00:34:13.900
They think that you should make
your view property observable,

00:34:13.900 --> 00:34:15.900
you should make your
model property observable,

00:34:15.900 --> 00:34:15.900
and you're done.

00:34:15.940 --> 00:34:19.890
And that's not true.

00:34:19.900 --> 00:34:23.900
So the thing to understand is that
bindings are actually asymmetric.

00:34:23.900 --> 00:34:30.020
The view observes the model, that's true,
and whenever the model changes,

00:34:30.020 --> 00:34:32.900
the view gets this notification
and it updates appropriately.

00:34:32.900 --> 00:34:34.900
It gets observed value for keypath.

00:34:34.990 --> 00:34:36.830
But the other direction,
that's not how it works.

00:34:37.140 --> 00:34:39.720
When the view needs to update the model,
it just does it.

00:34:39.900 --> 00:34:41.880
It directly messages.

00:34:41.890 --> 00:34:43.900
I haven't used an observing line here in
the direction from the view to the model.

00:34:43.900 --> 00:34:47.890
I've used a hard line to indicate
that it just has this thing,

00:34:47.920 --> 00:34:51.900
it just uses it directly.

00:34:51.900 --> 00:34:54.900
So what this means, however,
is that the easy case,

00:34:54.900 --> 00:34:59.150
the reason why we fell into this before,
is that we didn't have any need

00:34:59.180 --> 00:35:01.900
to update the model from the view.

00:35:01.900 --> 00:35:03.900
Data was never flowing in that direction.

00:35:03.900 --> 00:35:06.890
It was always flowing in the
direction from the model to the view,

00:35:06.970 --> 00:35:08.900
which meant the KVO stuff
was just working.

00:35:08.900 --> 00:35:11.100
And on top of that,
it was working because of NSObject's

00:35:11.100 --> 00:35:11.900
implementation of the bind value.

00:35:11.900 --> 00:35:17.810
Which I'm going to go through.

00:35:18.110 --> 00:35:19.940
So NSObject implements bind.

00:35:19.940 --> 00:35:23.810
What it does is that in the bind method,
it starts observing the model.

00:35:23.810 --> 00:35:24.730
Okay, fine.

00:35:24.750 --> 00:35:26.320
And it passes its own context.

00:35:26.320 --> 00:35:28.890
No, we're going to keep that
in the back of your head.

00:35:28.970 --> 00:35:29.980
Okay.

00:35:29.980 --> 00:35:32.720
Then it implements
observed value for keypath.

00:35:32.800 --> 00:35:35.470
And when it gets the
context that it expects,

00:35:35.470 --> 00:35:40.020
it dispatches another message to itself,
which is set value for key with the

00:35:40.020 --> 00:35:42.690
value that got pushed up from the model.

00:35:42.690 --> 00:35:43.780
Okay.

00:35:43.780 --> 00:35:45.890
And what does it use as the keypath?

00:35:45.950 --> 00:35:46.790
It uses the binding.

00:35:48.580 --> 00:35:51.960
So that means that when under
under certain conditions,

00:35:51.960 --> 00:35:52.900
that means that's enough.

00:35:52.950 --> 00:35:56.720
Whenever the data is always flowing
from the model to the view and you've

00:35:56.740 --> 00:36:01.700
made a binding whose name exactly
matches a property in your view,

00:36:01.700 --> 00:36:03.150
then you're done.

00:36:03.780 --> 00:36:06.100
Okay, and I did want to point out,
of course,

00:36:06.170 --> 00:36:11.720
this means NSObject really is doing
some observation of almost anything.

00:36:11.720 --> 00:36:15.700
And if you don't check your contexts in
the observed value for keypath method,

00:36:15.700 --> 00:36:17.680
then you're going to block it
and it's going to stop working.

00:36:17.700 --> 00:36:20.210
So be sure to call super and
observe value for keypath if

00:36:20.210 --> 00:36:21.940
you don't recognize the context.

00:36:21.940 --> 00:36:26.870
Then the harder case is when
you do sometimes need to update

00:36:26.870 --> 00:36:29.290
the model using the view.

00:36:29.700 --> 00:36:31.550
We can handle that too.

00:36:31.650 --> 00:36:32.240
Here's our plan for doing that.

00:36:32.260 --> 00:36:35.530
First of all, we have to handle both
directions of data flow.

00:36:35.640 --> 00:36:38.080
But let's let NSObject handle the
data flow whenever it's coming

00:36:38.160 --> 00:36:39.200
from the model to the view.

00:36:39.440 --> 00:36:43.080
What that means is that we're
either not going to override bind

00:36:43.080 --> 00:36:44.890
or we're going to call super.

00:36:45.100 --> 00:37:00.500
[Transcript missing]

00:37:01.640 --> 00:37:04.860
The way this works,
sometimes you think of bindings

00:37:04.860 --> 00:37:06.760
as aliasing two properties.

00:37:06.760 --> 00:37:08.890
You have some property in the
view and you've got a property

00:37:08.890 --> 00:37:11.230
in the model and you think the
bindings makes them the same.

00:37:11.230 --> 00:37:12.340
That's not really true.

00:37:12.340 --> 00:37:15.860
It's more like a default
implementation of a delegate.

00:37:15.860 --> 00:37:18.810
And if you think about the way delegates
work or target action or any of that,

00:37:18.810 --> 00:37:20.100
it's not that they're in sync.

00:37:20.190 --> 00:37:22.540
It's that sometimes the view says,
you know,

00:37:22.540 --> 00:37:24.730
this is a good time to update the model.

00:37:24.740 --> 00:37:27.170
Or with the text system,
it's not like you get every single

00:37:27.290 --> 00:37:31.130
character every time somebody types or
and you don't get because you wouldn't

00:37:31.340 --> 00:37:34.300
want it because you only want the
text when the user is actually done.

00:37:34.340 --> 00:37:35.900
Bindings works the same way.

00:37:35.900 --> 00:37:39.680
It keeps its own copy and it just
updates the model at appropriate times.

00:37:39.760 --> 00:37:41.210
It's just exactly like a delegate.

00:37:41.300 --> 00:37:46.800
Okay, that said, so let's,
as an example for a custom binding,

00:37:46.800 --> 00:37:48.360
let's use Sketch.

00:37:48.360 --> 00:37:53.690
And could I have the demo machine,
please?

00:37:53.690 --> 00:37:53.690
Thank you.

00:37:55.220 --> 00:37:58.200
Okay,
so Sketch is an application that is,

00:37:58.200 --> 00:38:01.320
as an example,
it ships in developer/applications

00:38:01.320 --> 00:38:04.420
whenever you've installed
the developer tools.

00:38:04.520 --> 00:38:06.930
And it is a little drawing program.

00:38:07.000 --> 00:38:09.260
So I'm going to show it off to start.

00:38:09.300 --> 00:38:13.130
So you can make circles,
you can make big rectangles,

00:38:13.200 --> 00:38:17.310
you can color them, salmon, evidently.

00:38:17.540 --> 00:38:22.620
But then what I want to talk about,
that might be a bug or something,

00:38:22.630 --> 00:38:23.320
I don't know.

00:38:25.200 --> 00:38:28.880
What I wanted to mention is that
it has a rather nice class in it,

00:38:28.880 --> 00:38:33.270
which I'm going to talk about,
which is this scroll view here, okay?

00:38:33.490 --> 00:38:37.740
You see the pop-up down in the corner,
it has a zoom property.

00:38:37.800 --> 00:38:40.420
So you can zoom in on the thing.

00:38:40.470 --> 00:38:43.010
And it uses bindings to
do the zoom property.

00:38:43.220 --> 00:38:47.050
And it falls into the easy case,
actually, because the scroll view,

00:38:47.180 --> 00:38:51.380
there's no way to update the
zoom from the scroll view itself.

00:38:51.430 --> 00:38:55.730
There's just also this pop-up button,
which can control it.

00:38:55.830 --> 00:38:58.120
But the pop-up button pushes
data down to the model.

00:38:58.150 --> 00:39:01.460
The model,
and then the data pops back up into the

00:39:01.520 --> 00:39:03.360
view and actually updates the scroll.

00:39:03.580 --> 00:39:04.400
Okay, that's great.

00:39:04.400 --> 00:39:05.240
That's how that already works.

00:39:05.240 --> 00:39:06.600
I was saying that's the easy case.

00:39:06.630 --> 00:39:08.450
Why, however,
am I saying that we're going

00:39:08.460 --> 00:39:09.760
to do the hard case in Sketch?

00:39:09.790 --> 00:39:14.170
Well, something that might be nice
with this is that in 10.6,

00:39:14.220 --> 00:39:15.960
we have support for gesture events.

00:39:15.990 --> 00:39:17.880
In Mac OS X,
the same as you have on the phone.

00:39:17.940 --> 00:39:21.020
So if you have a new model
MacBook Pro or MacBook Air,

00:39:21.020 --> 00:39:24.700
such as the one that I'm using right now,
then if you make a pinch

00:39:24.700 --> 00:39:30.090
gesture on your trackpad,
then you can magnify or back away

00:39:30.220 --> 00:39:31.500
from whatever you're looking at.

00:39:31.500 --> 00:39:34.080
So it would be really nice if
our scroll view had that ability.

00:39:34.120 --> 00:39:36.530
But when we add that ability,
it's going to knock us into the

00:39:36.530 --> 00:39:38.440
hard case because we're going
to have to start having to,

00:39:38.470 --> 00:39:41.360
we're going to need to be able to push
data from the view into the model.

00:39:41.390 --> 00:39:44.120
So that's what we're going to do.

00:39:44.280 --> 00:39:48.280
First, let's just take a look at
what the code looks like for

00:39:48.280 --> 00:39:50.590
now for the existing binding.

00:39:50.800 --> 00:40:05.600
[Transcript missing]

00:40:06.140 --> 00:40:08.230
What it's doing here
is it's grabbing the,

00:40:08.240 --> 00:40:12.160
it's taking the,
say somebody tries to bind this property,

00:40:12.160 --> 00:40:14.180
which is a scroll view zoom factor, okay?

00:40:14.180 --> 00:40:18.200
Then it binds the pop-up button,
and then it also calls super.

00:40:18.200 --> 00:40:20.540
So if I could switch back
to the slides for a minute,

00:40:20.540 --> 00:40:22.380
I'd like to diagram what's going on.

00:40:24.120 --> 00:40:24.890
Thank you.

00:40:25.110 --> 00:40:25.740
Okay, so here's what happens.

00:40:25.760 --> 00:40:29.270
So when somebody comes along and says,
scroll view,

00:40:29.400 --> 00:40:31.150
please bind your factor to the model.

00:40:31.150 --> 00:40:35.720
The scroll view has this internal
pop-up instance variable,

00:40:36.230 --> 00:40:38.100
basically, that's opaque.

00:40:38.100 --> 00:40:39.290
The model doesn't know about it.

00:40:39.390 --> 00:40:41.670
Okay, so you would think that that
means that the scroll view,

00:40:41.670 --> 00:40:44.000
it does need to sometimes push data
down to the model because the user

00:40:44.090 --> 00:40:45.540
can manipulate the pop-up button.

00:40:45.710 --> 00:40:50.550
But what it does is that rather
than directly messaging its pop-up,

00:40:50.730 --> 00:40:55.330
when somebody asks it to bind,
it first tells its internal pop-up

00:40:55.410 --> 00:40:59.800
variable to bind to the model,
and then it goes ahead and calls super,

00:40:59.800 --> 00:41:03.750
which means it's taking advantage of
the NS object level implementation

00:41:03.750 --> 00:41:06.980
of bind in addition to having
bound the pop-up button so that

00:41:07.140 --> 00:41:10.210
whenever the model changes,
both the pop-up and the scroll

00:41:10.210 --> 00:41:11.900
view are going to update.

00:41:11.940 --> 00:41:13.770
Ken Ferrry This is a little bit unusual.

00:41:13.780 --> 00:41:15.620
It actually means that the
scroll view is going to update.

00:41:15.620 --> 00:41:17.560
So the scroll view is bindings only.

00:41:17.570 --> 00:41:20.410
You can't directly tell the scroll
view to change its zoom factor because

00:41:20.410 --> 00:41:22.620
it would not update its pop-up.

00:41:23.100 --> 00:41:46.400
[Transcript missing]

00:41:48.770 --> 00:41:49.540
Okay, great.

00:41:49.560 --> 00:41:50.570
So that's that.

00:41:50.650 --> 00:41:52.530
So like I said,
what this method does is it

00:41:52.590 --> 00:41:54.890
really just creates the pop-up
button if it isn't already there.

00:41:54.890 --> 00:41:57.740
It binds the pop-up button,
and then it just calls

00:41:57.740 --> 00:41:59.290
super unconditionally.

00:41:59.290 --> 00:42:00.720
And that's how that works.

00:42:00.720 --> 00:42:01.430
Okay, great.

00:42:01.750 --> 00:42:05.340
So now let's go ahead and actually
implement our gesture support.

00:42:05.360 --> 00:42:09.480
So I have my pop-up that I did
with PagmaMark for event handling.

00:42:09.480 --> 00:42:13.050
The reason there wasn't anything
there is because it was commented out.

00:42:13.100 --> 00:42:15.160
So let's go ahead and uncomment it now.

00:42:15.160 --> 00:42:18.550
What happens is that when the user
makes a pinch gesture or something

00:42:18.550 --> 00:42:22.660
that's supposed to be able to change
something like a zooming on your view,

00:42:22.890 --> 00:42:26.730
and its application and its window
will dispatch this method to you,

00:42:26.730 --> 00:42:28.570
which is magnify with event.

00:42:28.600 --> 00:42:30.650
It's very easy to use.

00:42:30.650 --> 00:42:35.460
And what you can do is you can pull
the magnification out of the event,

00:42:35.460 --> 00:42:37.710
which is a change in percent.

00:42:37.780 --> 00:42:42.330
So if you get something like
0.25 as the magnification,

00:42:42.360 --> 00:42:46.580
that means... Increase
your zoom factor by 0.25.

00:42:46.580 --> 00:42:48.730
So if you're currently
at 100% and you get that,

00:42:48.730 --> 00:42:53.200
then you want to go up to 125%. If you
get minus 0.25 and you're at 100%,

00:42:53.200 --> 00:42:55.920
you want to go down to 75%. This,
we luck out,

00:42:56.040 --> 00:42:59.130
and it's exactly how Sketch models
it in the first place.

00:42:59.130 --> 00:43:03.210
There's a factor instance variable,
which is the zoom, which is the scaling.

00:43:03.220 --> 00:43:07.160
And what we want to do with the
magnification is we just want to add it.

00:43:07.170 --> 00:43:11.580
So if you're at 1,
it goes up to 1.25 or down to 0.75.

00:43:11.580 --> 00:43:17.240
However... We do have to cap it because
the app kit is not smart enough to know,

00:43:17.240 --> 00:43:20.520
hey,
this is already zoomed in all the way.

00:43:20.520 --> 00:43:21.520
You can't go any further.

00:43:21.520 --> 00:43:23.790
I mean,
it might start sending you minus 0.25

00:43:23.800 --> 00:43:25.610
events when you're already down to 0.

00:43:25.620 --> 00:43:30.010
So I have a method up here, which just...

00:43:30.360 --> 00:43:34.880
caps the scaling to clamps
it to some reasonable values.

00:43:34.920 --> 00:43:38.170
So it has both a min and a max,
and it makes sure that

00:43:38.230 --> 00:43:39.650
we don't exceed them.

00:43:39.700 --> 00:43:43.620
Okay, so then we have our new factor,
and then we need to set it.

00:43:43.700 --> 00:43:46.380
Now,
because of the way the scroll view works,

00:43:46.380 --> 00:43:47.980
like I said,
because it's actually bindings only,

00:43:47.980 --> 00:43:52.700
what we can do is we can just
update our model and let those

00:43:52.700 --> 00:43:56.940
changes bounce back into both the
scroll view and the pop-up button.

00:43:56.960 --> 00:43:58.940
And that's what I'm going
to do in this method.

00:43:59.130 --> 00:44:02.310
Set value for binding,
which I just made up myself,

00:44:02.480 --> 00:44:06.180
and I probably should have given a
prefix because that's too generic.

00:44:06.240 --> 00:44:09.190
So don't do that.

00:44:09.640 --> 00:44:13.940
Okay, so how does it work?

00:44:14.040 --> 00:44:17.320
So you grab the binding
info for this binding,

00:44:17.320 --> 00:44:18.470
whatever it is.

00:44:18.600 --> 00:44:21.360
Okay, if it's not nil,
that means you're bound.

00:44:21.360 --> 00:44:23.260
If it's nil,
something weird has happened,

00:44:23.260 --> 00:44:24.280
and we just want to ignore that.

00:44:24.280 --> 00:44:25.750
Actually, I guess it might not be weird.

00:44:25.760 --> 00:44:27.020
It might just mean you're not bound.

00:44:27.020 --> 00:44:29.620
We'll pull out the observer,
and we'll just say, okay,

00:44:29.620 --> 00:44:30.660
you asked for the observed
object using this documented key.

00:44:30.660 --> 00:44:33.100
You asked the binding info for,
this is just a dictionary.

00:44:33.100 --> 00:44:35.380
You ask it for its observed object.

00:44:35.490 --> 00:44:36.080
Okay, great.

00:44:36.080 --> 00:44:38.090
You ask it for the observed key path.

00:44:38.180 --> 00:44:39.060
Fine.

00:44:39.060 --> 00:44:41.110
All right,
and then we just need to update it.

00:44:41.300 --> 00:44:45.320
So we will say observed
object set value for key path.

00:44:45.570 --> 00:44:48.050
That's going to update the model,
and that's all it takes.

00:44:48.160 --> 00:44:51.100
And then that will, because of the
KVO observation we're doing,

00:44:51.100 --> 00:44:57.300
will always bounce back into both our
scroll view and the pop-up button.

00:44:57.320 --> 00:44:59.070
So let's just see it.

00:44:59.230 --> 00:45:00.460
We're actually done.

00:45:00.460 --> 00:45:04.960
So if I make this guy,
and I make it some nice color,

00:45:04.960 --> 00:45:08.180
and you'll have to take my word for
it that I'm actually going to start

00:45:08.200 --> 00:45:10.770
using the fancy gesture events,
but there they are.

00:45:12.220 --> 00:45:14.640
So it works really nicely.

00:45:14.640 --> 00:45:15.500
Okay.

00:45:15.500 --> 00:45:16.440
And that's it.

00:45:16.470 --> 00:45:17.840
So, yeah.

00:45:18.330 --> 00:45:20.360
Pretty easy.

00:45:20.360 --> 00:45:24.480
I hope that that made sense.

00:45:24.480 --> 00:45:24.480
I don't know.

00:45:27.320 --> 00:45:30.590
Okay, the one thing that I did want
to mention is that there are a

00:45:30.590 --> 00:45:33.600
number of options that people
use when they're doing binding.

00:45:33.600 --> 00:45:34.810
I, in fact, already showed one.

00:45:34.960 --> 00:45:42.510
I showed using the value
transformer name option to say what

00:45:42.830 --> 00:45:45.460
transformations we want it done.

00:45:45.570 --> 00:45:47.810
And what I've just,
when you're pushing things

00:45:47.840 --> 00:45:49.330
from the view to the model.

00:45:49.570 --> 00:45:51.040
And I haven't done that.

00:45:51.180 --> 00:45:53.560
So I haven't accommodated
any of those options.

00:45:53.590 --> 00:45:56.170
And the reason I've done that,
I haven't done it,

00:45:56.170 --> 00:45:57.630
is because it's too hard.

00:45:57.710 --> 00:45:59.120
Because there are a lot of options.

00:45:59.120 --> 00:46:00.370
There's a value transformer.

00:46:00.370 --> 00:46:01.810
There's a value transformer name.

00:46:01.810 --> 00:46:03.060
There's any number of things.

00:46:03.060 --> 00:46:04.960
You have to handle them all individually.

00:46:04.960 --> 00:46:07.500
And there's no way to
expand it in the future.

00:46:07.500 --> 00:46:10.460
So really what I'm saying is that, again,
this is a case where

00:46:10.460 --> 00:46:13.250
just look at what you,
you don't need to handle everything

00:46:13.340 --> 00:46:15.490
completely generically all the time.

00:46:15.660 --> 00:46:17.750
Just do what your code needs to do.

00:46:17.750 --> 00:46:21.750
And because we don't need any fancy
value transformers at the moment,

00:46:21.760 --> 00:46:23.690
I'm just not doing them.

00:46:23.880 --> 00:46:25.180
And I'll do them as necessary.

00:46:25.180 --> 00:46:27.890
And hopefully maybe AppKit can try to,
in the future,

00:46:28.040 --> 00:46:31.120
do something that is sufficiently
generic that would be able to

00:46:31.120 --> 00:46:32.820
handle all the options for you.

00:46:32.900 --> 00:46:33.780
But it's not there yet.

00:46:33.960 --> 00:46:36.310
So this is probably what you ought to do.

00:46:36.420 --> 00:46:37.610
Could I have the slides back, please?

00:46:42.500 --> 00:53:05.300
[Transcript missing]
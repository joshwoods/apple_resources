WEBVTT

00:00:21.440 --> 00:00:22.080
Welcome, everyone.

00:00:22.300 --> 00:00:24.460
Hope you can hear me OK.

00:00:24.570 --> 00:00:25.540
Great.

00:00:25.690 --> 00:00:28.540
Well, I just want to say we are really,
really thrilled to be doing

00:00:28.540 --> 00:00:32.860
today's presentation on 3D graphics
for iPhone OS using OpenGL ES.

00:00:32.860 --> 00:00:36.600
And as we look out at the crowd here,
it's really great to see all of you here.

00:00:36.600 --> 00:00:39.060
As Steve and Bertrand
and Scott have mentioned,

00:00:39.060 --> 00:00:41.760
we do believe this is the
birth of a real new platform,

00:00:41.760 --> 00:00:42.920
brand new platform.

00:00:42.920 --> 00:00:46.720
And you guys are all the key to
making that platform a reality.

00:00:46.720 --> 00:00:51.280
So we are looking at teaching
you today about OpenGL ES.

00:00:51.300 --> 00:00:53.020
And we're going to talk about
OpenGL ES on the iPhone.

00:00:53.040 --> 00:00:58.860
And to do that, we're going to take a
brief look at our agenda.

00:00:59.330 --> 00:01:01.850
So first off,
first thing we're going to do

00:01:01.910 --> 00:01:07.880
in today's talk is talk about
a brief overview of OpenGL ES,

00:01:07.920 --> 00:01:12.340
what it is, and how you'll use it,
and how it compares to desktop OpenGL,

00:01:12.340 --> 00:01:15.000
which you've probably used before,
or how it compares to some

00:01:15.060 --> 00:01:18.830
other 3D programming APIs,
which you might be familiar with.

00:01:19.050 --> 00:01:23.260
The next thing that we're going to do
is talk about OpenGL ES on the iPhone.

00:01:23.400 --> 00:01:27.600
Now, in developing OpenGL ES for
the iPhone OS,

00:01:27.650 --> 00:01:32.270
We implemented some new APIs,
we created some key technologies,

00:01:32.380 --> 00:01:36.500
and we developed some key concepts
that we want you to become familiar

00:01:36.710 --> 00:01:38.920
with as you develop your applications.

00:01:38.980 --> 00:01:41.240
And the reason that we want you to
become familiar with these concepts

00:01:41.240 --> 00:01:43.800
in particular is that some of
them are unique to the iPhone OS,

00:01:43.820 --> 00:01:46.980
and some of them are simply
unique to embedded development,

00:01:47.100 --> 00:01:51.040
developing for small consumer
electronics products like the iPhone,

00:01:51.200 --> 00:01:53.820
and other products in this similar class.

00:01:53.960 --> 00:01:57.180
And this may be an area where
you may not be familiar with if

00:01:57.180 --> 00:01:59.210
you've done desktop programming.

00:01:59.710 --> 00:02:02.990
Some of those key technologies
are the areas of integration

00:02:02.990 --> 00:02:07.160
with the rest of the iPhone OS,
and some of them are some new APIs.

00:02:07.210 --> 00:02:09.320
We'll talk about those today.

00:02:10.250 --> 00:02:12.390
Next,
we'll talk about the iPhone simulator

00:02:12.390 --> 00:02:14.860
and OpenGL ES support there,
and how you can use it,

00:02:14.930 --> 00:02:17.400
how you can use it to
develop your application,

00:02:17.400 --> 00:02:19.920
what it's good for,
and what you need to use

00:02:19.920 --> 00:02:21.780
the device for instead.

00:02:22.560 --> 00:02:26.410
And last, we'll talk about our
recommendations for best practices,

00:02:26.810 --> 00:02:30.660
some caveats with the device,
and just how to use the device to be

00:02:30.770 --> 00:02:35.240
the most efficient and to develop the
most highest performing and the best

00:02:35.240 --> 00:02:37.660
looking applications that you can.

00:02:37.770 --> 00:02:41.840
So let's move to the next section
of our talk today and begin

00:02:41.840 --> 00:02:45.670
by thinking about some of our
assumptions about your background.

00:02:45.810 --> 00:02:48.400
So first of all,
this is not going to be a talk

00:02:48.530 --> 00:02:50.130
to teach basic 3D graphics.

00:02:50.230 --> 00:02:52.720
We're going to assume you have
some background in this area.

00:02:52.780 --> 00:02:54.860
And judging by the size
of the crowd here today,

00:02:55.020 --> 00:02:56.720
I can assume that that's probably true.

00:02:56.720 --> 00:02:59.650
There's a lot of folks here,
and it looks like you're ready to do

00:02:59.650 --> 00:03:01.970
some very cool 3D graphics programming.

00:03:02.100 --> 00:03:08.130
So we'll also assume that you know
OpenGL 1.5 and its extension mechanism.

00:03:09.240 --> 00:03:12.240
There's a few other key technologies
we'll make the assumption that you

00:03:12.240 --> 00:03:13.670
know at least a little bit about.

00:03:13.670 --> 00:03:15.970
The first of those is
Cocoa and Objective-C,

00:03:15.970 --> 00:03:18.680
or Cocoa Touch today,
as we've talked about in the iPhone,

00:03:18.680 --> 00:03:21.780
and Core Animation and UI Kit.

00:03:21.900 --> 00:03:25.420
Now, on these last two subjects,
you might not be experts yet.

00:03:25.440 --> 00:03:28.580
There's a ton of great information
here at WWDC in the iPhone SDK on

00:03:28.630 --> 00:03:32.830
Apple's developer website for you to
familiarize yourself with these concepts.

00:03:32.870 --> 00:03:34.550
And we won't be looking
at them too deeply,

00:03:34.550 --> 00:03:37.010
but we do assume a little bit of
familiarity to understand some

00:03:37.010 --> 00:03:38.600
of the code snippets we'll show.

00:03:39.490 --> 00:03:40.660
All right.

00:03:40.800 --> 00:03:42.890
With that, let's begin.

00:03:43.580 --> 00:03:45.440
So as we mentioned,
the first thing we'd like to do is

00:03:45.550 --> 00:03:48.310
start with an overview of OpenGL ES.

00:03:48.450 --> 00:03:51.950
And the very first thing you
need to know about OpenGL ES is

00:03:51.950 --> 00:03:54.870
that it is a subset of OpenGL.

00:03:54.980 --> 00:03:57.820
So if you've done
OpenGL programming on the Mac,

00:03:57.860 --> 00:04:02.660
on Windows, on other platforms,
you'll feel right at home with OpenGL ES.

00:04:02.730 --> 00:04:04.920
The basic concepts are the same.

00:04:04.970 --> 00:04:08.840
The basic methodology programming
the API is extremely similar.

00:04:08.890 --> 00:04:11.340
And you can use the same
basic programming techniques

00:04:11.530 --> 00:04:13.770
for your 3D graphics.

00:04:14.390 --> 00:04:16.530
OpenGL ES is an industry standard.

00:04:16.540 --> 00:04:19.390
It's an open standard,
which means it has multi-platform

00:04:19.450 --> 00:04:22.870
support across a wide
variety of hardware vendors.

00:04:23.250 --> 00:04:26.860
This list of hardware vendors includes
many hardware vendors that maybe you

00:04:26.860 --> 00:04:30.130
haven't even seen before if you haven't
done embedded device programming.

00:04:30.260 --> 00:04:32.730
But it's actually
incredibly well supported,

00:04:32.730 --> 00:04:35.270
and there are just literally millions,
if not billions,

00:04:35.300 --> 00:04:38.360
of devices using this API.

00:04:40.650 --> 00:04:48.070
The reason that it is a subset of
Open GL 1.5 is part of -- part of the

00:04:48.070 --> 00:04:51.910
reason is because it is focused on
targeting an embedded class device.

00:04:52.050 --> 00:04:52.930
And what does that mean?

00:04:53.110 --> 00:04:55.220
Well, these are small consumer
electronics devices.

00:04:55.220 --> 00:04:57.500
They typically run off a battery.

00:04:57.610 --> 00:04:59.290
The iPhone is a perfect example.

00:04:59.420 --> 00:05:04.070
But others are set-top boxes, GPS units,
other types of small devices.

00:05:04.440 --> 00:05:09.250
And the API is specifically targeted
to try and drive this class of device.

00:05:09.410 --> 00:05:12.690
And as we talk about what Open GL ES is
a little later in the presentation,

00:05:12.950 --> 00:05:17.230
you can see how certain design choices
were made to favor these devices.

00:05:18.080 --> 00:05:21.010
Perhaps most importantly, though,
OpenGL ES is a full-featured

00:05:21.010 --> 00:05:22.620
hardware acceleration API.

00:05:22.750 --> 00:05:26.780
So it fully supports 3D graphics
programming with fixed function

00:05:26.780 --> 00:05:30.030
vertex and pixel processing.

00:05:31.690 --> 00:05:33.920
So as we move on,
let's take a look first at some of the

00:05:34.010 --> 00:05:38.550
API design goals of why OpenGL ES was
created the way that it was.

00:05:38.660 --> 00:05:40.580
As I mentioned,
it was specifically designed

00:05:40.710 --> 00:05:42.480
for embedded class devices.

00:05:42.590 --> 00:05:46.190
Now, really what this means in terms
of the API design is that the

00:05:46.300 --> 00:05:50.130
API had to be designed for the
implementations themselves to be smaller.

00:05:50.400 --> 00:05:51.800
Smaller in lots of ways.

00:05:51.910 --> 00:05:53.570
Smaller in the amount
of power that they use,

00:05:53.690 --> 00:05:56.240
because these devices are
typically on a battery or some

00:05:56.240 --> 00:05:57.800
other limited power budget.

00:05:57.930 --> 00:06:00.190
Smaller in the amount of
memory that they consume.

00:06:00.310 --> 00:06:03.180
Smaller in the amount of processor
cycles that they consume.

00:06:03.300 --> 00:06:06.670
The typical processors and
memory systems for these devices,

00:06:06.800 --> 00:06:10.100
while incredibly powerful,
might be considerably smaller than what

00:06:10.100 --> 00:06:16.590
you're used to if you've done any kind of
desktop or workstation class programming.

00:06:17.560 --> 00:06:22.540
A second key point about the API design
goals for OpenGL ES is that there was an

00:06:22.630 --> 00:06:27.500
intention in the design to take advantage
of the fact that the API was new.

00:06:27.650 --> 00:06:29.500
And it was targeting a
new class of devices,

00:06:29.600 --> 00:06:32.280
trying to bring this
functionality to them.

00:06:32.680 --> 00:06:35.550
As a result,
there wasn't a huge amount of legacy

00:06:35.550 --> 00:06:37.460
support that people had to worry about.

00:06:37.610 --> 00:06:40.420
And while they wanted to
maintain a certain consistency

00:06:40.420 --> 00:06:44.990
with the API of OpenGL,
there was not a need to retain

00:06:44.990 --> 00:06:48.120
exact binary or API compatibility.

00:06:48.180 --> 00:06:53.680
And this gave us, the Kronos group,
who developed OpenGL ES API,

00:06:53.730 --> 00:06:58.120
an opportunity to actually
remove some obsolete functions,

00:06:58.290 --> 00:07:01.400
to clean up the API,
and to think very carefully about

00:07:01.400 --> 00:07:04.220
what to include and what not to
include in order to fit in some of

00:07:04.330 --> 00:07:06.960
these constraints I've just outlined.

00:07:07.650 --> 00:07:10.840
And as a consequence,
or perhaps another motivation

00:07:11.400 --> 00:07:13.570
for this type of design,

00:07:22.330 --> 00:07:32.320
So, the API was consciously designed
with the idea that there does not

00:07:32.320 --> 00:07:33.810
have to be a software fallback
or a means for the CPU to execute

00:07:33.820 --> 00:07:33.830
things that the GPU cannot.

00:07:33.830 --> 00:07:33.850
As a result,
what's actually in the API is very,

00:07:33.850 --> 00:07:33.890
very likely to be hardware accelerated.

00:07:33.890 --> 00:07:33.930
And this is actually a benefit to you,
because you can actually use it

00:07:33.930 --> 00:07:34.200
to run things that the GPU cannot.

00:07:54.200 --> 00:07:54.200
And this is actually a benefit to you,
because you can actually use it

00:07:54.200 --> 00:07:54.200
to run things that the GPU cannot.

00:07:54.660 --> 00:07:57.030
All right,
so let's take a look next at the

00:07:57.030 --> 00:07:59.200
traditional 3D graphics pipeline.

00:07:59.200 --> 00:08:01.500
If you've done any
OpenGL programming before,

00:08:01.660 --> 00:08:03.100
this will look very familiar to you.

00:08:03.100 --> 00:08:06.660
And this is the exact same 3D
pipeline used by OpenGL ES.

00:08:06.660 --> 00:08:11.050
So you start with your traditional
stages of geometry processing,

00:08:11.160 --> 00:08:13.660
rasterization, texturing,
fragment processing,

00:08:13.760 --> 00:08:15.380
and frame buffer operations.

00:08:15.380 --> 00:08:19.880
And you'll see that as we walk
through the features of OpenGL ES,

00:08:19.880 --> 00:08:23.840
that these same stages,
the same pipeline applies.

00:08:25.480 --> 00:08:28.520
So what I'm going to do next is kind of
walk through each of these stages and

00:08:28.520 --> 00:08:32.810
show specific features in OpenGL ES,
and particularly how they

00:08:32.810 --> 00:08:34.900
compare to desktop OpenGL.

00:08:35.030 --> 00:08:40.840
And this should give you a good feel for
what's in the API and how you can use it.

00:08:41.010 --> 00:08:45.260
So let's take a look first at
the geometry processing stage.

00:08:45.370 --> 00:08:49.600
Now, the first thing I want to say on
this slide in particular is that you

00:08:49.600 --> 00:08:53.060
can see from the sort of inclusion
features here of what's included and

00:08:53.060 --> 00:08:57.580
what's been removed relative to desktop
OpenGL that this is a full-featured API.

00:08:57.860 --> 00:09:03.300
It fully supports geometry processing,
vertex array-based rendering,

00:09:03.360 --> 00:09:06.500
buffer objects, vertex lighting, shading,
et cetera.

00:09:06.620 --> 00:09:08.700
But there's a few key features
that have been removed.

00:09:08.770 --> 00:09:10.740
And again,
the reason they've been removed

00:09:10.880 --> 00:09:13.690
is because some of these
features are inefficient,

00:09:13.830 --> 00:09:16.410
perhaps inefficient
even on desktop systems.

00:09:16.540 --> 00:09:18.840
Some of them have become redundant,
and then a few of them are not

00:09:18.890 --> 00:09:22.120
likely to be accelerated on some
of these embedded class devices.

00:09:22.120 --> 00:09:23.310
Thank you.

00:09:24.110 --> 00:09:26.240
The one you're going to notice here,
probably if you've done any

00:09:26.240 --> 00:09:28.930
OpenGL programming before,
that's probably the most key,

00:09:29.060 --> 00:09:30.780
is the immediate mode entry points.

00:09:30.910 --> 00:09:34.340
Specifying vertices one at a
time is likely to be inefficient,

00:09:34.430 --> 00:09:38.710
again, even on desktop systems,
and was removed from the API.

00:09:39.380 --> 00:09:43.050
Let's take a look next at the
rasterization phase of the pipeline.

00:09:43.150 --> 00:09:45.960
And here, once again,
there's very full features.

00:09:46.080 --> 00:09:49.920
So you've seen from some of the demos
that we've done so far that you can

00:09:50.050 --> 00:09:55.220
create really terrific looking 3D
games and applications with OpenGL ES.

00:09:55.260 --> 00:09:59.860
In fact,
you can see some of those games in

00:10:00.340 --> 00:10:04.510
Steve's keynote and some of the other
examples from the application store.

00:10:07.400 --> 00:10:08.550
Now, a few key features here
have been removed as well.

00:10:08.640 --> 00:10:11.340
So if you look on the right side,
you'll see quad and polygon

00:10:11.350 --> 00:10:12.530
primitives have been removed.

00:10:12.540 --> 00:10:14.910
And once again,
the reason they've been removed is

00:10:15.000 --> 00:10:16.420
because they're largely redundant.

00:10:16.540 --> 00:10:21.400
You can actually do quads and polygons
with triangles and other techniques.

00:10:22.000 --> 00:10:24.340
Things like draw pixels and copy
pixels have also been removed.

00:10:24.490 --> 00:10:26.690
But again,
you can implement these with what's

00:10:26.690 --> 00:10:28.190
remaining in the OpenGL ES API.

00:10:28.310 --> 00:10:32.230
So this is all an attempt to make
the API smaller to fit in the types

00:10:32.230 --> 00:10:36.230
of devices that can fit in your
pocket or that are just generally

00:10:36.580 --> 00:10:39.610
constrained to run the OpenGL ES API.

00:10:40.960 --> 00:10:44.620
In the texturing stage,
here you have 2D texturing,

00:10:44.620 --> 00:10:47.090
multi-texturing,
lots of different formats,

00:10:47.150 --> 00:10:49.650
lots of different filters,
mipmap generation.

00:10:49.920 --> 00:10:51.380
So again, it's very full-featured.

00:10:51.730 --> 00:10:54.660
However, certain features,
such as secondary color,

00:10:54.670 --> 00:10:56.870
and features that might require
a considerable amount of memory,

00:10:56.880 --> 00:11:00.260
such as 3D texturing,
or that might require a considerable

00:11:00.260 --> 00:11:03.020
amount of CPU processing,
such as converting from one

00:11:03.020 --> 00:11:06.880
type of pixel format to another,
have been removed.

00:11:07.720 --> 00:11:14.440
And last, when we look in the
fragment processing stage,

00:11:14.510 --> 00:11:17.520
when we look at this stage,
we actually see that there's not

00:11:17.520 --> 00:11:19.390
very much that's been removed at all.

00:11:19.590 --> 00:11:21.160
There's a few blend equations
that have been removed,

00:11:21.260 --> 00:11:24.010
but largely the whole feature
set is there from OpenGL.

00:11:24.100 --> 00:11:26.940
And this is key,
because most of your processing in these

00:11:26.940 --> 00:11:30.650
types of devices is in the pixel space,
in the fragment processing space.

00:11:30.770 --> 00:11:33.710
And the API here is very full-featured.

00:11:34.800 --> 00:11:39.000
And finally, if we took a look at frame
buffer operations and some of the

00:11:39.000 --> 00:11:43.200
miscellaneous features of the API,
we can see that there's actually

00:11:43.580 --> 00:11:46.820
only a few things that are probably
unlikely to be used in this space

00:11:47.000 --> 00:11:48.260
that are actually been removed.

00:11:48.350 --> 00:11:50.400
So double precision is a good example.

00:11:50.470 --> 00:11:52.700
Because double precision
is a feature that,

00:11:52.750 --> 00:11:56.860
once again, on the desktop is often not
even accelerated and has

00:11:56.860 --> 00:11:58.520
been removed from the API.

00:11:58.580 --> 00:12:01.450
Or other features that require a
certain amount of CPU-based processing,

00:12:01.460 --> 00:12:05.220
such as pushing and
popping your OpenGL state.

00:12:05.470 --> 00:12:09.390
I've gone through this in a hurry
because we mostly want to point you

00:12:09.510 --> 00:12:13.880
at the official specification for
OpenGL ES to give you all of the details.

00:12:13.880 --> 00:12:17.640
If you take a look at Kronos' website,
as I mentioned earlier,

00:12:17.640 --> 00:12:20.990
Kronos is the organization that
controls the OpenGL ES standard.

00:12:21.020 --> 00:12:25.200
This is an open standard,
just like OpenGL, which they also define.

00:12:25.200 --> 00:12:27.580
They have a website that
defines all of this.

00:12:27.640 --> 00:12:30.560
It provides a full
specification of the behavior,

00:12:30.560 --> 00:12:33.460
and it also provides a
different specification,

00:12:33.460 --> 00:12:35.380
sort of similar to what
I've been doing here today.

00:12:35.460 --> 00:12:37.960
Theirs is actually much more
formal and much more detailed.

00:12:37.960 --> 00:12:40.210
So here's an example showing
some of the features that

00:12:40.210 --> 00:12:42.960
are present in OpenGL ES and
some of them that are absent.

00:12:43.140 --> 00:12:46.380
And you can compare this to the
full OpenGL specification to get

00:12:46.410 --> 00:12:49.170
a good feel for what's in the API.

00:12:49.990 --> 00:12:51.780
So in the interest of time,
I'm going to move on from what's

00:12:51.790 --> 00:12:56.290
actually in the OpenGL ES core
functionality set itself and talk a

00:12:56.290 --> 00:12:59.150
little bit about OpenGL ES extensions.

00:12:59.160 --> 00:13:04.650
So OpenGL ES extensions work
just like OpenGL extensions.

00:13:04.660 --> 00:13:07.040
And this is important in
a couple different ways.

00:13:07.140 --> 00:13:09.650
First of all,
it's the exact same mechanism

00:13:09.650 --> 00:13:11.260
that you used in OpenGL.

00:13:11.260 --> 00:13:14.250
So if you've done OpenGL programming,
you know that you have to query

00:13:14.250 --> 00:13:17.560
for the list of extensions that are
supported by your implementation.

00:13:18.700 --> 00:13:21.700
And that those extensions can
be named to indicate whether

00:13:21.730 --> 00:13:24.740
they're supported by one vendor,
multiple vendors,

00:13:24.740 --> 00:13:27.820
or some official extension
by the Kronos group.

00:13:27.860 --> 00:13:32.610
Such extensions would have
the arb or oes suffix on them.

00:13:32.620 --> 00:13:33.730
So let's go ahead and look at some
of the extensions that we've used.

00:13:34.560 --> 00:13:36.840
And this last point up here is key.

00:13:36.890 --> 00:13:40.020
Implementations will support
different sets of extensions,

00:13:40.020 --> 00:13:43.040
perhaps across different
driver revisions.

00:13:43.140 --> 00:13:46.960
So you need to make sure to always query
for the extensions before you use them,

00:13:47.160 --> 00:13:50.000
and make sure that you are prepared
to deal with their presence or

00:13:50.120 --> 00:13:53.560
absence at any given time if you
choose to use extension features.

00:14:06.370 --> 00:14:06.620
So we won't talk about all of the
extensions that we support in the

00:14:06.620 --> 00:14:06.620
OpenGL ES implementation on the iPhone,
but we'll talk about a couple of them

00:14:06.620 --> 00:14:06.620
because they highlight some kind of key
characteristics of OpenGL ES extensions.

00:14:06.840 --> 00:14:11.700
So the first one I want to highlight
here is the OES map buffer extension.

00:14:11.740 --> 00:14:13.810
I call this one out not
necessarily because it's an

00:14:13.810 --> 00:14:16.960
amazing piece of functionality,
but it's a good example of

00:14:16.960 --> 00:14:21.880
a feature which is actually
a core part of OpenGL 1.5,

00:14:21.890 --> 00:14:22.680
meaning it's required.

00:14:22.680 --> 00:14:24.170
Every implementation supports it.

00:14:24.380 --> 00:14:27.060
And it's actually an optional
extension in OpenGL ES.

00:14:27.060 --> 00:14:30.310
The API is essentially the same.

00:14:30.320 --> 00:14:33.440
It has some suffixes on the function
entry points and enumerants,

00:14:33.440 --> 00:14:35.540
but otherwise it's basically the same.

00:14:35.540 --> 00:14:38.900
And like all extensions,
you need to query before you use it

00:14:38.910 --> 00:14:42.370
to find out whether it's present or
not on your particular implementation.

00:14:42.370 --> 00:14:47.180
On ours it is, but this is a good example
of this type of extension.

00:14:48.740 --> 00:14:55.840
Another key extension that is a good
example to show about certain properties

00:14:55.840 --> 00:15:01.430
of extensions in OpenGL ES is the
IMG Texture Compression PVRTC extension.

00:15:01.440 --> 00:15:06.070
Now, this extension I highlight partly
because we encourage you very highly

00:15:06.200 --> 00:15:10.490
to use this extension when doing
iPhone OS programming for OpenGL ES,

00:15:10.840 --> 00:15:14.820
but also because it's a good
example of an extension which is

00:15:14.860 --> 00:15:20.790
particular to a specific GPU vendor
or perhaps even a specific GPU.

00:15:21.510 --> 00:15:25.050
will talk more about this
extension a little later on.

00:15:25.170 --> 00:15:27.510
The last one I want to highlight
here out of this list is the

00:15:27.510 --> 00:15:29.860
OES Frame Buffer Object Extension.

00:15:29.980 --> 00:15:34.780
Now, we mention this because,
first of all, we make heavy use of this

00:15:34.790 --> 00:15:40.250
extension on the iPhone OS,
and we use it for configuring all

00:15:40.250 --> 00:15:42.830
of your frame buffer operations.

00:15:42.850 --> 00:15:45.580
So when you're going to decide what
format your frame buffer should

00:15:45.580 --> 00:15:48.620
be for OpenGL ES or whether you
should have a depth buffer or not,

00:15:48.820 --> 00:15:51.090
you'll be using this extension.

00:15:52.170 --> 00:15:54.410
This might be a little different
than some other implementations

00:15:54.420 --> 00:15:57.910
of OpenGL and OpenGL ES,
in that some of them have other means

00:15:57.910 --> 00:15:59.420
of configuring the frame buffer.

00:15:59.420 --> 00:16:00.930
But here, this is what you'll use.

00:16:01.120 --> 00:16:04.920
So we'll talk more in depth
about it in a few moments.

00:16:05.600 --> 00:16:08.300
Okay, so that's all we're going
to say about extensions.

00:16:08.380 --> 00:16:13.110
But what we want to do now is take
a look at some OpenGL ES code.

00:16:13.330 --> 00:16:15.290
And first,
we'll start off by comparing it to

00:16:15.290 --> 00:16:21.110
the corresponding code in OpenGL 1.5,
just to give you a feel for how

00:16:21.110 --> 00:16:21.110
they compare with each other.

00:16:21.510 --> 00:16:24.250
So the first thing we have
here is some OpenGL code,

00:16:24.250 --> 00:16:26.840
and it's basically setting up some state.

00:16:26.840 --> 00:16:30.200
It's going to set up some
transformation state.

00:16:30.570 --> 00:16:32.120
And then at the end,
at the last line here,

00:16:32.120 --> 00:16:34.190
it's going to do some drawing.

00:16:34.540 --> 00:16:39.090
Now, I'd like to take a look at what
this code would look like if

00:16:39.090 --> 00:16:40.470
we converted it to OpenGL ES.

00:16:44.040 --> 00:16:45.740
So as you can see,
actually hardly anything

00:16:45.740 --> 00:16:46.310
here has changed.

00:16:46.470 --> 00:16:49.730
And that's the point,
that with the exception

00:16:49.730 --> 00:16:51.630
of one routine here,
which actually has a slightly

00:16:51.630 --> 00:16:54.160
different suffix because,
again, there's no double

00:16:54.160 --> 00:16:55.380
precision floating point.

00:16:55.380 --> 00:16:58.380
There's a GL ortho call,
which takes single precision arguments.

00:16:58.390 --> 00:17:02.010
With that small exception,
this is exactly the same code.

00:17:02.920 --> 00:17:05.240
We think this is really,
really powerful because this

00:17:05.240 --> 00:17:07.500
means that if you're used
to doing OpenGL programming,

00:17:07.500 --> 00:17:10.640
if you have a large body of code,
if you have games that could

00:17:10.640 --> 00:17:13.370
run in OpenGL or applications,
converting them to

00:17:13.370 --> 00:17:15.670
OpenGL ES should be very,
very straightforward.

00:17:15.680 --> 00:17:19.020
Now there's some caveats and some
tips and techniques specific to

00:17:19.060 --> 00:17:23.340
OpenGL ES and even further specific to
the iPhone that we'll go over here today.

00:17:23.340 --> 00:17:27.560
But this is a big takeaway point,
is that you should realize that

00:17:27.560 --> 00:17:32.190
you're probably very familiar with
OpenGL ES before you ever get started.

00:17:32.390 --> 00:17:35.720
And there's a few other minor
code changes of this flavor,

00:17:35.720 --> 00:17:39.210
such as some extensions have
slightly different suffixes,

00:17:39.320 --> 00:17:42.440
some features have become
optional that used to be core,

00:17:42.500 --> 00:17:46.440
and there's this change from
double to single precision,

00:17:46.440 --> 00:17:49.770
but largely it's very, very,
very similar.

00:17:50.540 --> 00:17:52.900
All right, so that's OpenGL ES.

00:17:52.960 --> 00:17:56.800
And now we want to talk about
using OpenGL ES on the iPhone.

00:17:56.800 --> 00:18:00.800
And here, once again,
we've got several key technologies

00:18:00.800 --> 00:18:03.040
and concepts we want you
to become familiar with,

00:18:03.160 --> 00:18:04.250
and I'm going to go over them now.

00:18:04.260 --> 00:18:08.530
The first thing I'd like to say is
that we have a full OpenGL ES 1.1

00:18:08.530 --> 00:18:10.750
implementation on the iPhone.

00:18:10.760 --> 00:18:12.630
That means it's fully
hardware accelerated,

00:18:12.630 --> 00:18:15.020
fixed function, vertex,
and fragment processing.

00:18:15.970 --> 00:18:18.110
And it's very highly performant.

00:18:18.120 --> 00:18:22.130
You can create really, really,
really great games with the iPhone.

00:18:22.140 --> 00:18:26.100
And you've seen some of them already in
the keynotes that have gone on so far,

00:18:26.150 --> 00:18:27.700
and in the game session
that was earlier today.

00:18:27.700 --> 00:18:30.280
So you think there's just an
amazing amount of potential here.

00:18:30.330 --> 00:18:33.040
And I look at some of these demos,
and I see the things we've

00:18:33.040 --> 00:18:35.630
shown in the keynote,
some of the things we've shown that are

00:18:35.760 --> 00:18:37.260
going to be on the application store.

00:18:37.260 --> 00:18:39.020
And I'm still blown away.

00:18:39.020 --> 00:18:40.510
I can't believe this is a cell phone.

00:18:40.520 --> 00:18:42.730
This is a thing you usually
are just answering calls with,

00:18:42.730 --> 00:18:45.380
and it has this really,
really fantastic 3D implementation.

00:18:45.760 --> 00:18:46.840
Thank you.

00:18:47.740 --> 00:18:52.100
The other thing we want to say is that it
is-- our implementation for OpenGL ES on

00:18:52.260 --> 00:18:56.640
the iPhone is efficiently integrated
with the iPhone user interface.

00:18:56.640 --> 00:18:58.220
Now,
we do this in a couple different ways,

00:18:58.250 --> 00:19:01.840
but the way you'll probably run into it
the most often is that Core Animation,

00:19:01.840 --> 00:19:05.580
which provides the key to the
user interface on the iPhone,

00:19:05.990 --> 00:19:10.040
Core animation layers can actually
serve as OpenGL ES rendering surfaces.

00:19:10.080 --> 00:19:13.420
This means that you can render
directly into a core animation layer,

00:19:13.420 --> 00:19:17.410
and then use it as you would essentially
any other core animation layer.

00:19:17.940 --> 00:19:20.800
You can create some
amazing user interfaces,

00:19:20.800 --> 00:19:24.770
and you can create some very
efficient use of the 3D pipeline on

00:19:24.770 --> 00:19:26.000
the iPhone using these techniques.

00:19:26.040 --> 00:19:28.220
And we'll go over them in a few moments.

00:19:28.290 --> 00:19:31.220
But because you can put your
content in a core animation layer,

00:19:31.220 --> 00:19:33.710
this means your content
becomes a first class citizen.

00:19:33.730 --> 00:19:37.010
This is not just switch
into OpenGL ES mode,

00:19:37.070 --> 00:19:40.380
do some 3D rendering,
and then shut everything down,

00:19:40.480 --> 00:19:42.260
and then draw your user interface.

00:19:42.320 --> 00:19:47.590
They can be very carefully integrated,
and they can be composited together.

00:19:47.770 --> 00:19:50.390
This is key to providing the
seamless type of graphics

00:19:50.750 --> 00:19:52.810
experience on the iPhone.

00:19:53.160 --> 00:19:57.230
All right, so let's take a look next at a
little bit of background about

00:19:57.320 --> 00:20:01.980
how OpenGL ES typically interacts
with its host environment or

00:20:01.980 --> 00:20:06.090
its host operating system,
and then we'll talk about exactly

00:20:06.090 --> 00:20:06.090
how that works on the iPhone.

00:20:06.700 --> 00:20:08.440
So there's three
APIs we've listed up here,

00:20:08.440 --> 00:20:10.460
or really three types of APIs.

00:20:10.790 --> 00:20:14.810
The first one is OpenGL or
OpenGL ES itself.

00:20:14.900 --> 00:20:18.000
And this provides the rendering API,
the thing you're actually

00:20:18.000 --> 00:20:18.910
going to draw with.

00:20:19.040 --> 00:20:22.290
But it doesn't define anything
about how you start up,

00:20:22.450 --> 00:20:25.410
how you initialize your context,
or how you display anything.

00:20:25.420 --> 00:20:28.350
And for that, we turn to some other APIs.

00:20:28.730 --> 00:20:33.460
We call the first one a platform API,
or the OpenGL ES platform API.

00:20:33.590 --> 00:20:36.720
And it's basically responsible
for the device initialization,

00:20:36.720 --> 00:20:39.760
the initial configuration,
creating your rendering context.

00:20:39.760 --> 00:20:41.360
And there's some examples up here.

00:20:41.360 --> 00:20:44.900
If you've done programming on the Mac,
you're probably familiar

00:20:44.900 --> 00:20:47.930
with AGL and CGL,
or NSOpenGL, or Windows, it's WGL,

00:20:47.930 --> 00:20:50.240
or other embedded devices, it's EGL.

00:20:50.240 --> 00:20:53.330
And these are all sort of similar
types of platform APIs in this respect.

00:20:53.390 --> 00:20:56.080
And then generally,
there's a native Windows system

00:20:56.170 --> 00:20:59.070
API that's actually responsible
for displaying your content.

00:20:59.080 --> 00:21:01.180
On the Mac, that might be Quartz.

00:21:01.180 --> 00:21:03.740
On Linux or Unix, it might be X Windows.

00:21:03.740 --> 00:21:06.410
And it's going to be responsible
for taking your content

00:21:06.410 --> 00:21:07.840
and putting it on a screen.

00:21:07.860 --> 00:21:09.060
So how does that look?

00:21:09.060 --> 00:21:13.480
Well, normally there's this sort of block
diagram that takes your application code,

00:21:13.480 --> 00:21:16.660
where you'll manage your
surfaces through your display,

00:21:16.660 --> 00:21:18.420
native Windows system API.

00:21:18.420 --> 00:21:20.130
You'll manage your context.

00:21:20.200 --> 00:21:22.920
You'll manage your context
through this type of platform API.

00:21:22.980 --> 00:21:25.680
And then you'll do your drawing
through OpenGL or OpenGL ES.

00:21:25.780 --> 00:21:30.530
Now, if we take a look at this diagram
as it pertains to the iPhone,

00:21:30.530 --> 00:21:35.190
you'll see that basically we have
implemented the native windowing

00:21:35.370 --> 00:21:37.920
system API with core animation.

00:21:38.000 --> 00:21:41.210
This is the API that's going to be
responsible for doing your display,

00:21:41.210 --> 00:21:44.010
for presenting your interface,
and integrating the two.

00:21:44.120 --> 00:21:47.510
And we've implemented the
platform API with a new

00:21:47.750 --> 00:21:50.190
API introduced in the iPhone OS.

00:21:50.200 --> 00:21:52.780
Called EAGL or Eagle.

00:21:52.780 --> 00:21:56.130
And we're going to speak much more
in depth about both of those now.

00:21:58.270 --> 00:22:01.060
All right, so first off, Eagle.

00:22:01.130 --> 00:22:05.660
Well, the first thing you're going to
see is that Eagle serves the role

00:22:05.660 --> 00:22:09.550
of our iPhone OS platform API,
and is specifically responsible

00:22:09.830 --> 00:22:14.900
for defining the interface in
between OpenGL ES and the iPhone OS.

00:22:15.200 --> 00:22:16.940
What does this mean?

00:22:17.050 --> 00:22:18.840
Well,
this means this is the API that's going

00:22:18.840 --> 00:22:22.540
to manage your device initialization,
your rendering contexts.

00:22:22.670 --> 00:22:25.180
And it's also the API that's
going to do the communication on

00:22:25.180 --> 00:22:28.850
your behalf with Core Animation,
our native windowing system,

00:22:28.950 --> 00:22:30.900
to display your content.

00:22:47.090 --> 00:22:47.090
And the last point is that,
as we mentioned earlier,

00:22:47.090 --> 00:22:47.090
it's also going to use the
OES Frame Buffer Object API for

00:22:47.090 --> 00:22:47.090
its drawable configuration.

00:22:47.090 --> 00:22:47.090
And we'll talk more about how that works.

00:22:47.090 --> 00:22:47.090
So the first part of the
Eagle API that you're going to run

00:22:47.090 --> 00:22:47.090
into is the Eagle Context Object.

00:22:47.520 --> 00:22:51.110
The Eagle context is an abstract
data type that represents

00:22:51.160 --> 00:22:56.140
all of your OpenGL ES state,
as well as your command streams.

00:22:56.220 --> 00:22:58.660
So you can have one of these
Eagle contexts current at any

00:22:58.660 --> 00:23:00.840
given time for your thread.

00:23:00.890 --> 00:23:04.270
And this is because OpenGL ES,
just like OpenGL on the Mac,

00:23:04.430 --> 00:23:07.270
is not a thread-safe API.

00:23:07.670 --> 00:23:10.530
Whenever you've made one of these
contexts current to your thread,

00:23:10.690 --> 00:23:13.360
all the OpenGL commands that
you issue will then be done

00:23:13.360 --> 00:23:16.040
with respect to that context.

00:23:16.160 --> 00:23:18.600
Let's take a look at
what that looks like.

00:23:18.680 --> 00:23:21.310
So in order to set up an Eagle context,
you follow only really

00:23:21.310 --> 00:23:24.160
basically two steps before
you can issue OpenGL commands.

00:23:24.180 --> 00:23:25.740
I've outlined them up here.

00:23:25.820 --> 00:23:29.200
So the first one is you're
going to allocate and initialize

00:23:29.200 --> 00:23:30.480
the Eagle context itself.

00:23:30.480 --> 00:23:34.150
And to do that,
you basically follow this sort

00:23:34.230 --> 00:23:36.790
of standard Objective-C object
initialization and

00:23:36.790 --> 00:23:37.890
allocation methodology.

00:23:37.940 --> 00:23:41.920
So we allocate an object,
and then we're going to initialize it.

00:23:41.980 --> 00:23:45.230
In this particular case,
we initialize it with an argument that

00:23:45.310 --> 00:23:47.500
defines the rendering API we want to use.

00:23:48.910 --> 00:23:50.980
OpenGL ES 1.

00:23:52.270 --> 00:23:54.360
If we look at the second
block of code up here,

00:23:54.360 --> 00:23:58.540
we'll see the second step we have to take
is to set that context to become current.

00:23:58.600 --> 00:24:01.810
Once that context is current,
we are basically ready to

00:24:01.810 --> 00:24:03.540
issue OpenGL ES commands.

00:24:03.570 --> 00:24:05.500
And that's our third
block of code up here.

00:24:05.540 --> 00:24:09.340
It issues a single OpenGL ES command
to get the renderer string identifying

00:24:09.340 --> 00:24:11.460
which renderer we're using.

00:24:11.880 --> 00:24:12.740
So this is very simple.

00:24:12.760 --> 00:24:13.670
It's actually just two steps.

00:24:13.780 --> 00:24:15.240
You can issue OpenGL ES commands.

00:24:15.380 --> 00:24:17.510
But you're probably asking
yourself an important question.

00:24:17.640 --> 00:24:21.660
If I were to draw right now,
where would my rendering go?

00:24:21.780 --> 00:24:25.550
This is an important point when
you're doing 3D graphics programming.

00:24:25.880 --> 00:24:29.730
So for that,
we turn to frame buffer objects.

00:24:29.870 --> 00:24:34.590
Now, on OpenGL ES for the iPhone,
we use frame buffer objects,

00:24:34.590 --> 00:24:37.580
or sometimes called FBOs,
for all of your rendering.

00:24:37.710 --> 00:24:43.100
This is probably different from
some other environments in which

00:24:43.100 --> 00:24:46.930
you've used OpenGL ES or OpenGL,
because we use it for both

00:24:46.950 --> 00:24:50.380
on-screen and off-screen rendering,
as well as all of your

00:24:50.500 --> 00:24:52.080
displayable content.

00:24:52.200 --> 00:24:55.480
And the API is defined by this
OES frame buffer object extension

00:24:55.560 --> 00:24:57.370
that we keep talking about.

00:24:57.960 --> 00:25:01.830
So a framebuffer object is simply
an OpenGL ES state object that

00:25:01.860 --> 00:25:06.060
contains references to color,
depth, and stencil buffers.

00:25:06.100 --> 00:25:08.510
And those color, depth,
and stencil buffers can themselves

00:25:08.610 --> 00:25:13.650
be stored in other OpenGL ES objects,
such as textures, or a new type of object

00:25:14.020 --> 00:25:16.980
called a render buffer,
which is simply a buffer that stores

00:25:16.980 --> 00:25:19.530
an image that you can render into.

00:25:20.670 --> 00:25:23.690
All right, so let's take a look at
what this looks like,

00:25:23.840 --> 00:25:26.050
sort of the object relationship
and how you use this code.

00:25:26.190 --> 00:25:30.400
So the first step in creating a
framebuffer object is to call the

00:25:30.400 --> 00:25:33.240
gen and bind framebuffer routines.

00:25:33.560 --> 00:25:35.460
Once again,
if you've done any OpenGL programming,

00:25:35.460 --> 00:25:37.140
this will be very familiar to you.

00:25:37.200 --> 00:25:41.700
And the API for OES framebuffer object is
heavily derived from the ext framebuffer

00:25:41.700 --> 00:25:44.660
object extension in desktop OpenGL.

00:25:45.970 --> 00:25:47.600
So this is very traditional
OpenGL programming.

00:25:47.600 --> 00:25:49.280
You generate a name,
you bind it to your context,

00:25:49.290 --> 00:25:52.080
and we've created a frame buffer object.

00:25:52.130 --> 00:25:54.980
The second step is to actually
allocate the buffers where we're

00:25:55.080 --> 00:25:57.290
going to store our image data.

00:25:57.900 --> 00:26:01.230
So once again,
we call generate-- gen render buffers,

00:26:01.470 --> 00:26:04.460
bind render buffers to bind it to
our context to create these objects.

00:26:04.480 --> 00:26:07.780
And then we'll make a third call,
render buffer storage.

00:26:07.790 --> 00:26:10.320
Now render buffer storage's
purpose is to actually do the

00:26:10.320 --> 00:26:13.520
allocation of these buffers for you,
to actually allocate the memory that's

00:26:13.600 --> 00:26:16.500
going to store your pixel values.

00:26:16.640 --> 00:26:18.920
Now we've got render buffers allocated,
a frame buffer.

00:26:18.950 --> 00:26:22.520
The last step is actually to
attach them to each other.

00:26:22.760 --> 00:26:25.320
So we call frame buffer render buffer.

00:26:25.340 --> 00:26:28.760
This is somewhat of a confusing name,
but it follows the GL methodology

00:26:29.040 --> 00:26:32.120
of naming the object that we're
attaching to another object.

00:26:32.190 --> 00:26:35.620
So we're attaching a render
buffer to a frame buffer.

00:26:36.750 --> 00:26:39.500
Let's look at that code a
little more briefly here.

00:26:39.610 --> 00:26:41.480
And so you can see we
have these steps outlined.

00:26:41.480 --> 00:26:44.500
This is basically what you would need
to do to set up a frame buffer object

00:26:44.610 --> 00:26:46.530
to do OpenGL ES rendering on the iPhone.

00:26:46.540 --> 00:26:50.130
Now you don't need to write this down,
because we actually provide an

00:26:50.130 --> 00:26:53.270
Xcode template that outlines
and handles all of this for you.

00:26:53.400 --> 00:26:54.960
But we want you to
understand how it's working.

00:26:54.960 --> 00:26:56.580
So we'll go over it real quickly.

00:26:56.720 --> 00:26:59.900
You simply generate the names for
your frame buffer and render buffer.

00:26:59.900 --> 00:27:03.040
You bind the frame buffer and
render buffer to your context.

00:27:04.030 --> 00:27:06.630
You allocate some storage
for the render buffer,

00:27:06.630 --> 00:27:09.940
and then you attach the render
buffer to the frame buffer.

00:27:12.040 --> 00:27:14.490
Okay.

00:27:14.620 --> 00:27:19.650
So, use Eagle to create
your OpenGL ES context,

00:27:19.870 --> 00:27:23.080
and you use the OBS Frame Buffer
Object API to configure

00:27:23.080 --> 00:27:24.540
your frame buffer.

00:27:24.940 --> 00:27:27.480
Now you probably have
yet another question.

00:27:27.610 --> 00:27:30.550
How do we actually display this content?

00:27:32.970 --> 00:27:35.480
Well, for that,
we're going to turn to another class,

00:27:35.530 --> 00:27:39.680
another part of the Eagle API,
another part of the Core Animation API,

00:27:39.770 --> 00:27:41.920
and that is the CA Eagle layer.

00:27:42.040 --> 00:27:46.230
Now, the CA Eagle layer is essentially
nothing more than a subclass

00:27:46.230 --> 00:27:50.600
of a Core Animation layer,
but one that is specifically designed

00:27:50.710 --> 00:27:53.590
to display OpenGL ES content.

00:27:53.970 --> 00:27:57.340
It essentially integrates
the OpenGL ES and

00:27:57.340 --> 00:27:59.650
Core Animation APIs together.

00:27:59.730 --> 00:28:02.520
It allows you to render
into a Core Animation layer.

00:28:02.880 --> 00:28:07.620
And because you can attach one of these
objects to an OpenGL ES render buffer,

00:28:07.700 --> 00:28:12.330
you can now render directly into the
objects that are displayed on screen.

00:28:13.640 --> 00:28:17.020
So very briefly,
we can see how do we use this.

00:28:17.090 --> 00:28:18.740
Let me outline the steps real quickly.

00:28:18.870 --> 00:28:23.820
So the first thing you need to do is
subclass a UIView that you're going to

00:28:23.820 --> 00:28:26.260
use to display your rendered contents.

00:28:26.330 --> 00:28:27.380
Why do we do this?

00:28:27.500 --> 00:28:31.620
Well, in Cocoa Touch,
every UIView object is backed

00:28:31.620 --> 00:28:33.850
by a core animation layer.

00:28:34.150 --> 00:28:37.550
So we want to back this
particular UI view by a specific

00:28:37.650 --> 00:28:41.800
kind of core animation layer,
namely one that you can render into.

00:28:42.590 --> 00:28:47.460
And the way that you do that is you're
going to override a method of the UIView,

00:28:47.480 --> 00:28:51.540
the layer class method,
to return the CA Eagle layer class

00:28:51.540 --> 00:28:54.140
instead of the CA layer class.

00:28:55.280 --> 00:28:57.350
The next thing you'll do, as we outlined,
is create and bind an

00:28:57.350 --> 00:28:59.950
OpenGL ES render buffer and an FBO.

00:29:00.040 --> 00:29:03.710
You're going to attach your
CA Eagle layer to your render buffer.

00:29:03.900 --> 00:29:25.600
[Transcript missing]

00:29:26.700 --> 00:29:28.540
Let's look at how these
objects relate to each other.

00:29:28.540 --> 00:29:31.710
So you start with the
Eagle context itself.

00:29:31.820 --> 00:29:36.320
And the next thing you're going to do,
as we said, is bind a new render buffer.

00:29:36.440 --> 00:29:39.510
Once you've done that,
you typically would allocate storage,

00:29:39.510 --> 00:29:42.110
as we were saying before,
to do some rendering.

00:29:42.220 --> 00:29:44.900
And this would generally
generate an internal allocation

00:29:44.900 --> 00:29:46.080
of renderable storage.

00:29:46.160 --> 00:29:47.760
But we're actually going to take
a slightly different tack here,

00:29:47.760 --> 00:29:49.010
because we don't want
to just render to this.

00:29:49.100 --> 00:29:50.200
We want to display it.

00:29:50.330 --> 00:29:53.160
So we're going to make
another call in the Eagle API.

00:29:53.260 --> 00:29:58.710
And this API is the similarly named
render buffer storage from drawable.

00:29:58.800 --> 00:30:02.280
And what this routine does,
it actually allocates renderable and

00:30:02.410 --> 00:30:06.420
displayable storage simultaneously,
and then shares that storage

00:30:06.610 --> 00:30:10.020
by attaching the CA Eagle layer
to the render buffer object.

00:30:10.100 --> 00:30:11.920
Now the CA Eagle layer,
as we keep mentioning,

00:30:12.140 --> 00:30:15.780
is nothing more than a subclass
of your core animation layer.

00:30:20.420 --> 00:30:23.330
And then the last step is you want
to present your render buffer,

00:30:23.380 --> 00:30:25.470
called Eagle Context
Present Render Buffer,

00:30:25.560 --> 00:30:26.890
to actually display this on screen.

00:30:26.900 --> 00:30:29.400
So wherever this core animation
layer would be displayed on screen,

00:30:29.400 --> 00:30:30.820
that's where your content will go.

00:30:30.900 --> 00:30:33.280
Now we have some recommendations a little
later in the presentation about the

00:30:33.280 --> 00:30:36.350
best and most efficient way to do that,
but that's basically how these

00:30:36.350 --> 00:30:37.820
objects relate to each other.

00:30:37.900 --> 00:30:42.190
So let's take a look next at how you
would actually get your rendering into

00:30:42.190 --> 00:30:44.900
one of these displayable render buffers.

00:30:44.990 --> 00:30:46.890
So we have this configuration
we've just set up.

00:30:47.160 --> 00:30:50.900
Next thing you would do is you would
allocate your frame buffer object.

00:30:50.900 --> 00:30:52.900
You would bind that frame
buffer object to your context.

00:30:52.900 --> 00:30:55.780
So now all your rendering will
go to your frame buffer object.

00:30:55.910 --> 00:30:58.900
And the last step is to
attach your render buffer,

00:30:58.900 --> 00:31:01.880
the one you've attached
to your CA Eagle layer,

00:31:01.980 --> 00:31:02.900
to the frame buffer.

00:31:02.900 --> 00:31:06.360
Now you've created a pathway by which
your Eagle Context can issue rendering

00:31:06.360 --> 00:31:09.900
commands into the CA Eagle layer,
and they can be displayed.

00:31:09.900 --> 00:31:14.100
And if you want, you can also optionally
attach a depth buffer.

00:31:15.300 --> 00:31:57.400
[Transcript missing]

00:31:59.590 --> 00:32:02.590
And the last thing I want to say
about Eagle before we move on is

00:32:02.590 --> 00:32:08.340
that we fully support sharing of
objects between OpenGL ES contexts.

00:32:08.450 --> 00:32:12.130
And there's information about how to do
this in the iPhone OS Programmer's Guide.

00:32:12.240 --> 00:32:14.790
We mention it here for completeness.

00:32:14.850 --> 00:32:17.220
All right, so we've talked about a
bunch of concepts here.

00:32:17.260 --> 00:32:21.510
Let's just take a quick look
at the Xcode template that will

00:32:21.690 --> 00:32:25.240
tie this all together for you.

00:32:25.380 --> 00:32:28.870
So I'm going to switch
to the demo machine here.

00:32:32.220 --> 00:32:36.870
Now, first thing I'm going to
do is launch Xcode here.

00:32:37.290 --> 00:32:40.640
And I'm going to create a new project.

00:32:40.910 --> 00:32:44.070
We provide right here
the OpenGL ES application

00:32:44.130 --> 00:32:45.470
template for you to use.

00:32:45.740 --> 00:32:48.540
And it's a great starting point,
because it does all of this

00:32:48.640 --> 00:32:51.260
complicated work for setting
up your framebuffer object,

00:32:51.310 --> 00:32:52.500
initializing your context.

00:32:52.740 --> 00:32:54.400
It does this all for you.

00:32:54.620 --> 00:32:58.970
Now, if you simply choose this project,
we'll create it right here.

00:33:01.860 --> 00:33:05.480
and you'll see that we basically
instantiated a bunch of files for you.

00:33:05.500 --> 00:33:07.760
Now,
I haven't added anything to this project.

00:33:07.790 --> 00:33:12.360
I'm simply going to look quickly
at some of the implementation.

00:33:12.410 --> 00:33:18.660
Now, the first thing you'll notice
here is that this template will

00:33:18.660 --> 00:33:23.110
instantiate in a subclass of UIView,
just like we recommended.

00:33:23.200 --> 00:33:52.000
[Transcript missing]

00:33:52.500 --> 00:33:59.310
in this initialization routine here
will allocate an Eagle context.

00:33:59.940 --> 00:34:03.220
and it will initialize it
with our rendering API,

00:34:03.220 --> 00:34:05.810
and it will set our
context to be current.

00:34:07.730 --> 00:34:10.580
The next thing that we can
notice about this routine,

00:34:10.580 --> 00:34:14.510
this method, is that it sets up the
frame buffer for us.

00:34:14.650 --> 00:34:16.750
So it does the steps I just outlined,
generate your render

00:34:16.850 --> 00:34:22.650
buffer and frame buffers,
call render buffer storage from drawable,

00:34:22.660 --> 00:34:27.950
passing in this CA Eagle layer
we just allocated,

00:34:27.950 --> 00:34:31.530
and attaches the color
render buffer attached to the

00:34:31.530 --> 00:34:31.530
CA Eagle layer to our frame buffer.

00:34:33.230 --> 00:34:38.580
And the last key point about the template
is it has basically a placeholder for

00:34:38.580 --> 00:34:42.690
you to put your OpenGL ES rendering code.

00:34:43.100 --> 00:34:47.230
And you can see right here that basically
it just has the same kind of OpenGL code

00:34:47.240 --> 00:34:54.340
you're probably familiar with,
setting up some state,

00:34:54.340 --> 00:34:54.340
clearing the screen,
and issuing a draw call.

00:34:57.850 --> 00:35:00.320
All right, we'll come back to this
template in a moment,

00:35:00.340 --> 00:35:03.190
but I want to talk a little
bit next about some of the

00:35:03.190 --> 00:35:08.480
implementation details of the iPhone
OS OpenGL ES so that you can use them

00:35:08.660 --> 00:35:11.850
when designing your own application.

00:35:11.970 --> 00:35:18.710
So we can switch back to
the presentation machine.

00:35:19.270 --> 00:35:20.640
There we go.

00:35:26.620 --> 00:35:30.460
The first thing we want to
say is that the iPhone OS and

00:35:30.460 --> 00:35:35.140
iPhone is using the Imagination
Technologies PowerVR MBX Lite GPU.

00:35:35.140 --> 00:35:37.990
Now, this is a terrific
GPU for embedded devices.

00:35:37.990 --> 00:35:43.240
It supports hardware-accelerated
OpenGL ES 1.1 fully,

00:35:43.240 --> 00:35:47.180
full vertex and fragment
processing acceleration.

00:35:47.220 --> 00:35:49.280
And it's designed for embedded systems.

00:35:49.340 --> 00:35:52.450
It's designed for the types of
devices just like the iPhone.

00:35:53.130 --> 00:35:57.000
It implements a couple of
techniques in that design that can

00:35:57.430 --> 00:36:00.420
use memory and to use the system
in the most efficient manner.

00:36:00.440 --> 00:36:02.980
The first one is called Tile-Based
Deferred Mode Rendering,

00:36:02.980 --> 00:36:05.220
and the second one is
Hidden Surface Removal.

00:36:05.240 --> 00:36:08.760
I'll talk a little bit about each of
those because they will affect how you

00:36:08.760 --> 00:36:10.850
write some of your application code.

00:36:11.210 --> 00:36:15.340
These are basically guidelines that
will affect the best way that you

00:36:15.660 --> 00:36:20.180
should use to get the most performance
and efficiency out of the system,

00:36:20.180 --> 00:36:21.980
not the correctness of what you render.

00:36:21.980 --> 00:36:22.940
But they're still important.

00:36:22.940 --> 00:36:24.640
to keep in mind.

00:36:25.400 --> 00:36:27.250
So what is Tile-based
Deferred Mode Rendering?

00:36:27.500 --> 00:36:31.280
Well, a traditional renderer is going
to render each polygon in order,

00:36:31.350 --> 00:36:33.400
in the order that you send it to OpenGL.

00:36:33.400 --> 00:36:35.640
A Tile-based Deferred Mode Renderer,
on the other hand,

00:36:35.730 --> 00:36:37.560
actually takes a different tack.

00:36:37.620 --> 00:36:41.720
In order to minimize its access to memory
and use memory the most efficient manner,

00:36:41.790 --> 00:36:45.040
it's going to store entire
frames worth of data at a time.

00:36:45.150 --> 00:36:47.600
It's going to then break
that data into tiles.

00:36:47.710 --> 00:36:51.280
Generally,
tiles are organized by screen position.

00:36:51.340 --> 00:36:55.570
And it will create a list of rendering
commands for each of those tiles.

00:36:55.990 --> 00:36:57.910
Once it's done that,
it will process each tile.

00:36:58.150 --> 00:37:00.740
And once it has this whole
list of the scene data,

00:37:00.740 --> 00:37:04.510
it can actually figure out exactly which
pixels need to be processed for any tile.

00:37:04.820 --> 00:37:06.720
It only needs to process
the visible ones,

00:37:06.820 --> 00:37:07.880
which saves it a bunch of work.

00:37:08.120 --> 00:37:10.940
And then it writes out
the final pixel values.

00:37:11.030 --> 00:37:12.600
Now why does this matter?

00:37:12.600 --> 00:37:15.400
Well, as we said,
it's incredibly efficient.

00:37:15.420 --> 00:37:18.080
It allows you to get the really
great performance that you saw

00:37:18.080 --> 00:37:19.880
in some of the demos so far.

00:37:20.140 --> 00:37:26.680
And it just basically can save battery
life and processing time for you.

00:37:26.750 --> 00:37:29.410
But there's a caveat that
certain types of operations you

00:37:29.410 --> 00:37:32.740
might be used to using on other
implementations can be more expensive.

00:37:32.790 --> 00:37:34.670
And basically,
those are the set of operations

00:37:35.020 --> 00:37:39.990
that depend on previous
rendering having been completed.

00:37:41.210 --> 00:37:44.700
Again, this batches up a whole tile,
a whole frame's worth of data into

00:37:44.700 --> 00:37:46.130
tiles every time before it renders.

00:37:46.190 --> 00:37:49.060
So anything you do that says, hey,
I'm done rendering,

00:37:49.060 --> 00:37:52.330
can cause us to go through this process,
looking through all of the

00:37:52.330 --> 00:37:54.690
information that is in the scene,
and figuring out the

00:37:54.690 --> 00:37:55.490
best way to render it.

00:37:55.570 --> 00:37:58.180
We'll talk a little bit more
about that when we get to

00:37:58.340 --> 00:37:59.860
our best practices section.

00:37:59.860 --> 00:38:02.760
There's a few other implementation
details we wanted to highlight.

00:38:02.760 --> 00:38:06.370
We support 16 and 32-bit color buffers.

00:38:06.400 --> 00:38:08.920
We support an optional
24-bit depth buffer.

00:38:09.480 --> 00:38:13.280
And we don't support stencil buffers in
the iPhone OS OpenGL ES implementation.

00:38:13.280 --> 00:38:18.940
There's two texture units that can be
up to 1024 pixels in width and height,

00:38:19.000 --> 00:38:20.080
and must be a power of two.

00:38:20.080 --> 00:38:22.680
And there's eight lights and
one clip plane supported.

00:38:25.320 --> 00:38:26.090
All right.

00:38:26.180 --> 00:38:30.080
So we've talked a lot about the
details of OpenGL ES on the iPhone.

00:38:30.140 --> 00:38:32.570
We're going to spend a few moments
talking about using OpenGL ES on

00:38:32.570 --> 00:38:33.970
the iPhone simulator next.

00:38:33.980 --> 00:38:36.090
So what can we say about that?

00:38:36.120 --> 00:38:39.910
Well, this is an entirely second
OpenGL ES implementation

00:38:39.910 --> 00:38:41.730
in the iPhone OS SDK.

00:38:41.810 --> 00:38:46.050
This one runs on your host Mac,
and it allows you to write your

00:38:46.250 --> 00:38:50.540
code in the simulator on your Mac,
test it out, make sure everything's

00:38:50.540 --> 00:38:53.600
rendering correctly before you
ever deploy it to a device.

00:38:53.930 --> 00:38:55.000
This is incredibly handy.

00:38:55.000 --> 00:38:59.620
Now, the functionality is extremely
similar to what's on the device.

00:38:59.640 --> 00:39:02.860
However, the performance profile is very,
very different,

00:39:02.860 --> 00:39:04.460
or it can be very different.

00:39:04.460 --> 00:39:07.240
So you want to use the simulator
to get real fast turnaround

00:39:07.240 --> 00:39:10.760
and do rapid experiments,
make sure everything's drawing properly,

00:39:10.760 --> 00:39:13.700
but you want to use the device
for all your performance tuning

00:39:13.700 --> 00:39:15.490
and your mainline development.

00:39:17.400 --> 00:39:44.100
[Transcript missing]

00:39:44.310 --> 00:39:48.170
So we can take a look next at
a demo of the OpenGL ES support

00:39:48.330 --> 00:39:50.200
in the iPhone simulator.

00:39:50.310 --> 00:39:52.580
So I'll go back to the demo machine.

00:40:13.630 --> 00:40:13.630
And the first thing we want to show
is actually the exact same template

00:40:13.630 --> 00:40:13.630
we just were looking at a moment ago.

00:40:13.630 --> 00:40:13.630
Now,
if we can see what this is about to draw,

00:40:13.630 --> 00:40:13.630
we have -- it's going to
draw a triangle strip here.

00:40:13.630 --> 00:40:13.630
It's got some rotation.

00:40:13.630 --> 00:40:13.630
So let's take a look here and target
first the iPhone OS simulator.

00:40:13.800 --> 00:40:14.640
This is the same project.

00:40:14.730 --> 00:40:16.200
I didn't actually
change any of this code.

00:40:16.200 --> 00:40:19.500
It just came from the template,
so you can try this in your

00:40:19.500 --> 00:40:21.500
own version of the SDK.

00:40:21.620 --> 00:40:24.250
And all I'm going to do
is click Build and Go.

00:40:25.790 --> 00:40:29.410
Simulator launches,
and we have OpenGL ES rendering

00:40:29.460 --> 00:40:30.420
in the simulator.

00:40:30.440 --> 00:40:33.200
And this is, as I said,
it's very convenient to use the simulator

00:40:33.310 --> 00:40:35.140
for sort of quick little experiments.

00:40:35.200 --> 00:40:38.140
So if I wanted to stop this
application and actually say,

00:40:38.140 --> 00:40:39.920
oh, I need to change my mind.

00:40:39.920 --> 00:40:42.960
I actually would like the background
color to be a little different,

00:40:42.980 --> 00:40:46.460
and I want the rotation of this
square to be a little different,

00:40:46.460 --> 00:40:50.250
I can actually save that, change it,
and with a few keystrokes,

00:40:50.320 --> 00:40:52.410
I can see the results of what I changed.

00:40:55.460 --> 00:40:58.080
So this is very, very handy.

00:41:00.000 --> 00:41:03.260
Now, actually, if we can switch back to
the slides for one moment,

00:41:03.260 --> 00:41:06.320
I want to show one other
bit of information.

00:41:06.440 --> 00:41:11.430
So a few years ago at WWDC,
we showed a demo running on

00:41:11.430 --> 00:41:15.380
Mac OS X that was highlighting
the use of framebuffer objects.

00:41:15.430 --> 00:41:19.030
And that demo was called FBO Bunnies.

00:41:19.820 --> 00:41:22.300
Now,
this was back when FBO bunnies were new.

00:41:22.460 --> 00:41:24.870
And we thought, well,
we're using frame buffer objects

00:41:25.120 --> 00:41:26.380
very heavily on the iPhone.

00:41:26.540 --> 00:41:30.940
This would be a good candidate
demo to run on the iPhone itself.

00:41:31.080 --> 00:41:33.880
So we decided, great,
we're going to take FBO bunnies,

00:41:34.020 --> 00:41:38.020
we're going to change it
from OpenGL to OpenGL ES,

00:41:38.180 --> 00:41:40.630
and we thought, great,
this demo needs a new name.

00:41:41.000 --> 00:41:44.400
So we decided we would
give it a new name.

00:41:45.940 --> 00:41:47.700
is now FBO Bunnies.

00:41:47.770 --> 00:41:53.190
So switch back to the demo machine here,
and we'll show that demo running.

00:42:12.490 --> 00:42:12.490
Okay, so we'll quit out of our
project that was the template,

00:42:12.490 --> 00:42:12.490
and we'll switch into our second demo.

00:42:12.490 --> 00:42:12.490
And this is the bunnies demo.

00:42:12.490 --> 00:42:12.490
Now, first off, let's take a look at this
thing running on the Mac.

00:42:12.490 --> 00:42:12.490
Now, we can do this by, again,
just a few project settings.

00:42:13.260 --> 00:42:15.080
will have this run just so you
can see what it looked like

00:42:15.390 --> 00:42:16.090
when it was running on the Mac.

00:42:16.150 --> 00:42:20.580
Now, this is running in a Mac OS window
using the native OpenGL implementation

00:42:20.580 --> 00:42:23.560
on the Mac using OpenGL ES here.

00:42:25.030 --> 00:42:28.780
This demo basically draws
this bunny into a texture,

00:42:28.980 --> 00:42:31.770
texture maps it,
puts it on the side of a cube, and then,

00:42:31.790 --> 00:42:35.340
as bunnies often want to do, multiplies.

00:42:35.390 --> 00:42:38.380
And then it does a depth of
field effect on the bunnies.

00:42:38.430 --> 00:42:41.650
All this is done with the
Frame Buffer Object API and some

00:42:41.650 --> 00:42:43.620
render to texture techniques.

00:42:43.670 --> 00:42:47.460
Let's take a look at that same
demo running in the simulator.

00:42:47.520 --> 00:42:50.120
Now, actually, before we do that,
let's see what we actually

00:42:50.120 --> 00:42:51.710
had to do to get this running.

00:42:51.790 --> 00:42:56.660
So at the top of this file,
we have this target OS additional

00:42:56.660 --> 00:43:00.790
we've set to target the device,
the iPhone versus the Mac.

00:43:00.880 --> 00:43:02.890
And if we look at what we
actually had to change,

00:43:02.910 --> 00:43:05.530
you'll see it's a very,
very small amount of changes.

00:43:05.600 --> 00:43:09.890
The first change here is we
have to include a slightly

00:43:09.890 --> 00:43:11.570
different set of headers.

00:43:12.290 --> 00:43:16.800
OpenGL on the Mac,
OpenGL ES on the phone.

00:43:16.890 --> 00:43:19.500
And we also include a slightly
different set of names for

00:43:19.500 --> 00:43:21.100
the FrameBufferObject API.

00:43:21.100 --> 00:43:24.300
As we mentioned earlier,
this is the OES FrameBufferObject API.

00:43:24.300 --> 00:43:25.620
But basically, it's the same.

00:43:25.620 --> 00:43:29.260
You can see all we really did was
change a few values on the suffix.

00:43:29.540 --> 00:43:32.320
And lastly,
there's a change here from single

00:43:32.320 --> 00:43:33.780
precision to double precision.

00:43:33.780 --> 00:43:35.330
But that's it.

00:43:35.430 --> 00:43:39.760
We don't actually use this
conditional anywhere else in the file.

00:43:39.760 --> 00:43:45.030
And we have one other very subtle
change in that the iPhone OS uses Eagle,

00:43:45.120 --> 00:43:47.520
as we've described,
to manage its windows,

00:43:47.520 --> 00:43:50.930
while the Mac uses Glut, or can use Glut.

00:43:50.940 --> 00:43:53.300
And this is just a simple little demo,
so we decided to use it.

00:43:53.480 --> 00:43:56.610
So the Mac sets up its code
here using the Glut APIs.

00:43:56.620 --> 00:44:02.130
And the OpenGL ES The iPhone
version uses the Eagle template

00:44:02.170 --> 00:44:02.920
that we set up earlier.

00:44:02.920 --> 00:44:06.960
So let's see this running first
now on the iPhone simulator.

00:44:16.190 --> 00:44:18.090
Here's the demo running on the simulator.

00:44:18.100 --> 00:44:22.600
So this is actually very cool.

00:44:22.600 --> 00:44:24.640
Like, we haven't hardly
changed the code at all.

00:44:24.640 --> 00:44:28.330
We made a few little syntactic
changes to some lines of code.

00:44:28.340 --> 00:44:30.340
But the content is all exactly the same.

00:44:30.410 --> 00:44:30.880
It draws.

00:44:30.930 --> 00:44:32.060
It looks the same.

00:44:32.110 --> 00:44:33.660
And it performs pretty well.

00:44:33.720 --> 00:44:35.150
This is running in the simulator.

00:44:35.290 --> 00:44:39.180
So let's take a look next at this
exact same code running on the device.

00:44:39.240 --> 00:44:42.480
This time, we actually won't need to
change the code at all.

00:44:42.530 --> 00:44:49.960
We'll simply target the
device in the Xcode window.

00:44:50.050 --> 00:44:53.790
And I need to switch to the
iPhone display screen here.

00:44:53.820 --> 00:45:01.330
All right.

00:45:01.450 --> 00:45:03.900
So we'll get this running.

00:45:11.600 --> 00:45:14.940
There we go.

00:45:14.960 --> 00:45:15.800
In theory.

00:45:15.830 --> 00:45:16.420
Ah, there we go.

00:45:16.650 --> 00:45:17.420
Great.

00:45:17.530 --> 00:45:18.630
So here's the same demo.

00:45:18.640 --> 00:45:20.650
We were just running it
on the Mac a moment ago.

00:45:20.880 --> 00:45:24.160
Our demo from a few years ago, WWC,
showing the state of the

00:45:24.160 --> 00:45:25.740
art technology on your Mac.

00:45:25.860 --> 00:45:30.410
And now, the power of that rendering
is in your iPhone.

00:45:39.850 --> 00:45:41.560
So let's stop that,
and we'll come back to that demo

00:45:41.560 --> 00:45:44.240
one more time in a few moments.

00:45:44.290 --> 00:45:46.850
Well, let's take a look at
our last section here.

00:45:47.010 --> 00:45:53.580
So we want to spend some
time-- back to the slides,

00:45:53.580 --> 00:45:57.270
please-- spend some time talking about
our recommendations and best practices

00:45:57.270 --> 00:45:57.270
for developing your own application.

00:45:57.630 --> 00:46:00.440
So we've divided these
into a few sections.

00:46:00.530 --> 00:46:03.920
The first sections are just some general
guidelines and how to best coexist and

00:46:03.920 --> 00:46:06.340
how to use the CAEagle layer efficiently.

00:46:06.400 --> 00:46:10.050
And then we talk a fair amount
about optimizing your application

00:46:10.050 --> 00:46:15.030
to minimize memory bandwidth,
storage, and CPU overhead.

00:46:15.300 --> 00:46:33.000
[Transcript missing]

00:46:33.100 --> 00:47:03.300
[Transcript missing]

00:47:03.580 --> 00:47:05.660
Another key point.

00:47:05.700 --> 00:47:07.720
A lot of developers who do
embedded device programming are

00:47:07.720 --> 00:47:11.190
used to not having a full floating
point support on their processor,

00:47:11.190 --> 00:47:15.660
so they may have some kind of
emulated support for floating point.

00:47:15.710 --> 00:47:18.680
The iPhone CPU fully supports
floating point natively,

00:47:18.760 --> 00:47:19.970
so this is just wasted work.

00:47:20.060 --> 00:47:23.260
So if you have that code in something
you're trying to port to the iPhone,

00:47:23.260 --> 00:47:25.840
you should just get rid of it,
because it won't help you out here,

00:47:25.840 --> 00:47:28.450
and it'll just eat up your CPU.

00:47:28.700 --> 00:47:31.120
In the OpenGL ES case,
there's a lot of features

00:47:31.160 --> 00:47:33.980
in OpenGL ES that give you
real high quality rendering,

00:47:33.980 --> 00:47:36.600
but are more expensive
than some other features.

00:47:36.600 --> 00:47:39.450
Such things as blending and
lighting can be expensive.

00:47:39.590 --> 00:47:43.090
So you don't want to leave those
enabled if you don't need to.

00:47:43.190 --> 00:47:45.100
Now there's sort of a
trade-off to be made,

00:47:45.100 --> 00:47:48.320
because our next recommendation is
actually to avoid OpenGL ES state

00:47:48.350 --> 00:47:50.670
changes as much as possible.

00:47:51.000 --> 00:47:53.580
Now, these are somewhat in conflict,
because if there are certain

00:47:53.580 --> 00:47:56.040
expensive features you have enabled,
you may want to turn

00:47:56.040 --> 00:47:58.590
them off to disable them,
but you don't want to be

00:47:58.600 --> 00:47:59.810
toggling them back and forth.

00:48:00.020 --> 00:48:02.660
So in general,
what we can say is that OpenGL ES state

00:48:02.760 --> 00:48:05.910
changes in general can be expensive,
and you should take steps

00:48:06.000 --> 00:48:07.270
to try and minimize them.

00:48:07.540 --> 00:48:10.060
You can do this by keeping a shadow
copy of your OpenGL ES state,

00:48:10.060 --> 00:48:12.950
and this can help you avoid
redundant state changes,

00:48:12.950 --> 00:48:17.710
and it can also avoid the need to
query the OpenGL for its state.

00:48:19.370 --> 00:48:22.440
Now, the next two points are really
influenced by the tile-based

00:48:22.440 --> 00:48:24.660
deferred mode rendering architecture.

00:48:24.740 --> 00:48:27.590
And as we mentioned them briefly earlier,
but you want to minimize the

00:48:27.600 --> 00:48:32.440
number of rendering destination
changes within a given frame.

00:48:32.490 --> 00:48:36.910
And you want to carefully schedule any
of the operations in OpenGL ES that can

00:48:36.910 --> 00:48:39.600
cause you to force a frame to finish.

00:48:39.660 --> 00:48:45.280
And you basically want to do these at the
beginning or perhaps the end of a frame,

00:48:45.280 --> 00:48:45.280
but not lots of times in
the middle of your frame.

00:48:47.080 --> 00:48:50.180
Now there's a few more techniques
here in this sort of general category.

00:48:50.260 --> 00:48:52.500
You want to use alpha blending
instead of alpha testing.

00:48:52.500 --> 00:48:55.780
This might be a little counterintuitive
on other implementations.

00:48:55.900 --> 00:48:59.500
Alpha blending might be really expensive,
and alpha testing might be, you know,

00:48:59.500 --> 00:49:01.610
saving you the cost of
doing that expensive work.

00:49:01.740 --> 00:49:04.380
But in this implementation,
alpha tests can actually

00:49:04.380 --> 00:49:07.370
defeat the hidden surface
removal techniques in the GPU,

00:49:07.600 --> 00:49:10.800
and alpha blending is
actually very inexpensive.

00:49:11.190 --> 00:49:14.190
You generally want to draw
your opaque objects first and

00:49:14.190 --> 00:49:15.610
your blended objects last.

00:49:15.710 --> 00:49:18.470
And this can help increase the
effectiveness of the hidden

00:49:18.470 --> 00:49:20.460
surface removal parts of the GPU.

00:49:20.610 --> 00:49:25.120
And you want to try and minimize certain
state changes that can be expensive.

00:49:25.210 --> 00:49:27.650
And some of these include
things like scissor,

00:49:27.650 --> 00:49:30.620
viewport, and dither state.

00:49:30.910 --> 00:49:33.720
Generally, these are not things that you
might change often anyway.

00:49:34.070 --> 00:49:36.440
But we've seen a fair amount
of applications coming to the

00:49:36.550 --> 00:49:39.120
iPhone where they're not used
to these things being expensive.

00:49:39.160 --> 00:49:41.500
And so we wanted to call that out.

00:49:41.590 --> 00:49:44.940
We also recommend that you don't
allocate a depth buffer unnecessarily.

00:49:44.940 --> 00:49:47.480
So if you're going through
some effort to sort your state,

00:49:47.540 --> 00:49:50.400
you can actually save some memory
bandwidth by not even bothering

00:49:50.400 --> 00:49:52.000
to allocate a depth buffer.

00:49:52.000 --> 00:49:55.700
It simply can waste memory
storage and also bandwidth.

00:49:55.850 --> 00:49:59.410
And lastly, in this category,
we want to say that you should

00:49:59.410 --> 00:50:02.660
try and minimize the number of
draw calls that you're making.

00:50:02.780 --> 00:50:05.940
So you can do this by, again,
sorting your state to put similar

00:50:05.940 --> 00:50:07.960
states together before drawing.

00:50:08.080 --> 00:50:12.190
And you can also do this through little
tricks like joining your triangle strips

00:50:12.380 --> 00:50:15.090
together with some degenerate triangles.

00:50:16.280 --> 00:50:19.660
The next section we want to talk
about here is how to best coexist

00:50:19.800 --> 00:50:21.880
with the iPhone OS user interface.

00:50:21.940 --> 00:50:23.600
Now, as we mentioned,
we're rendering into

00:50:23.710 --> 00:50:25.060
Core Animation layers.

00:50:25.120 --> 00:50:29.460
And Core Animation is very
efficient at compositing

00:50:29.640 --> 00:50:31.740
content from different sources.

00:50:31.820 --> 00:50:33.290
But in general,
when you're playing a game,

00:50:33.360 --> 00:50:36.150
you mostly want to focus in on
the content you're generating.

00:50:36.250 --> 00:50:38.680
So if you want the most
efficient display path possible,

00:50:38.750 --> 00:50:42.370
you need to use screen
size CA Eagle layers.

00:50:42.500 --> 00:50:44.820
In general,
you also want to avoid making any kind of

00:50:44.840 --> 00:50:49.850
transformations on your CA Eagle layers
in the Core Animation API.

00:50:49.970 --> 00:50:53.940
If you need to do simple transformations,
such as running in landscape mode,

00:50:54.000 --> 00:50:57.130
you can do that with
the OpenGL API itself.

00:50:57.330 --> 00:50:59.380
Now, if you do it with Core Animation,
it will all work.

00:50:59.500 --> 00:51:02.980
It's just you might want to save
that for special effects or cases

00:51:02.980 --> 00:51:08.740
where you're not trying to run at
your highest possible frame rate.

00:51:09.290 --> 00:51:14.220
There's a few other areas of concern and
tips we wanted to mention with respect

00:51:14.350 --> 00:51:16.380
to coexisting with the user interface.

00:51:16.440 --> 00:51:19.680
So as we mentioned, for best performance,
generally you want to be

00:51:19.680 --> 00:51:21.490
the only thing rendering.

00:51:21.650 --> 00:51:25.170
And so typically you want to
use the CA Eagle layer's opaque

00:51:25.320 --> 00:51:29.180
property and set that to yes,
so that your content is essentially

00:51:29.180 --> 00:51:31.290
treated as opaque by core animation.

00:51:31.600 --> 00:51:35.480
And this generally means avoid
blending your content with the UI.

00:51:35.610 --> 00:51:38.680
Once again, this will work just fine,
but we recommend you don't do

00:51:38.680 --> 00:51:42.470
it if you're in a performance
sensitive region of your code.

00:51:42.890 --> 00:51:46.550
Now, if you decide you do want to
composite OpenGL ES and your UI,

00:51:46.550 --> 00:51:49.970
we still recommend that you
leave the opaque setting of

00:51:49.970 --> 00:51:51.790
the CA Eagle layer to yes.

00:51:51.890 --> 00:51:53.680
So it means you still
want to leave it opaque.

00:51:53.810 --> 00:51:57.710
But you want to put your
OpenGL ES content below

00:51:57.860 --> 00:52:02.030
is a great example of how
OpenGL ES can drive iPhone games

00:52:02.030 --> 00:52:04.800
and other mobile 3D applications.

00:52:05.020 --> 00:52:09.580
Jeremy Sandmel is a great example of
how OpenGL ES can drive iPhone games

00:52:09.580 --> 00:52:11.800
and other mobile 3D applications.

00:52:11.800 --> 00:52:15.800
Jeremy Sandmel is a great example of
how OpenGL ES can drive iPhone games

00:52:15.800 --> 00:52:18.140
and other mobile 3D applications.

00:52:18.140 --> 00:52:21.390
Jeremy Sandmel is a great example of
how OpenGL ES can drive iPhone games

00:52:21.490 --> 00:52:23.440
and other mobile 3D applications.

00:52:23.440 --> 00:52:28.160
Jeremy Sandmel is a great example of how
OpenGL in OpenGL to make this happen.

00:52:28.170 --> 00:52:31.110
And last, this is, once again,
an embedded device.

00:52:31.400 --> 00:52:32.130
Very powerful.

00:52:32.190 --> 00:52:33.620
It can do really great things.

00:52:33.670 --> 00:52:36.840
But you're sharing resources
with the rest of the system here.

00:52:36.980 --> 00:52:39.080
So generally,
you want to avoid simultaneous

00:52:39.080 --> 00:52:42.780
rendering with OpenGL ES and
UIKit or Core Animation if you

00:52:42.870 --> 00:52:45.030
have performance sensitive code.

00:52:45.580 --> 00:52:48.900
Now, we'll say a few things quickly
about optimizing for memory

00:52:48.900 --> 00:52:51.510
and vertex and texture next.

00:52:52.740 --> 00:52:56.850
So first for memory,
you're using a shared memory system.

00:52:56.940 --> 00:53:00.370
And what that means is that the memory
that you're using for graphics is

00:53:00.490 --> 00:53:04.140
not necessarily available to the rest
of the system when you're using it.

00:53:04.220 --> 00:53:07.030
So you generally want to use no
more than 24 megs of memory for

00:53:07.030 --> 00:53:09.050
your textures and your surfaces.

00:53:09.260 --> 00:53:10.880
And we actually enforce this limit.

00:53:10.920 --> 00:53:13.000
Now, we say generally you don't
want to use more than this,

00:53:13.020 --> 00:53:15.830
but actually, you know,
you're better off the less you're using.

00:53:15.890 --> 00:53:18.860
So you should try and stay as
far below that as possible.

00:53:19.000 --> 00:53:22.150
And we give a few techniques in
the next few slides that show

00:53:22.150 --> 00:53:23.930
exactly how you can do that.

00:53:24.020 --> 00:53:27.810
But some examples,
you can compress your texture data using

00:53:28.080 --> 00:53:30.850
the PVRT texture compression format.

00:53:30.920 --> 00:53:34.380
And you can also deallocate other memory
that you're not using in the system,

00:53:34.380 --> 00:53:37.490
such as the textures
you've just given OpenGL.

00:53:38.940 --> 00:53:42.640
Similarly, when dealing with vertex data,
you want to minimize the amount

00:53:42.640 --> 00:53:44.940
of vertex data you're sending.

00:53:45.110 --> 00:53:47.080
Now, you can do this through
a variety of techniques,

00:53:47.080 --> 00:53:51.240
such as using indexed triangle strips,
or you can actually fake the system out,

00:53:51.390 --> 00:53:53.340
fake the user out,
by not sending the geometry

00:53:53.340 --> 00:53:55.870
in the first place,
either culling it yourself or using

00:53:55.970 --> 00:54:02.080
techniques like dot 3 lighting or
texture to just simply make it look

00:54:02.080 --> 00:54:02.080
more complex than it actually is.

00:54:02.940 --> 00:54:06.240
Generally, you want to use the smallest
amount of data you can.

00:54:06.240 --> 00:54:10.240
And this is sort of a general rule
for all of the OpenGL ES programming.

00:54:10.240 --> 00:54:14.170
For instance,
you can get by with 4 byte colors,

00:54:14.170 --> 00:54:16.980
or maybe two texture
coordinates instead of four,

00:54:16.980 --> 00:54:19.730
or shorts for your texture
coordinates instead of floats.

00:54:19.940 --> 00:54:20.400
This is good.

00:54:20.400 --> 00:54:23.240
You want to generally pack your
data as tightly as possible.

00:54:23.240 --> 00:54:27.360
And you want to generally
avoid fixed point vertex data.

00:54:27.360 --> 00:54:29.860
The reason we mention this is that,
once again, if you're coming from

00:54:29.860 --> 00:54:31.730
other embedded platforms,
maybe you're using that

00:54:31.730 --> 00:54:32.880
for efficiency purposes.

00:54:32.900 --> 00:54:34.140
Or performance.

00:54:34.150 --> 00:54:36.480
On this platform,
floating point data is just fine.

00:54:36.480 --> 00:54:38.810
If you're going to use 32-bit data,
you might as well use floating

00:54:38.930 --> 00:54:40.000
point and get the performance.

00:54:40.000 --> 00:54:42.180
I'm sorry, get the precision.

00:54:44.570 --> 00:54:48.390
Now, on the subject of lighting,
there's a few other key points here.

00:54:48.510 --> 00:54:52.740
Generally, the lighting is fully
accelerated by the GPU,

00:54:52.740 --> 00:54:55.400
but certain types of lights
are more expensive than others.

00:54:55.400 --> 00:54:57.410
So in your lighting model,
you want to use the

00:54:57.480 --> 00:54:58.590
simplest model you can.

00:54:58.800 --> 00:55:01.370
And this might mean using fewer
lights or simpler types of lights.

00:55:01.420 --> 00:55:04.400
So you can use directional
lights instead of spotlights.

00:55:04.400 --> 00:55:07.010
And you can even pre-compute your
lighting if you find that you can

00:55:07.010 --> 00:55:10.190
store the values in a color or texture.

00:55:11.690 --> 00:55:12.560
All right.

00:55:12.630 --> 00:55:15.510
Lastly, in the subject of textures,
we want to say that you

00:55:15.530 --> 00:55:19.010
should try to minimize your
texture storage requirements.

00:55:19.090 --> 00:55:20.930
This is, again,
this general rule of minimizing the

00:55:20.970 --> 00:55:23.860
amount of memory you're consuming,
because it not only saves you storage,

00:55:23.930 --> 00:55:24.960
but it saves you bandwidth.

00:55:24.960 --> 00:55:27.010
All of that data has
to be read by the GPU.

00:55:27.120 --> 00:55:29.970
So if you can get by with
16-bit color for your textures,

00:55:30.030 --> 00:55:33.480
you should try it,
and also for your rendering surfaces.

00:55:33.560 --> 00:55:37.880
And if you can use the PVRTC compression
format for your textures,

00:55:38.140 --> 00:55:41.610
this can provide a huge win,
because it can drastically reduce

00:55:41.610 --> 00:55:44.540
the amount of texture storage and
memory bandwidth that you need.

00:55:44.630 --> 00:55:48.110
We provide a tool in the SDK,
the path listed here on the slide,

00:55:48.340 --> 00:55:50.640
to actually allow you to
create textures in this format,

00:55:50.730 --> 00:55:56.450
convert from RGBA values to this
PVRTC texture compression format.

00:55:56.540 --> 00:56:02.340
And when you're using this format,
it's generally a good idea to check out

00:56:02.360 --> 00:56:04.380
what the compression format looks like.

00:56:04.420 --> 00:56:05.370
We provide this tool.

00:56:05.430 --> 00:56:07.860
It will actually give
you a preview of that,

00:56:07.910 --> 00:56:10.960
because certain types of images
will compress better than others.

00:56:10.970 --> 00:56:14.380
So you can take a look at that.

00:56:14.690 --> 00:56:16.020
Two last points.

00:56:16.050 --> 00:56:17.880
When using MIT mapping,
we generally recommend

00:56:17.880 --> 00:56:20.470
you use-- first of all,
we generally recommend you

00:56:20.470 --> 00:56:22.760
use MIT mapping because that
can also improve efficiency.

00:56:22.760 --> 00:56:25.710
But also, you should try and use the
linear MIT map nearest setting to

00:56:25.710 --> 00:56:27.420
improve efficiency the greatest.

00:56:27.510 --> 00:56:32.780
And lastly, again,
as an influence of the tile-based

00:56:32.780 --> 00:56:36.670
deferred mode renderer,
you want to try and minimize

00:56:36.670 --> 00:56:36.670
the number of times you're
modifying sub-regions of textures.

00:56:37.740 --> 00:56:39.670
All right,
so the last thing we want to say about

00:56:39.670 --> 00:56:42.440
our best practices is use the tools.

00:56:42.490 --> 00:56:45.480
We have really great tools
in the iPhone OS SDK.

00:56:45.580 --> 00:56:47.300
And one of them is instruments.

00:56:47.350 --> 00:56:48.620
We've seen some demos so far.

00:56:48.620 --> 00:56:52.050
I'm going to show you how to use
instruments next with OpenGL ES.

00:56:52.220 --> 00:56:54.780
So we can switch to
the demo machine here.

00:57:00.540 --> 00:57:05.780
Okay, so let's take a look
back at our bunnies demo.

00:57:05.780 --> 00:57:09.180
And what we will do is we will
set this to the release setting,

00:57:09.230 --> 00:57:11.560
just because we're going to
be looking at performance.

00:57:11.600 --> 00:57:18.360
And what we want to do first
is run this demo on the device.

00:57:18.450 --> 00:57:23.170
So I'm going to rebuild and
run the demo on the device,

00:57:23.170 --> 00:57:24.260
the FBO bunnies demo.

00:57:24.260 --> 00:57:30.060
And if you can switch for a
moment to the iPhone display.

00:57:38.300 --> 00:57:42.240
That's running on the device here.

00:57:42.290 --> 00:57:44.670
And so this will give you a feel
for just from looking at it,

00:57:44.680 --> 00:57:46.780
you know,
what the performance is right now.

00:57:46.820 --> 00:57:49.780
And if we switch for a moment
back to the demo machine here,

00:57:49.780 --> 00:57:52.110
I'll show you what we
can do with instruments.

00:57:52.210 --> 00:57:55.220
So I'm going to leave this
running on the device,

00:57:55.290 --> 00:57:57.020
but I'm going to switch
in Open Instruments.

00:57:57.020 --> 00:58:00.660
And Instruments provides
a default template for

00:58:00.660 --> 00:58:03.110
OpenGL ES performance app monitoring.

00:58:03.200 --> 00:58:06.520
So if you can click on that,
and we choose that,

00:58:07.070 --> 00:58:10.850
We will get the instruments panel
with the OpenGL ES template.

00:58:10.850 --> 00:58:12.930
And in this panel,
we can simply choose to

00:58:12.970 --> 00:58:16.470
attach to our running process,
which I'll do right here.

00:58:18.440 --> 00:58:19.900
Once we've done that, I'm going to start.

00:58:19.910 --> 00:58:23.220
And it begins recording
statistics from the device.

00:58:23.300 --> 00:58:27.360
So the device statistics I'm recording
right here are frames per second,

00:58:27.460 --> 00:58:29.980
the basic measurement of performance.

00:58:30.370 --> 00:58:33.190
Just to get a feel for it right now,
we can see we're capturing a

00:58:33.190 --> 00:58:35.530
few different measurements here.

00:58:35.530 --> 00:58:39.890
But you can see it's kind of
noodling around between maybe

00:58:39.890 --> 00:58:42.740
22 to a high of 27 on here.

00:58:42.740 --> 00:58:45.810
So we'll call it 25 frames per second.

00:58:47.810 --> 00:58:48.120
All right.

00:58:48.120 --> 00:58:50.880
Now let's take a look and
stop this for one moment,

00:58:50.880 --> 00:58:56.080
and I'm going to go back and
check out another setting that we

00:58:56.080 --> 00:58:59.130
have in the application itself.

00:58:59.130 --> 00:59:03.420
So if I look at the application,
we decided when we're looking at

00:59:03.420 --> 00:59:07.210
converting this to run in OpenGL ES and
to run on the iPhone instead of a Mac,

00:59:07.210 --> 00:59:10.810
there's a few tips and techniques
that we've recommended here today

00:59:10.810 --> 00:59:12.340
we wanted to take advantage of.

00:59:12.340 --> 00:59:13.650
So we've listed them here.

00:59:13.650 --> 00:59:17.600
I won't go through them one at a time,
but the first one is -- well,

00:59:17.600 --> 00:59:21.030
you decided to use short
arrays instead of floats.

00:59:21.030 --> 00:59:25.460
So this converted our floating point data
to short data and gave that to the GPU,

00:59:25.460 --> 00:59:28.040
and this was a considerable
performance win.

00:59:28.160 --> 00:59:30.420
We also looked at
batching up our rendering.

00:59:30.580 --> 00:59:34.270
So once again, taking similar states,
putting them together through

00:59:34.270 --> 00:59:36.930
a variety of techniques,
and minimizing the number of

00:59:36.930 --> 00:59:39.000
draw calls we actually had to do.

00:59:39.010 --> 00:59:42.100
And lastly,
we looked at using 32-bit color

00:59:42.100 --> 00:59:44.380
before we convert to 16-bit color.

00:59:44.620 --> 00:59:45.700
to see what effect that gets.

00:59:45.700 --> 00:59:48.110
So I'm actually going to turn that on.

00:59:54.060 --> 00:59:54.060
I'm going to stop it from running.

00:59:54.060 --> 00:59:54.060
I'm going to rebuild and recompile it.

00:59:56.800 --> 01:00:06.800
[Transcript missing]

01:00:10.100 --> 01:00:25.000
[Transcript missing]

01:00:27.730 --> 01:00:30.430
And you can see now,
performance actually,

01:00:30.560 --> 01:00:33.640
although it's noodling around,
is noodling around a higher number here.

01:00:33.770 --> 01:00:37.690
And if we let it sort of settle in,
we see it kind of settles in at about

01:00:37.850 --> 01:00:40.460
a little above 30 frames a second.

01:00:40.560 --> 01:00:45.800
So we've taken a few of these techniques,
such as using smaller vertex size data,

01:00:46.290 --> 01:00:51.210
using 32-bit versus 16-bit
colors-- we chose 16-bit-- and

01:00:51.210 --> 01:00:53.080
batching up our state changes.

01:00:53.350 --> 01:00:54.920
And we got-- well, this is pretty good.

01:00:54.920 --> 01:00:58.410
We got about a 20% performance boost.

01:00:58.540 --> 01:01:01.160
Now I want to look at a few
other statistics we have here.

01:01:01.470 --> 01:01:03.980
There's quite a few here,
and they have some confusing names.

01:01:03.980 --> 01:01:07.320
We wanted to call out a few of
them that are really important.

01:01:07.430 --> 01:01:09.500
So we've obviously got frames per second.

01:01:09.610 --> 01:01:14.540
Now we want to see-- another one that's
important is GART resident object size.

01:01:14.660 --> 01:01:17.250
And that is a measure of
how much memory we're using.

01:01:17.360 --> 01:01:23.150
And the last one we want to click on here
is command buffer implicit submit count.

01:01:23.710 --> 01:01:26.690
Now, Instruments plots all these
for us up here and tracks

01:01:26.750 --> 01:01:30.450
their statistics down here,
and I'll just tell you what

01:01:30.450 --> 01:01:32.930
these are as we go through them.

01:01:32.940 --> 01:01:34.960
So the first one is
CommandBufferImplicitSubmitCount.

01:01:34.960 --> 01:01:39.020
That is a measurement of how
many times the implementation

01:01:39.310 --> 01:01:43.160
needed to submit the scene on your
behalf because of this tile-based

01:01:43.160 --> 01:01:44.780
deferred-mode rendering architecture.

01:01:44.790 --> 01:01:47.740
We batch up a certain amount of data,
then we submit it to the GPU.

01:01:47.740 --> 01:01:51.440
And generally, you want that number to be
zero or as low as possible.

01:01:51.440 --> 01:01:54.220
If you see that number climbing,
you're generally going to

01:01:54.220 --> 01:01:56.630
be seeing some performance
issues that you want to avoid.

01:01:56.640 --> 01:01:59.380
And you can avoid them by taking
advantage of all the techniques

01:01:59.380 --> 01:02:01.400
that we've mentioned today,
minimizing the amount of

01:02:01.400 --> 01:02:04.060
data that you require,
minimizing the amount of draw calls.

01:02:04.080 --> 01:02:06.220
So that's a number you
want to watch out for.

01:02:06.220 --> 01:02:10.680
The other number here is
the GartResidentObjectSize.

01:02:10.740 --> 01:02:15.850
Now, again, a bit of a confusing name,
but it's basically telling you how

01:02:15.850 --> 01:02:18.090
much memory the GPU is needing to use.

01:02:18.180 --> 01:02:22.600
Right now, as we look at it,
it's using right about 3 megs of memory.

01:02:22.840 --> 01:02:26.240
I didn't show this before,
but in the other version of this demo,

01:02:26.240 --> 01:02:28.590
before we turned on our faster options,
it was using right

01:02:28.600 --> 01:02:29.880
about 4 megs of memory.

01:02:29.880 --> 01:02:33.940
So we saved a quarter of our
memory by turning these options on.

01:02:33.980 --> 01:02:35.940
And again,
that can help with performance.

01:02:40.250 --> 01:02:41.340
Okay, cool.

01:02:41.390 --> 01:02:45.760
So I'm going to stop this demo now and
show you one last demo that kind of

01:02:45.920 --> 01:02:47.400
puts a lot of this stuff all together.

01:02:47.400 --> 01:02:53.490
So we've shown you some spinning
squares and some cute and fuzzy bunnies.

01:02:53.490 --> 01:02:57.540
We'll show you something
a little more interesting.

01:02:59.700 --> 01:03:06.740
will show you how to use
OpenGL ES to drive iPhone games

01:03:06.740 --> 01:03:11.530
and other mobile 3D applications.

01:03:12.400 --> 01:03:15.220
This demo is a demo from
the iPhone-- I'm sorry,

01:03:15.220 --> 01:03:18.640
from the Imagination
Technologies PowerVR MBX SDK.

01:03:18.760 --> 01:03:21.900
And what this demo shows is sort
of some typical game-like content

01:03:21.900 --> 01:03:24.250
you can create using OpenGL ES.

01:03:24.410 --> 01:03:29.140
The demos from the SDK,
the Imagination Technologies SDK,

01:03:29.170 --> 01:03:31.270
show off a lot of these
tips and techniques,

01:03:31.410 --> 01:03:35.080
and we'll see what this
demo looks like here.

01:03:38.600 --> 01:03:44.580
So we have our robots coming out,
much scarier than fuzzy bunnies.

01:03:44.580 --> 01:03:47.970
And the robots will come out,
and they'll say hi to each other.

01:03:50.990 --> 01:03:53.820
And this is exactly the kind of content
which looks really great on the iPhone.

01:03:53.820 --> 01:03:57.660
You know, it's really focused in on sort
of game-like rendering scenes.

01:03:57.710 --> 01:04:01.390
And here the robots, they begin fighting,
as robots often do.

01:04:11.000 --> 01:04:32.900
[Transcript missing]

01:04:47.850 --> 01:04:52.400
is sort of the hidden Steadicam
guy following behind him.

01:04:52.430 --> 01:04:54.800
Now this part makes me sad.

01:04:54.800 --> 01:04:59.700
He really knows how to
kick a guy when he's down.

01:05:04.910 --> 01:05:07.650
All right, great.

01:05:07.720 --> 01:05:11.680
So that is robots.

01:05:11.760 --> 01:05:16.090
Many thanks to Imagination
Technologies for providing a demo.

01:05:18.560 --> 01:05:21.290
OK, so now I'll switch back
to the slides here.

01:05:21.400 --> 01:05:23.320
And I just want to give a quick review.

01:05:23.320 --> 01:05:26.440
So there's some key statistics you
want to measure with instruments.

01:05:26.520 --> 01:05:30.040
There's raw performance you
can get with frames per second.

01:05:30.120 --> 01:05:33.780
There's the graphics memory usage
with the GART resident object size,

01:05:33.920 --> 01:05:38.250
and the implicit scene flushing,
command buffer implicit submit count.

01:05:38.380 --> 01:05:41.440
And again, we want to highlight all of
these for you so you can use them

01:05:41.440 --> 01:05:45.820
in tuning your applications to
run an OpenGL ES on the iPhone.

01:05:47.310 --> 01:05:49.500
Let's take a look at
what we've learned today.

01:05:49.620 --> 01:05:52.700
So we started off by
discussing OpenGL ES,

01:05:52.800 --> 01:05:58.000
what it is, how you use it,
how it's a subset of desktop OpenGL 1.5,

01:05:58.110 --> 01:06:00.950
and what features it contains and
what features have been removed.

01:06:01.060 --> 01:06:03.200
And we learned that it's
incredibly powerful.

01:06:03.310 --> 01:06:06.480
All of the key features for doing
hardware accelerated vertex and

01:06:06.480 --> 01:06:08.680
fragment processing are all still there.

01:06:08.800 --> 01:06:12.370
And you can use it to create robots
and fuzzy bunnies and all of the

01:06:12.520 --> 01:06:14.740
other cool demos we've seen so far.

01:06:14.840 --> 01:06:18.920
We also spent some time talking about
using OpenGL ES on the iPhone itself.

01:06:19.020 --> 01:06:21.800
And for that,
we looked at some key new technologies,

01:06:21.930 --> 01:06:24.920
such as the Eagle API for
creating your contexts,

01:06:25.100 --> 01:06:28.230
Frame Buffer Objects API for
managing your frame buffer,

01:06:28.340 --> 01:06:31.540
and the CA Eagle Layer subclass
of Core Animation for

01:06:31.540 --> 01:06:35.220
displaying your content and
integrating with the iPhone OS.

01:06:35.330 --> 01:06:37.640
We also took a look at the
iPhone OS support in the

01:06:37.640 --> 01:06:40.880
iPhone-- OpenGL ES support
in the iPhone simulator.

01:06:41.000 --> 01:06:43.300
And in there,
we found that we have a fully

01:06:43.300 --> 01:06:44.740
featured OpenGL ES implementation.

01:06:44.740 --> 01:06:47.930
And we found that we have a fully
featured OpenGL ES implementation

01:06:47.930 --> 01:06:50.820
in the simulator,
which you can use to do your initial

01:06:50.820 --> 01:06:54.830
development and algorithmic testing,
make sure all your code

01:06:54.910 --> 01:06:56.880
runs and looks just great.

01:06:56.880 --> 01:06:59.620
But you should do your
performance tuning on the device,

01:06:59.620 --> 01:07:00.970
using tools such as
instruments and other tools,

01:07:00.970 --> 01:07:01.500
such as SHARP.

01:07:01.780 --> 01:07:04.310
And finally, we spent a good deal of
time talking about the best

01:07:04.310 --> 01:07:05.880
practices and recommendations.

01:07:05.940 --> 01:07:08.490
Most of these focused
in on two key areas,

01:07:08.660 --> 01:07:12.520
specifically understanding
how to best use the tile-based

01:07:12.520 --> 01:07:17.400
deferred mode renderer,
and how to minimize memory bandwidth,

01:07:17.400 --> 01:07:22.170
CPU overhead, driver overhead,
and memory storage.

01:07:23.080 --> 01:07:24.160
We have some more information.

01:07:24.160 --> 01:07:28.460
You can take a look at the iPhone OS SDK,
where we go through all of

01:07:28.460 --> 01:07:29.540
this in much more detail.

01:07:29.540 --> 01:07:34.630
And we also have all of the sample
code and tools that you can use

01:07:34.740 --> 01:07:37.340
to do your performance techniques,
performance optimization.

01:07:37.340 --> 01:07:42.350
You should also take a look at the
OpenGL ES website on chronos.org.

01:07:42.380 --> 01:07:44.690
We have a ton of
information about OpenGL ES,

01:07:44.690 --> 01:07:47.320
documentation,
and a lot of good recommendations

01:07:47.320 --> 01:07:48.660
for how to use the API.

01:07:49.370 --> 01:07:52.540
And also, Imagination Technologies,
makers of the

01:07:52.540 --> 01:07:55.880
PowerVR MBX Lite GPU and the iPhone,
have a great website

01:07:55.920 --> 01:07:57.130
about the MBX itself.

01:07:57.210 --> 01:07:59.170
And you can find out all about
its architecture there and how

01:07:59.170 --> 01:08:00.350
to drive it most efficiently.

01:08:00.360 --> 01:08:03.950
Alan Schaefer,
our graphics technology evangelist,

01:08:03.990 --> 01:08:08.320
can answer all of your questions
about OpenGL ES on the iPhone.

01:08:08.320 --> 01:08:11.520
And there's a few additional
resources here at WWDC.

01:08:11.520 --> 01:08:13.800
We have a lab tomorrow morning.

01:08:13.800 --> 01:08:15.300
We encourage you all to come.

01:08:15.300 --> 01:08:18.980
I mean, based on what we've seen so far,
we've just been blown away about...

01:08:19.140 --> 01:08:22.320
With the SDK that people have had
for just a short period of time,

01:08:22.460 --> 01:08:23.860
it's been really, really cool.

01:08:23.860 --> 01:08:25.800
We've seen some amazing demos so far.

01:08:25.800 --> 01:08:27.340
So come to the OpenGL ES lab.

01:08:27.340 --> 01:08:28.520
We can answer your questions there.

01:08:28.520 --> 01:08:30.580
And there's some related sessions.

01:08:30.580 --> 01:08:34.380
There's some sessions on core animation,
general sessions on tuning

01:08:34.480 --> 01:08:37.060
OpenGL on the desktop,
but also apply generally

01:08:37.060 --> 01:08:38.600
to OpenGL ES on the iPhone.

01:08:38.600 --> 01:08:41.250
And just general
performance tuning sessions.

01:08:41.260 --> 01:08:45.180
As we saw earlier this afternoon,
there's a great session on games

01:08:45.180 --> 01:08:47.020
for using OpenGL ES in games.

01:08:47.020 --> 01:08:49.020
And you can check that out as well.

01:08:49.020 --> 01:08:49.710
All right.

01:08:49.710 --> 01:08:52.630
With that,
I thank you very much for your attention.

01:08:52.660 --> 01:08:54.020
I hope you found this very useful.

01:08:54.020 --> 01:08:57.280
And I'm going to turn it over to
Alan Schaefer next and ask some

01:08:57.280 --> 01:09:00.980
members from the Embedded Graphics
team to come up to do some Q&A.

01:09:00.980 --> 01:09:02.060
Thank you very much.

01:09:02.060 --> 01:09:06.420
Thank you.
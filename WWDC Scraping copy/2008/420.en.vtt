WEBVTT

00:00:20.200 --> 00:00:21.800
Good afternoon.

00:00:21.940 --> 00:00:24.180
My name is Patrick Beard,
and I work on the

00:00:24.180 --> 00:00:29.490
Objective-C runtime team,
and I work on garbage collection.

00:00:29.600 --> 00:00:35.040
And I'm happy to be here today
to tell you about garbage

00:00:35.040 --> 00:00:37.790
collection with Objective-C.

00:00:40.180 --> 00:00:41.010
So you're here.

00:00:41.200 --> 00:00:42.240
You're curious.

00:00:42.250 --> 00:00:46.100
Maybe you want to put a toe in the water.

00:00:46.140 --> 00:00:48.480
Why use garbage collection?

00:00:49.750 --> 00:00:59.550
Garbage collection will
give you faster development.

00:00:59.550 --> 00:01:03.030
You'll be able to spend less time
thinking about memory management and

00:01:03.030 --> 00:01:03.030
more time thinking about program design.

00:01:03.300 --> 00:01:06.550
Memory leaks, gone.

00:01:06.730 --> 00:01:12.500
Crashes due to dangling pointers, gone,
hopefully.

00:01:12.610 --> 00:01:17.370
And we provide tools that will help you
visualize your program as it's running.

00:01:19.500 --> 00:01:24.260
You can also get faster software because
the code you write will be simpler.

00:01:24.470 --> 00:01:28.580
Less code hopefully means
faster a lot of the time.

00:01:29.150 --> 00:01:32.840
The garbage collector can
also be collecting memory,

00:01:32.860 --> 00:01:38.040
finding memory that's garbage that
should be freed in the background.

00:01:38.100 --> 00:01:40.870
It runs concurrently with your program.

00:01:41.030 --> 00:01:44.770
And it's also sensitive to
whether the user is actually

00:01:44.770 --> 00:01:46.900
doing something important.

00:01:46.900 --> 00:01:50.500
It can remain out of the
way until the user pauses.

00:01:50.710 --> 00:01:53.860
And so perceived performance can go up.

00:01:55.660 --> 00:01:57.400
And it's about time.

00:01:57.530 --> 00:01:59.730
It's about your time,
saving you time while

00:01:59.730 --> 00:02:00.790
you write your code.

00:02:00.940 --> 00:02:02.100
It's about execution time.

00:02:02.100 --> 00:02:04.790
It's about making your
programs run faster.

00:02:04.940 --> 00:02:09.380
And garbage collection has been
around since the 1960s and has

00:02:09.380 --> 00:02:13.960
become increasingly popular with the
languages like Java and C# that have

00:02:13.960 --> 00:02:16.500
been around for quite a while now.

00:02:16.630 --> 00:02:20.490
So isn't it about time you
use garbage collection?

00:02:22.780 --> 00:02:26.200
So the structure of the talk today,
I'm going to talk about

00:02:26.240 --> 00:02:28.110
some high-level GC concepts.

00:02:28.320 --> 00:02:31.400
If you're not familiar with
how garbage collectors work,

00:02:31.400 --> 00:02:33.840
I'm going to spend a
little time showing you,

00:02:33.840 --> 00:02:36.460
giving you a mental
model for how they work.

00:02:36.470 --> 00:02:42.320
Then I'm going to spend some time
talking about what's new in Snow Leopard.

00:02:42.320 --> 00:02:46.320
We have some exciting
developments to talk about.

00:02:46.370 --> 00:02:49.700
Then I'm going to dive
into the nuts and bolts,

00:02:49.700 --> 00:02:49.700
how to use garbage collection.

00:02:49.960 --> 00:02:52.410
How you can get the most out of it.

00:02:52.460 --> 00:02:55.780
Finally,
I will spend some time on a demo,

00:02:55.950 --> 00:03:04.930
one of our-- a couple of our tools,
and show you how to find out what's

00:03:04.930 --> 00:03:04.930
happening in a program and understand it,
comprehend it better.

00:03:06.760 --> 00:03:11.270
So let's dive into some
garbage collection concepts.

00:03:11.470 --> 00:03:15.400
First off, what is a garbage collector?

00:03:15.400 --> 00:03:15.400
What to do?

00:03:15.740 --> 00:03:21.940
In this talk, I'm going to concentrate on
using a garbage collector for

00:03:21.940 --> 00:03:25.230
managing your objects primarily.

00:03:25.230 --> 00:03:29.360
We're having a talk tomorrow at 2:00.

00:03:29.360 --> 00:03:34.660
Greg Parker is going to talk
about how the garbage collector

00:03:34.660 --> 00:03:36.390
can also be used for lower-level
tasks managing raw memory.

00:03:36.390 --> 00:03:36.390
But we're going to talk about
objects primarily today.

00:03:37.570 --> 00:03:47.670
So another way to think about
garbage collection beyond it

00:03:47.670 --> 00:03:47.670
being automatic memory management,
automatic object management,

00:03:47.670 --> 00:03:47.670
is what it isn't.

00:03:49.180 --> 00:03:53.030
With garbage collection,
you can forget about reference counting.

00:03:53.230 --> 00:03:57.170
You can forget about bookkeeping,
a bunch of details that can take a lot of

00:03:57.170 --> 00:03:59.620
your time to think about getting right.

00:03:59.780 --> 00:04:03.690
It means no dangling pointers.

00:04:03.790 --> 00:04:08.170
You can't over-release an object
with garbage collection because

00:04:08.180 --> 00:04:10.500
there's no retain release to do.

00:04:10.630 --> 00:04:13.260
And on the other hand, no memory leaks.

00:04:13.260 --> 00:04:15.700
You can't over-retain an object.

00:04:15.700 --> 00:04:18.560
Thank you very much,
or you're very welcome.

00:04:20.170 --> 00:04:26.920
So let's talk about the memory model
in any garbage collected program with a

00:04:26.920 --> 00:04:29.760
little bit of emphasis on the Macintosh,
Mac OS X.

00:04:31.730 --> 00:04:36.610
Memory is divided up
into three main areas.

00:04:36.750 --> 00:04:43.000
The first area are your local
variables and your globals.

00:04:43.000 --> 00:04:51.630
The local variables live on your stack
and globals are in static data segments.

00:04:51.630 --> 00:04:51.630
Second area,
we call the garbage collected heap.

00:04:51.630 --> 00:04:51.630
All of your objects go here.

00:04:52.030 --> 00:04:55.780
There's no more multiple zones
and specifying a zone when you

00:04:55.820 --> 00:04:58.340
allocate Objective-C objects.

00:04:58.460 --> 00:04:59.510
And then there's the malloc zone.

00:04:59.720 --> 00:05:00.710
Good old malloc-free.

00:05:00.990 --> 00:05:02.840
It's still there.

00:05:07.620 --> 00:05:11.350
So the first thing a garbage collector
does is it needs to find out what

00:05:11.520 --> 00:05:16.200
objects are live in your program.

00:05:16.200 --> 00:05:16.200
So the first thing it does is it

00:05:17.320 --> 00:05:20.320
scans your stack.

00:05:20.470 --> 00:05:27.340
Next thing it does is it goes
through all your global variables,

00:05:27.340 --> 00:05:27.340
finds the pointers that
you've stored there.

00:05:28.610 --> 00:05:39.500
So as I said, the garbage collected heap,
that's where your objects go.

00:05:39.540 --> 00:05:40.590
And there's also a section of that
heap reserved for non-objects,

00:05:40.590 --> 00:05:40.590
some of which are scanned and
some of which are not scanned.

00:05:43.630 --> 00:05:47.650
So the garbage collector
scans your objects and stops

00:05:47.870 --> 00:05:52.790
with the scanned non-objects,
and the unscanned objects

00:05:52.790 --> 00:05:55.200
are not looked at.

00:05:55.230 --> 00:05:59.370
Malic zone is explicitly ignored
by the garbage collector.

00:06:02.310 --> 00:06:05.000
So I want to show you a concrete example.

00:06:05.170 --> 00:06:10.700
Say we have a program that
is manipulating work queues.

00:06:10.820 --> 00:06:12.930
First thing it does is it
allocates the first element,

00:06:13.190 --> 00:06:15.340
stores it on your stack.

00:06:15.450 --> 00:06:18.870
The object is allocated is in the heap,
so this represents a pointer

00:06:18.870 --> 00:06:20.560
from the stack into the heap.

00:06:21.620 --> 00:06:27.730
We allocate another
object and a third object.

00:06:27.740 --> 00:06:34.100
So now we have a full
work queue ready to go,

00:06:34.100 --> 00:06:34.100
and the function returns,
stores the head of the work

00:06:34.100 --> 00:06:34.100
queue in a global variable,

00:06:35.480 --> 00:06:36.940
gets rid of the stack reference.

00:06:37.010 --> 00:06:38.600
Now the garbage collector runs.

00:06:38.700 --> 00:06:41.480
It has scanned your stack
and your global variables,

00:06:41.540 --> 00:06:46.820
and it traces all the pointers it finds
until it reaches your data structure,

00:06:46.870 --> 00:06:49.540
marks it, leaves it alone.

00:06:51.230 --> 00:06:55.270
So now we advance from the head of
the work queue to another element.

00:06:55.280 --> 00:06:58.770
We store this new element
in another global variable.

00:06:59.290 --> 00:07:01.790
Erase the pointer from the head.

00:07:01.790 --> 00:07:06.300
We're going to process that element,
and then the garbage collector kicks in.

00:07:07.350 --> 00:07:09.470
Object disappears.

00:07:09.660 --> 00:07:14.930
So object management becomes
assignment and erasing of pointers.

00:07:15.270 --> 00:07:17.280
That's all you have to do.

00:07:19.530 --> 00:07:25.020
So let's bring this now down to
how our collector does its job.

00:07:25.060 --> 00:07:27.330
Pardon me for a second.

00:07:34.800 --> 00:07:37.820
When we scan the stack,
we look at every word,

00:07:37.820 --> 00:07:40.540
every pointer-sized word on the stack.

00:07:40.540 --> 00:07:43.500
Now, we don't look at the entire stack.

00:07:43.500 --> 00:07:46.780
We look at the live
stack in your program.

00:07:46.790 --> 00:07:49.460
Now,
if you have only a single thread running,

00:07:49.460 --> 00:07:52.390
that means we look at the
live range of the current,

00:07:52.390 --> 00:07:55.180
where that thread
happens to be right now.

00:07:55.700 --> 00:07:58.970
When we look through it,
we look at every, as I said, every word,

00:07:58.990 --> 00:08:01.630
and we follow the rule,
if it looks like a pointer,

00:08:01.740 --> 00:08:02.750
it is a pointer.

00:08:02.750 --> 00:08:04.980
We call that conservative stack scanning.

00:08:04.980 --> 00:08:06.550
We do that because it's fast.

00:08:06.580 --> 00:08:09.480
We also do that because we
don't have any other choice.

00:08:09.480 --> 00:08:12.860
The C compiler,
the Objective-C compiler that

00:08:12.860 --> 00:08:16.760
we have does not annotate the
stack in any interesting way

00:08:16.760 --> 00:08:19.200
that lets us scan more exactly.

00:08:19.620 --> 00:08:22.830
It turns out to not be that big
a problem to do that because

00:08:23.390 --> 00:08:25.140
stacks come and go all the time.

00:08:25.700 --> 00:08:30.620
And we even provide a facility to clear
the stack periodically so stray pointers

00:08:30.620 --> 00:08:34.360
don't tend to stay there very long.

00:08:36.620 --> 00:08:45.370
Next thing, we scan globals precisely.

00:08:45.370 --> 00:08:46.610
That means we look at every one of
the globals you've ever assigned

00:08:46.610 --> 00:08:46.610
to that might contain a pointer.

00:08:47.750 --> 00:08:53.840
Unlike the stack,
we know exactly which globals contain

00:08:53.840 --> 00:09:00.320
pointers to objects at any given time.

00:09:00.320 --> 00:09:01.420
We do that by discovering the
globals as you assign to them,

00:09:01.420 --> 00:09:01.420
and more on how that
works in a little bit.

00:09:01.800 --> 00:09:05.070
We also scan the instance variables
of your objects precisely.

00:09:05.350 --> 00:09:10.540
So if you happen to have an integer
size field that looks like a pointer,

00:09:10.650 --> 00:09:11.690
we ignore it.

00:09:11.760 --> 00:09:15.950
And it's your job to make sure
your objects are always stored

00:09:15.960 --> 00:09:18.580
in properly typed variables.

00:09:18.710 --> 00:09:21.660
That brings me to the next topic.

00:09:22.040 --> 00:09:24.840
So I want to talk about
three concepts today.

00:09:24.840 --> 00:09:29.010
These are kinds of references
that you should understand.

00:09:29.110 --> 00:09:33.340
The first one, the primary one,
is the strong reference.

00:09:33.450 --> 00:09:38.040
Strong references are
Objective-C object pointers.

00:09:38.040 --> 00:09:42.180
And they come in various flavors.

00:09:42.180 --> 00:09:46.980
Most general type for storing an
object pointer is the ID type.

00:09:46.980 --> 00:09:50.400
If you know Objective-C, you know that.

00:09:50.410 --> 00:09:54.800
Then we have these other concrete
class name star pointer types.

00:09:54.820 --> 00:09:57.390
As long as you store your pointers
in variables of these types,

00:09:57.390 --> 00:10:00.930
the garbage collector will be able
to keep track of what you're doing.

00:10:03.600 --> 00:10:09.590
So I want to emphasize the way the
garbage collector finds your objects

00:10:09.590 --> 00:10:12.890
is by following strong references.

00:10:12.890 --> 00:10:17.850
Any object pointer reference from
the stack or a global variable

00:10:18.550 --> 00:10:24.030
will lead to an object or through
a chain of object references.

00:10:24.030 --> 00:10:25.830
That's how your objects stay connected.

00:10:25.830 --> 00:10:25.830
That's how they stay in touch.

00:10:25.830 --> 00:10:25.830
That's how they stay alive.

00:10:27.720 --> 00:10:32.270
The next topic,
the next kind of reference,

00:10:33.000 --> 00:10:33.290
is the weak reference.

00:10:33.770 --> 00:10:36.140
As far as I know,
we're the only programming language

00:10:36.280 --> 00:10:39.230
out there that actually has language
support for weak references.

00:10:39.300 --> 00:10:41.490
You've probably heard of weak references.

00:10:41.590 --> 00:10:43.200
Java has support for them.

00:10:43.200 --> 00:10:47.130
But as a class,
you have to use a wrapper object

00:10:47.130 --> 00:10:49.990
to represent weak references.

00:10:50.200 --> 00:10:54.760
The last time I looked,
my knowledge might be behind.

00:10:54.930 --> 00:10:56.670
But that was -- Every time
a new release comes out,

00:10:56.670 --> 00:10:56.670
I check.

00:10:56.670 --> 00:10:56.670
Do they have language support?

00:10:56.670 --> 00:10:56.670
We do.

00:10:57.490 --> 00:10:58.600
So what is a weak reference?

00:10:58.720 --> 00:11:04.830
A weak reference is a way to tell the
compiler and the garbage collector,

00:11:04.830 --> 00:11:06.260
"Skip this pointer.

00:11:06.510 --> 00:11:08.140
I know what I'm doing.

00:11:08.200 --> 00:11:10.890
I don't want this particular
pointer to be traced.

00:11:11.010 --> 00:11:15.440
I want this pointer to not hold up
garbage collection of an object."

00:11:15.630 --> 00:11:24.010
How do you get one simply by declaring
an instance variable or a global

00:11:24.010 --> 00:11:24.010
variable with a weak storage class?

00:11:24.910 --> 00:11:29.090
So here's an example,
a simple class that has some interface

00:11:29.130 --> 00:11:32.240
that lets you attach an observer to it.

00:11:32.340 --> 00:11:37.730
The observer, the observable object,
will only send messages about what

00:11:37.910 --> 00:11:41.220
it's doing as long as the observer
is live to the garbage collector.

00:11:41.220 --> 00:11:45.270
If the garbage collector finds
observer objects not reachable,

00:11:45.270 --> 00:11:49.160
not visible anymore,
then it will clear it out.

00:11:49.240 --> 00:11:56.730
So here's what it looks like.

00:11:56.730 --> 00:11:56.730
We have a strong
reference to our observer.

00:11:56.730 --> 00:11:56.730
We destroy that strong reference.

00:11:57.720 --> 00:12:00.260
Garbage collector clears
the weak reference.

00:12:00.260 --> 00:12:02.650
So the garbage collector does two things.

00:12:02.810 --> 00:12:07.490
It will not follow the pointer,
and if the object is garbage collected,

00:12:07.490 --> 00:12:09.500
it will clear the pointer.

00:12:09.560 --> 00:12:11.920
And then,
so there are only two states that

00:12:11.920 --> 00:12:14.020
you can see the weak reference in.

00:12:14.170 --> 00:12:18.280
Either you read it and you
temporarily create a strong reference,

00:12:18.280 --> 00:12:21.060
or you read it and you
see a nil reference.

00:12:21.080 --> 00:12:27.080
So this can be the basis of
caching and is a very useful

00:12:27.080 --> 00:12:30.620
primitive to have available to you.

00:12:33.760 --> 00:12:42.040
So the garbage collector
tosses the object,

00:12:42.040 --> 00:12:42.040
and the observable object only sees nil.

00:12:43.300 --> 00:12:49.830
The next concept is new for Snow Leopard,
and it is called the

00:12:49.830 --> 00:12:52.840
associative reference.

00:12:52.840 --> 00:12:57.960
Now,
associative references are interesting

00:12:57.960 --> 00:13:02.200
in that they allow you to create
effectively what looks like a

00:13:02.200 --> 00:13:02.200
strong reference to an object,
but without actually storing a pointer.

00:13:02.830 --> 00:13:06.720
So a strong reference is a
sort of conditional reference.

00:13:06.720 --> 00:13:08.890
An associative reference
is a conditional reference,

00:13:08.950 --> 00:13:13.030
just like a strong reference is,
but there's no storage required.

00:13:13.160 --> 00:13:15.100
And this gives you some
interesting capabilities.

00:13:15.210 --> 00:13:18.280
For example,
imagine you wanted to associate a

00:13:18.400 --> 00:13:21.010
string object with a color object.

00:13:21.060 --> 00:13:23.040
With an associative reference,
you can do that.

00:13:23.040 --> 00:13:25.550
Any string, whatever,
you don't have any control over

00:13:25.640 --> 00:13:27.560
the implementation of the string.

00:13:27.560 --> 00:13:32.580
In fact, any object instance whatsoever
can have an arbitrary other

00:13:32.580 --> 00:13:34.720
object associated with it.

00:13:34.720 --> 00:13:38.530
And what this means is if that
string object is garbage collected,

00:13:38.530 --> 00:13:41.980
the color object will be
garbage collected alongside it.

00:13:41.990 --> 00:13:44.360
And as long as the
string object is alive,

00:13:44.360 --> 00:13:47.080
the color object will remain alive.

00:13:49.690 --> 00:13:56.760
So when we destroy the strong
reference to the string,

00:13:56.760 --> 00:13:56.760
the whole kit and caboodle disappears.

00:14:00.790 --> 00:14:05.070
So how do we find out if our
object has been garbage collected?

00:14:05.230 --> 00:14:07.350
You can get an active notification.

00:14:07.530 --> 00:14:11.990
Your class, your instance can know that
it's been garbage collected by

00:14:12.050 --> 00:14:14.500
implementing a finalized method.

00:14:14.570 --> 00:14:16.950
This is very similar to Java.

00:14:18.460 --> 00:14:25.910
The one thing we don't
do the same way as Java,

00:14:25.910 --> 00:14:25.910
we don't allow you to store
a pointer to yourself.

00:14:26.090 --> 00:14:31.370
In a finalized method,
we explicitly disallow

00:14:31.370 --> 00:14:31.370
what's called resurrection.

00:14:31.620 --> 00:14:35.330
But the purpose of a finalized
method is to release resources,

00:14:35.330 --> 00:14:39.060
resources that you have allocated
in some way that are not managed

00:14:39.060 --> 00:14:40.840
by the garbage collector.

00:14:41.000 --> 00:14:41.840
But it's optional.

00:14:41.840 --> 00:14:44.200
You don't have to write one,
and it's avoidable.

00:14:44.390 --> 00:14:47.280
Oftentimes,
a resource you might be managing can

00:14:47.350 --> 00:14:51.890
be managed better and more simply by
using a wrapper object of some sort,

00:14:51.900 --> 00:14:54.470
something that might be in Foundation.

00:14:55.330 --> 00:15:01.020
Let's hear some caveats
to do with finalization.

00:15:01.020 --> 00:15:01.020
As I said, there's no resurrection.

00:15:02.370 --> 00:15:09.620
Finalized methods get called
after weak references are cleared,

00:15:09.620 --> 00:15:09.620
so even your finalized methods
will never see weak references.

00:15:10.130 --> 00:15:15.770
They're called in an arbitrary order.

00:15:16.640 --> 00:15:23.690
You can't guarantee that one object
gets finalized before another.

00:15:23.690 --> 00:15:23.690
And they have to be thread-safe,
because we are making it so

00:15:23.690 --> 00:15:23.690
that they might be called

00:15:24.100 --> 00:15:31.810
On the collector thread,
on the main thread,

00:15:31.940 --> 00:15:38.010
or they might be called on the thread
that's currently using an object,

00:15:38.010 --> 00:15:38.010
or a thread that's currently
doing a garbage collection.

00:15:38.290 --> 00:15:41.780
The final thing is objects can be
messaged after they're finalized

00:15:41.800 --> 00:15:43.900
because of that arbitrary ordering.

00:15:43.900 --> 00:15:47.220
All the objects in a cluster
of garbage can see each other.

00:15:47.330 --> 00:15:53.550
And that can be confusing because
that means you might get called,

00:15:53.550 --> 00:15:58.960
some of your methods might
get called when you've already

00:15:58.960 --> 00:16:00.270
finalized some of the state.

00:16:00.270 --> 00:16:00.270
That calls for some
defensive programming,

00:16:00.270 --> 00:16:00.270
to say the least.

00:16:04.980 --> 00:16:16.790
Now, write barriers are something that
garbage collectors-- that our garbage

00:16:16.790 --> 00:16:17.890
collector uses as a foundation for
implementing a number of useful features.

00:16:18.460 --> 00:16:28.700
Weak references, for example,
are built upon the concept

00:16:28.700 --> 00:16:28.700
of a write barrier.

00:16:28.700 --> 00:16:28.700
We have two kinds of write barriers:
strong write barriers

00:16:28.700 --> 00:16:28.700
and weak write barriers.

00:16:29.940 --> 00:16:35.010
What we are able to build on top of
the concept of a write barrier are the

00:16:35.450 --> 00:16:39.260
various garbage collection algorithms.

00:16:39.260 --> 00:16:41.390
So let me step back and say
what is a write barrier?

00:16:41.560 --> 00:16:46.170
A write barrier is how we do all
assignment of object pointers in

00:16:46.170 --> 00:16:50.210
the language when you assign to
an instance variable or a global

00:16:50.210 --> 00:16:54.480
variable or an indirect pointer,
we will issue a write barrier.

00:16:54.480 --> 00:16:57.600
We don't issue a write barrier
when you write to the stack.

00:16:57.600 --> 00:17:01.250
stack writes are very common,
so that's a good optimization.

00:17:02.030 --> 00:17:04.600
But this affords us a lot of
flexibility by effectively

00:17:04.950 --> 00:17:12.030
virtualizing the assignment operator
whenever it's used on your objects.

00:17:12.100 --> 00:17:17.510
This allows us to do at least three kinds
of garbage collection algorithms that we

00:17:17.560 --> 00:17:20.000
are working on and have had for a while.

00:17:20.000 --> 00:17:25.900
Generational GC, there's something called
the generational hypothesis.

00:17:25.900 --> 00:17:31.240
That's an assumption that objects
mostly are created for temporary use,

00:17:31.660 --> 00:17:34.860
and they die very soon
after they're created.

00:17:34.860 --> 00:17:37.940
That's a great example of
that is event objects when

00:17:37.940 --> 00:17:39.160
you're doing event processing.

00:17:41.610 --> 00:17:46.040
The other important thing to
know about generational garbage

00:17:46.040 --> 00:17:49.480
collection is that objects are aged,
and as they get older,

00:17:49.480 --> 00:17:51.240
we look at them less often.

00:17:51.480 --> 00:17:58.710
The write barrier gives us a
convenient way to track whether or

00:17:58.710 --> 00:17:58.710
not objects should be looked at.

00:17:59.250 --> 00:18:01.400
Another algorithm is a
concurrent GC algorithm,

00:18:01.400 --> 00:18:02.000
as I said.

00:18:02.000 --> 00:18:06.940
We run the garbage collector in another
thread independently of your code,

00:18:06.940 --> 00:18:11.100
so your code, your program will run
with many fewer pauses.

00:18:11.240 --> 00:18:16.100
The cost for that, though,
is paid for by using the write barrier.

00:18:16.100 --> 00:18:19.270
It gives us a way to sort of
incrementally find out what

00:18:19.270 --> 00:18:22.520
your program is doing behind
the garbage collector's back.

00:18:23.090 --> 00:18:27.430
The write barrier also lets us do
an exciting new technique where we

00:18:27.430 --> 00:18:32.840
track whether or not objects are
known only by a single thread or not.

00:18:32.970 --> 00:18:37.590
So we call that the
thread local collector,

00:18:37.590 --> 00:18:37.590
and I'll be discussing
that in a few minutes.

00:18:39.620 --> 00:18:44.070
So to bring this down to concrete terms,
a write barrier.

00:18:44.190 --> 00:18:47.440
The strong write barrier, as an example,
if you have an instance variable,

00:18:47.440 --> 00:18:50.320
whenever it gets written
to using a setter method,

00:18:50.370 --> 00:18:54.030
the compiler generates a call to
the Objective-C runtime system.

00:18:54.180 --> 00:18:58.760
So we get a call to obc assign
Ivar for instance variables.

00:18:59.730 --> 00:19:04.040
weak references go through a
different kind of write barrier.

00:19:04.180 --> 00:19:06.160
We have the weak write barrier.

00:19:06.300 --> 00:19:12.200
And we also, in this particular case,
have a read barrier.

00:19:12.550 --> 00:19:16.640
This is how the runtime system
guarantees that when you are

00:19:17.070 --> 00:19:20.730
reading a weak reference,
that all you get back is either

00:19:20.800 --> 00:19:23.330
a valid strong reference or nil.

00:19:23.740 --> 00:19:26.460
This is a synchronization point
with the garbage collector.

00:19:29.660 --> 00:19:33.000
All right, let's talk about what's
new for Snow Leopard.

00:19:36.160 --> 00:19:48.570
The first topic is how we're
making your software more robust.

00:19:48.570 --> 00:19:48.570
The second two topics have to
do with improved performance.

00:19:56.900 --> 00:20:02.230
So as I stated earlier,
global variables are tracked precisely.

00:20:02.880 --> 00:20:06.240
We discover the global variables as they
go through the global write barrier.

00:20:06.240 --> 00:20:11.580
We add them to a list of roots of globals
that should be scanned from then on.

00:20:11.850 --> 00:20:16.600
And it works really great,
except when it doesn't.

00:20:16.660 --> 00:20:18.600
In Leopard,

00:20:19.110 --> 00:20:25.350
We realized that if you pass
the address of a global variable

00:20:25.350 --> 00:20:32.350
down a function call chain,
our indirect write bearer had no

00:20:32.350 --> 00:20:37.490
knowledge of the fact that it was
a pointer to a global variable.

00:20:37.490 --> 00:20:37.490
So we could miss writes to
global variables through

00:20:37.490 --> 00:20:37.490
that sort of a call path.

00:20:38.170 --> 00:20:41.090
So here's an example of
a workaround for that.

00:20:41.310 --> 00:20:46.050
Don't ever pass a global to-- address
to a global variable and you'll be fine.

00:20:46.220 --> 00:20:53.690
Use a local variable or
an instance variable,

00:20:53.690 --> 00:20:54.990
either one will work,
and then assign it back to the

00:20:54.990 --> 00:20:54.990
global variable when you're done.

00:20:56.990 --> 00:21:01.430
So under Snow Leopard, we've fixed this,
and we've added even the

00:21:01.470 --> 00:21:08.010
ability to know-- we've added
to the indirect write barrier,

00:21:08.010 --> 00:21:13.470
essentially,
the ability to know if an address

00:21:13.470 --> 00:21:16.290
you're writing to is in some global
data segment of some library or bundle

00:21:16.290 --> 00:21:16.290
that maybe has been dynamically loaded.

00:21:16.360 --> 00:21:20.660
And that also gives us the ability
to have a goodbye kiss to the

00:21:20.660 --> 00:21:23.020
collector if a bundle gets unloaded.

00:21:23.220 --> 00:21:26.320
So then we won't have
any stray references,

00:21:26.420 --> 00:21:29.090
global references being scanned.

00:21:29.280 --> 00:21:33.340
So in Snow Leopard,
you'll be able to write code like this,

00:21:33.390 --> 00:21:35.720
where you simply pass the
pointer to the global variable.

00:21:36.130 --> 00:21:38.690
But if you want your
code to continue to run,

00:21:39.470 --> 00:21:46.300
write it the other way,
because then if you want it to run

00:21:46.300 --> 00:21:51.030
under both Snow Leopard and Leopard.

00:21:51.030 --> 00:21:51.030
Plus, that way is actually
slightly more efficient,

00:21:51.030 --> 00:21:51.030
because we don't have
to classify the pointer.

00:21:52.730 --> 00:21:55.170
All right, that was a bug fix.

00:21:55.440 --> 00:21:57.600
Now this is a new feature.

00:21:57.820 --> 00:22:00.210
So faster allocation.

00:22:01.720 --> 00:22:05.020
We studied running Objective-C programs,
Cocoa programs,

00:22:05.090 --> 00:22:10.090
and realized that there's a really big
premium on the performance of allocating

00:22:10.090 --> 00:22:12.440
lots and lots of small objects.

00:22:12.590 --> 00:22:18.750
Most objects are between 16 and
48 bytes in a 32-bit program.

00:22:19.670 --> 00:22:27.270
So if you can make those
objects really fast to allocate,

00:22:27.270 --> 00:22:27.270
programs speed up very, very measurably.

00:22:28.060 --> 00:22:33.490
So we did this by creating a cache
that hangs off of thread local storage

00:22:33.860 --> 00:22:38.810
and putting the most common sizes in
there and periodically refilling it.

00:22:39.540 --> 00:22:46.540
But it turns out that was not enough to
speed up garbage collection because in

00:22:46.540 --> 00:22:53.910
a sense what we'd be doing is making the
garbage collector's job harder by giving

00:22:53.910 --> 00:22:57.760
threads access to objects even faster.

00:22:57.760 --> 00:23:00.870
And we already had some problems
in keeping up and having the

00:23:00.870 --> 00:23:00.870
collector reclaim objects as
fast as they were being consumed.

00:23:01.260 --> 00:23:09.240
So that problem was made worse by if
we only performed this optimization.

00:23:09.240 --> 00:23:17.220
But an optimization like this
was also added to malloc.

00:23:17.220 --> 00:23:17.220
And as you can see, in Snow Leopard,
malloc runs six times faster as a result.

00:23:17.960 --> 00:23:21.380
But it's not enough of an optimization
for the garbage collector.

00:23:21.420 --> 00:23:23.410
Malik's in a different position.

00:23:23.410 --> 00:23:27.050
It's able to allocate an object
off of the thread local cache,

00:23:27.170 --> 00:23:29.240
and then when someone's
done with the object,

00:23:29.240 --> 00:23:31.340
put it right back on
a thread local cache.

00:23:31.420 --> 00:23:37.860
In our system, the garbage collector is
running on another thread.

00:23:37.900 --> 00:23:41.450
It doesn't have access to other threads,
thread local caches.

00:23:41.450 --> 00:23:41.450
So we only get half the optimization.

00:23:44.410 --> 00:23:47.110
So this gave us an idea.

00:23:47.290 --> 00:23:53.180
What if we could have our garbage
collector run on every thread,

00:23:53.180 --> 00:23:54.800
potentially?

00:23:54.800 --> 00:24:00.570
And what if we could have objects --
what if we could find out whether objects

00:24:00.570 --> 00:24:03.620
are known by only one thread or not?

00:24:04.080 --> 00:24:12.180
The auto-release pool in
reference-counted non-GC code

00:24:12.200 --> 00:24:18.740
works as well as it does because
most objects come into existence,

00:24:18.740 --> 00:24:18.740
are used temporarily,
and then they are auto-released

00:24:18.740 --> 00:24:18.740
all on the same thread.

00:24:20.570 --> 00:24:24.230
This gave us the idea of having what
we call the thread local collector.

00:24:24.230 --> 00:24:29.680
As I said, the generational hypothesis is
that most objects die young.

00:24:29.820 --> 00:24:35.470
With the thread local hypothesis,
we gained the intuition

00:24:35.470 --> 00:24:40.300
that most objects stay,
live and die their entire

00:24:40.300 --> 00:24:43.400
existence on a single thread.

00:24:43.400 --> 00:24:45.260
This gives us an opportunity to run
a much simpler garbage collector.

00:24:45.730 --> 00:24:50.630
That simply examines the
current thread stack and all

00:24:50.630 --> 00:24:55.470
the objects reachable from it.

00:24:55.470 --> 00:24:59.970
And if we could keep track of which
objects were just local to that stack,

00:24:59.970 --> 00:24:59.970
that collector would only have
to consider that set of objects.

00:25:00.710 --> 00:25:05.450
And the write barrier, again,
comes in and saves us and provides

00:25:05.450 --> 00:25:10.490
us a way to actually determine,
has this object remained local or not?

00:25:10.750 --> 00:25:16.520
So the write barrier can actually trap a
store into a global object and reclassify

00:25:16.610 --> 00:25:18.100
an object from local to global.

00:25:18.100 --> 00:25:20.310
We call that an escape.

00:25:23.910 --> 00:25:26.790
So Leopard works really well.

00:25:27.130 --> 00:25:28.860
It comes and picks up your garbage.

00:25:28.880 --> 00:25:30.710
It's kind of slow.

00:25:32.480 --> 00:25:37.150
With Snow Leopard,
performance is going to go way up.

00:25:37.300 --> 00:25:45.830
And here's a preliminary graph of
what kind of performance we've been

00:25:45.830 --> 00:25:45.830
seeing on some specialized benchmarks.

00:25:48.220 --> 00:25:51.400
We call this the recycling rate.

00:25:51.400 --> 00:25:58.200
This is the rate at which an object
can be allocated and then reclaimed.

00:25:58.520 --> 00:26:05.570
And some of our measurements indicate
that we can get objects in and out of

00:26:05.920 --> 00:26:10.710
the thread local cache a factor of 30
times faster than we were doing before.

00:26:10.710 --> 00:26:10.710
This is going to be huge.

00:26:10.710 --> 00:26:10.710
So if you've--

00:26:14.500 --> 00:26:19.200
Thank you.

00:26:19.200 --> 00:26:22.490
And thank you to Blaine Garst and
Josh Benke for working so hard on it.

00:26:23.760 --> 00:26:31.790
If you had the excuse of performance,
"Ah, garbage collection is too slow,"

00:26:31.790 --> 00:26:31.790
we hope to prove you wrong and
hope you'll prove us right.

00:26:34.260 --> 00:26:37.870
So now let's get into some nuts
and bolts using garbage collection.

00:26:37.870 --> 00:26:43.530
If you haven't done it before,
this is how you do it.

00:26:43.760 --> 00:26:46.700
You turn it on,
you opt in to garbage collection,

00:26:46.710 --> 00:26:52.080
you go into Xcode,
you make a new project,

00:26:52.170 --> 00:26:55.380
and if you're just writing
an app from scratch,

00:26:55.380 --> 00:26:55.380
just turn it on.

00:26:56.540 --> 00:27:07.990
Type in "garbage collection" in
the search box in the Preferences

00:27:07.990 --> 00:27:09.260
Project Inspector and choose
"Required." Required is the

00:27:09.260 --> 00:27:09.260
recommended choice for applications.

00:27:09.740 --> 00:27:19.270
Supported allows you to write a
framework that can actually run

00:27:19.270 --> 00:27:21.530
in either garbage collected mode
or non-garbage collected mode.

00:27:21.530 --> 00:27:21.530
In my demo, I'm going to show you an
example of such a framework.

00:27:25.430 --> 00:27:28.410
So here's the hello world of
garbage collecting programs.

00:27:28.720 --> 00:27:34.000
If you've turned everything on correctly,
one checkbox.

00:27:34.630 --> 00:27:43.860
Then this program will print "Hello,
Garbage Collector" because

00:27:43.860 --> 00:27:47.590
the NSGarbageCollector class
is the Foundation interface

00:27:47.590 --> 00:27:47.590
to the garbage collector,
returns nil if the garbage

00:27:47.590 --> 00:27:47.590
collector mode is not turned on.

00:27:51.080 --> 00:27:59.310
So now I'm going to talk about
a few design patterns that

00:27:59.310 --> 00:27:59.310
garbage collection influences,
garbage collection affects.

00:28:00.230 --> 00:28:03.790
First one is the venerable
accessor method pattern.

00:28:03.900 --> 00:28:04.830
Set get methods.

00:28:04.970 --> 00:28:06.540
Everybody does them.

00:28:06.540 --> 00:28:07.900
Nobody likes them.

00:28:08.160 --> 00:28:10.750
But they are a fact of life.

00:28:11.020 --> 00:28:14.650
When you write one using retain-release,
you have to follow something that

00:28:14.650 --> 00:28:16.200
looks roughly like this pattern.

00:28:16.400 --> 00:28:19.790
This is the recommended
pattern we all follow.

00:28:20.550 --> 00:28:25.340
You have to make sure that when you
are changing a value that the value is,

00:28:25.420 --> 00:28:29.320
in fact, a new value,
then it's safe to call release on the

00:28:29.320 --> 00:28:31.940
old value and call retain on the new.

00:28:32.120 --> 00:28:35.120
The getter method uses
the auto-release pattern,

00:28:35.120 --> 00:28:36.840
retain auto-release.

00:28:37.020 --> 00:28:43.690
That guarantees that the object
will stay live with respect to the

00:28:43.690 --> 00:28:43.690
current thread's auto-release pool.

00:28:45.330 --> 00:28:53.450
When you write it in garbage collection,
if you've written any Java code,

00:28:53.450 --> 00:28:53.450
this is how you write it in Java.

00:28:53.450 --> 00:28:53.450
Just get set.

00:28:54.590 --> 00:29:05.060
All that ownership,
transfer of ownership logic that we

00:29:05.060 --> 00:29:05.690
had to do before is now nicely tucked
away in the runtime system behind

00:29:05.690 --> 00:29:05.690
being done by the write barriers.

00:29:08.060 --> 00:29:17.750
Now for extra credit,
not so much extra credit these days with

00:29:17.750 --> 00:29:17.750
so many cores around and needing to write
lots and lots of threads in our programs.

00:29:18.770 --> 00:29:20.400
To write your accessor
methods thread safe,

00:29:20.400 --> 00:29:24.330
you've got to use some
sort of critical section.

00:29:24.310 --> 00:29:33.720
Wrap the code that we did
before in the critical section.

00:29:33.850 --> 00:29:35.300
Same basic idea,
but now this is the thread-safe version.

00:29:35.300 --> 00:29:35.300
Well, guess what?

00:29:35.300 --> 00:29:35.300
Under Garbage Collection, you're done.

00:29:38.410 --> 00:29:43.400
Another thing that is very
problematic in reference-counted code,

00:29:43.400 --> 00:29:45.490
retain-release, is the cycle.

00:29:45.490 --> 00:29:47.140
The cycle is a bugaboo.

00:29:47.140 --> 00:29:51.730
You can't handle cycles cleanly
in reference-counted code.

00:29:51.870 --> 00:29:56.390
This is why our frameworks take such
great pains to use what are called

00:29:56.390 --> 00:29:59.530
non-retained references and to advertise.

00:29:59.530 --> 00:30:01.270
You have to read the doc.

00:30:01.320 --> 00:30:04.570
You have to know,
"When I put this object there,

00:30:04.570 --> 00:30:06.200
I better worry about taking
it out when I'm done."

00:30:07.080 --> 00:30:08.660
So why?

00:30:08.660 --> 00:30:10.730
Because here's an example of a cycle.

00:30:10.900 --> 00:30:14.730
We have a pointer that's pointing
to one of the elements of the cycle

00:30:14.730 --> 00:30:16.900
of this circularly linked list.

00:30:17.120 --> 00:30:23.780
And that object has
retained count of two.

00:30:23.840 --> 00:30:25.130
We get rid of it.

00:30:25.130 --> 00:30:25.130
Its retained count goes to one.

00:30:25.130 --> 00:30:25.130
Now the whole thing is a leak.

00:30:27.680 --> 00:30:32.960
Under garbage collection,
objects have a retain count,

00:30:32.990 --> 00:30:38.440
but garbage collected objects,
the retain count is zero.

00:30:38.440 --> 00:30:44.930
We have this retain count as a
backward compatible way of interacting

00:30:44.930 --> 00:30:50.250
with core Foundation objects,
but Cocoa objects don't use it.

00:30:50.250 --> 00:30:50.250
They don't even allocate any space
for it other than a couple of bits.

00:30:51.120 --> 00:30:54.240
However, you can use that retain
count if you need to.

00:30:54.320 --> 00:30:56.960
You can call cf.retain on a Cocoa object.

00:30:56.960 --> 00:31:00.160
You do that if you're going
to store that pointer.

00:31:00.160 --> 00:31:03.280
Remember I said the garbage collector
doesn't look in the malloc zone.

00:31:03.280 --> 00:31:11.790
But if you have some malloc data
structures and you just need to put

00:31:11.790 --> 00:31:11.790
that object there and hold on to it,
you can call cf.retain on it.

00:31:13.990 --> 00:31:17.960
When you get rid of that, though,
that object's retain

00:31:17.960 --> 00:31:21.280
count will go to zero,
and garbage collector

00:31:21.280 --> 00:31:23.460
tosses everything in mass.

00:31:23.460 --> 00:31:24.660
No problem.

00:31:24.750 --> 00:31:28.610
Okay, the next thing I want to
talk about is nib loading.

00:31:30.220 --> 00:31:31.560
So nibs are these files.

00:31:31.560 --> 00:31:32.830
They contain user interfaces.

00:31:32.830 --> 00:31:33.600
We all know them.

00:31:33.600 --> 00:31:34.620
We all love them.

00:31:34.870 --> 00:31:38.610
They work a little bit differently
under garbage collected code.

00:31:38.960 --> 00:31:42.800
So here's a nib that has
one top-level object in it.

00:31:42.830 --> 00:31:45.170
It's a HUD panel.

00:31:47.070 --> 00:31:49.620
Under retain release,
I have a simple program

00:31:49.620 --> 00:31:51.330
that has a button,
test.

00:31:51.490 --> 00:31:55.010
When you click that button,
the window pops up.

00:31:55.140 --> 00:31:57.430
It just loaded that nib.

00:31:58.150 --> 00:32:01.000
Do it again, another one comes up.

00:32:01.260 --> 00:32:01.910
Third time.

00:32:01.910 --> 00:32:05.900
We get three and we see that
really nice alpha blended effect.

00:32:06.010 --> 00:32:07.670
Ooh.

00:32:08.170 --> 00:32:09.310
OK.

00:32:09.310 --> 00:32:11.310
Under Garbage Collection,
run the same program.

00:32:11.310 --> 00:32:11.310
We recompiled it.

00:32:12.900 --> 00:32:15.240
Wait a second, where did that window go?

00:32:15.280 --> 00:32:18.590
Do it again, third time,

00:32:19.810 --> 00:32:21.660
The window comes up and it goes away.

00:32:21.750 --> 00:32:23.380
Window comes up, it goes away.

00:32:23.500 --> 00:32:25.200
What's happening?

00:32:28.940 --> 00:32:34.220
Under garbage, under retain release code,
top level objects by default leak.

00:32:34.220 --> 00:32:37.160
They come up,
they have a retain count of one,

00:32:37.670 --> 00:32:39.010
nobody's holding onto them.

00:32:39.440 --> 00:32:41.120
They stay around.

00:32:42.550 --> 00:32:44.790
Under GC, they go away.

00:32:44.970 --> 00:32:53.370
So if you're creating objects whose
sole side effect is to set something up,

00:32:53.370 --> 00:32:53.370
set some preferences, do whatever,

00:32:53.960 --> 00:32:57.300
And they would leak by default
in reference-counted code.

00:32:57.550 --> 00:32:58.920
The GC collects them.

00:32:58.930 --> 00:33:02.470
So you have to be aware of that,
but mostly just worry about

00:33:02.470 --> 00:33:05.140
connecting your objects with outlets.

00:33:05.200 --> 00:33:09.590
I had one particular case
where I needed to create some

00:33:09.650 --> 00:33:14.740
objects that wrap some streams,
and the only way I could keep

00:33:14.740 --> 00:33:20.140
them live was by storing my object
self into a global variable.

00:33:20.140 --> 00:33:20.200
I had to do that under
GC to keep it rooted.

00:33:23.670 --> 00:33:25.470
Another application
of garbage collection,

00:33:25.470 --> 00:33:31.660
now this gets back into
the weak references system,

00:33:31.660 --> 00:33:31.660
is called weak caching.

00:33:32.090 --> 00:33:37.380
So say we have an application that
deals in lots and lots of images.

00:33:37.380 --> 00:33:41.870
It could be a screen saver bouncing
images around and it's displaying

00:33:41.870 --> 00:33:46.070
them at various scale sizes or
something where the performance of

00:33:46.160 --> 00:33:48.670
rendering each frame is critical.

00:33:48.860 --> 00:33:57.020
So we don't want to let the
graphic system scale the images,

00:33:57.020 --> 00:33:57.020
we want to pre-scale the images.

00:33:57.480 --> 00:34:04.840
So we have a set of scaled images that
get created one by one and held onto.

00:34:04.910 --> 00:34:07.460
But eventually,
if we run through lots and lots of scale

00:34:07.460 --> 00:34:10.440
sizes with lots and lots of images,
we might run out of memory.

00:34:10.520 --> 00:34:11.240
How do we get rid of them?

00:34:11.380 --> 00:34:16.540
How do we know to get rid of them?

00:34:16.540 --> 00:34:16.910
Well, the weak reference system can
give us a handy way to do that.

00:34:17.780 --> 00:34:22.540
Here's a class called an Image Scaler,
and it has two instance variables,

00:34:22.540 --> 00:34:27.100
an image that we want to get
various scaled copies of,

00:34:27.690 --> 00:34:31.600
And a map table that
will act as our cache.

00:34:31.600 --> 00:34:32.600
So it's real simple.

00:34:32.600 --> 00:34:37.580
We create one with an image,
and we call the scaled image

00:34:37.580 --> 00:34:41.290
method specifying a size,
an NS size.

00:34:42.670 --> 00:34:47.660
So this method creates the map
table using a special method,

00:34:47.660 --> 00:34:50.740
Map Table with Strong to Weak Objects.

00:34:50.790 --> 00:34:54.280
Now,
in case maybe you're not aware of this,

00:34:54.280 --> 00:34:59.000
but NSMapTable used to be a
C-based API from the olden days.

00:34:59.000 --> 00:35:01.710
And in Leopard, we enhanced it.

00:35:01.770 --> 00:35:03.520
We gave it a lot more power.

00:35:03.520 --> 00:35:05.860
We turned it into an
object for one thing.

00:35:05.860 --> 00:35:09.660
We also made it a sort of
dictionary Swiss Army knife.

00:35:09.660 --> 00:35:13.480
You can configure these
things in so many ways,

00:35:13.520 --> 00:35:15.860
I don't even understand
all the combinations.

00:35:15.860 --> 00:35:18.360
But this one is particularly useful.

00:35:18.780 --> 00:35:20.200
Strong to Weak Objects.

00:35:20.430 --> 00:35:23.360
The strong refers to the keys
that we're going to use in the

00:35:23.360 --> 00:35:25.860
dictionary and the map table.

00:35:26.080 --> 00:35:29.190
And weak refers to the values
that we want to hold onto,

00:35:29.190 --> 00:35:31.430
in this case, the scaled images.

00:35:36.220 --> 00:35:39.130
So when the scaled
image method is called,

00:35:39.300 --> 00:35:45.570
we take that size that was
specified that we're asking for,

00:35:45.570 --> 00:35:45.570
we wrap it in an NS value,
and that will be our key.

00:35:46.040 --> 00:35:58.260
We then check to see if the
cache contains that copy of it.

00:35:58.260 --> 00:35:59.370
If not, then we make a new copy,
we scale that image,

00:35:59.370 --> 00:35:59.370
and store it in our cache.

00:36:00.090 --> 00:36:04.830
Now, what's great about this,
for as many clients as happen

00:36:04.880 --> 00:36:09.200
to be using this image,
this scaled image, at the same time,

00:36:09.350 --> 00:36:13.310
think threads or multiple calls to it,

00:36:13.580 --> 00:36:21.490
These images, these scaled copies,
will all be shared,

00:36:21.490 --> 00:36:28.600
and then when all the threads
that are done with those images

00:36:28.600 --> 00:36:28.600
go away and release those images,
that copy will go away.

00:36:28.600 --> 00:36:28.600
So the cache does this for us for free.

00:36:32.190 --> 00:36:36.010
So let's talk about finalization
a little bit more in depth now.

00:36:36.350 --> 00:36:39.070
Finalization is something

00:36:39.800 --> 00:36:45.200
[Transcript missing]

00:36:45.690 --> 00:36:54.170
For all the reasons I said before,
the caveats that were stated,

00:36:54.170 --> 00:36:54.170
it's tricky.

00:36:54.170 --> 00:36:54.170
You've got to make sure your
finalizers are thread safe.

00:36:54.820 --> 00:37:02.300
So it's a better idea
to look at your objects,

00:37:02.300 --> 00:37:06.790
design your classes with states in mind,
the allowed states that the

00:37:06.790 --> 00:37:06.790
object should go through.

00:37:06.790 --> 00:37:06.790
So think of it as a state machine.

00:37:07.480 --> 00:37:11.760
When an object is done,
prefer an explicit shutdown.

00:37:11.900 --> 00:37:15.580
A great example of this is a
file or a network connection,

00:37:15.580 --> 00:37:20.140
something that is holding onto
resources that are fairly costly.

00:37:20.210 --> 00:37:23.140
You should just design
that right into your API.

00:37:26.100 --> 00:37:31.760
So finalization is there
primarily as a backstop.

00:37:31.850 --> 00:37:35.810
One very great advantage of a
garbage collected system over

00:37:35.950 --> 00:37:40.340
a non-garbage collected system
is in the face of exceptions.

00:37:40.430 --> 00:37:46.340
We don't have fancy stack
destructors where objects will be

00:37:46.340 --> 00:37:49.570
torn down as the stack unwinds.

00:37:49.570 --> 00:37:55.430
We do have an exception system
that is compatible with that.

00:37:55.730 --> 00:38:00.360
We actually don't need it under
garbage collected code because

00:38:00.450 --> 00:38:07.180
the finalizers of the objects that
might have been allocated along

00:38:07.180 --> 00:38:07.180
the way while you were throwing--
before you threw the exception,

00:38:07.950 --> 00:38:09.080
will get invoked.

00:38:09.440 --> 00:38:12.040
So the finalizers are
there to sort of clean up,

00:38:12.040 --> 00:38:16.940
make sure things aren't left dangling,
resources are not clogging up the system.

00:38:16.950 --> 00:38:19.670
That's a great use of a finalizer.

00:38:21.780 --> 00:38:26.940
So, concrete example,
some sort of simulation.

00:38:26.950 --> 00:38:29.680
You've got an object
that goes into a mode.

00:38:29.680 --> 00:38:31.460
It is running its engine.

00:38:31.460 --> 00:38:35.940
Maybe it's doing a physics simulation
or it's doing an animation.

00:38:35.940 --> 00:38:40.610
Maybe there's a thread
or a timer behind it.

00:38:40.610 --> 00:38:46.850
Make sure that that object has an
API to tear it down gracefully.

00:38:46.850 --> 00:38:46.850
Please don't leave the motor running.

00:38:51.650 --> 00:38:55.000
So how do I get rid of a finalize?

00:38:55.090 --> 00:39:00.780
Here's a case where we have a class that
holds onto a buffer that's been malloc'd.

00:39:01.230 --> 00:39:05.230
And in this case,
it's technically correct.

00:39:05.240 --> 00:39:10.600
We need a finalize method.

00:39:10.600 --> 00:39:10.600
If we don't have one, that buffer,
it's going to leak.

00:39:13.130 --> 00:39:14.050
But we can change this.

00:39:14.170 --> 00:39:16.080
There's a Foundation alternative to it.

00:39:16.150 --> 00:39:17.950
It's called NSMutableData.

00:39:17.950 --> 00:39:21.690
The NSMutableData actually is
even better than a malloc-free

00:39:21.690 --> 00:39:25.740
because it's a resizable buffer,
a resizable block of memory.

00:39:25.930 --> 00:39:27.430
This is all very simple stuff.

00:39:27.540 --> 00:39:33.710
But if you just simply switch
from that to the other,

00:39:33.710 --> 00:39:35.050
your finalized method goes to nothing.

00:39:35.050 --> 00:39:35.050
In fact, you don't even need one.

00:39:41.650 --> 00:39:46.750
There are a number of systems,
subsystems in Cocoa and

00:39:46.750 --> 00:39:48.620
things you can use.

00:39:49.010 --> 00:39:52.000
And this is just a
short list of examples.

00:39:52.120 --> 00:39:56.780
These are the kinds of things that
really require you to disconnect them.

00:39:56.930 --> 00:40:00.400
You can't just simply, in most cases,
leave them to the garbage

00:40:00.540 --> 00:40:02.010
collector to clean up.

00:40:02.060 --> 00:40:04.000
You bring up a window.

00:40:04.090 --> 00:40:05.920
Well, except for that case
I showed you with the nibs,

00:40:06.260 --> 00:40:09.260
panels will disappear if
they're garbage collected.

00:40:09.500 --> 00:40:10.500
But windows do not.

00:40:10.570 --> 00:40:12.050
Windows are more special.

00:40:12.060 --> 00:40:15.060
They get attached to the user
interface of your program.

00:40:15.060 --> 00:40:18.060
So the user will close a window.

00:40:18.060 --> 00:40:21.060
That's a very active operation.

00:40:21.060 --> 00:40:24.060
Timers, on the other hand, well,
they're not visible.

00:40:24.060 --> 00:40:26.940
Timers have to be torn down,
just like in reference-counted code.

00:40:27.060 --> 00:40:31.050
So these are the kinds of things that
you will still have to think about.

00:40:31.060 --> 00:40:32.060
Garbage collection is a very
important part of your design.

00:40:32.090 --> 00:40:35.050
Garbage collection won't solve
all these problems for you.

00:40:35.150 --> 00:40:37.060
Key value observation is another one.

00:40:37.060 --> 00:40:39.440
If you happen to create
an observer on an object,

00:40:39.440 --> 00:40:43.250
don't let the object that's being
observed garbage collect while the

00:40:43.390 --> 00:40:46.060
key value observation is in force.

00:40:46.060 --> 00:40:47.860
Most of the time you're not
going to have to think about

00:40:47.860 --> 00:40:49.020
this if you're using bindings.

00:40:49.040 --> 00:40:51.830
The binding system takes care of it.

00:40:52.520 --> 00:40:56.230
The last one is the notification center.

00:40:56.360 --> 00:40:59.300
The notification center
uses weak references.

00:40:59.390 --> 00:41:02.950
So, you don't have to write a finalized
method if what you--all you need to

00:41:02.960 --> 00:41:08.540
do is unregister your object from,
uh, the notification center.

00:41:08.720 --> 00:41:11.060
However,
you do want to make sure you don't

00:41:11.060 --> 00:41:15.840
leave your object in a bad state and
still attach to the notification center.

00:41:15.940 --> 00:41:20.380
So, there's a case where maybe as part
of your object's explicit shutdown,

00:41:20.510 --> 00:41:22.460
you should take it out of
the notification center.

00:41:22.570 --> 00:41:23.580
But you don't have to.

00:41:23.790 --> 00:41:27.340
It will be removed for you.

00:41:31.100 --> 00:41:33.700
I don't know if you've
seen this little guy.

00:41:33.770 --> 00:41:36.600
That's the logo for the mascot of GDB.

00:41:36.600 --> 00:41:40.150
Fish, I can't remember the name of it,
it's a kind of fish that lives

00:41:40.150 --> 00:41:45.240
in shallow water and squirts
and eats low-hanging bugs.

00:41:45.340 --> 00:41:48.640
Just thought that was interesting.

00:41:48.640 --> 00:41:52.090
We've added support to GDB for
doing real low-level tasks having

00:41:52.270 --> 00:41:54.710
to do with garbage collection.

00:41:54.740 --> 00:42:00.320
So one of the facilities is you can now,
within GDB, if a program has crashed,

00:42:00.320 --> 00:42:05.970
usually that's why you're in GDB,
you can look at the total history

00:42:05.970 --> 00:42:08.780
of an object's allocation.

00:42:08.780 --> 00:42:12.520
That is, all of the stack logs,
all the stack crawls of an object,

00:42:12.520 --> 00:42:14.860
when it was allocated and deallocated.

00:42:14.860 --> 00:42:19.860
This facility is invaluable when
debugging garbage collection problems.

00:42:20.130 --> 00:42:25.780
If you forgot to create
a strong reference,

00:42:25.780 --> 00:42:35.280
you used a void star to hold onto a
pointer to a garbage collected object,

00:42:35.340 --> 00:42:36.760
and it goes away,
you can use this facility to

00:42:36.760 --> 00:42:36.760
find out who last allocated it
and when did it get deallocated.

00:42:37.640 --> 00:42:41.260
Another facility is you want to know,
well, why is this object still here?

00:42:41.460 --> 00:42:42.390
It should be gone.

00:42:42.390 --> 00:42:44.880
You can ask GDB,
there's a command to ask it,

00:42:44.880 --> 00:42:48.930
what are all the objects currently
referencing this object directly?

00:42:49.030 --> 00:42:57.100
And there's also a way to find out
what global variables and along what

00:42:57.100 --> 00:43:01.300
path is my object being referenced?

00:43:01.300 --> 00:43:01.300
We call that root tracing.

00:43:01.300 --> 00:43:01.300
So that's in GDB.

00:43:03.450 --> 00:43:13.180
The next tool we provide,
the next level up the chain,

00:43:13.180 --> 00:43:14.910
a hierarchy of high levelness,
is the GC instrument in the Instruments

00:43:14.910 --> 00:43:14.910
program you've probably heard about.

00:43:15.680 --> 00:43:24.110
The GC instrument is a sort of a
version of the object alloc tool with

00:43:24.390 --> 00:43:31.970
Knowledge, customized knowledge for
the garbage collector.

00:43:31.970 --> 00:43:31.970
It can also show you
the same information.

00:43:31.970 --> 00:43:31.970
It can show you

00:43:32.200 --> 00:43:38.350
What objects are referencing your
objects' direct chains look like,

00:43:38.350 --> 00:43:44.890
and you can look at--
peruse the stack histories.

00:43:44.890 --> 00:43:44.890
It's a good tool to try to
understand your program.

00:43:44.890 --> 00:43:44.890
And furthermore, it can actually show you

00:43:46.190 --> 00:43:49.950
What are all the objects
currently in your program?

00:43:49.950 --> 00:43:52.860
You can search for them by type,
search for them by pointer.

00:43:53.070 --> 00:43:57.810
So it's a great visualization tool,
and I'm going to be demonstrating

00:43:57.810 --> 00:43:57.810
that in a few minutes.

00:43:58.440 --> 00:44:02.360
Finally, there's this cool little open
source tool called Fscript.

00:44:02.460 --> 00:44:07.900
And it is really handy to look at
your program while it's running,

00:44:07.900 --> 00:44:12.090
interact with it,
and sort of do what-if type queries.

00:44:12.100 --> 00:44:13.410
You know, like, well,
what if I got rid of

00:44:13.410 --> 00:44:14.730
this pointer right here,
right now?

00:44:14.740 --> 00:44:15.250
What would happen?

00:44:15.260 --> 00:44:19.100
So that's a nifty little tool.

00:44:19.100 --> 00:44:22.700
It's now garbage collection compatible,
and it's packaged as a framework.

00:44:22.700 --> 00:44:26.520
And it is a framework that
works in both GC and non-GC.

00:44:26.860 --> 00:44:29.530
So it's a good example of that if
you're interested in doing that.

00:44:29.600 --> 00:44:35.560
So let's give this a whirl.

00:44:43.370 --> 00:44:50.080
So I have instruments set up right
now to run a demo application.

00:44:57.600 --> 00:45:04.700
One of the things we can do is
pause it and take a look at--

00:45:06.700 --> 00:45:11.360
How big our heap size is,
how many objects are around in

00:45:11.400 --> 00:45:14.500
terms of overall memory size,

00:45:15.370 --> 00:45:23.000
And the top bar in this upper
display is the amount of virtual

00:45:23.160 --> 00:45:27.280
memory set aside for the program,
whereas the other, the tiny one,

00:45:27.280 --> 00:45:28.700
is how much is actually in use.

00:45:28.920 --> 00:45:31.420
It's a tiny little program.

00:45:42.430 --> 00:45:44.040
Unpause.

00:45:44.120 --> 00:45:49.630
So this is a tiny little application.

00:45:49.630 --> 00:45:49.630
It's very similar to the nib
loader that I showed you before.

00:45:50.120 --> 00:45:52.810
It has two buttons,
one that creates a panel,

00:45:52.810 --> 00:45:54.620
one that creates a window.

00:45:54.760 --> 00:45:57.930
The keep checkbox says,
should we hold a reference to

00:45:58.020 --> 00:46:00.020
the object after we allocate it?

00:46:01.130 --> 00:46:04.140
So if I make one,

00:46:05.930 --> 00:46:08.960
Move it around, make another one.

00:46:09.020 --> 00:46:11.140
First one, garbage collects.

00:46:11.140 --> 00:46:12.290
Goes away.

00:46:12.810 --> 00:46:16.740
Do it again just to prove
that it wasn't a fluke.

00:46:16.890 --> 00:46:18.200
Second one goes away.

00:46:18.340 --> 00:46:20.640
Uncheck the checkbox.

00:46:20.820 --> 00:46:21.430
Goes away.

00:46:21.540 --> 00:46:21.680
Great.

00:46:21.800 --> 00:46:25.340
That's all that's going to plan.

00:46:25.460 --> 00:46:29.720
Now, we create an NSWindow.

00:46:32.980 --> 00:46:33.900
Create another Ennis window.

00:46:33.900 --> 00:46:38.650
Another Ennis window.

00:46:39.060 --> 00:46:45.010
None of the objects
are garbage collecting.

00:46:45.010 --> 00:46:45.010
What's going on?

00:46:45.010 --> 00:46:45.010
Oh, I know.

00:46:45.010 --> 00:46:45.010
It's my checkbox.

00:46:45.010 --> 00:46:45.010
Let me uncheck it.

00:46:45.310 --> 00:46:46.190
Go away, please.

00:46:46.200 --> 00:46:51.400
Go away, go away, go away, go away.

00:46:51.400 --> 00:46:51.400
They're not going away.

00:46:51.400 --> 00:46:51.400
Why aren't they going away?

00:46:54.290 --> 00:46:55.300
So let me simplify it.

00:46:55.300 --> 00:47:03.700
Well, I happen to know that--
let me get rid of that one,

00:47:03.700 --> 00:47:05.390
make another one.

00:47:06.680 --> 00:47:12.320
To show that this object is actually
still referenced by my program,

00:47:12.320 --> 00:47:15.310
I want to pop up an F script window.

00:47:15.420 --> 00:47:21.310
In F script window, I have this object C,
which is my controller.

00:47:21.480 --> 00:47:24.310
And its window field right now is null,
and yet the object's

00:47:24.350 --> 00:47:26.510
still staying around.

00:47:31.000 --> 00:47:34.240
A window, not a HUD.

00:47:34.240 --> 00:47:35.160
There.

00:47:35.170 --> 00:47:36.690
Now look at it again.

00:47:36.930 --> 00:47:37.580
All right.

00:47:37.580 --> 00:47:41.610
So this object is the thing
that's holding on to my window.

00:47:41.700 --> 00:47:43.870
F script lets me look into that.

00:47:43.870 --> 00:47:45.300
I could do C window.

00:47:45.590 --> 00:47:48.000
I could do C set window.

00:47:48.000 --> 00:47:49.430
No.

00:47:50.310 --> 00:47:52.690
Still, the object's not going away.

00:47:53.810 --> 00:47:57.130
All right, I know it was this address,
so let's pop into instruments

00:47:57.130 --> 00:47:59.040
and see what's going on.

00:47:59.160 --> 00:48:02.190
First thing I have to
do is take a snapshot.

00:48:03.330 --> 00:48:05.240
You can set it to periodically snapshot.

00:48:05.240 --> 00:48:08.950
I'm just having it snapshot
on demand right now.

00:48:10.530 --> 00:48:22.590
Now, I can have it show me all the
objects in the heap currently,

00:48:22.590 --> 00:48:22.590
lots and lots of strings.

00:48:22.590 --> 00:48:22.590
And I can paste in

00:48:24.700 --> 00:48:25.700
Copy.

00:48:25.700 --> 00:48:29.460
Paste in the pointer.

00:48:29.460 --> 00:48:31.540
All right.

00:48:31.540 --> 00:48:31.540
There's the NSWindow.

00:48:35.390 --> 00:48:38.740
So we have this block list.

00:48:38.810 --> 00:48:41.660
We have this one object
that's found in it.

00:48:41.680 --> 00:48:43.880
There's a detail view over
here that gives me some

00:48:43.970 --> 00:48:45.790
information about the object.

00:48:45.910 --> 00:48:52.300
Here is the stack crawl of
when the object was allocated.

00:48:52.300 --> 00:48:52.920
Makes sense.

00:48:53.000 --> 00:48:56.450
I recognize that code.

00:48:56.450 --> 00:48:59.290
That's my code.

00:48:59.290 --> 00:48:59.610
PCB controller, blah, blah, blah.

00:49:00.710 --> 00:49:06.190
The other thing it can tell us over here
is what's holding on to this window.

00:49:06.340 --> 00:49:09.580
Huh, it's telling me that the
NSApplication object is somehow

00:49:09.580 --> 00:49:11.590
holding on to the window.

00:49:11.790 --> 00:49:16.530
I can pop back up to
F script and say NSApp.

00:49:19.990 --> 00:49:26.170
In fact, there are two windows,
but I don't really know

00:49:26.170 --> 00:49:26.170
which window is which,
so I want to figure that out.

00:49:26.920 --> 00:49:31.760
So I can ask it using this handy send a
message to all the elements of an array.

00:49:32.030 --> 00:49:32.730
That's really handy.

00:49:32.790 --> 00:49:35.360
I wish GDB had that.

00:49:35.870 --> 00:49:39.190
This basically lets me easily
positionally identify the

00:49:39.190 --> 00:49:41.330
windows that I'm interested in.

00:49:41.410 --> 00:49:42.340
So what the heck?

00:49:42.340 --> 00:49:44.940
Why is the application
still holding on to it?

00:49:45.000 --> 00:49:48.990
I happen to know that the
NS app is supposed to only have

00:49:49.040 --> 00:49:50.620
weak references to windows.

00:49:50.730 --> 00:49:52.880
So why is it staying around?

00:49:52.960 --> 00:49:59.950
Well, we can dive into this object
if we go back to instruments,

00:49:59.950 --> 00:50:01.870
and it can tell us

00:50:02.560 --> 00:50:10.750
Exactly how the object is connected.

00:50:10.750 --> 00:50:10.750
This display over here gives me a path.

00:50:11.780 --> 00:50:23.410
From the NS application object
all the way to the NS window.

00:50:23.410 --> 00:50:23.410
So it tells me, oh,
it's connected to the window menu.

00:50:25.520 --> 00:50:26.840
There it is.

00:50:26.990 --> 00:50:27.920
Bring it back up.

00:50:27.920 --> 00:50:30.640
So it's still alive because of that.

00:50:33.400 --> 00:50:36.900
If I close the window, it disappears.

00:50:36.970 --> 00:50:40.080
Windows take care of their own lifetime.

00:50:41.810 --> 00:50:46.000
So Instruments was able to tell me it's
basically communicating with my process.

00:50:46.120 --> 00:50:52.200
It's able to enumerate all
of the objects in the system,

00:50:52.260 --> 00:50:59.100
and it's able to find out how
they're connected together.

00:50:59.100 --> 00:50:59.100
All right.

00:50:59.100 --> 00:50:59.100
Demo, demo.

00:51:03.120 --> 00:51:08.940
So we have one more session where
we're going to be talking about

00:51:09.230 --> 00:51:12.180
advanced topics in garbage collection.

00:51:12.180 --> 00:51:16.520
If you're interested in learning
more and more about that,

00:51:16.550 --> 00:51:19.950
we talk about how core
Foundation interacts,

00:51:19.950 --> 00:51:23.500
how to do dual-mode frameworks,
and porting.

00:51:23.500 --> 00:51:26.720
Maybe you want to port
a large body of code.

00:51:26.720 --> 00:51:31.440
And then some more about some
of the lower-level tool support.

00:51:31.440 --> 00:51:32.750
So in summary,

00:51:40.130 --> 00:51:44.640
Garbage collection is like having
your own personal accountant.

00:51:44.670 --> 00:51:45.720
He's there at your side.

00:51:46.010 --> 00:51:47.060
He's doing your bookkeeping.

00:51:47.130 --> 00:51:48.900
He's balancing your checkbook.

00:51:49.020 --> 00:51:54.380
He's making sure you deliver
your project on time.

00:51:54.780 --> 00:51:57.180
You don't have to worry
about bookkeeping.

00:51:58.830 --> 00:52:02.000
It's also checking to make sure
the amount of memory you're

00:52:02.000 --> 00:52:06.110
using is staying under control,
so you're going to be under budget.

00:52:06.270 --> 00:52:15.400
And finally, in Snow Leopard,
with a thread local collector,

00:52:15.440 --> 00:52:16.100
you have effectively a team of
accountants all working on your

00:52:16.100 --> 00:52:16.100
behalf and at your service.

00:52:18.240 --> 00:52:20.850
There's another session tomorrow,
as I said.

00:52:20.920 --> 00:52:24.400
Greg Parker's going to be giving a talk,
and we already had a session yesterday.

00:52:24.400 --> 00:52:26.340
Thank you very much.
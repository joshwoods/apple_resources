WEBVTT

00:00:20.250 --> 00:00:23.990
And I also work on some of the
internal plug-ins that we ship.

00:00:24.130 --> 00:00:28.090
The FxPlug community has really
been growing by leaps and bounds

00:00:28.120 --> 00:00:29.140
over the past several years.

00:00:29.230 --> 00:00:32.650
We found that we have everything
from one-person shops to large

00:00:32.650 --> 00:00:34.600
companies writing FxPlugs.

00:00:34.600 --> 00:00:36.690
And they encompass
everything from hobbyists to

00:00:36.690 --> 00:00:38.170
Oscar-award-winning developers.

00:00:38.200 --> 00:00:41.400
You can see some of their effects
in movies like Harry Potter,

00:00:41.400 --> 00:00:42.690
Lord of the Rings, and things like that.

00:00:42.750 --> 00:00:44.200
So you're in good company.

00:00:44.240 --> 00:00:47.840
Plus, it's just really kick-ass to
write plug-ins for a living,

00:00:47.840 --> 00:00:48.440
you know?

00:00:48.620 --> 00:00:52.530
So what we're going to talk about
today is what the FxPlug SDK is.

00:00:52.930 --> 00:00:55.600
You'll learn how you can
write FxPlug plug-ins.

00:00:55.660 --> 00:01:01.100
We'll talk about what's new in 1.2.2
and the soon-to-be-released 1.2.3.

00:01:01.140 --> 00:01:04.000
I'll talk about porting your plug-ins
to FxPlug from other architectures.

00:01:04.080 --> 00:01:05.790
So if you've already got
some After Effects plug-ins

00:01:05.800 --> 00:01:09.250
or things like that,
you can bring them over to FxPlug.

00:01:09.370 --> 00:01:11.910
Paul Schneider's going to
come up and talk about working

00:01:11.910 --> 00:01:13.490
with FxPlugs in Final Cut Pro.

00:01:13.510 --> 00:01:15.980
And then Pete Warden's going to
talk about some advanced topics,

00:01:16.020 --> 00:01:17.630
some OpenGL things,
and how to get your things

00:01:17.700 --> 00:01:18.480
running really quickly.

00:01:18.500 --> 00:01:19.780
quickly.

00:01:20.380 --> 00:01:21.960
So what is the FxPlug SDK?

00:01:22.230 --> 00:01:23.980
Well,
it's a visual effects architecture that

00:01:24.070 --> 00:01:28.600
we created at Apple for the Pro apps,
and it's hosted in Motion, Final Cut Pro,

00:01:28.600 --> 00:01:30.340
and Final Cut Express.

00:01:30.380 --> 00:01:33.020
It's Objective-C based,
so if you've been writing Cocoa code

00:01:33.120 --> 00:01:35.720
and Objective-C code already,
you're already familiar

00:01:35.970 --> 00:01:38.580
with how to use it,
and it uses OpenGL for

00:01:38.580 --> 00:01:40.520
extreme performance.

00:01:40.900 --> 00:01:44.040
So why would you want to write an
FX plug versus some other type of plugin?

00:01:44.040 --> 00:01:46.520
The biggest reason is that
we have a million registered

00:01:46.600 --> 00:01:47.840
users of Final Cut Pro.

00:01:47.840 --> 00:01:50.190
We probably have a few
more users than that,

00:01:50.260 --> 00:01:52.740
but registered users is about a million.

00:01:52.740 --> 00:01:56.250
As I said, you can get extreme
performance using OpenGL,

00:01:56.460 --> 00:01:59.740
and most of your plugins can
probably run in real time,

00:01:59.740 --> 00:02:02.180
which your users will really love.

00:02:02.180 --> 00:02:05.480
You produce a universal binary,
works on PowerPC and Intel,

00:02:05.480 --> 00:02:09.580
and that's apparently a new feature
for some other architectures.

00:02:09.580 --> 00:02:12.110
You can have custom UI in
your parameter list,

00:02:12.110 --> 00:02:15.370
so if you want to have, say,
curves or something that we don't supply,

00:02:15.370 --> 00:02:16.640
you can make that yourself.

00:02:16.640 --> 00:02:19.160
You don't have to if you don't want to,
but the option is there.

00:02:19.160 --> 00:02:22.160
And the great thing is that you'll
base it on Cocoa and you can

00:02:22.220 --> 00:02:24.410
build it in Interface Builder.

00:02:24.420 --> 00:02:25.420
Paul will talk about that a little bit.

00:02:25.420 --> 00:02:29.360
So you can really
rapidly develop nice UIs.

00:02:29.360 --> 00:02:34.520
You can get pixels that are in
RGBA format or YCBCR with alpha format.

00:02:34.520 --> 00:02:35.640
You can get floating point pixels.

00:02:35.640 --> 00:02:38.220
So if you're working with extended
dynamic range and you need to,

00:02:38.220 --> 00:02:40.420
you know,
avoid clamping and things like that,

00:02:40.420 --> 00:02:41.600
you have that option.

00:02:41.600 --> 00:02:44.460
In Motion, you can create onscreen
controls using OpenGL,

00:02:44.460 --> 00:02:48.550
and that allows the user to directly
manipulate whatever is on the canvas so

00:02:48.560 --> 00:02:50.890
they don't have to just set parameters.

00:02:50.910 --> 00:02:53.900
They can actually move things
around and things like that.

00:02:53.900 --> 00:02:55.870
And you can also get some 3D
information about where your

00:02:55.870 --> 00:02:58.610
layers are located in space,
where cameras are located,

00:02:58.610 --> 00:02:59.980
things like that.

00:02:59.980 --> 00:03:03.020
So I'm going to go over how
to write an FXPlug plugin.

00:03:03.020 --> 00:03:05.490
We'll talk about how
to create a new file,

00:03:05.510 --> 00:03:09.140
a new project in Xcode,
we'll create some unique IDs to identify.

00:03:09.140 --> 00:03:13.230
We'll write some source code to
create our parameters and render.

00:03:13.420 --> 00:03:15.220
And then we'll build and install.

00:03:15.530 --> 00:03:16.420
And hopefully that goes well.

00:03:16.420 --> 00:03:18.420
We'll test it and then ship it.

00:03:18.420 --> 00:03:19.420
So let's look at this.

00:03:19.420 --> 00:03:22.080
In Xcode, to create a new project,
you go to the File menu

00:03:22.080 --> 00:03:23.420
and select New Project.

00:03:23.420 --> 00:03:25.420
And it brings up the
new project assistant.

00:03:25.450 --> 00:03:29.400
And you can see we've got under the
heading of standard Apple plugins,

00:03:29.400 --> 00:03:30.420
we have FXPlugs.

00:03:30.420 --> 00:03:33.420
And there are three types
of FXPlugs you can write.

00:03:33.420 --> 00:03:34.900
There's the standard,
which is the standard,

00:03:34.900 --> 00:03:37.420
which is the standard,
which is the standard plugin.

00:03:37.420 --> 00:03:38.320
And then there's the standard,
which is the standard,

00:03:38.390 --> 00:03:38.920
which is the standard plugin.

00:03:38.970 --> 00:03:43.220
There's FX generator,
which takes no image input.

00:03:43.220 --> 00:03:45.400
So if you're generating
a pattern of some sort,

00:03:45.400 --> 00:03:47.420
you don't need to modify
an existing image,

00:03:47.420 --> 00:03:50.090
something like a checkerboard or
stripes or a fractal or something,

00:03:50.140 --> 00:03:51.760
you'd create a generator.

00:03:51.760 --> 00:03:53.840
And FX filter takes a single image input.

00:03:53.840 --> 00:03:56.820
So if you're doing a color correction or
a distortion where you take an image and

00:03:56.850 --> 00:03:59.820
you modify it in some way and output it,
that would be a filter.

00:03:59.820 --> 00:04:01.120
And there are FX transitions.

00:04:01.120 --> 00:04:03.360
And these are for moving
between two images.

00:04:03.360 --> 00:04:06.110
So if you want to do a crossfade or
some sort of flying in and flying out,

00:04:06.110 --> 00:04:08.570
that sort of thing,
you'd have a transition.

00:04:08.700 --> 00:04:10.760
So once you choose which
one you want to write,

00:04:10.760 --> 00:04:12.680
it asks you for a name
and where to put it.

00:04:12.730 --> 00:04:15.220
We'll call this my filter.

00:04:15.240 --> 00:04:18.540
And it brings up the source
code and the resources.

00:04:18.610 --> 00:04:21.220
And the first thing you're
going to want to do is open up

00:04:21.270 --> 00:04:23.370
that Info.plist resource file.

00:04:23.380 --> 00:04:26.000
And in there,
you'll find the pro plug plugin list.

00:04:26.000 --> 00:04:29.080
And this is a -- excuse me --
pro plug plugin group list.

00:04:29.080 --> 00:04:33.450
And this is the list of all the groups
that your plugins are going to go into.

00:04:33.510 --> 00:04:35.080
You can have more than
one plugin in a binary.

00:04:35.080 --> 00:04:36.760
In this example, we'll just make one.

00:04:36.760 --> 00:04:38.480
So we only need one group.

00:04:38.480 --> 00:04:40.840
I'm going to call it my filter.

00:04:40.840 --> 00:04:42.700
You can put them into existing groups.

00:04:42.700 --> 00:04:45.620
Like I think we have color
correction and distortion,

00:04:45.620 --> 00:04:47.180
for example, in motion.

00:04:47.180 --> 00:04:48.640
Or you can create your own.

00:04:48.750 --> 00:04:49.700
Most people create their own.

00:04:49.700 --> 00:04:52.220
You might have it named after your
company or named after the particular

00:04:52.220 --> 00:04:54.020
product that you're working on.

00:04:54.020 --> 00:04:56.470
Whiz bang filters 1.0 or whatever.

00:04:56.520 --> 00:04:58.800
But the important thing is
this unique identifier here.

00:04:58.800 --> 00:05:02.430
You generate this UUID,
a universally unique identifier,

00:05:02.560 --> 00:05:05.420
by using the command line tool UUID gen.

00:05:05.420 --> 00:05:07.320
And I'll talk about how to do
that without going out to the

00:05:07.370 --> 00:05:09.260
command line in a little bit.

00:05:09.260 --> 00:05:10.260
But it's a unique number.

00:05:10.260 --> 00:05:12.640
Every time you run the command,
you get a unique number.

00:05:12.670 --> 00:05:15.910
Every other developer who runs
it will get a unique number,

00:05:15.910 --> 00:05:16.350
too.

00:05:17.260 --> 00:05:20.940
So then you find the ProPlug
plugin list in the InfoP list file,

00:05:20.940 --> 00:05:23.450
and this is the list of all the plugins
that are going to be in this binary.

00:05:23.460 --> 00:05:25.220
As I said, in this case,
we just have one,

00:05:25.220 --> 00:05:28.760
and you can see we have keys for
the class name that it corresponds

00:05:28.760 --> 00:05:30.020
with and the display name.

00:05:30.020 --> 00:05:31.260
And you'll notice we have group.

00:05:31.520 --> 00:05:33.750
And again,
this UUID is the same one that we

00:05:33.760 --> 00:05:36.720
just generated on the previous slide,
and this says that this filter

00:05:36.870 --> 00:05:38.820
goes into the group with that UUID.

00:05:38.820 --> 00:05:42.620
And the reason we use IDs instead
of names is because it's potentially

00:05:42.620 --> 00:05:45.940
possible that you might come up with
a name like Cool Filters or something,

00:05:45.940 --> 00:05:48.060
and some other developer
comes up with the same name.

00:05:48.060 --> 00:05:51.110
You want to make sure that
yours go into the right place.

00:05:51.120 --> 00:05:53.260
And likewise,
you need to generate another

00:05:53.260 --> 00:05:55.380
unique ID for your actual plugin.

00:05:55.380 --> 00:06:00.230
So if you have a plugin with one name,
it doesn't conflict with anyone else,

00:06:00.380 --> 00:06:02.180
or if somebody's using a
localized version of the

00:06:02.180 --> 00:06:04.440
app in a different language,
we don't search by name,

00:06:04.440 --> 00:06:05.460
we search by UUID.

00:06:07.400 --> 00:06:10.510
And the easy way to do this is
to write a little script and put

00:06:10.510 --> 00:06:12.260
it in the script menu in Xcode.

00:06:12.260 --> 00:06:14.890
If you look on the right
side of the Xcode menu bar,

00:06:15.070 --> 00:06:18.200
there's a little scroll menu
and that's the script menu.

00:06:18.200 --> 00:06:20.420
If you open that up,
you'll see a bunch of

00:06:20.420 --> 00:06:21.930
scripts that you can run.

00:06:21.930 --> 00:06:24.030
And you can create your own scripts.

00:06:24.030 --> 00:06:26.120
In this case, this is a bin sh script.

00:06:26.260 --> 00:06:29.990
And it's a single command,
echo minus n back tick uuidgen back tick.

00:06:29.990 --> 00:06:34.210
And you can either put this in slash
library slash application support slash

00:06:34.210 --> 00:06:37.270
apple slash developer tool slash scripts.

00:06:37.340 --> 00:06:44.430
Or you can go to the script menu and
I think the bottom item is edit scripts.

00:06:44.540 --> 00:06:46.510
And if you do that,
it will bring up a dialogue right

00:06:46.510 --> 00:06:48.970
in Xcode and you can add new ones
and change the existing ones.

00:06:48.970 --> 00:06:52.100
And once you do that,
you can just select the uuid

00:06:52.140 --> 00:06:55.430
in the Info.plist file and
then from the script menu,

00:06:55.430 --> 00:06:58.250
choose new uuid or whatever you named it.

00:06:58.300 --> 00:07:00.280
And it will replace the one that's there.

00:07:00.280 --> 00:07:02.690
And as you can see,
we put a comment in there that

00:07:02.690 --> 00:07:04.680
says you must change this group ID.

00:07:04.680 --> 00:07:09.570
And there's another one for
the actual plugin ID as well.

00:07:10.130 --> 00:07:11.840
Okay, so then you're going to have
to write some source code.

00:07:11.840 --> 00:07:14.350
I'm going to go into much greater
detail about this in a little bit,

00:07:14.500 --> 00:07:16.820
but suffice it to say you
need to add your parameters.

00:07:16.820 --> 00:07:19.880
This is, you know,
if you've got sliders for controlling

00:07:19.880 --> 00:07:22.380
the amount of blur or the size
of something in your filter,

00:07:22.380 --> 00:07:24.740
you need to add those
to the parameter list.

00:07:24.800 --> 00:07:26.970
And then you need to write
the code that's actually

00:07:26.970 --> 00:07:28.220
going to render your output.

00:07:28.370 --> 00:07:30.760
And you can do that in
either the CPU or the GPU.

00:07:30.760 --> 00:07:34.110
We highly encourage you to write
both so that the host application can

00:07:34.110 --> 00:07:37.880
decide which is better for it to use
and then choose the appropriate one.

00:07:38.520 --> 00:07:39.420
So then you'll build.

00:07:39.420 --> 00:07:41.040
Just choose build from the build menu.

00:07:41.040 --> 00:07:43.740
And assuming you don't get any
errors that you need to correct,

00:07:43.830 --> 00:07:45.660
you need to install the plug-in.

00:07:45.660 --> 00:07:49.210
And the plug-ins go in either
slash library slash plug-in slash

00:07:49.220 --> 00:07:52.780
FxPlug or in tilde slash library
slash plug-in slash FxPlug.

00:07:52.780 --> 00:07:57.240
And obviously you don't want to have
to be copying the built binary every

00:07:57.240 --> 00:07:59.910
time you're done building it to test it.

00:07:59.980 --> 00:08:03.730
So what you can do is create a
symlink from the plug-ins directory

00:08:03.840 --> 00:08:06.140
pointing back to your built library.

00:08:06.140 --> 00:08:07.450
It's just ln minus sf.

00:08:08.130 --> 00:08:10.500
The path to your built
library or your built plug-in,

00:08:10.540 --> 00:08:11.300
I should say.

00:08:11.300 --> 00:08:13.720
And then the path to
the plug-in directory.

00:08:15.710 --> 00:08:16.790
And then you can just build and run.

00:08:16.800 --> 00:08:17.820
And of course,
you're going to want to run.

00:08:17.820 --> 00:08:20.000
You're going to want to test in
both Motion and Final Cut Pro.

00:08:20.000 --> 00:08:22.320
In Motion,
if you click on the Library tab

00:08:22.320 --> 00:08:24.730
in the Inspector window,
you'll see you get,

00:08:24.730 --> 00:08:27.480
on the left-hand side,
you get a list of categories,

00:08:27.480 --> 00:08:29.200
two of which are filters and generators.

00:08:29.200 --> 00:08:32.340
And if you click on Filters,
on the right, you'll see the groups,

00:08:32.340 --> 00:08:35.920
and these are the groups that you
create and that we create internally.

00:08:35.920 --> 00:08:38.260
And you can see there's the
My Filter group that we created,

00:08:38.280 --> 00:08:41.480
and if you click on that, down below,
you see all the filters in that group.

00:08:41.480 --> 00:08:42.980
In this case, it's just My Filter.

00:08:43.740 --> 00:08:46.560
Likewise, in Final Cut Pro,
in the Browser window,

00:08:46.560 --> 00:08:48.160
there's the Effects tab.

00:08:48.160 --> 00:08:52.640
There are folders for video transitions,
video filters, and video generators.

00:08:52.760 --> 00:08:56.260
If you twirl open the video filters,
you should see My Filter in there,

00:08:56.260 --> 00:08:57.890
and if you twirl that open,
you should see the actual

00:08:58.000 --> 00:08:58.940
filter inside the folder.

00:09:00.800 --> 00:09:02.380
All right,
so let's talk about the SDK and

00:09:02.380 --> 00:09:04.320
get into some of the details.

00:09:04.340 --> 00:09:08.080
FxPlugs are a form of ProPlug,
and these are NSBundles that we

00:09:08.400 --> 00:09:12.540
use in Pro apps to extend the
functionality of our applications.

00:09:12.540 --> 00:09:15.450
Plug-in classes are going to conform
to certain plug-in protocols,

00:09:15.510 --> 00:09:18.260
and I'll describe those in a
lot more detail in a second.

00:09:18.340 --> 00:09:21.370
And host applications are going to
provide objects to the plug-ins so

00:09:21.390 --> 00:09:25.190
that they can talk back to the host
app and ask it for things and tell

00:09:25.190 --> 00:09:27.190
it things that it needs to know.

00:09:27.550 --> 00:09:28.520
So what are these protocols?

00:09:28.620 --> 00:09:32.840
Well, in Objective-C,
a protocol is similar to an abstract base

00:09:32.850 --> 00:09:35.100
class in C++ or an interface in Java.

00:09:35.100 --> 00:09:37.420
It's a description of things
that will be implemented.

00:09:37.420 --> 00:09:41.180
It doesn't have any
implementation behind it.

00:09:41.290 --> 00:09:44.370
And you create your class,
and you say it implements a protocol,

00:09:44.390 --> 00:09:47.070
you have to write the
functionality for those functions,

00:09:47.210 --> 00:09:48.610
or methods, I should say.

00:09:48.710 --> 00:09:50.820
So in this case,
we see we've got a protocol

00:09:50.910 --> 00:09:53.330
called fxBaseEffect,
and it has two methods.

00:09:53.340 --> 00:09:55.020
There's actually a couple more,
but these are the two

00:09:55.020 --> 00:09:55.940
important ones for now.

00:09:55.940 --> 00:09:59.670
AddParameters is where you'll actually
set up your sliders and checkboxes and

00:09:59.740 --> 00:10:01.970
custom parameters and things like that.

00:10:02.020 --> 00:10:05.680
And then ParameterChanged is where
the host app will call back into

00:10:05.680 --> 00:10:09.210
your plug-in and tell it that
somebody changed a parameter.

00:10:09.220 --> 00:10:10.850
You can use that for
supervision if you've got,

00:10:10.920 --> 00:10:12.550
say, a min and a max,
and you always want to keep the

00:10:12.650 --> 00:10:14.140
maximum greater than the minimum.

00:10:14.140 --> 00:10:16.030
You can keep those in sync there.

00:10:16.040 --> 00:10:18.380
Now, that's the BaseEffect protocol.

00:10:18.860 --> 00:10:21.280
There are two other protocols,
fxGenerator and fxFilter.

00:10:21.280 --> 00:10:23.000
Actually,
there's one for fxTransitions as well.

00:10:23.000 --> 00:10:27.100
And you can see that they both
inherit from fxBaseEffect.

00:10:27.100 --> 00:10:29.020
That's what the brackets there mean.

00:10:29.020 --> 00:10:33.180
And fxGenerator adds the
renderOutputWithInfo method.

00:10:33.180 --> 00:10:36.680
And that's because it can create
an output without any input.

00:10:36.680 --> 00:10:40.120
You'll see fxFilter has
renderOutputWithInputWithInfo.

00:10:40.120 --> 00:10:43.700
And that's because it takes an
input image as one of its inputs

00:10:43.740 --> 00:10:47.620
and as one of its arguments
and then generates its output.

00:10:47.620 --> 00:10:51.010
Now, both of these, when you implement an
fxFilter and fxGenerator,

00:10:51.010 --> 00:10:53.440
also include the addParameters
and parameterChanged methods.

00:10:55.580 --> 00:10:58.420
So let's look at our add parameters
method and how we'd write that.

00:10:58.430 --> 00:11:00.680
When you want to tell the
host app to do something,

00:11:00.680 --> 00:11:03.770
like create a new parameter,
you need to first get an

00:11:03.860 --> 00:11:05.340
object from the API manager.

00:11:05.340 --> 00:11:08.720
You'll be passed the API manager
in your initialization method.

00:11:08.760 --> 00:11:10.870
It's usually called a
knit with API manager.

00:11:10.940 --> 00:11:14.120
And it's an object that you use
to communicate back with the host.

00:11:14.140 --> 00:11:17.330
In this case, we tell the API manager,
give us the API for this

00:11:17.480 --> 00:11:18.830
particular protocol.

00:11:18.840 --> 00:11:21.920
In this case, it's the FX parameter
creation API protocol.

00:11:21.920 --> 00:11:25.000
It's kind of a mouthful, but basically,
we're going to be creating parameters.

00:11:25.000 --> 00:11:27.820
Give us the object that allows
us to create parameters.

00:11:27.820 --> 00:11:30.920
Once you get it,
you can call add float slider with name,

00:11:30.920 --> 00:11:33.700
add point parameter with name,
add color parameter with name,

00:11:33.700 --> 00:11:34.680
things like that.

00:11:34.840 --> 00:11:37.180
And that's all you have to do
to actually tell the host app

00:11:37.260 --> 00:11:40.410
that you've got a parameter,
that you've got a slider or whatever.

00:11:40.420 --> 00:11:44.240
You don't need to go into Interface
Builder if you don't want to.

00:11:44.240 --> 00:11:47.660
You don't need to write any
action methods to get called

00:11:47.790 --> 00:11:48.980
back and things like that.

00:11:48.980 --> 00:11:52.180
The host app will take care of
all the keyframing and everything.

00:11:52.210 --> 00:11:55.460
So obviously, there are a lot of
different parameter types.

00:11:55.500 --> 00:11:58.560
There is the floating point slider.

00:11:58.560 --> 00:12:01.940
Looks like our graphics aren't showing.

00:12:01.940 --> 00:12:02.560
Oh, there we go.

00:12:02.560 --> 00:12:02.740
OK.

00:12:02.820 --> 00:12:06.310
So we've got the floating point slider,
the integer slider.

00:12:06.360 --> 00:12:08.260
Sorry about that.

00:12:08.260 --> 00:12:10.250
Let's go back here.

00:12:11.350 --> 00:12:14.080
We've got toggle buttons,
which are just check boxes,

00:12:14.180 --> 00:12:15.920
an angle slider, which is a knob.

00:12:15.920 --> 00:12:18.940
We've got RGB colors with alpha,
and that's kind of nice so you

00:12:19.060 --> 00:12:21.910
don't have to have two parameters,
a color parameter and

00:12:21.920 --> 00:12:24.680
then an alpha slider,
unless you do it all in one.

00:12:24.680 --> 00:12:27.550
Likewise,
we have 2D points so that you can

00:12:27.890 --> 00:12:32.280
place across here right on the canvas
and let the user drag things around,

00:12:32.280 --> 00:12:35.820
so if they want to position
some aspect of your plug-in,

00:12:35.870 --> 00:12:39.640
it gives them direct feedback,
which is really nice.

00:12:39.980 --> 00:12:44.700
Pop-up menu, this can have any number
of textual items in it.

00:12:45.070 --> 00:12:45.910
You can have an image.

00:12:45.910 --> 00:12:48.060
And the great thing about an
image well is that it doesn't

00:12:48.060 --> 00:12:49.050
have to be a still image.

00:12:49.050 --> 00:12:49.500
It can be.

00:12:49.500 --> 00:12:50.420
It can be footage.

00:12:50.420 --> 00:12:52.380
In Motion,
it can be a group which contains

00:12:52.380 --> 00:12:55.060
footage and stills and shapes
and other things like that.

00:12:55.080 --> 00:12:56.630
So it gives the user a lot of power.

00:12:56.730 --> 00:12:58.100
So they're very useful.

00:12:58.100 --> 00:13:01.730
You can have text if you want to
have some sort of titling plug-in.

00:13:01.790 --> 00:13:03.570
It's really useful for that.

00:13:03.590 --> 00:13:06.010
And you can have groups of parameters,
which is really nice.

00:13:06.100 --> 00:13:09.100
If you've got a lot of parameters,
and you'll find that some users really

00:13:09.100 --> 00:13:12.140
like having a lot of parameters,
you can group some of them together.

00:13:12.140 --> 00:13:14.140
The user can twirl/close
the ones they aren't using.

00:13:14.140 --> 00:13:16.300
It cleans up the UI,
makes it a little easier to use.

00:13:16.380 --> 00:13:19.030
You can have custom parameters,
as I said.

00:13:19.050 --> 00:13:21.100
And I'll talk about these in
greater detail in a minute.

00:13:21.130 --> 00:13:24.130
But you can have them
be anything you want.

00:13:24.140 --> 00:13:25.820
In this case,
we've got this crazy text style.

00:13:25.820 --> 00:13:28.470
You could have an RGB curves,
things like that,

00:13:28.470 --> 00:13:31.040
all kinds of things that
you can do with that.

00:13:31.190 --> 00:13:33.490
We have some optional
parameter types you can use,

00:13:33.560 --> 00:13:35.970
histogram for doing levels
and things like that.

00:13:35.980 --> 00:13:38.300
A gradient parameter.

00:13:38.300 --> 00:13:41.320
And this is really great because
you don't have to have the user

00:13:41.320 --> 00:13:44.820
go out to an image editing app,
create a one pixel high image,

00:13:44.850 --> 00:13:47.370
import it into the project,
find it in the project,

00:13:47.370 --> 00:13:48.810
and then drop it on your plug-in.

00:13:48.970 --> 00:13:51.250
You can just put a gradient
parameter right there,

00:13:51.250 --> 00:13:55.080
and you can see they can create all
kinds of gradients with that directly.

00:13:55.080 --> 00:13:56.700
Okay.

00:13:56.710 --> 00:13:59.030
So once we have these parameters,
of course, we have to get their

00:13:59.030 --> 00:14:00.110
values in order to render.

00:14:00.190 --> 00:14:03.700
We might have a blur amount that we
need to get or something like that.

00:14:03.700 --> 00:14:04.780
So it's the same thing as before.

00:14:04.780 --> 00:14:07.150
We ask the API manager for
the object that implements

00:14:07.160 --> 00:14:08.780
the parameter retrieval API.

00:14:08.780 --> 00:14:10.930
And once we have it,
we just call get float

00:14:11.060 --> 00:14:12.670
parameter from RAM at time.

00:14:12.670 --> 00:14:16.370
And we give a unique ID to each of
our parameters when we create them,

00:14:16.370 --> 00:14:18.080
and that's how we identify them.

00:14:18.080 --> 00:14:20.480
And these are just -- you know,
we usually just number

00:14:20.570 --> 00:14:21.770
them starting at one.

00:14:21.770 --> 00:14:23.730
They aren't UUIDs or anything like that.

00:14:23.730 --> 00:14:26.520
And you'll notice that it's got
that time parameter in there.

00:14:26.610 --> 00:14:29.350
In some other applications,
when you want to get a parameter at a

00:14:29.350 --> 00:14:32.700
different time than the current time,
you have to check out the parameter,

00:14:32.800 --> 00:14:34.910
do something with it,
and then check it back in.

00:14:34.910 --> 00:14:36.200
And that's really cumbersome.

00:14:36.410 --> 00:14:37.740
So we made it a lot easier for you.

00:14:37.790 --> 00:14:39.880
You just pass it the
time value that you want,

00:14:39.880 --> 00:14:41.070
and you should get that.

00:14:41.310 --> 00:14:44.660
Likewise, for setting values,
you'll get the object which

00:14:44.710 --> 00:14:48.850
implements the parameter setting API,
and then you'll just say set

00:14:48.950 --> 00:14:53.830
float value to parm at time,
set int value to parm at time.

00:14:53.850 --> 00:14:55.990
And that's how you can
do parameter supervision.

00:14:55.990 --> 00:14:59.390
For example, you get the min and the max,
and if the max is less than the min,

00:14:59.450 --> 00:15:02.270
set it to one greater than the min,
things like that.

00:15:03.580 --> 00:15:06.670
Okay, so let's look at custom
UI in a little more detail.

00:15:06.900 --> 00:15:09.020
You can assign a custom UI to
either a standard parameter,

00:15:09.120 --> 00:15:12.300
like a floating point parameter,
or to a custom parameter,

00:15:12.300 --> 00:15:14.970
which is some custom data
that you will create yourself.

00:15:15.000 --> 00:15:17.860
For example, if you're doing curves,
we don't have any sort of data

00:15:17.860 --> 00:15:20.620
type that works with curves,
so you'd have to create that.

00:15:20.640 --> 00:15:24.300
They're going to appear in the inspector,
just like all the other parameters.

00:15:24.300 --> 00:15:25.310
They'll be in the parameter list.

00:15:25.350 --> 00:15:27.570
They can be resizable,
and it's going to be

00:15:27.570 --> 00:15:28.900
a subclass of NSView.

00:15:28.900 --> 00:15:32.520
So if you've been writing Cocoa code,
you already know how to write an NSView.

00:15:33.510 --> 00:15:37.070
And it will act just like an NSView that
was created by the application.

00:15:37.080 --> 00:15:39.700
And you can create them programmatically,
which I'll show,

00:15:39.700 --> 00:15:42.280
and Paul's going to show how to
do them in Interface Builder.

00:15:42.300 --> 00:15:43.490
So let's look at some of
the things that we can do.

00:15:44.640 --> 00:15:48.780
Okay, so the basic tasks are we have to
tell the host app that we can support,

00:15:48.780 --> 00:15:52.540
that we can host a custom parameter view,
and we do that by adding the

00:15:52.540 --> 00:15:56.080
FxCustomParameterViewHost protocol
to our class declaration.

00:15:56.080 --> 00:15:59.720
We'll need to create the custom
parameter in the add parameters method.

00:15:59.720 --> 00:16:02.520
We'll need to write the, well,
we'll need to tell the host app that

00:16:02.520 --> 00:16:05.440
we're going to add the parameter
in the add parameters method,

00:16:05.440 --> 00:16:06.740
and then we'll have
to write the function,

00:16:06.740 --> 00:16:08.940
the method,
which actually creates the view

00:16:08.940 --> 00:16:10.540
and returns it to the host app.

00:16:10.980 --> 00:16:12.930
And then we'll have to
write code to draw the view,

00:16:12.980 --> 00:16:15.780
respond to events like mouse down,
key down, things like that.

00:16:15.820 --> 00:16:18.330
And then we'll write code to
modify the data if there's

00:16:18.330 --> 00:16:19.960
custom data associated with it.

00:16:20.040 --> 00:16:21.100
So let's look at that.

00:16:21.140 --> 00:16:23.300
This is a typical class declaration.

00:16:23.300 --> 00:16:27.550
You can see we've got the interface,
my plug, it's a subclass of NSObject,

00:16:27.550 --> 00:16:31.480
and it implements the FxFilter
protocol because it's a filter.

00:16:31.480 --> 00:16:35.040
Well, all you have to do is add comma
FxCustomParameterViewHost to that,

00:16:35.040 --> 00:16:37.670
and that tells the host
application that you're able to

00:16:37.670 --> 00:16:39.390
host a custom parameter view.

00:16:41.620 --> 00:16:46.500
So in "Add Parameters" we need
to actually tell the host app

00:16:46.500 --> 00:16:49.020
which of our parameters are
gonna be custom parameters.

00:16:49.020 --> 00:16:52.970
And we do that by getting the
FX parameter creation API object and then

00:16:53.260 --> 00:16:55.300
calling add custom parameter with name.

00:16:55.300 --> 00:16:56.680
We pass it a parameter ID.

00:16:56.680 --> 00:16:59.050
You can have more than
one custom parameter.

00:16:59.170 --> 00:17:02.230
So later when you go to create them,
you'll get past the ID of which

00:17:02.270 --> 00:17:03.730
one you're supposed to create.

00:17:03.850 --> 00:17:04.890
Pass it a default value.

00:17:04.890 --> 00:17:07.720
In this case,
we've got a type that we've created

00:17:07.720 --> 00:17:12.510
called "point array." And then you
have to pass it the custom UI flag.

00:17:12.510 --> 00:17:15.620
It's K FX parameter flag custom UI.

00:17:15.620 --> 00:17:19.890
And that tells it that this
custom parameter has custom UI.

00:17:20.940 --> 00:17:23.620
Then you have to actually create
it or read it in from a nib or

00:17:23.620 --> 00:17:24.950
whatever you're going to do.

00:17:24.960 --> 00:17:27.420
And you do that in your
createViewForParm method.

00:17:27.420 --> 00:17:29.750
And as you can see,
it passes you the ID of the parameter

00:17:29.750 --> 00:17:31.200
that it wants you to create.

00:17:31.200 --> 00:17:33.980
It'll get called once for each
parameter that has custom UI.

00:17:33.980 --> 00:17:37.100
So in this case, we check it to see which
one we're creating.

00:17:37.100 --> 00:17:39.180
We're creating the myCustomItemID.

00:17:39.180 --> 00:17:43.120
And we allocate our custom view and
then call its initialization method.

00:17:43.120 --> 00:17:46.320
And we pass it the API manager
so it can do some things later.

00:17:46.320 --> 00:17:49.260
And then we simply return the NSView,
the pointer to the

00:17:49.260 --> 00:17:50.800
NSView that we get back.

00:17:51.780 --> 00:17:54.040
And that's all there is
to actually creating it.

00:17:54.130 --> 00:17:56.940
Now you've actually got to do all the
things that you would do for an NSView.

00:17:56.940 --> 00:17:59.680
So you're going to have to override
the drawRect method to draw

00:17:59.890 --> 00:18:01.200
whatever it is you're drawing.

00:18:01.200 --> 00:18:04.820
You're going to have to override
all the NSResponder methods,

00:18:04.820 --> 00:18:09.100
things like mouseDown, mouseDragged,
keyDown, and respond to all those things.

00:18:09.100 --> 00:18:11.310
If you want to assign contextual menus,
you can do that.

00:18:11.340 --> 00:18:16.520
And the view controller that you
write is going to want to change

00:18:16.520 --> 00:18:19.260
the value of the custom data.

00:18:19.260 --> 00:18:23.530
It's going to want to tell
the custom parameter view to

00:18:23.530 --> 00:18:24.490
update and things like that.

00:18:24.560 --> 00:18:26.810
In order to communicate
back with the host,

00:18:26.810 --> 00:18:28.580
there's a little problem here, though.

00:18:28.600 --> 00:18:32.960
And that's that because you're an
NSView and it's in the application

00:18:32.960 --> 00:18:37.040
just like any other NSView,
the OS calls it directly to do things

00:18:37.040 --> 00:18:39.350
like redraw and respond to events.

00:18:39.360 --> 00:18:42.110
So the host app doesn't know that
you've been called to do that.

00:18:42.180 --> 00:18:44.560
So if you start asking for parameters,
it gets a little confused.

00:18:44.560 --> 00:18:48.580
So we have the custom parameter
action API in order to handle that.

00:18:49.280 --> 00:18:53.300
And what this is is it's just like any
other thing you get from the API manager.

00:18:53.300 --> 00:18:55.440
You ask for the object,
which implements that API.

00:18:55.440 --> 00:18:58.740
And it has a method called startAction.

00:18:58.740 --> 00:19:01.960
And what this says is we're going
to start modifying some parameters.

00:19:01.960 --> 00:19:04.500
And you pass it a pointer
to the custom view.

00:19:04.500 --> 00:19:07.560
And it says this is the view that's
going to be modifying parameters.

00:19:07.560 --> 00:19:09.600
The other thing is you've
been called by the OS,

00:19:09.600 --> 00:19:11.330
as I said,
so you don't know what the current

00:19:11.330 --> 00:19:14.110
timeline time is because usually
that's passed to you as a parameter

00:19:14.110 --> 00:19:16.940
to your render method or your
parameter change method or whatever.

00:19:16.940 --> 00:19:19.080
Actually, not parameter change,
just your render method.

00:19:19.080 --> 00:19:19.080
So you don't know what the current
timeline time is because usually

00:19:19.080 --> 00:19:19.080
that's passed to you as a parameter
to your render method or your

00:19:19.080 --> 00:19:19.100
parameter change method or whatever.

00:19:19.100 --> 00:19:21.950
So in order to get that,
you have to ask the action

00:19:22.060 --> 00:19:23.390
API for the current time.

00:19:24.760 --> 00:19:27.560
Then you can do all the usual
things you'd do as if it was

00:19:27.560 --> 00:19:29.090
any other part of your plug-in.

00:19:29.090 --> 00:19:31.840
You can get and set parameter
values and things like that.

00:19:31.840 --> 00:19:35.140
And when you're done to clean up,
you just call end action and pass

00:19:35.140 --> 00:19:37.520
it a pointer to that NSView again.

00:19:38.700 --> 00:19:41.740
Okay,
so if you've got custom data associated

00:19:41.740 --> 00:19:45.350
with your custom parameter view,
you need to write some

00:19:45.440 --> 00:19:46.460
code to deal with that.

00:19:46.630 --> 00:19:48.740
You're going to need to make
it an NSObject subclass,

00:19:48.740 --> 00:19:52.260
and it's going to need to
implement the NSCoding protocol.

00:19:52.450 --> 00:19:55.760
One of the things you're going to have
to do is create some default data for it.

00:19:55.760 --> 00:19:58.560
In this case,
we've created a class method called

00:19:58.560 --> 00:20:02.980
emptyData that returns some empty
data that we can pass as a default.

00:20:04.110 --> 00:20:06.460
And the other thing you're
going to want to do is pass the

00:20:06.460 --> 00:20:11.440
not-animatable flag because currently
custom data is not key-frameable.

00:20:11.440 --> 00:20:15.180
Hopefully we'll get that in the future,
but we seem to keep putting

00:20:15.180 --> 00:20:16.780
it off for some reason.

00:20:16.780 --> 00:20:21.660
But as I said, you need to implement the
NSCoding protocol for your data.

00:20:21.660 --> 00:20:25.710
And what that does is it allows us
to have you serialize your data for

00:20:25.720 --> 00:20:28.240
writing out to the user's document.

00:20:28.240 --> 00:20:31.980
So when the user saves,
we'll call your ENCODE_WITH_CODER method.

00:20:32.090 --> 00:20:36.410
You'll serialize your data just like
you would in any other Cocoa app.

00:20:36.940 --> 00:20:38.850
And then later when we read
in the user's document,

00:20:38.850 --> 00:20:41.360
we'll ask you to deserialize it,
and we'll call your

00:20:41.360 --> 00:20:43.610
INIT_WITH_CODER method to do that.

00:20:43.940 --> 00:20:47.800
So that's parameters and custom
parameters in particular.

00:20:47.920 --> 00:20:49.300
Let's look at rendering.

00:20:49.450 --> 00:20:51.800
Now,
all rendering happens with an FxImage.

00:20:51.800 --> 00:20:55.300
An FxImage is a base class,
and there are two subclasses of it.

00:20:55.300 --> 00:20:58.300
FxTexture, which is a thin wrapper
around OpenGL textures,

00:20:58.320 --> 00:21:00.560
and that's how you do
hardware-accelerated stuff,

00:21:00.670 --> 00:21:04.190
and FxBitmap,
which will give you-- it's basically a

00:21:04.190 --> 00:21:07.120
wrapper around a RAM-based bitmap image,
and that's convenient for

00:21:07.120 --> 00:21:10.560
doing things with code that
you might have already written,

00:21:10.560 --> 00:21:12.470
say, for another plug-in architecture.

00:21:13.090 --> 00:21:17.740
In the case of -- well, actually,
both FX bitmaps and FX textures can have

00:21:17.740 --> 00:21:19.150
a number of different pixel formats.

00:21:19.160 --> 00:21:22.030
You can get 8-bit integer ARGB.

00:21:22.070 --> 00:21:25.700
For textures only,
you can get 16-bit float ARGB.

00:21:25.700 --> 00:21:28.420
And for both of them,
you can get 32-bit float ARGB.

00:21:28.540 --> 00:21:33.100
If you want, you can get 8-bit integer
R4-08 or 32-bit float R4FL.

00:21:33.100 --> 00:21:35.460
And those are YCBCR formats.

00:21:35.460 --> 00:21:38.680
And they're described in letters
from the ice flow 19 and 27.

00:21:38.740 --> 00:21:42.230
If you go to developer.apple.com
and search for letters from

00:21:42.230 --> 00:21:45.280
the ice flow or just ice flow,
it should pop those up.

00:21:45.280 --> 00:21:47.540
They're QuickTime documents.

00:21:47.650 --> 00:21:49.300
Bitmaps have pre-multiplied alpha.

00:21:49.300 --> 00:21:52.200
So keep that in mind if you have to
do some things -- you may need to

00:21:52.200 --> 00:21:54.770
do some things that un-premultiply
them and just remember to

00:21:54.770 --> 00:21:56.440
pre-multiply them when you're done.

00:21:56.440 --> 00:21:57.430
And they have a row bytes parameter.

00:21:57.440 --> 00:21:59.960
And I think Paul will get into
this in a little more detail.

00:21:59.980 --> 00:22:02.480
But basically,
it tells you how many bytes

00:22:02.710 --> 00:22:04.220
there are per scan line.

00:22:04.220 --> 00:22:05.670
And if you're looking
at something that's,

00:22:05.710 --> 00:22:08.540
say, 640 by 480 and it's an
8-bit integer ARGB format.

00:22:08.540 --> 00:22:11.560
. . . You may think, okay,
so 640 by times 4 is

00:22:11.700 --> 00:22:13.800
roughly 2400 bytes wide.

00:22:13.930 --> 00:22:16.530
But you get the row bytes and you see,
oh, my gosh, it's like 5200.

00:22:16.590 --> 00:22:17.580
What's that about?

00:22:17.720 --> 00:22:20.670
Well, if you've got an interlaced
frame where you've got an

00:22:20.670 --> 00:22:24.330
upper field and a lower field,
we may pass you a pointer to

00:22:24.330 --> 00:22:28.670
the beginning of the frame,
tell you that the line is 640 pixels

00:22:28.730 --> 00:22:31.680
wide but that it's 5200 bytes wide.

00:22:31.800 --> 00:22:36.710
So just process the first 640 pixels,
skip the next 2400 bytes,

00:22:36.710 --> 00:22:38.350
and go to the next line.

00:22:38.470 --> 00:22:41.460
Don't assume that's what we're going
to do because we don't always do that.

00:22:41.460 --> 00:22:43.660
The different applications
work differently.

00:22:43.660 --> 00:22:45.220
Some applications do that, some don't.

00:22:45.220 --> 00:22:49.570
So just always obey the row
bytes and you'll be fine.

00:22:50.050 --> 00:22:52.390
Okay, FX textures, as I said,
they're a thin wrapper

00:22:52.390 --> 00:22:53.700
around OpenGL textures.

00:22:53.700 --> 00:22:56.100
You want to always get
the texture coordinates.

00:22:56.100 --> 00:22:59.490
There's a method for getting those,
and your texture may be located

00:22:59.490 --> 00:23:02.080
somewhere in texture space
that you're not expecting.

00:23:02.080 --> 00:23:05.770
It's not necessarily always oriented
at the origin or anything like that,

00:23:05.830 --> 00:23:07.420
so you need to make sure
you get the coordinates.

00:23:07.420 --> 00:23:11.640
You can do a bind and
enable to start using them.

00:23:11.640 --> 00:23:12.940
You can get the texture ID.

00:23:12.940 --> 00:23:15.390
If you need to pass that to, say,
an OpenGL routine that

00:23:15.390 --> 00:23:16.870
needs a texture ID,
you can get that.

00:23:16.880 --> 00:23:19.920
They also have pre-multiplied alpha,
and I just want to give

00:23:19.920 --> 00:23:21.000
you one small warning here.

00:23:21.000 --> 00:23:25.550
You probably won't go creating
a lot of FX textures yourself.

00:23:25.560 --> 00:23:29.030
They're not real useful for doing
things like communicating with the OS,

00:23:29.040 --> 00:23:34.500
and generally it's hard for the host
app to tell who owns the texture,

00:23:34.500 --> 00:23:36.550
so it doesn't know when it
can delete it if you do that.

00:23:36.680 --> 00:23:39.100
So if you're just going to
be creating textures for your

00:23:39.100 --> 00:23:42.870
own use and talking to OpenGL,
you can just create regular

00:23:42.870 --> 00:23:46.140
OpenGL textures with
gl-gentext or whatever you use,

00:23:46.200 --> 00:23:48.140
but when you communicate
with the host app,

00:23:48.240 --> 00:23:49.960
you'll get... It'll give
you the FX textures,

00:23:49.960 --> 00:23:52.810
and it may occasionally ask
you to give it an FX texture.

00:23:52.820 --> 00:23:57.300
But in general,
it's just too thin of a wrapper

00:23:57.300 --> 00:24:00.380
to do a lot with it other than
communicate with the host.

00:24:00.380 --> 00:24:04.130
Okay, there's a whole bunch more FX plug
functionality that we don't

00:24:04.130 --> 00:24:05.400
have time to get into today.

00:24:05.400 --> 00:24:08.220
I think Paul's going to talk a
little bit about the FX timing API.

00:24:08.220 --> 00:24:12.770
You can request images, input images,
at different times using the

00:24:12.770 --> 00:24:16.200
temporal image API or the
temporal transition image API,

00:24:16.200 --> 00:24:17.960
and that's good for doing
things like retiming or,

00:24:17.960 --> 00:24:19.610
if you're doing something like this,
or if you're doing echo

00:24:19.700 --> 00:24:20.500
or feedback effects.

00:24:20.500 --> 00:24:24.030
In Motion,
you can get 3D layer and camera

00:24:24.030 --> 00:24:26.600
position and orientation information.

00:24:26.600 --> 00:24:28.800
You can create on-screen controls,
as I said.

00:24:28.800 --> 00:24:31.060
In all the host apps,
you can get host information,

00:24:31.060 --> 00:24:32.940
so you can tell if you're
running in Final Cut Express,

00:24:32.940 --> 00:24:35.500
Final Cut Pro, Motion,
and you can get plug-in

00:24:35.500 --> 00:24:36.860
versioning information.

00:24:36.860 --> 00:24:40.180
So if you created version 1.0
of your product and somebody

00:24:40.180 --> 00:24:44.780
applies it in their document,
and then later they update to version

00:24:44.780 --> 00:24:47.580
2.0 and they open that document,
you can see that the data for

00:24:47.580 --> 00:24:50.460
your plug-in was created with 1.0,
and you may need to add some

00:24:50.860 --> 00:24:53.090
information to it or remove
some information or whatever.

00:24:55.200 --> 00:30:18.800
[Transcript missing]

00:30:18.890 --> 00:30:20.180
So we can use this to our advantage.

00:30:20.330 --> 00:30:23.120
In After Effects,
you call the PFAddFloatSlider macro

00:30:23.120 --> 00:30:25.200
to create a new floating point slider.

00:30:25.200 --> 00:30:29.320
In FxPlugs, you call the Param API's
AddFloatSliderWithName method.

00:30:29.320 --> 00:30:31.520
You know, they've got PFAddPoint.

00:30:31.520 --> 00:30:34.650
We've got AddPointParameterWithName,
things like that.

00:30:34.700 --> 00:30:39.740
So why don't we wrap these up
in some generic wrapper and

00:30:39.740 --> 00:30:41.560
call it from both plug-ins?

00:30:41.580 --> 00:30:45.500
In this case, what I'm going to do is I'm
going to create some FX helpers.

00:30:45.820 --> 00:30:48.720
And so I've prefixed everything
with FXH for FX helper.

00:30:48.720 --> 00:30:51.540
We're going to create a method,
a single function.

00:30:51.540 --> 00:30:56.780
Because Objective-C is a superset of C,
we can use straight C in this.

00:30:56.780 --> 00:30:58.650
So we're going to create
a single function,

00:30:58.650 --> 00:31:02.270
which will add a float slider,
and it will do the appropriate

00:31:02.270 --> 00:31:05.590
thing in After Effects and the
appropriate thing in FxPlug.

00:31:07.570 --> 00:31:08.950
So this is what our header
is going to look like.

00:31:08.990 --> 00:31:11.820
We're going to have a
fxh create float slider.

00:31:11.870 --> 00:31:15.260
The first argument is going to be a
pointer to some app specific data.

00:31:15.260 --> 00:31:17.700
Because each application has
different requirements of how

00:31:17.700 --> 00:31:20.910
it has to create the parameter,
we're going to pass the

00:31:20.910 --> 00:31:22.860
appropriate data in that pointer.

00:31:22.910 --> 00:31:25.320
And then you can see the things that
are going to be the same among them.

00:31:25.320 --> 00:31:28.510
The parameter name, the parameter ID,
the default value, the min and max,

00:31:28.580 --> 00:31:29.410
things like that.

00:31:29.610 --> 00:31:32.400
Likewise, we're going to have to have
a method to actually get that

00:31:32.420 --> 00:31:34.010
value back when we go to render.

00:31:34.120 --> 00:31:35.750
So we're going to call
fxh get float param,

00:31:35.870 --> 00:31:38.440
and we're going to pass it
that app specific data again,

00:31:38.440 --> 00:31:41.220
the ID and the time that we want.

00:31:42.500 --> 00:31:44.810
So here's what it's going to
look like in After Effects.

00:31:44.870 --> 00:31:47.920
The first thing we're going to do is
we're going to cast that app-specific

00:31:48.020 --> 00:31:50.750
data to a pf indata pointer,
and that's the gigantic structure

00:31:50.790 --> 00:31:52.580
that they send to your plugin.

00:31:52.600 --> 00:31:55.440
And then we create a param def structure,
we clear it,

00:31:55.460 --> 00:31:58.480
and we call the pf addFloatSlider macro.

00:31:58.480 --> 00:32:01.980
And that's all there is to it for
adding a floating point slider.

00:32:02.400 --> 00:32:04.010
Of course, it's very similar in FX Plug.

00:32:04.020 --> 00:32:08.490
We cast that app-specific data
to be the object which implements

00:32:08.560 --> 00:32:11.090
the parameter creation API,
and then we call

00:32:11.090 --> 00:32:13.380
addFloatSlider with name,
pass it the name,

00:32:13.380 --> 00:32:16.610
we pass it the parameter ID,
the default value, the min and the max,

00:32:16.610 --> 00:32:18.230
and all that stuff.

00:32:18.520 --> 00:32:21.740
So we can write a single function
called SetupGammaParameters,

00:32:21.740 --> 00:32:26.030
if this is a gamma filter, for example,
and call that from both applications.

00:32:26.040 --> 00:32:28.270
So this is how we'd call
it in After Effects.

00:32:28.440 --> 00:32:31.500
We just call SetupGammaParameters,
and we pass it the inData pointer.

00:32:31.500 --> 00:32:35.800
In FxPlug, we call SetupGammaParameters,
and we pass it the pointer

00:32:35.810 --> 00:32:38.540
to the object that implements
the parameter creation API.

00:32:38.540 --> 00:32:40.850
And then this is what
it actually looks like.

00:32:40.920 --> 00:32:43.280
It calls the helper function
that we wrote earlier.

00:32:44.080 --> 00:32:48.060
And when we compile for After Effects,
it'll call the After Effects version

00:32:48.070 --> 00:32:48.960
of that function.

00:32:48.960 --> 00:32:51.470
And when we compile for FxPlug,
it'll call the FxPlug

00:32:51.560 --> 00:32:53.080
version of that function.

00:32:54.820 --> 00:32:57.480
So in summary,
you can see that there's a pretty good

00:32:57.480 --> 00:33:02.480
correspondence between the two APIs,
and other image and video processing

00:33:02.480 --> 00:33:04.760
APIs are very similar as well.

00:33:04.760 --> 00:33:07.440
You're going to implement
either a filter,

00:33:07.450 --> 00:33:12.480
a generator, or a transition,
and you can write code that

00:33:12.480 --> 00:33:15.590
will work both in FxPlug and
in After Effects and other

00:33:15.590 --> 00:33:18.200
architectures as well pretty easily.

00:33:18.200 --> 00:33:21.160
So I'm going to turn it over to Paul,
and he's going to talk about

00:33:21.200 --> 00:33:23.260
advanced topics with Final Cut Pro.

00:33:24.320 --> 00:33:25.100
So take it away, Paul.

00:33:32.690 --> 00:33:33.600
Hi, everybody.

00:33:33.600 --> 00:33:34.260
I'm Paul Schneider.

00:33:34.380 --> 00:33:37.840
I'm an engineer in Final Cut working
on the plug-in hosting.

00:33:37.850 --> 00:33:42.830
And today I'm gonna talk a little
bit about some more sort of,

00:33:42.830 --> 00:33:42.830
uh...

00:33:43.000 --> 00:34:49.000
[Transcript missing]

00:34:49.910 --> 00:34:51.960
So I'll just go through these one by one.

00:34:51.960 --> 00:34:54.690
The first, with the aspect ratio,
you can see that when we're

00:34:54.820 --> 00:34:58.660
displaying it on the computer monitor,
we'll scale horizontally when we show

00:34:58.660 --> 00:35:06.790
it to the user to simulate the actual
device that they'll be looking at it on.

00:35:06.930 --> 00:35:09.800
So you need to be prepared
to handle aspect ratio.

00:35:09.800 --> 00:35:12.580
And how do you do that in FxPlug?

00:35:12.780 --> 00:35:15.600
Well, we tag each FX image
with an aspect ratio.

00:35:15.600 --> 00:35:19.770
So you can simply ask your inputs and
your outputs what their aspect is and

00:35:19.770 --> 00:35:22.290
then adjust your rendering accordingly.

00:35:22.600 --> 00:35:25.620
The next one is the
interlaced processing.

00:35:25.780 --> 00:35:29.660
We'll ask you to render one field of
video and then a second field of video,

00:35:29.660 --> 00:35:32.260
and we'll interlace that together.

00:35:32.360 --> 00:35:35.100
So you can see in this picture,
the first image is red,

00:35:35.100 --> 00:35:37.250
the second is blue, and we combine them.

00:35:37.330 --> 00:35:38.560
So you need to be ready for that.

00:35:38.560 --> 00:35:41.590
Another--there's a difference between
Final Cut and Motion here as well.

00:35:41.670 --> 00:35:45.640
In Final Cut,
the fields are half height because,

00:35:45.640 --> 00:35:49.260
you know, we take--we combine two
of them to form a frame.

00:35:49.320 --> 00:35:52.260
In Motion, they'll actually take
the half height fields,

00:35:52.480 --> 00:35:57.360
they'll scale them to full height,
so it's a little easier to process,

00:35:57.460 --> 00:35:59.260
but not quite as fast.

00:35:59.270 --> 00:36:02.350
So you need to be ready
for handling fields,

00:36:02.350 --> 00:36:06.260
and you need to be ready for the
difference between Final Cut and Motion.

00:36:06.260 --> 00:36:09.260
And this is how you do
that inside the FxPlug API.

00:36:09.260 --> 00:36:12.260
Similar to aspect ratio,
each image is tagged with a field.

00:36:12.260 --> 00:36:15.260
The Fx field in them will
be either the lower field,

00:36:15.260 --> 00:36:17.620
the upper field,
or a full progressive frame if you're

00:36:17.660 --> 00:36:19.260
working in a progressive sequence.

00:36:19.260 --> 00:36:21.330
And then we have the
host capabilities object,

00:36:21.380 --> 00:36:23.260
which gives you information
about the host you're running in.

00:36:23.260 --> 00:36:27.070
And one of the things you can ask about
is whether this host upscales fields.

00:36:27.260 --> 00:36:30.380
If this is yes, then you're running
in an app like Motion,

00:36:30.380 --> 00:36:33.260
where the fields will be stretched
to full height for you to process.

00:36:33.260 --> 00:36:36.380
If this is no, then you're running in
an app like Final Cut,

00:36:36.550 --> 00:36:39.250
where the fields will just
be the raw field data.

00:36:39.260 --> 00:36:42.750
So you need to handle both cases.

00:36:43.400 --> 00:36:48.760
Then finally, the low-resolution proxy,
you can see here in this example, we've,

00:36:48.760 --> 00:36:52.100
um, we've asked you to process an
image that's half the size,

00:36:52.100 --> 00:36:55.230
and then we'll scale that up for display,
just to make playback faster

00:36:55.230 --> 00:36:56.480
or something like that.

00:36:56.500 --> 00:36:58.710
And you can tell this is
going on by looking at the,

00:36:58.710 --> 00:37:01.050
um,
the scale info in the render info struct

00:37:01.180 --> 00:37:02.840
that we passed to you during render.

00:37:02.990 --> 00:37:05.190
So we have the scale x and scale y.

00:37:05.320 --> 00:37:08.040
If, uh, we're rendering 1:1,
these will be 1.0.

00:37:08.040 --> 00:37:11.320
If we're rendering half size,
it'll be 0.5, et cetera.

00:37:11.440 --> 00:37:13.050
So that seems like a
lot to keep track of.

00:37:13.200 --> 00:37:16.700
Um, but you can kind of combine them all
into just a single scale factor that

00:37:16.720 --> 00:37:18.340
you use to adjust your rendering.

00:37:18.390 --> 00:37:21.200
Here's a quick snippet of code, uh,
that shows how to do this.

00:37:21.290 --> 00:37:23.590
This is, um,
taken directly from an example

00:37:23.590 --> 00:37:26.730
plug-in that I'll be talking about
in a minute that ships with the SDK.

00:37:26.840 --> 00:37:28.620
So don't worry about typing this down.

00:37:28.840 --> 00:37:30.720
But you can see I'll
start out with a uniform,

00:37:30.850 --> 00:37:32.580
you know, 1:1 scaling.

00:37:32.630 --> 00:37:36.090
I'll scale-- I'll-- I'll take
the aspect ratio of my output,

00:37:36.210 --> 00:37:38.480
and I'll adjust my
horizontal scale by that.

00:37:38.520 --> 00:37:40.650
I'll check to see if I'm
working in a half-height field.

00:37:40.840 --> 00:37:40.840
That's a two-part scale.

00:37:40.840 --> 00:37:40.840
I'll check to see if I'm
working in a half-height field.

00:37:40.840 --> 00:37:40.840
That's a two-part scale.

00:37:40.880 --> 00:37:42.100
That's a two-part check.

00:37:42.160 --> 00:37:44.990
First, check to see if, um,
I'm processing a field right now.

00:37:45.110 --> 00:37:48.640
And second, check to see if the fields in
this application are half-height.

00:37:48.720 --> 00:37:50.680
If both of those things are true,
then I'll adjust my

00:37:50.680 --> 00:37:52.800
vertical scaling by 0.5.

00:37:52.880 --> 00:37:54.820
And then finally,
I'll-- I'll blend in the, uh,

00:37:54.930 --> 00:37:58.880
the resol-- the low-resolution proxy,
if there is any.

00:37:59.960 --> 00:38:01.900
So I'm just going to step
over to the demo machine,

00:38:01.900 --> 00:38:06.020
and this is a lot easier to
see than it is to talk about.

00:38:06.020 --> 00:38:10.310
You can see here I've got a plugin
called Scrolling Rich Texts.

00:38:10.320 --> 00:38:11.480
We shipped this with the SDK.

00:38:11.570 --> 00:38:13.180
It's one of our examples.

00:38:13.210 --> 00:38:17.360
And this is just a simple
plugin for example purposes.

00:38:17.360 --> 00:38:22.780
Let's see you scrub through,
and we'll do an easy title crawl here.

00:38:22.780 --> 00:38:27.470
This also demonstrates the sort
of gotchas I was talking about.

00:38:27.500 --> 00:38:29.970
This plugin correctly
handles aspect ratio,

00:38:29.980 --> 00:38:32.560
half height fields, and the render scale.

00:38:32.690 --> 00:38:36.470
But it also allows you to turn handling
for each of those situations off so

00:38:36.580 --> 00:38:40.080
you can see what difference it makes.

00:38:40.130 --> 00:38:43.260
For example here, if I turn off handling
of the aspect ratio,

00:38:43.270 --> 00:38:46.900
you can see the text
sort of gets squished.

00:38:46.920 --> 00:38:50.360
This is an NTSC sequence,
which has an aspect of 0.9.

00:38:50.360 --> 00:38:51.760
It's pretty close to 1.0.

00:38:51.840 --> 00:38:53.920
So the squishing isn't that obvious.

00:38:53.950 --> 00:38:56.360
If I was working in HD or
with an anamorphic sequence,

00:38:56.360 --> 00:38:57.480
the squishing would be pretty similar.

00:38:57.480 --> 00:38:58.480
It would be pretty severe.

00:38:58.480 --> 00:38:59.740
It would be obviously wrong.

00:38:59.860 --> 00:39:03.160
So you can see, but when I turn on the
aspect ratio handling,

00:39:03.180 --> 00:39:04.980
the text looks correct.

00:39:04.980 --> 00:39:06.750
The second one is the half height fields.

00:39:06.800 --> 00:39:10.920
If I turn off support for that,
the text is twice as big as it should be.

00:39:10.920 --> 00:39:14.260
This is because I'm drawing
that text into each field,

00:39:14.270 --> 00:39:16.870
and Final Cut is
interlacing them together.

00:39:16.990 --> 00:39:19.240
So if I draw the text
at full height twice,

00:39:19.240 --> 00:39:21.120
it's going to be twice
as tall as it should be.

00:39:21.240 --> 00:39:23.980
So I need to adjust that,
draw my text at half height

00:39:24.310 --> 00:39:27.260
into each field so that when
the two fields are combined,

00:39:27.260 --> 00:39:28.730
it looks correct.

00:39:28.820 --> 00:39:30.260
And this third one is render scale.

00:39:30.260 --> 00:39:34.560
And this one is something a lot of people
miss because if you drop support for it,

00:39:34.580 --> 00:39:36.700
it doesn't seem like there's
any problem right away.

00:39:36.730 --> 00:39:39.150
But when you go to play back,
suddenly the text is twice as

00:39:39.150 --> 00:39:40.520
big as it's supposed to be.

00:39:40.540 --> 00:39:43.100
And this is because by default,
at the default settings,

00:39:43.140 --> 00:39:47.880
Final Cut will drop down to
half resolution during playback

00:39:47.880 --> 00:39:50.880
for an effect where it doesn't
have any profiling information.

00:39:50.880 --> 00:39:53.110
It doesn't know how fast it is.

00:39:53.570 --> 00:39:57.950
So when we drop down to half resolution
and I draw my text full height for full

00:39:57.950 --> 00:40:02.150
size into the half resolution image,
Final Cut's going to scale that image up.

00:40:02.270 --> 00:40:03.380
It's going to double it in size.

00:40:03.380 --> 00:40:05.000
The text is going to be twice as big.

00:40:05.030 --> 00:40:08.410
What I need to do is
look at my render scale,

00:40:08.410 --> 00:40:12.680
see that I'm currently
rendering at half resolution,

00:40:12.760 --> 00:40:17.240
and then draw the text smaller
so when it gets scaled up,

00:40:17.240 --> 00:40:17.370
it'll look correct.

00:40:17.370 --> 00:40:17.370
And you can see here,
that's exactly what happens.

00:40:19.450 --> 00:40:22.630
So I'm just going to go through a
couple of the features of this plug-in,

00:40:22.720 --> 00:40:25.140
which, as I said, it comes with the SDK.

00:40:25.190 --> 00:40:27.940
It's sort of a grab bag plug-in
that shows you how to do a

00:40:27.940 --> 00:40:31.440
lot of things that people have
asked about on the mailing list.

00:40:31.570 --> 00:40:34.740
So as I said,
this is a fairly simple title crawl.

00:40:34.800 --> 00:40:36.000
It's a generator.

00:40:36.030 --> 00:40:41.410
One nice thing about this is that the
title crawl animation takes up the

00:40:41.750 --> 00:40:43.340
duration of the item in the timeline.

00:40:43.340 --> 00:40:46.000
So at the first frame,
my text is all the way at

00:40:46.000 --> 00:40:47.680
the bottom of the screen.

00:40:47.730 --> 00:40:50.680
At the last frame, text is all the way at
the top of the screen.

00:40:50.700 --> 00:40:55.320
This is true no matter how much
time the generator takes up.

00:40:55.420 --> 00:40:59.620
If I want to trim it in the timeline,
the animation stays the same.

00:40:59.690 --> 00:41:03.370
The crawl speeds up so that I'm
at the bottom of the canvas here,

00:41:03.370 --> 00:41:05.450
I'm at the top of the canvas here.

00:41:05.600 --> 00:41:06.940
And you can see I've
got some controls here.

00:41:07.110 --> 00:41:08.680
I can make the text bigger or smaller.

00:41:08.680 --> 00:41:10.100
I can change the size.

00:41:10.130 --> 00:41:11.000
I can change the value.

00:41:11.000 --> 00:41:13.340
These are standard FxPlug controls.

00:41:13.340 --> 00:41:15.680
Control types, parameter types.

00:41:15.680 --> 00:41:18.340
I didn't have to write
any special code for this.

00:41:18.460 --> 00:41:20.580
And you can imagine there's a lot
more I could do with this text.

00:41:20.580 --> 00:41:22.770
I could change the typeface.

00:41:22.900 --> 00:41:27.040
I could maybe change the justification.

00:41:27.350 --> 00:41:29.960
I didn't want to add all of those
controls to an example plug-in.

00:41:29.960 --> 00:41:33.790
What I decided to do instead was
if you want more rich formatting,

00:41:33.800 --> 00:41:38.540
just allow the user to pick an RTF file
somewhere on the disk and use that.

00:41:38.690 --> 00:41:42.170
So you can see up here,
if I change the text type from

00:41:42.200 --> 00:41:46.050
simple text to a text file,
all of these controls go away,

00:41:46.050 --> 00:41:48.340
and they're replaced with
a new type of parameter,

00:41:48.470 --> 00:41:49.930
which allows me to choose a file.

00:41:50.100 --> 00:41:53.300
Now, this is not something that's
built into the FxPlug API.

00:41:53.300 --> 00:41:56.330
This is a custom parameter
that I created myself.

00:41:56.340 --> 00:41:59.550
So I created this UI in
Interface Builder,

00:41:59.550 --> 00:42:03.980
and you can simply, you know,
choose a text file,

00:42:04.200 --> 00:42:07.380
bring it into Final Cut, and here it is.

00:42:07.660 --> 00:42:11.770
So this is a lot more
complicated text than,

00:42:11.770 --> 00:42:11.770
um...

00:42:12.400 --> 00:42:39.400
[Transcript missing]

00:42:40.060 --> 00:42:41.540
Save it.

00:42:41.540 --> 00:42:42.880
Go back to Final Cut.

00:42:42.880 --> 00:42:45.510
Scroll down so I can see that change,
and there it is.

00:42:45.510 --> 00:42:50.440
So this was pretty powerful
and not very much code.

00:42:50.480 --> 00:42:53.670
I'm going to go back to the
slides now and talk about

00:42:53.780 --> 00:42:55.800
how the plug-in was written.

00:42:58.750 --> 00:43:00.980
So there's a couple of features
of the plug-in that people

00:43:00.980 --> 00:43:03.120
asked about in the mailing list
that this tries to demonstrate.

00:43:03.120 --> 00:43:09.000
The first is the FxTiming API,
which I believe we added in FxPlug 1.2.

00:43:09.190 --> 00:43:13.270
The Timing API gives you a lot
of information about the context

00:43:13.410 --> 00:43:15.870
of your effect and the timeline.

00:43:15.950 --> 00:43:19.820
It'll tell you the frame rate
of the timeline you're in,

00:43:19.820 --> 00:43:24.690
the start time and the duration of
your effect if you're a generator,

00:43:24.690 --> 00:43:28.530
or even if you're not,
if you're a transition, say.

00:43:28.530 --> 00:43:30.410
It'll also give you
information about your input.

00:43:30.410 --> 00:43:30.410
So if you're a filter,
you can find the properties of the

00:43:30.410 --> 00:43:30.410
clip that you've been applied to.

00:43:31.200 --> 00:43:33.830
It'll also let you convert between
timeline times and item times.

00:43:33.890 --> 00:43:37.690
If you've been applied to a clip that
doesn't have the same frame rate or

00:43:37.690 --> 00:43:42.170
field order as the timeline you're in,
this allows you to do some conversion.

00:43:43.210 --> 00:43:46.600
Now, this plug-in, you know,
obviously just uses it in a simple

00:43:46.600 --> 00:43:49.490
way just to find out the duration
of the generator and the timeline.

00:43:49.660 --> 00:43:51.100
So here's the code to do that.

00:43:51.210 --> 00:43:59.520
The first thing I do is get the FxTiming
API object from the API manager,

00:43:59.520 --> 00:44:04.150
similar to how I get
everything else in FxPlug.

00:44:04.150 --> 00:44:04.150
And then I just ask the Timing
API for the duration of my effect.

00:44:04.290 --> 00:44:06.160
And once I know how many
frames the effect takes up,

00:44:06.210 --> 00:44:10.500
it's a pretty simple calculation to
look at the current frame I'm rendering,

00:44:10.500 --> 00:44:13.990
find out how far into the
total number of frames that is,

00:44:14.070 --> 00:44:16.990
and adjust the scrolling appropriately.

00:44:17.900 --> 00:44:19.760
The next thing you may have
noticed is that this plug-in

00:44:19.760 --> 00:44:21.960
features dynamic parameter display.

00:44:21.960 --> 00:44:24.410
So you change that pop-up,
some parameters hide,

00:44:24.450 --> 00:44:27.080
some new parameters show
that were previously hidden.

00:44:27.160 --> 00:44:29.440
I'm just going to talk
about that quickly.

00:44:30.530 --> 00:44:33.630
So if you want to add a dynamic
parameter display to your plug-in,

00:44:33.630 --> 00:44:35.990
the first thing you'll probably
want to do is create some of

00:44:35.990 --> 00:44:37.400
your parameters initially hidden.

00:44:37.430 --> 00:44:42.420
And you can do this by passing the
KFX parameter flag hidden flag to

00:44:42.700 --> 00:44:47.010
when you create your parameters
inside your add parameters method.

00:44:47.600 --> 00:44:49.270
If you've got a hidden parameter,
you'll probably want

00:44:49.270 --> 00:44:50.940
to show it eventually.

00:44:50.940 --> 00:44:53.330
You can do this inside parameterChanged.

00:44:53.330 --> 00:44:56.500
Here's just an example block
of code that sort of simulates

00:44:56.500 --> 00:44:58.100
that menu tracking code.

00:44:58.100 --> 00:45:01.340
So in my parameterChanged method,
I check to see if the parameter that

00:45:01.340 --> 00:45:04.090
changed was the hideShow pop-up menu.

00:45:04.140 --> 00:45:07.600
If it was,
I get the current value of the pop-up.

00:45:07.680 --> 00:45:09.520
And if the pop-up is
currently set to hide,

00:45:09.620 --> 00:45:12.600
I'll set the hidden flag on
the parameters I want to hide.

00:45:12.670 --> 00:45:15.850
If the parameter is set to show,
I'll clear that hidden flag,

00:45:15.980 --> 00:45:20.490
which makes the parameters visible.

00:45:20.700 --> 00:45:28.900
[Transcript missing]

00:45:30.100 --> 00:45:33.100
Another thing that you noticed
was I had some custom UI,

00:45:33.100 --> 00:45:36.330
and rather than create my own custom
view class and implement the drawing

00:45:36.330 --> 00:45:39.830
method and the mouse tracking methods,
I decided I didn't need that.

00:45:39.880 --> 00:45:43.750
I just wanted to use some standard
AppKit controls and stick them in a view.

00:45:43.850 --> 00:45:46.700
And the best way to do that
is with Interface Builder.

00:45:46.770 --> 00:45:50.680
This is something that we hadn't shown
you how to do in our examples before,

00:45:50.680 --> 00:45:52.900
and this one shows you how to do it.

00:45:53.870 --> 00:45:57.800
So the first thing you do is you tell
InterfaceBuilder-- you create your nib,

00:45:57.830 --> 00:46:04.020
and you tell InterfaceBuilder
about your plug-in class.

00:46:04.020 --> 00:46:11.140
So the name of the class that implements
this plug-in is ScrollingRichText.

00:46:11.140 --> 00:46:11.140
It's just--you can see I've told
InterfaceBuilder that this class exists.

00:46:11.140 --> 00:46:11.140
It's a subclass of NSObject.

00:46:11.330 --> 00:46:13.600
I'm going to tell Interface Builder
a little bit about the class.

00:46:13.600 --> 00:46:17.180
The class is one outlet,
which is a pointer to a custom view.

00:46:17.910 --> 00:46:21.170
And two actions,
choose text file and edit text file,

00:46:21.170 --> 00:46:24.390
which correspond to those two
buttons you saw on the interface.

00:46:25.160 --> 00:46:27.590
The next thing to do is
actually create the UI.

00:46:27.600 --> 00:46:31.440
So I've added a view to my nib,
and I've dropped in two

00:46:31.440 --> 00:46:34.100
buttons and just a static text.

00:46:34.100 --> 00:46:37.000
Um, standard Cocoa controls.

00:46:38.400 --> 00:46:42.540
Now I'm just going to
wire these things up.

00:46:42.620 --> 00:46:43.280
Oh, no, I'm sorry.

00:46:43.390 --> 00:46:46.760
The next thing you want to do is
change the files owner of the nib to

00:46:46.760 --> 00:46:48.800
be an instance of your plug-in class.

00:46:48.850 --> 00:46:52.890
So now this nib is owned by an instance
of the scrolling rich text class.

00:46:53.670 --> 00:46:55.360
Now I can start wiring things up.

00:46:55.480 --> 00:46:59.930
So I'll connect the file owner's
outlet to the view I've created.

00:46:59.940 --> 00:47:05.820
So this scrolling rich text's custom view
points to the view that I've created.

00:47:06.240 --> 00:47:08.120
And similarly,
I'll connect the buttons to the

00:47:08.120 --> 00:47:09.860
actions of the file's owner.

00:47:09.860 --> 00:47:12.790
So the Choose button will trigger
the Choose Text File action.

00:47:12.970 --> 00:47:16.140
The Edit button will trigger
the Edit Text File action.

00:47:16.670 --> 00:47:18.600
Now I'm ready to write
just a little bit of code.

00:47:18.600 --> 00:47:21.090
Here's the declaration
for my plug-in class.

00:47:21.100 --> 00:47:24.220
You can see it's a
FxCustomParameterView host

00:47:24.220 --> 00:47:26.600
because it does have custom UI.

00:47:26.620 --> 00:47:30.550
And there's the outlet and the actions
that I added in Interface Builder.

00:47:32.390 --> 00:47:36.240
Now when I go to my Add My Parameters,
I'll create a custom parameter.

00:47:36.280 --> 00:47:38.300
I'll pass the custom UI flag.

00:47:38.340 --> 00:47:42.300
And you can see the default value of
this parameter is just an empty NSString.

00:47:42.300 --> 00:47:45.300
Darrin talked about when you're
creating custom parameters,

00:47:45.300 --> 00:47:49.370
you can create your own
class for the data type,

00:47:49.370 --> 00:47:52.290
and you can do anything you want
as long as it conforms to NSCoding.

00:47:52.300 --> 00:47:56.780
One of the nice things about FxPlug is
that AppKit actually ships with a lot of

00:47:56.780 --> 00:48:01.300
classes that conform to NSCoding that you
can use directly if they meet your needs.

00:48:01.360 --> 00:48:05.890
So if you want to use NSString, NSNumber,
NSData, you can.

00:48:05.900 --> 00:48:10.260
You can just create a custom parameter,
use that as the data type,

00:48:10.450 --> 00:48:13.250
and you don't have to write
any serialization code.

00:48:14.530 --> 00:48:18.690
So now in my createViewForParm method,
this is when I actually create-- this is

00:48:18.690 --> 00:48:23.000
when the host asks me to create the view
that'll be used for the custom parameter.

00:48:23.170 --> 00:48:25.040
This is pretty easy,
'cause I did all the work

00:48:25.040 --> 00:48:26.940
in InterfaceBuilder already.

00:48:27.030 --> 00:48:32.140
So if I'm being asked to create
the UI for my text file path param,

00:48:32.290 --> 00:48:36.940
I'll load the Nib for that
custom view I created,

00:48:37.190 --> 00:48:38.540
and I'll pass myself as the owner.

00:48:38.540 --> 00:48:40.660
Remember,
the owner of the Nib was an instance

00:48:40.740 --> 00:48:43.220
of the scrolling rich text plugin.

00:48:43.370 --> 00:48:47.470
This plugin is that class,
so I just pass myself.

00:48:47.630 --> 00:48:50.900
And when the Nib is loaded,
the outlets and the actions are wired up.

00:48:50.900 --> 00:48:54.100
So by the time the Nib is loaded,
my custom view pointer points

00:48:54.100 --> 00:48:56.000
to a valid NSView instance.

00:48:56.000 --> 00:48:58.810
So all I have to do is return it,
and I'm done.

00:48:59.500 --> 00:49:05.130
And I'll just go back to the demo machine
quickly to show you that one more time.

00:49:06.210 --> 00:49:11.390
You can see I've got my
standard controls here.

00:49:11.490 --> 00:49:13.860
If I change the menu,
the plug-in's parameter

00:49:13.860 --> 00:49:17.070
change method is called,
and it responds by setting the

00:49:17.070 --> 00:49:20.740
hidden flag on some parameters,
clearing them on others.

00:49:20.860 --> 00:49:23.940
So this new custom
parameter is now visible,

00:49:24.020 --> 00:49:26.440
and here's the UI that
I created in Interface Builder.

00:49:26.530 --> 00:49:30.930
Everything is wired up
with very little code.

00:49:31.560 --> 00:49:33.000
With that,
I'm going to hand it over to Pete Warden,

00:49:33.000 --> 00:49:37.380
who's going to talk about advanced
GPU topics inside Final FxPlug.

00:49:41.400 --> 00:49:42.830
Thanks, Paul.

00:49:42.840 --> 00:49:44.600
So I'm Pete Warden.

00:49:44.600 --> 00:49:49.070
I've been doing a lot of
filter work over the years.

00:49:49.300 --> 00:49:53.380
And the particular advanced topics
I'm going to be talking about are the

00:49:53.380 --> 00:49:55.540
ones that relate to GPU programming.

00:49:55.550 --> 00:49:58.970
In particular,
all the stuff you need to do to use

00:49:58.970 --> 00:50:02.930
raw OpenGL to write GPU plug-ins.

00:50:03.440 --> 00:50:04.390
Why is it so tricky?

00:50:04.590 --> 00:50:07.640
OpenGL is not designed
for image processing.

00:50:07.680 --> 00:50:09.990
It's an API that's
designed for 3D rendering.

00:50:10.250 --> 00:50:12.900
It's possible to do
image processing with it.

00:50:12.950 --> 00:50:15.640
It's possible to use the
GPU for image processing.

00:50:15.670 --> 00:50:19.500
But you have to use some fairly
advanced and obscure features,

00:50:19.560 --> 00:50:22.430
which have been hard to get
documentation and examples on.

00:50:23.380 --> 00:50:26.090
The first thing I should say is
that Apple has recognized this

00:50:26.140 --> 00:50:31.060
problem over the years and actually
has a couple of very nice APIs for

00:50:31.060 --> 00:50:35.750
doing a lot of GPU processing,
like Quartz Composer and Core Image.

00:50:35.820 --> 00:50:40.270
And we have quite a few developers who
are using these pretty successfully to

00:50:40.270 --> 00:50:44.810
get the performance advantage that you
can get out of the GPU without having to

00:50:44.850 --> 00:50:49.700
delve quite so deeply into some of the
dark and dusty corners of the OpenGL API.

00:50:49.700 --> 00:50:52.420
But there's still a lot of valid
reasons why you may need to write

00:50:52.420 --> 00:50:55.550
direct... ...directly to OpenGL.

00:50:55.550 --> 00:51:00.000
So to answer developers' questions,
we actually put up one of our

00:51:00.140 --> 00:51:06.400
internal filters into the SDK,
demonstrating the techniques that

00:51:06.400 --> 00:51:11.550
we use to get very fast image
processing working on the GPU.

00:51:14.200 --> 00:51:17.200
Probably the thing that we get
most questions about that's

00:51:17.290 --> 00:51:22.620
most confusing is how you do
intermediate rendering on the GPU.

00:51:22.620 --> 00:51:24.420
On the CPU, it's very simple.

00:51:24.420 --> 00:51:28.660
You have a system memory bitmap that you
can just access as a piece of memory.

00:51:28.660 --> 00:51:31.520
On the GPU,
you need something where you can

00:51:31.520 --> 00:51:35.400
actually render into a texture
and then use that texture as a

00:51:35.400 --> 00:51:38.010
source for subsequent operation.

00:51:39.320 --> 00:51:42.690
Traditionally, that meant using pbuffers.

00:51:42.690 --> 00:51:46.710
There are some other
alternatives like FBOs that I'm

00:51:46.710 --> 00:51:47.730
going to briefly talk about.

00:51:47.740 --> 00:51:55.110
We don't have any help from the host for
creating or managing these objects yet.

00:51:55.320 --> 00:51:57.200
That's something we've
had a lot of requests for,

00:51:57.420 --> 00:52:00.400
and we're definitely looking
at what we can do there.

00:52:00.420 --> 00:52:03.200
But for now,
you should use the sample code that

00:52:03.220 --> 00:52:07.060
we ship and actually look at the
pbuffer code that I'm going to talk

00:52:07.110 --> 00:52:09.120
about a bit and use that as a basis.

00:52:09.330 --> 00:52:11.630
for your own plugins.

00:52:12.320 --> 00:52:15.200
So what is a P-Buffer?

00:52:15.220 --> 00:52:17.640
It's a way of rendering into a texture.

00:52:17.690 --> 00:52:21.090
The key attribute is
that it stays in VRAM.

00:52:21.470 --> 00:52:23.400
Everything's still happening on the card.

00:52:23.400 --> 00:52:27.380
It's very tempting when you're first
looking at doing GPU programming to

00:52:27.450 --> 00:52:31.750
try and pull down image data from the
card to do just some CPU processing

00:52:31.880 --> 00:52:37.050
on it to get some intermediate images,
but that completely kills performance.

00:52:37.060 --> 00:52:40.730
You lose all of the parallelism
that you can get from running

00:52:40.730 --> 00:52:42.180
both CPU and GPU code.

00:52:42.720 --> 00:52:44.320
So, I think that's it.

00:52:46.060 --> 00:52:50.890
FBOs are very similar
under the hood to PBuffers,

00:52:50.890 --> 00:52:55.880
but they offer a much more modern and,
in a lot of ways,

00:52:55.880 --> 00:52:57.770
easier to use interface.

00:52:58.020 --> 00:53:03.660
And we're moving over to using FBOs,
but we still have a lot

00:53:03.660 --> 00:53:09.930
of code using PBuffers,
and our example will show you how

00:53:09.930 --> 00:53:09.930
to use PBuffers to do this stuff.

00:53:11.750 --> 00:53:16.040
So this is the list of functions to
do with pbuffers that we actually

00:53:16.090 --> 00:53:17.740
give you in the sample code.

00:53:17.810 --> 00:53:21.580
I'm not going to spend too
much time talking about them,

00:53:21.580 --> 00:53:21.580
but...

00:53:21.960 --> 00:53:25.480
The create and destroy functions are
hopefully fairly self-explanatory.

00:53:25.530 --> 00:53:28.900
That's how you create these images that
you're going to be using on the GPU.

00:53:28.900 --> 00:53:34.760
When you want to actually
start drawing into the texture,

00:53:34.830 --> 00:53:37.630
you need to redirect all
of your GL commands into

00:53:37.740 --> 00:53:40.160
that area of texture memory.

00:53:40.210 --> 00:53:43.810
And you do that by calling pbuffer begin,
which under the hood does the

00:53:43.820 --> 00:53:47.810
right commands to redirect the

00:53:48.030 --> 00:53:53.170
Subsequent GL commands that you're going
to issue to draw into that area of VRAM.

00:53:53.180 --> 00:53:56.540
When you're done drawing,
when you've done all of

00:53:56.540 --> 00:53:58.940
your drawing operations,
you want to end up in that texture,

00:53:58.940 --> 00:54:01.770
you call pbuffer end,
and then you go back to drawing

00:54:01.770 --> 00:54:05.160
into whichever context you were
actually in before you started

00:54:05.260 --> 00:54:06.970
drawing into the pbuffer.

00:54:06.980 --> 00:54:13.300
When you want to use that image that
you've drawn into as a texture source,

00:54:13.300 --> 00:54:16.990
for example,
for a fragment program or other shader,

00:54:16.990 --> 00:54:19.080
you call pbuffer use.

00:54:19.140 --> 00:54:23.940
And this is very,
very similar to the standard

00:54:23.950 --> 00:54:30.830
bind and enable on an FxPlug,
an FxTexture, or just to binding and

00:54:30.830 --> 00:54:33.780
enabling a raw GL texture.

00:54:34.000 --> 00:54:36.960
You can use it exactly the same way
if you've got multiple textures.

00:54:36.980 --> 00:54:40.080
If you've got multiple texture units,
you can set GL active texture to

00:54:40.080 --> 00:54:41.980
control which unit you're going to use.

00:54:41.980 --> 00:54:48.690
It looks exactly like
a normal GL texture.

00:54:49.690 --> 00:54:52.950
The next most asked topic is shaders.

00:54:53.330 --> 00:54:57.190
How do you write a pixel shader to
do some interesting operation that

00:54:57.190 --> 00:55:01.500
isn't supported by the standard
GL fixed function pipeline?

00:55:02.070 --> 00:55:05.530
We've got a lot of mileage
out of our fragment program.

00:55:05.540 --> 00:55:13.220
Again, this is kind of similar to the
difference between PBuffers and FBOs.

00:55:13.650 --> 00:55:17.360
GLSL is a much higher level
language that has been introduced

00:55:17.450 --> 00:55:19.440
over the past couple of years.

00:55:19.440 --> 00:55:21.960
We're starting to use it.

00:55:21.960 --> 00:55:25.000
We're having a lot of success with it.

00:55:25.160 --> 00:55:28.540
Probably for new developers,
it would be a good idea

00:55:28.540 --> 00:55:30.600
to definitely consider it.

00:55:30.600 --> 00:55:31.700
It's a lot easier to get into.

00:55:32.180 --> 00:55:36.300
But we still have some reasons why
we go back to our fragment program.

00:55:36.300 --> 00:55:38.500
For example,
running on very old hardware.

00:55:38.930 --> 00:55:41.910
Some of the very early ATI cards,
which can run pixel shaders,

00:55:42.240 --> 00:55:46.070
have very low limits on the number of
instructions they can actually run.

00:55:46.070 --> 00:55:48.480
They can only run 64
arithmetic instructions,

00:55:48.500 --> 00:55:49.250
for example.

00:55:49.260 --> 00:55:53.080
And it's a lot easier to predict
if your program is going to run

00:55:53.180 --> 00:55:57.400
on that sort of hardware if you're
writing in something that looks

00:55:57.400 --> 00:56:01.980
more like Assembler and has a closer
correspondence to those actual programs.

00:56:02.000 --> 00:56:04.910
actual limits.

00:56:05.450 --> 00:56:09.260
In the code sample, we have just a couple
of helper functions.

00:56:09.330 --> 00:56:14.070
I mean, the first thing you should always
remember is always check to see that

00:56:14.070 --> 00:56:16.480
your program can actually be loaded.

00:56:16.570 --> 00:56:19.830
Because of these limits,
programs that run on one card

00:56:19.830 --> 00:56:23.330
may not run on a whole bunch
of other cards that you test.

00:56:23.330 --> 00:56:26.330
So it's going to be very
hard to tell unless you have

00:56:26.660 --> 00:56:30.510
some kind of error reporting,
possibly from your QA or your users,

00:56:30.510 --> 00:56:33.330
to tell why things are going wrong.

00:56:33.340 --> 00:56:38.500
Unless you have some explicit checking to
see if you can run the fragment program.

00:56:38.630 --> 00:56:41.600
And quite often what we
can do in those cases is if

00:56:41.600 --> 00:56:45.730
you've got CPU implementation,
just fall back to actually running

00:56:45.810 --> 00:56:49.270
the CPU implementation in that
case instead if you're running

00:56:49.270 --> 00:56:51.280
on hardware that isn't capable.

00:56:54.000 --> 00:58:49.900
[Transcript missing]

00:58:50.640 --> 00:58:53.630
If you really, really, really,
really need them,

00:58:53.630 --> 00:58:55.930
or you've got some legacy
code that relies on them,

00:58:55.990 --> 00:58:58.800
it is possible to emulate at
the cost of some performance.

00:58:58.820 --> 00:59:03.100
And the directional blur sample
code that we ship with the X SDK now

00:59:03.600 --> 00:59:08.720
demonstrates how to do the four-tap
filtering within your fragment

00:59:08.720 --> 00:59:11.340
program to emulate bilinear filtering.

00:59:12.400 --> 00:59:15.740
We don't have a sample that
demonstrates how to emulate blending,

00:59:16.040 --> 00:59:20.440
but the basic idea is that you
draw one polygon into a buffer,

00:59:20.810 --> 00:59:24.320
and then you finalize that P buffer,
and then you use that as a texture source

00:59:24.320 --> 00:59:27.640
to do the blending of the next polygon.

00:59:27.640 --> 00:59:33.170
So you end up with a pass per polygon,
which is very inefficient

00:59:33.170 --> 00:59:35.850
from the performance side.

00:59:38.410 --> 00:59:43.600
So Paul mentioned already that
to give users good performance,

00:59:43.600 --> 00:59:47.790
we use low resolution proxies.

00:59:47.790 --> 00:59:51.860
And usually that's just a
case of scaling parameters.

00:59:51.900 --> 00:59:54.570
If you're just drawing into a
single context and you don't

00:59:54.570 --> 01:00:01.220
have any intermediate buffers,
you just can apply the scale and possible

01:00:01.220 --> 01:00:02.650
offset if there's any fields involved.

01:00:03.480 --> 01:00:07.980
But when you've got intermediate buffers,
when you've got p-buffers, it's very,

01:00:07.980 --> 01:00:12.200
very easy, and I've made this error
myself quite a few times,

01:00:12.240 --> 01:00:16.880
to not take that into account when you're
doing your intermediate buffer rendering.

01:00:16.880 --> 01:00:21.150
So you'll get a low-res input image,
you'll accidentally scale it up into

01:00:21.230 --> 01:00:25.470
a full-size intermediate p-buffer,
and then do all of your processing

01:00:25.470 --> 01:00:29.060
on that large intermediate p-buffer,
and then you'll end up

01:00:29.120 --> 01:00:32.980
scaling it down at the end,
and the results will look fine.

01:00:33.100 --> 01:00:36.640
But the users won't be getting
the performance that they really

01:00:36.640 --> 01:00:40.280
should be getting when you go
down to a low-resolution proxy.

01:00:40.280 --> 01:00:43.240
So just kind of keep an eye out for that.

01:00:43.240 --> 01:00:46.760
If you're jumping down to low resolution
and your plugin isn't speeding up,

01:00:46.760 --> 01:00:49.540
and you're using intermediate buffers,
that's something you

01:00:49.920 --> 01:00:51.260
really should be checking.

01:00:51.260 --> 01:00:54.590
So those are the topics
I'm going to cover.

01:00:54.630 --> 01:00:58.760
I'm just going to hand over
to Darren now to wrap up.

01:01:02.600 --> 01:01:04.030
Thank you very much, Pete.

01:01:04.030 --> 01:01:06.300
Okay,
if after WWDC you still have questions,

01:01:06.310 --> 01:01:08.530
well, first,
there will be a lab after this,

01:01:08.530 --> 01:01:10.720
which I'll get to in a second,
but after WWDC,

01:01:10.730 --> 01:01:14.010
you can go to the ProApps Dev Mailing
Lists and add yourself to that and

01:01:14.010 --> 01:01:17.920
search the archives and see if your
question's already been answered.

01:01:17.920 --> 01:01:22.600
You can do that at lists.apple.com,
and it's a really great group of people.

01:01:22.600 --> 01:01:25.790
There are a lot of developers who are
currently shipping products on it,

01:01:25.910 --> 01:01:28.950
and they're very helpful,
very useful for answering questions when

01:01:28.950 --> 01:01:30.960
we can't or when we don't have the time.

01:01:32.600 --> 01:01:35.190
If you have questions of a proprietary
nature that you don't want your

01:01:35.200 --> 01:01:38.100
potential competitors to see,
you can send them to the

01:01:38.100 --> 01:01:42.390
ProAppsdk@group.apple.com address,
and that'll go to me and

01:01:42.390 --> 01:01:44.640
Pete and Paul and a couple
other people internal to Apple,

01:01:44.680 --> 01:01:45.720
but other people won't see it.

01:01:45.740 --> 01:01:50.000
If you want to see the sample
code for porting your plug-ins

01:01:50.000 --> 01:01:55.530
from After Effects to FxPlug,
that's available at developer.apple.com

01:01:55.900 --> 01:01:58.200
slash WWDC slash attendee.

01:01:59.920 --> 01:02:02.950
As I said,
there's a lab today from two-- there

01:02:02.950 --> 01:02:06.630
are actually two labs starting at 2
o'clock in the Graphics and Media Lab.

01:02:06.770 --> 01:02:09.950
The Final Cut Pro lab,
you can get some help with your

01:02:09.950 --> 01:02:13.740
Final Cut Pro XML questions,
and the FxPlug Effects Lab.

01:02:13.920 --> 01:02:18.840
So in summary, FxPlug 1.2.2 and 1.2.3
have some new features.

01:02:18.840 --> 01:02:22.940
The FxColorImageInfo API, excuse me,
FxImageColorInfo API.

01:02:22.940 --> 01:02:25.050
The Xcode templates,
you should be able to find

01:02:25.050 --> 01:02:26.380
those again and use them.

01:02:26.380 --> 01:02:29.380
And of course, improved support in
Motion and Final Cut Pro.

01:02:29.380 --> 01:02:31.880
Please join the mailing list.

01:02:31.920 --> 01:02:34.060
Bring us your questions.

01:02:34.060 --> 01:02:35.400
Let us help you.

01:02:35.530 --> 01:02:39.390
And if you can, optimize for hardware and
software rendering because

01:02:39.390 --> 01:02:39.390
your users will appreciate it.
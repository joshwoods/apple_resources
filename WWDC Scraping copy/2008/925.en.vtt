WEBVTT

00:00:20.340 --> 00:00:22.000
Good morning.

00:00:22.150 --> 00:00:26.030
Welcome to session 925,
Debugging and Profiling

00:00:26.030 --> 00:00:28.140
Your iPhone Application.

00:00:28.250 --> 00:00:29.240
My name is Dave Payne.

00:00:29.240 --> 00:00:32.700
I'm the manager of the
Analysis Tools team at Apple.

00:00:32.840 --> 00:00:36.220
Now, perhaps you went to the
Developer Tools State of the

00:00:36.220 --> 00:00:41.260
Union address on Monday afternoon
where Max Druckmann in the Dashcode

00:00:41.270 --> 00:00:47.970
demo built an application that he
referred to as Where Would Dave Go?

00:00:49.150 --> 00:00:51.240
So that's easy.

00:00:51.240 --> 00:00:55.720
My colleagues and I are very excited
this morning to tell you about debugging

00:00:55.720 --> 00:00:58.820
and profiling your iPhone applications.

00:00:58.820 --> 00:01:05.310
We'll be doing this with both the iPhone
itself as well as the iPhone Simulator.

00:01:05.310 --> 00:01:08.300
We'll start out with an
overview of the tools,

00:01:08.300 --> 00:01:11.000
then get into the heart of the content.

00:01:11.000 --> 00:01:15.520
Along the way,
we'll look at specific situations

00:01:15.520 --> 00:01:19.860
that are fairly common to
run into in development.

00:01:19.860 --> 00:01:25.390
So debugging with Objective-C properties,
finding buffer overruns,

00:01:25.690 --> 00:01:31.110
finding over-released objects,
and profiling application launch time.

00:01:32.010 --> 00:01:36.240
The primary tools that you'll use for
debugging and profiling for your iPhone

00:01:36.240 --> 00:01:41.080
applications are the same as those that
you would use for your Mac applications.

00:01:41.270 --> 00:01:46.940
So the Xcode IDE,
the Instruments Analysis Tool,

00:01:47.090 --> 00:01:50.200
and the Shark Profiling Tool.

00:01:50.680 --> 00:01:54.000
As you know,
Xcode provides a full graphical source

00:01:54.000 --> 00:01:58.980
code debugging environment that gives
great ways to view your variable

00:01:58.980 --> 00:02:04.700
values and modify those both in a
variable view window through data tips.

00:02:04.840 --> 00:02:07.820
It's got full debug breakpoint
support with conditional

00:02:08.300 --> 00:02:10.700
breakpoints and breakpoint commands.

00:02:12.100 --> 00:02:14.920
Debugging in line with
your source editor,

00:02:15.290 --> 00:02:20.160
the mini debugger to not leave
your application environment

00:02:20.160 --> 00:02:22.150
when you're debugging.

00:02:23.040 --> 00:02:27.360
Instruments is a great way to visualize
the behavior and the performance of

00:02:27.360 --> 00:02:30.060
your application or your entire system.

00:02:30.190 --> 00:02:34.360
It can collect multiple tracks of
performance data at the same time,

00:02:34.490 --> 00:02:40.940
lets you filter in on time slices,
you can correlate events between

00:02:40.940 --> 00:02:47.310
the different event tracks,
and just sort down through and really

00:02:47.310 --> 00:02:50.290
hone in on the information you need.

00:02:51.500 --> 00:02:55.340
Shark is a great
CPU profiling application.

00:02:55.340 --> 00:02:57.700
It's got very low overhead.

00:02:57.700 --> 00:03:04.740
It can profile down to the source line
level or even the instruction level.

00:03:04.740 --> 00:03:10.120
It supports time profile on
your iPhone applications.

00:03:11.020 --> 00:03:14.120
So all of these applications,
all these tools are available

00:03:14.230 --> 00:03:18.700
for both your Mac applications
and your iPhone applications.

00:03:18.860 --> 00:03:21.940
We've got some additional tools as well.

00:03:22.090 --> 00:03:26.610
So we have the DTrace Scriptable
Dynamic Tracing Facility that gives you a

00:03:26.610 --> 00:03:33.030
lot of power to go in and trace anything
in your application or even the kernel.

00:03:33.330 --> 00:03:37.900
We've got a debugging malloc
library called guard malloc that

00:03:37.900 --> 00:03:40.520
lets you find buffer overruns.

00:03:40.520 --> 00:03:44.620
There's a facility in the
Cocoa framework called NSZombie that

00:03:44.620 --> 00:03:47.880
lets you find overreleased objects.

00:03:48.040 --> 00:03:51.330
And we've got a variety of command
line tools that you can run in

00:03:51.400 --> 00:03:57.000
a terminal window to sample your
application or look at its memory usage.

00:03:57.950 --> 00:03:59.850
So these are all great.

00:03:59.930 --> 00:04:04.440
They really help you look at
things on your Mac applications,

00:04:04.440 --> 00:04:06.300
but they're not available on the iPhone.

00:04:06.300 --> 00:04:09.970
Some of them take too much
system resources to be

00:04:09.970 --> 00:04:12.140
able to run on the iPhone.

00:04:12.140 --> 00:04:16.540
Or in the case of the command line tools,
we don't have a terminal

00:04:16.540 --> 00:04:18.940
environment available there.

00:04:19.400 --> 00:04:24.100
But there is a solution that you
can use the full suite of tools

00:04:24.300 --> 00:04:26.520
in the iPhone app simulator.

00:04:26.640 --> 00:04:30.880
So you can use these techniques
on your iPhone applications,

00:04:30.880 --> 00:04:33.090
and we'll show how to do that.

00:04:33.820 --> 00:04:35.650
So how does that come about?

00:04:35.840 --> 00:04:38.740
Well, of course, Mac applications,
the entire stack you've

00:04:38.800 --> 00:04:43.460
built as a Mac application,
you're running on the Cocoa frameworks,

00:04:43.630 --> 00:04:48.040
the Mac OS X system libraries,
the Mac OS X kernel, all on your Mac.

00:04:48.620 --> 00:04:52.080
Your iPhone applications
running on the device,

00:04:52.350 --> 00:04:54.560
they're all built for that environment.

00:04:54.700 --> 00:04:57.680
Your application is working
with the Cocoa Touch frameworks,

00:04:57.680 --> 00:05:01.440
the iPhone OS system libraries,
the iPhone OS kernel,

00:05:01.440 --> 00:05:05.570
on the iPhone or the iPod touch.

00:05:06.540 --> 00:05:12.020
But the iPhone Simulator provides
kind of a hybrid environment that

00:05:12.120 --> 00:05:17.260
you have your application built as
if it was actually a Mac application.

00:05:17.260 --> 00:05:20.020
For example, built for x86.

00:05:20.020 --> 00:05:23.650
It's running on a version of
the Cocoa Touch frameworks

00:05:23.920 --> 00:05:26.120
that are built for x86.

00:05:26.120 --> 00:05:29.940
But then these are running on
the Mac OS X system libraries,

00:05:29.940 --> 00:05:33.780
the Mac OS X kernel,
interacting with the Mac OS X daemons.

00:05:34.720 --> 00:05:38.690
And so because it's kind of an
iPhone app that's really running

00:05:38.940 --> 00:05:42.820
as a Macintosh application,
that's how the tools are then

00:05:42.820 --> 00:05:45.320
able to apply in this situation.

00:05:45.400 --> 00:05:49.530
So let's go ahead and take a look
at debugging with the iPhone SDK.

00:05:49.640 --> 00:05:53.820
I'd like the debugger team manager,
Chris Friesen, to take you through that.

00:05:53.900 --> 00:05:55.570
Thanks, Dave.

00:05:58.800 --> 00:05:59.600
Good morning, everyone.

00:05:59.600 --> 00:06:03.140
I'm Christopher Friesen,
manager of the debugger team.

00:06:03.140 --> 00:06:06.200
Now, with the iPhone SDK,
Apple has delivered to us the

00:06:06.520 --> 00:06:13.090
desktop development experience
for your mobile applications.

00:06:13.090 --> 00:06:13.090
Now, this means that

00:06:15.250 --> 00:06:18.730
that the debugging interface is the same
for your mobile applications as it is

00:06:18.860 --> 00:06:21.890
for developing Cocoa Apps for Mac OS X.

00:06:21.930 --> 00:06:24.420
This means that you get
in-editor debugging,

00:06:24.490 --> 00:06:29.020
crash catching, data tips,
data formatters, and breakpoint actions.

00:06:30.610 --> 00:06:32.860
Now,
debugging in the simulator and debugging

00:06:33.040 --> 00:06:35.880
on your device have some differences.

00:06:35.940 --> 00:06:38.630
As Dave just said,
when you're debugging in the simulator,

00:06:38.840 --> 00:06:40.400
you're doing an API simulation.

00:06:40.430 --> 00:06:43.680
You're not actually
emulating any hardware.

00:06:44.520 --> 00:06:46.550
Now,
we also only have guard malloc support

00:06:46.940 --> 00:06:49.840
when you're debugging in the simulator.

00:06:49.840 --> 00:06:52.840
And if you want to look at your
crash logs or system console,

00:06:52.940 --> 00:06:56.680
you'd go to your console app
as you would on Mac OS X.

00:06:57.520 --> 00:07:01.560
Now, if you're using properties
in your simulator app,

00:07:01.580 --> 00:07:06.400
it requires fully declared instance
variables in the interface of that class.

00:07:06.640 --> 00:07:09.040
And we'll talk more about that later.

00:07:13.370 --> 00:07:16.190
To debug on your iPhone,
it's as simple as selecting

00:07:16.700 --> 00:07:21.290
the device in the overview
popup in Xcode of your project.

00:07:21.810 --> 00:07:24.520
And to access the system
console and crash logs,

00:07:24.550 --> 00:07:28.130
you'd visit those tabs
in Xcode's organizer.

00:07:28.260 --> 00:07:30.910
They're called console and crash logs.

00:07:32.200 --> 00:07:36.060
As you use properties on the device,
you don't have to declare

00:07:36.110 --> 00:07:39.340
the instance variables in the
interface of your classes.

00:07:39.460 --> 00:07:42.410
We'll talk more about how that
might be a problem later if you

00:07:42.410 --> 00:07:44.100
want to run on the simulator.

00:07:44.250 --> 00:07:48.650
And again, remember that you have limited
resources on the phone compared to

00:07:48.650 --> 00:07:51.040
running in the simulator on your Mac.

00:07:54.240 --> 00:07:57.350
Now we're going to talk
about Objective-C properties.

00:07:57.410 --> 00:07:58.680
Quick overview.

00:07:58.750 --> 00:08:03.100
Properties are an explicit specification
of how accessor methods behave.

00:08:03.220 --> 00:08:05.650
For instance, are you retaining a value?

00:08:05.710 --> 00:08:08.770
Are you making a copy of the
value that's getting set?

00:08:08.770 --> 00:08:11.600
Or are you simply doing
a simple assignment?

00:08:11.840 --> 00:08:15.780
The compiler can then automatically
synthesize these accessors for you.

00:08:15.780 --> 00:08:21.030
So you don't have to remember
how to code for these different

00:08:21.030 --> 00:08:23.980
types of accessor behaviors.

00:08:27.150 --> 00:08:29.860
Here's an instance of a
declared instance variable.

00:08:29.900 --> 00:08:32.850
Of course, the instance variable
is in the interface.

00:08:32.940 --> 00:08:35.910
Here it's called pwordless data.

00:08:35.980 --> 00:08:39.000
When it's undeclared,
you don't have to declare it.

00:08:39.530 --> 00:08:43.860
Now, when it's undeclared,
this will only run on the iPhone.

00:08:43.870 --> 00:08:46.430
If you switch to the
simulator and try and build,

00:08:46.450 --> 00:08:48.400
you'll get some compiler errors.

00:08:48.530 --> 00:08:50.620
So if you're coding,
you really want to declare all

00:08:50.760 --> 00:08:52.160
of your instance variables.

00:08:52.290 --> 00:08:56.770
And that way,
you can switch back and forth between

00:08:56.770 --> 00:09:03.010
the simulator and the iPhone and be
able to use some of the performance

00:09:03.010 --> 00:09:03.010
tools that aren't available when
you're debugging on the device.

00:09:05.520 --> 00:09:08.780
I might be thinking,
if the compiler is creating

00:09:08.840 --> 00:09:12.060
these accessors for me,
how do I break on them?

00:09:12.170 --> 00:09:15.500
How do I view the actual
values and how do I call these

00:09:15.500 --> 00:09:17.720
setters and getters myself?

00:09:19.360 --> 00:09:26.780
To set a breakpoint on a setter
when your property is defined

00:09:26.780 --> 00:09:26.780
as @synthesized P wordless data.

00:09:27.250 --> 00:09:31.230
To break up the setter,
you'd set a breakpoint at set,

00:09:31.330 --> 00:09:39.420
and then you'd capitalize
the first letter of the first

00:09:39.420 --> 00:09:39.420
word of the instance variable,
in this case, p, wordless data,

00:09:39.420 --> 00:09:39.420
ending with a semicolon.

00:09:39.940 --> 00:09:42.220
To break on the getter,
you'd set a symbolic breakpoint

00:09:42.220 --> 00:09:45.530
on the method pwordlessData.

00:09:47.400 --> 00:09:53.670
Now you can also create a property where
you've mapped the instance variable name

00:09:53.670 --> 00:09:57.600
to a different name that you're going
to actually use in your source code.

00:09:57.600 --> 00:10:00.870
So in this case,
the instance variable is pwordlessdata,

00:10:00.870 --> 00:10:04.230
but we've mapped that to wordlessdata,
so we can just type

00:10:04.240 --> 00:10:06.010
wordlessdata in our source.

00:10:06.070 --> 00:10:09.530
That means the accessors are
now based on wordlessdata,

00:10:09.580 --> 00:10:14.090
so to break on the setter,
we set a break -- symbolic break point

00:10:14.090 --> 00:10:19.050
at set capital W wordlessdata colon,
and to break at the getter,

00:10:19.130 --> 00:10:22.080
it's simply breaking on wordlessdata.

00:10:24.080 --> 00:10:27.750
Now here we've broken at the setter.

00:10:27.800 --> 00:10:29.760
This is what our stack
trace would look like.

00:10:29.760 --> 00:10:33.760
We see that we've broken on
set word list data colon.

00:10:34.060 --> 00:10:36.150
Now when that's selected,

00:10:37.180 --> 00:10:41.040
In the stack frame view,
in your source code,

00:10:41.040 --> 00:10:48.100
the PC will actually show the PC arrow
at the end of the implementation.

00:10:48.220 --> 00:10:49.880
for that particular class.

00:10:49.950 --> 00:10:54.140
So you'll need to look at the source--you
will need to look at the stack in order

00:10:54.140 --> 00:10:56.450
to see exactly why you've broken there.

00:10:56.640 --> 00:10:57.930
and what the method name is.

00:10:58.160 --> 00:11:02.120
Now if you go up a stack frame,
you'll see that we have in fact stopped

00:11:02.120 --> 00:11:06.910
where we're using the properties
dot notation to set the instance

00:11:06.910 --> 00:11:09.780
variable for wordless data to a value.

00:11:11.690 --> 00:11:14.840
How do you go about viewing
some of these values?

00:11:14.840 --> 00:11:18.200
Now, if you happen to still be using
undeclared instance variables,

00:11:18.360 --> 00:11:23.240
they won't show up whenever you turn
open the variable in the variables view.

00:11:23.240 --> 00:11:25.930
If they are declared,
then they do show up.

00:11:26.240 --> 00:11:29.800
You can still access the values
by calling an expression in

00:11:29.800 --> 00:11:33.140
Xcode's debugger console,
simply using the normal

00:11:33.140 --> 00:11:36.100
Objective-C bracket notation.

00:11:36.180 --> 00:11:39.700
So in this case, in the last line there,
it says we're going to evaluate the

00:11:39.700 --> 00:11:45.480
expression in Xcode's debugger console,
PO, open brace, self, word list data,

00:11:45.480 --> 00:11:46.650
close brace.

00:11:46.650 --> 00:11:49.020
And that'll print that
instance variable's value.

00:11:49.020 --> 00:11:55.510
Now let's do a quick demo of
Objective-C properties and crash logs.

00:12:02.280 --> 00:12:04.530
We can switch to Demo Machine 7.

00:12:04.560 --> 00:12:11.860
Now we'll open our project.

00:12:14.200 --> 00:12:16.080
And we'll set our breakpoint on setter.

00:12:16.250 --> 00:12:21.860
Set P word list data colon.

00:12:21.860 --> 00:12:24.460
And then we'll click build and go.

00:12:25.740 --> 00:12:29.020
The application is now installing
over to the device over USB.

00:12:29.020 --> 00:12:30.600
It's being sandboxed.

00:12:30.630 --> 00:12:34.230
User preferences are being archived.

00:12:35.070 --> 00:12:38.890
and now starting the remote
debugger and launched in GDB.

00:12:39.140 --> 00:12:46.190
And we see that in our
breakpoints window here,

00:12:46.190 --> 00:12:46.190
our symbolic breakpoint
has been grayed out.

00:12:47.380 --> 00:12:51.630
and the Enable Breakpoints
checkbox is now in the mixed state.

00:12:51.730 --> 00:12:55.740
This means that the debugger was
unable to resolve the breakpoint.

00:12:55.840 --> 00:12:58.690
So we might have used
the wrong symbol name.

00:12:59.310 --> 00:13:02.640
So let's do a project find on that.

00:13:02.700 --> 00:13:04.630
Synthesize.

00:13:21.230 --> 00:13:27.520
and David Gulland:
So here we see that it's been mapped

00:13:27.520 --> 00:13:35.020
to the other name as we saw in
one of the example slides earlier.

00:13:35.020 --> 00:13:35.020
So we actually want to set our
breakpoint on set word list data,

00:13:35.020 --> 00:13:35.020
not set pword list data.

00:13:35.020 --> 00:13:35.020
So now we'll jump back
to our breakpoints.

00:13:35.410 --> 00:13:41.780
And we'll set our symbolic breakpoint
on set word list data colon.

00:13:41.780 --> 00:13:46.230
And we can also set our
breakpoint on the accessor,

00:13:46.240 --> 00:13:47.870
word list data.

00:13:48.710 --> 00:13:51.520
And we see by location column that
the debugger has actually been

00:13:51.520 --> 00:13:56.590
able to find symbols for these
breakpoints in the executable.

00:13:59.600 --> 00:14:06.680
So now I will quickly shake the device
and play a little bit of Boggle.

00:14:06.680 --> 00:14:07.910
We'll hit the breakpoint.

00:14:07.910 --> 00:14:12.520
And we see here in the stack frame that
we've broken that set word list data.

00:14:12.690 --> 00:14:15.390
and the PCRO is pointing at the at end.

00:14:15.460 --> 00:14:18.410
So when the PCRO is
pointing at the at end,

00:14:18.410 --> 00:14:20.900
you want to jump,
you want to look at the stack

00:14:20.900 --> 00:14:24.100
view to see exactly why you've
broken and what the method is.

00:14:24.100 --> 00:14:31.450
And here we've set,
we're calling the setter.

00:14:31.450 --> 00:14:32.310
And if we continue, we see the same thing
whenever we're at the getter.

00:14:36.490 --> 00:14:39.620
What do you do when you're running
your application and you're not

00:14:39.620 --> 00:14:43.100
running it in the debugger and
something happens to your application?

00:14:43.220 --> 00:14:45.930
So if we can switch to the device.

00:14:49.160 --> 00:14:51.340
If we could switch to the device, please.

00:14:51.340 --> 00:14:52.720
There we go.

00:14:52.720 --> 00:14:54.420
And we'll launch our app.

00:14:54.430 --> 00:14:56.580
It's good old baffle.

00:14:58.250 --> 00:15:02.640
And instead of shaking it,
I will drag my finger around,

00:15:02.690 --> 00:15:04.470
or no I won't.

00:15:13.290 --> 00:15:15.070
There we go.

00:15:15.150 --> 00:15:17.440
Worked better in practice.

00:15:17.560 --> 00:15:21.390
All right,
so now I'll try to spell a word.

00:15:22.480 --> 00:15:24.030
There we are.

00:15:24.140 --> 00:15:25.380
And our applications crashed.

00:15:25.540 --> 00:15:26.340
So what do we do?

00:15:26.440 --> 00:15:28.670
We didn't have the debugger attached.

00:15:28.670 --> 00:15:28.670
Well,

00:15:29.160 --> 00:15:33.280
- You would go to the
organizer back in Xcode.

00:15:33.280 --> 00:15:34.340
So if we can switch back
to the demo machine.

00:15:35.940 --> 00:15:39.500
And we'll go to Window and Organizer.

00:15:39.510 --> 00:15:40.950
And here's our device.

00:15:41.020 --> 00:15:43.190
And we can click on the console.

00:15:43.440 --> 00:15:47.850
And then we can search filter on baffle,
which is the name of our application.

00:15:47.920 --> 00:15:53.120
And we'll click reload to make
sure we have the latest messages.

00:15:53.120 --> 00:15:53.120
And here it tells us that

00:15:53.730 --> 00:15:55.040
Are application deactivated?

00:15:55.040 --> 00:15:56.960
I don't see any crash logs.

00:15:57.010 --> 00:15:59.550
We should check the crash logs anyway.

00:16:00.060 --> 00:16:02.620
When you click on Crash Logs,
it'll go and fetch the

00:16:02.620 --> 00:16:03.910
crash logs from the device.

00:16:03.910 --> 00:16:09.150
And here we see that it has in
fact symbolicated the crash log.

00:16:09.680 --> 00:16:14.600
and the crash happened near
BGbaffleward.m at line 68.

00:16:14.600 --> 00:16:20.150
So let's switch back to slides
and talk about crash logs.

00:16:32.290 --> 00:16:38.740
The crash logs get copied from the device
into Xcode every time you visit that tab.

00:16:38.740 --> 00:16:42.220
They also get copied over when
-- the first time you plug in

00:16:42.220 --> 00:16:44.400
a device when Xcode's launched.

00:16:44.400 --> 00:16:47.640
Now the symbolication happens
on the host immediately after

00:16:47.820 --> 00:16:51.160
those crash logs are copied over.

00:16:51.160 --> 00:16:53.570
And it uses the symbols
not only from the SDK,

00:16:53.640 --> 00:16:57.080
but from the DSIM file,
which has your debugging symbols,

00:16:57.080 --> 00:17:00.640
because it has a matching
unique identifier inside of it.

00:17:00.640 --> 00:17:02.830
And we use a spotlight
search to find that,

00:17:03.020 --> 00:17:06.670
and then we look for the dot app in
the same directory because we need a

00:17:06.720 --> 00:17:08.980
couple symbols out of that as well.

00:17:08.980 --> 00:17:13.910
So you want to ensure that spotlight
indexing is enabled on your laptop in

00:17:13.910 --> 00:17:16.290
order to get symbolicated crash logs.

00:17:19.020 --> 00:17:22.960
If you ship your application
or give it to development or,

00:17:22.990 --> 00:17:25.130
I'm sorry,
Q&A because you want some testing

00:17:25.170 --> 00:17:29.000
done and you want to be able to
symbolicate those crash logs later,

00:17:29.000 --> 00:17:35.570
you want to save off the DSIM file as
well as the .app in the same location.

00:17:37.580 --> 00:17:40.520
Each time you build,
those DSIM files get overwritten

00:17:40.860 --> 00:17:43.920
in order to match the new
application that's been generated.

00:17:45.870 --> 00:17:47.640
So what exactly are DSIM files?

00:17:47.810 --> 00:17:51.740
Well, they're the fully linked dwarf
information for your executable.

00:17:51.780 --> 00:17:55.140
They're the debugging symbols.

00:17:55.680 --> 00:17:58.780
And as I said earlier,
the DSIM has a unique identifier

00:17:58.780 --> 00:18:03.060
inside it that matches the
executable unique identifier.

00:18:03.120 --> 00:18:06.670
And they're generated in the same
directory by the build system.

00:18:06.990 --> 00:18:08.660
These stay on your Macintosh.

00:18:08.750 --> 00:18:12.140
They don't get sent to the
device or anywhere else.

00:18:12.140 --> 00:18:16.880
And they're necessary for verbose
debugging and crash logs and instruments,

00:18:16.900 --> 00:18:18.800
as we'll see later.

00:18:19.430 --> 00:18:22.540
Here's a quick graphical representation
of your build products directory

00:18:22.960 --> 00:18:27.590
with an executable and a DSIM with
matching unique identifiers.

00:18:29.220 --> 00:18:34.760
Now let's talk about memory access issues
and how you find them using GuardMalloc.

00:18:35.830 --> 00:18:38.940
So GuardMalloc catches your
memory access problems.

00:18:38.990 --> 00:18:43.310
It's only available in the Simulator
for your iPhone applications.

00:18:44.060 --> 00:18:47.400
It forces an immediate
crash on bad memory access.

00:18:47.490 --> 00:18:50.100
For instance, buffer overruns,
buffer underruns,

00:18:50.100 --> 00:18:56.470
accessing freed or unallocated memory,
and also accessing uninitialized memory.

00:18:58.110 --> 00:18:59.990
So how does it work?

00:19:00.070 --> 00:19:03.750
Well, each allocation happens
on a separate VM page.

00:19:04.160 --> 00:19:06.860
To catch buffer overruns,
your allocation is aligned

00:19:06.860 --> 00:19:09.140
with the end of the page.

00:19:09.140 --> 00:19:12.800
And then a guard page is placed after it,
like this.

00:19:15.950 --> 00:19:18.340
Now to catch buffer underruns,
you have to set one of

00:19:18.340 --> 00:19:19.980
guard malloc's options.

00:19:19.980 --> 00:19:23.280
In my environment variable
malloc protect before.

00:19:23.320 --> 00:19:25.240
Then,

00:19:25.610 --> 00:19:28.740
The allocation starts at the
beginning of the VM page and the

00:19:28.740 --> 00:19:30.740
guard page is placed before that.

00:19:30.740 --> 00:19:36.250
And this will cause a crash if you try
and access memory before the allocation.

00:19:37.860 --> 00:19:42.200
To enable GuardMalloc in Xcode,
go to the Run menu,

00:19:42.230 --> 00:19:45.790
go down to the bottom,
and check Enable GuardMalloc.

00:19:46.750 --> 00:19:49.160
This is effectively setting
an environment variable,

00:19:49.160 --> 00:19:54.180
DYLD_INSERT_LIBRARIES,
pointing at the libgmalic dilib.

00:19:54.310 --> 00:19:58.200
Now for more information about
GuardMalloc and all its options,

00:19:58.200 --> 00:20:01.030
you want to look at the
man page for libgmalloc.

00:20:01.140 --> 00:20:03.670
Note that the man page
is not called malloc,

00:20:03.670 --> 00:20:07.300
so you want to make a note of that.

00:20:07.410 --> 00:20:16.120
And now I'll have a demo of
catching memory access exceptions.

00:20:16.120 --> 00:20:16.120
We can switch to the demo machine.

00:20:23.200 --> 00:20:28.530
So here we are and we're going
to build and go on our device.

00:20:29.300 --> 00:20:30.400
It's not the same baffle.

00:20:30.400 --> 00:20:35.140
It'll behave a little bit better than
crashing after selecting four words.

00:20:35.250 --> 00:20:37.000
So we're still installing now.

00:20:37.010 --> 00:20:39.310
It's copying it over the USB.

00:20:40.080 --> 00:20:46.200
Doing the things that it does,
all those seven things they talked

00:20:46.200 --> 00:20:46.200
about in the State of the Union.

00:20:46.830 --> 00:20:49.140
So now it's running on the device.

00:20:49.180 --> 00:20:51.140
I'll start a new game.

00:20:51.170 --> 00:20:53.030
I'll shake it.

00:20:56.300 --> 00:21:01.610
Now we can see that it's
behaving much better.

00:21:01.720 --> 00:21:08.890
Now, memory access issues can be rather
insidious because your application

00:21:08.890 --> 00:21:08.890
may seem like it's perfectly fine.

00:21:10.120 --> 00:21:12.300
You may be corrupting data.

00:21:12.310 --> 00:21:14.140
Pardon?

00:21:14.250 --> 00:21:15.940
You may be actually corrupting data.

00:21:15.960 --> 00:21:25.610
So let's switch to running in the
simulator with GuardMalloc enabled.

00:21:27.000 --> 00:21:30.330
Now we click Build and Go.

00:21:30.350 --> 00:21:33.200
It's installing the
application in the simulator.

00:21:36.520 --> 00:21:39.500
This is the first time I've run the
simulator today after rebooting,

00:21:39.500 --> 00:21:41.500
so it takes a little while to come up.

00:21:41.770 --> 00:21:44.480
Here it is.

00:21:44.480 --> 00:21:46.910
Running baffle.

00:21:46.910 --> 00:21:49.230
We can shake it.

00:21:53.430 --> 00:21:54.320
And we've crashed.

00:21:54.320 --> 00:21:57.790
In the status bar in the lower corner,
it told us that GDB was

00:21:57.800 --> 00:21:59.930
attaching to the program.

00:21:59.930 --> 00:22:03.320
And now we see that we are at has suffix.

00:22:03.370 --> 00:22:05.110
And it looks like

00:22:05.720 --> 00:22:07.440
And if we do a step over,
we'll see that the

00:22:07.540 --> 00:22:11.650
program received a signal,
exe bad access.

00:22:12.660 --> 00:22:14.340
So now let's investigate a little bit.

00:22:14.360 --> 00:22:16.490
So if we hover over Word,
our data tip comes up

00:22:16.660 --> 00:22:18.740
and it has an address.

00:22:19.100 --> 00:22:21.420
But if we turn it down,
we should be seeing the first

00:22:21.420 --> 00:22:25.230
letter of this char star,
and we aren't getting anything.

00:22:25.350 --> 00:22:27.190
Something's a little fishy.

00:22:28.130 --> 00:22:29.900
Let's go up here to the Variables view.

00:22:29.910 --> 00:22:34.170
We'll Control-click on
Word and select View as Memory.

00:22:34.550 --> 00:22:37.400
The debugger comes back telling us, hey,
we're unable to read

00:22:37.400 --> 00:22:38.670
this memory location.

00:22:38.770 --> 00:22:41.980
So that probably means
this memory's been freed.

00:22:43.870 --> 00:22:49.070
And if we go up our stack,
we can see that we've gone

00:22:49.120 --> 00:22:52.610
and malloced some memory,
done some string copies

00:22:52.690 --> 00:22:55.450
and string cats to it,
and then freed it to make

00:22:55.520 --> 00:22:57.240
sure we didn't leak it.

00:22:57.340 --> 00:22:59.480
However, we're using it later.

00:22:59.610 --> 00:23:02.130
So this is obviously freed too early.

00:23:02.160 --> 00:23:07.430
Now, this is the same code that seemed
to be running fine on the device.

00:23:07.430 --> 00:23:11.350
And here we see that we
actually had a memory problem.

00:23:11.420 --> 00:23:13.300
Let's switch back to slides.

00:23:18.550 --> 00:23:21.600
I'll leave you with some quick
troubleshooting tips if your application

00:23:21.600 --> 00:23:24.370
doesn't launch on the device from Xcode.

00:23:24.480 --> 00:23:29.370
The first place to check is Xcode's
debugger console for error messages.

00:23:29.550 --> 00:23:31.950
Then you should try and
launch the application on

00:23:31.950 --> 00:23:35.890
your device using your finger,
not trying to launch it from Xcode.

00:23:36.900 --> 00:23:43.200
Then check the Organizer's Console tab
for provisioning or signing errors.

00:23:43.300 --> 00:23:46.360
And finally,
check for crash logs in the Organizer.

00:23:46.360 --> 00:23:51.920
And now let's bring up Steve Lewallen
to talk about profiling and

00:23:51.920 --> 00:23:54.170
analysis with instruments.

00:23:58.000 --> 00:23:59.980
Thank you, Chris.

00:24:00.000 --> 00:24:01.880
Good morning, everyone.

00:24:01.990 --> 00:24:05.960
So today I'd like to talk to you
about one of our premier analysis and

00:24:05.960 --> 00:24:08.560
profiling tools known as Instruments.

00:24:08.690 --> 00:24:14.520
We first introduced Instruments
in Leopard for analysis and

00:24:14.520 --> 00:24:20.740
profiling in Mac applications,
and now we've extended it to

00:24:20.740 --> 00:24:21.100
support profiling and analysis in
the simulator and on the iPhone.

00:24:21.360 --> 00:24:23.200
So, what is Instruments?

00:24:23.330 --> 00:24:25.700
Well, first and foremost,
it's a performance tool.

00:24:25.700 --> 00:24:28.170
So,
you can see that you can use Instruments

00:24:28.170 --> 00:24:30.280
to find bottlenecks in your own code.

00:24:30.430 --> 00:24:32.920
You can look at the
memory use of your app.

00:24:33.130 --> 00:24:36.740
You can even identify perhaps
inefficient graphics algorithms

00:24:36.750 --> 00:24:38.600
that you have in your games.

00:24:40.900 --> 00:24:43.700
But it's also an analysis tool.

00:24:43.700 --> 00:24:45.590
So you can observe the
history of a pointer,

00:24:45.700 --> 00:24:48.410
for example,
or you can look at how your system

00:24:48.410 --> 00:24:50.800
is interacting with the file system.

00:24:50.920 --> 00:24:57.480
You can even see how your app is
working on the device in relation to

00:24:57.550 --> 00:25:03.670
the other processes on the device,
how much CPU it's taking

00:25:03.800 --> 00:25:04.250
versus the CPU they're taking,
memory to memory, et cetera.

00:25:04.720 --> 00:25:07.570
And finally,
when you're running in a simulator,

00:25:07.690 --> 00:25:10.830
again, as Dave said,
a simulator app is basically a Mac app.

00:25:11.110 --> 00:25:14.250
You can actually use DTrace
to look at your app from the

00:25:14.300 --> 00:25:16.110
kernel on up to user space.

00:25:17.240 --> 00:25:21.840
So in using Instruments,
you can do so either standalone or you

00:25:21.840 --> 00:25:27.030
can do so from Xcode to extend that edit,
build, debug cycle into a full edit,

00:25:27.030 --> 00:25:31.620
build, debug, profile,
and analysis cycle.

00:25:31.620 --> 00:25:34.560
Whichever way you use it,
you use Instruments to record and

00:25:34.560 --> 00:25:36.480
correlate arbitrary data streams.

00:25:36.810 --> 00:25:42.300
So for example, you could say, well,
how much memory does it take

00:25:42.300 --> 00:25:44.680
to consume this special file
my application reads in?

00:25:44.880 --> 00:25:48.000
Whatever you do,
you can then use to record your data,

00:25:48.000 --> 00:25:50.900
you can then use Instruments
to mine that data.

00:25:50.900 --> 00:25:58.450
You can turn your data upside down,
inside out,

00:25:58.450 --> 00:25:59.770
filter it on different things and
really narrow down the data to just

00:25:59.770 --> 00:25:59.770
what is the source of your problem.

00:26:01.160 --> 00:26:05.780
So now let's talk about using
Instruments in the Simulator itself.

00:26:05.780 --> 00:26:09.280
There are similar capabilities
in Instruments when using a

00:26:09.280 --> 00:26:11.860
Simulator app with Instruments.

00:26:11.860 --> 00:26:15.200
You have the ability to
look at memory issues.

00:26:15.270 --> 00:26:17.440
You can look at CPU issues.

00:26:17.440 --> 00:26:19.320
You can look at I/O issues.

00:26:19.370 --> 00:26:23.900
In this case, using DTrace file
activity-based instrumentation.

00:26:23.900 --> 00:26:28.470
And you can use DTrace to discover
other things that we haven't thought

00:26:28.470 --> 00:26:30.150
of that are specific to your apps.

00:26:31.340 --> 00:26:33.740
Now,
one thing you need to be made aware of,

00:26:33.740 --> 00:26:35.900
and I'm sure by this
time you probably are,

00:26:35.900 --> 00:26:38.100
but let's just go over it again.

00:26:38.100 --> 00:26:41.610
The results that you gather in a
profiling and analysis tool such

00:26:41.670 --> 00:26:45.280
as instruments when you're looking
at an app in a simulator has to

00:26:45.280 --> 00:26:50.670
be interpreted a bit differently,
maybe with a healthy dose of

00:26:50.750 --> 00:26:55.640
skepticism because when the
app is running in a simulator,

00:26:55.700 --> 00:26:59.640
it's compiled for the Mac,
linked against iPhone

00:26:59.710 --> 00:27:04.080
frameworks compiled for the Mac,
running on the Mac OS.

00:27:04.200 --> 00:27:07.290
And therefore, your memory issues,
for example,

00:27:07.620 --> 00:27:12.480
will have a different memory profile
when your app is in the simulator

00:27:12.480 --> 00:27:15.430
than it is in the iPhone itself.

00:27:15.610 --> 00:27:19.660
Of course, it goes without saying
also that the hardware,

00:27:19.660 --> 00:27:23.540
whether it's a Mac Pro 8 way
or even a cool MacBook Air,

00:27:23.540 --> 00:27:26.260
is way more powerful than your iPhone.

00:27:26.390 --> 00:27:29.660
And so you need to be aware
that the performance envelope,

00:27:29.820 --> 00:27:34.240
that your iPhone app is running in,
in the simulator is different than

00:27:34.240 --> 00:27:37.880
the far more constrained environment
it will find itself in when it's

00:27:37.940 --> 00:27:39.880
actually running on the phone.

00:27:40.030 --> 00:27:43.620
And that's why I like to say and
point out that using instruments or

00:27:43.700 --> 00:27:48.820
analysis tools against your app in the
simulator is best suited for analysis.

00:27:48.950 --> 00:27:52.870
So you can observe how it's behaving,
track down different problems,

00:27:53.020 --> 00:27:55.590
but when you want to finally
get ready to fine tune that

00:27:55.590 --> 00:27:59.380
performance before you ship it,
you really want to use instruments

00:27:59.420 --> 00:28:02.260
against the app on the device
itself where it's operating within

00:28:02.260 --> 00:28:06.810
the parameters that that device,
that piece of hardware has.

00:28:07.580 --> 00:28:13.090
So there are unique aspects to
using instruments with a simulator.

00:28:13.200 --> 00:28:16.830
For example, some Mac instruments,
they simply don't apply.

00:28:17.070 --> 00:28:20.890
The UR Recorder Instrument uses
accessibility frameworks on the Mac,

00:28:20.980 --> 00:28:23.640
and we don't have that on the iPhone,
so that doesn't apply.

00:28:23.780 --> 00:28:27.250
We don't have Core Data on the iPhone,
so the Core Data instrumentation

00:28:27.250 --> 00:28:28.030
does not apply.

00:28:28.280 --> 00:28:31.210
And our new garbage
collection instrument,

00:28:31.380 --> 00:28:34.940
Object Graph,
that we introduced in Xcode 3.1,

00:28:34.940 --> 00:28:39.840
it doesn't apply because we don't
have garbage collection on the phone.

00:28:39.850 --> 00:28:41.190
However, the other instrumentation does.

00:28:41.740 --> 00:28:44.400
Now, secondly,
applications are quote unquote

00:28:44.420 --> 00:28:46.200
installed in the simulator.

00:28:46.340 --> 00:28:50.480
So when you select a simulator app,
whether from Instruments or from Xcode,

00:28:50.480 --> 00:28:56.450
the first thing that's going to happen,
if need be,

00:28:56.450 --> 00:28:59.710
is that app is going to be installed
in the simulator and then it's

00:28:59.710 --> 00:28:59.710
going to be launched for you.

00:28:59.710 --> 00:28:59.710
So we take care of all that for you.

00:29:00.960 --> 00:29:05.370
Now, when you're using Instruments
against your app in the simulator,

00:29:05.370 --> 00:29:10.240
you're probably pursuing one of a few
common profiling and analysis goals.

00:29:10.380 --> 00:29:12.680
You may be seeking to increase
the stability of your app.

00:29:12.780 --> 00:29:16.660
Maybe you're using ObjectAlloc and
DTrace to track down an over-release.

00:29:16.760 --> 00:29:20.930
In fact, we'll see a very useful cool
demo of that in a moment.

00:29:21.390 --> 00:29:24.240
Or perhaps you're just trying to
reduce the memory footprint of your

00:29:24.240 --> 00:29:26.500
app by tracking down leaked memory.

00:29:26.610 --> 00:29:29.490
That's very valid to do in the simulator.

00:29:29.800 --> 00:29:34.800
Or perhaps you're looking for ways
to use memory more efficiently.

00:29:34.900 --> 00:29:37.270
If, for example,
you're putting so many objects

00:29:37.270 --> 00:29:40.340
in the auto release pool that
that's growing very large,

00:29:40.530 --> 00:29:43.660
then your overall memory footprint,
even though it will be temporary,

00:29:43.780 --> 00:29:44.380
will spike.

00:29:44.510 --> 00:29:47.630
And that could cause a danger to your
app when it's actually on that phone.

00:29:47.630 --> 00:29:49.730
So you want to look for
those issues as well.

00:29:50.620 --> 00:29:53.500
So now let's talk a bit more
about that over-release issue,

00:29:53.500 --> 00:29:58.880
that increasing stability type of
goal you might have using Instruments.

00:29:59.010 --> 00:30:00.620
So what is an over-release?

00:30:00.730 --> 00:30:03.720
An over-release is when you have
an object that's deallocated

00:30:03.720 --> 00:30:05.580
and then you message it.

00:30:05.740 --> 00:30:10.620
So this will lead to unspecified behavior
in your app and an eventual crash.

00:30:10.740 --> 00:30:13.150
And we call these
over-released objects zombies.

00:30:13.260 --> 00:30:17.890
They're dead, but they're still walking
around making trouble.

00:30:18.050 --> 00:30:21.770
What you need to do is diagnose
this using the NS Zombies

00:30:21.770 --> 00:30:23.680
facility that's on the Mac.

00:30:23.990 --> 00:30:27.730
This is only available on the Mac whether
it's a Mac app or a simulator app.

00:30:27.810 --> 00:30:29.940
So this type of issue,
you must use instruments

00:30:29.940 --> 00:30:31.240
with the simulator.

00:30:31.240 --> 00:30:34.250
You can't do it on the iPhone itself.

00:30:35.220 --> 00:30:38.860
So what would a typical scenario look
like when you're trying to diagnose

00:30:38.870 --> 00:30:42.740
an over-release problem which quite
frankly without instruments and

00:30:42.740 --> 00:30:46.410
without NSOMBIs would be a very
frustrating thing to have to do.

00:30:46.690 --> 00:30:52.810
And in a retained release sort of
memory-managed language like Objective C,

00:30:52.810 --> 00:30:58.520
this can be a fairly common thing
that will happen in your code.

00:30:58.520 --> 00:31:01.400
So the first thing is
it's going to crash.

00:31:01.400 --> 00:31:06.040
And you're going to see some message in
the console or the debugger that says

00:31:06.040 --> 00:31:10.140
something happened to some mysterious
thing that was at some pointer.

00:31:10.170 --> 00:31:12.480
And that's not very helpful at all.

00:31:12.590 --> 00:31:17.040
So what you'll want to do is you'll
go to your executable inspector in

00:31:17.040 --> 00:31:23.740
Xcode and you'll set the environment
variable NSZOMBI enabled to yes.

00:31:23.800 --> 00:31:25.720
And then you'll rerun.

00:31:25.890 --> 00:31:28.040
Now you'll get something
that's a bit more helpful.

00:31:28.040 --> 00:31:32.200
At least you'll know what type of
object that was at that pointer.

00:31:32.320 --> 00:31:36.120
But you still don't know
how it became over released.

00:31:36.250 --> 00:31:39.070
So let's go and -- so what do you do now?

00:31:39.450 --> 00:31:44.360
Well, let's go to Instruments and take a
look at how we can fully diagnose

00:31:44.470 --> 00:31:46.980
this and just nail this problem.

00:31:50.820 --> 00:31:55.030
So demo machine six please.

00:31:55.220 --> 00:31:55.770
All right.

00:31:55.840 --> 00:32:00.420
So the first thing I'm going to do is
launch my poor baffle Cocoa Touch app.

00:32:00.540 --> 00:32:03.600
You would have thought that this
app being front and center at

00:32:03.600 --> 00:32:06.750
this conference that we would
have had this in better shape,

00:32:06.750 --> 00:32:09.380
but this app has suffered
the entire conference.

00:32:09.380 --> 00:32:11.280
This time it's crashing on us here.

00:32:11.590 --> 00:32:17.190
So I'm going to build it and I'm
going to run it in the simulator.

00:32:17.810 --> 00:32:21.210
And I'm going to show you the basic
scenario that leads to the crash.

00:32:21.360 --> 00:32:24.220
When I start a new game
and I select my first word,

00:32:24.320 --> 00:32:25.460
I think is fine.

00:32:25.460 --> 00:32:26.570
Then I select another one.

00:32:27.040 --> 00:32:29.080
Oh, GDB is loading.

00:32:29.420 --> 00:32:31.710
Let's go to GDB in the console.

00:32:32.030 --> 00:32:35.250
And yes, indeed,
we get this not so helpful

00:32:35.300 --> 00:32:39.860
message that our app has crashed,
messaging something that

00:32:39.940 --> 00:32:42.200
was at some random pointer.

00:32:42.320 --> 00:32:46.040
So I'm going to use Instruments to
diagnose this and track it down.

00:32:46.170 --> 00:32:49.960
Now, the first thing that I want
to do is I want to stop my

00:32:50.360 --> 00:32:52.900
app in the debugger here.

00:32:52.900 --> 00:32:55.230
I want to quit the
debugger because right now,

00:32:55.380 --> 00:32:58.600
Baffle Cocoa Touch is in
the simulator suspended.

00:32:58.710 --> 00:33:01.620
If I would just go to Instruments
right now and try to launch a new

00:33:01.620 --> 00:33:04.200
instance of Baffle Cocoa Touch,
it would fail.

00:33:04.370 --> 00:33:08.600
And the reason is that the simulator
is occupied right now with this app.

00:33:08.610 --> 00:33:10.370
So if you run into
that kind of a problem,

00:33:10.370 --> 00:33:12.100
say, oh, I remember when Steve said
go back to the app.

00:33:12.100 --> 00:33:14.300
I'm going to go back to
the debugger and stop it.

00:33:14.300 --> 00:33:15.500
So I'm going to stop that now.

00:33:15.500 --> 00:33:18.370
And I'm going to go down to Instruments.

00:33:19.300 --> 00:34:43.500
[Transcript missing]

00:34:43.920 --> 00:34:49.870
So, I'm going to use a little DTrace
custom instrument that I built

00:34:49.870 --> 00:34:52.660
to surface the zombie pointer.

00:34:52.770 --> 00:34:54.600
Now, I'm doing this as a
bit of a tease as well.

00:34:54.600 --> 00:34:58.940
I want to encourage you guys to go
to the DTrace session later today.

00:34:58.940 --> 00:35:02.610
I believe it's at 3:30 and then
there's a great advanced DTrace and

00:35:02.620 --> 00:35:04.860
instrument session tomorrow morning.

00:35:04.860 --> 00:35:08.620
So, what I'm going to do is I'm going
to go up to the upper right of

00:35:08.620 --> 00:35:11.220
my Instruments window and I'm
going to hit the Library button.

00:35:11.220 --> 00:35:12.650
I'm going to search for zombie.

00:35:12.660 --> 00:35:13.840
Thank you.

00:35:14.290 --> 00:35:16.860
So this is my little zombie
detection instrument.

00:35:16.960 --> 00:35:19.400
Again, you could do all this
without this instrument,

00:35:19.400 --> 00:35:21.570
but it's just going to make
it a little cooler and more

00:35:21.630 --> 00:35:22.970
convenient in Instruments itself.

00:35:23.060 --> 00:35:24.070
All right.

00:35:24.190 --> 00:35:28.880
Now I'm ready to try to track
down this over-released object.

00:35:29.000 --> 00:35:31.540
So I'm going to go and I'm going
to click the Record button in the

00:35:31.550 --> 00:35:33.180
upper left of the Instruments window.

00:35:33.520 --> 00:35:37.550
That's going to start up my app in the
simulator again and start recording data.

00:35:37.630 --> 00:35:41.910
I'm going to go and put it through its
paces again that led to that crash.

00:35:44.270 --> 00:35:45.030
Okay, crashed.

00:35:45.030 --> 00:35:47.020
We get the crash dialogue,
which we expected.

00:35:47.310 --> 00:35:48.540
I'll dismiss that.

00:35:48.650 --> 00:35:50.990
Now if we look at the
NS Zombie Detection Instrument,

00:35:50.990 --> 00:35:52.970
and far right here we
see a little spike here.

00:35:53.280 --> 00:35:54.190
That's an event.

00:35:54.220 --> 00:35:57.340
And the only event this
tracks is messages to zombies.

00:35:57.410 --> 00:35:59.890
And if I look down here
in the detail view,

00:35:59.890 --> 00:36:02.510
I can even get the
pointer to that zombie.

00:36:02.510 --> 00:36:04.540
So I'm going to copy that out.

00:36:05.090 --> 00:36:07.930
And now I'm going to go to
my ObjectAlloc instrument.

00:36:08.040 --> 00:36:11.020
Now, you've seen ObjectAlloc several
times during this conference already.

00:36:11.020 --> 00:36:14.550
Hopefully you've made great use of it
on the Mac and your iPhone apps already.

00:36:14.790 --> 00:36:16.480
But let me just review,
just for a second here,

00:36:16.480 --> 00:36:17.870
what we're seeing.

00:36:18.190 --> 00:36:20.600
We have three basic detail
views in ObjectAlloc,

00:36:20.750 --> 00:36:21.960
one of which is a summary view.

00:36:21.960 --> 00:36:24.930
It shows all the different types
of objects it's ever seen and

00:36:24.930 --> 00:36:28.300
categorizes them by how many times
they were created and how many are

00:36:28.440 --> 00:36:31.110
still left when we stopped running,
et cetera.

00:36:31.200 --> 00:36:33.910
Second view is a call tree view,
which will show me all the places

00:36:33.910 --> 00:36:37.180
where the memory was allocated
that we saw with ObjectAlloc.

00:36:37.290 --> 00:36:40.640
The third view is very
relevant for this bug here.

00:36:40.640 --> 00:36:43.600
This view is an event view that
will show me all the pointers

00:36:43.680 --> 00:36:46.600
where they're allocated,
no matter what type they were,

00:36:46.600 --> 00:36:50.470
from the time I started
the app until it crashed.

00:36:50.580 --> 00:36:53.380
So I have that little
pointer that I copied from my

00:36:53.380 --> 00:36:55.140
zombie detection instrument.

00:36:55.250 --> 00:36:57.520
So I'm going to go down to
the lower right-hand field,

00:36:57.520 --> 00:37:01.150
the search field,
and I'm going to say search by address.

00:37:01.290 --> 00:37:02.870
And now I'm going to
paste in that address.

00:37:03.460 --> 00:37:08.460
And now I have the actual
object that was overreleased.

00:37:08.570 --> 00:37:11.870
If I click on this little round
circle that has this arrow in it,

00:37:11.870 --> 00:37:16.160
I'm going to get to the
entire history of that object.

00:37:16.510 --> 00:37:19.260
So first I can see where it was created.

00:37:19.290 --> 00:37:22.340
And I can see retains and
auto releases and releases.

00:37:22.470 --> 00:37:24.970
So let's go to the extended detail view.

00:37:24.980 --> 00:37:29.670
I'll use the view menu in the far right,
say extended detail.

00:37:29.850 --> 00:37:35.880
And I'll reorient my back trace so
it's a bit more convenient for us here.

00:37:35.880 --> 00:37:39.410
And I'll see that, well,
it was malloc'd here.

00:37:39.560 --> 00:37:42.430
When I'm looking at these
frames from top to bottom,

00:37:42.430 --> 00:37:45.740
I see a call and below it
I'll either see a library,

00:37:45.740 --> 00:37:50.120
we see lib system, lib objc,
core foundation, et cetera,

00:37:50.330 --> 00:37:52.580
or I'll see the actual path to a file.

00:37:52.920 --> 00:37:58.420
That will be source code that instruments
has found that applies to this project.

00:37:58.420 --> 00:38:03.500
So I'm going to double click on this
and I'm going to see what's going on.

00:38:03.500 --> 00:38:03.500
Well,

00:38:03.860 --> 00:38:06.700
It looks like it's created in
a little static factory method,

00:38:06.820 --> 00:38:08.220
Create Table View Cell.

00:38:08.460 --> 00:38:09.960
Cool, that seems fine.

00:38:10.100 --> 00:38:13.400
If I look at my other retains and
releases in that initial creation,

00:38:13.440 --> 00:38:16.300
it seems like my retain
count's pretty balanced there,

00:38:16.300 --> 00:38:17.910
everything seems reasonable.

00:38:18.050 --> 00:38:22.020
But two back-to-back auto releases,
that seems a little suspicious.

00:38:22.050 --> 00:38:25.440
So let's look at where each
of these auto releases are.

00:38:25.440 --> 00:38:28.770
So again, I'm going to click on the first
frame that I have that has source

00:38:29.000 --> 00:38:30.580
in it that's to my project.

00:38:30.650 --> 00:38:32.100
I'll double click there.

00:38:32.190 --> 00:38:36.220
It again takes me to the factory method,
and I see that the factory method,

00:38:36.250 --> 00:38:39.740
appropriately so,
is allocating a new instance of this

00:38:39.740 --> 00:38:41.740
and then returning an auto-release.

00:38:41.800 --> 00:38:44.380
If the caller doesn't want
to do anything with it,

00:38:44.380 --> 00:38:45.810
it'll be cleaned up automatically.

00:38:45.870 --> 00:38:47.340
Otherwise, they should retain it.

00:38:47.440 --> 00:38:48.960
So that looks cool, that's fine.

00:38:49.030 --> 00:38:50.330
Let's look at the next auto-release.

00:38:50.430 --> 00:38:52.860
This is looking pretty
suspicious at this point.

00:38:52.950 --> 00:38:55.950
So I'll select that,
and I'll double click on that

00:38:55.950 --> 00:38:58.400
frame and go to the source.

00:38:58.460 --> 00:39:02.050
Now what we have here is a table view,
cell for row and index at path.

00:39:02.140 --> 00:39:07.800
So this API is supposed to return
an instance of UITableViewCell.

00:39:08.110 --> 00:39:11.570
And if I look down here,
I can see that it calls the factory

00:39:11.670 --> 00:39:15.730
method that returns an auto-release
version and then auto-releases itself.

00:39:15.810 --> 00:39:18.080
So maybe this developer
was confused and thought,

00:39:18.090 --> 00:39:22.340
well, I should return an auto-release
version from this method.

00:39:22.410 --> 00:39:25.110
But actually,
that's the source of the problem.

00:39:25.230 --> 00:39:28.940
So since this is already auto-released,
what I'm going to do is simply

00:39:28.940 --> 00:39:30.750
delete this auto-release.

00:39:30.870 --> 00:39:32.020
So I'll go ahead and do that now.

00:39:32.140 --> 00:39:36.910
I'm going to hit build and run again.

00:39:39.010 --> 00:39:42.020
And it's linking,
installing in the simulator and running.

00:39:42.020 --> 00:39:46.190
And now put it through its paces again
to see if it still crashes on me.

00:39:47.100 --> 00:39:53.460
And it doesn't, so this is working fine,
so that's great.

00:39:53.540 --> 00:39:59.090
Exit Xcode, exit Instruments,
and back to slides, please.

00:40:00.420 --> 00:40:03.800
So now we've seen how we can use
Instruments to track down what used to be

00:40:03.900 --> 00:40:06.460
a truly maddening thing to try to find.

00:40:06.570 --> 00:40:10.400
That would lead to instability
in your app and you'd spend many

00:40:10.400 --> 00:40:12.410
hours trying to fix yourself.

00:40:12.680 --> 00:40:14.220
So that was pretty simple.

00:40:14.370 --> 00:40:18.090
So now let's move on to using
Instruments in the iPhone.

00:40:18.750 --> 00:40:22.140
So again,
similar capabilities as profiling

00:40:22.320 --> 00:40:24.610
Mac apps or simulator apps.

00:40:24.680 --> 00:40:26.430
You can look at memory analysis.

00:40:26.640 --> 00:40:28.640
You can look at CPU bound issues.

00:40:28.710 --> 00:40:30.190
You can look at I/O.

00:40:30.190 --> 00:40:33.270
In this case,
since DTrace isn't on the phone,

00:40:33.310 --> 00:40:38.530
we have built a great new instrument
called the I/O Activity Instrument in the

00:40:38.530 --> 00:40:44.550
system usage template that will basically
give you Uber on steroids version of

00:40:44.550 --> 00:40:49.830
SF usage with call trees and back traces,
all that kind of great stuff.

00:40:50.260 --> 00:40:53.400
And we've introduced two new
graphics instruments to look at

00:40:53.400 --> 00:40:55.870
Core Animation and OpenGL ES.

00:41:00.140 --> 00:41:05.920
So I'd like to encourage you to be a
bit more proactive in your analysis

00:41:06.360 --> 00:41:11.050
in profiling of apps that are destined
for the iPhone because the iPhone

00:41:11.050 --> 00:41:15.300
runs in a more -- the iPhone app
runs in a more sensitive environment.

00:41:15.300 --> 00:41:17.280
It has more constraints on it.

00:41:17.420 --> 00:41:21.050
So, for example,
you have to remember that applications

00:41:21.050 --> 00:41:23.130
are Sandboxed on the system.

00:41:23.340 --> 00:41:28.580
And so let's say you had a little
utility library that had some logging you

00:41:28.580 --> 00:41:34.000
could turn on and when you turn it on,
you scrolled it away and slashed temp.

00:41:34.000 --> 00:41:37.700
And you built that in the simulator
and everything worked great.

00:41:37.830 --> 00:41:40.730
But when you just took that app
and you moved it to the iPhone,

00:41:40.730 --> 00:41:44.090
suddenly your log wasn't
being created anymore.

00:41:44.090 --> 00:41:48.050
If you use the FS usage
instrument we call IO Activity,

00:41:48.050 --> 00:41:51.390
you'll be able to see that you get
a security permission error when

00:41:51.390 --> 00:41:53.100
you actually try to create a file.

00:41:53.100 --> 00:41:56.240
00:02:00:00 - 00:02:11:00 Unknown So you
want to you want to make sure that

00:41:56.240 --> 00:41:57.490
you've dealt with those types of issues.

00:41:57.500 --> 00:42:02.420
Secondly,
as we've sort of alluded to earlier,

00:42:02.420 --> 00:42:08.140
if the iPhone OS determines that the
amount of memory that your app is

00:42:08.140 --> 00:42:12.210
using is becoming a threat to the phone
itself and you're listening for it,

00:42:12.210 --> 00:42:14.110
it will send you a low
memory notification.

00:42:14.110 --> 00:42:20.430
And if you don't clean up or reduce the
amount of memory you're using quickly,

00:42:20.660 --> 00:42:23.060
your app is going to be
terminated to save the phone.

00:42:23.080 --> 00:42:26.140
00:02:11:00 - 00:02:36:00 Unknown So you
want to use the various memory

00:42:26.560 --> 00:42:31.120
analysis instrumentation that we
have when you run it on the phone.

00:42:31.120 --> 00:42:32.970
Remember how the memory profile
is going to be different on

00:42:33.090 --> 00:42:34.460
the phone than the simulator.

00:42:34.540 --> 00:42:36.810
So when you go to the phone,
you want to watch that memory,

00:42:36.810 --> 00:42:40.260
maybe use the activity monitor just
to watch the memory and see if it

00:42:40.340 --> 00:42:41.880
stays about at a certain level.

00:42:41.880 --> 00:42:44.660
It doesn't just keep growing like crazy.

00:42:44.840 --> 00:42:48.350
And you really want to make sure
that your app is ready to live out

00:42:48.350 --> 00:42:50.710
in the real world on the phone.

00:42:51.090 --> 00:42:56.590
So there are unique aspects to using
instruments with iPhone itself.

00:42:56.970 --> 00:42:59.910
Again, with the simulator,
the same instruments don't

00:42:59.910 --> 00:43:01.580
apply for the same reasons.

00:43:01.580 --> 00:43:04.990
Now, Instruments will not install
an app on the iPhone.

00:43:05.010 --> 00:43:09.850
We leave that task to Xcode
and the Xcode organizer.

00:43:09.980 --> 00:43:13.080
However,
if you use Instruments from Xcode itself,

00:43:13.230 --> 00:43:16.260
so you go to the run menu,
which we'll see in a minute,

00:43:16.260 --> 00:43:20.100
you launch a performance tool and
Instruments starts up and your

00:43:20.100 --> 00:43:21.940
app is launched on the phone.

00:43:21.940 --> 00:43:24.550
In that workflow,
your app will actually be

00:43:24.550 --> 00:43:26.270
installed on the phone for you.

00:43:28.420 --> 00:43:31.310
So again,
you may be pursuing one of various

00:43:31.310 --> 00:43:35.580
common profiling goals when using
Instruments with your iPhone

00:43:35.840 --> 00:43:37.580
app actually on the device.

00:43:37.820 --> 00:43:40.640
You may be again seeking
to increase stability,

00:43:40.640 --> 00:43:45.000
but maybe this time you're looking
for that increasing memory issue.

00:43:45.540 --> 00:43:48.480
Or you might have read our
developer guidelines for

00:43:48.480 --> 00:43:50.560
writing iPhone applications.

00:43:50.680 --> 00:43:53.120
And you read this one guideline
that said fast launch,

00:43:53.120 --> 00:43:53.800
short use.

00:43:53.950 --> 00:43:57.550
And what that means is your app
should launch as fast as it can and

00:43:57.550 --> 00:44:02.220
it should save out data appropriately
so that it connects it quickly.

00:44:04.960 --> 00:44:07.990
Or you might be trying to
improve the drawing performance

00:44:07.990 --> 00:44:14.110
of your core animation,
your app, or an Open GLS game.

00:44:14.800 --> 00:44:17.530
And finally,
you may be looking again at how

00:44:17.530 --> 00:44:20.060
your app is sandboxed in the system.

00:44:20.070 --> 00:44:24.990
So now let's take a look at another
demo of using Instruments against

00:44:24.990 --> 00:44:30.450
your app on the device to look at your
startup time and to try to improve that.

00:44:30.460 --> 00:44:34.470
Again, this is a perfect scenario for
using Instruments with your app on

00:44:34.470 --> 00:44:37.970
the device itself because if you
try to measure the startup time of

00:44:37.970 --> 00:44:41.210
your app when it's running in the
simulator on your 8-way Mac Pro,

00:44:41.210 --> 00:44:44.530
that's not really going to be
reflective of the real world.

00:44:44.540 --> 00:44:47.030
So let's look at Instruments
on the device itself.

00:44:47.040 --> 00:44:53.610
So if we can switch back to demo six,
please.

00:44:57.550 --> 00:45:03.650
Okay, so I'm going to start another
version of Baffle Cocoa Touch.

00:45:03.730 --> 00:45:06.260
And it's targeting the device here.

00:45:06.260 --> 00:45:08.690
And I'm going to build it.

00:45:11.240 --> 00:45:15.240
And now I'm going to go
to the Xcode Run menu.

00:45:15.360 --> 00:45:18.650
And I'm going to select
Start with Performance Tool.

00:45:20.000 --> 00:45:22.360
CPU Sampler.

00:45:22.450 --> 00:45:24.450
Now, the app is being installed,
as I said,

00:45:24.450 --> 00:45:27.640
in this particular workflow using
Instruments in combination with Xcode.

00:45:27.720 --> 00:45:30.400
The app will actually be
installed on the phone for you.

00:45:30.640 --> 00:45:34.190
And it's doing all the
things that it does.

00:45:34.360 --> 00:45:38.140
Now it's launching Instruments itself
and then Instruments will actually

00:45:38.140 --> 00:45:42.260
launch Baffle Cocoa Touch on the device.

00:45:42.390 --> 00:45:46.670
So one of the great things about
having this type of display in

00:45:46.670 --> 00:45:50.960
Instruments where it's real time,
we're seeing all the effects of your

00:45:50.960 --> 00:45:55.140
app on the system as it happens,
is that I can easily judge

00:45:55.140 --> 00:45:57.100
when startup is over.

00:45:57.250 --> 00:46:01.330
So I can see this area in the front,
all this activity ceased.

00:46:01.440 --> 00:46:05.600
The app is basically idle now,
so I'm going to hit stop.

00:46:05.720 --> 00:46:08.610
And I'm going to drill down on
that and see what's going on,

00:46:08.680 --> 00:46:10.160
see if I can improve that.

00:46:10.320 --> 00:46:15.590
So I'm going to use the time scale here
in the left middle section of the window,

00:46:15.720 --> 00:46:17.500
stretch it out a bit.

00:46:17.640 --> 00:46:20.320
And I like using running sample times,
which if you attended

00:46:20.320 --> 00:46:23.200
the Getting Started with
Instruments session yesterday,

00:46:23.200 --> 00:46:26.000
Daniel Delwa did a great
job of explaining the

00:46:26.000 --> 00:46:26.860
differences in the time scale.

00:46:26.860 --> 00:46:28.920
So I'm going to go back to my previous
screen and using Sampler in this feature.

00:46:29.050 --> 00:46:30.560
So I'm going to select that.

00:46:30.650 --> 00:46:37.030
And if I go to the top here
and I go to my extended detail

00:46:37.030 --> 00:46:40.690
view and reorient my stack,

00:46:43.100 --> 00:46:48.600
I'm going to see that all the time
the top heavy hitters here are in my

00:46:48.600 --> 00:46:54.100
BG Sane Glass view in it with frame
calling into UI image image name.

00:46:54.100 --> 00:46:57.390
But let's double click on
that and see what's going on.

00:46:57.800 --> 00:47:03.190
So, here's my init method and
we have this loop here.

00:47:03.300 --> 00:47:04.640
What's going on here?

00:47:04.640 --> 00:47:09.060
Well, we're loading in a bunch of
images and stuffing them in this

00:47:09.160 --> 00:47:11.780
array pcontent's image--images.

00:47:11.780 --> 00:47:14.270
How many of these images are they?

00:47:14.590 --> 00:47:15.680
Well, are there?

00:47:15.860 --> 00:47:18.400
Well, there's about 50 of them.

00:47:18.410 --> 00:47:23.740
If I double click on this,
we can see the actual--it's 51 there.

00:47:23.740 --> 00:47:28.480
Now, these are actually the background
images for the hour sand glass.

00:47:28.490 --> 00:47:30.830
So, as time progresses and
the game is going on,

00:47:30.830 --> 00:47:34.400
your time is running out,
the hour glass runs down.

00:47:34.400 --> 00:47:38.040
There's a different image
for each level of the sand.

00:47:38.600 --> 00:47:40.950
Well,
it appears that we're loading all 50 plus

00:47:41.050 --> 00:47:47.650
of these images when we first create the
initial UI at startup time for the app.

00:47:47.880 --> 00:47:54.260
It also appears that we're
attempting to cache these away.

00:47:54.260 --> 00:47:54.260
Well,

00:47:54.550 --> 00:47:57.460
We don't really need to do
either one of these things.

00:47:57.630 --> 00:48:01.990
We don't need to load all
these images all at once,

00:48:01.990 --> 00:48:05.500
because it's not that big of a hit
to load one of these images every so

00:48:05.630 --> 00:48:10.380
often as the sand progresses downward
when the user is playing the game,

00:48:10.560 --> 00:48:13.700
because for most of the game,
the app isn't doing the

00:48:13.780 --> 00:48:17.090
thinking the user is,
trying to find a word.

00:48:17.210 --> 00:48:20.740
So there's plenty of horsepower
here left to load this image.

00:48:20.970 --> 00:48:24.340
The second thing is,
perhaps this developer thought that

00:48:24.490 --> 00:48:28.550
they could cache away this image
data so the next time they needed it,

00:48:28.550 --> 00:48:30.490
it would be faster to render.

00:48:30.520 --> 00:48:33.940
But actually, UIImage,
when you do image with name,

00:48:34.260 --> 00:48:37.370
handles caching behind
the scenes for you.

00:48:38.020 --> 00:48:41.660
So what I would assert is that
the best thing to do is actually

00:48:41.750 --> 00:48:47.130
simply create new instances of
UI image using image named when we

00:48:47.130 --> 00:48:50.370
actually need the background images.

00:48:50.560 --> 00:48:53.500
So let's see where we
actually use those images.

00:48:53.500 --> 00:48:56.890
So I'm going to do a project find.

00:48:57.540 --> 00:49:02.400
Object at index is probably
what's going on here.

00:49:02.490 --> 00:49:04.630
I'll do project.

00:49:05.520 --> 00:49:08.780
And we're loading it in
two different places here.

00:49:08.780 --> 00:49:11.090
Let me expand this window.

00:49:11.450 --> 00:49:14.680
And I'm going to hide
my project tree there.

00:49:14.730 --> 00:49:15.860
OK.

00:49:16.010 --> 00:49:22.380
So we have one image here, index zero,
in the actual init with frame.

00:49:22.440 --> 00:49:25.550
What that is is the initial background
image of the hourglass that you

00:49:25.710 --> 00:49:28.830
see when the game first starts,
but you haven't started playing.

00:49:29.020 --> 00:49:34.360
And the other one is basically
when time is progressing.

00:49:34.490 --> 00:49:37.270
So as time progresses,
we figure out the next image at

00:49:37.270 --> 00:49:40.640
a particular index to load in,
and we load that in.

00:49:40.640 --> 00:49:42.560
In this case,
we get it from the array because

00:49:42.560 --> 00:49:44.600
we loaded all these ahead of time.

00:49:44.660 --> 00:49:45.090
OK.

00:49:45.650 --> 00:49:51.970
So let's do what I suggested and just
load these images in as we need them.

00:49:52.200 --> 00:49:54.070
So I'm going to say,
I'm going to copy out this

00:49:54.080 --> 00:49:55.400
little line of code here.

00:49:55.400 --> 00:49:58.220
I'm going to reuse that and I'm
going to delete this section here.

00:49:58.460 --> 00:50:00.780
We don't need to do that anymore.

00:50:00.780 --> 00:50:07.860
And the first thing I'm going to do
is replace this initial image load,

00:50:07.860 --> 00:50:09.690
index position zero.

00:50:09.690 --> 00:50:09.690
And I'm going to go ahead and

00:50:11.820 --> 00:50:12.540
Save that away.

00:50:12.650 --> 00:50:15.120
And I'll go to the other line as well.

00:50:15.220 --> 00:50:19.010
And this is where we're actually
loading in the progressively

00:50:19.010 --> 00:50:20.910
lowering sand background.

00:50:20.930 --> 00:50:26.030
And I'll load this guy in.

00:50:28.330 --> 00:50:32.600
Okay, I'll build that, save everything.

00:50:32.630 --> 00:50:34.520
Okay, succeeded.

00:50:34.570 --> 00:50:36.330
So now let's go back
to the run menu again.

00:50:36.330 --> 00:50:39.230
One of the coolest things I like
about the integration of Xcode and

00:50:39.240 --> 00:50:42.150
instruments is that they're really
smart about how they interact.

00:50:42.340 --> 00:50:46.110
So Xcode knows that the last
thing it did was to run the

00:50:46.220 --> 00:50:48.600
CPU sampler in instruments.

00:50:48.600 --> 00:50:52.830
So I can just select that again and
it's going to go and install the app

00:50:52.830 --> 00:50:54.760
again and do all the things it does.

00:50:54.880 --> 00:50:58.910
And it also, working with instruments,
will then be able to say to instruments,

00:50:59.090 --> 00:51:02.000
hey, you know,
this is another trace using CPU sampler,

00:51:02.090 --> 00:51:05.300
but it's against that same thing you
just opened up a trace document for.

00:51:05.300 --> 00:51:07.330
So can you reuse that previous document?

00:51:07.510 --> 00:51:10.800
We'll see how that becomes
handy in a little bit.

00:51:10.840 --> 00:51:15.080
So now I've launched my app again and
again with instruments we can see that

00:51:15.080 --> 00:51:19.170
we had this little bit of activity
and now we seem to have reached idle.

00:51:19.330 --> 00:51:23.430
So let's take a look and see if
we've cleared up that startup time.

00:51:23.440 --> 00:51:26.400
So first of all,
if I sort by running time again,

00:51:26.400 --> 00:51:29.880
I can see that, well,
all those big samples that I saw earlier,

00:51:29.880 --> 00:51:30.890
they're gone.

00:51:30.890 --> 00:51:36.580
We don't see anything in my init method,
as we would have expected,

00:51:36.740 --> 00:51:38.990
that is loading those images.

00:51:38.990 --> 00:51:42.070
And if I wanted to visually
just to compare it,

00:51:42.190 --> 00:51:45.880
do a very quick look at
whether I improved performance,

00:51:45.880 --> 00:51:49.180
I could go to the left-hand
side of the screen.

00:51:49.200 --> 00:51:51.480
I can go to the left-hand side
of the sampler instrument and

00:51:51.560 --> 00:51:53.700
twist down this twisty here,
and I can visually

00:51:53.700 --> 00:51:54.790
compare the previous run.

00:51:54.810 --> 00:51:58.180
So it's pretty easy to just
see that in the first run,

00:51:58.180 --> 00:52:00.810
without the performance
optimization at startup time,

00:52:00.810 --> 00:52:02.320
it took about this much time.

00:52:02.320 --> 00:52:05.150
And, you know, when I optimized it,
then we're down to just

00:52:05.150 --> 00:52:06.740
this little bit of activity.

00:52:06.740 --> 00:52:07.540
So that's great.

00:52:07.540 --> 00:52:08.180
Excellent.

00:52:08.180 --> 00:52:14.540
The one last thing to do is to
look at what I asserted earlier.

00:52:14.540 --> 00:52:18.950
I asserted that if I create, say,
UI and Android applications,

00:52:18.950 --> 00:52:19.180
I can visually compare the previous run.

00:52:19.180 --> 00:52:19.180
So it's pretty easy to just
see that in the first run,

00:52:19.180 --> 00:52:19.180
without the performance
optimization at startup time,

00:52:19.180 --> 00:52:19.180
it took about this much time.

00:52:19.180 --> 00:52:19.180
And, you know, when I optimized it,
then we're down to just

00:52:19.180 --> 00:52:19.180
this little bit of activity.

00:52:19.180 --> 00:52:19.180
So that's great.

00:52:19.180 --> 00:52:19.180
Excellent.

00:52:19.180 --> 00:52:23.470
image, image name with BG timer 1,
the timer images are called BG timer 1,

00:52:23.470 --> 00:52:28.000
BG timer 2, BG timer 3, et cetera,
if I loaded BG timer 1 and then

00:52:28.190 --> 00:52:31.620
I created a new instance of
UIM image with the same name,

00:52:31.620 --> 00:52:34.980
BG timer 1, that that data would not
be loaded in again even if

00:52:34.980 --> 00:52:38.010
I deallocated the previous instance.

00:52:38.090 --> 00:52:42.250
So let's use that IO activity
instrument to see if that

00:52:42.250 --> 00:52:44.090
assertion was actually correct.

00:52:44.090 --> 00:52:46.520
So I'm going to go start
a new trace document.

00:52:46.660 --> 00:52:52.020
I'm going to go to my iPhone category of
templates now since I'm actually running

00:52:52.020 --> 00:52:54.530
instruments against the iPhone itself.

00:52:54.530 --> 00:52:57.570
I'm going to go to the
system usage template,

00:52:57.570 --> 00:52:58.590
select that,

00:52:58.910 --> 00:53:04.900
And I'm going to launch my
bafflecoco touch app again.

00:53:05.030 --> 00:53:11.530
Instruments conveniently will list just
the apps that it sees on the device.

00:53:12.520 --> 00:53:15.900
And I'm going to start that up again.

00:53:15.900 --> 00:53:21.770
And if we could go to the iPhone
device display for a moment,

00:53:21.770 --> 00:53:23.270
I'd appreciate that.

00:53:25.190 --> 00:53:30.560
Okay, so let's just make sure first
of all that the hourglass lowers

00:53:30.910 --> 00:53:35.780
because we don't want to have
optimized by breaking the entire app.

00:53:36.160 --> 00:53:41.040
So the game starts and we can see down
here that the hourglass is lowering.

00:53:41.120 --> 00:53:43.180
So let's let it go
through all of its paces.

00:53:43.420 --> 00:53:45.490
Let's switch back to the demo machine,
please.

00:53:45.640 --> 00:53:47.420
Demo six.

00:53:48.590 --> 00:53:52.790
Now if we go down to the bottom
of this I/O Activity Instrument

00:53:52.790 --> 00:53:54.570
and I search for BG Timer,

00:53:55.180 --> 00:53:58.300
We're filtered by all those timers
so we can see the new images as they

00:53:58.300 --> 00:54:02.560
were loaded in so the app has ended.

00:54:02.560 --> 00:54:04.860
The time is over now,
but it's still running.

00:54:04.970 --> 00:54:09.170
So now what I'm going to do is
I'm going to start the game again.

00:54:09.630 --> 00:54:13.560
and the images,
the hourglass will begin to lower again.

00:54:13.560 --> 00:54:15.240
I'm not going to keep switching
back and forth on you.

00:54:15.410 --> 00:54:16.470
That would be a little crazy.

00:54:16.770 --> 00:54:19.180
But if we look now at
the instrument again,

00:54:19.310 --> 00:54:22.040
though the hourglass
images are appearing,

00:54:22.040 --> 00:54:24.680
they're not being
reloaded from the phone,

00:54:24.680 --> 00:54:30.700
even though I was just instantiating
new UI image instances with new names.

00:54:30.800 --> 00:54:35.140
So I would say that we successfully
optimized the app and dealt

00:54:35.140 --> 00:54:36.980
with startup time there.

00:54:37.060 --> 00:54:39.270
Of course, optimization is never over.

00:54:39.630 --> 00:54:42.900
If we can go back to the slides, please.

00:54:43.680 --> 00:54:46.440
There could have been other
places where I still could

00:54:46.550 --> 00:54:48.280
have optimized startup time.

00:54:48.450 --> 00:54:50.870
So it's always nail the first guy,
the biggest guy,

00:54:50.870 --> 00:54:54.120
and then go down to the next guy,
and the next guy, and the next guy,

00:54:54.120 --> 00:54:57.210
until you can't get to any of your
code and it's just the system.

00:54:57.210 --> 00:55:00.700
But we did a pretty good job of using
Instruments there against the app on

00:55:00.700 --> 00:55:03.200
the device to optimize startup time.

00:55:03.310 --> 00:55:07.720
So today we've talked about
a lot of very cool tools,

00:55:07.800 --> 00:55:10.060
very powerful analysis
and profiling tools.

00:55:10.340 --> 00:55:12.810
Our premier tools of
Xcode and the debugger,

00:55:12.810 --> 00:55:15.200
of Instruments, and Shark.

00:55:15.350 --> 00:55:19.600
We've also talked about our command
line tools that I have available on

00:55:19.650 --> 00:55:22.700
the simulator and on the Mac side.

00:55:23.000 --> 00:55:32.230
So I think the tool bag is pretty full
in that you have enough to go forth

00:55:32.230 --> 00:55:36.450
and make your apps robust and fast,
make them have a low memory

00:55:36.450 --> 00:55:39.760
footprint as possible,
make efficient use of the file system,

00:55:40.070 --> 00:55:43.510
and draw really great fast graphics.

00:55:43.690 --> 00:55:48.380
So with that, of course, the usual,
you can contact Michael Jurowicz

00:55:48.380 --> 00:55:50.060
for more information.

00:55:50.060 --> 00:55:55.010
You can look up various of these
helpful URLs for performance docs.

00:55:55.110 --> 00:55:59.590
And there's a bit of a quandary that
I have and I'm going to put you into

00:55:59.620 --> 00:56:03.900
as well today because at 3:30 today,
there's two sessions

00:56:03.900 --> 00:56:06.100
that I'd like to be in.

00:56:06.100 --> 00:56:08.830
There's optimizing performance
for your iPhone application.

00:56:09.130 --> 00:56:11.520
There's also using DTrace on Mac OS X.

00:56:11.520 --> 00:56:15.290
So I didn't set that schedule up,
but we'll all be running back

00:56:15.290 --> 00:56:18.020
and forth passing each other,
I guess.

00:56:18.020 --> 00:56:20.060
Also, performance tuning your
application with Sharp.

00:56:20.060 --> 00:56:21.930
Sharp is an awesome tool.

00:56:22.060 --> 00:56:24.060
So check that out at 5:00 today.

00:56:24.060 --> 00:56:26.350
And finally, tomorrow,
we have our advanced

00:56:26.350 --> 00:56:28.030
instruments and DTrace session.

00:56:28.150 --> 00:56:34.640
So you can look at how one would build
custom DTrace instruments as I did

00:56:34.690 --> 00:56:38.060
earlier for that over-release issue.
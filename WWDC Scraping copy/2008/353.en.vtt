WEBVTT

00:00:20.490 --> 00:00:23.400
Good morning.

00:00:23.550 --> 00:00:29.300
This is the What's New in
Objective-C and C and C++ talk.

00:00:29.300 --> 00:00:31.010
My name is Blaine Garst.

00:00:31.010 --> 00:00:34.690
I work on runtimes.

00:00:34.690 --> 00:00:42.780
And so let's find out what
we have cooking on your seed,

00:00:42.790 --> 00:00:42.790
on your

00:00:45.050 --> 00:00:50.000
So first let's talk a little
bit about Objective-C evolution.

00:00:50.020 --> 00:00:54.430
It turns out Objective-C has
changed over time and most of the

00:00:54.430 --> 00:00:56.990
change happened in its early days.

00:00:57.040 --> 00:01:01.810
And in the early late 80s, early 90s,
very early 90s,

00:01:02.030 --> 00:01:06.940
the major changes in the language were
made when it moved from a preprocessor

00:01:07.060 --> 00:01:12.100
into GNU and syntax changed and
we added some features and stuff.

00:01:12.200 --> 00:01:15.900
But it stayed pretty much
the same for quite a while.

00:01:15.930 --> 00:01:18.220
This was what we used at Next.

00:01:18.330 --> 00:01:22.800
This is what we used on Mac OS X Cheetah,
on Puma, on Jaguar.

00:01:22.800 --> 00:01:25.870
Even back then, though,
we were kind of looking at the language

00:01:25.870 --> 00:01:28.470
and looking at Java and we're going,
well, you know,

00:01:28.470 --> 00:01:30.580
we could probably improve some things.

00:01:30.630 --> 00:01:37.260
And so we took a small step forward
in 03 in the Panther release by

00:01:37.260 --> 00:01:41.980
introducing a better exception construct.

00:01:42.160 --> 00:01:45.120
And a better synchronization construct.

00:01:45.240 --> 00:01:47.600
But that's, you know,
fairly small changes.

00:01:47.950 --> 00:01:50.720
But we kind of liked that idea.

00:01:50.820 --> 00:01:54.500
We took a look at the patterns
that we used in Cocoa and said,

00:01:54.570 --> 00:01:56.010
you know, we could do a lot better.

00:01:56.100 --> 00:02:00.060
And we had been working on
this other thing called garbage

00:02:00.060 --> 00:02:04.590
collection for a while and some
of that actually got out in Tiger,

00:02:04.590 --> 00:02:05.790
it turns out.

00:02:06.090 --> 00:02:10.240
When Leopard came out in '07,
we ended up delivering a

00:02:10.380 --> 00:02:12.240
whole bunch of features.

00:02:12.380 --> 00:02:15.180
And again now,
as you preview Snow Leopard,

00:02:15.180 --> 00:02:17.430
we're introducing just a few more.

00:02:17.510 --> 00:02:22.020
And so we sort of are going to call
this new thing Objective-C 2.1.

00:02:22.120 --> 00:02:26.380
So what we're going to talk about today
is the most recent set of changes.

00:02:26.420 --> 00:02:29.960
In particular,
the Objective-C 2.0 language is what you

00:02:29.960 --> 00:02:33.360
will find on Leopard and on the iPhone.

00:02:33.440 --> 00:02:36.960
And then we'll spend some time
talking about 2.1 features that

00:02:36.960 --> 00:02:39.960
are available only on Snow Leopard.

00:02:40.010 --> 00:02:41.460
So let's get started.

00:02:41.520 --> 00:02:42.810
Ah, I forgot.

00:02:42.990 --> 00:02:45.440
That one thing we heard about, blocks.

00:02:45.570 --> 00:02:49.130
We're going to spend a fair amount
of time talking about blocks.

00:02:49.310 --> 00:02:50.980
Objective-C 2.0.

00:02:51.160 --> 00:02:55.080
So this is, well, I wouldn't say review,
but

00:02:55.760 --> 00:02:58.140
Let's review!

00:02:58.290 --> 00:03:02.280
First thing we did was add the
for in statement which is a fast,

00:03:02.500 --> 00:03:05.700
concise, and safe way to travel
through collections.

00:03:05.700 --> 00:03:08.380
So, in this case,
walking through an array,

00:03:08.480 --> 00:03:11.700
this is the fastest way you
can go through an array.

00:03:11.700 --> 00:03:14.550
It's faster than doing objected index.

00:03:14.700 --> 00:03:17.680
It's faster than creating an
object enumerator and going

00:03:17.870 --> 00:03:19.620
through the object enumerator.

00:03:19.850 --> 00:03:24.700
It's just faster and it's safer because
we have a mutator check in there to say,

00:03:24.740 --> 00:03:27.080
"If somebody changed the
array underneath you,

00:03:27.210 --> 00:03:29.190
then the next time you
go after an object,

00:03:29.190 --> 00:03:31.900
you'll get an exception." So,
we like that.

00:03:32.060 --> 00:03:34.700
We like the concise
way to go through that.

00:03:34.700 --> 00:03:37.700
The for in statement is just nice.

00:03:37.700 --> 00:03:39.820
Of course,
it applies to more than arrays.

00:03:39.820 --> 00:03:41.700
It applies to any collection class.

00:03:41.700 --> 00:03:44.660
Actually, any class that implements
this particular protocol.

00:03:44.730 --> 00:03:48.700
So, if you've got a set of stuff you want
to vend via the for in statement,

00:03:48.700 --> 00:03:52.670
you just implement this fast
enumeration protocol and you can use

00:03:52.860 --> 00:03:53.700
the language feature to get to it.

00:03:53.810 --> 00:03:56.690
So, in this case,
we're enumerating a dictionary.

00:03:56.690 --> 00:03:59.540
We get the keys out of the dictionary.

00:03:59.700 --> 00:04:02.960
Well, it's quite often the case that
you actually want the values that

00:04:02.960 --> 00:04:04.690
are associated with those keys.

00:04:04.700 --> 00:04:07.700
And so,
you have to go and get the value back.

00:04:07.700 --> 00:04:11.100
And people said, "Well,
why can't you do sort of like for key

00:04:11.100 --> 00:04:15.660
and value in dictionary?" And we go,
"Well, that's really hard to get the

00:04:15.760 --> 00:04:19.880
syntax and make the handshakes
and all sorts of stuff." So,

00:04:20.140 --> 00:04:22.700
although for in is very good for
doing one way through your collection,

00:04:22.700 --> 00:04:27.560
it's very bad in that it only goes
one way through your collection.

00:04:27.700 --> 00:04:30.660
But, you know, it's pretty good,
pretty nice.

00:04:30.700 --> 00:04:35.630
One of the nicest things about it is
that the way you go through collections

00:04:35.730 --> 00:04:39.700
in different ways is you build an
object enumerator of some kind.

00:04:39.700 --> 00:04:41.700
There's many different
enumeration methods.

00:04:41.840 --> 00:04:44.890
And we built the fast enumeration
protocol on that so you can use the for

00:04:44.890 --> 00:04:47.700
in statement with any object enumerator.

00:04:47.700 --> 00:04:49.700
And at least you get some
conciseness out of it.

00:04:49.700 --> 00:04:51.700
So, we like that.

00:04:51.700 --> 00:04:55.860
These are all very -- one of the things
-- one of the reasons they're fast is

00:04:55.900 --> 00:04:58.700
that they allocate no extra memory.

00:04:58.700 --> 00:05:02.700
It uses a little stack buffer
to rip through the stuff.

00:05:02.700 --> 00:05:04.760
And so,
we like the idea that you don't have to

00:05:04.760 --> 00:05:06.700
create memory to go through a collection.

00:05:06.700 --> 00:05:09.700
Because going through collections
is something you do quite often.

00:05:11.400 --> 00:05:15.860
Another thing we did was we added
an optional statement in protocols.

00:05:15.990 --> 00:05:19.040
Now protocols are, we're

00:05:19.320 --> 00:05:32.250
We extended them with the optional
keyword so that you don't have to

00:05:32.250 --> 00:05:34.600
implement all the optional methods.

00:05:34.600 --> 00:05:36.790
You can implement some of them.

00:05:37.330 --> 00:05:41.790
So an example here, a guest, for example,
has to implement the

00:05:41.930 --> 00:05:45.380
RSVP but can do either eat,
drink, or laugh.

00:05:45.500 --> 00:05:48.680
And then you can build an adult object
that does the eat and drink method,

00:05:48.680 --> 00:05:52.170
and you can build a child object
that just does the eat and laugh.

00:05:54.260 --> 00:05:56.920
Then you can have one kind of
a party that takes a guest,

00:05:56.920 --> 00:06:00.750
another kind of party that
takes a different kind of guest.

00:06:00.760 --> 00:06:05.320
So you get to reuse the protocol idea
across many different implementations.

00:06:05.420 --> 00:06:07.600
Now, this is kind of a silly example.

00:06:07.600 --> 00:06:11.820
In truth, what we're doing is for the
delegate methods inside the app kit.

00:06:11.940 --> 00:06:14.930
Now,
delegation is a very powerful technique

00:06:14.940 --> 00:06:21.170
where a large object like the application
has an object called its delegate.

00:06:22.020 --> 00:06:25.260
And the delegate gets to implement
sort of extender behavior.

00:06:25.260 --> 00:06:26.580
It gets to do the fun stuff.

00:06:26.580 --> 00:06:32.720
So we have these fun stuff methods,
and the application object says,

00:06:32.720 --> 00:06:35.650
if I have a delegate,
does that delegate implement

00:06:35.750 --> 00:06:38.320
this particular method
that does the fun stuff?

00:06:38.410 --> 00:06:40.240
And if it does, it calls out to that.

00:06:40.360 --> 00:06:42.010
So that's a very powerful technique.

00:06:42.020 --> 00:06:46.510
And so what this does is specify
the methods on how you do that,

00:06:46.620 --> 00:06:49.160
which methods you can implement.

00:06:49.160 --> 00:06:51.920
And it helps make your
code more readable.

00:06:51.940 --> 00:06:55.120
and nicer.

00:06:55.770 --> 00:07:00.010
So it turns out that the AppKit is
introducing these protocols,

00:07:00.010 --> 00:07:03.850
and on the phone,
they get to use them quite a bit more.

00:07:03.860 --> 00:07:12.260
So we see delegate methods being used
in both the AppKit and in the UIKit.

00:07:12.260 --> 00:07:17.040
And in the case of UIKit,
where they're writing brand new APIs,

00:07:17.040 --> 00:07:22.480
they get to specify that, you know,
when they have the set delegate method,

00:07:22.930 --> 00:07:27.000
they get to specify the type of that
delegate coming in using that protocol,

00:07:27.000 --> 00:07:30.680
which lets you, you know,
it helps you understand what that thing

00:07:30.720 --> 00:07:32.700
does and what you need to do to do that.

00:07:32.780 --> 00:07:37.860
That funny syntax, ID, UI, modal view,
delegate, says...

00:07:38.850 --> 00:07:44.810
Any object that conforms to this
protocol can be sent in as the delegate.

00:07:46.330 --> 00:07:50.000
The other thing we looked at in
Objective-C 2.0 were setters and getters.

00:07:50.260 --> 00:07:52.460
So this is your typical

00:07:52.660 --> 00:07:55.650
You got an instance variable and you
write a setter and a getter access

00:07:55.650 --> 00:07:58.600
method because you don't want to
make the instance variable public.

00:07:58.600 --> 00:08:01.930
You don't want people just
hacking on your instance variable.

00:08:01.960 --> 00:08:03.240
You want them to go through some methods.

00:08:03.410 --> 00:08:06.540
And that gives you a level of
control and flexibility monitoring,

00:08:06.540 --> 00:08:07.680
all kinds of stuff.

00:08:07.770 --> 00:08:09.070
You don't even have to
have an instance variable,

00:08:09.070 --> 00:08:09.460
really.

00:08:09.460 --> 00:08:12.730
You can just implement it
through magic if you want it.

00:08:12.760 --> 00:08:15.920
So this is a very typical pattern.

00:08:15.920 --> 00:08:20.550
And the issues with it are
that it's tedious to write.

00:08:21.100 --> 00:08:23.670
And in fact, error-prone to implement.

00:08:23.680 --> 00:08:27.040
And so there's other things.

00:08:27.060 --> 00:08:30.380
It's like, well,
there's things about that interface

00:08:30.380 --> 00:08:31.800
that you actually don't know.

00:08:31.820 --> 00:08:35.840
And you have to go to the documentation
to find out if there is documentation.

00:08:35.840 --> 00:08:40.410
So we didn't like these
things about this.

00:08:40.420 --> 00:08:44.200
And even when you go
to use these accessors,

00:08:44.200 --> 00:08:48.540
they're kind of, again,
tedious and cumbersome to use.

00:08:48.630 --> 00:08:50.870
So the first thing we did
was we improved accessors.

00:08:51.180 --> 00:08:53.560
We improved access by
introducing the dot syntax.

00:08:53.560 --> 00:08:59.790
So wherever you used to see set title
or get title or something like that,

00:08:59.800 --> 00:09:02.750
you can now use the dot syntax to do it.

00:09:02.790 --> 00:09:03.700
And it's very straightforward.

00:09:03.700 --> 00:09:10.440
And we reused dot because every object
in Objective-C comes off the heap.

00:09:10.570 --> 00:09:13.450
And so there is no sort of
local thing on the stack that

00:09:13.510 --> 00:09:15.300
you would use dot for anyway.

00:09:15.300 --> 00:09:17.130
So it's an unused syntax for us.

00:09:17.160 --> 00:09:20.680
And so we used it to say we're
going to send methods there.

00:09:20.680 --> 00:09:21.080
But you could.

00:09:21.080 --> 00:09:21.670
You get to write them.

00:09:21.690 --> 00:09:23.590
So these two are exactly equivalent.

00:09:23.600 --> 00:09:27.980
The compiler just synthesizes
these messages underneath you.

00:09:27.980 --> 00:09:30.110
And you just get to write
things in a simpler way.

00:09:33.750 --> 00:09:37.300
Unfortunately, the compiler just sort of
does this pattern match,

00:09:37.440 --> 00:09:42.120
and so you can actually use dot syntax
in places sometimes where you shouldn't.

00:09:42.120 --> 00:09:47.390
But anyway, for convenience,
we just relax the rules a little bit.

00:09:47.990 --> 00:09:52.120
So the second thing we wanted to
look at was how do you simplify

00:09:52.120 --> 00:09:54.170
declaration and implementation.

00:09:54.330 --> 00:09:59.040
So we turned the setter-getter
pattern into a language

00:09:59.040 --> 00:10:00.940
concept called a property.

00:10:01.090 --> 00:10:04.730
So where you wrote
before that other stuff,

00:10:04.810 --> 00:10:09.150
you can now simply write
@property copy and a string

00:10:09.590 --> 00:10:12.730
doc name and get your job done.

00:10:12.730 --> 00:10:12.730
So you can use

00:10:13.700 --> 00:10:20.140
You can use properties inside classes,
as we see here, but also inside protocols

00:10:20.900 --> 00:10:23.630
or inside categories.

00:10:23.720 --> 00:10:27.000
Now, that funny thing, copy,
is what I was talking about before.

00:10:27.070 --> 00:10:31.070
Copy, in this case,
says that when you set it,

00:10:31.780 --> 00:10:34.700
The setter is actually gonna make
a copy of your input strings.

00:10:34.700 --> 00:10:41.160
You can supply a mutable string to
this as the value in the setter,

00:10:41.240 --> 00:10:44.480
and a copy will be made,
and so you can feel free.

00:10:44.500 --> 00:10:48.460
You can knowingly go ahead and
change your mutable string later,

00:10:48.490 --> 00:10:52.110
knowing that whatever value
you had is well preserved.

00:10:52.290 --> 00:10:55.800
So this is a very important
aspect of the interface.

00:10:55.800 --> 00:10:59.200
And so we get a place to say
that now in the interface.

00:10:59.240 --> 00:11:03.690
It's part of the contract
that this class provides.

00:11:04.240 --> 00:11:07.120
There are many or several
different sets of attributes,

00:11:07.120 --> 00:11:09.920
and I wanted to talk about them because
you're going to see them in interfaces,

00:11:09.920 --> 00:11:11.550
and you might as well
know what they mean.

00:11:11.760 --> 00:11:13.950
So assign is the default.

00:11:13.960 --> 00:11:15.490
If you don't say anything,
you get assigned.

00:11:15.500 --> 00:11:19.880
This turns out to be,
under non-garbage-collected environments,

00:11:19.880 --> 00:11:21.600
a bad thing to do for objects.

00:11:21.620 --> 00:11:23.290
So the compiler warns about that.

00:11:23.340 --> 00:11:25.820
So assign is we just sort
of copy the bits over.

00:11:25.820 --> 00:11:28.640
Under garbage collection,
we apply garbage collection

00:11:28.820 --> 00:11:30.460
write barrier technology.

00:11:30.460 --> 00:11:35.480
And so under that environment,
assign is the default.

00:11:35.480 --> 00:11:36.580
It just sort of works.

00:11:36.580 --> 00:11:38.800
Your pointers are held the way
you kind of want them to be.

00:11:38.800 --> 00:11:43.320
Under a non-GC environment,
retain is what you expect.

00:11:43.320 --> 00:11:46.350
We retain the object coming
in and hold onto it strongly.

00:11:46.360 --> 00:11:47.830
You can create graphs.

00:11:47.940 --> 00:11:51.840
I'm sorry, you can create cycles
using the retain primitive.

00:11:51.840 --> 00:11:57.430
Otherwise, assign just kind of takes that
pointer and holds onto it,

00:11:57.430 --> 00:12:00.370
and it's going to dangle if it goes away,
and you don't.

00:12:00.490 --> 00:12:00.990
Undo it.

00:12:01.100 --> 00:12:03.320
But these are two common
patterns in Cocoa,

00:12:03.320 --> 00:12:05.170
and we needed to support them both.

00:12:06.820 --> 00:12:10.140
As you saw before,
copy makes a copy of the input thing.

00:12:10.140 --> 00:12:16.490
And so these are three
attributes you apply to objects.

00:12:18.550 --> 00:12:23.730
Non-atomic-- oh, and you choose one of
the above three-- assign,

00:12:23.730 --> 00:12:25.340
retain, or copy.

00:12:26.060 --> 00:12:28.440
A property can have the
non-atomic attribute,

00:12:28.440 --> 00:12:30.770
and what that means is it's not atomic.

00:12:30.770 --> 00:12:35.720
By default, properties are atomic,
which means when you go to change them,

00:12:35.720 --> 00:12:37.140
the change happens.

00:12:37.140 --> 00:12:41.480
If you assign a structure,
like a rectangle or a larger structure,

00:12:41.480 --> 00:12:46.080
you need to know that it all gets
there in a multi-threaded context.

00:12:46.080 --> 00:12:47.950
Either all of it's there or not.

00:12:48.020 --> 00:12:51.900
So the default being atomic was the
right way to go in the face of multi-core

00:12:52.060 --> 00:12:54.140
and multi-threaded programming.

00:12:55.320 --> 00:12:58.540
However, at a setter,
going and getting little items at a

00:12:58.540 --> 00:13:00.920
time might not make sense totally.

00:13:00.920 --> 00:13:05.240
Sometimes you'll have a different context
around access to getters and setters.

00:13:05.320 --> 00:13:07.600
You might have your own
at-synchronized statement,

00:13:07.650 --> 00:13:09.580
or you might have your
other locking things,

00:13:09.580 --> 00:13:11.870
such that you change two
or three things at once.

00:13:11.870 --> 00:13:15.450
And what non-atomic says is don't
go to the bother of making them

00:13:15.760 --> 00:13:19.420
intensely thread-safe because
you already know better and are

00:13:19.420 --> 00:13:22.190
going to do that on your own,
or you know that you

00:13:22.290 --> 00:13:23.910
don't need to do that.

00:13:23.920 --> 00:13:27.180
So non-atomic gives you a
faster implementation of getters

00:13:27.270 --> 00:13:31.820
and setters under non-GC,
and is used for speed where

00:13:31.820 --> 00:13:35.180
you know you can use the speed.

00:13:36.470 --> 00:13:38.980
The interface,
we use methods to get to things.

00:13:39.110 --> 00:13:41.960
Sometimes for historical
or aesthetic reason,

00:13:41.960 --> 00:13:44.860
you might not just want the
names that we provide by default.

00:13:45.000 --> 00:13:48.760
So you can specify the names you want.

00:13:49.060 --> 00:13:53.330
And finally, you can declare your
property to be read only,

00:13:53.330 --> 00:13:55.520
meaning you just have a getter.

00:13:55.520 --> 00:13:58.820
And later,
you can actually override that, say,

00:13:58.820 --> 00:14:01.460
in a subclass or in a
category or something,

00:14:01.460 --> 00:14:03.370
and say, it's actually read-write.

00:14:03.460 --> 00:14:05.210
We can add a setter.

00:14:05.300 --> 00:14:07.800
So read-write is the default.

00:14:07.800 --> 00:14:10.920
You have to say read only
to say we only do a getter.

00:14:11.080 --> 00:14:16.460
So so far, I've talked about how
properties help the interface,

00:14:16.520 --> 00:14:18.360
help the specification.

00:14:18.370 --> 00:14:21.950
On the implementation side,
we also said writing those setters and

00:14:21.950 --> 00:14:23.860
getters is tedious and error prone.

00:14:23.860 --> 00:14:26.550
And so let's let the
compiler and runtime do it.

00:14:26.750 --> 00:14:28.940
So we do that with a
synthesize statement.

00:14:29.040 --> 00:14:33.060
So inside your implementation,
you provide an at synthesize statement.

00:14:33.080 --> 00:14:38.280
And it tells the compiler to fill in the
implementation if it doesn't find one.

00:14:38.990 --> 00:14:41.770
On the new runtime,
which is what we use on

00:14:41.770 --> 00:14:45.590
64-bit on the iPhone,
it will actually synthesize the

00:14:45.590 --> 00:14:48.530
instance variable if you haven't
supplied the instance variable.

00:14:48.540 --> 00:14:52.410
So it makes writing simple
properties just dead simple

00:14:52.520 --> 00:14:54.510
and fast and does it right.

00:14:54.560 --> 00:14:57.910
You can choose to back your
property with an instance

00:14:58.000 --> 00:15:00.320
variable with a different name.

00:15:01.730 --> 00:15:05.480
And you can choose to implement your
getters and setters at runtime and tell

00:15:05.600 --> 00:15:09.540
the compiler you're going to do that and
not to warn you when it doesn't find it.

00:15:09.640 --> 00:15:16.700
So we will talk more about how these
low-level mechanisms work on Friday,

00:15:16.700 --> 00:15:19.840
and I'll have a pointer to the
talk on Friday a little bit later.

00:15:21.790 --> 00:15:25.880
I mentioned this newer runtime,
a modern runtime.

00:15:25.910 --> 00:15:28.550
It has a lot of very nice
features in it that are sort

00:15:28.550 --> 00:15:31.010
of independent of the language,
but suddenly you get to do

00:15:31.010 --> 00:15:32.360
new things in the language.

00:15:32.360 --> 00:15:34.270
For example,
this thing called non-fragile

00:15:34.310 --> 00:15:35.380
instance variables.

00:15:35.380 --> 00:15:40.230
It turns out you don't have to expose
the actual layout of your object.

00:15:40.230 --> 00:15:44.520
You don't have to swear by that across
releases because your subclassers

00:15:44.810 --> 00:15:48.890
know exactly where everything is,
and you can't change that underneath

00:15:48.890 --> 00:15:51.660
subclassers that have already shipped.

00:15:51.850 --> 00:15:55.230
So there's a lot of really
nice features in the runtime,

00:15:55.230 --> 00:15:59.680
and we will definitely talk about
those more on Friday at this talk.

00:16:03.330 --> 00:16:06.090
The big thing in Objective-C 2.0
was garbage collection.

00:16:06.090 --> 00:16:11.270
It is the motivator for changing,
putting the 2.0 on it.

00:16:11.280 --> 00:16:14.040
Garbage collection is a
fabulous way to program.

00:16:14.040 --> 00:16:18.030
It is currently only on
our Mac OS X platforms.

00:16:18.040 --> 00:16:23.080
Every framework on the system is
garbage collectible compatible,

00:16:23.080 --> 00:16:27.010
and we have seen some
fantastic applications built

00:16:27.110 --> 00:16:30.860
on top of core animation,
all of our WebKit,

00:16:30.860 --> 00:16:34.620
all of our heavy-duty frameworks.

00:16:34.760 --> 00:16:37.390
It lets you, of course, do, you know,
when you code,

00:16:37.390 --> 00:16:40.570
when you think about designing things,
it gives you new cycles,

00:16:40.570 --> 00:16:42.330
new patterns to program with.

00:16:42.540 --> 00:16:43.770
Cycles are okay now.

00:16:43.790 --> 00:16:46.780
We have these things called
zeroing weak references,

00:16:46.780 --> 00:16:49.300
which lets you keep weak pointers,
you know,

00:16:49.300 --> 00:16:52.960
non-retained pointers to things,
and they zero out automatically

00:16:52.970 --> 00:16:54.570
when the object goes away.

00:16:54.620 --> 00:16:57.540
It makes, it's,
they're fun to program with.

00:16:58.860 --> 00:17:04.270
However, garbage collection programs,
they run fast, they have been shown

00:17:04.270 --> 00:17:07.900
to run in less memory,
and they, of course,

00:17:07.900 --> 00:17:11.690
have fewer crashes and leaks.

00:17:12.020 --> 00:17:17.300
So what we have in Mac OS X is a
fairly sophisticated collector,

00:17:17.300 --> 00:17:18.660
and I wanted to go
through it a little bit.

00:17:18.720 --> 00:17:21.540
So right now you might
have several threads,

00:17:21.640 --> 00:17:23.070
main, a couple worker threads.

00:17:23.080 --> 00:17:27.520
You've got some global graph of objects,
your documents, you know,

00:17:27.520 --> 00:17:30.230
the stuff that's in your application,
and you've got a heap.

00:17:30.780 --> 00:17:34.620
So what happens is, you know,
a thread will, you know,

00:17:34.620 --> 00:17:39.310
allocate a couple objects and change,
you know, the global graph.

00:17:39.420 --> 00:17:43.650
And on average,
about half the objects allocated

00:17:43.690 --> 00:17:46.710
are actually just temporaries.

00:17:46.720 --> 00:17:50.160
So the temporaries are discarded,
and so another thread can

00:17:50.160 --> 00:17:51.810
kind of do the same thing.

00:17:51.820 --> 00:17:55.190
And, of course...

00:17:57.080 --> 00:17:58.930
You can lop things off the global graph.

00:17:59.090 --> 00:18:00.250
You can change the global graph.

00:18:00.350 --> 00:18:01.370
You can delete a document.

00:18:01.380 --> 00:18:04.560
And so what happens is we have
a two-stage kind of collector.

00:18:04.690 --> 00:18:07.300
We have a generational collector,
which comes in.

00:18:07.300 --> 00:18:11.600
It uses write barriers to detect
whether the newest objects

00:18:11.600 --> 00:18:14.000
are still interesting or not.

00:18:14.000 --> 00:18:18.730
And so a generational collector generally
comes in and sweeps up the temporaries

00:18:18.750 --> 00:18:20.460
that you haven't done much with.

00:18:20.540 --> 00:18:24.370
And then we have a background
full collection that will

00:18:24.930 --> 00:18:26.700
pick up everything else.

00:18:27.000 --> 00:18:29.760
So we have a two-stage collector there.

00:18:30.130 --> 00:18:35.170
So with that,
let me shift into Objective-C 2.1.

00:18:35.170 --> 00:18:37.660
But keeping in the
garbage collection theme,

00:18:37.690 --> 00:18:39.180
let's talk about that first.

00:18:39.270 --> 00:18:39.920
Oh, yeah, I forgot.

00:18:39.920 --> 00:18:40.550
No more badges.

00:18:40.630 --> 00:18:45.140
From here on out in the talk,
it's new stuff for Snow Leopard.

00:18:45.840 --> 00:18:49.600
So the first thing we added was something
we call thread local collection.

00:18:49.600 --> 00:18:53.840
In a garbage collection environment,
the generational hypothesis is

00:18:54.110 --> 00:18:56.340
that most objects die young.

00:18:56.340 --> 00:19:00.630
So go to extra work to make sure
that allocating and collecting

00:19:00.740 --> 00:19:02.690
local objects is done very fast.

00:19:02.690 --> 00:19:05.290
On Snow Leopard,
we've improved upon that.

00:19:05.360 --> 00:19:08.900
We say most objects die local,
meaning they never get

00:19:08.900 --> 00:19:10.980
attached to the global graph.

00:19:12.800 --> 00:19:17.530
When we introduced garbage collection,
I got a few bug reports right early.

00:19:17.540 --> 00:19:19.520
They go, my program crashes right away.

00:19:19.550 --> 00:19:20.400
And I go, really?

00:19:20.400 --> 00:19:23.630
You know, I mean, okay,
show me your program.

00:19:23.680 --> 00:19:26.700
And so they showed me this
little allocation loop.

00:19:26.780 --> 00:19:29.410
They showed me a program
that only created garbage.

00:19:29.520 --> 00:19:33.740
And so this is a program I actually run,
and I'm going to show

00:19:33.740 --> 00:19:34.610
you some numbers from it.

00:19:34.720 --> 00:19:38.330
But you can run this program
or this little piece of code on

00:19:38.370 --> 00:19:39.830
many different threads at once.

00:19:39.840 --> 00:19:42.300
And all it does is just allocate stuff.

00:19:43.750 --> 00:19:46.990
And, well,
eventually you outrun the collector

00:19:46.990 --> 00:19:50.080
and it crashes the program
because you run out of memory.

00:19:50.100 --> 00:19:54.240
So on Leopard,
you run the program and it turns

00:19:54.240 --> 00:19:58.250
out that the traditional system,
the retain-release

00:19:58.270 --> 00:20:00.390
system that uses malloc,
you know,

00:20:00.600 --> 00:20:02.960
has some performance characteristics.

00:20:02.960 --> 00:20:06.780
And the garbage collection one
actually outruns it for at least a few

00:20:07.040 --> 00:20:09.390
seconds before it runs out of memory.

00:20:09.400 --> 00:20:11.310
And so that's why it's in red.

00:20:11.360 --> 00:20:15.540
So what this graph shows
is that by adding threads,

00:20:15.540 --> 00:20:21.280
this was run on an eight-core machine,
so seven threads are, you know,

00:20:21.280 --> 00:20:24.580
each has a dedicated processor,
essentially, or a dedicated core.

00:20:24.580 --> 00:20:27.330
And, you know,
allocation rates are linear up to the

00:20:27.330 --> 00:20:31.320
point where you run out of cores and
then they kind of dip down a little bit.

00:20:31.360 --> 00:20:40.680
So we're talking a peak of about 500,000
allocations and recoveries per second.

00:20:41.320 --> 00:20:42.220
In the GC case.

00:20:42.220 --> 00:20:46.560
So in Snow Leopard,
one thing they did was they provided

00:20:46.560 --> 00:20:49.080
for malloc an allocation cache.

00:20:49.080 --> 00:20:53.040
And they dramatically improved the
performance for multiple threads.

00:20:53.160 --> 00:20:54.940
Six times the performance.

00:20:54.940 --> 00:20:57.040
That's very nice.

00:20:57.060 --> 00:20:59.960
We asked them to do that, actually.

00:20:59.960 --> 00:21:01.330
Actually, a lot of people did.

00:21:01.350 --> 00:21:04.200
But allocation caches are good.

00:21:04.240 --> 00:21:08.310
And we had put one in for our garbage
collector very early on in Snow Leopard.

00:21:08.420 --> 00:21:10.990
And then we added this other thing,
which is.

00:21:11.400 --> 00:21:12.930
Thread collections as well.

00:21:12.960 --> 00:21:17.580
And so whereas we had to double
the scale on this graph to show you

00:21:17.580 --> 00:21:23.330
how good Snow Leopard malloc is,
we have to, again, adjust the graph.

00:21:23.460 --> 00:21:27.540
This time by a factor of ten
to show you how fast we can

00:21:27.540 --> 00:21:30.200
create and collect garbage.

00:21:34.460 --> 00:21:37.370
Now, why is collecting garbage important?

00:21:37.480 --> 00:21:40.370
Well, I just told you,
half the stuff you create is

00:21:40.370 --> 00:21:42.650
thread local and is garbage.

00:21:42.650 --> 00:21:45.820
And so the faster you can create it,
the faster your program is going to run.

00:21:45.840 --> 00:21:47.920
It's very sweet.

00:21:47.920 --> 00:21:49.180
Let me show you a little bit about that.

00:21:49.620 --> 00:21:51.930
So here's the same diagram before.

00:21:51.940 --> 00:21:55.550
And what we've done is we've
added thread local caches.

00:21:55.550 --> 00:21:59.220
And again, when you allocate one object,
though,

00:21:59.240 --> 00:22:02.240
we actually pull in a few extras as well.

00:22:02.280 --> 00:22:04.430
So we fill the cache using one lock.

00:22:04.560 --> 00:22:06.260
That's one speed saving.

00:22:06.260 --> 00:22:08.890
Again, it takes a couple objects out.

00:22:09.200 --> 00:22:11.500
One's attached and one isn't.

00:22:11.520 --> 00:22:14.520
And other threads are doing
this thing at the same time.

00:22:14.520 --> 00:22:18.050
And again,
they also attach one and get rid of one.

00:22:18.250 --> 00:22:21.390
But in this case,
what we do is every thread

00:22:21.390 --> 00:22:26.230
at the right time says,
hmm, it's kind of like an auto-release

00:22:26.230 --> 00:22:28.150
pool in some respects.

00:22:28.150 --> 00:22:31.350
It says, what things in my local graph?

00:22:31.440 --> 00:22:34.310
We keep track of the local objects.

00:22:34.460 --> 00:22:37.490
Which ones of these are no longer
visible from my current stack?

00:22:37.540 --> 00:22:42.370
And so we just get to examine our current
stack and nothing else on the system.

00:22:42.370 --> 00:22:43.350
It's very fast.

00:22:43.450 --> 00:22:44.680
It's very fast.

00:22:44.680 --> 00:22:47.760
And so what happens is
the objects come and go.

00:22:48.270 --> 00:22:52.450
Back and forth, allocated, garbage back,
garbage in, garbage out.

00:22:52.680 --> 00:22:53.950
And it's just very fast.

00:22:53.950 --> 00:22:56.260
And there's no other thread involved.

00:22:56.350 --> 00:22:58.040
It's a beautiful system.

00:22:58.060 --> 00:23:01.140
Now, of course,
you can still disconnect graphs,

00:23:01.180 --> 00:23:04.150
you know,
lop off chunks from the regular graph.

00:23:04.150 --> 00:23:07.880
And the regular collector's got to,
you know, pick that up.

00:23:08.070 --> 00:23:10.640
But what we've done here, obviously,
is increase the scale.

00:23:10.660 --> 00:23:14.530
The background collector
has half the work to do.

00:23:14.530 --> 00:23:17.900
And so we can really go after
larger and larger applications.

00:23:17.900 --> 00:23:18.500
with this.

00:23:18.510 --> 00:23:20.950
We think it's pretty neat.

00:23:27.200 --> 00:23:32.480
It just fits.

00:23:32.620 --> 00:23:35.340
The next thing we added
in Objective-C 2.1 is

00:23:35.340 --> 00:23:38.080
associative references.

00:23:38.190 --> 00:23:42.240
So the problem is if you
know how to write categories,

00:23:42.240 --> 00:23:44.310
and I'm sure you all do,

00:23:44.400 --> 00:23:46.720
You sometimes need some data.

00:23:46.730 --> 00:23:52.170
And how do you associate that data
with the thing you're extending

00:23:52.410 --> 00:23:55.590
without that thing's cooperation?

00:23:56.000 --> 00:24:00.360
There's no way to do it, really.

00:24:00.360 --> 00:24:02.000
So you try to add something.

00:24:02.000 --> 00:24:05.270
Where do you put this extra data?

00:24:06.530 --> 00:24:14.840
You can't stick it in a global map
table because the target object will

00:24:14.840 --> 00:24:14.840
never go away because the global
map table is going to keep it.

00:24:15.540 --> 00:24:18.370
Under garbage collection,
you might think one of these weak,

00:24:18.480 --> 00:24:22.590
strong map tables will work,
but actually, much to our surprise,

00:24:22.590 --> 00:24:27.180
that'll actually form a
cycle that's uncollectible.

00:24:27.200 --> 00:24:30.780
And so this is just a hard problem,
and people don't do that.

00:24:30.800 --> 00:24:33.900
If you're in a scripting language
and every object is a dictionary,

00:24:33.900 --> 00:24:34.520
it's fine.

00:24:34.650 --> 00:24:35.900
Anybody can add something to it.

00:24:36.000 --> 00:24:38.480
But in a compiled language,
it's very hard to extend an

00:24:38.480 --> 00:24:40.130
object that's already out there.

00:24:40.160 --> 00:24:42.780
But we figured out how to do it.

00:24:43.180 --> 00:24:47.020
And so in Objective-C 2.1,
we have some new runtime calls.

00:24:47.060 --> 00:24:50.630
It's called setAssociation
and getAssociation.

00:24:50.640 --> 00:24:55.420
And what you do is you ask,
associate this extra thing,

00:24:55.420 --> 00:24:59.400
this nifty object, to the object,
in this case, self,

00:24:59.500 --> 00:25:04.020
and hold on to it in sort of
a property-style retain way.

00:25:04.020 --> 00:25:07.800
And so, like the properties,
each way we have a property,

00:25:07.800 --> 00:25:09.660
we have an option for that.

00:25:09.780 --> 00:25:11.340
And you have to have a key.

00:25:11.600 --> 00:25:14.470
Because several things can
want to extend the same object.

00:25:14.480 --> 00:25:16.340
And so you have to have
a key for your use.

00:25:16.340 --> 00:25:22.120
And we stick in a unique void star,
which is the address of some unique

00:25:22.120 --> 00:25:23.950
location that's known only to you.

00:25:23.960 --> 00:25:25.320
So we use that as the key.

00:25:25.320 --> 00:25:28.540
So this is a pretty nifty little system.

00:25:31.370 --> 00:25:34.420
We added another thing.

00:25:34.450 --> 00:25:35.620
Ah, I'm sorry.

00:25:35.790 --> 00:25:41.210
So again, associative references add
data to arbitrary objects.

00:25:41.440 --> 00:25:44.660
came from this study that
actually had leaks in GC that

00:25:44.660 --> 00:25:46.380
we were kind of afraid of.

00:25:46.380 --> 00:25:48.720
It works under both GC and non-GC.

00:25:48.720 --> 00:25:51.910
So this is a new design pattern again.

00:25:51.920 --> 00:25:54.950
You can extend existing
objects with value,

00:25:55.160 --> 00:25:58.120
not only with methods,
but with some data.

00:25:58.120 --> 00:26:01.410
I do have to caution you, though,
it's not trivially cheap.

00:26:01.450 --> 00:26:04.520
It is not just adding another
field in the dictionary.

00:26:04.520 --> 00:26:08.840
There's 15,
20 words of memory and some CPU that

00:26:08.840 --> 00:26:11.120
go in to making that happen.

00:26:11.510 --> 00:26:14.240
Getting the association is
a locked hash table access.

00:26:14.240 --> 00:26:17.350
So the getters and the
setters aren't totally cheap,

00:26:17.350 --> 00:26:19.990
but when you have to do it,
this is the way to do it.

00:26:22.030 --> 00:26:25.190
So the other thing we
added in Objective-C 2.1 is

00:26:25.190 --> 00:26:27.780
this thing we call blocks.

00:26:28.450 --> 00:26:32.480
So your first blocks are very simple.

00:26:32.620 --> 00:26:33.350
A, B, and C.

00:26:33.360 --> 00:26:36.400
We all have them or have had
them and have done that for our

00:26:36.450 --> 00:26:38.200
children if we have children.

00:26:38.230 --> 00:26:40.620
But blocks actually,

00:26:40.990 --> 00:26:41.820
can be different.

00:26:41.900 --> 00:26:44.330
They can actually be
in different languages,

00:26:44.460 --> 00:26:44.900
for example.

00:26:44.900 --> 00:26:47.900
And we think blocks should be
in several different languages.

00:26:47.900 --> 00:26:49.660
So they are.

00:26:49.660 --> 00:26:53.800
And the other thing about blocks is
they can be a little complicated.

00:26:53.800 --> 00:26:54.730
They can be a lot of fun.

00:26:54.780 --> 00:26:59.520
They can hide a lot of
interior stuff behind you.

00:26:59.520 --> 00:27:03.420
And in combination,
they can do phenomenal things for you.

00:27:03.480 --> 00:27:08.130
So let's spend some time and
talk about what blocks are for C,

00:27:08.300 --> 00:27:10.160
Objective-C, and C++.

00:27:11.120 --> 00:27:14.050
So in this case, we have a string.

00:27:14.870 --> 00:27:19.970
Our blocks were inspired by Smalltalk,
because that's where we got

00:27:19.970 --> 00:27:21.940
the name and some of the ideas,
and also Ruby,

00:27:21.940 --> 00:27:23.990
and actually a little bit of Java.

00:27:23.990 --> 00:27:28.060
You'll have to pay attention to figure
out where the Java connection is.

00:27:28.060 --> 00:27:31.270
But in this case, we have a string,
and we have a new

00:27:31.420 --> 00:27:33.550
enumeration method on string.

00:27:34.140 --> 00:27:35.790
It says,

00:27:36.790 --> 00:27:38.700
This is a very simple project.

00:27:38.700 --> 00:27:41.900
It gives me every line that
is in this huge string.

00:27:41.900 --> 00:27:45.390
So here we read a string in from a file,
and then we want to

00:27:45.390 --> 00:27:48.920
enumerate that string,
just handing off every string,

00:27:48.920 --> 00:27:52.370
every line that's in that
file to this block of code.

00:27:52.860 --> 00:27:55.310
And so the block of code
takes some parameters,

00:27:55.350 --> 00:28:01.060
and for every line that
contains the string AKE,

00:28:01.060 --> 00:28:07.890
it'll stick it into the AKEs array,
and that's pretty simple, pretty fast,

00:28:07.910 --> 00:28:09.510
pretty concise.

00:28:10.600 --> 00:28:12.410
So...

00:28:14.300 --> 00:29:40.500
[Transcript missing]

00:29:40.700 --> 00:29:41.540
That's all you have to do.

00:29:41.540 --> 00:29:44.640
One of the options is do it in the
background and it'll do whatever

00:29:44.640 --> 00:29:47.090
you pass in in the background.

00:29:48.770 --> 00:29:52.330
Let's go back to that first example,
the lines iterator.

00:29:52.350 --> 00:29:54.090
And here I've added some mutations.

00:29:54.100 --> 00:29:57.640
So let's say you have a counter
in your function and you want to

00:29:57.670 --> 00:29:59.750
update it from within the block.

00:29:59.760 --> 00:30:04.150
Well, we actually let you do that,
but we ask that you provide

00:30:04.250 --> 00:30:06.060
us a little extra syntax.

00:30:06.200 --> 00:30:11.400
And that syntax is very
much like Smalltalk or Ruby.

00:30:11.400 --> 00:30:23.570
You put your shared variables inside
the or bars to say they're shared.

00:30:23.570 --> 00:30:23.570
They're shared between
the stack and this block.

00:30:24.910 --> 00:30:27.030
That begs the question, well,
what was going on with

00:30:27.230 --> 00:30:28.580
the aches variable before?

00:30:28.580 --> 00:30:32.070
And what happens there,
if you don't say that it's shared,

00:30:32.070 --> 00:30:35.190
then what we do is we actually
make a copy of that variable and

00:30:35.190 --> 00:30:36.980
stick it in the block itself.

00:30:36.980 --> 00:30:38.800
A block is a data structure.

00:30:38.800 --> 00:30:42.390
It starts out on the stack,
and it's got copies of things

00:30:42.480 --> 00:30:44.120
that are not by reference.

00:30:45.070 --> 00:30:48.370
And so when you hand these
things off to other threads,

00:30:48.380 --> 00:30:52.140
as you'll soon see,
they actually get to operate on many

00:30:52.140 --> 00:30:55.940
of the values right there in the
block and not have to go through,

00:30:55.940 --> 00:30:59.550
you know, not have to share them for one,
which is kind of a hard thing to

00:30:59.550 --> 00:31:01.060
do in a multi-threaded environment.

00:31:01.060 --> 00:31:05.400
So they get very much a local copy of it.

00:31:05.480 --> 00:31:08.010
And the deal here is the
local copy is a constant.

00:31:08.070 --> 00:31:09.160
You can't update it.

00:31:09.280 --> 00:31:11.850
If you updated it, you know,
you'd read and write your code,

00:31:11.970 --> 00:31:13.330
and it would look very funny.

00:31:13.380 --> 00:31:15.040
The values would go away.

00:31:15.060 --> 00:31:18.490
out of sync and stuff.

00:31:18.870 --> 00:31:21.850
Where else can we use blocks?

00:31:21.940 --> 00:31:27.200
So here's an example of QSort,
QSort that takes a block comparator.

00:31:27.310 --> 00:31:29.160
And it's very natural.

00:31:29.400 --> 00:31:32.800
In this example,
what we're doing is it's sort of

00:31:33.010 --> 00:31:35.320
like your first name and last name.

00:31:35.320 --> 00:31:37.700
It fixed positions in every string.

00:31:37.700 --> 00:31:41.460
And so you pass in the
beginning and ending positions,

00:31:41.460 --> 00:31:44.240
and it does a two-field sort.

00:31:44.290 --> 00:31:47.400
And so you can actually read the code

00:31:47.580 --> 00:31:54.980
I actually haven't tested it,
but I think it's right.

00:31:54.980 --> 00:31:54.980
And it's pretty clear as to
what's supposed to be going on.

00:31:55.480 --> 00:31:58.080
You don't, I mean,
blocks are a convenient way to do this.

00:31:58.080 --> 00:32:00.910
You don't, if you didn't have blocks,
of course,

00:32:00.910 --> 00:32:03.040
you would use the existing QSortR.

00:32:03.040 --> 00:32:06.380
But QSortR takes one of
these void star parameters,

00:32:06.380 --> 00:32:10.450
and what you would have to do is pass
in some structure that contained all

00:32:10.450 --> 00:32:13.890
the parameterization of the sort,
and all that code in orange is

00:32:13.890 --> 00:32:18.360
actually extra code that sort of
gets in the way of your algorithm.

00:32:18.480 --> 00:32:22.360
And so blocks are very convenient
for expressing your algorithm without

00:32:22.380 --> 00:32:24.530
a lot of this extra boilerplate.

00:32:27.400 --> 00:32:30.540
So in general,
the trouble with this boilerplate

00:32:30.540 --> 00:32:33.740
is anything that takes a function
pointer is kind of limited

00:32:33.760 --> 00:32:38.960
because functions can only refer
to globals and their parameters.

00:32:38.980 --> 00:32:41.580
And sometimes the parameters
can't carry the information.

00:32:41.580 --> 00:32:46.600
And so globals make them thread unsafe,
very much so.

00:32:46.600 --> 00:32:50.460
And the way you make an algorithm
or a global function thread safe

00:32:50.470 --> 00:32:52.480
is you pass a context pointer.

00:32:53.160 --> 00:32:59.550
So you pass a context pointer in and,
well, you can do it.

00:32:59.640 --> 00:33:00.620
We all do it.

00:33:00.700 --> 00:33:02.040
It's all kind of tedious.

00:33:02.040 --> 00:33:08.050
But it really gets hard when
you use it as a callback,

00:33:08.080 --> 00:33:10.460
when you try to use a function
pointer as a callback,

00:33:10.460 --> 00:33:14.180
where both the function pointer
and the data have to be saved.

00:33:14.340 --> 00:33:17.130
Because how do you save
somebody else's data?

00:33:17.140 --> 00:33:20.920
It's like, I mean, there's many different
ways of saving data.

00:33:20.920 --> 00:33:26.300
And so it's... I'm gonna
go through an example here.

00:33:27.220 --> 00:33:29.790
As I said,
callbacks are a popular way to program,

00:33:29.790 --> 00:33:30.350
though.

00:33:30.540 --> 00:33:34.980
So here's a callback
in our existing code.

00:33:34.980 --> 00:33:38.240
You set up some callback
function that does your thing.

00:33:38.260 --> 00:33:43.670
And you pass that callback function into,
in this case, a Net Service browser.

00:33:43.710 --> 00:33:45.660
And that's fine.

00:33:45.690 --> 00:33:46.700
Easy so far.

00:33:46.740 --> 00:33:48.140
Simple, straightforward.

00:33:48.180 --> 00:33:50.870
And then you get to the
wrapped data pointer.

00:33:51.150 --> 00:33:53.710
You don't just get to
hand your void star in.

00:33:53.940 --> 00:33:58.820
You have to put your void star
inside a very specific structure.

00:33:59.050 --> 00:34:04.420
The structure is a
Net Service client context.

00:34:04.420 --> 00:34:06.780
And I think you have to allocate it.

00:34:06.820 --> 00:34:10.860
I know that it's got a retain and a
release function pointer in there.

00:34:10.860 --> 00:34:14.180
And so you have to set up a retain
function and a release function.

00:34:14.290 --> 00:34:18.060
You have to figure out when that
retain function is going to be called.

00:34:18.090 --> 00:34:20.770
I mean, you can do it.

00:34:20.850 --> 00:34:22.240
We have documentation.

00:34:22.260 --> 00:34:23.900
But it just gets in the way.

00:34:23.900 --> 00:34:26.170
It's going to get in the
way of what you want to do,

00:34:26.170 --> 00:34:29.470
which is just write that code.

00:34:32.910 --> 00:34:38.080
You can imagine what would this
look like if we did it with blocks.

00:34:38.080 --> 00:34:41.160
And it would look just like this.

00:34:41.170 --> 00:34:44.700
Your code would be there,
and that would be all you have to write,

00:34:44.700 --> 00:34:46.620
and that's what you want to write.

00:34:46.700 --> 00:34:48.930
So two things about this.

00:34:48.930 --> 00:34:51.950
So far, this is just imaginary.

00:34:51.950 --> 00:34:55.840
We have a lot of places where we
use callbacks in our code today,

00:34:55.840 --> 00:34:59.800
and we haven't wholesale replaced
them with block variants.

00:35:01.300 --> 00:35:04.950
But the second thing you might be asking,
we're talking about callback, right?

00:35:05.060 --> 00:35:11.740
So how the heck can you refer to a
stack local variable in a callback?

00:35:12.440 --> 00:35:14.300
That's an interesting question.

00:35:14.370 --> 00:35:18.800
So before I answer it,
I want to say we wanted to build

00:35:18.800 --> 00:35:24.300
something else brand new in Snow Leopard,
something very sophisticated.

00:35:24.490 --> 00:35:28.500
And it would have had to use callbacks
in order to get off the ground.

00:35:28.700 --> 00:35:30.240
And we didn't like callbacks.

00:35:30.330 --> 00:35:33.000
So that's one of the
reasons we did blocks.

00:35:33.130 --> 00:35:37.000
And so that new thing is, of course,
Grand Central Dispatch.

00:35:37.000 --> 00:35:38.790
So I'm going to spend just a
couple minutes here talking

00:35:38.880 --> 00:35:41.410
about Grand Central Dispatch.

00:35:41.740 --> 00:35:44.930
So as you saw in Bertrand's talk,
he had a much better animation.

00:35:45.070 --> 00:35:47.790
You've got work queues,
and you fill the work

00:35:47.990 --> 00:35:50.690
queues up with blocks.

00:35:50.940 --> 00:35:55.750
And then there's a manager that will
spin up a thread to process that.

00:35:56.010 --> 00:35:57.830
Or maybe it'll spin up two threads.

00:35:57.850 --> 00:36:01.950
Or if you're on a big machine that's
got a lot of threads or a lot of cores,

00:36:02.010 --> 00:36:04.300
it'll spin up a lot of
threads to work on this.

00:36:04.320 --> 00:36:07.440
In this case, it probably wouldn't spin
up more than three threads.

00:36:07.450 --> 00:36:10.590
And so the threads process the data.

00:36:11.670 --> 00:36:16.040
And, you know, when the -- essentially
when the data is done,

00:36:16.040 --> 00:36:18.840
though, the right thing happens.

00:36:18.840 --> 00:36:23.900
The manager notices and the worker
threads go away and it's done.

00:36:24.010 --> 00:36:26.140
And you don't have to spin threads up.

00:36:26.280 --> 00:36:28.360
You don't have to do that
management of what happens

00:36:28.450 --> 00:36:29.790
when the work queue goes down.

00:36:30.110 --> 00:36:35.850
And so it's a very nice facility
for just pushing work off and

00:36:35.850 --> 00:36:35.850
letting something else do it.

00:36:36.740 --> 00:36:39.000
You can find out a lot more
about that later today.

00:36:39.000 --> 00:36:42.030
Not in this room though.

00:36:42.690 --> 00:36:47.780
So the API to add a block of work to

00:36:47.970 --> 00:36:50.550
Grand Center Dispatch is blocks.

00:36:50.840 --> 00:36:53.270
And so this is the API.

00:36:53.620 --> 00:36:56.120
You say dispatch call,
you name the queue,

00:36:56.150 --> 00:36:58.900
you give it a block of work.

00:36:59.620 --> 00:37:04.090
And, of course,
how can some object that's a stack

00:37:04.200 --> 00:37:08.380
local be referenced from something
that's stored over whatever?

00:37:08.380 --> 00:37:14.180
And so, as I said before, that construct,
that up arrow thing,

00:37:14.190 --> 00:37:16.470
is a stack local block.

00:37:16.560 --> 00:37:20.030
It's actually allocated on the stack,
and it references things

00:37:20.030 --> 00:37:21.290
that are on the stack.

00:37:21.360 --> 00:37:27.300
So the way we do that, of course,
is that we introduce a copy API.

00:37:27.850 --> 00:37:30.940
So you copy a block,
and when you copy the block,

00:37:30.970 --> 00:37:31.860
the magic happens.

00:37:31.860 --> 00:37:34.060
So in this case,
let's imagine how we would

00:37:34.060 --> 00:37:35.550
implement lib dispatch.

00:37:35.560 --> 00:37:38.460
First of all, you would have some kind
of a work queue item,

00:37:38.460 --> 00:37:41.150
and the work queue item
would hold a block.

00:37:41.230 --> 00:37:44.680
And so this is the syntax for
declaring a block that takes a void

00:37:44.680 --> 00:37:46.790
as a parameter and returns a void.

00:37:46.800 --> 00:37:50.140
It's kind of like
function pointer syntax.

00:37:50.140 --> 00:37:51.740
It's not the prettiest.

00:37:53.610 --> 00:37:59.610
To do the dispatch call,
what you do is you allocate

00:37:59.640 --> 00:38:03.800
a new work queue item,
and you block copy the block

00:38:03.980 --> 00:38:06.420
coming in and stash it in there.

00:38:06.420 --> 00:38:09.180
And then when the worker
thread needs to do something,

00:38:09.180 --> 00:38:12.550
it finds one of the work queue items,
and it simply calls it.

00:38:12.750 --> 00:38:14.280
Again, much like a function pointer.

00:38:14.280 --> 00:38:16.930
Passing in no arguments
and expecting none back.

00:38:17.070 --> 00:38:18.740
And then it does a block release.

00:38:18.740 --> 00:38:20.910
And so that's how we do it.

00:38:21.050 --> 00:38:23.650
We use a little bit of extra
memory management to keep track

00:38:23.650 --> 00:38:25.790
of blocks and make them happen.

00:38:27.410 --> 00:38:29.450
Well, okay, sort of.

00:38:29.540 --> 00:38:35.300
What really happens is that
there's some sophisticated

00:38:35.330 --> 00:38:36.980
data structures going on below.

00:38:36.980 --> 00:38:40.990
And so on your stack on the left,
when you start out with a block,

00:38:40.990 --> 00:38:44.360
you've got a block data
structure and it has a reference

00:38:44.450 --> 00:38:48.500
to another data structure,
a shared variable in this case.

00:38:48.500 --> 00:38:50.180
And so that's fine.

00:38:50.430 --> 00:38:52.740
And so we use sort of a
double indirection to get

00:38:52.740 --> 00:38:54.330
to that shared variable.

00:38:54.330 --> 00:38:56.380
So it's more expensive, but it works.

00:38:56.860 --> 00:39:01.730
And so when you do a block copy,
we create a new block.

00:39:01.870 --> 00:39:05.380
And what we do is we sort of
move that variable off into

00:39:05.380 --> 00:39:07.140
the heap under the table.

00:39:07.140 --> 00:39:09.460
You don't see that part happening.

00:39:09.520 --> 00:39:11.970
You just see your copy of the block.

00:39:12.020 --> 00:39:15.670
And so it can happen that you have,
since it's a shared variable,

00:39:15.670 --> 00:39:18.880
you can use that same shared
variable in another block.

00:39:18.880 --> 00:39:22.770
And so there can be multiple blocks
referencing your shared variable.

00:39:22.960 --> 00:39:25.500
And if those blocks
get copied to the heap,

00:39:25.650 --> 00:39:26.300
then they all get copied to the heap.

00:39:26.320 --> 00:39:30.660
And they also end up referencing
the correct variable.

00:39:30.740 --> 00:39:34.930
So we do a little bit of funny
business and whatnot such

00:39:34.930 --> 00:39:40.550
that if the stack goes away,
the heap preserves that shared variable.

00:39:40.840 --> 00:39:45.150
And it also works, though,
if somehow your heap copies

00:39:45.150 --> 00:39:49.490
of the blocks go away first,
we keep enough magic around

00:39:49.500 --> 00:39:54.840
that the stack still has a valid
reference to the thing in the heap.

00:39:55.780 --> 00:39:58.470
So it's just magic.

00:40:00.290 --> 00:40:02.100
Let's talk a little bit about the syntax.

00:40:02.100 --> 00:40:09.640
So sort of the abstract
syntax thingy for it is this.

00:40:09.640 --> 00:40:10.840
It's kind of like a function pointer.

00:40:10.840 --> 00:40:14.790
It's got a return type and
it's got some argument types.

00:40:15.490 --> 00:40:19.900
We kind of use the abstract part when
you declare methods in Objective-C.

00:40:19.900 --> 00:40:23.330
And so this is what it looks
like when you declare a method.

00:40:25.420 --> 00:40:29.060
When you actually declare a variable,
it's more function pointer style.

00:40:29.060 --> 00:40:30.550
And again,
this is very much like function

00:40:30.640 --> 00:40:32.720
pointers in Objective-C already.

00:40:32.820 --> 00:40:35.920
So it takes just a little
bit of getting used to.

00:40:35.950 --> 00:40:36.680
Maybe a lot.

00:40:38.500 --> 00:40:44.600
[Transcript missing]

00:40:44.960 --> 00:40:46.040
Funny things look funny.

00:40:46.070 --> 00:40:46.800
They look very funny.

00:40:46.800 --> 00:40:51.700
So this is how you declare
an array of blocks.

00:40:51.740 --> 00:40:56.730
And if you want to have a lot of fun,
here's a function that takes

00:40:56.730 --> 00:40:58.970
an int that returns a block.

00:40:59.370 --> 00:41:01.340
Now,
you could do this with function pointers.

00:41:01.340 --> 00:41:04.040
And if you like doing this stuff,
you could play around

00:41:04.040 --> 00:41:04.800
with function pointers.

00:41:04.800 --> 00:41:07.860
Or if you've got the seed installed,
you could do this here.

00:41:08.010 --> 00:41:10.580
You could have a pointer to
a function that takes an int.

00:41:10.610 --> 00:41:13.670
I'm sorry, that was a function that took
an int that returned a block.

00:41:13.730 --> 00:41:16.920
And this is the pointer to a function
that takes an int returning a block.

00:41:16.920 --> 00:41:22.370
And finally, here's a block that takes
an int that returns a block.

00:41:22.430 --> 00:41:23.740
And so it gets ugly.

00:41:23.740 --> 00:41:25.560
And I have some ideas
on how to improve this.

00:41:25.560 --> 00:41:28.930
But this is what it is in the seed today.

00:41:29.240 --> 00:41:32.080
Let's talk about that syntax.

00:41:32.120 --> 00:41:35.080
When we wrote the block expressions,

00:41:35.520 --> 00:41:37.910
We actually didn't have to
talk about the return type.

00:41:38.020 --> 00:41:41.130
We infer the return type for
the block expression from the

00:41:41.130 --> 00:41:42.870
return statement if there is one.

00:41:42.940 --> 00:41:46.790
So if there's a return type,
then we know what the type is.

00:41:46.790 --> 00:41:50.790
If there's no return statement,
then the return type is void.

00:41:50.790 --> 00:41:53.510
So that's a little bit of shorthand.

00:41:53.520 --> 00:41:56.610
If you write a block that
takes no arguments at all,

00:41:56.610 --> 00:42:00.550
void, you can say void if you want,
or you can just say nothing.

00:42:00.650 --> 00:42:03.500
So it makes writing short
little things short.

00:42:03.570 --> 00:42:04.610
We like that.

00:42:05.500 --> 00:42:08.020
And if you have more
than one shared variable,

00:42:08.020 --> 00:42:09.720
separate them with commas.

00:42:13.490 --> 00:42:16.180
So let's talk about which
variables get done which way.

00:42:16.410 --> 00:42:20.530
And so local variables,
stack local variables,

00:42:20.540 --> 00:42:24.500
as well as static local variables,
are imported as const.

00:42:24.500 --> 00:42:28.180
And if you try to update them,
the compiler will get mad at you.

00:42:29.190 --> 00:42:33.770
Globals, static file globals, globals,
extern globals.

00:42:34.100 --> 00:42:35.100
Globals are globals.

00:42:35.250 --> 00:42:36.220
Just use them.

00:42:36.230 --> 00:42:38.790
We don't do anything magic with globals.

00:42:38.820 --> 00:42:42.410
Only the local variables do
we do something funny with.

00:42:43.790 --> 00:42:47.700
Mmm, I forgot something.

00:42:47.880 --> 00:42:49.940
Blocks are objects.

00:42:50.130 --> 00:42:53.040
What I talked about was all
C stuff for the most part.

00:42:53.210 --> 00:42:58.540
In Objective-C,
a block is actually an object as well.

00:42:59.600 --> 00:43:05.190
So they can be sent
messages like ID variables,

00:43:08.030 --> 00:43:11.140
They respond to only a few messages.

00:43:11.210 --> 00:43:14.010
Retain, release, auto-release,
and copy are the principal

00:43:14.010 --> 00:43:15.400
messages you send to them.

00:43:15.480 --> 00:43:22.810
But this allows you to very
conveniently express the idea

00:43:22.810 --> 00:43:27.800
of create a block on the fly,
hand it out in the normal

00:43:27.800 --> 00:43:27.800
auto-release fashion that you
do when you create something.

00:43:28.810 --> 00:43:31.370
Under garbage collection,
you don't have to worry

00:43:31.370 --> 00:43:32.930
about the release thing.

00:43:33.050 --> 00:43:37.450
But under non-GC, you create a block,
something has to release it

00:43:37.450 --> 00:43:39.310
to get rid of the memory.

00:43:40.310 --> 00:43:43.960
At the moment, any objects that are
inside that block literal,

00:43:43.960 --> 00:43:46.360
when they're copied, are retained.

00:43:46.370 --> 00:43:48.880
And so you can create cycles that way.

00:43:48.880 --> 00:43:51.180
We're working on a way
such that you can say,

00:43:51.180 --> 00:43:53.060
don't retain this one, please.

00:43:55.610 --> 00:43:58.710
I showed you block copy,
capital block copy,

00:43:58.810 --> 00:44:01.360
and capital block release earlier.

00:44:01.370 --> 00:44:04.000
Always use those in pairs.

00:44:04.040 --> 00:44:08.700
Don't mix and match the block
copy stuff with the methods,

00:44:08.860 --> 00:44:11.320
copy and release and whatnot.

00:44:11.390 --> 00:44:18.380
They share some plumbing underneath,
but don't intermix them.

00:44:19.390 --> 00:44:22.100
So you can use blocks like objects.

00:44:22.350 --> 00:44:25.120
They can be properties.

00:44:26.420 --> 00:44:29.040
It just works.

00:44:29.100 --> 00:44:31.700
You can use them.

00:44:31.820 --> 00:44:33.980
Somebody put blocks into an array.

00:44:34.210 --> 00:44:36.110
They made a copy, so it's a real object.

00:44:36.180 --> 00:44:46.550
They stick it in the array,
and then they can walk through the array

00:44:46.790 --> 00:44:47.770
and call every block that's in the array.

00:44:47.770 --> 00:44:47.770
OK, it works.

00:44:48.670 --> 00:44:54.390
But remember that block literals are
the first case and probably the only

00:44:54.530 --> 00:45:00.880
case we're gonna do where it's an actual
Objective-C object created on the stack.

00:45:01.130 --> 00:45:04.750
So you can't return them off the stack.

00:45:04.960 --> 00:45:08.940
You C++ programmers know all this,
but the Objective-C programmers in here

00:45:08.940 --> 00:45:11.100
are going to have to remember this.

00:45:11.200 --> 00:45:15.450
Happily, the compiler is going
to warn you about that.

00:45:15.680 --> 00:45:19.700
And so if you assign one of these into
a variable and return the variable,

00:45:19.700 --> 00:45:22.960
it's still returning
a stack-based object.

00:45:22.960 --> 00:45:25.180
And so you probably just
won't get a compiler warning,

00:45:25.180 --> 00:45:26.710
but it will still crash for you.

00:45:29.040 --> 00:45:32.280
It turns out that the
stack-based objects actually do

00:45:32.280 --> 00:45:34.600
respond to retain and release.

00:45:34.610 --> 00:45:37.880
They don't do anything,
but they respond to the messages.

00:45:37.880 --> 00:45:43.240
So you can actually stick a stack-based
object into an array and take it out

00:45:43.240 --> 00:45:47.080
before the block goes out of scope.

00:45:47.150 --> 00:45:50.590
So it's allowed, but it's dangerous.

00:45:52.220 --> 00:45:56.520
When you're inside a method,
an instance variable is

00:45:56.520 --> 00:45:58.400
still directly accessible.

00:45:58.400 --> 00:46:03.060
We import the self instead
of the instance variable.

00:46:03.060 --> 00:46:05.420
So you don't get a const copy
of the instance variable.

00:46:05.420 --> 00:46:08.780
You get a const bit copy of self.

00:46:08.810 --> 00:46:12.920
So you can update and access instance
variables within blocks directly.

00:46:23.010 --> 00:46:25.440
Blocks are fairly new.

00:46:25.550 --> 00:46:26.090
There will be bugs.

00:46:26.300 --> 00:46:28.330
There won't be blood,
but there will be bugs.

00:46:28.330 --> 00:46:31.750
So we haven't gotten our C++ support yet.

00:46:31.780 --> 00:46:34.780
We will.

00:46:34.780 --> 00:46:40.810
The syntax is still a work in progress.

00:46:42.920 --> 00:46:48.120
Blocks that have shared variables
in your seed cannot be copied.

00:46:48.130 --> 00:46:51.470
You'll get a big warning.

00:46:51.810 --> 00:46:56.410
Unless you're running garbage
collection and you add this funny

00:46:56.550 --> 00:46:58.510
marker where you declare the variable.

00:46:58.540 --> 00:47:02.600
So here,
if you want to play around with the full,

00:47:02.600 --> 00:47:08.360
you know, thin edge, you know, thin ice,
if you want to play on thin ice,

00:47:08.360 --> 00:47:13.090
you play around with making
copyable shared variables this way.

00:47:13.270 --> 00:47:16.810
So in this case,
the poly variable is going to be shared.

00:47:16.820 --> 00:47:20.920
You have to both mark it with the
OR bars and use this funny biref thing.

00:47:21.650 --> 00:47:22.570
But it works.

00:47:22.570 --> 00:47:23.380
It's fun.

00:47:23.380 --> 00:47:27.570
We almost have support for non-GCN,
but it didn't quite make

00:47:27.580 --> 00:47:28.780
the seed in the compiler.

00:47:30.270 --> 00:47:32.080
Hmm.

00:47:32.130 --> 00:47:32.760
Let's talk about tools.

00:47:32.760 --> 00:47:38.070
There is already support,
refactoring style support,

00:47:38.150 --> 00:47:44.290
for converting old style iterations
and whatnot into new style.

00:47:44.300 --> 00:47:45.500
I won't go through these.

00:47:45.500 --> 00:47:46.840
It's, I don't know.

00:47:46.840 --> 00:47:48.030
You can try it out.

00:47:48.110 --> 00:47:49.420
Try it out in Xcode.

00:47:49.420 --> 00:47:53.010
There's a convert to blocks thing,
and it will analyze your code

00:47:53.010 --> 00:47:56.800
and make some suggested changes,
just like refactoring does.

00:47:56.800 --> 00:47:59.740
So, well, it's kind of interesting.

00:48:01.200 --> 00:48:06.800
When you get into the debugger,
what you'll find is that it mostly works.

00:48:06.820 --> 00:48:08.660
You can single step into blocks.

00:48:08.830 --> 00:48:12.600
They are, after all,
just function pointers, it turns out.

00:48:12.620 --> 00:48:15.140
There are real functions
underneath with magic arguments.

00:48:15.950 --> 00:48:20.170
And so stepping into them sort of works,
except that the

00:48:20.500 --> 00:48:34.700
[Transcript missing]

00:48:35.410 --> 00:48:39.440
By default, imported is just pointers
to their stack counterparts.

00:48:39.440 --> 00:48:42.240
And so you have to go star
whatever to see their values,

00:48:42.240 --> 00:48:44.580
unless you use that BiRef thing.

00:48:44.580 --> 00:48:48.040
And if you use the BiRef thing,
you're just gonna see the raw

00:48:48.040 --> 00:48:49.710
implementation of how we do it.

00:48:49.860 --> 00:48:52.410
So that's where we're
at with the debugger.

00:48:52.420 --> 00:48:54.110
It's possible.

00:48:55.280 --> 00:49:01.590
So for the talk,
Objective-C 2.0 has some great features.

00:49:02.430 --> 00:49:05.800
Garbage collection, for end properties.

00:49:05.800 --> 00:49:08.190
2.1 adds some more.

00:49:08.280 --> 00:49:12.300
Associative references,
this fast allocation stuff.

00:49:12.310 --> 00:49:14.460
We've added blocks to
three different languages.

00:49:14.460 --> 00:49:17.710
Well, eventually, C++ as well.

00:49:17.800 --> 00:49:21.850
provides dramatically better iteration,
much better callbacks,

00:49:21.930 --> 00:49:29.300
and it lets the app kit expose things
that you can use directly from C++.

00:49:29.470 --> 00:49:35.740
So we haven't quite gotten
to redoing delegate methods,

00:49:35.740 --> 00:49:38.500
but it might be possible that
for every delegate method

00:49:38.500 --> 00:49:43.120
that you could imagine today,
we might invent a block call-in such

00:49:43.120 --> 00:49:47.660
that you could set a delegate call-out
from any language you want without

00:49:47.660 --> 00:49:51.760
having to have some intermediate
object that calls into your C++

00:49:51.760 --> 00:49:53.300
engine or something like that.

00:49:53.380 --> 00:49:58.240
So we really like the idea that you
can take Objective-C code and stuff

00:49:58.290 --> 00:50:03.020
it into that low-level Q sort stuff
or these other APIs or from C++,

00:50:03.020 --> 00:50:05.420
and it builds a sort
of multi-language glue.

00:50:09.740 --> 00:50:15.290
Before we close, though,
I wanted to show you something for fun.

00:50:15.370 --> 00:50:19.700
So how many times when
you've written code,

00:50:19.730 --> 00:50:24.880
you sort of need to do something
when some other object goes away?

00:50:25.010 --> 00:50:28.360
So imagine being able to
attach one of these new things,

00:50:28.390 --> 00:50:33.120
this block, attach it to an object such
that when the object dies,

00:50:33.180 --> 00:50:36.000
your code gets executed.

00:50:36.020 --> 00:50:39.070
Well, here's the implementation.

00:50:39.770 --> 00:50:40.950
Let's go through the implementation.

00:50:41.070 --> 00:50:44.420
First of all, we need a helper object,
a death watcher.

00:50:44.480 --> 00:50:47.640
Whenever you need to attach a block,
we're going to create a whole new object

00:50:47.930 --> 00:50:50.380
that's going to remember the block.

00:50:50.380 --> 00:50:51.900
So that's what we do.

00:50:52.040 --> 00:50:54.530
So we create an object.

00:50:54.780 --> 00:50:59.350
And its only purpose is to have
a finalized method that calls

00:50:59.350 --> 00:51:01.910
that block that got remembered.

00:51:02.080 --> 00:51:07.200
So the implementation is
create a helper object,

00:51:07.200 --> 00:51:07.850
death,

00:51:08.040 --> 00:51:12.390
Assign the death block to be
the thing that you passed in.

00:51:12.540 --> 00:51:15.910
Notice, I forgot to mention,
the at property copy.

00:51:15.940 --> 00:51:20.720
Blocks are objects,
and so the at property copy says copy

00:51:20.820 --> 00:51:24.140
the thing on assignment on the setter.

00:51:24.140 --> 00:51:29.340
So the death.death block actually
performs a copy of the block coming in,

00:51:29.360 --> 00:51:34.600
which makes it safe to refer to anything
that you want to use inside your block.

00:51:34.750 --> 00:51:41.860
And then you do that set association
thing to say when this object dies,

00:51:41.860 --> 00:51:45.880
when self dies,

00:51:46.420 --> 00:51:49.620
Detach the death object.

00:51:49.720 --> 00:51:52.610
It's no longer interesting
to have that association.

00:51:52.760 --> 00:51:55.010
And so that death object
will get detached.

00:51:55.100 --> 00:51:58.760
And since this is its only reference,
it too will go away.

00:51:58.760 --> 00:52:02.060
The garbage collector will
notice that right away.

00:52:02.060 --> 00:52:08.640
This actually almost works,
or this will work under non-GC as well.

00:52:08.650 --> 00:52:12.920
We have a bug in the seed such
that it doesn't work in the seed,

00:52:12.920 --> 00:52:12.920
but it does work.

00:52:13.610 --> 00:52:14.400
Back at the office.

00:52:14.400 --> 00:52:20.570
So you make that association,
and so that's how you

00:52:20.720 --> 00:52:24.280
can have a block of code,
any block of code,

00:52:24.310 --> 00:52:29.110
multiple blocks of code executed
whenever some other object that

00:52:29.150 --> 00:52:32.100
doesn't know you from anything dies.

00:52:32.100 --> 00:52:35.850
And so this, you know, this open,
blocks open up some sort of

00:52:36.080 --> 00:52:40.460
metaprogramming opportunities here
that we're still thinking about.

00:52:40.460 --> 00:52:43.140
If this became a pattern
that was very popular,

00:52:43.340 --> 00:52:46.340
we of course would implement
it in much less memory,

00:52:46.340 --> 00:52:50.630
much less space, much less faster,
you know, a lot of, much better.

00:52:50.640 --> 00:52:54.820
But, you know, this wraps together three
ideas from this talk,

00:52:54.940 --> 00:52:59.310
the properties, blocks,
and the set association in one slide.

00:52:59.320 --> 00:53:01.970
And so I could have spent
the whole talk on that.

00:53:02.100 --> 00:53:05.850
just discussing this slide, but, well.

00:53:06.060 --> 00:53:08.530
So for more information,
you should talk to

00:53:08.530 --> 00:53:11.790
Michaelopoulos Jurowicz,
the developer.

00:53:11.890 --> 00:53:15.120
He's not really Michaelopoulos,
but he calls me Blaine Garst,

00:53:15.160 --> 00:53:18.030
so I call him Michaelopoulos.

00:53:18.340 --> 00:53:20.280
We have some documentation.

00:53:20.280 --> 00:53:24.560
This is the documentation for
the Objective-C 2.0 features.

00:53:24.580 --> 00:53:27.490
There is some preliminary
documentation on blocks and the seed,

00:53:27.520 --> 00:53:32.600
but you'll have to go search for it.

00:53:32.600 --> 00:53:35.080
I couldn't find the URL for it.

00:53:35.890 --> 00:53:38.560
There are a lot of sessions that
are going to talk about Blocks API.

00:53:38.560 --> 00:53:43.920
If you can go backwards in time,
you would want to see yesterday's

00:53:43.920 --> 00:53:47.080
talk about Objective-C.

00:53:47.150 --> 00:53:51.030
What's New in Cocoa follows
this talk in this room.

00:53:51.790 --> 00:53:54.090
Later this afternoon is
Grand Central Dispatch,

00:53:54.090 --> 00:53:55.080
as I said before.

00:53:55.080 --> 00:53:57.640
Tomorrow,
we're going to talk more about how

00:53:57.640 --> 00:54:01.870
you write garbage-collected programs,
the do's and the don'ts of writing

00:54:01.870 --> 00:54:05.960
garbage-collected programs from
the programmer's viewpoint.

00:54:06.580 --> 00:54:09.820
On Friday,
we'll talk about low-level runtime stuff.

00:54:09.870 --> 00:54:15.440
How do you get into the real
nitty-gritty guts of what's going on,

00:54:15.760 --> 00:54:20.220
including a discussion on, say,
our unified exception model

00:54:20.220 --> 00:54:22.720
between C++ and Objective-C.

00:54:22.720 --> 00:54:26.520
So, there's a lot more stuff
coming up in the show.

00:54:26.520 --> 00:54:27.560
We have labs.

00:54:27.560 --> 00:54:30.750
There's a garbage
collection lab on Thursday,

00:54:30.790 --> 00:54:31.680
tomorrow.

00:54:31.680 --> 00:54:35.180
If you come down to the
labs right after this talk,

00:54:35.450 --> 00:54:36.560
the team will be down.

00:54:36.560 --> 00:54:40.140
We'll be down there to answer
questions about this or any other

00:54:40.210 --> 00:54:43.150
Objective-C 2.0 or 2.1 feature.

00:54:44.040 --> 00:54:46.780
So, before Q&A,
I'll just answer some stuff

00:54:46.780 --> 00:54:49.180
that's going to get asked anyway.

00:54:49.180 --> 00:54:52.320
So, blocks are available in GCC 4.2.

00:54:52.320 --> 00:54:53.940
That's not available for the phone.

00:54:53.940 --> 00:54:58.030
We're putting support into this
new compiler called LLVM Clang,

00:54:58.030 --> 00:55:00.180
the new front end to the new back end.

00:55:00.180 --> 00:55:04.620
And we'll get C++ done
after we go back to work.

00:55:05.960 --> 00:55:07.980
Will blocks be proposed as a standard?

00:55:07.980 --> 00:55:10.100
We're certainly going to talk to people.

00:55:10.100 --> 00:55:15.510
We would like to see blocks
used at this low-level level.

00:55:16.070 --> 00:55:20.700
We're using Unix APIs because we think
they make a lot of things possible.

00:55:20.700 --> 00:55:24.120
And so we chose the syntax we did.

00:55:24.570 --> 00:55:27.510
Ugly as it is,
but it's possible for it to be

00:55:27.510 --> 00:55:29.700
a standard with ugly syntax.

00:55:29.860 --> 00:55:32.190
We had some other nicer ideas,
but we really think

00:55:32.190 --> 00:55:33.520
that this might happen.

00:55:33.520 --> 00:55:34.070
We don't know.

00:55:36.100 --> 00:55:40.940
So C++ OX has something
they call closures.

00:55:40.950 --> 00:55:45.820
And what I just showed you, blocks,
blocks are closures.

00:55:45.820 --> 00:55:47.880
They're full closures.

00:55:47.930 --> 00:55:53.250
The C++ standard thing called
closures aren't quite closures.

00:55:53.310 --> 00:55:55.240
They only work as iterators.

00:55:55.240 --> 00:55:56.840
You can't copy them.

00:55:56.840 --> 00:55:59.780
And they only work, as I understand it,
within an STL context.

00:55:59.790 --> 00:56:02.620
So they're sort of closures.

00:56:03.160 --> 00:56:08.640
They're sort of like the first
implementation of blocks in Smalltalk,

00:56:08.640 --> 00:56:09.880
but they're not as powerful as ours.
WEBVTT

00:00:20.920 --> 00:00:21.300
Good morning.

00:00:21.300 --> 00:00:22.340
My name is Andy Carol.

00:00:22.340 --> 00:00:26.440
I'm an engineer here at Apple,
and this session is Spotlight:

00:00:26.530 --> 00:00:28.640
Search and Be Searched.

00:00:28.750 --> 00:00:31.430
What does it mean to
search and be searched?

00:00:31.520 --> 00:00:36.440
A lot of your applications already
search or could benefit from search.

00:00:36.570 --> 00:00:40.600
Installers want to know where are
previous versions of applications.

00:00:40.770 --> 00:00:43.800
Productivity apps want
to know where fonts,

00:00:43.910 --> 00:00:45.340
sounds, and other files.

00:00:45.670 --> 00:00:48.360
A lot of programs can benefit from this.

00:00:48.380 --> 00:00:49.640
And be searched.

00:00:49.710 --> 00:00:52.320
Your customers want to be
able to find your data.

00:00:52.550 --> 00:00:54.760
How can you help them find your data?

00:00:54.800 --> 00:00:56.110
Let Spotlight do that.

00:00:56.210 --> 00:00:59.060
Let Spotlight help your
customers find your data,

00:00:59.220 --> 00:01:04.000
and let Spotlight help your programs
find the data that they're looking for.

00:01:04.050 --> 00:01:05.610
But what is Spotlight?

00:01:05.740 --> 00:01:07.080
It's a lot of things.

00:01:07.230 --> 00:01:11.300
Spotlight is a top-to-bottom search
facility built into the system.

00:01:11.340 --> 00:01:15.560
It's part of the user experience in the
most common areas that the user works.

00:01:15.600 --> 00:01:17.160
It's also expandable.

00:01:17.370 --> 00:01:21.240
It's designed to bring your data
into that search capability,

00:01:21.490 --> 00:01:25.360
and it provides mechanisms for
your programs to be able to find

00:01:25.360 --> 00:01:27.350
the data that they're looking for.

00:01:27.400 --> 00:01:30.750
Let's take a look at that
in a little bit more detail.

00:01:31.680 --> 00:01:34.280
At its core,
Spotlight is basically a server

00:01:34.670 --> 00:01:36.490
with a database attached to it.

00:01:36.870 --> 00:01:40.040
And it has a database that
contains a lot of information.

00:01:40.120 --> 00:01:43.410
The most important information
is the metadata storage.

00:01:43.550 --> 00:01:45.560
Let's talk about that a little bit.

00:01:45.630 --> 00:01:47.400
What is metadata?

00:01:47.580 --> 00:01:52.910
Metadata is information
about information.

00:01:53.150 --> 00:01:55.340
Let's take a look at a good example.

00:01:55.420 --> 00:01:59.380
The Finder info window is probably
the most common user visible

00:01:59.380 --> 00:02:02.250
source of metadata in the system.

00:02:02.460 --> 00:02:04.400
Let's take a look at a
little bit more detail.

00:02:04.570 --> 00:02:07.680
From this,
we can see the size of the photograph.

00:02:07.870 --> 00:02:11.930
We can see that the photograph
was taken with a Panasonic camera.

00:02:12.050 --> 00:02:15.600
And the exposure time
is 1/125 of a second.

00:02:15.720 --> 00:02:18.190
Now,
this information isn't the photograph,

00:02:18.330 --> 00:02:20.800
but it's information
about the photograph.

00:02:20.930 --> 00:02:24.260
And it's the kind of information
that your users would want to

00:02:24.260 --> 00:02:26.940
use to find that photograph.

00:02:27.020 --> 00:02:29.800
Let's take a look at how that's
implemented in the system.

00:02:29.810 --> 00:02:30.580
It's very simple.

00:02:30.760 --> 00:02:32.300
It's key value pairs.

00:02:32.370 --> 00:02:35.050
We have an attribute and we have a value.

00:02:35.180 --> 00:02:37.620
For example, the...

00:02:37.700 --> 00:02:42.200
Pixel size, the file name, et cetera,
are all attributes,

00:02:42.200 --> 00:02:47.140
and they typically are named KMDItem
followed by whatever value is appropriate

00:02:47.140 --> 00:02:49.700
for the information being described.

00:02:49.740 --> 00:02:51.920
You can store not only
information like this,

00:02:51.920 --> 00:02:53.600
but you can internationalize it.

00:02:54.320 --> 00:02:57.640
Information can be provided
rather than as a flat value.

00:02:57.700 --> 00:02:59.700
It can be provided as a dictionary.

00:02:59.930 --> 00:03:04.170
And that dictionary can be keyed by
the localization code so that users

00:03:04.170 --> 00:03:09.690
around the world can see the appropriate
information for that metadata.

00:03:10.420 --> 00:03:12.300
But Spotlight is more than metadata.

00:03:12.340 --> 00:03:14.090
It's also content.

00:03:14.210 --> 00:03:16.690
Content from your files.

00:03:16.800 --> 00:03:22.740
The KMDItmTextContent field represents
all of the user searchable text that

00:03:22.790 --> 00:03:25.400
would be found in a particular file.

00:03:25.530 --> 00:03:27.390
Now for a text file,
this is pretty obvious.

00:03:27.390 --> 00:03:29.660
You provide the content of the text file.

00:03:29.660 --> 00:03:34.250
Spotlight will let people search for
words and phrases in that content.

00:03:34.480 --> 00:03:36.170
But it can be more than that.

00:03:36.200 --> 00:03:40.730
A lot of files don't really have
text content in the traditional sense

00:03:40.760 --> 00:03:44.680
but they have a lot of value that
can be construed as text content,

00:03:44.960 --> 00:03:45.840
song lyrics.

00:03:45.840 --> 00:03:51.750
Or for example, a CAD program might have
descriptions for each room and the

00:03:51.750 --> 00:03:56.690
descriptions could be concatenated
and searched from the content index.

00:03:56.800 --> 00:03:59.860
It's important to note that
this information is writable,

00:03:59.970 --> 00:04:02.420
that is it can be
imported into the system,

00:04:02.560 --> 00:04:05.320
and you can perform queries against it.

00:04:05.320 --> 00:04:10.050
But it's not generally easy to fetch
back the text content of a file.

00:04:10.110 --> 00:04:12.180
It's used only for searching.

00:04:15.350 --> 00:04:19.680
Spotlight also has a built-in
UI that a lot of users interact with.

00:04:19.750 --> 00:04:28.670
This is the Spotlight menu, the Finder,
and File/Save/Load dialogs.

00:04:30.220 --> 00:04:32.130
It's also extendable.

00:04:32.250 --> 00:04:36.740
We do this with another part of the
architecture called the importers.

00:04:36.870 --> 00:04:38.870
And the importer has plugins.

00:04:39.010 --> 00:04:42.200
There are plugins to bring in
each common file type already

00:04:42.200 --> 00:04:44.690
provided with the system.

00:04:44.980 --> 00:04:45.840
We have a list here.

00:04:45.840 --> 00:04:51.300
It's pretty comprehensive: images,
sounds, video, file formats for text,

00:04:51.300 --> 00:04:51.900
etc.

00:04:52.150 --> 00:04:55.360
But the one thing that's
missing is your data.

00:04:55.500 --> 00:04:57.330
And we're going to talk
today about how to get your

00:04:57.680 --> 00:05:00.640
application's data into Spotlight.

00:05:00.700 --> 00:05:05.380
We do that by your providing a
plug-in for your users that will

00:05:05.400 --> 00:05:11.490
know how to index your data files
so that your customers can find data

00:05:11.490 --> 00:05:11.970
that's created with your program.

00:05:12.400 --> 00:06:22.900
[Transcript missing]

00:06:23.980 --> 00:06:25.690
Now let's take a look at the info.p list.

00:06:25.850 --> 00:06:28.940
This is sort of the core file
in your project that describes

00:06:28.940 --> 00:06:32.580
the capabilities of what you're
building to the rest of the system.

00:06:32.640 --> 00:06:35.430
And there's one important field
that we're going to want to edit.

00:06:35.600 --> 00:06:38.270
It's the supported UTI type.

00:06:38.440 --> 00:06:42.620
We need to define a UTI type for
the kind of data that your importer,

00:06:42.620 --> 00:06:45.620
plug-in, is going to process.

00:06:45.750 --> 00:06:47.120
What is a UTI type?

00:06:47.500 --> 00:06:49.900
It's a uniform type identifier.

00:06:50.040 --> 00:06:54.480
This lets the system know in a
universal way what kind of file you

00:06:54.550 --> 00:06:56.720
have and what its capabilities are.

00:06:56.940 --> 00:06:58.800
There's a naming convention for this.

00:06:58.890 --> 00:07:01.520
It's basically your
domain name backwards.

00:07:01.690 --> 00:07:05.760
This is done to prevent collisions
with other companies' data types and to

00:07:05.760 --> 00:07:07.880
make it so that there's no bureaucracy.

00:07:07.960 --> 00:07:11.440
You can choose a UTI type that's
appropriate for your file without

00:07:11.440 --> 00:07:13.100
clearing it with anyone else.

00:07:13.390 --> 00:07:14.940
There's one exception.

00:07:15.000 --> 00:07:19.370
UTIs that start with the word "public"
are meant for the simple built-in

00:07:19.380 --> 00:07:23.820
data types that are universal and
not owned by any one application.

00:07:23.870 --> 00:07:25.760
And public is reserved for Apple.

00:07:25.830 --> 00:07:30.550
Apple's the only source for
UTI types that start with public.

00:07:30.890 --> 00:07:34.840
But anything with your domain
name is yours to work with.

00:07:34.930 --> 00:07:36.980
Now how do we declare these?

00:07:37.210 --> 00:07:40.580
Really, it's your application
that owns the UTI type.

00:07:40.680 --> 00:07:44.260
So it's important that your application
declare the types of files that

00:07:44.260 --> 00:07:44.260
it--that it's going to be using.

00:07:44.260 --> 00:07:48.260
It's important that your
application export your UTI type.

00:07:48.260 --> 00:07:51.650
That makes it the authority
for the rest of the system on

00:07:51.650 --> 00:07:57.300
the behavior for that UTI type.

00:07:57.380 --> 00:08:00.000
What application is launched
when you double-click on it?

00:08:00.080 --> 00:08:01.520
What icon does it have?

00:08:01.540 --> 00:08:06.540
This is all very important information,
and your app is the final authority.

00:08:06.540 --> 00:08:11.100
But what about when you have an importer
plug-in for Spotlight and you're not

00:08:11.100 --> 00:08:13.580
sure if your app is going to be there?

00:08:13.580 --> 00:08:17.720
Your plug-in can also declare
the UTI type for the system,

00:08:17.840 --> 00:08:21.580
but instead of exporting it,
your app will import it.

00:08:21.580 --> 00:08:23.550
And that's just as good to the system.

00:08:23.620 --> 00:08:25.450
The system will know
everything about the UTI type,

00:08:25.590 --> 00:08:29.580
but the system also knows that
this is a fallback declaration,

00:08:29.580 --> 00:08:33.580
and that if your app is present,
the application will take precedence.

00:08:33.580 --> 00:08:38.870
So it's a good idea to import one
for your plug-in as a fallback.

00:08:39.550 --> 00:08:43.690
So now we go and we'll enter
in the UTI type made up one

00:08:43.700 --> 00:08:46.090
for this particular plugin.

00:08:46.360 --> 00:08:49.220
Now we have to talk about the schema.

00:08:49.270 --> 00:08:53.600
A schema is metadata about metadata.

00:08:54.120 --> 00:08:58.390
It describes the metadata
attributes that your plugin

00:08:58.390 --> 00:09:01.060
will be providing to the system.

00:09:01.100 --> 00:09:05.520
Now, the system provides quite a
few predefined attributes,

00:09:05.520 --> 00:09:09.260
and you can define that your
plugin will provide them.

00:09:09.310 --> 00:09:14.090
In this case, we're providing a title,
a comment, and other fields.

00:09:14.400 --> 00:09:19.590
Now, you can also specify which fields
from your data types should

00:09:19.590 --> 00:09:22.130
appear in Finder info windows.

00:09:22.290 --> 00:09:25.940
So when the user opens an info window,
the bottom two fields,

00:09:26.030 --> 00:09:29.390
the title and the comment,
are the fields they would

00:09:29.390 --> 00:09:30.970
see from the Finder.

00:09:31.180 --> 00:09:34.060
If you need to define
your own data types,

00:09:34.060 --> 00:09:39.070
the schema.xml file contains
comments to describe how to define

00:09:39.130 --> 00:09:43.480
your own data types and inform
the system as to their structure.

00:09:43.740 --> 00:09:46.940
But we really recommend
that whenever possible,

00:09:46.940 --> 00:09:51.820
you use the existing data types unless
there's really no way to describe

00:09:52.260 --> 00:09:54.770
your content with the existing ones.

00:09:55.220 --> 00:09:58.920
The last thing we have to do is
implement the callback function.

00:09:59.080 --> 00:10:01.470
This is really the meat of the importer.

00:10:01.610 --> 00:10:05.720
The callback function will be
called with a path to the file

00:10:05.720 --> 00:10:11.480
the system wants to import,
and your plug-in will open the file,

00:10:11.670 --> 00:10:14.350
Parse it or input it in
any way that's appropriate,

00:10:14.500 --> 00:10:17.600
pulling out the attributes you
want to inform Spotlight about,

00:10:17.800 --> 00:10:20.920
and then you'll put those
attributes with their values in the

00:10:20.920 --> 00:10:22.690
dictionary that you're provided.

00:10:22.860 --> 00:10:26.920
That dictionary will be sent back to
the server and users can now search

00:10:27.030 --> 00:10:31.750
and find this specific file based on
the attributes that you've provided.

00:10:32.900 --> 00:10:38.300
Kaelin will now give us a demo of how to
go ahead and build an importer plugin.

00:10:38.550 --> 00:10:39.400
Good morning.

00:10:39.400 --> 00:10:40.160
I'm Kaelin Colclasur.

00:10:40.160 --> 00:10:43.030
And as Andy said,
what we'll be looking at doing this

00:10:43.340 --> 00:10:48.280
morning is actually taking an existing
application and looking at how simple

00:10:48.280 --> 00:10:52.990
it is to build an importer plug-in and
expose that application's content to

00:10:52.990 --> 00:10:57.850
the user's desktop via its metadata.

00:10:58.400 --> 00:11:00.910
For our demonstration here,
we started with a little

00:11:01.190 --> 00:11:03.300
application called Fortunes.

00:11:03.300 --> 00:11:06.040
For those of you with a
bit of a Unix-y background,

00:11:06.040 --> 00:11:09.780
this is inspired by the classic
fortune cookie program that

00:11:09.780 --> 00:11:12.180
shipped in Unix for decades now.

00:11:12.360 --> 00:11:17.010
It basically allows the users to
accumulate a nice little collection

00:11:17.050 --> 00:11:21.300
of witty sayings and store them away,
and then it can spit them out

00:11:21.300 --> 00:11:25.300
when your terminal window logs
in or something like that.

00:11:25.370 --> 00:11:27.990
So the classic Fortunes--

00:11:30.500 --> 00:11:37.300
[Transcript missing]

00:11:56.790 --> 00:11:59.760
Yay.

00:11:59.840 --> 00:12:01.860
Sorry about that.

00:12:01.910 --> 00:12:03.840
OK.

00:12:04.040 --> 00:12:07.070
So our Fortunes application,
I'll go ahead and launch it here,

00:12:07.130 --> 00:12:11.600
and as we see,
it gives us a nice little Cocoa table

00:12:11.600 --> 00:12:15.980
view with a list of the Fortunes that
I've happened to put together so far.

00:12:16.040 --> 00:12:21.480
Now for the purposes of making
this interesting content

00:12:21.480 --> 00:12:24.140
to index with Spotlight,
I've actually,

00:12:24.140 --> 00:12:27.130
instead of using sort of the
classic Fortunes file format,

00:12:27.130 --> 00:12:32.400
where you have a single monolithic
file that has a simple text delimiter,

00:12:32.460 --> 00:12:36.350
I use individual files to
store the Fortune data.

00:12:36.450 --> 00:12:39.320
So let's go ahead and
look at one of those.

00:12:39.950 --> 00:12:42.040
And we can see here this
is just a-- you know,

00:12:42.040 --> 00:12:44.700
the standard XML plist format file.

00:12:44.960 --> 00:12:45.930
And, um...

00:12:47.890 --> 00:12:52.500
Each one of these files holds a
single entry in our Fortune database,

00:12:52.500 --> 00:12:56.580
and we'll basically store individual
files like this every time we

00:12:56.580 --> 00:12:58.640
add a new entry to the database.

00:12:58.800 --> 00:13:01.780
So without further ado,
let's go ahead and see what it takes

00:13:01.940 --> 00:13:07.840
to get that content indexed and
searchable from the Mac OS X desktop.

00:13:07.950 --> 00:13:12.950
So the first thing we want to do in Xcode
is create a new Spotlight plugin project.

00:13:15.300 --> 00:13:19.960
We just create a new project,
and we navigate down into our

00:13:19.960 --> 00:13:24.720
Mac OS X standard Apple plug-in
section and select the

00:13:24.720 --> 00:13:27.220
Spotlight plug-in template.

00:13:27.250 --> 00:13:28.540
Choose that.

00:13:28.580 --> 00:13:33.280
We're going to save it as Fortune Cookie.

00:13:35.880 --> 00:13:41.030
And the actual target for this project
will be fortunecookie.mdimporter.

00:13:41.180 --> 00:13:44.360
So now, as Andy mentioned,
one of the first things we'll need to do

00:13:44.360 --> 00:13:51.820
with our new Fortune Cookie project is
update this Info.plist file to basically

00:13:52.650 --> 00:13:57.000
expose to the system and launch services
the UTIs that this particular importer

00:13:57.000 --> 00:14:01.770
is going to support and also declare to
the system what metadata elements are

00:14:01.770 --> 00:14:05.660
going to be introduced by this importer.

00:14:05.840 --> 00:14:08.410
So we'll double-click to edit that.

00:14:08.510 --> 00:14:12.760
And as Andy was mentioning also,
one of the first things we want to do as

00:14:12.760 --> 00:14:15.370
we edit our Info.plist is to make sure,
since we're building a

00:14:15.370 --> 00:14:20.900
standalone importer project,
that we have an imported declaration

00:14:20.900 --> 00:14:23.340
for our document UTI type.

00:14:23.500 --> 00:14:28.800
So we'll go back to our application here,
actually open its Info.plist quickly,

00:14:28.890 --> 00:14:33.910
and find its declaration
for exported UTI types.

00:14:34.000 --> 00:14:35.520
And copy that.

00:14:37.640 --> 00:14:41.270
Then switch back to our
Fortune Cookie project

00:14:41.560 --> 00:14:43.000
and its InfoP list.

00:14:43.160 --> 00:14:50.930
We're going to create a new
declaration here of imported UTI types.

00:14:53.900 --> 00:14:57.580
And just by pasting there,
getting rid of the template,

00:14:57.580 --> 00:15:00.270
if I expand this out,
we can see that this basically

00:15:00.410 --> 00:15:05.600
contains the declaration of the
UTI tree that this particular content

00:15:05.600 --> 00:15:09.770
conforms to and also declares what
extension we're going to use for

00:15:09.770 --> 00:15:12.800
our files as we save them on disk.

00:15:13.040 --> 00:15:16.620
With that out of the way,
we can move on to setting the actual

00:15:16.620 --> 00:15:19.800
supported UTI type for this importer.

00:15:20.050 --> 00:15:24.800
Now, your importer plug-ins can
actually handle multiple UTIs.

00:15:24.800 --> 00:15:29.820
Like, if you have a document that has--
or if you have an application that

00:15:29.910 --> 00:15:32.270
has more than one type of document,
you can handle all of those

00:15:32.270 --> 00:15:33.700
with a single importer.

00:15:33.860 --> 00:15:38.590
So this document types...

00:15:43.210 --> 00:15:46.340
So the imported type UTIs that we're
going to edit here-- I'm sorry,

00:15:46.340 --> 00:15:50.330
the document types we're going to
edit here actually declare an array.

00:15:50.840 --> 00:15:53.070
of supported UTI types.

00:15:53.200 --> 00:15:55.330
In this case,
we've got only a single type,

00:15:55.520 --> 00:15:58.150
so we just fill that in.

00:16:03.630 --> 00:16:13.240
example.fortune-cookie.

00:16:13.410 --> 00:16:17.380
And with that done,
we're ready to save this file.

00:16:24.180 --> 00:16:26.620
Okay,
the next thing we want to do is actually

00:16:26.630 --> 00:16:32.400
edit our project so that we can use
Objective-C to implement our plugin.

00:16:32.480 --> 00:16:36.830
To do that,
we need to add to our external

00:16:36.830 --> 00:16:42.270
frameworks the existing metadata--
or the existing foundation framework.

00:16:50.700 --> 00:16:59.400
is a great example of this.

00:16:59.400 --> 00:16:59.400
He's a great example of how
to use Spotlight to create a

00:16:59.570 --> 00:17:02.400
Go ahead and change the
extension of our source file.

00:17:02.730 --> 00:17:05.190
We see here in the template
we have a standard source file

00:17:05.300 --> 00:17:08.300
called getMetadataForFile.c.

00:17:08.300 --> 00:17:16.330
We can just change that extension to .m,
and that sets us up to use Objective-C.

00:17:17.980 --> 00:17:21.000
Click to edit that file,
and the first thing we want to do now is

00:17:21.000 --> 00:17:24.870
go ahead and import foundation framework.

00:17:25.900 --> 00:17:29.140
And then we can see here the
template includes enumeration

00:17:29.140 --> 00:17:32.440
of the steps that we're actually
running through right here.

00:17:32.640 --> 00:17:35.200
So we'll just come down and...

00:17:36.260 --> 00:17:40.690
Paste in an implementation
for our importer here.

00:17:40.850 --> 00:17:43.500
Since we're using Objective-C, we,
of course,

00:17:43.500 --> 00:17:48.550
want to declare an auto-release pool,
and basically,

00:17:49.000 --> 00:17:52.680
Our documents on disk consist of
a simple plist format that the

00:17:53.000 --> 00:17:57.140
Foundation dictionary class has a
convenience method to read for us.

00:17:57.240 --> 00:18:00.730
So we just call that convenience
method with the path that's passed

00:18:00.980 --> 00:18:03.000
in when our importer is called.

00:18:03.120 --> 00:18:08.700
And we fill in the attributes dictionary,
which is a mutable dictionary reference,

00:18:08.880 --> 00:18:12.820
from the elements in our dictionary
that we want to include as

00:18:12.820 --> 00:18:16.090
metadata for our document type.

00:18:16.190 --> 00:18:19.800
If we succeed in loading the dictionary
and setting all those attributes,

00:18:19.820 --> 00:18:22.600
we go ahead and are going to
set a status value to true,

00:18:22.640 --> 00:18:26.200
which tells the Spotlight infrastructure
that this importer plug-in succeeded

00:18:26.200 --> 00:18:27.860
for this particular document.

00:18:27.990 --> 00:18:31.080
If there's any problem at all,
all you can do here is return false.

00:18:31.200 --> 00:18:35.000
There's no UI or anything
presented from an importer plug-in.

00:18:35.000 --> 00:18:37.260
So then we go ahead
and return that status,

00:18:37.260 --> 00:18:40.090
and that's all there is to the plug-in.

00:18:40.190 --> 00:18:42.500
Now, we do have one further
thing we need to do.

00:18:42.570 --> 00:18:44.900
And you can notice here
we've -- in our plug-in,

00:18:44.900 --> 00:18:49.440
we've basically -- we've basically used
a set of standard attributes that we

00:18:49.550 --> 00:18:53.740
got from mditem.h that sort of captured
the essence of the metadata that we

00:18:53.740 --> 00:18:56.000
wanted to have for each of our documents.

00:18:56.240 --> 00:18:58.990
But for example purposes,
we're also going to go ahead

00:18:58.990 --> 00:19:00.500
and define a custom attribute.

00:19:00.710 --> 00:19:02.970
For a custom attribute,
you use the same sort of

00:19:03.010 --> 00:19:07.000
reverse DNS naming convention
that you use for the UTI.

00:19:07.000 --> 00:19:10.850
The notable exception is
where in a reverse DNS name,

00:19:10.850 --> 00:19:15.900
you would have dots in the name,
you use underscores instead.

00:19:15.900 --> 00:19:19.970
is key-value coding compliant for Cocoa.

00:19:20.800 --> 00:19:23.460
Okay, so we're done with that file.

00:19:23.640 --> 00:19:28.700
And now we can edit our schema to
go ahead and tell-- in the schema,

00:19:28.700 --> 00:19:32.820
declare the same information we
just imported in our importer so

00:19:32.980 --> 00:19:37.200
that Spotlight knows what to expect
when this importer plug-in is run.

00:19:37.260 --> 00:19:41.430
So under Resources,
we have a schema.xml file.

00:19:42.130 --> 00:19:47.820
And as the comment here says
in the attributes section,

00:19:48.770 --> 00:19:53.100
You can put in any declarations of
custom attributes that you need.

00:19:53.150 --> 00:19:56.090
Now, I would remind everyone, in general,
it's unusual for you to

00:19:56.090 --> 00:19:57.190
need a custom attribute.

00:19:57.250 --> 00:20:00.000
There's a pretty complete
set defined in mditem.h,

00:20:00.000 --> 00:20:03.650
and that's definitely your first
place to look as you're defining the

00:20:03.650 --> 00:20:06.150
metadata types for your document.

00:20:06.310 --> 00:20:09.750
But again, for example purposes here,
we'll go ahead and define our custom

00:20:09.860 --> 00:20:14.920
com example fortune ID attribute,
and we make it a single, simple,

00:20:15.090 --> 00:20:17.600
single-valued attribute of type CFString.

00:20:18.010 --> 00:20:20.570
And then the next thing we want to do

00:20:20.690 --> 00:20:25.000
We've got an all adders element,
which if you remember from Andy's slides,

00:20:25.160 --> 00:20:29.060
basically tells Spotlight all of
the attributes that are going to be

00:20:29.060 --> 00:20:34.030
returned by this importer plugin.

00:20:38.660 --> 00:20:40.360
It's not the correct declaration.

00:20:40.360 --> 00:20:42.600
Let me just fix that real quick.

00:20:42.600 --> 00:20:46.100
There we go.

00:20:46.100 --> 00:20:50.020
Here we declare our custom
attribute along with the three

00:20:50.020 --> 00:20:53.030
we selected from mditemh:
timestamp, display name,

00:20:53.040 --> 00:20:54.100
and text content.

00:20:54.100 --> 00:20:57.990
The last thing we need to edit
is our display attributes.

00:20:58.660 --> 00:21:01.750
And this is the subset of attributes
we would actually like the finder or

00:21:01.750 --> 00:21:05.320
the Spotlight menu-- the Spotlight
menu will display in a tooltip or the

00:21:05.480 --> 00:21:10.840
finder will display in that little
More Info panel in the Get Info window.

00:21:10.880 --> 00:21:14.430
And here we're just going
to use display name.

00:21:14.530 --> 00:21:21.190
So with that saved, we're actually ready
to build our plug-in.

00:21:26.320 --> 00:21:29.150
And the next thing we want to do is
actually set up so that we're able to

00:21:29.150 --> 00:21:31.600
debug our plug-in right here in Xcode.

00:21:31.820 --> 00:21:39.540
So to do that, under your project window,
you'll create a new custom executable...

00:21:39.900 --> 00:21:49.300
and point that at the MD import tool.

00:22:02.440 --> 00:22:05.800
Now, once we've got a custom
executable pointer at MD import,

00:22:05.800 --> 00:22:08.720
we basically need to set up the
arguments that we're going to pass

00:22:08.800 --> 00:22:11.060
every time MD import is invoked.

00:22:11.210 --> 00:22:13.300
And we'll also be taking a
look at how to run MD import

00:22:13.300 --> 00:22:15.140
directly from the command line.

00:22:15.270 --> 00:22:20.340
But the basic arguments we
want for debugging are...

00:22:21.220 --> 00:22:24.220
We'll add a -d2,
which will tell MD import to

00:22:24.330 --> 00:22:28.240
spit out some nice diagnostic
information to the console window.

00:22:28.460 --> 00:22:31.780
And we'll add a -g,

00:22:49.420 --> 00:22:54.140
with the path to our built importer.

00:22:54.270 --> 00:22:57.680
And the last thing we want to
do is set the path argument.

00:23:01.610 --> 00:23:06.770
In this case,
I've got a preexisting... file,

00:23:06.770 --> 00:23:08.570
and I just want to drag and drop.

00:23:08.670 --> 00:23:12.630
Good,
'cause I didn't want to try to type that.

00:23:12.920 --> 00:23:15.880
And with all that set,
we can actually go ahead and

00:23:15.880 --> 00:23:21.180
save our custom executable and
switch back to our source files.

00:23:22.310 --> 00:23:26.880
And we'll set a breakpoint right
in Xcode where we would want to

00:23:26.980 --> 00:23:30.200
check to see that we've successfully
loaded our document from disk.

00:23:30.200 --> 00:23:33.200
Now if we select Build and Go...

00:23:43.900 --> 00:23:45.840
So for some reason it
didn't hit the breakpoint,

00:23:45.840 --> 00:23:49.750
but we'll pretend it did.

00:23:53.100 --> 00:23:55.840
So normally Xcode would break right here,
and you'd be able to actually

00:23:55.840 --> 00:23:58.420
examine the values that were
pulled in by your importer and

00:23:58.420 --> 00:24:00.760
look at them right here in Xcode.

00:24:01.220 --> 00:24:02.720
So with...

00:24:03.120 --> 00:24:08.740
The other way to debug your importer
is actually using a terminal window.

00:24:08.760 --> 00:24:13.820
There are some handy options provided by
the MD import tool that you can use to

00:24:14.460 --> 00:24:17.450
look at the scalability of your importer,
see that you're getting

00:24:17.450 --> 00:24:19.100
the data you expected,
et cetera.

00:24:19.230 --> 00:24:24.660
So one of the first options we'll
look at here is the -p option.

00:24:24.710 --> 00:24:31.260
-p basically tells MD import to
collect and format statistics about the

00:24:31.360 --> 00:24:33.400
performance of your importer plug-in.

00:24:33.480 --> 00:24:36.380
So what I'm going to do here is
actually tell it to run the importer

00:24:36.380 --> 00:24:39.690
plug-in we just built on all of
the cookies that I've currently

00:24:39.710 --> 00:24:43.900
accumulated on my drive here.

00:24:43.960 --> 00:24:50.100
And we can see that the total processing
time for this plug-in for all the files,

00:24:50.100 --> 00:24:54.600
for all 31 files, was, you know,
under a second, which looks good.

00:24:54.610 --> 00:24:57.410
And we also get a nice summary
of the most expensive files

00:24:57.500 --> 00:24:58.790
for your importer plug-in.

00:24:58.800 --> 00:25:01.290
So if you do have performance
issues on an importer,

00:25:01.300 --> 00:25:04.000
this is a really good tool
for sort of isolating,

00:25:04.000 --> 00:25:07.170
you know, if it's a certain category of
files that you have issues with

00:25:07.200 --> 00:25:09.180
or if it's a specific file.

00:25:09.650 --> 00:25:12.540
Another nice tool to work with is MDLS.

00:25:12.700 --> 00:25:18.400
MDLS will basically list metadata
that's been stored already in the

00:25:18.400 --> 00:25:20.620
Spotlight index and let you see that.

00:25:20.800 --> 00:25:22.330
So...

00:25:23.300 --> 00:25:28.100
Let's take a look at an MDLS command
for one of the files we just imported.

00:25:28.210 --> 00:25:30.900
And we can see a nice little summary.

00:25:30.900 --> 00:25:34.810
We can see our content type tree.

00:25:35.290 --> 00:25:39.140
We noticed that our com example fortune
ID custom attribute was imported.

00:25:39.140 --> 00:25:41.200
That's a good sign that
our importer was running.

00:25:41.200 --> 00:25:44.060
And we also got a non-default
display name with the text

00:25:44.130 --> 00:25:45.140
of our fortune message.

00:25:45.140 --> 00:25:48.360
So that's another positive
indication that our importer

00:25:48.360 --> 00:25:50.460
has indexed this content.

00:25:50.540 --> 00:25:53.800
And the last thing you want
to do is test with mdefind.

00:25:53.950 --> 00:25:58.400
So basically,
mdefind will let us search for

00:25:58.400 --> 00:26:04.260
here any item in Spotlight's
database which has a com example

00:26:04.260 --> 00:26:06.740
fortune ID attribute of any value.

00:26:07.060 --> 00:26:09.190
And in this case,
it's only going to be our document

00:26:09.190 --> 00:26:11.200
type since that's a custom attribute.

00:26:11.340 --> 00:26:17.500
And we can see how that shows us all of
those on the locally attached storage.

00:26:17.700 --> 00:26:20.540
So the final place to look, of course,
is what your end users are going

00:26:20.540 --> 00:26:23.100
to see after you've gone through
the work of building this plug-in.

00:26:23.290 --> 00:26:26.620
And we can see if we now do a search,

00:26:26.760 --> 00:26:29.780
In the Spotlight menu,
one of our hits is indeed

00:26:29.780 --> 00:26:31.110
one of our Fortune files.

00:26:31.200 --> 00:26:34.410
And if we let the tooltip pop up,
we can see the display name,

00:26:34.410 --> 00:26:37.720
and we can also see the path to
where that's stored on our drive.

00:26:37.780 --> 00:26:39.690
And that concludes the first demo.

00:26:40.470 --> 00:26:42.500
Thank you.

00:26:45.720 --> 00:26:47.580
Thank you, Kaelin.

00:26:47.740 --> 00:26:52.300
Now, when you've built your plug-in,
you want to reinforce that

00:26:52.300 --> 00:26:53.500
you're going to want to test it.

00:26:53.560 --> 00:26:56.000
Kaelin showed how you
do your basic testing.

00:26:56.000 --> 00:27:02.080
You can do it from within Xcode,
or you can do the testing from

00:27:02.080 --> 00:27:02.080
the terminal command line.

00:27:02.310 --> 00:27:04.880
It's important you test
against all the architectures.

00:27:04.980 --> 00:27:10.740
You're going to want to test PowerPC,
32-bit Intel, and 64-bit Intel.

00:27:10.850 --> 00:27:15.230
If your machine is running 64 bits,
you can force the importer into

00:27:15.230 --> 00:27:21.550
32-bit mode by prefixing it on
the command line with arch-i386.

00:27:21.700 --> 00:27:27.760
And that option forces the following
command to always run in 32-bit mode.

00:27:27.900 --> 00:27:30.210
The -d option is also extremely useful.

00:27:30.420 --> 00:27:33.430
Those are debugging options
that will display progress that

00:27:33.490 --> 00:27:37.000
the importer is making as it's
working through your files.

00:27:37.140 --> 00:27:40.710
It's very, very useful when you're having
problems with your plug-in.

00:27:40.860 --> 00:27:45.420
And of course, the -p option to give you
performance statistics.

00:27:45.540 --> 00:27:47.920
Now, here's some goals for testing.

00:27:48.040 --> 00:27:50.360
Performance is extremely critical.

00:27:50.490 --> 00:27:53.950
Oftentimes, people think in terms of,
"Well, I ran the importer

00:27:54.090 --> 00:27:58.040
against my top 10 files,
and it works fine." But your users

00:27:58.040 --> 00:28:00.070
may not have 10 of your file.

00:28:00.200 --> 00:28:02.000
They may not have 100 of your file.

00:28:02.240 --> 00:28:04.590
They might have thousands,
tens of thousands,

00:28:04.680 --> 00:28:06.940
or even hundreds of thousands of files.

00:28:07.020 --> 00:28:10.130
And the cumulative time it takes
to index all of those files

00:28:10.520 --> 00:28:12.340
can be very painful for a user.

00:28:12.470 --> 00:28:16.410
I really want to encourage
people to use every performance

00:28:16.410 --> 00:28:20.960
tool to really streamline the
process of importing your data.

00:28:21.070 --> 00:28:24.310
And because your importer
plug-in will be run many,

00:28:24.390 --> 00:28:26.640
many times, it's important that
you don't leak memory.

00:28:26.660 --> 00:28:30.570
Or file descriptors,
or any other resource.

00:28:30.640 --> 00:28:33.970
And the worst sin of all is crashing.

00:28:34.140 --> 00:28:38.200
The time it takes to handle a crash
and relaunch the importer with your

00:28:38.200 --> 00:28:43.050
plug-in again can add up to a lot of
time if there are frequent crashes.

00:28:43.140 --> 00:28:47.470
So test against a lot of files,
and test against edge case or odd

00:28:47.470 --> 00:28:51.440
or even corrupt and broken files
to make sure that your plug-in

00:28:51.440 --> 00:28:53.630
is stable and good for the users.

00:28:53.640 --> 00:28:56.080
And again, test it on every architecture.

00:28:56.080 --> 00:28:59.560
Three-way testing is very important.

00:28:59.660 --> 00:29:03.030
Now where do you put the plug-in
when you're done building it?

00:29:03.220 --> 00:29:06.500
The primary location is
in /library/spotlight.

00:29:06.800 --> 00:29:10.130
This is where most people
will put their plug-ins.

00:29:10.290 --> 00:29:13.160
You can also put it directly
into your application.

00:29:13.290 --> 00:29:15.860
That way,
if the user has your application,

00:29:15.970 --> 00:29:17.960
they have your plug-in.

00:29:18.080 --> 00:29:22.480
But it's very important when you put
it there that you copy your plug-in

00:29:22.480 --> 00:29:24.310
to where it's going to finally be.

00:29:24.590 --> 00:29:27.440
Don't use a symlink or other
trick to make it appear there.

00:29:27.880 --> 00:29:30.920
That's because Spotlight
watches the locations where

00:29:30.920 --> 00:29:33.240
your plug-in is allowed to be,
and when it notices a

00:29:33.240 --> 00:29:35.780
new plug-in arriving,
it will add it into the

00:29:35.780 --> 00:29:37.650
pool of available plug-ins.

00:29:37.650 --> 00:29:41.530
If you simply put a symlink there,
Spotlight might not notice the

00:29:41.600 --> 00:29:44.120
addition of the new plug-in.

00:29:44.220 --> 00:29:46.700
Because there's multiple
places to put a plugin,

00:29:46.780 --> 00:29:48.330
there's a precedence issue.

00:29:48.480 --> 00:29:53.590
Spotlight will first look
in /library/spotlight.

00:29:53.690 --> 00:29:58.040
Then it will look in
system/library/spotlight.

00:29:58.040 --> 00:30:01.110
And then failing that,
it will look inside of an application

00:30:01.110 --> 00:30:03.300
to see if you've got an embedded plugin.

00:30:03.410 --> 00:30:07.580
So if there are two different
plugins that both want that UTI type,

00:30:07.710 --> 00:30:11.300
the first one found will be the
one used to import that file.

00:30:11.490 --> 00:30:13.870
You cannot daisy chain
or combine importers.

00:30:14.080 --> 00:30:15.520
One plugin will get the go.

00:30:15.840 --> 00:30:18.970
That plugin imports that particular file.

00:30:19.860 --> 00:30:24.220
The last thing that Spotlight brings
to the equation is an API to allow

00:30:24.220 --> 00:30:27.160
you to search within your application.

00:30:27.320 --> 00:30:28.880
Now, how does that work?

00:30:29.000 --> 00:30:33.720
We take the existing architecture
and we add in the ability

00:30:33.720 --> 00:30:36.540
to have application queries.

00:30:36.670 --> 00:30:39.790
Those queries will come
from your application.

00:30:40.140 --> 00:30:43.080
Now, you're going to use the
Spotlight query language,

00:30:43.080 --> 00:30:46.500
which for people who program in
C should look reasonably familiar.

00:30:46.630 --> 00:30:50.190
You're going to compare
attributes to values,

00:30:50.190 --> 00:30:54.120
and the files that match that
query statement will be the

00:30:54.230 --> 00:30:56.400
files returned from the query.

00:30:56.550 --> 00:31:01.330
You have basic data types: strings,
numbers, dates.

00:31:01.480 --> 00:31:04.050
They can be scalar, that is,
individual values,

00:31:04.210 --> 00:31:06.600
or they can be arrays of values.

00:31:06.770 --> 00:31:09.180
And you have the expected
string operators,

00:31:09.180 --> 00:31:10.000
equality.

00:31:10.120 --> 00:31:15.790
You can test a wildcard to test if
a string partially matches a value.

00:31:15.950 --> 00:31:18.910
And you have your normal
comparison values that you're

00:31:18.910 --> 00:31:22.730
used to for numerical values,
as well as a range detection,

00:31:22.790 --> 00:31:26.100
which allows you to specify
a range of numbers or dates

00:31:26.690 --> 00:31:29.340
that will match your test.

00:31:29.750 --> 00:31:32.990
You can group these things together
to make more complicated queries,

00:31:33.230 --> 00:31:36.600
queries that match multiple tests.

00:31:36.800 --> 00:31:41.300
And you can use the asterisk for the
wildcard to mean any metadata field.

00:31:41.300 --> 00:31:44.490
And then the last example,
if any metadata field has

00:31:44.900 --> 00:31:48.200
the word Boston in it,
that will return true.

00:31:48.400 --> 00:31:52.430
It's important to note, however,
the KMDItem text content

00:31:52.430 --> 00:31:54.340
doesn't fall into the star.

00:31:54.690 --> 00:31:59.230
That specific value must
be tested explicitly.

00:32:00.020 --> 00:32:03.790
Now, string comparisons,
it's actually fairly sophisticated.

00:32:03.900 --> 00:32:08.210
Your users might be surprised or
actually disappointed if you do your

00:32:08.210 --> 00:32:11.940
string compares as exact matches,
which is the default,

00:32:12.140 --> 00:32:16.140
because case may differ or other minor
things that the user wouldn't think

00:32:16.140 --> 00:32:18.560
ought to make the test fail will fail.

00:32:18.720 --> 00:32:22.940
So you can make your
comparison case insensitive.

00:32:23.050 --> 00:32:25.910
You can make it diacritic
insensitive if you're going to

00:32:25.910 --> 00:32:28.800
be having foreign language words.

00:32:28.920 --> 00:32:31.800
And you can do word-based testing
where you can say that if the

00:32:31.920 --> 00:32:35.710
word appears anywhere in a phrase,
for example,

00:32:36.100 --> 00:32:38.120
you want to go ahead and match.

00:32:38.390 --> 00:32:43.900
This type of comparison is always
done for KMDItem text content.

00:32:44.000 --> 00:32:47.500
And it's important to note that
these modifiers can be combined,

00:32:47.500 --> 00:32:50.200
and we'll see how that works in a moment.

00:32:51.490 --> 00:32:52.840
You can also do dates.

00:32:53.090 --> 00:32:56.750
Now, as a convenience,
there's multiple ways to specify a date.

00:32:56.960 --> 00:33:02.120
You can specify a date of right
now or this week or last week.

00:33:02.290 --> 00:33:07.160
You can provide your own explicit
date by using an ISO format.

00:33:07.160 --> 00:33:09.040
You can say today.

00:33:09.040 --> 00:33:12.910
You can also provide for all of
the different date formats a range,

00:33:12.910 --> 00:33:14.560
a relative offset.

00:33:14.680 --> 00:33:18.600
So you could say in the bottom example,
today minus 12,

00:33:18.600 --> 00:33:21.280
which really means 12 days ago.

00:33:23.180 --> 00:33:26.970
You can combine all of these
capabilities to make queries.

00:33:27.190 --> 00:33:30.700
You can, for example,
query if the number of pages in a

00:33:30.750 --> 00:33:33.270
document is larger than some value.

00:33:33.530 --> 00:33:38.900
Or if any author in a potential
array of authors matches Frank Burns,

00:33:38.900 --> 00:33:42.280
and you're not really worried
about case or diacritic and you're

00:33:42.650 --> 00:33:46.120
willing to do a word search,
or you can see the kind of query

00:33:46.120 --> 00:33:50.560
that's generated by the spotlight menu,
where basically if you were to search

00:33:50.560 --> 00:33:54.560
for the word apple in the spotlight menu,
it would actually say if any

00:33:54.670 --> 00:33:59.320
metadata field matches the word
apple followed by anything,

00:33:59.320 --> 00:34:05.400
case and diacritic insensitive,
or if any text content matches

00:34:06.000 --> 00:34:10.630
apple followed by anything,
case and diacritic insensitive,

00:34:10.810 --> 00:34:11.700
return that file.

00:34:11.700 --> 00:34:14.700
So that's how the spotlight menu works.

00:34:14.720 --> 00:34:17.280
And last,
this is a query that says you want

00:34:17.400 --> 00:34:22.920
to find all of the text files that
have been opened in the last 12 days.

00:34:22.980 --> 00:34:24.790
It's pretty useful.

00:34:25.090 --> 00:34:27.310
You can make more complicated queries.

00:34:27.420 --> 00:34:34.080
You can find all the photographs taken
with a Canon camera and a specific lens.

00:34:34.310 --> 00:34:40.060
You can find all the files
that have a specific DPI range.

00:34:40.060 --> 00:34:44.810
Or you can look for sound effects that
mention the word "thunder" that are

00:34:44.810 --> 00:34:47.950
between one and five seconds in length.

00:34:49.320 --> 00:34:52.580
Now, to actually do the queries,
you're going to have to use the API.

00:34:52.690 --> 00:34:55.790
And there's two basic
APIs that you have a choice of.

00:34:55.910 --> 00:35:01.340
The MD Query Ref API is a lower level,
more flexible API at the

00:35:01.340 --> 00:35:03.530
core foundation level.

00:35:03.830 --> 00:35:07.670
And you have NSMetadataQuery,
which is a higher level

00:35:07.670 --> 00:35:10.360
KVO compliant type syntax.

00:35:10.750 --> 00:35:12.670
And KVO is Key Value Observer.

00:35:12.670 --> 00:35:17.120
This is useful where you're doing
AppKit programming and you want to

00:35:17.120 --> 00:35:20.730
be notified when key values change,
your observer will be notified.

00:35:20.740 --> 00:35:25.320
And that makes it very easy to put
together higher level applications very,

00:35:25.320 --> 00:35:26.440
very easily.

00:35:26.470 --> 00:35:30.190
We're going to take a look
at the lower level API first.

00:35:30.930 --> 00:35:33.200
There's three basic flavors of query.

00:35:33.320 --> 00:35:35.830
You can do a synchronous query,
where your code will stop

00:35:35.860 --> 00:35:38.200
until the query is complete.

00:35:38.320 --> 00:35:40.660
You can do an asynchronous query,
where your code will

00:35:40.660 --> 00:35:43.600
continue to run normally,
and then the query will complete

00:35:43.600 --> 00:35:45.420
and you'll have your answers.

00:35:45.550 --> 00:35:49.210
Or you can do a live updated query,
where your query will run as long as

00:35:49.210 --> 00:35:51.310
you want it to run in the background.

00:35:51.540 --> 00:35:54.220
And as the user lives on the system,
and files are moved and

00:35:54.220 --> 00:35:57.770
changed and updated,
your query will be updated with the

00:35:57.830 --> 00:36:01.520
results live as the user's doing things.

00:36:01.890 --> 00:36:03.490
Let's talk about the
synchronous query first.

00:36:03.700 --> 00:36:05.610
It's the most simple.

00:36:06.530 --> 00:36:08.240
There's three basic steps.

00:36:08.370 --> 00:36:11.080
We're going to create an MD Query ref.

00:36:11.140 --> 00:36:13.740
We're going to ask it
to execute the query.

00:36:13.900 --> 00:36:17.910
And we're going to take a look at what
Spotlight sends back as the results.

00:36:18.250 --> 00:36:20.600
Creating the query is
very straightforward.

00:36:20.680 --> 00:36:23.170
We're going to create the query
and we're going to give it a query

00:36:23.250 --> 00:36:27.280
string which basically says we
want to find all the text files,

00:36:27.280 --> 00:36:29.810
the plain text files on the system.

00:36:30.050 --> 00:36:31.980
Very simple query.

00:36:34.030 --> 00:36:37.380
Then we're going to execute the query
and we're going to tell Spotlight that we

00:36:37.380 --> 00:36:40.270
want the query to execute synchronously.

00:36:40.270 --> 00:36:44.490
This clock until all of the
query results are available.

00:36:45.440 --> 00:36:47.890
And then when the results are in,
you can get a count of how

00:36:47.890 --> 00:36:49.300
many results there were.

00:36:49.480 --> 00:36:53.030
And you can iterate over those results,
taking a look at each MD item

00:36:53.030 --> 00:36:55.300
ref that's returned in turn.

00:36:55.300 --> 00:37:00.240
An MD item is basically a stand-in
for each file that's being returned.

00:37:00.570 --> 00:37:04.230
And you can ask that MD item for any
attributes that you want about that file.

00:37:04.390 --> 00:37:07.300
And in this case, we're going to iterate
over all of the results,

00:37:07.300 --> 00:37:10.560
and we're going to get the
display name for every file that

00:37:10.560 --> 00:37:12.300
was returned from this query.

00:37:12.540 --> 00:37:14.290
Very, very simple.

00:37:15.300 --> 00:37:19.040
But your users probably don't want
your application to come to a dead

00:37:19.040 --> 00:37:21.240
stop while you're doing a query.

00:37:21.380 --> 00:37:25.500
So you might find more value
in an asynchronous query.

00:37:26.180 --> 00:37:29.260
Now when you do an asynchronous query,
I first want to introduce

00:37:29.260 --> 00:37:30.300
some notifications.

00:37:30.430 --> 00:37:32.960
Because your query is going
to run in the background,

00:37:33.120 --> 00:37:35.520
you're probably going to
want to be informed as to

00:37:35.600 --> 00:37:37.040
the progress of your query.

00:37:37.040 --> 00:37:41.230
So you can get a progress notification,
which will occur at intervals

00:37:41.230 --> 00:37:45.270
while the query is ongoing to
let you know incremental results,

00:37:45.270 --> 00:37:49.270
and then you're going to get a did
finish notification that lets you know

00:37:49.270 --> 00:37:53.070
that the query is complete and you
will not be receiving any more results.

00:37:53.110 --> 00:37:56.150
Now let's take a look at
how we're going to do this.

00:37:56.150 --> 00:37:59.440
We're going to create a
query like we did before.

00:37:59.440 --> 00:38:03.410
This time we're going to register some
callbacks for those notifications.

00:38:03.560 --> 00:38:06.180
We're going to define those callbacks.

00:38:06.250 --> 00:38:09.520
We're actually going to run the query,
and then we're going to handle the

00:38:09.520 --> 00:38:11.520
results when the query is complete.

00:38:11.640 --> 00:38:13.160
Let's take a look at that.

00:38:13.240 --> 00:38:14.930
We're going to do the
same query we did before.

00:38:15.180 --> 00:38:19.470
We want to find all the plain
text files on the system.

00:38:20.010 --> 00:38:21.940
And then we're going to
register for our callbacks.

00:38:21.940 --> 00:38:25.370
We want our progress notification
that will let us know as the query

00:38:25.370 --> 00:38:29.430
is being handled and results are
incrementally being returned.

00:38:29.690 --> 00:38:33.200
And we're going to want to register
for our Did Finish notification so that

00:38:33.200 --> 00:38:37.910
we know that all of the results are
available and that the query is complete.

00:38:38.770 --> 00:38:40.930
And then we're going to
define the callbacks.

00:38:41.070 --> 00:38:42.940
Let's take a look at the did finish.

00:38:42.980 --> 00:38:45.520
When the notification comes in,
it's easy to obtain the

00:38:45.590 --> 00:38:48.610
query from the notification,
and then you can call your

00:38:48.610 --> 00:38:52.360
own function that will process
the results when you are done.

00:38:52.400 --> 00:38:54.940
I'm not going to cover the
progress notification yet.

00:38:54.960 --> 00:38:57.890
I'm going to come back
to that in a few moments.

00:38:58.660 --> 00:39:00.920
When you actually want
to execute the query,

00:39:00.980 --> 00:39:04.590
this time we're going to pass zero
instead of the synchronous statement.

00:39:04.690 --> 00:39:06.990
So your query will execute,
but your code will continue

00:39:06.990 --> 00:39:08.000
to run in your run loop.

00:39:08.120 --> 00:39:09.670
This code will not block here.

00:39:09.920 --> 00:39:12.880
This will run in the background
and the remainder of your

00:39:13.290 --> 00:39:15.020
code will execute as normal.

00:39:15.070 --> 00:39:18.450
When the results come in,
your notification will be called and then

00:39:18.480 --> 00:39:23.090
your notification could call a routine
that might look something like this.

00:39:23.180 --> 00:39:26.020
Just like with the synchronous case,
we're going to take a

00:39:26.020 --> 00:39:27.340
look at the result count.

00:39:27.380 --> 00:39:31.710
We're going to iterate over all of the
results and pull out whatever fields

00:39:31.900 --> 00:39:34.520
that you find appropriate for that query.

00:39:34.590 --> 00:39:36.220
That's it.

00:39:36.460 --> 00:39:38.160
Let's move to a more advanced query,
though.

00:39:38.160 --> 00:39:39.740
Let's take a look at a live query.

00:39:39.740 --> 00:39:42.600
This is really the most
interesting of them.

00:39:42.790 --> 00:39:45.650
We have to introduce a new notification.

00:39:45.760 --> 00:39:48.710
You're still going to receive
progress notifications as the

00:39:48.710 --> 00:39:50.610
results are initially coming in.

00:39:50.610 --> 00:39:53.290
And you're still going to
get a did finish when the

00:39:53.290 --> 00:39:56.860
initial results are complete,
when the first phase of the query is

00:39:56.860 --> 00:40:01.400
done and you have what's currently
on the disk that matches your query.

00:40:01.520 --> 00:40:05.190
But after that, you will receive did
update notifications.

00:40:05.190 --> 00:40:09.130
And these notifications will let you
know that something's changed on the

00:40:09.130 --> 00:40:13.430
file system and files now match your
query or they've been modified in

00:40:13.430 --> 00:40:17.360
your query or that they no longer
match your query so that you can

00:40:17.360 --> 00:40:19.810
do something live with the results.

00:40:20.910 --> 00:40:23.610
Creating this kind of query is a little
more complicated than the previous,

00:40:23.740 --> 00:40:25.300
but not by much.

00:40:25.330 --> 00:40:27.640
We're going to create the query.

00:40:27.880 --> 00:40:31.640
We're going to register for
our notification callbacks.

00:40:31.710 --> 00:40:34.370
We're going to get the initial
results finished callback,

00:40:34.450 --> 00:40:38.340
which indicates that all the
initial results are done.

00:40:38.420 --> 00:40:41.620
Once they're up, we're actually going
to execute the query.

00:40:41.690 --> 00:40:44.200
We're going to handle
the initial results,

00:40:44.250 --> 00:40:45.800
and then we're going
to listen for updates.

00:40:45.800 --> 00:40:46.550
That's the new step.

00:40:46.650 --> 00:40:49.160
We're going to listen for updates.

00:40:49.230 --> 00:40:51.220
We create the same query we did before.

00:40:51.490 --> 00:40:54.870
We want to find all of
the plain text files.

00:40:55.890 --> 00:40:58.800
We're going to register for a progress
notification because we want to see

00:40:58.800 --> 00:41:01.300
the results as they're coming in.

00:41:01.700 --> 00:41:03.930
We're going to register for
the Did Finish notification

00:41:04.170 --> 00:41:06.760
because we want to know when
the initial results are done,

00:41:06.890 --> 00:41:10.900
when the initial scan of everything
that's already on the disk is complete.

00:41:11.070 --> 00:41:13.510
And then we're going to want
the Did Update notifications

00:41:13.830 --> 00:41:15.180
for the liveness of the query.

00:41:15.470 --> 00:41:19.430
This is telling us what's happened
after the query was done so that

00:41:19.580 --> 00:41:21.880
we can keep up live as it changes.

00:41:22.550 --> 00:41:26.160
The results finished callback looks
very much the same as the previous one.

00:41:26.160 --> 00:41:30.750
We're going to call our handler when
the initial stage of the query is done.

00:41:31.220 --> 00:41:33.370
And then we're going
to execute our query.

00:41:33.510 --> 00:41:37.500
And this time we're going to tell
Spotlight that we want updates.

00:41:37.650 --> 00:41:38.710
This call will not block.

00:41:38.900 --> 00:41:41.270
Your code will continue to
run as you expect it to.

00:41:41.490 --> 00:41:45.680
But now you're going to be getting
your query results as well as updates

00:41:46.130 --> 00:41:48.310
to the query as it progresses.

00:41:48.800 --> 00:41:51.240
You're going to handle the query
results like we did before,

00:41:51.240 --> 00:41:54.120
but notice there's two extra calls.

00:41:54.170 --> 00:41:56.650
We're going to disable
updates at the beginning.

00:41:56.840 --> 00:41:59.190
We're going to look at the
results and then we're going to

00:41:59.190 --> 00:42:00.740
re-enable updates at the bottom.

00:42:00.990 --> 00:42:02.690
This is very, very important.

00:42:02.820 --> 00:42:05.800
When you're looking at these results,
this is a live query.

00:42:06.150 --> 00:42:09.640
And right then,
the user may be changing the file system

00:42:09.640 --> 00:42:15.100
in ways that cause new files to be added
into your results or files to be removed.

00:42:15.240 --> 00:42:18.520
And by disabling updates,
you prevent the results from changing

00:42:18.590 --> 00:42:21.060
while you're looking at them.

00:42:21.060 --> 00:42:23.700
When you're done looking at them,
you would re-enable updates and

00:42:23.700 --> 00:42:26.010
they will continue to come in.

00:42:26.130 --> 00:42:28.350
And if you remember when
I said I would talk about the

00:42:28.350 --> 00:42:32.320
progress notification later,
this is when I want to talk about it.

00:42:32.320 --> 00:42:35.260
Because the progress
notification is called while

00:42:35.260 --> 00:42:38.170
your query is being executed,
more results may be

00:42:38.290 --> 00:42:39.820
coming in at any time.

00:42:39.860 --> 00:42:43.210
So in any progress handler
that you write for synchronous

00:42:43.210 --> 00:42:47.180
or asynchronous or live query,
you should always disable updates

00:42:47.320 --> 00:42:51.140
and enable updates when you're
done if you choose to look at the

00:42:51.140 --> 00:42:53.460
results during the progress update.

00:42:54.750 --> 00:42:59.520
Now, you're going to get your callback
that indicates the query updated.

00:42:59.730 --> 00:43:02.980
Something has changed in
the results of your query.

00:43:03.030 --> 00:43:06.880
When you make the callback,
you can obtain the query from the

00:43:06.880 --> 00:43:11.310
notification and you can take a
look to see what items were added

00:43:11.310 --> 00:43:13.700
into this query result a moment ago.

00:43:13.700 --> 00:43:20.590
For example, a file might have been saved
that suddenly matches your query.

00:43:20.590 --> 00:43:21.130
You'd be notified about
the new added item.

00:43:21.490 --> 00:43:24.020
You can also take a look
at what items changed.

00:43:24.140 --> 00:43:28.420
These are files that used to match
your query and still match your query,

00:43:28.690 --> 00:43:32.080
but something in the file changed
that you might want to take a look at.

00:43:32.200 --> 00:43:33.390
And that would be listed here.

00:43:33.530 --> 00:43:39.190
You could look through this array
and find the list of all of the

00:43:39.190 --> 00:43:39.190
items that actually changed.

00:43:39.280 --> 00:43:42.110
And last, files might have been
removed from your query.

00:43:42.380 --> 00:43:44.640
That is, they no longer match your query.

00:43:44.680 --> 00:43:49.110
As an example, the user updated a file,
but he changed the contents of the

00:43:49.110 --> 00:43:52.700
file in a way that your query is
no longer interested in that file.

00:43:52.770 --> 00:43:56.830
And so you'll be notified that files
have fallen out of your results and

00:43:56.830 --> 00:43:59.350
that are no longer matching your query.

00:44:00.910 --> 00:44:05.190
Now let's move on to the
higher level NS metadata query.

00:44:05.210 --> 00:44:09.850
This is the Cocoa approach instead
of the core foundation approach.

00:44:10.560 --> 00:44:11.540
It has two flavors.

00:44:11.650 --> 00:44:16.040
You can't do a synchronous query here,
but you can do an asynchronous query,

00:44:16.040 --> 00:44:19.500
and you can also do an
asynchronous with updates,

00:44:19.500 --> 00:44:20.620
a live query.

00:44:20.660 --> 00:44:23.290
Let's take a look at how
we're going to do that.

00:44:24.940 --> 00:44:26.940
There's four basic steps.

00:44:26.970 --> 00:44:30.570
We're going to define
and initialize our class.

00:44:30.830 --> 00:44:31.860
This is a little more sophisticated.

00:44:31.860 --> 00:44:34.440
We're using object-oriented programming.

00:44:34.470 --> 00:44:38.780
We're going to listen for notifications
just like we did in the earlier examples.

00:44:38.810 --> 00:44:44.350
We're going to set up
and execute the query,

00:44:44.350 --> 00:44:44.350
and then we're going to
process the query results.

00:44:44.720 --> 00:44:46.090
The defining is pretty straightforward.

00:44:46.100 --> 00:44:49.300
In whatever class you define,
you're probably going to want to

00:44:49.390 --> 00:44:54.900
put an NS Metadata query reference
as part of your class declaration.

00:44:55.990 --> 00:44:57.980
And then in your
constructor for your class,

00:44:57.980 --> 00:45:00.390
in your init method,
you'll do whatever you would

00:45:00.390 --> 00:45:04.700
normally do for your own class,
but you'll create the query object,

00:45:04.770 --> 00:45:07.400
you'll set up the notifications,
and in this case,

00:45:07.400 --> 00:45:10.940
we're going to listen to the
gathering progress notification.

00:45:11.190 --> 00:45:13.870
This is the notification you
get while the results are

00:45:14.100 --> 00:45:15.860
being gathered incrementally.

00:45:16.080 --> 00:45:19.280
And you can also register for the
Did Finish notification because

00:45:19.280 --> 00:45:23.030
you're going to want to know
when those results are complete.

00:45:24.090 --> 00:45:26.670
Now we've set things up,
we have to actually

00:45:26.670 --> 00:45:28.240
provide the notification.

00:45:28.330 --> 00:45:32.010
This is a simple handling for
the did finish notification.

00:45:32.160 --> 00:45:34.620
Now notice we have to do
something a little different here.

00:45:34.850 --> 00:45:37.830
When we're told that our
initial query is complete,

00:45:37.880 --> 00:45:39.700
we need to stop the query.

00:45:39.820 --> 00:45:41.410
Otherwise,
this is going to be a live query

00:45:41.410 --> 00:45:42.590
and it's going to continue.

00:45:42.590 --> 00:45:45.880
But by stopping it here,
we've done an asynchronous query that

00:45:46.190 --> 00:45:48.500
completes when your results are gathered.

00:45:48.640 --> 00:45:51.160
And when the results are available,
you'll notify yourself with

00:45:51.240 --> 00:45:52.620
the query did finish method.

00:45:54.570 --> 00:45:57.680
Now we're going to actually
prepare the search itself.

00:45:57.750 --> 00:45:59.860
We need to set up sort descriptors.

00:45:59.940 --> 00:46:01.810
And what sort descriptors
tell the system is,

00:46:01.810 --> 00:46:05.580
"I'm going to get a lot of results back,
but I want them sorted in a particular

00:46:05.580 --> 00:46:09.300
order," which is actually very
convenient because it eliminates

00:46:09.300 --> 00:46:11.640
the need for you to have to sort.

00:46:11.980 --> 00:46:14.140
They're going to come
back in a specific order.

00:46:14.160 --> 00:46:16.290
In this particular case,
we're going to sort by

00:46:16.290 --> 00:46:17.930
the item display name.

00:46:18.050 --> 00:46:20.090
You can sort by as many
fields as you want,

00:46:20.090 --> 00:46:23.320
and they'll be sorted and
sub-sorted as appropriate.

00:46:23.440 --> 00:46:24.950
Then you're going to set your predicate.

00:46:24.950 --> 00:46:26.080
That's your search term.

00:46:26.190 --> 00:46:28.930
And in this particular case,
we're going to search for any

00:46:28.930 --> 00:46:30.800
kind of image on the system.

00:46:30.910 --> 00:46:34.620
Now, this uses NSPredicate,
which is very similar to the

00:46:34.620 --> 00:46:37.830
Spotlight query language,
but it's not quite identical.

00:46:37.970 --> 00:46:41.530
You're going to want to take a look at
the NSPredicate documentation to see

00:46:41.530 --> 00:46:44.320
the differences in the query syntax.

00:46:44.440 --> 00:46:47.740
And then we're actually
going to start the query.

00:46:48.470 --> 00:46:52.930
Now, when the results come back and
your call is activated to indicate

00:46:52.930 --> 00:46:56.490
that the results are complete,
just like before,

00:46:56.490 --> 00:46:59.900
you can get the result count,
iterate over the results,

00:46:59.970 --> 00:47:04.040
and pull out whatever attributes
for each file are important for you.

00:47:04.110 --> 00:47:07.730
In this example,
we're going to pull out the display name

00:47:07.730 --> 00:47:10.470
for every file that matches our query.

00:47:12.100 --> 00:47:14.480
Now let's move on to a live query.

00:47:14.780 --> 00:47:16.530
It's very similar.

00:47:16.650 --> 00:47:19.840
The only difference is that we're
going to be listening to updates.

00:47:19.900 --> 00:47:23.240
We're going to define and initialize
our class in the same way.

00:47:23.350 --> 00:47:25.630
We're going to do a
results finish callback.

00:47:25.810 --> 00:47:28.120
We're going to actually
execute the query,

00:47:28.570 --> 00:47:31.270
process our results,
and then we're going to go into a mode

00:47:31.270 --> 00:47:33.820
where we're listening for these updates.

00:47:34.110 --> 00:47:38.430
We define the class exactly the same:
Provide an NS Metadata query

00:47:38.590 --> 00:47:41.100
in and amongst your own fields.

00:47:41.220 --> 00:47:44.430
We're going to set up
the class the same way.

00:47:44.670 --> 00:47:46.880
We're going to ask for
the same notifications,

00:47:47.070 --> 00:47:49.880
the progress, the did finish.

00:47:49.910 --> 00:47:51.640
We're going to add in a new notification.

00:47:51.640 --> 00:47:55.090
We want to get the did update
notification that lets you know

00:47:55.160 --> 00:47:58.610
that something's changed and
your query should be updated.

00:47:59.730 --> 00:48:01.980
When we get our progress,
when we get our "Did

00:48:01.980 --> 00:48:05.100
Finish" notification,
there's an important change here:

00:48:05.260 --> 00:48:07.000
don't stop the query.

00:48:07.120 --> 00:48:09.280
If you stop the query,
you've made this into a

00:48:09.280 --> 00:48:10.760
simple asynchronous query.

00:48:10.860 --> 00:48:13.530
We want this to be live,
so if you don't stop it here,

00:48:13.590 --> 00:48:15.950
it will just naturally
become a live query,

00:48:16.010 --> 00:48:21.230
and you will receive the updates as
you expect as the file system changes.

00:48:22.100 --> 00:48:23.170
It gets the same way.

00:48:23.430 --> 00:48:28.710
We're going to look for all images,
and then we're going to start our query.

00:48:29.640 --> 00:48:34.070
Now, because this is a live query,
we're going to want to disable

00:48:34.070 --> 00:48:36.600
updates when the results are complete.

00:48:36.740 --> 00:48:40.430
Otherwise, the results might be changing
out from under us and lead

00:48:40.430 --> 00:48:42.260
to very unexpected results.

00:48:42.390 --> 00:48:46.100
So we're going to disable the updates,
and then we're going to iterate

00:48:46.110 --> 00:48:47.890
over each result returned.

00:48:48.000 --> 00:48:49.880
And in this case,
we're going to pull out the display

00:48:49.880 --> 00:48:51.480
name attribute from each file.

00:48:51.740 --> 00:48:54.900
You can pull out, of course,
any attribute that's interesting

00:48:54.900 --> 00:48:56.640
to you or useful for your query.

00:48:56.720 --> 00:48:58.940
And then when we're done
looking at the results,

00:48:59.000 --> 00:49:03.930
we're going to re-enable the updates so
that they can continue to be monitored.

00:49:04.420 --> 00:49:08.650
Now, when the updates come in,
you're going to be notified through

00:49:08.730 --> 00:49:11.190
the query update notification.

00:49:11.300 --> 00:49:16.100
But unlike the lower level MD Query Ref,
you can't find out directly

00:49:16.100 --> 00:49:18.860
which files were added,
removed, or changed.

00:49:19.000 --> 00:49:24.390
You simply know that files were changed
and you should re-look at the results.

00:49:24.800 --> 00:49:26.760
When you do things higher level in Cocoa,
though,

00:49:26.760 --> 00:49:31.770
because of the way you can do KVO stuff,
Key Value Observer,

00:49:31.890 --> 00:49:35.240
you can have the results
automatically update screen widgets,

00:49:35.300 --> 00:49:38.050
et cetera,
and Kaelin will show an example

00:49:38.050 --> 00:49:39.900
of that in a few minutes.

00:49:41.390 --> 00:49:44.460
Now, when you do your queries,
there's a lot that you can do to

00:49:44.460 --> 00:49:48.010
make them run significantly faster.

00:49:48.100 --> 00:51:28.800
[Transcript missing]

00:51:30.470 --> 00:51:35.160
We also can dramatically increase
the performance of the query if

00:51:35.160 --> 00:51:39.500
we fetch the attributes with the
query and we do the sorting for you.

00:51:39.570 --> 00:51:43.060
If you recall when we created the query,
the last field was null

00:51:43.060 --> 00:51:44.590
when we create the query.

00:51:44.600 --> 00:51:47.110
We had a query string,
but we didn't specify

00:51:47.180 --> 00:51:48.600
the last possible value.

00:51:48.920 --> 00:51:51.250
That are sorting attributes.

00:51:51.490 --> 00:51:54.340
And in this particular case,
we're going to provide an array to

00:51:54.340 --> 00:51:59.050
say that we want to sort our results
by the title and then sub-sort

00:51:59.120 --> 00:52:01.660
the results by the display name.

00:52:01.730 --> 00:52:03.690
This has two benefits.

00:52:03.810 --> 00:52:06.880
Spotlight will return the results
to you already sorted in the

00:52:06.890 --> 00:52:08.860
way that you want it sorted.

00:52:08.940 --> 00:52:13.960
And those two attributes will be
returned directly with your query.

00:52:14.060 --> 00:52:18.280
When you ask for information
about the returned items,

00:52:18.420 --> 00:52:21.360
those two fields will
already be available to you,

00:52:21.470 --> 00:52:25.170
making it significantly faster for
you to actually get the attributes

00:52:25.650 --> 00:52:26.880
for what you're looking up.

00:52:27.130 --> 00:52:27.520
If you don't specify it,
you're not going to get the attributes.

00:52:27.520 --> 00:52:30.380
If you don't specify a sorting
order and you ask for an

00:52:30.450 --> 00:52:33.450
attribute for a returned item,
that will require a

00:52:33.450 --> 00:52:36.380
round trip to the server,
which adds quite a bit

00:52:36.380 --> 00:52:38.120
of expense to your query.

00:52:38.120 --> 00:52:41.020
Now we're going to see how
we take advantage of that.

00:52:41.020 --> 00:52:46.020
When you're fetching your attributes,
if you recall, we got the result count.

00:52:46.020 --> 00:52:50.720
And then we iterated over every result,
taking a look at the empty item,

00:52:50.930 --> 00:52:54.140
and then asking that empty
item for a specific attribute.

00:52:54.280 --> 00:52:56.580
In this case,
we're asking for the display name.

00:52:56.740 --> 00:53:00.180
Now this is slow because it
makes a round trip display name.

00:53:00.330 --> 00:53:05.680
What I'm going to recommend you do is
if you've specified sorting attributes,

00:53:05.840 --> 00:53:08.020
you get the attributes this way.

00:53:08.200 --> 00:53:13.820
Taking the query, you say you want the
display name for each item,

00:53:13.960 --> 00:53:17.730
and we will directly give you the
display name that has been prefetched.

00:53:17.920 --> 00:53:22.030
This is a significant optimization
for how fast you can get

00:53:22.030 --> 00:53:24.220
results for your queries.

00:53:24.330 --> 00:53:25.630
Now we're going to
take a look at Katelyn.

00:53:25.640 --> 00:53:30.200
will have a demo for us of
writing code to do a live query.

00:53:31.870 --> 00:53:34.300
Okay, so you'll recall our
Fortunes application.

00:53:34.300 --> 00:53:38.550
Let's take a look and see how
we've actually implemented that.

00:53:38.880 --> 00:53:43.100
We started with a simple
Cocoa project template,

00:53:43.350 --> 00:53:47.940
and you can see here we've got a--
our main window with a table view and

00:53:47.940 --> 00:53:49.800
a nice little search control here.

00:53:49.970 --> 00:53:54.990
So the--the way this application
works is we actually run-- when the

00:53:55.060 --> 00:53:59.360
application is launched a Spotlight query
that finds all of the Fortune files,

00:53:59.380 --> 00:54:01.680
gathers all their display names,
and then we just plot

00:54:01.770 --> 00:54:05.870
that into the table view,
and we take advantage of NS Metadata

00:54:05.870 --> 00:54:10.680
Query Class's key value observation
compliance to be able to wire all this up

00:54:10.700 --> 00:54:12.750
with Cocoa bindings and very little code.

00:54:12.880 --> 00:54:16.660
So let's take a look at what--
what's actually involved there.

00:54:16.940 --> 00:54:21.010
First thing we'll look at is
our Fortunes App Delegate class.

00:54:21.270 --> 00:54:25.390
So in typical Cocoa fashion,
all of our code for this application

00:54:25.400 --> 00:54:29.440
really just lives in the applications
delegate that we've written here.

00:54:29.580 --> 00:54:32.680
And if we pop open the delegate,
we can see here it's got a

00:54:32.680 --> 00:54:39.750
slot for the NSMetadata query,
which is the Cocoa version of a

00:54:39.750 --> 00:54:44.140
query class that Andy outlined
in the second part of his slides.

00:54:44.240 --> 00:54:48.830
We also have an IB outlet here for
wiring up the search control to a

00:54:48.830 --> 00:54:51.140
search string so our code can get at it.

00:54:51.320 --> 00:54:54.640
And we have an IB outlet for
getting at the table view.

00:54:54.640 --> 00:54:58.440
So it's really a pretty
simple application delegate.

00:54:58.640 --> 00:55:01.280
There's a little more work
to setting up the nib,

00:55:01.280 --> 00:55:03.910
and some of it's a little
bit less intuitive.

00:55:04.210 --> 00:55:09.580
But basically, to make bindings work
with an NSMetadata query,

00:55:09.700 --> 00:55:14.140
what you want to do is set up an array
controller to contain the results.

00:55:14.140 --> 00:55:18.820
So what we've done here
is actually dropped an

00:55:18.820 --> 00:55:24.380
NSArray controller into our nib file,
and we've set up a little bit of a code

00:55:24.880 --> 00:55:30.500
: So, we set its mode to be class, which,
when the object is reconstituted

00:55:30.500 --> 00:55:33.430
and instantiated from the nib,
basically configures it to display

00:55:33.430 --> 00:55:35.300
objects of a particular class.

00:55:35.300 --> 00:55:37.800
And we set the class to NSMetadataItem.

00:55:37.890 --> 00:55:41.370
So, NSMetadataItem is each result
from an NSMetadata query

00:55:41.370 --> 00:55:43.300
gives you an NSMetadataItem.

00:55:43.300 --> 00:55:46.590
And the other really nice thing we
can do to facilitate key-value binding

00:55:46.860 --> 00:55:50.910
is to come down here and just add
individual keys for the attributes

00:55:51.000 --> 00:55:53.300
that we want to be able to bind to.

00:55:53.300 --> 00:55:55.290
So,
you can see here I've pre-populated this

00:55:55.440 --> 00:56:00.400
with keys for our com example fortune
ID attribute that we defined and also

00:56:00.400 --> 00:56:03.800
KMDItemTimeStamp and KMDItemDisplayName.

00:56:03.800 --> 00:56:07.370
We use the timestamp for sorting and
the display name is what we actually

00:56:07.450 --> 00:56:09.400
want to populate the table view with.

00:56:09.610 --> 00:56:13.170
Switching over to look at the bindings,
we can see that the content

00:56:13.170 --> 00:56:18.740
array for this particular array
controller is bound to query.results.

00:56:18.860 --> 00:56:22.170
So that key path
basically is going to go--

00:56:22.280 --> 00:56:27.580
Back to our app delegate,
find the query attribute that

00:56:27.580 --> 00:56:31.660
we were looking at and then
bind to its results path.

00:56:31.690 --> 00:56:35.440
And sort of through the magic of KVO,
as our live query executes

00:56:35.440 --> 00:56:37.860
and new results come in,
these bindings will fire,

00:56:37.860 --> 00:56:40.560
the array controller will update,
and that internal update our UI,

00:56:40.560 --> 00:56:44.430
all without us writing any
code to explicitly do that.

00:56:44.810 --> 00:56:51.050
And then the other thing we do is we have
the table column actually referencing

00:56:51.050 --> 00:56:56.310
this same array controller to get values
for each of the table column cells.

00:56:57.590 --> 00:57:02.540
So now, let's, without further ado,
get to the code.

00:57:02.540 --> 00:57:05.110
The actual app delegate

00:57:06.720 --> 00:57:10.860
is also pretty simple.

00:57:10.860 --> 00:57:15.660
In our initialization method,
we go ahead and allocate an NS metadata

00:57:15.660 --> 00:57:17.990
query and bind that to ourself.

00:57:17.990 --> 00:57:23.060
And then we prepare the query by
setting an array of sort descriptors.

00:57:23.060 --> 00:57:27.670
So if you're familiar with Core Data,
this is exactly the same

00:57:27.670 --> 00:57:31.890
sort descriptor class that
Core Data uses in its infrastructure.

00:57:31.970 --> 00:57:35.240
And we basically,
we create an array of these

00:57:35.630 --> 00:57:38.850
and set it up so that our query
results will be returned to us

00:57:38.850 --> 00:57:42.020
sorted first by the timestamp,
then by the display name,

00:57:42.040 --> 00:57:43.340
then by the Fortune ID.

00:57:43.430 --> 00:57:46.730
Now, as Andy was alluding earlier,
this has the side effect of also

00:57:46.730 --> 00:57:52.010
configuring the framework so that as
results are fetched from the live query,

00:57:52.050 --> 00:57:55.180
these attribute values also come
back with the results without an

00:57:55.180 --> 00:57:57.960
additional round trip to the server.

00:58:00.190 --> 00:58:04.270
Looking at how we actually
start the query running,

00:58:04.270 --> 00:58:07.380
we have a convenience method
here because we call it from

00:58:07.380 --> 00:58:08.900
a couple of different places.

00:58:08.900 --> 00:58:11.200
I named it Reset Query Predicate.

00:58:11.360 --> 00:58:13.910
Basically,
we start out with a simple predicate

00:58:14.090 --> 00:58:19.350
that will search for all items
in Spotlight with a content type

00:58:19.430 --> 00:58:21.500
of com example fortune cookie.

00:58:21.660 --> 00:58:25.860
So what this gets us is, by default,
a simple predicate,

00:58:25.870 --> 00:58:29.290
or a simple query predicate,
that finds all the fortune cookies

00:58:29.290 --> 00:58:33.890
on all of our attached local storage
and displays those in our table view.

00:58:34.080 --> 00:58:36.950
Now,
if the search string's been filled in

00:58:37.080 --> 00:58:40.690
through the interface builder binding
that we looked at in the nib file,

00:58:40.690 --> 00:58:42.840
we actually build a
more complex predicate,

00:58:42.840 --> 00:58:47.630
a compound predicate that has
a sub-predicate of KMDItem

00:58:47.630 --> 00:58:51.960
text content like case,
diacritic, insensitive,

00:58:52.250 --> 00:58:56.830
whatever the user's entered search
string was with an asterisk appended.

00:58:56.980 --> 00:59:00.230
So basically what we're asking
Spotlight for is a case,

00:59:00.230 --> 00:59:04.980
diacritic, insensitive,
and word-matching prefix search.

00:59:05.160 --> 00:59:09.730
This is the same kind of search that the
finder and the search menu do by default,

00:59:09.730 --> 00:59:12.310
and it's what users will
typically expect to see if your

00:59:12.310 --> 00:59:14.380
application has a search field.

00:59:14.550 --> 00:59:16.750
Now,
this is a simple version of this in a

00:59:16.750 --> 00:59:21.680
more complex application with more rich
types of metadata about the content.

00:59:21.680 --> 00:59:25.100
You might have other options as well,
but this is kind of a good example

00:59:25.330 --> 00:59:26.840
of setting up a default search.

00:59:26.910 --> 00:59:31.050
Again, if the user has provided
a search predicate,

00:59:31.200 --> 00:59:34.430
we go ahead and create a
compound predicate just by anding

00:59:34.430 --> 00:59:35.960
together these two predicates.

00:59:36.080 --> 00:59:39.000
And then one way or another,
we set the query's predicate and

00:59:39.000 --> 00:59:42.600
we start the query to running.

00:59:43.100 --> 01:01:07.000
[Transcript missing]

01:01:07.310 --> 01:01:10.440
Now, to demonstrate that this is
actually a live search going on,

01:01:10.440 --> 01:01:12.700
let's do a...

01:01:13.420 --> 01:01:18.280
Search that doesn't have any matches,
and then we'll flip to the finder,

01:01:18.280 --> 01:01:22.850
and I've actually got a fortune on my
disk that does have that text in it,

01:01:22.910 --> 01:01:25.050
but it's got the wrong
extension right now.

01:01:25.290 --> 01:01:27.180
So this sort of...

01:01:27.720 --> 01:01:31.440
helps drive home the significance of how
the UTIs and extensions and everything

01:01:31.440 --> 01:01:33.140
map into the Spotlight infrastructure.

01:01:33.330 --> 01:01:36.600
You'll see when we come into the Finder
and change the extension on this file,

01:01:36.680 --> 01:01:38.660
Finder pops up this dialog.

01:01:38.730 --> 01:01:41.360
Now, one of the reasons that it's
doing this is we're actually

01:01:41.750 --> 01:01:44.660
switching the UTI definition,
and that's gonna have side effects.

01:01:44.780 --> 01:01:46.600
For one thing,
it's gonna cause the importer

01:01:46.600 --> 01:01:49.800
that we wrote in our first demo
to be executed on this file

01:01:50.100 --> 01:01:52.300
because it's now a different UTI.

01:01:52.450 --> 01:01:55.180
So we'll go ahead and click Use Fortune.

01:01:56.130 --> 01:01:58.600
And when we do that,
if we bring our app back to the front,

01:01:58.630 --> 01:02:02.870
you see the importer ran,
the plugin imported all the

01:02:02.880 --> 01:02:04.540
metadata that we had defined.

01:02:04.590 --> 01:02:07.150
It pushed that into Spotlight.

01:02:07.410 --> 01:02:11.030
That new data, that new item,
now matches the live query

01:02:11.030 --> 01:02:12.400
that we have executing.

01:02:12.490 --> 01:02:16.300
So those results get sent to us,
and KVO populates it into our table view,

01:02:16.300 --> 01:02:20.980
and it all just kind of happens,
which is pretty cool.

01:02:21.240 --> 01:02:23.960
And that concludes our second demo.

01:02:24.020 --> 01:02:25.530
Thank you.

01:02:28.890 --> 01:02:31.920
Thank you, Kaelin.

01:02:31.920 --> 01:02:35.150
Using Spotlight, you can really add a lot
to your applications.

01:02:35.230 --> 01:02:38.360
You can help your users find your data,
which they're going to

01:02:38.360 --> 01:02:41.430
really want to be able to do,
especially if they've got a lot of it,

01:02:41.540 --> 01:02:45.890
and you'll be able to have your
application use the power of the search

01:02:45.930 --> 01:02:50.570
capability of Spotlight to help your
users find their data or other data

01:02:50.570 --> 01:02:53.560
that's beneficial to your application.

01:02:53.620 --> 01:02:57.570
I want to stress again the importance
of testing it three-way universal.

01:02:57.810 --> 01:02:59.140
Test it against PowerPC.

01:02:59.740 --> 01:03:01.730
Test it against Intel 32-bit.

01:03:01.960 --> 01:03:04.800
And please test it against Intel 64-bit.

01:03:04.950 --> 01:03:06.310
And test the hell out of it.

01:03:06.410 --> 01:03:07.790
Test performance.

01:03:07.900 --> 01:03:09.090
Test that it's stable.

01:03:09.390 --> 01:03:13.700
Make sure that your user's going to have
a good experience importing your data.

01:03:13.800 --> 01:03:17.380
And consider adding more Spotlight
searches to your applications.

01:03:17.380 --> 01:03:19.600
Your users can really benefit from it.

01:03:19.700 --> 01:03:22.090
We're going to have a lab today at 5:00.

01:03:22.180 --> 01:03:25.800
And if anybody has any questions,
about how to import files

01:03:25.800 --> 01:03:28.030
or how to do queries,
I want to encourage everyone

01:03:28.080 --> 01:03:29.440
to come down to the lab.

01:03:29.440 --> 01:03:32.990
Lots of times at these labs,
people have left with fully functional

01:03:32.990 --> 01:03:35.140
importers ready to go for their data.

01:03:35.140 --> 01:03:37.700
So if you have that kind
of work you need to do,

01:03:37.700 --> 01:03:38.710
come on down and talk to us.

01:03:38.830 --> 01:03:41.430
We would really love to see you.

01:03:41.640 --> 01:03:44.500
If you need more information,
this is the contact

01:03:44.530 --> 01:03:48.470
information for our evangelist,
as well as a pointer

01:03:48.520 --> 01:03:50.620
to our documentation.

01:03:50.770 --> 01:03:54.780
If you go to developer.apple.com
and search for Spotlight

01:03:54.780 --> 01:03:59.230
overview or UTI information,
you'll find the links that you need

01:03:59.580 --> 01:04:02.740
to develop applications for Spotlight.

01:04:02.880 --> 01:04:06.430
Other sessions, which probably have
already happened by now,

01:04:06.430 --> 01:04:10.690
but you'll be able to see on the DVD that
you're going to get for attending,

01:04:10.820 --> 01:04:12.600
these other things may help.

01:04:12.680 --> 01:04:16.100
Using Quick Look,
how to use the file system efficiently,

01:04:16.160 --> 01:04:19.320
and as well, of course,
an encouragement to come to our lab.
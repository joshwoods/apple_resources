WEBVTT

00:00:21.690 --> 00:00:24.400
Good afternoon, everyone.

00:00:24.440 --> 00:00:28.310
Welcome to session 381,
Core Data Tips and Tricks.

00:00:28.700 --> 00:00:29.800
My name is Miguel Sanchez.

00:00:29.800 --> 00:00:32.060
I'm an engineer in the Core Data team.

00:00:32.080 --> 00:00:34.980
This is the middle chapter of
the Core Data trilogy that we

00:00:35.110 --> 00:00:37.830
have prepared for you guys.

00:00:37.840 --> 00:00:39.270
This is the second session.

00:00:39.440 --> 00:00:42.550
I must warn you,
we will end in the cliffhanger.

00:00:43.700 --> 00:00:46.840
So the purpose of this session is for
you to gain a deeper understanding

00:00:46.840 --> 00:00:48.560
of Core Data technologies.

00:00:48.740 --> 00:00:52.210
I'm going to go over some best
practices that we'd like you to follow.

00:00:52.280 --> 00:00:55.240
I'm going to be paying particular
emphasis on optimization and

00:00:55.240 --> 00:00:57.520
performance issues within Core Data.

00:00:57.520 --> 00:01:01.680
I'm also assuming that most of you
have some Core Data experience.

00:01:01.680 --> 00:01:05.670
Can I get a show of hands who does
not have Core Data experience?

00:01:05.840 --> 00:01:09.080
Okay, those people that don't have
a lot of Core Data experience,

00:01:09.130 --> 00:01:11.160
it's still a good session
for you guys to listen to.

00:01:11.160 --> 00:01:15.190
There's a lot of good content
that you will get out of it.

00:01:15.220 --> 00:01:16.750
I'm just not going to
cover all the basics.

00:01:16.820 --> 00:01:19.970
And finally,
the content that I'll be talking

00:01:19.970 --> 00:01:21.960
about is Leopard content.

00:01:21.960 --> 00:01:25.480
So this is all applicable to
what's already shipping and you

00:01:25.480 --> 00:01:27.380
have had since last October.

00:01:28.970 --> 00:01:30.660
This is our roadmap.

00:01:30.720 --> 00:01:33.540
We'll be spending some time looking
at fetching behind the scenes,

00:01:33.600 --> 00:01:36.500
how you can optimize that.

00:01:36.520 --> 00:01:40.630
Then going to a little bit of
debugging and performance analysis,

00:01:40.700 --> 00:01:45.220
advanced property modeling that
will lead us into migration,

00:01:45.230 --> 00:01:49.690
Leopard migration,
and we'll finalize with multi-threading.

00:01:52.490 --> 00:01:55.470
Let's start out with fetching.

00:01:55.720 --> 00:01:59.690
By the way, the counter is not going.

00:02:04.060 --> 00:02:08.260
So fetching-- thank you.

00:02:08.880 --> 00:02:11.840
I hope everybody in this room
is already aware of the speed

00:02:11.850 --> 00:02:15.960
difference between fetching
something from MyO versus memory.

00:02:15.960 --> 00:02:18.900
So as your code data
application is going along,

00:02:18.900 --> 00:02:23.440
it's requesting information,
requesting fetches.

00:02:23.440 --> 00:02:27.480
Some of those will be serviced by
data that you have already in memory.

00:02:27.580 --> 00:02:31.880
And some of the other fetches will
have to go to disk to get them.

00:02:31.880 --> 00:02:36.200
So be aware that there's a huge speed
barrier between those two worlds.

00:02:36.360 --> 00:02:40.340
When you're in the memory side of things,
we're measuring things in nanoseconds.

00:02:40.440 --> 00:02:42.690
When we go to disk,
we're now using milliseconds

00:02:42.700 --> 00:02:44.190
as a unit of measure.

00:02:44.300 --> 00:02:47.560
That's a sixth order of
magnitude difference.

00:02:47.670 --> 00:02:49.780
It's actually not a million times slower.

00:02:49.780 --> 00:02:50.980
It's more in the thousands.

00:02:50.980 --> 00:02:53.960
We're measuring gigabytes
versus terabyte accesses.

00:02:53.960 --> 00:02:56.060
But it's still a very
important difference here.

00:02:56.060 --> 00:02:59.390
A thousandth time slower
by having hit the disk.

00:02:59.490 --> 00:03:04.130
So it's very important for you guys to
realize and to be aware of where that

00:03:04.230 --> 00:03:09.430
data is coming from and only fetch the
things that you absolutely need to fetch.

00:03:10.630 --> 00:03:15.990
Now, Core Data already does a lot behind
the scenes so that you don't have

00:03:16.090 --> 00:03:17.110
to worry too much about this.

00:03:17.190 --> 00:03:20.620
For example, as you know,
we don't bring in all of your object

00:03:20.630 --> 00:03:22.420
graph when you instantiate your database.

00:03:22.420 --> 00:03:26.360
We simply bring in the main
objects you initially requested,

00:03:26.440 --> 00:03:29.850
and if those have relationships,
we treat the destination

00:03:29.870 --> 00:03:31.310
objects as faults.

00:03:31.400 --> 00:03:34.940
So those are like thin shells of
objects which are not fully populated,

00:03:35.360 --> 00:03:39.180
and we only fetch them from
disk as you actually touch those

00:03:39.180 --> 00:03:40.640
objects and request information.

00:03:40.660 --> 00:03:42.900
So we're not pulling in
the whole object graph.

00:03:44.350 --> 00:03:47.970
One thing you might not be aware
of is that behind the scenes,

00:03:47.970 --> 00:03:52.790
we are keeping a raw cache with entries
with all of your object information.

00:03:52.850 --> 00:03:55.600
So here's the raw cache,
here's my fully instantiated person,

00:03:55.600 --> 00:03:58.240
and there are the fields
for the person entity.

00:03:58.440 --> 00:04:01.890
So when you trigger a fault,

00:04:02.820 --> 00:04:06.960
We go to the database and we
populate the raw cache and then we

00:04:06.960 --> 00:04:10.890
fully realize your faulted object.

00:04:11.470 --> 00:04:15.480
But you must not equate firing
a fault with accessing disk.

00:04:15.700 --> 00:04:17.250
It's not the same thing.

00:04:17.590 --> 00:04:21.260
Triggering a fault means simply that
we're going to fully realize your object,

00:04:21.340 --> 00:04:24.000
but we could potentially find
the information that we need

00:04:24.040 --> 00:04:25.570
in the raw cache already.

00:04:25.650 --> 00:04:29.630
This is because that information
was prefetched somehow.

00:04:29.710 --> 00:04:33.910
It was fetched by another context,
or maybe you even fetched it already in

00:04:33.910 --> 00:04:37.570
the code that you're in where you had
returned your object back into a fault.

00:04:37.710 --> 00:04:43.070
So don't think that firing a
fault always goes into disk.

00:04:43.870 --> 00:04:48.840
The keys for you to control how fetching
happens is through the Fetch Request API.

00:04:48.840 --> 00:04:52.750
At a high level, you have an entity and a
predicate that you're giving us.

00:04:52.750 --> 00:04:55.940
But remember that you have a lot
of tweaking that you can do within

00:04:56.050 --> 00:04:57.620
the Fetch Request that you create.

00:04:57.630 --> 00:05:02.240
You can tell us whether you want us to
return full objects or just the IDs.

00:05:02.240 --> 00:05:06.660
Do you want us to populate that
row cache that I mentioned or not?

00:05:06.770 --> 00:05:08.400
Do you want us to
pre-fetch relationships?

00:05:08.400 --> 00:05:10.480
Stop after a certain limit?

00:05:12.060 --> 00:05:14.900
So let's just walk through each
one of these specific cases and how

00:05:14.900 --> 00:05:16.280
you would optimize your fetching.

00:05:18.190 --> 00:05:22.240
The absolutely most optimal fetching
that you can potentially do going to

00:05:22.240 --> 00:05:27.250
disk is when you simply want to get
back the count of a fetch request.

00:05:27.260 --> 00:05:32.800
So we have API on NSManagedObjectContext
where you pass out a fetch request

00:05:32.840 --> 00:05:39.060
and we simply bring back the count of
whatever was resulted in the database.

00:05:39.060 --> 00:05:42.180
So we don't create any IDs,
no instance creation,

00:05:42.180 --> 00:05:45.040
no populating of the row caches, entries.

00:05:46.120 --> 00:05:50.200
The second level up is if you only
want us to give you the object IDs.

00:05:50.200 --> 00:05:54.220
If this is what you want,
by default we give you back full objects.

00:05:54.220 --> 00:05:58.750
If you only want object IDs,
you can use the set result type in

00:05:58.870 --> 00:06:03.650
NSFetchRequest and you set the result
type to be NSManagedObjectID result type.

00:06:05.660 --> 00:06:08.100
Now,
why would you only want to get back IDs?

00:06:08.140 --> 00:06:10.310
There's a lot of things
that you can do with IDs.

00:06:10.360 --> 00:06:13.950
You might be doing a simple
membership comparison,

00:06:13.950 --> 00:06:15.700
where you don't need the full object.

00:06:15.740 --> 00:06:17.580
It's not an object-to-object
comparison there.

00:06:17.580 --> 00:06:20.360
You're simply checking whether
something belongs into a set,

00:06:20.360 --> 00:06:23.400
and that set could have come from
a relationship or somewhere else.

00:06:23.480 --> 00:06:26.280
So you might not need the full
ID to answer the question that

00:06:26.280 --> 00:06:29.790
you-- the full object to answer
the question that you need.

00:06:31.870 --> 00:06:34.550
Now,
one important thing to realize is that

00:06:34.610 --> 00:06:40.590
I just mentioned that we were going to
get object IDs in the previous slide.

00:06:40.590 --> 00:06:44.840
The fact that you requested only
object IDs in your fetch request

00:06:44.840 --> 00:06:49.140
does not imply that we did not
populate your raw cache entry.

00:06:49.140 --> 00:06:52.060
So we do populate the raw cache entries,
even though you only

00:06:52.060 --> 00:06:53.470
request the object IDs.

00:06:55.280 --> 00:06:58.540
The one thing we don't do is we don't
fully realize your objects for you,

00:06:58.610 --> 00:07:00.590
but the raw cache entries
are still populated.

00:07:00.590 --> 00:07:05.860
So if you want to avoid that step,
you also have to tell us to not

00:07:06.080 --> 00:07:08.400
include the property values.

00:07:09.070 --> 00:07:11.880
So the default is to include the
property values in the raw cache,

00:07:11.880 --> 00:07:14.590
and you have to tell us to not do that,
and then we would only give

00:07:14.590 --> 00:07:15.940
you back the object IDs.

00:07:15.940 --> 00:07:20.150
So these two things are orthogonal,
object IDs with populating the raw cache.

00:07:22.540 --> 00:07:25.540
Moving on,
you want to prefetch your data.

00:07:25.600 --> 00:07:28.820
Let's say that you're in a
situation where you're fetching

00:07:28.820 --> 00:07:30.880
in people of a person entity.

00:07:30.930 --> 00:07:33.180
And you know that every
time you access a person,

00:07:33.180 --> 00:07:39.020
you will always be accessing the
address information for that person.

00:07:39.120 --> 00:07:42.520
So you don't want to be triggering
a fault individually and incurring

00:07:42.520 --> 00:07:44.610
multiple trips to the database.

00:07:44.710 --> 00:07:47.240
You want to give us the hint
that you're going to be accessing

00:07:47.270 --> 00:07:51.580
that information right away,
so why don't we do something about it?

00:07:51.640 --> 00:07:55.020
So if you tell us to prefetch
the address relationship when

00:07:55.020 --> 00:07:57.700
you specify the fetch request,
what we would do is we would

00:07:57.700 --> 00:07:59.800
reduce your fetches down to two.

00:07:59.860 --> 00:08:02.500
We would do the initial fetch
to get all the people that you

00:08:02.570 --> 00:08:04.840
requested in your fetch request.

00:08:04.880 --> 00:08:08.670
Then we collect all of the object
IDs for the related objects.

00:08:08.910 --> 00:08:11.930
And then in a single fetch,
we go to the database and pull in

00:08:11.930 --> 00:08:13.530
all of the address information.

00:08:13.540 --> 00:08:18.800
So now you only have two database access
rather than triggering a database access

00:08:18.800 --> 00:08:23.620
each time you're going and each time
you're touching an address object.

00:08:23.640 --> 00:08:25.610
Notice that we're not
creating address objects.

00:08:25.680 --> 00:08:29.860
We're simply bringing in the prefetch,
the row cache entries,

00:08:29.860 --> 00:08:33.160
and then we're still
creating faults for you.

00:08:33.170 --> 00:08:36.160
But then later on during the
execution of your application,

00:08:36.160 --> 00:08:39.670
when you actually touch that
object and the fault is converted

00:08:39.700 --> 00:08:43.360
into a fully realized object,
you won't be crossing

00:08:43.420 --> 00:08:45.080
the threshold of I/O.

00:08:45.320 --> 00:08:48.440
You'll be getting your
information back from memory.

00:08:48.490 --> 00:08:49.730
So this will be a lot faster.

00:08:49.740 --> 00:08:50.940
Thank you.

00:08:54.040 --> 00:08:57.290
You'll notice in the previous slide that
I said we bring in the raw cache entries,

00:08:57.300 --> 00:08:58.320
but we still create faults.

00:08:58.400 --> 00:09:02.820
You can go one step further and tell us,
you know what, I don't even want you to

00:09:02.820 --> 00:09:04.280
spend time creating faults.

00:09:04.280 --> 00:09:06.280
Just give me the fully realized objects.

00:09:06.280 --> 00:09:10.220
So you would use the set returns objects
as faults to know it's yes by default.

00:09:10.220 --> 00:09:13.480
And in this case,
when we're doing the initial fetching,

00:09:13.480 --> 00:09:17.500
we're populating the raw cache entries,
we can be a little bit more efficient

00:09:17.570 --> 00:09:21.320
about converting all those objects into
real objects rather than triggering

00:09:21.320 --> 00:09:22.830
the faults one by one later on.

00:09:22.830 --> 00:09:27.340
So So this is yet another step
that you can ask us to do.

00:09:29.600 --> 00:09:33.080
You could also incur fetching
when you're doing deletions.

00:09:33.150 --> 00:09:36.210
Let's say that you're
deleting a manager object.

00:09:36.730 --> 00:09:39.380
goes away, you save out to the database,
you think this is a very

00:09:39.460 --> 00:09:41.710
lightweight operation,
you're simply deleting one

00:09:41.710 --> 00:09:43.020
thing of your database.

00:09:43.020 --> 00:09:44.470
Not quite.

00:09:44.900 --> 00:09:49.080
Remember that a good part of what
Core Data does for you is all of

00:09:49.160 --> 00:09:52.050
the object graph management and
your relationship maintenance.

00:09:52.050 --> 00:09:55.180
So if the manager is
related to employees,

00:09:55.180 --> 00:09:58.520
and those employees' worst case scenario,
they happen to be faults,

00:09:58.520 --> 00:10:00.580
you haven't even accessed
them in the past,

00:10:00.580 --> 00:10:03.550
but we still have to update all
their inverse relationships and

00:10:03.630 --> 00:10:06.560
cascade the deletes depending
on what you decided to do.

00:10:06.600 --> 00:10:10.890
So we go out and do the fetches
and realize the objects and do the

00:10:10.890 --> 00:10:13.770
correct updating of the relationship.

00:10:13.890 --> 00:10:15.710
So keep that in mind.

00:10:15.710 --> 00:10:18.960
A deletion can incur a lot of
fetching because we're doing the

00:10:19.160 --> 00:10:21.100
relationship maintenance for you.

00:10:21.220 --> 00:10:23.290
So if you want to avoid
situations like this,

00:10:23.290 --> 00:10:25.800
you know you're going to be
in a situation like this,

00:10:25.800 --> 00:10:29.580
you might want to pre-fetch those related
objects because you know that you're

00:10:29.590 --> 00:10:33.680
going to be deleting them and you're
going to need to access them right away.

00:10:33.680 --> 00:10:36.580
And also balance how often you're
going to be in a situation like this.

00:10:36.660 --> 00:10:41.100
Don't spread them out too far,
but also you might not want to do

00:10:41.100 --> 00:10:44.110
them right one after the other.

00:10:45.140 --> 00:10:46.720
Searching.

00:10:46.740 --> 00:10:48.150
We're still in the
fetching side of things.

00:10:48.190 --> 00:10:50.580
Remember that one of the things
that you pass down to the

00:10:50.580 --> 00:10:52.060
fetch request is a predicate.

00:10:52.060 --> 00:10:55.620
The predicate is evaluated
by the database engine,

00:10:55.620 --> 00:10:57.160
SQLite in our case.

00:10:57.160 --> 00:11:00.960
So you can be smart about how
you structure your predicate.

00:11:00.960 --> 00:11:04.610
Be sure that you order all of the easier
parts to execute at the beginning,

00:11:04.700 --> 00:11:08.590
at the front of the predicate,
so that you filter out requests early on.

00:11:08.590 --> 00:11:14.680
You might want to limit relationship
queries where you're incurring joins.

00:11:15.190 --> 00:11:17.100
At the database layer,
so there's still something

00:11:17.100 --> 00:11:21.700
that you can do about smartly
constructing your predicates.

00:11:22.700 --> 00:11:24.990
One of the heavier things that
you can do with searching is when

00:11:24.990 --> 00:11:28.500
you are doing a regular expression
matching and full text searching.

00:11:28.500 --> 00:11:30.960
So you certainly get a
lot more flexibility,

00:11:30.960 --> 00:11:33.900
but this is heavy compute intensive.

00:11:33.900 --> 00:11:37.100
If you're doing a lot
of contains searches,

00:11:37.100 --> 00:11:41.900
you might want to complement the core
data store that you have with a specific

00:11:42.030 --> 00:11:45.680
text indexing solution such as SearchKit.

00:11:45.990 --> 00:11:48.690
And if you do that,
the way that you would bind the two

00:11:48.690 --> 00:11:51.060
worlds would be through the object ID.

00:11:51.280 --> 00:11:55.360
So the object IDs is what would
be represented in both sides,

00:11:55.430 --> 00:11:57.280
and you do the heavy
searching on your engine,

00:11:57.280 --> 00:12:00.160
and then you bring back that object ID,
and you fetch your objects in

00:12:00.160 --> 00:12:01.740
the core data side of things.

00:12:04.180 --> 00:12:07.760
So that's it for fetching.

00:12:07.940 --> 00:12:11.020
Always remember where
your data is coming from.

00:12:11.030 --> 00:12:15.060
Disk or memory, that's a big, big,
big speed difference.

00:12:15.070 --> 00:12:18.830
Only fetch what you need,
and try to prefetch things that you know

00:12:18.830 --> 00:12:21.570
you're going to be using right away.

00:12:23.550 --> 00:12:27.070
So you're developing your application,
and you get to a point where you realize

00:12:27.120 --> 00:12:28.470
that something's not quite right.

00:12:28.680 --> 00:12:29.800
Things seem slow.

00:12:30.150 --> 00:12:32.490
How do you determine what is going on?

00:12:32.500 --> 00:12:33.890
What is slow in your application?

00:12:33.900 --> 00:12:36.260
You suspect that it might
have to do with the fetching,

00:12:36.260 --> 00:12:38.340
but how do you prove that?

00:12:39.280 --> 00:12:45.490
So here are the mechanisms that you have
for tracking down issues in Core Data.

00:12:45.680 --> 00:12:48.750
One of the easiest one is to
simply enable SQL debugging.

00:12:48.840 --> 00:12:52.400
So we have a default that you
com.apple/cordatasqldebug.

00:12:52.480 --> 00:12:55.980
When you enable this,
every time we go to the database,

00:12:56.020 --> 00:12:59.510
we're going to log the SQL that goes.

00:12:59.580 --> 00:13:02.590
If you guys were in the previous session,
What's New in Core Data,

00:13:02.590 --> 00:13:04.730
you saw Adam do a lot
of this in his demo.

00:13:04.850 --> 00:13:09.320
So it's a good place also to learn
a lot about how we're doing the

00:13:09.320 --> 00:13:11.390
things behind the scenes for you.

00:13:11.530 --> 00:13:15.070
So I encourage you to turn on
the debugging and look at the

00:13:15.070 --> 00:13:19.230
SQL we're generating as we're
going to the database and how we're

00:13:19.240 --> 00:13:21.080
bringing back that information.

00:13:21.080 --> 00:13:23.460
So in this case,
we have a very simple example

00:13:23.460 --> 00:13:26.060
where we log a line of SQL.

00:13:26.090 --> 00:13:29.060
And you see how long it took
to execute in the database.

00:13:29.060 --> 00:13:32.120
And then we brought back only one row.

00:13:32.370 --> 00:13:37.990
If you see this happening a lot,
you're manipulating your application UI,

00:13:37.990 --> 00:13:40.590
and you see a lot of
one rows coming back,

00:13:40.630 --> 00:13:44.530
then that might be a hint that maybe
you could batch some of those things.

00:13:44.590 --> 00:13:48.170
So you see that the disk
access is happening.

00:13:48.950 --> 00:13:51.400
Now,
parsing through all that SQL information

00:13:51.400 --> 00:13:55.120
might be a little too complicated
once you get a lot of output.

00:13:55.220 --> 00:13:58.980
So another level of debugging
that you can do is by using

00:13:58.980 --> 00:14:00.440
the Instruments application.

00:14:00.500 --> 00:14:05.590
The framework implements DTrace probes.

00:14:05.880 --> 00:14:06.830
We have them in there.

00:14:06.840 --> 00:14:10.740
The result of that can be analyzed
in the Instruments application.

00:14:10.790 --> 00:14:15.130
You can get information about fetching,
fault firing, I/O access.

00:14:15.290 --> 00:14:18.210
So if you use the
Instruments application,

00:14:19.030 --> 00:14:22.240
We even have a template,
a Core Data template,

00:14:22.240 --> 00:14:24.650
to start your debugging.

00:14:24.980 --> 00:14:30.330
If you select that template,
we give you three instruments by default.

00:14:31.290 --> 00:14:35.040
There's a fetching instrument that gives
you information as to what's going on

00:14:35.040 --> 00:14:37.900
when a fetch request is being executed,
what kind of things we're fetching,

00:14:37.900 --> 00:14:40.470
how many things came back.

00:14:41.530 --> 00:14:44.120
There's a cache, there is a,
what's the official name?

00:14:44.120 --> 00:14:45.880
The Core Data cache instrument.

00:14:45.950 --> 00:14:48.290
This is where we tell you
when we're missing the cache,

00:14:48.290 --> 00:14:51.470
we thought something was going to be
in one of the entries in the row cache,

00:14:51.580 --> 00:14:53.840
it's not there,
now we have to go to the database.

00:14:53.840 --> 00:14:57.790
And a saving instrument that tells
you how long the saving took.

00:15:00.940 --> 00:15:05.320
So I'm going to walk you through an
example of how you would gather this

00:15:05.340 --> 00:15:07.940
information from the instrument's UI.

00:15:07.960 --> 00:15:09.060
This is a simple example.

00:15:09.060 --> 00:15:09.930
It's GoFetch.

00:15:09.940 --> 00:15:12.100
It's available on the ADC website.

00:15:12.100 --> 00:15:15.060
You can do it later on after the session.

00:15:15.320 --> 00:15:18.730
But you basically have a person,
which is a lightweight entity.

00:15:18.740 --> 00:15:21.060
It simply contains textual information.

00:15:21.100 --> 00:15:23.770
And then a heavier entity
with image information.

00:15:23.790 --> 00:15:26.170
In this case, it's the icon.

00:15:27.130 --> 00:15:31.570
The GoFetch UI allows you to
configure a lot of things over

00:15:31.600 --> 00:15:33.020
on the left-hand side here.

00:15:33.020 --> 00:15:35.980
This is a good place to experiment
with all of the settings that

00:15:35.980 --> 00:15:37.570
I mentioned for fetch request.

00:15:37.610 --> 00:15:41.520
For purposes of this walkthrough,
I am only going to be enabling or

00:15:41.520 --> 00:15:44.240
disabling prefetching of relationships.

00:15:57.330 --> 00:15:58.480
The GoFetch UI allows you to
configure a lot of things over

00:15:58.480 --> 00:15:58.480
on the left-hand side here.

00:15:58.480 --> 00:15:58.480
This is a good place to experiment
with all of the settings that

00:15:58.480 --> 00:15:58.480
I mentioned for fetch request.

00:15:58.480 --> 00:15:58.480
For purposes of this walkthrough,
I am only going to be enabling or

00:15:58.480 --> 00:15:58.480
disabling prefetching of relationships.

00:15:58.730 --> 00:16:13.700
The person information,
which is the lighter weight,

00:16:13.700 --> 00:16:13.700
as well as the image information.

00:16:13.700 --> 00:16:13.700
We're always displaying that in the UI.

00:16:13.700 --> 00:16:13.700
And right after I do the fetch,
I drag the scroller up and down so

00:16:13.700 --> 00:16:13.700
I reveal more of the information.

00:16:13.700 --> 00:16:13.730
During the second run,

00:16:14.520 --> 00:16:19.060
The only change that we do is that
we enable prefetching so that we say,

00:16:19.060 --> 00:16:22.210
you know,
don't leave the icon objects as false.

00:16:22.280 --> 00:16:27.230
Go and prefetch their information so
that you don't do single firing of false.

00:16:27.290 --> 00:16:29.420
So let's say we had done this.

00:16:29.420 --> 00:16:31.100
What would it look like in instruments?

00:16:31.100 --> 00:16:32.820
Here's the first run.

00:16:32.820 --> 00:16:34.010
Here's the second run.

00:16:34.280 --> 00:16:35.360
And here's the second one.

00:16:35.360 --> 00:16:39.380
Let's focus on the
fetching instrument first.

00:16:40.030 --> 00:16:44.140
As you can see on the top,
where we didn't have prefetching,

00:16:44.240 --> 00:16:48.900
we did a lot less fetching,
and it was a lot quicker to do that,

00:16:49.040 --> 00:16:50.920
because we're only fetching
the light instance,

00:16:51.010 --> 00:16:51.820
which is the person.

00:16:51.820 --> 00:16:54.020
It only has person, first name,
and last name.

00:16:54.020 --> 00:16:55.600
So we're done very quickly.

00:16:55.600 --> 00:16:59.100
And at the bottom,
where we're enabling the prefetching,

00:16:59.100 --> 00:17:03.690
the fetching took a lot longer initially,
because we're now prefetching all of

00:17:03.790 --> 00:17:07.300
the heavy information in the image,
in the icon entity.

00:17:09.180 --> 00:17:10.540
Well, why would we want to do that?

00:17:10.540 --> 00:17:12.750
Why would we want to incur that cost?

00:17:12.750 --> 00:17:18.100
Well, because what this UI does is that
we always show the icon information

00:17:18.100 --> 00:17:20.180
right next to the person information.

00:17:20.180 --> 00:17:24.380
So if we now focus on the
cache misses instrument,

00:17:24.540 --> 00:17:28.470
you'll see that as I'm dragging
the scroller up and down,

00:17:28.680 --> 00:17:31.110
in the first case,
I am now missing the cache.

00:17:31.300 --> 00:17:34.530
There's activity there going on,
and that is incurring a disk access.

00:17:34.670 --> 00:17:38.090
Well, in the second case,
where I already did the prefetching,

00:17:38.090 --> 00:17:39.940
we're not missing the caches.

00:17:39.940 --> 00:17:46.180
So just in terms of namings,
RCM is Relationship Cache

00:17:46.280 --> 00:17:49.680
Miss and Cache Miss for CM.

00:17:49.680 --> 00:17:53.000
It should actually say to
many Relationship Cache Miss.

00:17:53.000 --> 00:17:56.220
So in this case,
we only have it to one relationship.

00:17:56.300 --> 00:17:58.830
If you put them together,
if you see these two

00:17:58.830 --> 00:18:02.740
instruments together,
you can clearly see how they're related.

00:18:02.740 --> 00:18:04.580
Say you're no prefetching.

00:18:04.760 --> 00:18:07.700
But then we do the fetching later on,
or lots of prefetching,

00:18:07.700 --> 00:18:09.830
and then we don't do
any fetching later on.

00:18:09.840 --> 00:18:13.780
So this is how you can gather
information from this application.

00:18:15.900 --> 00:18:18.240
As some of you might know,
the Instruments application

00:18:18.320 --> 00:18:20.560
has two other main UI areas.

00:18:20.660 --> 00:18:24.140
In the detail area,
you will see the beginning and

00:18:24.140 --> 00:18:25.690
the end of each one of our probes.

00:18:25.890 --> 00:18:30.600
So in the case of fetching,
we show you that we're fetching persons.

00:18:30.600 --> 00:18:32.340
This is the kind of
entity we're fetching.

00:18:32.340 --> 00:18:34.780
And not only that,
but this is how many we fetched.

00:18:34.900 --> 00:18:37.880
So that's all instrumented behind
the scenes for you in the framework.

00:18:37.880 --> 00:18:41.310
And if you want to know
where in your code this is,

00:18:41.320 --> 00:18:44.800
you simply drag the pointer in
the Instruments application,

00:18:45.340 --> 00:18:46.870
and we show you the stack trace.

00:18:46.970 --> 00:18:49.200
So just drag your pointer to
where you see a lot of activity,

00:18:49.200 --> 00:18:50.200
which you're not expecting.

00:18:50.200 --> 00:18:54.830
And then in the back trace, you will see,
hopefully, somewhere in your source

00:18:54.920 --> 00:18:58.200
code which you can identify,
and then you can now drill down and

00:18:58.200 --> 00:18:59.360
figure out what's going on there.

00:18:59.360 --> 00:19:02.840
So that's it for the
Instruments application.

00:19:04.850 --> 00:19:07.850
Moving on,
there's a version of Core Data of

00:19:07.850 --> 00:19:12.200
the Core Data framework which
is debug for debug purposes.

00:19:12.390 --> 00:19:14.480
You can download this
from the ADC website.

00:19:14.760 --> 00:19:17.380
You can just go to the download section,
developer tools,

00:19:17.380 --> 00:19:18.730
the debug and profile libs.

00:19:18.730 --> 00:19:23.470
It's part of the debug libraries that
you can get from the ADC website,

00:19:23.600 --> 00:19:25.110
not just Core Data.

00:19:25.590 --> 00:19:28.460
What you get when you have this
library on your system is we

00:19:28.460 --> 00:19:30.290
enable a lot of the assertions.

00:19:30.300 --> 00:19:33.290
So you might trigger,
if something's going

00:19:33.290 --> 00:19:36.360
wrong in your application,
you might fire off an assertion,

00:19:36.360 --> 00:19:39.910
and it would give you more information
as to what we thought should have

00:19:40.030 --> 00:19:41.840
happened and is not happening.

00:19:41.840 --> 00:19:46.160
It's mostly useful for when you're
doing multi-threading debugging.

00:19:46.160 --> 00:19:48.270
If you're in that scenario,
I'll be talking about

00:19:48.480 --> 00:19:51.680
multi-threading later on,
but you would enable the user default

00:19:51.690 --> 00:19:55.360
com.apple.core.data threading debug,
and then we enable all of the

00:19:55.360 --> 00:19:56.680
multi-threading assertions.

00:19:56.680 --> 00:20:00.010
So this is a great way for you
to gather more information.

00:20:02.020 --> 00:20:05.310
Once you download the library,
there's one step of configuration.

00:20:05.430 --> 00:20:09.160
It's all explained in TechNode 2124.

00:20:09.160 --> 00:20:12.740
TechNode 2124, by the way,
it's a very general

00:20:12.740 --> 00:20:15.160
debugging in Mac OS TechNode.

00:20:15.280 --> 00:20:19.160
It has a lot of information
as to how you would go about

00:20:19.160 --> 00:20:22.140
general debugging in the platform.

00:20:22.140 --> 00:20:23.660
So if you're not familiar
with the TechNode,

00:20:23.660 --> 00:20:24.810
I suggest that you check it out.

00:20:24.880 --> 00:20:29.460
But a little part of NetTechNode is how
you would configure the debug libraries.

00:20:29.810 --> 00:20:32.160
So the debug libraries have a suffix,
underscore debug.

00:20:32.160 --> 00:20:34.980
If you want your application
to pick up those libraries,

00:20:34.980 --> 00:20:38.960
you have to set the
DYLD image suffix setting.

00:20:38.960 --> 00:20:41.300
You can also set this within Xcode.

00:20:41.300 --> 00:20:44.640
If you're going to the
inspector for the executable,

00:20:44.640 --> 00:20:48.670
there's an option there to set,
this is the suffix I want to use in

00:20:48.670 --> 00:20:49.810
the libraries that you're picking up.

00:20:51.810 --> 00:20:55.100
The only gatter here is that
you might have other debug

00:20:55.100 --> 00:20:58.130
libraries on your system,
so if you don't want to pick

00:20:58.230 --> 00:21:01.530
up all of the debug libraries,
you want to rename that file

00:21:01.530 --> 00:21:06.030
to a unique suffix and then
set only that unique suffix.

00:21:08.060 --> 00:21:10.800
So we're done with the
analysis and debugging section.

00:21:10.850 --> 00:21:14.800
Turn on SQL Logging for learning
a lot about how we're doing

00:21:14.830 --> 00:21:15.900
things behind the scenes.

00:21:15.900 --> 00:21:18.290
Use the Instruments application.

00:21:18.290 --> 00:21:21.950
And use the default,
the debug library if you want to

00:21:21.980 --> 00:21:26.540
use a little more help in debugging
your multi-threaded applications.

00:21:29.530 --> 00:21:36.110
Moving on, next tip and trick section,
Advanced Property Modeling.

00:21:36.700 --> 00:21:40.920
I'll be focusing purely
on three things here.

00:21:40.920 --> 00:21:47.000
Non-standard types, fetch properties,
and derived properties.

00:21:47.000 --> 00:21:50.300
This is not a full modeling
subsection of my talk.

00:21:50.570 --> 00:21:53.100
For that,
you would want to go to the next hour.

00:21:53.100 --> 00:21:58.900
Melissa will be doing a full presentation
on better schema design for Core Data,

00:21:58.900 --> 00:22:01.920
so I recommend that you guys go to that.

00:22:01.930 --> 00:22:05.140
We're simply focusing on certain
aspects of attributes here.

00:22:08.490 --> 00:22:09.680
So, Transformable Attributes.

00:22:09.850 --> 00:22:14.700
Here we have a very simple example
where you have a car entity,

00:22:14.700 --> 00:22:17.340
and you want that car to have a color.

00:22:17.400 --> 00:22:21.580
But you want to model
your color as an NS color.

00:22:21.700 --> 00:22:25.500
And as you quickly see,
we don't have NSColor in the default

00:22:25.800 --> 00:22:28.020
types that Core Data supports.

00:22:28.120 --> 00:22:32.720
We have numbers and dates and strings,
but we don't have a color type.

00:22:32.790 --> 00:22:36.210
So no worries,
you can select the transformable type.

00:22:36.390 --> 00:22:38.730
That's one of the types that
you have available to you.

00:22:38.990 --> 00:22:43.010
And that will allow you to model
one of the non-standard types.

00:22:44.820 --> 00:22:47.280
So the trick is to use
transformable type.

00:22:47.390 --> 00:22:51.100
This is a new kind of type
we introduced in Leopard.

00:22:51.120 --> 00:22:55.130
And what we do behind the scenes
for you is that we archive and

00:22:55.260 --> 00:22:58.830
unarchive this other type into a data.

00:22:59.200 --> 00:23:03.280
So by default, we use NSKeyed unarchived
from data transformer.

00:23:03.280 --> 00:23:04.750
We use the value transformer.

00:23:04.970 --> 00:23:05.800
But you can use your own.

00:23:05.900 --> 00:23:12.310
You can specify within the UI whatever
transformer that you want to use.

00:23:12.440 --> 00:23:18.120
As long as it goes back and forth between
an NSData and it's bi-directional.

00:23:18.140 --> 00:23:22.260
The one other gotcha that you need
to keep in mind here is that--

00:23:22.690 --> 00:23:27.400
The fact that you told us that your type
is transformable didn't tell us anything

00:23:27.400 --> 00:23:31.260
about the fact that you're actually
using an NSColor behind the scenes.

00:23:31.260 --> 00:23:35.140
So you're going to get compiler
warnings if you start accessing

00:23:35.140 --> 00:23:38.840
the set color and color accessors
because we don't know anything about

00:23:38.840 --> 00:23:40.460
the actual type that you're using.

00:23:40.460 --> 00:23:46.030
So be sure to declare the property in
your header with the correct type so that

00:23:46.090 --> 00:23:49.280
you don't get those compiler warnings.

00:23:49.360 --> 00:23:51.560
But everything else is done
behind the scenes for you,

00:23:51.560 --> 00:23:54.020
the transforming back and forth.

00:23:56.120 --> 00:23:58.200
Fetch properties.

00:23:58.650 --> 00:24:01.580
Fetch properties,
think of them as kind of

00:24:01.580 --> 00:24:04.860
weak one-way relationships.

00:24:04.900 --> 00:24:08.530
Fetch properties that are part
of your entity are populated by

00:24:08.530 --> 00:24:14.370
executing a fetch request and bringing
that information back as an array

00:24:14.370 --> 00:24:16.770
and putting that in your entity.

00:24:16.920 --> 00:24:18.940
This is slightly different
from a relationship.

00:24:18.940 --> 00:24:22.510
As many of you know, a relationship,
when you're inspecting a

00:24:22.520 --> 00:24:26.690
relationship in your instances,
we are treating those as sets.

00:24:26.700 --> 00:24:29.740
So this is a fetch request result.

00:24:29.840 --> 00:24:31.600
We give it to you back as an array.

00:24:31.600 --> 00:24:35.130
It's part of your instance,
but we're also not doing any

00:24:35.130 --> 00:24:37.400
relationship management for you.

00:24:37.400 --> 00:24:38.730
We're not doing refreshing.

00:24:38.730 --> 00:24:40.620
We're not doing inverse relationships.

00:24:40.670 --> 00:24:43.640
When would you want to
use something like this?

00:24:43.790 --> 00:24:47.700
If you have a smart group
concept in your application,

00:24:47.700 --> 00:24:54.330
but most likely when you're
modeling cross-door relationships.

00:24:55.520 --> 00:24:59.150
There's actually an example for
doing the cross-store relationship

00:24:59.220 --> 00:25:01.060
modeling with fetch property.

00:25:01.250 --> 00:25:03.720
It's actually on the
systems that you have now.

00:25:03.720 --> 00:25:07.040
As of Leopard, just go to the
/developer/example/core-data,

00:25:07.070 --> 00:25:11.550
the iClass example, look in there,
and part of what that example

00:25:11.550 --> 00:25:15.400
does is modeling a cross-store
relationship with a fetch property.

00:25:18.120 --> 00:25:20.600
So here's a quick example.

00:25:20.660 --> 00:25:25.740
We have a collection
entity and a song entity.

00:25:26.660 --> 00:25:29.260
Within your collection,
you want to have a property that

00:25:29.350 --> 00:25:34.980
represents your highest rated songs,
the songs that you've rated the highest.

00:25:35.180 --> 00:25:38.000
But you don't want that to
be a full-blown relationship,

00:25:38.000 --> 00:25:45.590
so you model that as a fetch property,
you associate a predicate,

00:25:46.520 --> 00:25:49.140
And that would be a fetch property.

00:25:49.140 --> 00:25:53.010
Now, remember, we're not taking care of
refreshing this property.

00:25:53.060 --> 00:25:57.020
Once we fetch it the first time,
we're not taking care of monitoring when

00:25:57.020 --> 00:26:01.380
new songs are coming in or going away
and refreshing the property for you.

00:26:01.380 --> 00:26:02.670
That is something you have to do.

00:26:02.680 --> 00:26:06.490
So you have to register for change
notification at some sort of level,

00:26:06.500 --> 00:26:09.420
be it the object, context,
or controller level.

00:26:09.420 --> 00:26:12.250
And when you get that notification,
what you most likely want to do is turn

00:26:12.370 --> 00:26:15.070
your object back into a fault so that
the next time you get a notification,

00:26:15.110 --> 00:26:16.380
you can see it's not a fault.

00:26:16.400 --> 00:26:19.370
And by the time you
access that relationship,

00:26:19.370 --> 00:26:21.710
we re-execute the fetch request.

00:26:21.710 --> 00:26:23.360
So this is your responsibility.

00:26:26.890 --> 00:26:32.480
The simplest case of a derived attribute
is a full name where you're concatenating

00:26:32.620 --> 00:26:34.680
a first name and a last name.

00:26:34.720 --> 00:26:40.540
But a more interesting use case for this
would be as an optimization technique.

00:26:40.610 --> 00:26:44.340
Let's say that you have a
blog entry entity where you

00:26:44.410 --> 00:26:49.340
have all of your blog entries,
which are kind of big chunks of text,

00:26:49.340 --> 00:26:53.380
those are being stored in
the regular text attribute,

00:26:53.380 --> 00:26:54.360
right?

00:26:55.470 --> 00:26:58.850
But there could be all kinds
of random stuff in that text

00:26:58.900 --> 00:27:01.020
accents and different cases.

00:27:01.020 --> 00:27:04.630
So you want your searching to
be very fast in a normalized

00:27:04.770 --> 00:27:06.240
version of that text.

00:27:06.240 --> 00:27:09.380
So you would model a derived property,
normalized text.

00:27:09.380 --> 00:27:13.940
You do the normalization step each
time you set the regular text.

00:27:13.940 --> 00:27:16.700
And that normalization step
might be a little heavy.

00:27:16.700 --> 00:27:18.370
So you're doing that each time.

00:27:18.390 --> 00:27:21.760
But once you have that result,
you can store it in that property.

00:27:21.760 --> 00:27:23.910
So you're deriving that information.

00:27:24.330 --> 00:27:26.520
The simplest case of a derived attribute
is a full name where you're concatenating

00:27:26.520 --> 00:27:27.310
a first name and a last name.

00:27:27.310 --> 00:27:29.450
But a more interesting use case for this
would be as an optimization technique.

00:27:29.460 --> 00:27:30.810
Let's say that you have a
blog entry entity where you

00:27:30.810 --> 00:27:32.590
have all of your blog entries,
which are kind of big chunks of text.

00:27:32.670 --> 00:27:34.750
But a more interesting use case for this
would be as an optimization technique.

00:27:34.840 --> 00:27:36.580
So you're deriving that information
from original information.

00:27:36.580 --> 00:27:37.840
And it's actually
persisted in your database,

00:27:37.840 --> 00:27:39.140
unlike the full name
example right above that.

00:27:39.140 --> 00:27:40.130
That's just a transient property.

00:27:40.130 --> 00:27:41.550
So you're actually doing the
processing and caching that

00:27:41.620 --> 00:27:42.510
information and saving it out.

00:27:42.510 --> 00:27:44.160
So when you do your searching,
you can do a lot faster searching

00:27:44.160 --> 00:27:46.760
on the normalized property rather
than the regular text property.

00:27:48.700 --> 00:27:50.080
We also have an example for this.

00:27:50.080 --> 00:27:52.540
It's called the right property.

00:27:52.540 --> 00:27:54.500
It's on the ADC website,
and it's actually

00:27:54.620 --> 00:27:55.770
associated to this session.

00:27:55.780 --> 00:27:59.260
So if you go to the things that
are associated with this session,

00:27:59.260 --> 00:28:02.820
this is one of them,
one of the ones that you'll find.

00:28:02.820 --> 00:28:06.210
This example not only
does the derived property,

00:28:06.210 --> 00:28:10.790
but it also does some interesting
stuff with overriding the default

00:28:10.790 --> 00:28:15.020
behavior in the search field so that
you can normalize the property before

00:28:15.020 --> 00:28:16.640
you pass it on to the fetching.

00:28:16.780 --> 00:28:20.890
So take a look at it, we do a couple of
interesting things there.

00:28:22.920 --> 00:28:25.160
So that's it for property modeling.

00:28:25.280 --> 00:28:30.120
You can model your own custom data
types using transformed properties.

00:28:30.380 --> 00:28:34.440
If you want weak relationships,
use fetch properties and use direct

00:28:34.540 --> 00:28:38.640
properties as a mechanism for
caching expensive computations.

00:28:41.180 --> 00:28:44.790
Moving on,
as you're improving your model and

00:28:44.790 --> 00:28:50.490
modifying it to make it more efficient,
you're most likely going to come across

00:28:50.490 --> 00:28:54.150
the concept of versioning and migration.

00:28:56.040 --> 00:28:59.490
So why is this an issue?

00:28:59.580 --> 00:29:03.660
Core Data does everything,
we do everything for you as long

00:29:03.660 --> 00:29:06.980
as you give us the blueprint of
your data in the shape of a model.

00:29:06.980 --> 00:29:10.540
So you give us a description of
your data and we're able to manage a

00:29:10.540 --> 00:29:13.000
store for you with that information.

00:29:13.000 --> 00:29:17.910
The moment that you change the blueprint,

00:29:18.540 --> 00:29:21.200
But you retain the
data in the old format,

00:29:21.200 --> 00:29:22.160
we don't know what to do.

00:29:22.160 --> 00:29:24.580
You're giving us an incompatible
blueprint to the data

00:29:24.620 --> 00:29:25.680
store that you're pointing.

00:29:25.680 --> 00:29:28.720
So this is what we're
calling a version skew,

00:29:28.720 --> 00:29:30.740
version incompatibility.

00:29:30.740 --> 00:29:32.520
So we don't know what to do.

00:29:32.520 --> 00:29:35.680
This is where migration comes into play.

00:29:35.680 --> 00:29:38.830
What are the kinds of things
that you can do to break our

00:29:38.830 --> 00:29:40.580
ability to read your data?

00:29:41.960 --> 00:29:45.380
If you change the name of your entity,
anything having to do with inheritance,

00:29:45.470 --> 00:29:48.460
anything having to do with the
properties that you're persisting out,

00:29:48.460 --> 00:29:52.520
and the same thing at the property level,
name, optionality, attribute types,

00:29:52.520 --> 00:29:54.960
you're changing the
description of your data.

00:29:54.960 --> 00:30:00.560
And you already have a data store,
which does not match that description.

00:30:00.560 --> 00:30:03.160
So we have a hard time reading it.

00:30:05.010 --> 00:30:07.640
There are things that you can change
in your model which do not break

00:30:07.640 --> 00:30:10.930
our ability to read your data,
such as the class name that

00:30:10.930 --> 00:30:13.320
we're going to use to instantiate
your objects at runtime,

00:30:13.320 --> 00:30:16.260
transient properties,
because by definition

00:30:16.390 --> 00:30:21.140
they're not in the store,
user info, and similarly for properties.

00:30:24.070 --> 00:30:26.690
So what we do to determine, oh,
let me just,

00:30:26.690 --> 00:30:30.080
how many were in the last session
in what's new in the Core Data?

00:30:30.080 --> 00:30:32.700
Okay, so not that many.

00:30:32.700 --> 00:30:34.780
If you haven't heard,
we have the concept of

00:30:34.780 --> 00:30:38.380
lightweight migration that we're
working on for Snow Leopard,

00:30:38.380 --> 00:30:43.330
but even in that realm,
knowing this content is still

00:30:43.330 --> 00:30:46.360
important because this is still
what's going on behind the scenes.

00:30:47.530 --> 00:30:51.760
So what we do is,
every time you give us a model,

00:30:51.760 --> 00:30:56.380
we calculate a hash digest of each
one of the entities in that model.

00:30:56.380 --> 00:31:00.180
It's a 32-byte hash digest,
which I'll represent as an

00:31:00.180 --> 00:31:02.450
icon here for easy comparison.

00:31:02.460 --> 00:31:05.010
And when you save your
data to your store,

00:31:05.010 --> 00:31:09.580
we save that versioning information
as part of the store's metadata.

00:31:11.110 --> 00:31:13.890
So once we have that
versioning information,

00:31:13.890 --> 00:31:17.640
we are able to check whether
a store is compatible with the

00:31:17.640 --> 00:31:19.700
model that you're giving us.

00:31:19.810 --> 00:31:23.420
So when you ask us to work with
a store and a particular model,

00:31:23.530 --> 00:31:26.710
the first thing we do is calculate
the versioning information,

00:31:26.910 --> 00:31:29.880
go to the store and get the metadata,
compare it.

00:31:30.220 --> 00:31:32.870
If they're the same,
we know that we have the correct

00:31:32.870 --> 00:31:34.690
blueprint to access your data.

00:31:34.860 --> 00:31:39.990
So we bring up the stack and
we do what you expect us to do.

00:31:40.760 --> 00:31:43.350
Similarly, this is how we would determine
that you did a change,

00:31:43.910 --> 00:31:46.600
because after we calculate
the version hashes,

00:31:46.600 --> 00:31:52.060
they don't match the version hashes that
are stored in your store as the metadata.

00:31:52.060 --> 00:31:56.630
So the default behavior for a
Core Data application with a UI is

00:31:56.630 --> 00:32:00.680
to bring up this panel saying,
I don't know how to read your data,

00:32:00.680 --> 00:32:02.710
you gave me the wrong
version of the model,

00:32:02.710 --> 00:32:04.040
so do something about it.

00:32:06.820 --> 00:32:09.470
Fortunately for you,
there is something you can do about it,

00:32:09.500 --> 00:32:11.890
and we help you a lot.

00:32:12.000 --> 00:32:16.640
Since Leopard, we have the mechanism of
versioning your models.

00:32:16.730 --> 00:32:19.600
So models are not
independent entities anymore.

00:32:19.600 --> 00:32:22.160
They're actually,
they can have different versions,

00:32:22.160 --> 00:32:24.960
and they can be grouped inside
of a higher level model,

00:32:24.960 --> 00:32:26.240
a version Core Data model.

00:32:26.360 --> 00:32:28.680
So Xcode has this functionality.

00:32:28.710 --> 00:32:30.820
You can tell it to create a
new version of your model,

00:32:30.820 --> 00:32:34.410
and you keep track of
them within your project.

00:32:35.560 --> 00:32:39.250
And we also give you the ability
to provide us a mapping model

00:32:39.330 --> 00:32:42.500
that tells us how to go from one
version of your model to another.

00:32:42.530 --> 00:32:46.290
And we even have a whole new
mapping model editor since Leopard,

00:32:46.550 --> 00:32:51.170
so this is how you kind of
bootstrap the migration.

00:32:51.990 --> 00:32:53.100
So what's a mapping model?

00:32:53.100 --> 00:32:58.060
A mapping model is yet another blueprint
where you tell us how to go from your old

00:32:58.060 --> 00:33:01.940
version to the new version of your data.

00:33:07.620 --> 00:33:08.740
Here's an example.

00:33:08.780 --> 00:33:12.180
Let's say that in your initial
version of your data model,

00:33:12.230 --> 00:33:16.060
you embedded the address information
for a person inside the entity.

00:33:16.150 --> 00:33:20.910
So you decided to model persons with
their street and their state inside.

00:33:21.010 --> 00:33:24.380
And then later on, you realize that that
was a little inefficient,

00:33:24.380 --> 00:33:27.150
you didn't wanna do that,
you wanna have two-one relationship.

00:33:27.300 --> 00:33:32.110
So you change your model to now have
person and an address with the address

00:33:32.110 --> 00:33:34.350
information in a separate entity.

00:33:34.460 --> 00:33:39.190
The problem is that you already
have a store that contains

00:33:39.190 --> 00:33:40.800
information in that format.

00:33:40.940 --> 00:33:47.240
So you somehow have to explain to us how
you want us to map that information over,

00:33:47.240 --> 00:33:49.390
how you want us to migrate
that information over.

00:33:49.410 --> 00:33:53.430
You would have to tell us, you know what,
take the person's instances and

00:33:53.520 --> 00:33:56.260
create new person instances from that.

00:33:56.330 --> 00:34:01.160
And take persons and also create address
instances for each one of the people.

00:34:01.230 --> 00:34:03.860
And inside each one of those
new instances you create,

00:34:03.920 --> 00:34:07.970
move the age and the name over
into the person instances and

00:34:07.970 --> 00:34:12.010
move the street and the state
over into the address instances.

00:34:12.060 --> 00:34:15.380
So you have to give us this information,
we can't figure this out for you.

00:34:17.820 --> 00:34:21.040
We introduced five new
classes in Leopard.

00:34:21.050 --> 00:34:26.430
The top three have to do with the
modeling of the mapping model,

00:34:26.430 --> 00:34:30.660
and the bottom two are what
actually perform the migration.

00:34:30.660 --> 00:34:34.240
I'd like to point out here that,
in particular,

00:34:34.560 --> 00:34:39.710
NS Entity Migration Policy is
a subclassable class,

00:34:39.710 --> 00:34:43.500
so you don't have to settle for the
default behavior that we give you.

00:34:43.500 --> 00:34:48.410
These are things that you can plug
in your own migration logic into.

00:34:48.520 --> 00:34:52.670
So what goes on behind the scenes
when we're migrating your stores?

00:34:53.250 --> 00:34:55.990
Well, we start out by detecting
a version incompatibility,

00:34:55.990 --> 00:34:56.500
right?

00:34:56.500 --> 00:34:59.090
You give us a model which
is not compatible with the

00:34:59.330 --> 00:35:01.940
store that you gave us,
that you pointed us to.

00:35:01.940 --> 00:35:04.220
So we look in the
resources of your project,

00:35:04.220 --> 00:35:07.800
because they should be there,
you've been managing them all along,

00:35:07.800 --> 00:35:11.260
and we look for the source model,
the correct version of your model,

00:35:11.330 --> 00:35:14.440
and a mapping model that tells
us how to go from A to B.

00:35:15.990 --> 00:35:19.200
We pass that on down to
the Migration Manager,

00:35:19.230 --> 00:35:24.210
and the Migration Manager takes care
of instantiating two Core Data stacks.

00:35:24.940 --> 00:35:27.800
and performs the
migration in three phases.

00:35:27.870 --> 00:35:32.540
During the first pass,
we move over all of the instances.

00:35:32.800 --> 00:35:53.500
[Transcript missing]

00:35:55.410 --> 00:35:59.290
Let's look at entity mappings,
the mapping modeling in

00:35:59.290 --> 00:36:00.480
a little more detail.

00:36:00.540 --> 00:36:04.560
So the entity mapping needs to have the
source entity and the destination entity.

00:36:04.560 --> 00:36:08.420
You can give it a name too,
and you can order it inside

00:36:08.420 --> 00:36:09.820
of the mapping model.

00:36:09.830 --> 00:36:12.700
And most importantly,
you can specify a custom

00:36:12.770 --> 00:36:15.710
policy class name,
which would be a subclass of our default

00:36:15.710 --> 00:36:21.180
behavior if you're not happy with
what we're doing for the migration.

00:36:21.970 --> 00:36:25.110
Entity mappings are made
up of property mappings.

00:36:25.280 --> 00:36:28.550
The essence of a property mapping,
think of a property mapping

00:36:28.620 --> 00:36:30.070
as a value expression.

00:36:30.170 --> 00:36:33.150
So you provide us a value expression,
we evaluate it,

00:36:33.210 --> 00:36:36.230
and whatever comes out of that,
that's the value of your property

00:36:36.230 --> 00:36:38.580
that you want us to fill in,
the destination entity.

00:36:38.580 --> 00:36:44.740
Because it's a value expression,
you have access to

00:36:44.740 --> 00:36:44.740
certain special keys that

00:36:44.990 --> 00:36:49.420
by prefixing them with dollar signs,
such as dollar sign source, destination,

00:36:49.420 --> 00:36:51.180
manager, entity mapping.

00:36:51.180 --> 00:36:54.660
So if you want to access these
things in your value expression,

00:36:54.660 --> 00:36:57.080
just be aware that they're there.

00:36:57.080 --> 00:37:00.320
And they're documented in the
NS Entity Migration Policy.

00:37:01.500 --> 00:37:03.020
Here's a simple example.

00:37:03.040 --> 00:37:05.800
This is how you would tell us,
I want you to migrate the name

00:37:05.800 --> 00:37:09.740
field by simply getting whatever
the name was on the source and stick

00:37:09.810 --> 00:37:11.940
it into the new instance's name.

00:37:11.940 --> 00:37:14.930
So just go to the source,
dollar sign source, dot name,

00:37:14.930 --> 00:37:17.610
and whatever that value was,
that's what I want my name

00:37:18.110 --> 00:37:19.780
property to be in the new world.

00:37:22.950 --> 00:37:25.040
Let's get back to the example here.

00:37:25.040 --> 00:37:27.280
So we have a source and a destination.

00:37:27.360 --> 00:37:31.600
In this case, you would need to define
two entity mappings.

00:37:31.600 --> 00:37:35.740
The first entity mapping would
migrate from person to person.

00:37:35.740 --> 00:37:38.720
So the source and the
destination is person.

00:37:38.720 --> 00:37:41.590
And the mapping at the property
level would be age and name,

00:37:41.590 --> 00:37:45.460
where you're simply going to the source
and fetching them from the source.

00:37:48.130 --> 00:37:51.530
Then you would need a second mapping
for migrating a person to an address

00:37:52.640 --> 00:37:56.670
where the source is a person and
the destination is the address.

00:37:56.760 --> 00:38:01.040
And this is where you're extracting
the address fields from the source.

00:38:01.130 --> 00:38:05.480
So this is information that you need
to define for us in the mapping model.

00:38:05.540 --> 00:38:08.320
You can do more sophisticated things,
such as introducing

00:38:08.320 --> 00:38:10.110
inheritance hierarchies.

00:38:10.220 --> 00:38:14.380
Say you have a flattened
space with employees only in

00:38:14.380 --> 00:38:18.030
the old version of the model,
and you decide to split up your

00:38:18.100 --> 00:38:20.890
employees into managers and programmers.

00:38:21.130 --> 00:38:24.320
So you can do that by
defining an entity mapping,

00:38:24.400 --> 00:38:25.960
employee to manager.

00:38:25.990 --> 00:38:29.480
The source is still employee,
but you can associate a

00:38:29.510 --> 00:38:32.040
filter with an entity mapping.

00:38:32.060 --> 00:38:34.380
So you can say,
don't fetch all the employees.

00:38:34.380 --> 00:38:37.700
Only fetch the employees whose
level is greater than two.

00:38:37.750 --> 00:38:39.900
Those are the managers in my world.

00:38:40.040 --> 00:38:43.100
So the destination instances
I want you to create from

00:38:43.100 --> 00:38:44.840
those employees are managers.

00:38:45.090 --> 00:38:50.690
And you migrate the entities,
the field level values over.

00:38:51.450 --> 00:38:54.100
You'll notice I haven't
mentioned much relationships.

00:38:54.280 --> 00:38:58.030
How do you actually indicate how
you want us to re-hook up your

00:38:58.030 --> 00:39:01.490
relationships in the second phase?

00:39:01.740 --> 00:39:05.620
So here we are at the end of the
first phase of the migration.

00:39:05.620 --> 00:39:07.240
We've created the instances.

00:39:07.240 --> 00:39:12.190
Now we want to bind the
person to the address.

00:39:13.300 --> 00:39:17.700
Your first crack at this might be, well,
I just want to get the source's address.

00:39:17.700 --> 00:39:21.610
That's what I want you to fill in as
the address in the destination world.

00:39:21.640 --> 00:39:25.010
That's not quite going
to work for two reasons.

00:39:25.060 --> 00:39:28.830
One is, if you evaluate dollar
sign source dot address,

00:39:28.840 --> 00:39:30.710
well, first of all,
there is no address in

00:39:30.710 --> 00:39:32.040
your source context.

00:39:32.040 --> 00:39:35.210
Sure, the information was
embedded in the person,

00:39:35.220 --> 00:39:39.180
but from a key path point of view,
it doesn't take you anywhere.

00:39:39.180 --> 00:39:42.930
And even if it did take you somewhere,
let's say that you had a version

00:39:42.930 --> 00:39:46.500
of the model that had an address,
the resulting object is an object

00:39:46.500 --> 00:39:48.340
that lives in that context.

00:39:48.340 --> 00:39:51.310
And you can't just pluck an
object out of a context and

00:39:51.310 --> 00:39:52.590
stick it into another context.

00:39:52.680 --> 00:39:55.160
Objects belong to one specific context.

00:39:55.160 --> 00:39:58.060
So even if that were the case,
you can't just take that value

00:39:58.060 --> 00:39:59.150
and stick it into the address.

00:39:59.160 --> 00:40:03.000
What you really want to do is,
you want to answer the question,

00:40:04.310 --> 00:40:08.510
What was the address instance
that was created for this person?

00:40:08.800 --> 00:40:10.950
So you want to do a lookup.

00:40:11.190 --> 00:40:15.050
We do have a couple of lookup methods
in the Migration Manager class.

00:40:15.210 --> 00:40:18.520
So instead of using that expression,

00:40:18.680 --> 00:40:20.360
You will need to use
a function expression.

00:40:20.360 --> 00:40:23.160
Remember,
property mappings are just expressions

00:40:23.160 --> 00:40:24.470
that we're evaluating for you.

00:40:24.470 --> 00:40:28.040
So the function expression looks a
little more daunting here on the screen,

00:40:28.040 --> 00:40:32.710
but the mapping model of UI and
Xcode has a way for you to generate

00:40:32.910 --> 00:40:36.300
this without having to type this in.

00:40:36.300 --> 00:40:40.180
You only type in the essential element.

00:40:40.700 --> 00:40:43.410
So what the function
expression is saying is,

00:40:43.410 --> 00:40:46.250
I want you to execute
a call on the manager.

00:40:46.390 --> 00:40:49.260
This is where the $manager
access comes into play.

00:40:50.020 --> 00:40:52.880
The method that I want you to call is,
what is the destination for

00:40:52.960 --> 00:40:54.510
the entity given this source?

00:40:55.460 --> 00:40:58.850
So you're basically asking,
given this source and this mapping,

00:40:59.100 --> 00:41:02.370
when you were creating addresses
from persons given this source,

00:41:02.370 --> 00:41:04.420
what was the address you created?

00:41:05.670 --> 00:41:09.790
So that will result in
that instance over there.

00:41:10.870 --> 00:41:13.500
So and that is what we want
to bind in the relationship.

00:41:13.540 --> 00:41:17.360
So that's how you-- relationship
mappings are a little bit--

00:41:17.470 --> 00:41:19.950
they take one additional step.

00:41:21.620 --> 00:41:24.120
Migration logging,
it's a debugging mechanism.

00:41:24.150 --> 00:41:27.400
We do have a user default,
com.apple.core.data.migration.debug.

00:41:27.420 --> 00:41:31.570
Enable that if you want to see
what's going on during migration.

00:41:31.640 --> 00:41:34.560
It's mostly useful for the
bootstrapping phase of migration,

00:41:34.560 --> 00:41:38.050
when we're determining whether
the model is compatible or not,

00:41:38.060 --> 00:41:40.260
when we're looking for mapping models.

00:41:40.260 --> 00:41:44.940
So we do a lot of logging there,
and you can see whether,

00:41:45.120 --> 00:41:49.020
why we're not finding your mapping model,
or why we didn't find the right source

00:41:49.040 --> 00:41:51.560
model that you expected us to find.

00:41:54.040 --> 00:41:56.240
So that's it for
versioning and migration.

00:41:56.240 --> 00:41:59.040
We do the skew detection for
you based on the calculation

00:41:59.040 --> 00:42:02.500
of the version hash digest.

00:42:02.500 --> 00:42:05.870
And we do model-driven migration.

00:42:05.940 --> 00:42:08.040
In a lot of cases,
you don't have to write a

00:42:08.040 --> 00:42:11.300
lot of code or any code.

00:42:11.300 --> 00:42:15.250
You simply define it in the model,
and we do the migration for you.

00:42:15.260 --> 00:42:18.700
What we're trying to do in
Snow Leopard is to infer some of

00:42:18.850 --> 00:42:23.160
those mapping models in certain
scenarios so that you don't even have

00:42:23.170 --> 00:42:25.440
to specify the mapping model for us.

00:42:25.540 --> 00:42:27.030
But you still need the other things.

00:42:27.040 --> 00:42:28.720
You still need a source model.

00:42:28.720 --> 00:42:32.260
You still have to deal with versioning,
and you still have to be aware of that.

00:42:32.260 --> 00:42:36.530
We're just trying to be smarter about
inferring the kinds of changes you did.

00:42:36.610 --> 00:42:37.940
But that's a Snow Leopard thing.

00:42:37.940 --> 00:42:41.770
So for Leopard, you still have to provide
the mapping model for us.

00:42:45.640 --> 00:42:49.200
Moving on to the last topic,
multi-threading in the

00:42:49.200 --> 00:42:51.700
Core Data environment.

00:42:53.170 --> 00:42:57.540
What would be the motivations for wanting
to use multiple threads in Core Data?

00:42:57.540 --> 00:43:02.780
One of the main ones is that you probably
want to be more responsive in your UI.

00:43:02.780 --> 00:43:08.110
You know that you have a heavy
operation that you want to spin off

00:43:08.110 --> 00:43:11.980
into the background while you quickly
return to the user in your UI while

00:43:11.980 --> 00:43:14.270
stuff is happening behind the scenes.

00:43:14.300 --> 00:43:17.210
So that's one of the main
motivations that you have.

00:43:17.880 --> 00:43:21.160
We're shipping lots of hardware
with more and more cores each time,

00:43:21.160 --> 00:43:23.260
so you might want to
take advantage of that,

00:43:23.360 --> 00:43:24.300
leverage those.

00:43:24.360 --> 00:43:27.960
Or you can do a lot of importing,
heavy importing.

00:43:27.960 --> 00:43:32.010
If you're importing from some
sort of legacy data type,

00:43:32.120 --> 00:43:35.460
XML,
a lot of importing behind the scenes,

00:43:35.460 --> 00:43:40.000
you can do that by spinning off
a thread in the background while

00:43:40.000 --> 00:43:42.400
your UI remains responsive.

00:43:46.080 --> 00:43:48.990
One thing that you have to be aware of,
though, is that the fact that

00:43:49.160 --> 00:43:53.460
you spin off a thread,
this is not a magic solution.

00:43:53.460 --> 00:43:55.540
Just the fact that you created
a thread doesn't automatically

00:43:55.540 --> 00:43:56.760
make everything fast.

00:43:56.760 --> 00:43:59.520
Always keep in mind,
what are the contention issues

00:43:59.580 --> 00:44:02.790
between the two different
threads that you're creating?

00:44:02.790 --> 00:44:05.810
So you might have multiple threads,
but if they're all competing

00:44:05.810 --> 00:44:07.980
for the same resource,
they're just going to be

00:44:08.070 --> 00:44:10.190
staggering one after the other,
and it would be a

00:44:10.220 --> 00:44:11.960
sequential processing model.

00:44:13.210 --> 00:44:15.620
Here we have an extreme case of that.

00:44:15.690 --> 00:44:19.210
We created a simple program
where all we did is allocate

00:44:19.240 --> 00:44:20.820
memory in four different threads.

00:44:20.920 --> 00:44:24.270
In both cases, we're allocating memory
in four different threads.

00:44:24.330 --> 00:44:28.760
It's even a quad-core machine,
so we do have the hardware resources.

00:44:29.680 --> 00:44:33.120
But in the first case,
even though we have four threads,

00:44:33.120 --> 00:44:37.280
we're sharing a lock,
and we're sharing one single memory pool.

00:44:38.440 --> 00:44:41.140
And you can see that that case is
a lot slower than the second case

00:44:41.240 --> 00:44:42.200
where we have multiple threads.

00:44:43.140 --> 00:44:46.340
So we have multiple memory
pools and a single lock per

00:44:46.340 --> 00:44:48.390
each thread that we're using.

00:44:48.890 --> 00:44:51.090
You have four threads,
but if you're not smart about

00:44:51.300 --> 00:44:54.020
how you're going to be marshaling
between the shared resources,

00:44:54.020 --> 00:44:57.240
you're going to end up with
a lot worse performance.

00:44:57.240 --> 00:45:00.500
So always be aware of
where the bottleneck is.

00:45:03.500 --> 00:45:07.410
From Core Data's point of view,
the element that is thread

00:45:08.560 --> 00:45:09.970
safe is the object ID.

00:45:10.090 --> 00:45:12.810
So these are immutable objects
that you can pass back and forth

00:45:12.890 --> 00:45:16.710
between threads without worrying
too much about what happens to them.

00:45:16.720 --> 00:45:19.010
They can't change.

00:45:19.200 --> 00:45:21.940
The pattern that we
want you to use is to,

00:45:21.960 --> 00:45:26.550
if you do start using multi-threading,
is to have a separate context

00:45:26.620 --> 00:45:28.300
for each thread that you create.

00:45:28.520 --> 00:45:33.650
So you go ahead, spin off your threads,
but be sure to have a separate

00:45:33.760 --> 00:45:39.510
context for each one of those threads
so that what falls out of that...

00:45:39.850 --> 00:45:43.340
is that objects belong
to only one context,

00:45:43.340 --> 00:45:46.580
and consequently,
they only belong to one thread.

00:45:48.020 --> 00:45:51.210
And believe us,
this will make your life a lot easier,

00:45:51.210 --> 00:45:55.080
especially when you get down to
the debugging side of things.

00:45:55.080 --> 00:45:57.200
There's fewer interactions.

00:45:57.360 --> 00:45:59.610
You know that if you have
an instance of your object,

00:45:59.830 --> 00:46:03.640
the only code that could have changed
it is code that was executing in that

00:46:03.640 --> 00:46:06.670
single thread and not other things
that are coming in from other threads.

00:46:06.680 --> 00:46:10.310
It improves the locking because
you're not locking at a very

00:46:10.320 --> 00:46:13.040
fine-grained level at the object level.

00:46:13.040 --> 00:46:16.440
We can move the locking
up at a higher level.

00:46:16.640 --> 00:46:18.780
So there's more concurrency
that can happen.

00:46:18.780 --> 00:46:22.440
This is the thread confinement pattern.

00:46:25.700 --> 00:46:27.860
If you do follow this pattern,
there are certain things

00:46:27.910 --> 00:46:28.740
that we do for you.

00:46:28.740 --> 00:46:33.000
We take care of locking the
managed object context and the

00:46:33.000 --> 00:46:34.380
context and the coordinator.

00:46:34.380 --> 00:46:36.720
Every time we're
accessing the coordinator,

00:46:36.720 --> 00:46:38.430
we do take care of locking that.

00:46:38.560 --> 00:46:41.750
So even though you have multiple threads,
going back to what is

00:46:41.840 --> 00:46:46.260
the shared resource,
in the very simple form of this pattern,

00:46:46.260 --> 00:46:48.480
the shared resource is the
persistent store coordinator.

00:46:48.480 --> 00:46:49.220
Okay.

00:46:49.220 --> 00:46:52.060
So even though you have multiple
threads with multiple contexts,

00:46:52.270 --> 00:46:55.020
when they're getting to the coordinator,
for whatever reason,

00:46:55.090 --> 00:46:57.360
they're either fetching
or they're saving,

00:46:57.520 --> 00:47:00.380
that's when they're doing the locking,
and that's when they have to

00:47:00.380 --> 00:47:01.350
wait for the other threads.

00:47:01.460 --> 00:47:04.280
But we take care of doing that for you.

00:47:04.280 --> 00:47:06.790
So you don't have to
think in those terms.

00:47:06.800 --> 00:47:08.740
You simply do what you do,
and Core Data does

00:47:08.780 --> 00:47:09.990
that behind the scenes.

00:47:15.630 --> 00:47:17.290
Because that's a shared resource,
you might wonder, well,

00:47:17.290 --> 00:47:20.130
if I have multiple contexts and
multiple copies of my object,

00:47:20.240 --> 00:47:25.470
am I not duplicating my information?

00:47:26.010 --> 00:47:29.740
And you're duplicating some information
but not all of the information.

00:47:29.930 --> 00:47:33.840
If you remember back to the first section
that we talked about in the fetching,

00:47:33.910 --> 00:47:37.260
do you guys remember the row
cache and the row cache entries?

00:47:37.370 --> 00:47:40.560
So think of your managed
objects as kind of thin wrappers

00:47:41.090 --> 00:47:44.280
where anything that's heavy,
an image or strings,

00:47:44.340 --> 00:47:47.520
they're actually pointing to the
entries inside the row cache.

00:47:47.590 --> 00:47:49.810
These are shared copy on
write if you modify them,

00:47:49.810 --> 00:47:53.190
but so you're not really duplicating
all of your object information.

00:47:53.220 --> 00:47:56.690
They're being shared at the
persistent store coordinator level,

00:47:56.700 --> 00:47:59.680
and you simply have thin wrappers of them
that are existing in your application.

00:47:59.680 --> 00:48:02.300
in your context.

00:48:02.510 --> 00:48:05.460
So don't worry too much about this.

00:48:05.500 --> 00:48:08.900
Now, how do you want to communicate
information back and forth

00:48:09.020 --> 00:48:10.800
between one thread and the other?

00:48:10.850 --> 00:48:14.010
Remember that I said that the
thread-safe element that we're

00:48:14.110 --> 00:48:16.820
providing for you is the object ID.

00:48:16.960 --> 00:48:20.940
So this is what you pass over into
the other threads without worrying.

00:48:20.960 --> 00:48:23.670
And in the other thread,
what you do is that you use the method

00:48:23.670 --> 00:48:29.400
objectWithId to go get a local version
of that object in that context.

00:48:30.500 --> 00:48:33.790
Now you cannot pass objects that
have been recently inserted because

00:48:33.790 --> 00:48:37.680
they still don't exist down in
the coordinator side of things.

00:48:37.750 --> 00:48:43.620
But you can pass objects that
have been fetched or updated.

00:48:43.750 --> 00:48:48.760
So things that haven't been saved yet
are still not in a place where you

00:48:48.760 --> 00:48:50.920
can access them in separate threads.

00:48:51.040 --> 00:48:54.200
So let me show you an
animation of how this works.

00:48:55.240 --> 00:48:57.260
You decide to do background fetching.

00:48:57.430 --> 00:49:01.820
So you're going to have a main thread,
which in this case happens to be

00:49:01.820 --> 00:49:03.240
this one on the right-hand side.

00:49:03.240 --> 00:49:04.800
That's your UI.

00:49:04.800 --> 00:49:07.840
It's entertaining your user
so that they don't get bored.

00:49:07.840 --> 00:49:10.520
And behind the scenes,
you're doing a lot of heavy fetching.

00:49:10.520 --> 00:49:12.220
It's in a separate thread, right?

00:49:13.020 --> 00:49:15.580
You're done with the
fetching in thread one.

00:49:15.580 --> 00:49:18.890
Now you want to tell
thread two that it's ready.

00:49:18.890 --> 00:49:20.980
You can use that information.

00:49:20.980 --> 00:49:24.990
You can't pass the objects around
because those are not thread safe,

00:49:25.110 --> 00:49:26.700
but you can pass the object IDs.

00:49:26.700 --> 00:49:28.730
So you pass the object ID.

00:49:28.730 --> 00:49:31.780
The main thread takes that object ID.

00:49:33.330 --> 00:49:37.130
and request the corresponding
object and get a local copy

00:49:37.130 --> 00:49:40.170
of that object in the context.

00:49:40.240 --> 00:49:43.840
You will notice that when
I got that object information,

00:49:43.840 --> 00:49:45.320
I didn't go to the disk.

00:49:45.320 --> 00:49:48.890
Do you guys remember my first
slide where going to disk is

00:49:48.890 --> 00:49:50.480
thousands of times slower?

00:49:50.480 --> 00:49:53.990
I only went to the Rokash entries.

00:49:53.990 --> 00:49:56.510
So the fetching,
I did get the benefit of doing

00:49:56.510 --> 00:49:59.380
the prefetching behind the
scenes in the other thread,

00:49:59.740 --> 00:50:01.660
because even though I'm
recreating the objects,

00:50:01.660 --> 00:50:02.800
I'm going to the Rokash.

00:50:02.800 --> 00:50:08.420
Okay, so this is the shared resource
and the heavy hit on the I/O was

00:50:08.420 --> 00:50:13.200
taken by a background thread
while my UI was responsive.

00:50:13.200 --> 00:50:18.720
So this is the main pattern that you
will be using for multi-threading.

00:50:21.450 --> 00:50:26.700
We lock, so if you're accessing
the store coordinator,

00:50:26.700 --> 00:50:28.890
if you're messaging the
store coordinator explicitly,

00:50:28.900 --> 00:50:30.780
take care of that, of locking it.

00:50:30.780 --> 00:50:35.390
If you explicitly message it when
you're asking us to add a new store

00:50:35.390 --> 00:50:38.740
or you're getting object URIs,
when you're accessing

00:50:38.740 --> 00:50:41.130
the store coordinator,
just be sure to lock it.

00:50:41.460 --> 00:50:46.400
You might also want to lock it when
you want to group a set of operations

00:50:46.500 --> 00:50:50.720
and make those visible as a single
operation to the other threads.

00:50:50.830 --> 00:50:53.300
So you would lock the coordinator,
remember that's a shared resource,

00:50:53.300 --> 00:50:56.060
you do an insert, a save, a delete,
whatever else you want to do,

00:50:56.060 --> 00:50:58.590
and then you unlock the coordinator,
and then the other threads

00:50:58.590 --> 00:51:01.220
can't do anything at that
moment until you're done.

00:51:01.220 --> 00:51:05.420
So that's a way of creating the
illusion that this was one atomic thing.

00:51:08.090 --> 00:51:12.100
Another pattern that you might
want to follow is if you don't

00:51:12.100 --> 00:51:15.060
want the persistent store
coordinator to be your bottleneck,

00:51:15.060 --> 00:51:18.550
you might want to create
multiple Core Data stacks so that

00:51:18.860 --> 00:51:20.470
that's not the shared resource.

00:51:20.490 --> 00:51:23.100
So you would have multiple coordinators.

00:51:23.120 --> 00:51:27.060
Of course, now you're duplicating data,
right?

00:51:27.060 --> 00:51:29.580
Now you really are duplicating
the raw cache entry,

00:51:29.580 --> 00:51:32.010
so you really do have two
copies of your objects.

00:51:32.060 --> 00:51:36.560
But it might be the case where you know
that this thread is accessing one store

00:51:36.560 --> 00:51:37.980
and that thread is accessing another.

00:51:38.000 --> 00:51:40.330
So there won't be any conflict.

00:51:40.400 --> 00:51:43.480
So if there is a conflict
at the store level,

00:51:43.480 --> 00:51:45.310
then the shared resource is the file.

00:51:45.310 --> 00:51:48.000
So there's always a shared
resource at some point.

00:51:50.980 --> 00:51:54.280
There's actually an example of doing
multi-threaded background fetching.

00:51:54.280 --> 00:51:56.460
The animated slide I showed
you two slides ago,

00:51:56.460 --> 00:51:57.470
it's on your systems.

00:51:57.470 --> 00:51:59.880
This isn't something that
you have to download.

00:51:59.880 --> 00:52:02.840
You can just go to Developer, Examples,
Core Data, Background Fetching,

00:52:02.840 --> 00:52:05.610
and you can see the
code for doing all this,

00:52:05.610 --> 00:52:09.980
passing the IDs around and then
getting the fully realized objects

00:52:09.980 --> 00:52:12.390
with the ID in a separate thread.

00:52:15.430 --> 00:52:19.330
Wrapping up,
some general Core Data threading

00:52:19.430 --> 00:52:21.650
tips in Cocoa.

00:52:21.760 --> 00:52:24.980
If you're doing undo,
the default settings for the undo manager

00:52:24.980 --> 00:52:27.660
are not compatible with multi-threading.

00:52:27.730 --> 00:52:30.810
So you want to disable that
in the context by setting

00:52:30.810 --> 00:52:32.720
the undo manager to nil.

00:52:32.720 --> 00:52:37.500
The groups by event is not thread safe,
so you want to not use that and manage

00:52:37.660 --> 00:52:41.120
the grouping of the undo by hand.

00:52:41.160 --> 00:52:45.030
So you can't do it,
you just have to do it by hand.

00:52:45.700 --> 00:52:49.400
And the second thing about spawning
off threads is that the threads

00:52:49.710 --> 00:52:51.410
that you're creating are detached.

00:52:51.410 --> 00:52:55.820
What that means is that the main process,
once they're created,

00:52:55.820 --> 00:52:59.400
it's not worrying about whether
they're done with their work or

00:52:59.400 --> 00:53:01.600
not before the main process quits.

00:53:01.600 --> 00:53:04.690
So they go away, they're detached,
so it's not my responsibility.

00:53:04.690 --> 00:53:05.990
If I want to quit, I quit.

00:53:06.500 --> 00:53:09.030
So be careful about what
those threads are doing.

00:53:09.030 --> 00:53:12.490
Because if they're doing
something that is important,

00:53:12.510 --> 00:53:16.410
such as saving or leaving your
data in an inconsistent state,

00:53:16.440 --> 00:53:19.120
you don't want the main process to quit.

00:53:19.290 --> 00:53:21.610
So you have to implement additional code.

00:53:21.610 --> 00:53:23.460
This is your responsibility.

00:53:23.460 --> 00:53:25.790
So that the main process
is always checking,

00:53:25.810 --> 00:53:28.180
hey, are you done with what you're doing?

00:53:28.180 --> 00:53:29.200
Because I'm about to quit.

00:53:29.360 --> 00:53:32.250
So don't, don't,
this is your responsibility.

00:53:32.250 --> 00:53:34.740
Remember, they're detached threads.

00:53:36.460 --> 00:53:38.910
In some cases,
you don't care if you quit because

00:53:38.910 --> 00:53:44.020
the work that you're doing behind the
scenes is work that you can throw away.

00:53:44.120 --> 00:53:47.400
You're doing background fetching,
you're doing cleanup, you don't care.

00:53:47.400 --> 00:53:49.950
Tear the process down.

00:53:49.970 --> 00:53:52.230
You're not going to leave your
data in an inconsistent state.

00:53:52.240 --> 00:53:57.390
So it's a good thing in some cases.

00:54:00.130 --> 00:54:05.590
There's also, as of 10.5,
there's NSOperationQueue,

00:54:05.590 --> 00:54:11.060
which is a mechanism that you can use
to model these dependencies between

00:54:11.060 --> 00:54:15.300
tasks so that the main task does not
quit until the other subtasks are done.

00:54:15.300 --> 00:54:18.940
So it's a convenient Cocoa API for
modeling the dependencies.

00:54:18.970 --> 00:54:21.180
You can wait for completion.

00:54:21.200 --> 00:54:25.360
You can say this task depends on this,
and now I have to wait until it's done.

00:54:26.040 --> 00:54:30.410
You can even, you have mechanisms for
suspending tasks that are running.

00:54:30.410 --> 00:54:35.680
So look into this as something
that you would use for your

00:54:35.780 --> 00:54:39.080
threads to be communicating so
that the main process doesn't

00:54:39.080 --> 00:54:41.210
quit and leave you in a bad state.

00:54:43.810 --> 00:54:47.100
If you want to introspect the
hardware that you're running in,

00:54:47.100 --> 00:54:52.310
you have access to that information
via Process Info or SysControl by name.

00:54:52.580 --> 00:54:55.460
So you can ask what your hardware is.

00:54:55.460 --> 00:54:59.220
You can't just pawn off threads if you
don't have the right number of cores

00:54:59.220 --> 00:55:01.780
or you have a limited set of resources.

00:55:01.930 --> 00:55:04.810
If you want to ask, here's how you ask.

00:55:06.880 --> 00:55:10.500
And just like the first slide
where I hope everybody realizes

00:55:10.500 --> 00:55:14.800
that going to the I/O is slow,
I hope everybody realizes too that

00:55:14.940 --> 00:55:18.040
multi-threading is not a trivial thing.

00:55:18.090 --> 00:55:19.260
You don't just spawn off a thread.

00:55:19.330 --> 00:55:21.080
So educate yourself.

00:55:21.330 --> 00:55:23.960
Here are two references
that we recommend.

00:55:24.020 --> 00:55:27.080
Even though the first book
has Java in the title,

00:55:27.080 --> 00:55:31.990
it's a more general software
engineering book with how to

00:55:32.250 --> 00:55:36.780
program with multiple threads,
independently of the language,

00:55:36.780 --> 00:55:38.400
so that's a good overview.

00:55:38.400 --> 00:55:43.720
The second book is more of a
pattern style kind of book.

00:55:43.810 --> 00:55:49.290
And we also have documentation on the
ADC website for multi-threading topics.

00:55:51.290 --> 00:55:55.650
So one last thing here, information that
I referenced in this talk.

00:55:55.710 --> 00:56:00.090
A lot of what I talked about, in fact,
I think everything,

00:56:00.090 --> 00:56:03.700
a lot more of that is in the
Core Data Programming Guide.

00:56:03.700 --> 00:56:07.600
This is a 180-plus page document
that you have on your system.

00:56:07.600 --> 00:56:08.850
It's very detailed.

00:56:08.850 --> 00:56:12.100
It gives you a lot of advanced
information on Core Data.

00:56:12.100 --> 00:56:13.260
There's a bunch of tutorials.

00:56:13.260 --> 00:56:16.270
There's two examples I talked
about that are on your system,

00:56:16.340 --> 00:56:19.920
the background fetching and the
iClass for the fetch properties.

00:56:20.400 --> 00:56:25.230
And there's two examples associated
with this session on the ADC website,

00:56:25.250 --> 00:56:29.950
the GoFetch to play around with the
fetch request options and the derived

00:56:29.950 --> 00:56:35.160
properties for normalizing textual
data when you're doing the searches.

00:56:38.350 --> 00:56:40.470
And like I said,
this is number two of three

00:56:40.720 --> 00:56:41.720
of Core Data sessions.

00:56:41.720 --> 00:56:45.870
At five in the Marina conference room,
there will be the last Core Data session.

00:56:45.990 --> 00:56:48.900
This will be the schema modeling session.

00:56:48.900 --> 00:56:52.040
And all of the Core Data team
will be available to you tomorrow,

00:56:52.040 --> 00:56:56.880
right before you get drunk
between 2:00 and 4:00.

00:56:57.090 --> 00:56:58.930
The beer bash is tomorrow, I believe,
right?

00:56:59.040 --> 00:57:03.260
So we have four hours of not
being drunk before we go,

00:57:03.260 --> 00:57:06.390
where you can ask us questions.

00:57:08.000 --> 00:57:14.060
and our evangelist, Michael Jurowicz,
and send us bug reports and/or

00:57:14.060 --> 00:57:17.430
use the Cocoa Dev discussion list
for answering more questions.
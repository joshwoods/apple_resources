WEBVTT

00:00:20.510 --> 00:00:24.800
Well, hello, everyone, and welcome.

00:00:24.800 --> 00:00:26.040
I'd like to welcome all of you.

00:00:26.040 --> 00:00:27.160
Look at this room.

00:00:27.280 --> 00:00:29.600
I mean, there are so many of you here.

00:00:29.600 --> 00:00:32.440
You guys are -- I just
perhaps want to start,

00:00:32.790 --> 00:00:33.980
congratulate all of you.

00:00:34.000 --> 00:00:36.760
You're here at the birth of a
new industry for the iPhone.

00:00:36.870 --> 00:00:39.790
So give yourselves a round of applause.

00:00:43.870 --> 00:00:45.870
So my name is Allan Schaffe,
I'm Apple's Graphics

00:00:46.060 --> 00:00:47.230
Technology Evangelist.

00:00:47.230 --> 00:00:48.890
In a few minutes,
I'll be joined by Kevin,

00:00:48.970 --> 00:00:52.700
who's a graphics engineer with
us and one of the authors of the

00:00:52.830 --> 00:00:56.800
Touch Fighter demo that you may
have seen around the show earlier.

00:00:57.050 --> 00:00:58.630
Yeah, sure.

00:00:58.910 --> 00:01:00.750
Go ahead.

00:01:02.900 --> 00:04:53.200
[Transcript missing]

00:04:53.390 --> 00:04:54.240
All right.

00:04:54.280 --> 00:04:57.930
Also, another element of the iPhone
is the ability to do networking.

00:04:58.020 --> 00:04:58.860
And you've seen this.

00:04:59.010 --> 00:05:03.140
And so this is something that has
a direct applicability for sort of

00:05:03.140 --> 00:05:06.250
classic games like chess and checkers,
backgammon,

00:05:06.400 --> 00:05:10.560
all those kinds of games where
you're competing against an opponent.

00:05:10.940 --> 00:05:13.570
But then likewise,
just the ability to have big

00:05:13.750 --> 00:05:17.710
multiplayer games is available to
you on the iPhone or with the iPhone.

00:05:17.710 --> 00:05:20.910
And so, you know,
I can start to imagine games coming

00:05:20.910 --> 00:05:25.510
out where you're competing in a sports
arena or a multi-level dungeon or at

00:05:25.510 --> 00:05:29.590
a poker table or some other kind of
game where you're competing against

00:05:29.930 --> 00:05:32.510
or with or against multiple opponents.

00:05:34.930 --> 00:05:42.900
The iPhone has the ability
to know its current location.

00:05:42.940 --> 00:05:46.090
This is something that games haven't
really taken advantage of in the

00:05:46.200 --> 00:05:49.650
past because console games are
plugged into your television set,

00:05:49.650 --> 00:05:53.480
and your computer games are probably
on your desk or on your laptop.

00:05:53.480 --> 00:05:58.660
But just the ability to have a
game that knows its location maybe

00:05:58.660 --> 00:06:02.790
expands the realm of games that
you can do beyond just simply

00:06:02.960 --> 00:06:04.940
porting a game over to the iPhone.

00:06:04.960 --> 00:06:09.350
Think in terms of new capabilities
that you might be able to put

00:06:09.350 --> 00:06:12.390
into a game that you have,
or new ideas.

00:06:12.440 --> 00:06:15.710
The first thing that comes to mind
with a lot of location-based games

00:06:15.710 --> 00:06:17.520
are sort of like treasure hunts.

00:06:17.560 --> 00:06:23.380
But imagine any kind of a game that
you're able to change the gameplay.

00:06:23.480 --> 00:06:25.580
Depending on where the user is.

00:06:25.640 --> 00:06:29.340
And that opens up a whole
new realm of possibilities.

00:06:29.340 --> 00:06:33.480
And I think it's a territory that
hasn't really been captured yet,

00:06:33.520 --> 00:06:37.490
and so there's a lot of opportunity
for you as developers to do that.

00:06:39.650 --> 00:06:41.860
I've mentioned, you know,
kind of going over to

00:06:41.860 --> 00:06:44.440
the technology side,
the high-resolution display.

00:06:44.440 --> 00:06:48.320
So, you know, the iPhone,
it has a big display, it's bright,

00:06:48.390 --> 00:06:53.540
it's high contrast, 160 DPI,
the resolution is 320 by 480.

00:06:53.540 --> 00:06:56.480
And so, you know, when we've been working
with mobile developers,

00:06:56.480 --> 00:06:59.310
they're looking at that and going like,
wow, this is great.

00:06:59.410 --> 00:07:01.690
You know,
they're scaling up their artwork,

00:07:01.710 --> 00:07:04.440
they're adding complexity
into their gameplay.

00:07:04.440 --> 00:07:06.990
And then likewise,
kind of related to this,

00:07:06.990 --> 00:07:10.470
the whole thing is being
driven by a screaming fast GPU.

00:07:10.470 --> 00:07:14.290
And I think you saw yesterday
during the keynote some of the

00:07:14.290 --> 00:07:17.410
examples there of just very,
very powerful graphics.

00:07:17.460 --> 00:07:20.130
We're going to be talking about
OpenGL ES in just a moment,

00:07:20.130 --> 00:07:22.820
and so we'll be showing you
a bit about how that's done.

00:07:24.760 --> 00:07:28.340
A number of media technologies
are available in the iPhone SDK,

00:07:28.340 --> 00:07:32.720
and in this session, really,
what we're going to be talking about are

00:07:33.180 --> 00:07:35.040
those topics that I've just mentioned.

00:07:35.040 --> 00:07:40.360
So input, networking,
and then things that you see here.

00:07:40.400 --> 00:07:45.410
And so OpenGL ES for 3D graphics,
Core Audio, and OpenAL for audio

00:07:45.920 --> 00:07:49.470
playback and recording,
and the Media Player Framework

00:07:49.670 --> 00:07:53.710
for full-screen video playback,
especially for cut scenes.

00:07:53.720 --> 00:07:57.310
In this particular session,
we're not going to have time to get

00:07:57.450 --> 00:07:59.500
into Quartz 2D or Core Animation.

00:07:59.780 --> 00:08:02.810
Those are things that you would
typically be using perhaps for a 2D game.

00:08:02.920 --> 00:08:05.420
And so -- but there's a
lot of sessions here at the

00:08:05.460 --> 00:08:07.280
conference about those as well.

00:08:07.280 --> 00:08:11.860
We're just going to be screaming
through a lot of different topics.

00:08:12.470 --> 00:08:17.280
So if you had a chance to see
the iPhone SDK launch event that

00:08:17.330 --> 00:08:20.350
took place a few months ago,
the demo that we showed

00:08:20.350 --> 00:08:24.050
there was one that,
as I said, was developed by Kevin and

00:08:24.050 --> 00:08:25.940
some of his colleagues.

00:08:26.090 --> 00:08:29.600
We called it Touch Fighter,
and this is a space fighting game.

00:08:30.700 --> 00:08:33.400
It took about two weeks to put together.

00:08:33.400 --> 00:08:36.460
Kevin has had a little more
time to work on it since then,

00:08:36.460 --> 00:08:39.320
and so here at the show,
we're going to be showing you, of course,

00:08:39.320 --> 00:08:41.440
Touch Fighter 2 today in this session.

00:08:41.440 --> 00:08:45.730
And this is really the example that
we're using to demonstrate a lot

00:08:45.910 --> 00:08:47.980
of the capabilities in the SDK.

00:08:48.090 --> 00:08:50.360
And so with that,
I'd like to bring up Kevin to

00:08:50.360 --> 00:08:51.980
show you Touch Fighter 2.

00:08:53.810 --> 00:08:56.130
Thanks, Sebastian.

00:08:56.140 --> 00:08:57.730
Yeah.

00:08:57.740 --> 00:08:59.220
Thank you, Alan.

00:08:59.220 --> 00:09:01.990
So the iPhone is a fantastic
platform for games.

00:09:02.000 --> 00:09:07.400
And this is because you have this unique
set of features that Alan just presented.

00:09:07.400 --> 00:09:12.640
And so it makes it a great
target for game play innovation.

00:09:12.980 --> 00:09:18.080
And so what we try to do in TouchFader
was to take most of this feature in a

00:09:18.100 --> 00:09:20.450
demo and to see how far we could go.

00:09:20.710 --> 00:09:25.030
So I'm going to demonstrate in details
what we have behind TouchWater 2.

00:09:28.870 --> 00:09:33.980
Let me go on the demo unit.

00:09:38.520 --> 00:09:40.860
Okay, can we go to the demo machine,
please?

00:09:40.860 --> 00:09:42.010
Okay, thank you.

00:09:42.120 --> 00:09:42.590
So here we are.

00:09:42.700 --> 00:09:45.640
So we have a new multiplayer mode
that we're not going to demo now,

00:09:45.640 --> 00:09:47.220
but maybe later.

00:09:47.220 --> 00:09:49.700
So I'm going to start as a single player.

00:09:49.700 --> 00:09:51.770
And so here you see Touch Fader.

00:09:51.910 --> 00:09:54.180
You see these beautiful graphics.

00:09:54.240 --> 00:09:57.440
And so how do I control the ship?

00:09:57.550 --> 00:10:02.330
So I steer and I use the accelerometer
to steer and move around.

00:10:02.330 --> 00:10:06.400
And so it's very nice
and it's very responsive.

00:10:06.400 --> 00:10:08.380
It's smooth yet.

00:10:08.430 --> 00:10:09.470
It's responsive.

00:10:09.470 --> 00:10:12.160
It's very nice to control,
very nice way to control

00:10:12.160 --> 00:10:13.810
the ship and very intuitive.

00:10:13.810 --> 00:10:16.150
So to fire now,
I can simply tap the screen.

00:10:16.250 --> 00:10:19.430
So I tap on the right side of the
screen to fire from the right.

00:10:19.450 --> 00:10:22.570
I tap from the left side of the
screen to fire from the left.

00:10:22.620 --> 00:10:24.960
And you know, that's kind of fun.

00:10:24.960 --> 00:10:30.580
So you see, you can hear right now,
sorry, the 3D positional sound.

00:10:30.580 --> 00:10:33.900
So as I go around,
the thrust of the ship gets

00:10:33.930 --> 00:10:37.040
panned and specialized via OpenAL.

00:10:37.040 --> 00:10:40.870
So in the same way,
the lasers get panned and specialized.

00:10:40.870 --> 00:10:45.720
The explosions are also located in space.

00:10:45.720 --> 00:10:48.220
So it's a very nice and it's
a very immersive experience.

00:10:48.220 --> 00:10:51.840
So I can do that.

00:10:51.840 --> 00:10:56.390
So what we did also in Touch Fader
is to integrate gestures to target

00:10:56.390 --> 00:10:58.000
specific moves and special moves.

00:10:58.000 --> 00:11:00.050
So for instance,
if I do an up swipe here,

00:11:00.050 --> 00:11:04.990
I'm throwing directly at missiles.

00:11:04.990 --> 00:11:04.990
And that's stunning.

00:11:06.500 --> 00:11:08.000
It's really nice.

00:11:08.000 --> 00:11:12.340
Again, I send the missiles from the left,
I hear from the right.

00:11:12.340 --> 00:11:13.500
It's very intuitive.

00:11:13.500 --> 00:11:18.940
You see these amazing graphics,
all these particle systems going on.

00:11:18.940 --> 00:11:21.230
I'm on fire,
but because it's a demo game and

00:11:21.230 --> 00:11:27.740
I can die and there's just one level,
I'm not really scared about that.

00:11:28.100 --> 00:11:29.000
So here you go.

00:11:29.000 --> 00:11:34.820
So you can also bring UI kit views,
so a scenic space where

00:11:34.820 --> 00:11:36.710
I can put some information.

00:11:36.750 --> 00:11:38.950
For instance, here,
let me show the frame per second

00:11:38.990 --> 00:11:40.460
counter and some gesture data.

00:11:40.460 --> 00:11:44.400
And what you can see is that even
with all this graphic and all

00:11:44.400 --> 00:11:47.660
this blending and stuff going on,
we're still pretty steady

00:11:47.660 --> 00:11:48.760
at 30 frames per second.

00:11:48.760 --> 00:11:49.550
So it's very nice.

00:11:49.550 --> 00:11:51.340
It's a very powerful
GPU that we have here.

00:11:51.340 --> 00:11:54.800
And you see this little mark here
that allows me to debug gesture,

00:11:54.800 --> 00:11:55.800
for instance.

00:11:57.280 --> 00:12:00.240
So some of the things we
did in Touch Fader is to add

00:12:00.240 --> 00:12:02.180
some ability to calibrate.

00:12:02.180 --> 00:12:04.960
So for instance,
here I'm in that location,

00:12:04.960 --> 00:12:08.820
but I might want to change
position as I play the game.

00:12:08.820 --> 00:12:11.240
So for instance, if I sit,
so I can go over here,

00:12:11.240 --> 00:12:15.100
and Touch Fader automatically detects
that you're in a new location under

00:12:15.100 --> 00:12:16.990
a new inclination and recalibrates.

00:12:17.000 --> 00:12:19.800
So it's very nice to allow
your gamer to do that,

00:12:19.800 --> 00:12:23.220
and we'll go more in detail on
how we did that and discuss that

00:12:23.250 --> 00:12:24.740
matter later in the presentation.

00:12:26.460 --> 00:12:29.980
So...

00:12:31.440 --> 00:12:34.690
So now I can do the final move that
leads me directly to the end of

00:12:34.700 --> 00:12:40.730
that one level demo game by doing a
two finger upswipe that is sending

00:12:40.730 --> 00:12:44.130
me directly to the end sequence.

00:12:48.900 --> 00:12:51.810
So you have a clean transition,
and here you have right now an X264

00:12:51.810 --> 00:12:53.880
movie playing right up in the game.

00:12:53.920 --> 00:13:01.050
So no PngR, X264 movie as a cutscene,
and here I have some advice from Apple.

00:13:03.110 --> 00:13:03.710
OK.

00:13:04.000 --> 00:13:04.840
And I tap the screen.

00:13:04.890 --> 00:13:05.650
I have high scores.

00:13:05.740 --> 00:13:07.380
So here again, some view.

00:13:07.380 --> 00:13:10.980
I can tap my name,
and a keyboard shows up,

00:13:10.980 --> 00:13:12.050
so I can change eventually.

00:13:12.160 --> 00:13:13.900
So here, that's a good one.

00:13:13.910 --> 00:13:14.560
I'm at rank two.

00:13:14.560 --> 00:13:17.120
I'm the only one better
than Steve in that game.

00:13:17.240 --> 00:13:18.620
So yeah.

00:13:19.040 --> 00:13:19.500
So here you go.

00:13:19.520 --> 00:13:21.720
That's "Dash Powder 2."

00:13:30.100 --> 00:13:32.780
So we learned a lot in
doing TouchFatter 2.

00:13:32.780 --> 00:13:36.900
And so it's a great integrator
of all these great iPhone

00:13:36.900 --> 00:13:38.460
features and technologies.

00:13:38.560 --> 00:13:40.660
And so we say, well,
it'd be great if you could share what

00:13:40.660 --> 00:13:44.540
we learned so you can-- and hopefully
it's going to help you in your own games.

00:13:44.540 --> 00:13:47.350
So what we're going to
do today here at WGBC,

00:13:47.350 --> 00:13:53.160
we're going to make the
TouchFatter source available.

00:13:57.030 --> 00:13:57.890
Thank you.

00:13:57.900 --> 00:14:00.920
So hopefully, we hope you like it and
you'll be able to find what's,

00:14:00.950 --> 00:14:03.660
you know,
some content that you can include

00:14:03.660 --> 00:14:04.880
and integrate in your own games.

00:14:04.920 --> 00:14:07.810
And so what we're going to do today
is that we're going to go through all

00:14:07.860 --> 00:14:11.610
the basics of the iPhone technologies
and APIs to get you started in

00:14:11.610 --> 00:14:15.180
doing your games on the iPhone that
leverage all these key technologies.

00:14:15.180 --> 00:14:17.880
And we're going to point
you to relevant sample code,

00:14:17.880 --> 00:14:21.360
so to the APIs, to relevant sample code,
and to locations within the

00:14:21.360 --> 00:14:24.060
Touch Fighter source that
are relevant and that serves

00:14:24.200 --> 00:14:25.810
the purpose we're discussing.

00:14:27.150 --> 00:14:32.290
So first, let me talk about drawing.

00:14:32.520 --> 00:14:35.290
So drawing is the first thing you do,
first thing you want to

00:14:35.300 --> 00:14:36.380
do generally in a game.

00:14:36.380 --> 00:14:41.220
And you have lots of different
drawing APIs on the iPhone that

00:14:41.300 --> 00:14:43.460
targets each specific needs that
you might have in your game.

00:14:43.460 --> 00:14:47.070
So the one you're already
familiar with is UIKit.

00:14:47.230 --> 00:14:51.140
So UIKit is this API and framework
responsible for all these nice

00:14:51.140 --> 00:14:53.800
controls and views on the phone.

00:14:53.800 --> 00:14:58.470
And it's built over Quartz
2D and core animation.

00:14:59.340 --> 00:15:03.240
So Quartz 2D is this API that
does 2D graphic generation,

00:15:03.240 --> 00:15:08.300
so text and lines and
gradients and are anti-aliased,

00:15:08.300 --> 00:15:10.730
so it looks very nice,
and also PDF support.

00:15:10.740 --> 00:15:15.550
And core animation is the
low-level API that's responsible

00:15:15.690 --> 00:15:21.430
for this fluid interaction that
you see all around the iPhone OS.

00:15:21.540 --> 00:15:25.940
And core animation talks
directly to the display hardware,

00:15:25.940 --> 00:15:27.920
so it's some sort of the
iPhone windowing system.

00:15:28.350 --> 00:15:29.970
So animation and compositing engine.

00:15:30.000 --> 00:15:33.720
And so that's where everybody goes.

00:15:33.720 --> 00:15:35.700
Everything goes to core animation.

00:15:35.700 --> 00:15:37.260
That's the real power of the platform.

00:15:38.730 --> 00:15:41.550
Now if you want to do 3D graphics,
so you have OpenGL,

00:15:41.550 --> 00:15:44.160
OpenGL ES on the iPhone, and Eagle.

00:15:44.160 --> 00:15:48.760
So Eagle is a new API specific
to the iPhone that makes the

00:15:48.790 --> 00:15:53.780
connection between OpenGL ES render
content and core animation.

00:15:53.820 --> 00:15:58.980
So OpenGL took directly to the graphics
hardware to be hardware accelerated to do

00:15:58.980 --> 00:16:01.710
these very nice and very fast graphics.

00:16:01.940 --> 00:16:04.650
So and then you have, for video playback,
you have the media player that

00:16:04.650 --> 00:16:07.820
takes directly to the video
hardware for hardware accelerated

00:16:07.830 --> 00:16:10.400
video playback and decompression.

00:16:12.090 --> 00:16:16.480
So now let me focus on OpenGL ES.

00:16:16.480 --> 00:16:21.200
So OpenGL ES is a high-performance
3D graphics API for embedded devices.

00:16:21.320 --> 00:16:25.330
And feature-wise,
it's very close to OpenGL 1.5

00:16:25.780 --> 00:16:29.550
fixed function pipeline,
so minus programmability on the desktop.

00:16:30.890 --> 00:16:35.740
And OpenGL for hardware acceleration
uses the iPhone PowerVR NBX Live GPU,

00:16:35.740 --> 00:16:40.670
which is a very powerful GPU for embedded
devices that maximize performance

00:16:40.670 --> 00:16:42.890
while minimizing power consumption.

00:16:42.900 --> 00:16:46.800
And to do that,
it uses two key technologies on that GPU,

00:16:46.960 --> 00:16:51.780
which are the Tile-Based Deferred
Renderer and Hidden Surface Removal,

00:16:51.920 --> 00:16:53.200
so TBDR and HSR.

00:16:53.260 --> 00:16:58.250
And so what these technologies are, TBDR,
is that the renderer, so the iPhone,

00:16:58.340 --> 00:17:00.680
the OpenGL context,
will be split into tiles.

00:17:00.700 --> 00:17:04.790
And each of these tiles will process
the visible triangles and discard

00:17:04.840 --> 00:17:07.980
the triangles that are hidden.

00:17:07.990 --> 00:17:09.660
So this before rasterization.

00:17:09.700 --> 00:17:13.120
And that makes it different from the
GPUs that you have on the desktop,

00:17:13.580 --> 00:17:16.570
because, for instance,
some invisible triangle

00:17:16.570 --> 00:17:17.690
will be discarded.

00:17:17.820 --> 00:17:19.990
So saving rasterization
on these triangles,

00:17:19.990 --> 00:17:23.690
and for instance, if a texture is hidden,
it will never get uploaded.

00:17:23.700 --> 00:17:26.100
So that saves bandwidth,
that saves power,

00:17:26.100 --> 00:17:29.700
and so that's a very powerful
technique on that particular GPU.

00:17:30.700 --> 00:17:34.700
And so that's the
Hidden Surface Removal part.

00:17:34.700 --> 00:17:37.200
And so the Deferred part means
that some things are going to be

00:17:37.200 --> 00:17:39.700
decided only at the render phase,
for instance, texture uploads.

00:17:39.700 --> 00:17:41.990
And so that means that if
you come to the desktop,

00:17:42.060 --> 00:17:45.700
you might organize your OpenGL comment
stream in some different manner.

00:17:45.700 --> 00:17:50.660
So we'll go in that section on
what it implies to be optimal on

00:17:50.660 --> 00:17:53.620
embedded devices on that iPhone.

00:17:53.720 --> 00:17:59.620
So Eagle is what connects the
OpenGL render content onto Core NMS.

00:18:00.700 --> 00:18:02.710
And so Core NMS is
basically a core animation,

00:18:02.710 --> 00:18:04.650
this iPhone composite windowing system.

00:18:04.800 --> 00:18:08.430
And it's pretty much
equivalent to NSOpenGL,

00:18:08.430 --> 00:18:13.600
CGL on the desktop, on the Mac desktop,
and other platforms.

00:18:13.720 --> 00:18:16.700
And so it connects to Core NMS using
the framebuffer object extension

00:18:16.700 --> 00:18:20.700
to connect the OpenGL render
content to Core NMS surfaces.

00:18:20.700 --> 00:18:24.910
And so it's a new API on the iPhone,
but we made it very easy

00:18:25.030 --> 00:18:28.690
for you to leverage,
so to get started in OpenGL ES.

00:18:28.700 --> 00:18:30.700
So with a little bit of a break,
I'll just show you a

00:18:30.700 --> 00:18:30.700
little bit of a demo.

00:18:30.820 --> 00:18:32.830
So you have the Xcode template,
that is the

00:18:32.890 --> 00:18:34.700
Cocoa Touch OpenGL application.

00:18:34.790 --> 00:18:37.620
So you just open Xcode, create a new
Cocoa Touch OpenGL application,

00:18:37.700 --> 00:18:39.700
and it sets everything up.

00:18:39.700 --> 00:18:43.700
So you have on the Eagle side,
on the Core animation side.

00:18:43.700 --> 00:18:46.590
And so you can get started
and start doing OpenGL code by

00:18:46.590 --> 00:18:48.700
implementing the draw view method.

00:18:48.700 --> 00:18:51.470
So by default, the template is drawing
a quad that is rotating.

00:18:51.700 --> 00:18:54.270
So that's simple,
but that's great to get started

00:18:54.270 --> 00:18:56.220
and to start writing some OpenGL.

00:18:56.500 --> 00:19:00.940
So the next thing you want
to do in OpenGL is going to

00:19:00.940 --> 00:19:03.020
be to bring in some assets,
some textures.

00:19:03.020 --> 00:19:06.830
And so similarly,
we made it very easy to bring in some

00:19:06.830 --> 00:19:10.890
textures using a texture 2D alpha
class that is shared among samples.

00:19:11.040 --> 00:19:14.520
So it's used in Touchpadder,
it's used in the crash landing sample,

00:19:14.520 --> 00:19:18.260
and it's very easy to create
a texture from an image path

00:19:18.360 --> 00:19:20.730
or something in your resource,
in your project,

00:19:20.740 --> 00:19:24.400
or including your project,
or from some data,

00:19:24.400 --> 00:19:27.820
but also from CG images or
UI images from the system.

00:19:27.820 --> 00:19:33.420
So it's very easy to create a
texture in OpenGL from the image file

00:19:33.420 --> 00:19:34.750
and format that you already have.

00:19:35.490 --> 00:19:39.230
Similarly, it's also easy to create a
texture containing a text

00:19:39.230 --> 00:19:41.570
string using this alpha class.

00:19:41.730 --> 00:19:44.410
You can create a string
with arbitrary font,

00:19:44.410 --> 00:19:47.640
size, dimensions,
and then also very easy to draw

00:19:47.640 --> 00:19:48.270
using some simple textures.

00:19:48.330 --> 00:19:52.780
convenience methods that draw
in the current OpenGL context.

00:19:53.130 --> 00:19:56.440
So the iPhone uses a
shared memory system,

00:19:56.440 --> 00:19:59.060
so all applications and
OpenGL use the shared memory,

00:19:59.060 --> 00:20:02.220
the same memory,
and as a consequence of that,

00:20:02.280 --> 00:20:05.890
the memory limited to OpenGL,
so surface and texture,

00:20:05.890 --> 00:20:07.600
is limited to 24 megabytes.

00:20:07.750 --> 00:20:10.790
So you really need to only,
so it's very important to

00:20:10.790 --> 00:20:12.740
only use the memory you need.

00:20:12.800 --> 00:20:16.680
And so there's this great texture
compression format specific

00:20:16.680 --> 00:20:19.640
to the GPU on the iPhone,
which is called PVRTC,

00:20:19.640 --> 00:20:22.220
that we really recommend you choose.

00:20:22.670 --> 00:20:24.780
It's really powerful,
and you can only win by

00:20:24.780 --> 00:20:26.190
using PRTC compression.

00:20:26.200 --> 00:20:30.380
So you win in performance,
you win in power conception,

00:20:30.490 --> 00:20:32.610
you reduce the memory
bandwidth that you use,

00:20:32.750 --> 00:20:34.520
and the memory footprint.

00:20:34.520 --> 00:20:36.230
So you win on every side.

00:20:36.260 --> 00:20:38.140
So it's really nice,
it's really powerful,

00:20:38.220 --> 00:20:39.880
and so we recommend you to use that.

00:20:39.880 --> 00:20:42.560
There is a texture tool,
a common line utility,

00:20:42.560 --> 00:20:45.950
that allows you to convert main
known image file formats onto a

00:20:46.040 --> 00:20:48.180
PVRTC compressed texture format.

00:20:48.180 --> 00:20:52.380
And then there's also a simple
pixel format in texture.

00:20:52.510 --> 00:20:54.810
So it's a texture tool that allows
you to create a texture to the object

00:20:54.980 --> 00:20:57.960
from that compressed texture file.

00:20:58.040 --> 00:21:01.900
But also you can look in the texture
to the source to know the OpenGL code.

00:21:01.900 --> 00:21:05.250
It's also very simple,
just a GL text image line and parameter.

00:21:05.320 --> 00:21:09.260
So really use PVRTC format texture.

00:21:11.140 --> 00:21:14.950
So if you want to go further in OpenGL,
there are some very nice

00:21:15.050 --> 00:21:17.680
sample applications that are
a great place to get started.

00:21:17.900 --> 00:21:21.140
So GL Paint will allow you to connect
that with multi-touch to stretch your

00:21:21.170 --> 00:21:23.100
fingers and to have it drawn in OpenGL.

00:21:23.140 --> 00:21:26.570
And also Crash Landing,
which is a very nice and very simple

00:21:26.600 --> 00:21:31.860
OpenGL ES-based game that leverages
Texture 2D following all the assets,

00:21:31.900 --> 00:21:35.720
OpenAIL for sound,
and Accelerometer for control.

00:21:36.020 --> 00:21:39.080
So it's a very simple application
that sets the things so

00:21:39.080 --> 00:21:42.700
you can really follow them,
and it's a great place to get started

00:21:42.700 --> 00:21:45.170
in OpenGL games on the iPhone.

00:21:45.380 --> 00:21:47.930
So that's it for the assets.

00:21:48.030 --> 00:21:51.660
So you have texture 2D that
helps you to load textures,

00:21:51.680 --> 00:21:55.100
so the maximum texture size is 1K by 1K.

00:21:55.100 --> 00:21:58.660
And so for 3D content,
what we did in TouchFader is to

00:21:58.660 --> 00:22:04.290
use the existing exporters from
the 3D modelers that you have

00:22:04.360 --> 00:22:08.910
to export into known formats,
vertices, and C file formats.

00:22:09.010 --> 00:22:10.380
So you can import that in the game.

00:22:10.380 --> 00:22:12.170
So you can use that.

00:22:12.230 --> 00:22:15.300
Or you, game developer,
already have a pipeline,

00:22:15.300 --> 00:22:16.180
a 3D pipeline in place.

00:22:16.180 --> 00:22:20.280
So it should be very easy to pour
that pipeline onto the iPhone to

00:22:20.280 --> 00:22:22.980
getting your 3D assets in the game.

00:22:23.110 --> 00:22:26.440
So the iPhone uses a shared
memory system and 24 megabytes

00:22:26.440 --> 00:22:28.400
of texture and surface memory.

00:22:28.400 --> 00:22:30.880
And after loading texture,
because the memory is shared,

00:22:30.980 --> 00:22:33.190
so deallocate -- don't keep
two copies of the same object.

00:22:33.310 --> 00:22:38.480
So deallocate the copy
once you're on the GPU.

00:22:38.480 --> 00:22:38.480
And that's coming soon.

00:22:38.770 --> 00:22:43.770
And now some tips specific
to the PowerVR MBX Live GPU.

00:22:43.800 --> 00:22:48.940
So as I said,
the PowerVR MBX Live GPU used

00:22:48.940 --> 00:22:51.320
two technologies,
so tile-based deferred renderer

00:22:51.320 --> 00:22:53.400
and hidden surface removal.

00:22:53.620 --> 00:22:59.140
And so this requires that you
might want to organize your common

00:22:59.460 --> 00:23:04.680
stream differently so that it makes
it easy for the GPU to render,

00:23:04.680 --> 00:23:05.560
so more efficient.

00:23:05.700 --> 00:23:09.600
And one thing you can do is
to draw first opaque geometry,

00:23:09.600 --> 00:23:13.440
so the hidden surface removal thing can
work and disregard the good triangle,

00:23:13.440 --> 00:23:14.600
and then blended geometry.

00:23:14.700 --> 00:23:17.920
So there's lots of sorting you
can do to get optimal performance,

00:23:18.000 --> 00:23:22.060
and that's one first sorting
that gives you good performance.

00:23:22.130 --> 00:23:26.880
And then because everything is delayed,
for instance, texture uploads,

00:23:26.950 --> 00:23:32.640
so it's some operation,
just like GL Text Subimage,

00:23:32.640 --> 00:23:35.640
have the same performance
that GL Redpixel,

00:23:35.640 --> 00:23:37.300
that depends on the
rendering destination.

00:23:37.300 --> 00:23:39.640
So you should be careful on
that particular GPU of the

00:23:39.740 --> 00:23:40.900
expense of these operations.

00:23:41.050 --> 00:23:44.520
So GL Text Subimage, GL Redpixel,
all these operations that depends

00:23:44.590 --> 00:23:48.240
on the render content are expensive.

00:23:48.240 --> 00:23:50.780
And also, so avoid 2D state changes,
for instance,

00:23:50.780 --> 00:23:54.200
viewport and caesars state changes.

00:23:54.280 --> 00:24:00.040
So OpenGL ES is going to be the most
efficient way to do most of your work,

00:24:00.040 --> 00:24:02.400
in particular compositing.

00:24:02.490 --> 00:24:05.130
So really,
we recommend to use full screen

00:24:05.130 --> 00:24:10.740
OpenGL context with-- so avoid to
go towards core animation to do

00:24:10.740 --> 00:24:14.180
compositing when you don't have to,
when it's not needed.

00:24:14.180 --> 00:24:17.700
So do the most compositing you can
in OpenGL for maximum performance,

00:24:17.830 --> 00:24:20.100
in particular,
the landscape orientation in games,

00:24:20.100 --> 00:24:23.670
if you want to do that net orientation,
do that within OpenGL,

00:24:23.760 --> 00:24:27.220
so changing the metrics and
not using core animation.

00:24:27.350 --> 00:24:32.560
So then again, use PVRTC and MIP maps,
which are pretty much a zero cost

00:24:32.730 --> 00:24:36.490
performance-wise on that GPU,
just a little-- memory footprint,

00:24:36.490 --> 00:24:39.450
but it's great for image
quality to have MIP maps using

00:24:39.450 --> 00:24:42.980
that parameter in the game.

00:24:43.730 --> 00:24:50.460
So other tips now specific to
OpenGL ES that also link to the

00:24:50.460 --> 00:24:55.270
embedded world is to minimize
the number of state changes.

00:24:55.360 --> 00:24:59.780
So eventually, consider sorting your
render objects per state.

00:24:59.780 --> 00:25:03.210
So first,
running some objects in some model view,

00:25:03.340 --> 00:25:05.890
so the blended objects, as we said.

00:25:05.900 --> 00:25:10.060
So the object with lighting on,
with the depth testing on, and so on.

00:25:10.060 --> 00:25:12.470
So to minimize the number
of call that you send to the

00:25:12.470 --> 00:25:14.060
framework that have an overhead.

00:25:14.220 --> 00:25:16.320
So sorting is a way to do it.

00:25:16.380 --> 00:25:20.660
Another way to do it is another option
is also to a complementary option.

00:25:20.680 --> 00:25:24.360
And so to consider caching the
current GL state in the code,

00:25:24.420 --> 00:25:30.030
so to intercept it before it goes to the
framework so you can store the current

00:25:30.140 --> 00:25:35.300
base address or the current vertex array,
the current bound texture,

00:25:35.300 --> 00:25:37.350
that sort of thing.

00:25:37.470 --> 00:25:41.080
And also, so you use a lot of vertex
array in OpenGL ES-based games.

00:25:41.160 --> 00:25:45.920
So maximize the OpenGL,
the GL draw efficiency by minimizing the

00:25:45.920 --> 00:25:47.780
number of draw records that you make.

00:25:47.780 --> 00:25:49.540
And to do that, there are some tricks.

00:25:49.660 --> 00:25:55.210
So you can use the general triangle
method to put multiple strips together

00:25:55.210 --> 00:25:59.400
and to send them with one draw record.

00:25:59.450 --> 00:26:02.420
And that's what we do in TouchFader
for all the particle system going on.

00:26:02.420 --> 00:26:06.520
It's just one draw record when
they're the same color and so on.

00:26:06.530 --> 00:26:08.020
So that's a big win.

00:26:08.020 --> 00:26:10.440
And also, so use indices.

00:26:10.550 --> 00:26:16.700
And so only leave the required state on,
in particular, lighting and blending,

00:26:16.700 --> 00:26:21.050
because the fill rate is
something that you need to watch.

00:26:21.130 --> 00:26:25.820
So use bending carefully to have the
hidden surface removal on the GPU.

00:26:25.820 --> 00:26:30.400
That is not going to
work when blending is on.

00:26:30.400 --> 00:26:33.720
And finally,
when you play a movie-- so a movie,

00:26:33.720 --> 00:26:39.200
for instance, an x264 movie requires the
current frame to be present,

00:26:39.200 --> 00:26:40.270
but also other frames.

00:26:40.360 --> 00:26:44.470
So a lot of memory needs to be
allocated to play the movie optimally.

00:26:44.660 --> 00:26:48.120
And so in that case,
if performance is an issue,

00:26:48.120 --> 00:26:50.820
you might want to consider
releasing your GL objects and

00:26:50.820 --> 00:26:53.440
eventually the whole GL context.

00:26:53.440 --> 00:26:55.360
So before playing the
good scene in TouchFader,

00:26:55.360 --> 00:26:59.150
we release everything to play the movie,
before playing the movie.

00:26:59.920 --> 00:27:04.960
And now let me have a little
overview of how we organize that

00:27:05.060 --> 00:27:06.800
within the TouchPattern source.

00:27:06.800 --> 00:27:18.100
So can I please go onto this machine,
please?

00:27:26.680 --> 00:27:29.890
Thank you,
so here we have the-- let me go

00:27:29.890 --> 00:27:32.220
to application didFinishLaunching.

00:27:32.260 --> 00:27:37.050
We have the application delegate
class that does all the work of

00:27:37.050 --> 00:27:41.040
setting up and organizing the
big structural part of the game.

00:27:41.040 --> 00:27:44.240
So in application didFinishLaunching,
we set up some properties

00:27:44.240 --> 00:27:45.120
on the animation.

00:27:45.120 --> 00:27:46.740
We create the window.

00:27:46.740 --> 00:27:48.400
We set the background color.

00:27:48.400 --> 00:27:51.040
We create the game view,
that is the open GLES base view

00:27:51.040 --> 00:27:55.350
that will do all the main actions,
the main part of the game here.

00:27:55.440 --> 00:27:57.060
So we add this as a subview.

00:27:57.060 --> 00:27:59.170
Then we turn on multi-touch on that view.

00:27:59.280 --> 00:28:01.560
We'll talk about that later.

00:28:01.660 --> 00:28:05.600
So the big part is that we initialize the
timer that we call the gameLoot method

00:28:05.600 --> 00:28:08.660
at a particular interval that you set.

00:28:08.660 --> 00:28:11.780
Then we just start everything,
make the window visible.

00:28:12.160 --> 00:28:16.810
So if we look at the game loop,
which is right up there,

00:28:16.860 --> 00:28:20.300
so the game loop is simply
calling the game loop method,

00:28:20.380 --> 00:28:22.920
associate game loop method,
on the game view,

00:28:22.920 --> 00:28:28.090
and when the game is over,
it's calling this play movie method.

00:28:28.400 --> 00:28:32.180
So if we go to this play movie method,
that's really the next part of the game.

00:28:32.180 --> 00:28:34.840
Whenever you won,
the mothership had exploded,

00:28:34.840 --> 00:28:38.000
and so you get into the exclusive
for movie playback part.

00:28:38.180 --> 00:28:41.090
So we release the timer,
and eventually the network

00:28:41.170 --> 00:28:42.420
timer in multiplayer.

00:28:42.460 --> 00:28:47.200
We set the background color to white
color for good transition into the movie.

00:28:47.260 --> 00:28:50.740
Then we release the view,
remove it from Super Viewer, release it.

00:28:50.790 --> 00:28:55.140
We generate the high scores to store
the high scores while the movie plays.

00:28:55.140 --> 00:28:57.530
Then we set up the end movie.

00:28:57.620 --> 00:29:02.570
And very simply,
we can start the movie by calling

00:29:02.570 --> 00:29:03.960
the play method on that movie.

00:29:03.960 --> 00:29:05.960
So boom, and it plays.

00:29:06.000 --> 00:29:10.110
And associate to the end movie
playback didFinishNotification,

00:29:10.110 --> 00:29:14.320
a selector that would be called
whenever the movie stopped

00:29:14.320 --> 00:29:18.600
playing so we can go into the
full screen into the high scores.

00:29:19.060 --> 00:29:22.980
So if I go to the movie
ended method here,

00:29:22.980 --> 00:29:25.420
so this movie ended
method creates an image,

00:29:25.460 --> 00:29:31.170
a UI image view from these little Winner
don't use drugs screens that we show

00:29:31.170 --> 00:29:34.580
up here with just these four lines.

00:29:34.580 --> 00:29:37.420
And then we add -- we
also show the high scores,

00:29:37.430 --> 00:29:39.710
so we add it as a sub view,
but these high scores are actually

00:29:39.710 --> 00:29:41.180
not visible at this current time.

00:29:41.180 --> 00:29:44.680
They're outside the main display,
the main rectangle of the display.

00:29:44.680 --> 00:29:50.050
So what we do in these high scores,
here we implement the touches began

00:29:50.050 --> 00:29:55.540
method that whenever we tap the screen,
we'll create this background

00:29:55.540 --> 00:29:59.320
view with the sheep rotating,
so open GLES view,

00:29:59.320 --> 00:30:04.700
and we'll begin an animation
to bring everything on display.

00:30:04.700 --> 00:30:09.720
So in the current rectangle,
visible rectangle.

00:30:09.720 --> 00:30:13.350
Then we create this view that
allows you to enter your name

00:30:13.350 --> 00:30:15.940
whenever you are in the high scores.

00:30:16.180 --> 00:30:19.180
good enough player in Touch Fighter.

00:30:19.730 --> 00:30:24.070
So now let's have a simple
peek at the main 3D view,

00:30:24.070 --> 00:30:25.320
the game view.

00:30:25.430 --> 00:30:30.600
So here in the initWithFrame method,
we allocate all the necessary objects

00:30:30.600 --> 00:30:32.620
and set the associated OpenGL state.

00:30:32.620 --> 00:30:36.910
So here we set the lights, the lighting,
then we create all the

00:30:36.910 --> 00:30:38.700
textures using texture2Ds.

00:30:38.700 --> 00:30:39.680
We set some parameters.

00:30:39.700 --> 00:30:41.280
We set the cameras.

00:30:41.280 --> 00:30:44.640
We create the star field.

00:30:44.850 --> 00:30:48.560
So we create the cube map here.

00:30:48.560 --> 00:30:53.830
So PVR4 on the iPhone
and PNG on the simulator.

00:30:53.870 --> 00:30:58.060
Then we create the little nice planet.

00:30:58.060 --> 00:31:00.140
So all these resources are located here.

00:31:00.140 --> 00:31:00.850
We set them.

00:31:00.940 --> 00:31:01.460
We allocate.

00:31:01.460 --> 00:31:01.960
We create them.

00:31:01.960 --> 00:31:03.280
We set the position, velocity scale.

00:31:03.280 --> 00:31:04.280
So the same for everything.

00:31:04.280 --> 00:31:07.900
So here the enemies and-- so
here the enemy is a spaceship.

00:31:08.030 --> 00:31:11.320
So we also create the
accelerometer instance.

00:31:11.320 --> 00:31:13.060
That would get us the
accelerometer data here.

00:31:13.060 --> 00:31:15.780
Set the smoothing and sensitivity values.

00:31:15.780 --> 00:31:16.500
The gestures.

00:31:16.540 --> 00:31:18.540
And then we--

00:31:19.250 --> 00:31:28.100
So we restore the NSUserDefault
that stores the settings pane.

00:31:28.100 --> 00:31:32.330
And then we have the UpdateScene method
that updates whatever needs to be

00:31:32.330 --> 00:31:33.750
updated to the position of the objects.

00:31:34.400 --> 00:31:39.130
And then the RenderScene method that
renders using OpenGL all these objects.

00:31:39.140 --> 00:31:44.020
And all these UpdateScene and
RenderScene methods are called through

00:31:44.030 --> 00:31:48.910
the GameLoop method in the view,
so we can have the rendering on and off.

00:31:48.920 --> 00:31:55.000
So these are the key and
core elements of TouchWriter.

00:31:55.000 --> 00:31:59.000
So let me go back to slides, please.

00:32:00.610 --> 00:32:02.760
Okay,
so that was the TouchHunter 2 code tour.

00:32:02.820 --> 00:32:04.780
So you really see the
big elements of the game.

00:32:04.780 --> 00:32:09.350
It's pretty simple to get all that
things together thanks to Core Animation,

00:32:09.350 --> 00:32:14.290
which makes it very easy to bring in any
kind of content in the same application.

00:32:14.300 --> 00:32:16.340
So you don't have to
choose one technology.

00:32:16.340 --> 00:32:19.240
You can bring them all
together smoothly and animated.

00:32:19.240 --> 00:32:23.500
And so it's a very powerful
part of the iPhone.

00:32:24.690 --> 00:32:27.180
In particular,
it's very easy to bring UI key controls.

00:32:27.180 --> 00:32:30.860
So you can use programmatically.

00:32:30.930 --> 00:32:33.330
You can create other views and so on,
just like you're used to do.

00:32:33.430 --> 00:32:36.060
But so you can bring them in.

00:32:36.060 --> 00:32:39.460
It's very nice to bring in
native UI inside a game.

00:32:39.460 --> 00:32:45.200
But also you can design your
UI in an interface builder.

00:32:45.200 --> 00:32:47.060
For instance, the settings pane,
that's what we do.

00:32:47.060 --> 00:32:47.980
It's just a Nib file.

00:32:47.980 --> 00:32:49.500
The high score, the same thing.

00:32:49.500 --> 00:32:50.340
It's a Nib file.

00:32:50.340 --> 00:32:53.140
So just in one line,
we can create a UI view

00:32:53.140 --> 00:32:54.600
from that Nib file.

00:32:54.620 --> 00:32:56.610
And bring it into the game.

00:32:56.620 --> 00:33:00.650
So if you want to animate it,
we simply add this view,

00:33:00.650 --> 00:33:02.440
add a subview of a current
application window.

00:33:02.440 --> 00:33:07.160
And we begin an animation and set
it from a point outside the display

00:33:07.160 --> 00:33:08.120
to a point inside the display.

00:33:08.120 --> 00:33:11.500
And in four lines, we have some Nib file
coming into the game.

00:33:11.500 --> 00:33:14.450
So as we said before,
this sort of compositing

00:33:14.450 --> 00:33:15.580
might be an issue.

00:33:15.580 --> 00:33:18.680
So if you have expensive rendering,
you might want to pause

00:33:18.690 --> 00:33:20.560
it or that sort of things.

00:33:20.560 --> 00:33:22.560
Or reduce it or be aware of it at least.

00:33:22.560 --> 00:33:24.290
So that's really nice.

00:33:24.620 --> 00:33:26.590
And then to play movies.

00:33:26.640 --> 00:33:28.500
So playing movies.

00:33:28.650 --> 00:33:30.620
So movies play full screen.

00:33:30.620 --> 00:33:32.590
They take the whole display.

00:33:32.660 --> 00:33:34.620
You can set some properties
on how the scaling is made.

00:33:34.620 --> 00:33:36.620
And if you want some
HUD display and so on.

00:33:36.620 --> 00:33:42.620
And it's great to enhance
the visual quality of a game.

00:33:42.620 --> 00:33:46.500
To punctuate the cutscenes,
the big start screen, the end screens.

00:33:46.630 --> 00:33:48.620
And so on.

00:33:48.620 --> 00:33:51.170
To really add some very nice
visual content and create an

00:33:51.170 --> 00:33:52.580
engaging experience in games.

00:33:52.660 --> 00:33:54.540
So that's really nice.

00:33:54.620 --> 00:33:56.620
And so very easy to bring
in a movie in a game.

00:33:56.620 --> 00:34:02.620
You simply create a mpmovieplayer
controller instance from a URL.

00:34:02.620 --> 00:34:06.520
And then you can set optional
properties on that instance.

00:34:06.640 --> 00:34:12.620
And then you need to listen to the
mpmovieplayback.didfinish notification.

00:34:12.620 --> 00:34:18.620
So that your current application is
called whenever the movie stops playing.

00:34:18.620 --> 00:34:20.620
So it can start up whenever you were.

00:34:20.620 --> 00:34:22.610
And then you just need to call
the play method on that instance.

00:34:22.730 --> 00:34:24.620
And boom, the movie starts playing.

00:34:24.620 --> 00:34:26.620
Start playing full screen.

00:34:26.620 --> 00:34:28.610
And that's as easy as it can be.

00:34:28.620 --> 00:34:32.330
When that's done,
so the callback will be called

00:34:32.480 --> 00:34:34.620
once the movie starts playing.

00:34:34.620 --> 00:34:38.380
So you can start up your pngel context,
your 3D content,

00:34:38.770 --> 00:34:40.620
or whatever you want to start up again.

00:34:44.290 --> 00:34:49.380
So lots of sessions on graphics
on the iPhone today and tomorrow,

00:34:49.540 --> 00:34:53.600
3D, 2D, graphics animation,
control views,

00:34:53.600 --> 00:34:57.670
and video delivery on the iPhone that
we recommend you to go check out.

00:34:57.760 --> 00:35:03.780
So these are a great complement
of that current session.

00:35:06.790 --> 00:35:10.460
So now let me talk about inputs.

00:35:10.540 --> 00:35:15.120
So the iPhone is a fantastic platform
because it has this unique way of

00:35:15.140 --> 00:35:18.800
getting data and of controlling a game,
of getting data into a game,

00:35:18.800 --> 00:35:20.420
and of controlling the game.

00:35:20.430 --> 00:35:22.160
In particular, multi-touch.

00:35:22.280 --> 00:35:24.460
So multi-touch is great.

00:35:24.460 --> 00:35:25.670
So it's super intuitive.

00:35:25.770 --> 00:35:29.520
So you can really touch the action
when it happens on the screen.

00:35:29.520 --> 00:35:33.580
You can move objects on the
display directly in the game.

00:35:33.710 --> 00:35:37.800
So you can also create some new ways,
some new hot zones, or some new controls.

00:35:37.950 --> 00:35:40.920
For instance, you type on the right,
and it fires from the right,

00:35:40.920 --> 00:35:41.780
that sort of thing.

00:35:41.780 --> 00:35:45.660
So you don't need-- you can
bypass the usual controllers.

00:35:45.690 --> 00:35:46.740
And that's very intuitive.

00:35:46.740 --> 00:35:48.390
That's very nice.

00:35:48.730 --> 00:35:53.080
Another thing you can do with
multi-touch are gestures.

00:35:53.100 --> 00:35:56.050
And so gesture is the evolution,
so the trajectory of

00:35:56.150 --> 00:35:57.630
the finger over time.

00:35:57.750 --> 00:36:01.310
And so that's very nice for
games because you can actually

00:36:01.310 --> 00:36:03.450
create some special moves.

00:36:03.540 --> 00:36:05.800
For instance,
let's imagine in a golf game,

00:36:05.800 --> 00:36:10.690
you can just describe the swing
and how accurate the swing is,

00:36:10.690 --> 00:36:12.760
how good the swing is
going to be in the game.

00:36:12.760 --> 00:36:15.540
You can do some punches
in some boxing game.

00:36:15.540 --> 00:36:16.660
And that's other things.

00:36:16.660 --> 00:36:19.950
And you can also use the gesture
that you're already familiar with,

00:36:20.050 --> 00:36:23.240
for instance, swipes and rotates,
as we did in Touch Fire,

00:36:23.240 --> 00:36:27.900
to throw some special weapons,
like missiles and so on.

00:36:27.900 --> 00:36:29.890
So let me--

00:36:43.340 --> 00:36:48.480
So main concepts in multi-touch,
so an event and a touch.

00:36:48.480 --> 00:36:53.130
So an event is shared over the
application and among all the

00:36:53.180 --> 00:36:54.570
views in the current application.

00:36:54.590 --> 00:36:59.300
And they contain all the information
on the current touch event going on.

00:36:59.430 --> 00:37:02.680
So they contain all the touch
instances of the current event.

00:37:04.280 --> 00:37:06.500
So the touch is contained
within an event,

00:37:06.500 --> 00:37:09.220
contain the information
on a particular finger.

00:37:09.420 --> 00:37:14.620
So the location, the phase,
the number of taps, and the timestamp.

00:37:15.100 --> 00:37:18.040
So how to get multi-touch in your game?

00:37:18.040 --> 00:37:22.910
So first on the view,
to get it in the view,

00:37:22.910 --> 00:37:25.940
you set the multi-touch enable
methods to yes on that view.

00:37:25.940 --> 00:37:31.110
And then the touches begin, touches move,
and touches ended methods of

00:37:31.230 --> 00:37:35.030
UI Responder will be called whenever
the phase of the current event,

00:37:35.030 --> 00:37:36.900
so touch event, is changing.

00:37:37.700 --> 00:37:42.520
So it allows you to follow
the event over time.

00:37:42.520 --> 00:37:46.450
And so the event will always
contain all the touches,

00:37:46.450 --> 00:37:50.660
and the first argument of these touches
began will be a set that contains

00:37:50.660 --> 00:37:54.370
the subset of these touches of the
event that match the particular phase.

00:37:54.400 --> 00:37:59.110
So let's say I start touching the screen,
so the touch began will be called

00:37:59.110 --> 00:38:02.810
with a set of the first touch,
and as the first argument and

00:38:02.860 --> 00:38:07.170
the event containing that touch,
I touch the screen a second time,

00:38:07.180 --> 00:38:07.680
and the touch will be called.

00:38:07.700 --> 00:38:10.540
So the touches began will be
called with first argument,

00:38:10.790 --> 00:38:13.720
this only second finger,
and the event containing the two fingers.

00:38:13.800 --> 00:38:16.690
And when I move the screen,
the touches move will be

00:38:16.970 --> 00:38:20.400
called with both two fingers on
both arguments of the method.

00:38:20.520 --> 00:38:21.610
So you get the idea.

00:38:21.620 --> 00:38:24.970
So it's really easy to get some
multi-touch into a game and to

00:38:25.030 --> 00:38:31.030
start creating some interesting
interaction with a game.

00:38:31.880 --> 00:38:36.200
So if you want to now do gestures.

00:38:36.200 --> 00:38:39.850
So to do gestures,
you need to connect the current

00:38:39.900 --> 00:38:42.640
touch with the previous touch to
create some trajectories and to

00:38:42.720 --> 00:38:45.700
understand the trajectories of
that trajectory evolve over time.

00:38:45.700 --> 00:38:48.110
And so to do that, so it's very easy.

00:38:48.110 --> 00:38:52.060
You get the touch instance from
the current set to your method,

00:38:52.160 --> 00:38:54.120
and you get this location.

00:38:54.380 --> 00:38:57.680
And then to connect that location
to the previous location.

00:38:57.680 --> 00:39:00.360
So there's similarly this
previous location in view method

00:39:00.360 --> 00:39:01.630
that allows you to connect it.

00:39:01.640 --> 00:39:07.270
Or you can similarly simply keep a
cache of the current touch instances,

00:39:07.370 --> 00:39:11.600
current touch objects,
because they will remain the

00:39:11.600 --> 00:39:13.890
same all around the event.

00:39:13.900 --> 00:39:19.450
So the touch object will remain the
same per finger all along touch events.

00:39:19.540 --> 00:39:20.400
You can track it that way.

00:39:20.440 --> 00:39:24.360
So it's pretty easy to get this.

00:39:24.360 --> 00:39:25.880
And so to do that, you can connect these
gestures into a game.

00:39:26.000 --> 00:39:28.470
And so to go further,
there are these sample applications,

00:39:28.500 --> 00:39:29.310
which are great.

00:39:29.730 --> 00:39:31.810
Touches for multi-touch tracking.

00:39:31.840 --> 00:39:33.480
So it's very nice.

00:39:33.480 --> 00:39:38.460
It allows you to follow and
understand whatever touch things

00:39:38.460 --> 00:39:44.230
you're doing correspond to what
phase and what method gets called.

00:39:44.500 --> 00:39:48.010
And so it shows that to you
in a HUD on the application.

00:39:48.020 --> 00:39:50.750
So the moveme tracks a view
and do some animations.

00:39:50.750 --> 00:39:51.420
It's nice.

00:39:51.500 --> 00:39:57.510
So in TouchFader,
we did some lot of work to analyze

00:39:57.560 --> 00:40:02.620
gestures and map them to known
swipes and rotates and so on.

00:40:02.680 --> 00:40:06.500
In particular, in the gesture class in
the TouchFader source,

00:40:06.860 --> 00:40:11.930
you can get the gesture type
as soon as it's recognized.

00:40:12.030 --> 00:40:13.640
So it can be a swipe or rotate.

00:40:13.640 --> 00:40:15.360
And it's going to tell you the angle.

00:40:15.360 --> 00:40:18.980
So absolute,
complete angle and the center.

00:40:19.010 --> 00:40:23.980
So you can really start doing
some nice things from there.

00:40:23.980 --> 00:40:26.130
And in particular,
you can build from there to

00:40:26.270 --> 00:40:30.700
create and to analyze more complex
gesture or texture that you like.

00:40:30.740 --> 00:40:34.300
So that's it for multi-touch.

00:40:36.540 --> 00:40:39.380
Now, let me talk about accelerometer.

00:40:39.380 --> 00:40:44.220
So accelerometer,
it's a fantastic controller.

00:40:44.220 --> 00:40:47.340
It's a fantastic way to control
the game because it's so natural.

00:40:47.340 --> 00:40:50.060
In Touch Fighter,
you can just move around

00:40:50.060 --> 00:40:52.290
to steer the ship,
but in a racing game,

00:40:52.290 --> 00:40:54.230
you can also throttle and brake.

00:40:54.320 --> 00:40:56.480
In a boxing game,
you can swing and punch,

00:40:56.480 --> 00:40:57.660
that sort of things.

00:40:57.680 --> 00:41:00.070
And it's very intuitive
and it's very nice.

00:41:00.180 --> 00:41:02.540
It's just you do something and
you have immediately the effect

00:41:02.540 --> 00:41:04.900
in the game and you understand
what's going on right away.

00:41:06.500 --> 00:41:09.230
So it's a very powerful
way to control a game.

00:41:09.550 --> 00:41:13.340
You can use that as a controller,
but you can also use that as a way

00:41:13.340 --> 00:41:16.390
to design some unique input method.

00:41:16.490 --> 00:41:20.560
For instance, you can flip to jump or
shake to reload again,

00:41:20.780 --> 00:41:21.590
that sort of thing.

00:41:21.680 --> 00:41:26.610
So it's really nice.

00:41:27.940 --> 00:41:34.320
The accelerometer data is
three-axis information that you get,

00:41:34.440 --> 00:41:37.320
which is the current orientation,
the vector of the current

00:41:37.460 --> 00:41:38.900
acceleration on the phone.

00:41:39.060 --> 00:41:42.580
It's stored in a UI acceleration
instances with three

00:41:42.580 --> 00:41:45.080
read-only properties,
X, Y, Z.

00:41:45.130 --> 00:41:51.190
And so that's pretty simple to get
information on what the current

00:41:51.190 --> 00:41:54.900
acceleration is in your game to start
using that as a way to control it.

00:41:55.580 --> 00:42:00.950
So first, you send the delegate method on
shared accelerometer instance to

00:42:00.950 --> 00:42:04.870
your class that will get called.

00:42:04.880 --> 00:42:09.030
So the accelerometer didAccelerate
method will be called on that class

00:42:09.150 --> 00:42:14.750
at an interval that you can choose by
sending the updateInterval property

00:42:15.300 --> 00:42:18.780
on the shared accelerometer instance.

00:42:19.020 --> 00:42:22.310
So the accelerometer didAccelerate
method will be called at this

00:42:22.310 --> 00:42:25.310
frequency and will contain,
as the second argument,

00:42:25.490 --> 00:42:27.810
the current acceleration,
so your acceleration that you

00:42:27.810 --> 00:42:30.180
can query for the xyz value.

00:42:32.430 --> 00:42:34.900
So to go further,
there's some great sample,

00:42:34.940 --> 00:42:39.760
in particular the accelerometer graph,
that tells you and allows you to

00:42:39.760 --> 00:42:43.360
understand what the accelerometer sees,
what the accelerometer doesn't see.

00:42:43.360 --> 00:42:46.250
In particular,
it's doing a graph of XYZ values

00:42:46.250 --> 00:42:48.320
of the current acceleration.

00:42:48.320 --> 00:42:51.210
And so in particular,
you'll see that the acceleration

00:42:51.210 --> 00:42:54.620
is invariant as you rotate
around the current acceleration.

00:42:54.640 --> 00:42:57.380
So that sort of motion will not
be seen by the accelerometer.

00:42:57.380 --> 00:42:59.970
Other things, so, I mean,
game developers know

00:42:59.970 --> 00:43:01.580
always lots of its physics.

00:43:02.140 --> 00:43:07.180
But, so, it's going to be pretty trivial,
but if you move at constant velocity,

00:43:07.180 --> 00:43:09.860
so acceleration is constant,
so it's not going to change in

00:43:09.860 --> 00:43:11.280
constant velocity displacements.

00:43:11.280 --> 00:43:15.130
So something that you can see by
playing with this accelerometer graph,

00:43:15.130 --> 00:43:16.510
a sample application.

00:43:16.560 --> 00:43:19.690
Another simple sample application,
which weighs up,

00:43:19.690 --> 00:43:23.950
shows you how to connect accelerometer
values to orientation on the UI.

00:43:25.670 --> 00:43:31.100
Okay, and so in Touch Fatter,
we did a lot of work to get

00:43:31.100 --> 00:43:34.660
accelerometer as a controller right.

00:43:34.690 --> 00:43:38.850
So in particular,
so accelerometer gives you

00:43:38.850 --> 00:43:40.460
raw value of the acceleration.

00:43:40.550 --> 00:43:44.380
And so to get a very smooth
control in your game,

00:43:44.380 --> 00:43:48.580
you need to find the good compromise
between smoothing and responsiveness.

00:43:48.580 --> 00:43:52.280
And so that means that you want to smooth
the data to get some smooth interaction,

00:43:52.280 --> 00:43:54.860
but too much smoothing will
make it less responsive.

00:43:54.860 --> 00:43:57.750
So what we did,
the solution we found in Touch Fatter

00:43:57.750 --> 00:44:01.980
was to do a little bit of smoothing,
but also some noise reduction,

00:44:01.980 --> 00:44:07.250
some signal processing very targeted at
noise reduction to get this very nice,

00:44:07.510 --> 00:44:11.970
smooth, yet responsive control and
interaction with the game.

00:44:11.980 --> 00:44:13.180
So it's really nice.

00:44:13.280 --> 00:44:15.700
There's this accelerometer
smoother class.

00:44:15.700 --> 00:44:18.910
We did a lot of work there,
so we encourage you to have a look.

00:44:19.030 --> 00:44:21.430
It feels really nice
when you play the game.

00:44:21.430 --> 00:44:24.210
So you have three
properties on this class.

00:44:24.330 --> 00:44:26.560
In Touch Fatter,
that tells you the position,

00:44:26.650 --> 00:44:30.300
allows you to calibrate
as we discuss in a second,

00:44:30.360 --> 00:44:33.120
also allows you to control the
smoothing and the sensitivity

00:44:33.440 --> 00:44:35.510
of the current acceleration.

00:44:36.420 --> 00:44:41.300
So some other thing we learned
while doing this work in TouchFaller

00:44:41.300 --> 00:44:45.260
is that because the accelerometer
callback might be in the main thread,

00:44:45.260 --> 00:44:48.370
and this main thread will
be the thread where you're

00:44:48.370 --> 00:44:51.100
going to do the geo-rendering,
and in an expensive game,

00:44:51.100 --> 00:44:53.760
this geo-rendering might
take a lot of time.

00:44:53.760 --> 00:44:59.760
So even if you ask for a very high
frequency of the accelerometer callback,

00:44:59.760 --> 00:45:03.370
they might not come as
often as you expect them.

00:45:03.380 --> 00:45:06.530
And so that's an issue in
particular when you want to do

00:45:06.530 --> 00:45:10.460
some smoothing and want some signal
processing where the sampling rate,

00:45:10.580 --> 00:45:12.260
the fact that the
sampling rate is regular,

00:45:12.260 --> 00:45:13.190
is very important.

00:45:13.220 --> 00:45:17.080
So you can find your
own solutions to that.

00:45:17.080 --> 00:45:19.880
The solution we found was to
actually do the signal processing

00:45:19.960 --> 00:45:22.970
and do the smoothing from whatever
is regular in the current game,

00:45:22.970 --> 00:45:24.810
and that's the geo-rendering loop.

00:45:24.960 --> 00:45:27.140
So doing that smoothing
in the geo-rendering loop,

00:45:27.140 --> 00:45:29.660
so in whatever is expensive
in the current situation,

00:45:29.660 --> 00:45:35.740
allowed to bypass and to avoid
some... Some jitter and some

00:45:35.740 --> 00:45:39.020
irregular motion in the control.

00:45:39.150 --> 00:45:42.870
So again, Chirag,
the TouchFaller source for

00:45:42.870 --> 00:45:49.450
smoothing and noise reduction
example using accelerometer data.

00:45:52.350 --> 00:45:57.580
OK, so another thing I show you in the
demo is-- so it's very nice to be able

00:45:57.580 --> 00:46:02.680
to give the gamers the ability to,
as they wish, while playing the game,

00:46:02.680 --> 00:46:04.620
to change their default position.

00:46:04.730 --> 00:46:06.840
So you can start the game
by playing like that,

00:46:06.840 --> 00:46:10.120
and you might want to sit down and
to then continue playing the game

00:46:10.120 --> 00:46:12.420
with that sort of inclination.

00:46:12.560 --> 00:46:18.120
So how do you give the gamers the
option to do that calibration?

00:46:18.240 --> 00:46:20.200
And so that's really up to you.

00:46:20.200 --> 00:46:22.750
So that really depends on the
user case scenario that you have.

00:46:22.990 --> 00:46:25.300
You might be in a game when you
want to force the user to hold

00:46:25.300 --> 00:46:31.680
the iPhone parallel to the floor,
and so to create some analogy

00:46:31.680 --> 00:46:35.430
between the iPhone and the ground.

00:46:35.560 --> 00:46:38.830
But you might want to give the option
to do this sort of recalibration.

00:46:38.830 --> 00:46:42.530
So some options, you can use three-finger
tap to automatically

00:46:42.530 --> 00:46:45.890
recalibrate whenever -- well,
to recalibrate whenever you

00:46:45.890 --> 00:46:47.500
do the three-finger tap.

00:46:47.500 --> 00:46:51.050
So in TouchFader,
we do this technique that

00:46:51.270 --> 00:46:55.420
detects whenever the player
is in some outer region,

00:46:55.500 --> 00:46:59.500
so outside the screen for some time,
so statically over there for some time,

00:46:59.500 --> 00:47:01.370
so with low variance in the movement.

00:47:01.500 --> 00:47:05.000
We say, well, that's likely to be the new
position the player is in,

00:47:05.010 --> 00:47:07.390
and so we use that as a
new center of movement.

00:47:07.500 --> 00:47:09.490
And so that works really nice.

00:47:09.490 --> 00:47:13.180
So that's also something that you
might want to have a look at if

00:47:13.320 --> 00:47:15.500
it makes sense to your scenario.

00:47:15.500 --> 00:47:17.500
But we find out that
it works really nice.

00:47:17.500 --> 00:47:19.500
So that's what we do.

00:47:19.500 --> 00:47:21.450
But again,
so there's no universal answer.

00:47:21.540 --> 00:47:27.500
It's a case-by-case kind of problem,
but it's nice to keep that in mind.

00:47:27.500 --> 00:47:31.500
So more on multi-touch and accelerometer.

00:47:31.500 --> 00:47:35.400
in these sessions on
Wednesday and Thursday.

00:47:49.770 --> 00:47:52.700
So now let me talk about audio.

00:47:52.810 --> 00:47:59.800
So the iPhone is a great iPod,
and the sound quality is really nice.

00:47:59.830 --> 00:48:03.440
And so it's great to be able
to leverage that in the game.

00:48:03.580 --> 00:48:07.220
So Core Audio and Audio Toolbox
are the place to start to

00:48:07.220 --> 00:48:09.400
bringing sound in a game.

00:48:09.400 --> 00:48:12.900
So that's a primary API for
audio playback on the iPhone,

00:48:12.940 --> 00:48:16.890
and it's a C front-end that takes
directly to the audio hardware for

00:48:16.930 --> 00:48:20.670
optimal sound quality and decompression.

00:48:20.980 --> 00:48:25.890
So Core Audio has several APIs,
and so you need to choose

00:48:25.900 --> 00:48:28.820
exactly what makes sense to
what you want to do in the game.

00:48:28.840 --> 00:48:33.380
So there's this very simple
API called Audio Services that

00:48:33.430 --> 00:48:35.020
allows you to play short sounds.

00:48:35.020 --> 00:48:36.400
So it's not for everything.

00:48:36.400 --> 00:48:40.500
It's really for some
punctual sounds in some UI,

00:48:40.500 --> 00:48:42.430
some beeps and boops.

00:48:42.580 --> 00:48:45.350
So not really for mixing,
but that's very easy to

00:48:45.350 --> 00:48:47.060
leverage to start up with.

00:48:47.660 --> 00:48:50.150
Then there's Audio Queue
Services that allow you to play

00:48:50.150 --> 00:48:51.710
longer sound and compressed sounds.

00:48:51.760 --> 00:48:56.740
And so that's nice because it
automatically loads chunks in memory,

00:48:56.740 --> 00:48:59.310
so you don't have the whole
source file in memory at once.

00:48:59.400 --> 00:49:06.300
And also for recording audio and
playing stream audio content.

00:49:06.810 --> 00:49:10.230
So now,
what if you want to do some sound mixing,

00:49:10.230 --> 00:49:14.110
and even better, some 3D sound mixing?

00:49:14.230 --> 00:49:17.220
So for that, there is OpenAL.

00:49:17.370 --> 00:49:19.580
OpenAL is just a line here,
but it's really nice.

00:49:19.660 --> 00:49:21.340
It's really big.

00:49:22.510 --> 00:49:28.940
So OpenAL allows you to do
3D specialized sound mixing.

00:49:28.950 --> 00:49:32.300
And what is very nice with OpenAL is
that it's going to share the

00:49:32.390 --> 00:49:34.280
same coordinate system as OpenGL.

00:49:34.390 --> 00:49:38.320
So it's very easy for you
OpenGL developer to transfer

00:49:38.320 --> 00:49:40.420
and to go from OpenGL to OpenAL.

00:49:40.580 --> 00:49:45.380
You simply associate to the position
in your referential of your 3D object a

00:49:45.380 --> 00:49:50.400
sound with the same coordinate or close
coordinate in the OpenAL referential.

00:49:50.450 --> 00:49:56.320
And then boom, from now on,
you have a 3D specialized game.

00:49:56.320 --> 00:50:01.970
And you know how this sort of audio
richness of immersion can really add to

00:50:01.970 --> 00:50:07.890
the already very rich experience that you
have with the graphics API on the iPhone.

00:50:08.030 --> 00:50:10.220
So OpenAL is there.

00:50:10.290 --> 00:50:11.260
It's on the phone.

00:50:11.330 --> 00:50:12.960
So you heard in touch, amazing it sounds.

00:50:12.960 --> 00:50:14.610
It's really nice.

00:50:14.620 --> 00:50:17.110
So OpenAL is there on the
phone without audio capture.

00:50:17.200 --> 00:50:18.840
So OpenAL 1.1.

00:50:19.090 --> 00:50:20.400
So you can bring it in.

00:50:20.400 --> 00:50:23.900
You can bring your existing
OpenAL code on the iPhone and it

00:50:23.900 --> 00:50:26.160
should work just as you expected.

00:50:26.160 --> 00:50:32.760
But we made it easy to leverage
OpenAL in a game by providing you

00:50:32.760 --> 00:50:38.210
with a simple OpenAL interface,
soundengine.h and cpp that

00:50:38.240 --> 00:50:39.900
is shared among samples.

00:50:39.950 --> 00:50:43.900
So crash landing and touch
fatter use that engine.

00:50:43.900 --> 00:50:48.860
And it's a wrapper over OpenAL and
an audio toolbox to play 3D

00:50:48.920 --> 00:50:50.400
positional sound and mix.

00:50:50.400 --> 00:50:53.040
So you can play mixing
with simple methods,

00:50:53.040 --> 00:50:54.380
simple functions.

00:50:54.460 --> 00:50:56.900
Load effect, set effect position,
start effect and boom,

00:50:56.900 --> 00:51:01.400
you have your effect playing
in space and being specialized.

00:51:01.400 --> 00:51:06.400
Also, you have background audio track
support to load background music,

00:51:06.400 --> 00:51:11.400
so compressed audio or compressed audio
as a background track in the game.

00:51:11.980 --> 00:51:15.400
So we have an Objective-C wrapper
in TouchFader that does a simple,

00:51:15.400 --> 00:51:22.040
very thin wrapper over that API to set
position and really maps and associate.

00:51:22.040 --> 00:51:26.360
It maps very well with the 3D
objects that we have in the game.

00:51:28.040 --> 00:51:30.550
So some notes about audio.

00:51:30.890 --> 00:51:35.660
So depending on the
requirement that you have,

00:51:35.660 --> 00:51:38.210
you might want to choose
a good compromise between

00:51:38.210 --> 00:51:40.050
performance and quality.

00:51:40.050 --> 00:51:51.160
In particular, in 3D expensive games,
you might want to get a sampling rate

00:51:51.620 --> 00:51:56.010
that requires a lot of CPU for the game,
for the current configuration.

00:51:56.080 --> 00:51:59.950
For instance, in Touch Fader,
with all the sounds going on,

00:51:59.950 --> 00:52:03.480
so 22K might be a good compromise
to get a great sound quality

00:52:03.480 --> 00:52:05.050
while having great performance.

00:52:05.060 --> 00:52:09.310
So in some of the games, you might want,
because graphic is cheap,

00:52:09.440 --> 00:52:12.600
you might think that it's
fine to bump up to 44K,

00:52:12.600 --> 00:52:14.160
and that's perfect.

00:52:14.160 --> 00:52:17.010
So that really depends
on the user scenario,

00:52:17.010 --> 00:52:21.100
on the expensiveness of the other
things going on in the game.

00:52:21.100 --> 00:52:23.110
So think about sampling rate there.

00:52:24.660 --> 00:52:27.730
So but one thing that is
important is to avoid mixing

00:52:27.730 --> 00:52:32.730
different sampling rate together,
because this will produce or

00:52:32.800 --> 00:52:36.230
incur some extra conversion
step between the sampling rate,

00:52:36.560 --> 00:52:38.090
which is a cost that you want to avoid.

00:52:40.130 --> 00:52:46.180
So you can play multiple
compressed files and mix them,

00:52:46.180 --> 00:52:52.220
but the hardware can only play one
compressed audio file at a time.

00:52:52.750 --> 00:52:57.460
So if you try to play multiple
compressed audio files,

00:52:57.560 --> 00:53:00.450
they will either play in
software if there is a software

00:53:00.450 --> 00:53:01.520
decoder or not play at all.

00:53:01.650 --> 00:53:07.360
So keep that in mind and consider using
compressed sound files in some cases,

00:53:07.360 --> 00:53:11.320
in these cases.

00:53:11.500 --> 00:53:15.800
So now more about audio right
after this session in Procedio,

00:53:15.810 --> 00:53:17.920
Audio Development for the iPhone.

00:53:17.940 --> 00:53:19.710
And so the lab is coming
on Wednesday also where you

00:53:19.810 --> 00:53:20.920
can ask all your questions.

00:53:31.900 --> 00:55:47.400
[Transcript missing]

00:55:48.140 --> 00:55:52.350
So yeah, so it's a great place.

00:55:52.460 --> 00:55:55.120
So that's for these host multiple client,
multiple conversion.

00:55:55.120 --> 00:55:58.650
But it's very easy to start from
this sample source and to build

00:55:59.030 --> 00:56:02.980
whatever network configuration
that makes sense to your game.

00:56:03.070 --> 00:56:05.520
So it's a great place to have
a first look at how you can

00:56:05.520 --> 00:56:07.770
do networking on the iPhone.

00:56:09.820 --> 00:56:11.690
So some notes on networking.

00:56:11.770 --> 00:56:15.400
So the name of the device in
Bonjour are the device names.

00:56:15.400 --> 00:56:18.280
And the device names are the device
name that you choose in iTunes that

00:56:18.290 --> 00:56:20.010
you associate with your iPhone.

00:56:20.250 --> 00:56:23.460
So if you want to do some multiplayer,
you might change that from my

00:56:23.550 --> 00:56:26.640
iPhone to something more personal.

00:56:26.640 --> 00:56:29.780
And so there is the system
configuration framework that allows

00:56:29.780 --> 00:56:33.890
you to know what network is available.

00:56:33.890 --> 00:56:37.220
So Edge or Wi-Fi or not 3G.

00:56:37.220 --> 00:56:40.590
So there is a sample application
called Net Reachability that allows

00:56:40.780 --> 00:56:44.560
you to get that information and
to see how you can do that and

00:56:44.780 --> 00:56:47.040
how you can get that information.

00:56:47.340 --> 00:56:50.680
So, and similarly,
you can -- the sample source is a great

00:56:50.680 --> 00:56:56.600
place to start if you want to create
peer-to-peer or other sort of networks.

00:57:02.660 --> 00:57:05.640
So there is this great thing in
Objective-C that allows you to,

00:57:05.640 --> 00:57:08.560
when you are in a game,
that allows you to send

00:57:08.560 --> 00:57:10.340
data over a connection.

00:57:10.360 --> 00:57:15.470
So when you're in a game, in Objective-C,
you might have objects

00:57:15.470 --> 00:57:19.120
with a set of properties,
and so you have your Objective-C object.

00:57:19.120 --> 00:57:22.230
And what would you like to
do is to send that object,

00:57:22.230 --> 00:57:25.550
all that information
associated with that object,

00:57:25.630 --> 00:57:29.180
over a connection so that other clients
can get exactly the same object.

00:57:29.200 --> 00:57:32.150
And so if you make your
object conform to NSCoding,

00:57:32.490 --> 00:57:35.580
simply by implementing these two methods,
encodeWithCoder and intWithCoder,

00:57:35.580 --> 00:57:39.480
you have then an easy way to
send your object data to your

00:57:39.480 --> 00:57:42.060
custom objects over a connection.

00:57:42.200 --> 00:57:45.580
So just with this method, ArchiveData,
with root object,

00:57:45.640 --> 00:57:49.090
you can get an NSData object
from that Objective-C object,

00:57:49.090 --> 00:57:52.240
send it on the connection,
and then on the other side,

00:57:52.240 --> 00:57:55.150
we construct the object
very transparently.

00:57:55.180 --> 00:57:57.900
So it's very nice to get an object
on both sides of the connection.

00:57:57.900 --> 00:57:59.180
So allow that.

00:57:59.200 --> 00:58:03.670
And then we have this
Objective-C NSCoding protocol.

00:58:03.700 --> 00:58:08.200
So for an example on that,
you can check the touchpad or source.

00:58:08.200 --> 00:58:10.200
So that's what we do to send information.

00:58:10.280 --> 00:58:12.150
And that's it.

00:58:12.200 --> 00:58:16.470
So another thing is that the
NSArray and lots of Objective-C objects

00:58:16.520 --> 00:58:22.150
already NSCoding compliant,
so you can easily leverage that to send

00:58:22.150 --> 00:58:25.790
complex structures over the network.

00:58:26.750 --> 00:58:30.250
So now let's talk about location.

00:58:30.350 --> 00:58:34.270
So as Allan mentioned,
the iPhone knows where you are.

00:58:34.730 --> 00:58:40.320
And so what it means is that it opens the
door to location-aware multiplayer games.

00:58:40.440 --> 00:58:41.320
And that's really big.

00:58:41.320 --> 00:58:44.340
And that's an area that is still
getting -- that is very hot right now,

00:58:44.340 --> 00:58:45.890
that is getting explored.

00:58:45.890 --> 00:58:50.080
So there's lots of things that
are very exciting in that domain.

00:58:50.080 --> 00:58:53.670
So the iPhone can create a
Wi-Fi tower and cell phone tower

00:58:53.670 --> 00:58:56.580
and a GPS to your current location.

00:58:57.840 --> 00:59:00.100
And then it gets this approximate.

00:59:00.180 --> 00:59:02.660
And so when you're in your network,
so you know all your clients

00:59:02.760 --> 00:59:05.930
and hosts in your game,
so configure, you can then put these

00:59:05.930 --> 00:59:08.940
locations in relation,
the one to the other,

00:59:08.940 --> 00:59:13.800
to know who's close, to know who's far,
and to eventually create some

00:59:13.800 --> 00:59:19.680
interaction with the people
around you in the physical world.

00:59:20.680 --> 00:59:25.500
So Core Location is the API,
the framework that you need to get

00:59:25.500 --> 00:59:28.040
an estimate on the current location.

00:59:28.040 --> 00:59:32.600
It tells you altitude, longitude,
and altitude.

00:59:32.600 --> 00:59:37.140
And so on the iPhone,
it's very important to use Core Location,

00:59:37.140 --> 00:59:41.280
and Core Location allows you to do
that to only get the estimate that

00:59:41.380 --> 00:59:44.270
you need so that you can minimize
the battery that you require,

00:59:44.350 --> 00:59:49.200
so the number of cell towers that you
will query to get your current estimate.

00:59:49.650 --> 00:59:53.340
So to get location,
you configure the distance.

00:59:53.340 --> 00:59:55.610
So you create a
co-location manager object.

00:59:55.620 --> 00:59:58.510
And then you set the distance
filter and design accuracy

00:59:58.510 --> 01:00:00.760
properties on that instance.

01:00:00.760 --> 01:00:03.970
And so the distance filter say,
how much do I need to move before

01:00:04.450 --> 01:00:07.000
my current location is invalidated?

01:00:07.060 --> 01:00:10.580
And the desired accuracy say,
how accurate I want that estimate to be.

01:00:10.580 --> 01:00:15.010
So then you call the start updating
location method and the start

01:00:15.010 --> 01:00:18.120
updating location method to start
getting an estimate and then stop

01:00:18.220 --> 01:00:19.940
whenever the estimate is good enough.

01:00:20.030 --> 01:00:23.260
So it's very important to set
that parameters right so that

01:00:23.260 --> 01:00:27.580
you do not require too much power
for the information you need.

01:00:27.580 --> 01:00:31.520
If you want some broad,
I want to know in what city I am in,

01:00:31.520 --> 01:00:35.000
so configure that properly so
that you don't require too much.

01:00:35.580 --> 01:00:40.740
So to know more about
location and accelerometer,

01:00:40.740 --> 01:00:44.400
so there is this presidio session
on accelerometer and location,

01:00:44.400 --> 01:00:48.800
so tomorrow, and so we encourage
you to go check it out.

01:00:51.300 --> 01:00:54.540
So now we're going to do a demo
of Multiplayer in Touchpad.

01:00:54.670 --> 01:00:59.740
So we build over these game
classes that allows you to see

01:00:59.740 --> 01:01:01.700
how it works and to try out.

01:01:01.700 --> 01:01:05.400
And it works very nice,
so we thought we would make you a demo.

01:01:05.840 --> 01:01:10.850
So can I go on the demo unit, please?

01:01:11.390 --> 01:01:15.870
So, and what we have here, we have Allan,
who has an iPhone here,

01:01:15.870 --> 01:01:19.140
and he's on the same network in here.

01:01:19.520 --> 01:01:21.840
So I can just start here
having a multiplayer game,

01:01:21.840 --> 01:01:25.240
and I'm going to host a game,
and Allan's going to join the game.

01:01:25.470 --> 01:01:30.180
So you have this very nice UI when I can
change my shape and it follows my finger,

01:01:30.180 --> 01:01:32.560
just like in CoverFlow,
so it's really nice.

01:01:32.560 --> 01:01:35.160
So I can swipe and send
these people around.

01:01:35.160 --> 01:01:40.120
So Allan joined the game,
and so I was selecting a little early.

01:01:40.120 --> 01:01:42.350
So you can see that
Allan is moving around,

01:01:42.350 --> 01:01:45.720
so that's Allan in front of me here,
who is moving and playing

01:01:45.720 --> 01:01:47.120
with his iPhone here.

01:01:47.120 --> 01:01:53.170
And so I can see he's firing,
and he can send missiles too, and...

01:01:53.500 --> 01:01:55.750
Here we go, they're sending missiles.

01:01:55.750 --> 01:01:59.020
And so the whole game
state is sent in real time,

01:01:59.020 --> 01:02:01.340
in background, to Allan Schaffer.

01:02:01.340 --> 01:02:03.100
So he sees exactly the
same thing as Anthony.

01:02:03.100 --> 01:02:05.340
So it's really nice to
do some multi-tayer.

01:02:05.340 --> 01:02:08.370
You can start playing together and
eventually compare the scores and see

01:02:08.380 --> 01:02:12.780
how much he's winning and how much he's
killing more ships than me and so on.

01:02:12.780 --> 01:02:14.860
So here the whole thing is going on.

01:02:14.860 --> 01:02:17.340
So he sees the same thing, the explosion,
all that stuff is transferred.

01:02:17.340 --> 01:02:19.020
And yeah.

01:02:21.740 --> 01:02:25.170
and you see all that
stuff going on over wi-fi

01:02:26.900 --> 01:02:27.200
Okay.

01:02:27.200 --> 01:02:28.630
So yeah.

01:02:28.630 --> 01:02:30.040
Thank you.

01:02:30.090 --> 01:02:31.680
So that was Touchpad or Multiplayer.

01:02:39.860 --> 01:02:45.460
And so before asking
Allan to come on stage,

01:02:45.510 --> 01:02:49.580
I really want to give you my final words,
which are that I can't wait to

01:02:49.580 --> 01:02:52.690
see what you guys are going to do,
because the possibilities

01:02:52.730 --> 01:02:55.390
are really there,
and the features are really there.

01:02:55.510 --> 01:03:01.110
And so there's a lot of
innovation going on in Gameplay,

01:03:01.140 --> 01:03:01.750
and I can't wait to see
what's going to happen.

01:03:01.750 --> 01:03:01.750
It's going to be really exciting.

01:03:06.600 --> 01:03:09.750
All right.

01:03:09.770 --> 01:03:13.700
Well, so over the past few months
during the beta period,

01:03:13.700 --> 01:03:17.010
I've been getting a lot of
questions from all of you about

01:03:17.010 --> 01:03:19.540
some device-specific issues.

01:03:19.540 --> 01:03:23.770
And so what I've compiled is just a quick
FAQ of a few of the things that just

01:03:24.210 --> 01:03:26.530
seem to be questions from everybody.

01:03:26.540 --> 01:03:29.810
These are not specific to
game development at all,

01:03:29.940 --> 01:03:34.340
and they're going to be covered
in other sessions during the show.

01:03:34.670 --> 01:03:36.800
But I will go ahead and
go into a few of them.

01:03:36.800 --> 01:03:39.510
So first,
what should you do if you're running

01:03:39.610 --> 01:03:41.690
on an iPhone and a call comes in?

01:03:41.700 --> 01:03:44.050
Well,
what the user is going to be presented

01:03:44.050 --> 01:03:47.350
with is a screen that comes up over
your game where they're given the

01:03:47.480 --> 01:03:49.200
option to decline or answer the call.

01:03:49.200 --> 01:03:52.840
When that screen appears,
a particular UI application

01:03:52.840 --> 01:03:54.780
delegate is going to fire.

01:03:54.780 --> 01:03:55.340
You see it here.

01:03:55.340 --> 01:03:58.720
It's the application will
resign active delegate.

01:03:58.720 --> 01:04:01.250
And that's when you should
probably pause your game.

01:04:01.260 --> 01:04:03.630
Just the user isn't going
to be able to get to it.

01:04:04.620 --> 01:04:07.720
And they're deciding,
they're seeing who's calling them.

01:04:07.720 --> 01:04:10.110
Now, if they take the call,
your application is

01:04:10.210 --> 01:04:11.520
going to be terminated.

01:04:11.520 --> 01:04:15.370
Before that happens,
you have just a few moments in this

01:04:15.740 --> 01:04:20.880
application will terminate delegate
method to save off your game state and

01:04:21.090 --> 01:04:25.590
do anything you want to do for the next
time the user comes back into your game.

01:04:25.600 --> 01:04:31.920
Now, if the user declines the call,
now your game is back in active again.

01:04:31.940 --> 01:04:34.520
And so you get a notification
of application did become.

01:04:34.650 --> 01:04:38.520
And that's where you should
probably resume your game was

01:04:38.590 --> 01:04:40.750
just paused in the meantime.

01:04:40.760 --> 01:04:43.760
And so you would do some sort
of game specific behavior there.

01:04:43.760 --> 01:04:45.310
Maybe you want to restart the level.

01:04:45.320 --> 01:04:48.440
Maybe you just put them, you know,
let them hit a continue button.

01:04:48.440 --> 01:04:51.640
You know, it's something specific to
how you would implement that.

01:04:53.870 --> 01:04:57.480
A question I get a lot is,
where can I save high scores?

01:04:57.590 --> 01:05:02.040
So the issue is that application data
on the iPhone and on the iPhone OS is

01:05:02.040 --> 01:05:05.000
sandboxed to your application bundle.

01:05:05.000 --> 01:05:07.630
And so only your application
can access its data,

01:05:07.630 --> 01:05:11.300
resources, and other things from its
documents folder and so on.

01:05:11.300 --> 01:05:15.680
You don't have the ability, for example,
to reach over into another application's

01:05:15.730 --> 01:05:19.210
resources to read their high scores,
and nor is there a centralized

01:05:19.210 --> 01:05:22.280
location on the iPhone for
you to just store stuff to.

01:05:22.280 --> 01:05:26.930
And so there's a simple approach, though,
and it has to do with the NSUserDefaults,

01:05:27.250 --> 01:05:29.610
which is something you typically
can use for preferences,

01:05:29.760 --> 01:05:30.760
but it works great for this.

01:05:30.990 --> 01:05:35.910
And it has just a setObjectForKey
and then objectForKeyRetrieval

01:05:35.910 --> 01:05:39.420
method to be able to just
get and set your high scores.

01:05:39.420 --> 01:05:42.750
Now, if you're doing something
a little more complex,

01:05:42.770 --> 01:05:45.990
you want to be able to have
global high scores from all of

01:05:45.990 --> 01:05:50.380
your users all over the Internet,
that's a custom implementation.

01:05:50.720 --> 01:05:54.010
You're going to have to somehow
connect over the network

01:05:54.010 --> 01:05:55.590
to a server that you host.

01:05:56.000 --> 01:05:58.150
Maybe you would have it
come through a web page.

01:05:58.180 --> 01:06:01.000
Maybe you would connect directly
through the CF network code.

01:06:01.000 --> 01:06:02.410
That would be your choice.

01:06:04.470 --> 01:06:06.950
A couple of things about the status bar.

01:06:06.950 --> 01:06:10.270
So typically in a full-screen game,
you want to hide the

01:06:10.420 --> 01:06:14.480
status bar or change it,
or you want to change its orientation.

01:06:14.590 --> 01:06:18.080
And so all of these things can be
controlled by the Info.plist that's

01:06:18.080 --> 01:06:19.900
associated with your application.

01:06:19.990 --> 01:06:22.210
And these are just different settings.

01:06:22.220 --> 01:06:26.000
So the status bar hidden,
set that to yes if you want to hide it.

01:06:26.000 --> 01:06:29.850
You can set it from the default,
which is the sort of a gray color,

01:06:29.850 --> 01:06:34.380
to black translucent if most of your
games have a black translucent color.

01:06:34.400 --> 01:06:35.960
Same colors are dark.

01:06:36.030 --> 01:06:38.740
Or you can orient it to landscape mode.

01:06:38.740 --> 01:06:43.820
In this case, landscape right for
landscape orientation.

01:06:44.570 --> 01:06:45.950
Two more things.

01:06:46.070 --> 01:06:49.640
If you want to customize the
launch image of your application,

01:06:49.640 --> 01:06:53.660
and so what that is is when an
iPhone application first launches,

01:06:53.660 --> 01:06:58.130
it displays an image while
your application state is all

01:06:58.130 --> 01:07:00.070
being initialized and so on.

01:07:00.080 --> 01:07:03.280
And the name of that file
is just default.ping.

01:07:03.280 --> 01:07:05.870
If you have that in the top
level of your application bundle,

01:07:05.870 --> 01:07:09.030
that's what's going to be shown
while all your game state is loading.

01:07:09.040 --> 01:07:14.470
Now, you probably want the contents of
that default.ping to be something

01:07:14.470 --> 01:07:18.340
like the 0% appearance of your loading
screen or just something that shows,

01:07:18.420 --> 01:07:22.220
okay, you know,
the game is now firing up.

01:07:22.900 --> 01:07:25.430
And last,
an issue that comes up if you're

01:07:25.510 --> 01:07:29.760
holding the iPhone and using
just the accelerometer for input,

01:07:29.940 --> 01:07:32.290
maybe you're never actually
touching the screen.

01:07:32.300 --> 01:07:35.260
And touching the screen
is what keeps it awake.

01:07:35.360 --> 01:07:40.300
And so there needs to be some
way for you to tell the iPhone,

01:07:40.300 --> 01:07:44.250
the SDK, I still want to keep awake even
if I'm not touching anything.

01:07:44.340 --> 01:07:45.780
And this is how you can do that.

01:07:45.930 --> 01:07:51.210
It's just a method on the shared
application object to disable this timer.

01:07:51.830 --> 01:07:52.180
All right.

01:07:52.380 --> 01:07:54.460
So that's actually my email address.

01:07:54.570 --> 01:07:55.840
You're going to see
that all over the show.

01:07:55.840 --> 01:07:59.520
But so we've given you kind
of a lot of homework here.

01:07:59.520 --> 01:08:00.610
You know, you saw this.

01:08:00.740 --> 01:08:04.640
There's a lot of Touch Fighter source
that we've shown you.

01:08:04.640 --> 01:08:06.950
We've told you go look at that code.

01:08:06.950 --> 01:08:14.410
You know, so come, go do that tonight,
you know, after the parties, of course,

01:08:14.410 --> 01:08:17.610
and then come to the lab tomorrow.

01:08:17.610 --> 01:08:17.810
And we'd be happy to
take questions there.
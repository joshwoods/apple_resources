WEBVTT

00:00:20.830 --> 00:00:21.400
Good afternoon.

00:00:21.400 --> 00:00:24.420
We have a lot to talk about today.

00:00:24.750 --> 00:00:26.330
Made my first mistake.

00:00:26.610 --> 00:00:28.800
I'm David Mishefsky.

00:00:28.800 --> 00:00:32.290
I've been working on iPhone performance
for a little over two years,

00:00:32.290 --> 00:00:36.610
where I've concentrated on high-level
application and framework performance.

00:00:36.680 --> 00:00:40.890
So I've done things like optimize
scrolling and SMS transcripts,

00:00:40.900 --> 00:00:43.940
large contacts lists,
and optimized a lot of

00:00:43.940 --> 00:00:46.500
code for performance over
the last couple of years.

00:00:46.500 --> 00:00:48.660
And we have a lot of great
topics to talk about.

00:00:48.730 --> 00:00:51.440
And so let's give you a quick overview.

00:00:51.440 --> 00:00:56.600
When we talk about performance,
we usually think about three things.

00:00:56.970 --> 00:01:02.120
And that's CPU slash GPU usage, memory,
and of course, power.

00:01:02.120 --> 00:01:05.040
So to cover all of these topics,
we're going to divide

00:01:05.110 --> 00:01:06.500
it into five sections.

00:01:06.500 --> 00:01:10.510
The first is drawing and scrolling,
where we have all sorts of

00:01:10.510 --> 00:01:13.990
wonderful graphics and smooth
animations on iPhone apps.

00:01:14.190 --> 00:01:17.310
So we'll learn how to optimize
applications for those

00:01:17.370 --> 00:01:18.650
graphically rich applications.

00:01:18.650 --> 00:01:18.700
And then we'll talk about performance.

00:01:18.700 --> 00:01:18.700
And then we'll talk about performance.

00:01:18.810 --> 00:01:19.880
And then we'll talk about performance.

00:01:19.880 --> 00:01:19.900
And then we'll talk about performance.

00:01:20.270 --> 00:01:23.460
Application launch,
which is absolutely critical for iPhone,

00:01:23.460 --> 00:01:26.930
and a little bit different than
Mac OS X because of the different

00:01:26.930 --> 00:01:28.800
use cases that we have on iPhone.

00:01:28.800 --> 00:01:32.680
Memory usage,
which is absolutely critical for

00:01:32.680 --> 00:01:36.180
iPhone applications because we
have a limited amount of memory,

00:01:36.180 --> 00:01:38.220
and we don't have a swap file on iPhone.

00:01:38.220 --> 00:01:41.080
So we'll tell you how to
deal with that limitation.

00:01:41.080 --> 00:01:42.020
Files and data.

00:01:42.110 --> 00:01:45.410
And there are some nice little
optimizations that we can make,

00:01:45.530 --> 00:01:47.240
particularly with large data files.

00:01:47.240 --> 00:01:50.170
And finally,
because this is a mobile device that

00:01:50.330 --> 00:01:53.330
people carry around with them every day,
and it's their connection

00:01:53.450 --> 00:01:55.590
to the outside world,
it is critical that our

00:01:55.590 --> 00:01:57.920
battery life is very,
very good on this device.

00:01:58.050 --> 00:02:01.020
So we'll tell you some things that
you can do in your applications

00:02:01.150 --> 00:02:04.140
to ensure that users will
experience good battery life.

00:02:05.900 --> 00:02:11.110
So the first thing that you notice about
iPhone is that it's not quite a Mac in

00:02:11.180 --> 00:02:13.300
terms of the hardware characteristics.

00:02:13.360 --> 00:02:16.080
If we compare our slowest
Mac Mini that we shipped today

00:02:16.080 --> 00:02:18.730
to the iPhone and iPod Touch,
there's really no contest

00:02:18.730 --> 00:02:19.620
in terms of speed.

00:02:19.620 --> 00:02:21.800
CPU is much, much greater.

00:02:21.800 --> 00:02:24.750
The RAM, of course, is very,
very high in any of

00:02:24.750 --> 00:02:27.790
the Macs that we ship,
and it's backed by the large

00:02:27.790 --> 00:02:31.630
swap file that you can put on
these wonderful hard drives.

00:02:31.670 --> 00:02:35.760
There's no L2 cache
on iPhone or iPhone X.

00:02:35.800 --> 00:02:39.260
And of course, for networking,
we have three different

00:02:39.310 --> 00:02:40.710
types of connection.

00:02:40.710 --> 00:02:45.260
We have Wi-Fi, which is very,
very high bandwidth, low latency, 3G,

00:02:45.260 --> 00:02:48.500
which is high bandwidth and high latency,
and Edge,

00:02:48.530 --> 00:02:51.330
which is low bandwidth and high latency.

00:02:51.420 --> 00:02:55.250
So in order to put this
great Mac OS X software into

00:02:55.410 --> 00:03:01.000
a small device like iPhone,
we need to do a few different things.

00:03:01.000 --> 00:03:04.560
And you will find that as you're
developing your applications,

00:03:04.560 --> 00:03:05.780
that you're going to need to have a
lot of experience with the Mac OS X.

00:03:05.780 --> 00:03:06.910
Thank you.

00:03:07.070 --> 00:03:15.000
The simulator is a great tool for rapid
application development and for testing

00:03:15.000 --> 00:03:18.130
your applications against frameworks,
but the performance that you

00:03:18.130 --> 00:03:20.420
experience on the device because
of those different hardware

00:03:20.420 --> 00:03:24.320
characteristics is actually much,
much different on the iPhone.

00:03:24.320 --> 00:03:28.670
So to demonstrate the importance of
profiling your applications on the

00:03:28.670 --> 00:03:33.260
iPhone and periodically running your
devices on the iPhone hardware itself,

00:03:33.400 --> 00:03:36.280
we have Peter Handel,
who is on the iPhone power team.

00:03:36.960 --> 00:03:38.520
And so, Peter, if you'll give the demo.

00:03:38.520 --> 00:03:40.860
Thank you.

00:03:43.900 --> 00:03:44.490
Hi, everyone.

00:03:44.640 --> 00:03:45.880
My name is Peter Handel.

00:03:45.960 --> 00:03:47.790
I'm an iPhone power engineer.

00:03:47.920 --> 00:03:50.800
Been doing that for almost two years now.

00:03:50.910 --> 00:03:53.350
As Dave mentioned,
it's really important to check the

00:03:53.520 --> 00:03:56.030
performance of your application,
not just in the simulator,

00:03:56.040 --> 00:03:57.560
but also on the device.

00:03:57.670 --> 00:04:00.630
Let's go ahead and have
an example of that.

00:04:04.580 --> 00:04:06.980
So here we are in Xcode.

00:04:07.080 --> 00:04:09.700
We have a simple little
movies application here.

00:04:09.740 --> 00:04:13.990
Now I'm going to go ahead and say,
let's go ahead and run this on the

00:04:13.990 --> 00:04:16.600
simulator and take a look at it.

00:04:16.650 --> 00:04:22.500
Well, here we have title of movies,
the actors, who's in it,

00:04:22.600 --> 00:04:24.840
a little synopsis of it.

00:04:24.970 --> 00:04:26.890
And when we scroll it,
it looks pretty good, right?

00:04:26.890 --> 00:04:26.890
I mean, this is pretty smooth scrolling.

00:04:28.070 --> 00:04:34.010
Now, let's go ahead and select
our device to be the target.

00:04:34.900 --> 00:04:37.880
Now what it's doing right now,
we're going to recompile this for the

00:04:37.880 --> 00:04:40.330
phone that I have sitting right here.

00:04:40.460 --> 00:04:44.030
It's going to go ahead and ship
that over and run it on here.

00:04:44.210 --> 00:04:45.930
So let's take a look.

00:04:46.100 --> 00:04:49.000
So it's the exact same application
as we had in the simulator here.

00:04:49.070 --> 00:04:53.800
However, when we scroll it,
it's pretty chunky.

00:04:58.330 --> 00:05:00.520
Can we get the iPhone here?

00:05:00.540 --> 00:05:04.710
There we go.

00:05:05.880 --> 00:05:06.570
Great.

00:05:06.720 --> 00:05:08.590
So as we see, it's pretty chunky.

00:05:08.800 --> 00:05:10.800
Honest.

00:05:11.950 --> 00:05:15.220
And that's an example of why
it's really important to check

00:05:15.280 --> 00:05:18.300
the performance on the device,
not just on the simulator.

00:05:18.470 --> 00:05:19.790
Dave?

00:05:29.160 --> 00:05:32.210
So that was a great example of
why when you are designing and

00:05:32.210 --> 00:05:35.370
implementing your applications,
you need to periodically run

00:05:35.370 --> 00:05:38.410
them on the device to ensure
that your application has great

00:05:38.410 --> 00:05:41.400
performance and will be a really,
really good first

00:05:41.400 --> 00:05:43.180
experience for the users.

00:05:43.220 --> 00:05:48.000
And to optimize for the iPhone,
we have some great drawing technologies.

00:05:48.050 --> 00:05:50.780
We, of course, have all the ones that
you're used to on Mac OS X,

00:05:50.780 --> 00:05:54.240
Core Animation,
our Quartz 2D drawing system.

00:05:54.290 --> 00:05:58.360
And for your wonderful games,
we have the OpenGL ES and, of course,

00:05:58.370 --> 00:06:01.480
the UI Kit graphics,
which gives you all of your standard

00:06:01.500 --> 00:06:04.660
widgets and the ability to draw
your own customized views for

00:06:04.730 --> 00:06:07.880
whatever your drawing purposes are.

00:06:09.350 --> 00:06:13.160
So the first thing is,
if we provide a widget for you,

00:06:13.160 --> 00:06:15.440
then please use this.

00:06:15.440 --> 00:06:17.210
Please use the widget for the drawing.

00:06:17.210 --> 00:06:20.390
A great example of this is
UIImageView which is very,

00:06:20.420 --> 00:06:24.600
very nicely optimized to get your image
contents to the hardware as quickly

00:06:24.600 --> 00:06:27.220
as possible without using more memory.

00:06:27.520 --> 00:06:31.650
So UIImageView provides a great way
for you to display images on the

00:06:31.650 --> 00:06:35.030
screen and of course if you want
to add a label to this picture,

00:06:35.030 --> 00:06:38.820
UILabel is also nicely optimized and
takes care of a lot of things for you.

00:06:38.890 --> 00:06:42.350
So if we have a built-in widget,
then please use them.

00:06:42.570 --> 00:06:44.620
And the same goes for animation.

00:06:44.800 --> 00:06:49.220
We have a wonderful, wonderful animation
system on our iPhones,

00:06:49.220 --> 00:06:52.740
Core Animation,
and we provide built-in capabilities

00:06:52.740 --> 00:06:57.040
to do things like alpha fades,
moving views across the screen,

00:06:57.200 --> 00:06:59.870
and all sorts of other
wonderful animations.

00:06:59.870 --> 00:07:03.920
So if you use the UIImageView animations
or Core Animation directly,

00:07:03.920 --> 00:07:06.730
you'll get some really great
performance because it's heavily

00:07:06.730 --> 00:07:09.290
optimized for our hardware.

00:07:10.150 --> 00:07:13.800
But a lot of times you are going
to be drawing views yourself.

00:07:13.920 --> 00:07:16.690
So when you draw views yourself,
there are several things you

00:07:16.690 --> 00:07:18.200
need to take into consideration.

00:07:18.500 --> 00:07:22.210
The first one is the same thing
that we mentioned on Mac OS X,

00:07:22.280 --> 00:07:24.700
which is mark your views as opaque.

00:07:24.730 --> 00:07:28.690
On iPhone and iPod Touch,
this optimization is even more important

00:07:28.700 --> 00:07:33.500
than it is on Mac OS X because of our
limited processing and GPU capabilities.

00:07:34.140 --> 00:07:37.990
When you mark views as opaque,
the entire compositing system and

00:07:37.990 --> 00:07:42.140
the hardware has to do a lot less
work in order to get the content

00:07:42.140 --> 00:07:44.950
that you are drawing all the way
through the hardware and onto the

00:07:45.000 --> 00:07:46.430
screen so that the user can see it.

00:07:46.540 --> 00:07:49.960
This happens in particular in scrolling.

00:07:49.960 --> 00:07:52.200
So in the demo that
Peter just showed you,

00:07:52.200 --> 00:07:55.380
many of the views that were on the
screen were actually translucent,

00:07:55.450 --> 00:07:59.300
causing the hardware to do a lot
more work and giving us the chunky

00:07:59.430 --> 00:08:01.680
scrolling that you saw in the demo.

00:08:02.080 --> 00:08:04.700
So always mark your views as opaque.

00:08:04.770 --> 00:08:09.340
The second optimization is, again,
another one that we have on Mac OS X,

00:08:09.410 --> 00:08:12.380
which is draw as little as you can.

00:08:12.390 --> 00:08:15.550
If you have, for instance,
a screen region where your

00:08:15.550 --> 00:08:19.340
entire view may not be updated,
but only one half of it will be,

00:08:19.340 --> 00:08:24.100
then tell UIKit to,
by using the set needs

00:08:24.100 --> 00:08:28.510
display and rect method,
to dirty one particular region

00:08:28.700 --> 00:08:31.730
so that when you have to draw,
you can check that rectangle

00:08:31.730 --> 00:08:35.580
in draw rect and only redisplay
that one portion of the screen.

00:08:35.680 --> 00:08:38.870
So that is one optimization that
will allow our hardware to have

00:08:38.870 --> 00:08:41.840
to do a little bit less work
and make the user experience a

00:08:41.840 --> 00:08:43.860
little bit better for your users.

00:08:43.880 --> 00:08:47.130
There are very, very,
very few drawing operations that

00:08:47.250 --> 00:08:51.090
could actually be done before the
time that it takes to actually just

00:08:51.090 --> 00:08:53.370
check a rectangle for intersection.

00:08:53.560 --> 00:08:58.480
So always use set needs display and rect
when it applies to your custom views.

00:08:58.500 --> 00:09:02.770
And the next optimization is to
cache any drawing objects that

00:09:02.840 --> 00:09:05.620
you need to redisplay really,
really quickly.

00:09:05.650 --> 00:09:08.640
Now, this doesn't go for every
image in your application,

00:09:08.680 --> 00:09:11.810
but there may be times during your
application where you might decide

00:09:11.810 --> 00:09:15.300
it's a little bit better if we
already had this object in memory.

00:09:15.320 --> 00:09:17.020
We do have a little bit
of memory on the device,

00:09:17.040 --> 00:09:19.040
so we can use it.

00:09:19.050 --> 00:09:21.780
But when you make this
sort of optimization,

00:09:21.810 --> 00:09:24.270
always be prepared to release
those objects when you

00:09:24.330 --> 00:09:27.250
have low memory conditions,
and we'll talk a lot about

00:09:27.250 --> 00:09:29.160
that later on in this talk.

00:09:30.260 --> 00:09:32.960
The next optimization is the
best sort of optimization.

00:09:32.960 --> 00:09:35.800
It's the type of optimization
that we give you for free,

00:09:35.920 --> 00:09:39.180
and that's using ping files.

00:09:39.440 --> 00:09:43.420
Now, we have chosen the ping format on
iPhone because we have some very,

00:09:43.420 --> 00:09:46.680
very good performance
changes that we've made,

00:09:46.760 --> 00:09:49.660
and we optimize our ping
files at build time.

00:09:49.660 --> 00:09:53.060
They're very quick to load,
and they have all the great translucency,

00:09:53.100 --> 00:09:56.280
and they have the alpha channels
so that you can have the great

00:09:56.280 --> 00:09:57.910
graphics that you expect.

00:09:58.130 --> 00:10:01.770
When you hit build in Xcode,
Xcode automatically optimizes

00:10:01.770 --> 00:10:06.890
your pings and converts them to an
optimized format that we can draw very,

00:10:06.890 --> 00:10:08.500
very quickly on iPhone.

00:10:08.590 --> 00:10:10.900
This means that your
images will appear very,

00:10:11.020 --> 00:10:13.240
very quickly when you launch your app.

00:10:13.240 --> 00:10:16.680
So if you use ping files,
you get this benefit for free.

00:10:18.890 --> 00:10:20.820
Now, there are a few tips for OpenGL ES.

00:10:20.940 --> 00:10:23.490
This was covered in great
detail earlier in the week,

00:10:23.490 --> 00:10:26.500
and there will be a lot of
OpenGL people at the lab tomorrow.

00:10:26.500 --> 00:10:30.170
But for anybody who is developing games,
of course,

00:10:30.300 --> 00:10:34.840
realize that OpenGL is a little bit
different from OpenGL on Mac OS X.

00:10:34.840 --> 00:10:38.450
In particular,
it's a tile-based deferred renderer,

00:10:38.500 --> 00:10:43.440
and so that has some implications that
if you went to the talk on Tuesday,

00:10:43.440 --> 00:10:45.980
they explained exactly what this means.

00:10:46.020 --> 00:10:48.060
It means it's very well
optimized for memory,

00:10:48.060 --> 00:10:51.200
but you have to design your
application a little bit differently.

00:10:51.200 --> 00:10:56.390
Textures and renderer buffers
are limited to 1024 by 1024.

00:10:56.500 --> 00:11:00.120
And, of course, we don't have any
separate graphics memory.

00:11:00.120 --> 00:11:02.660
Your texture memory is shared
with application memory,

00:11:02.660 --> 00:11:05.260
so it makes memory management very,
very important.

00:11:05.260 --> 00:11:09.500
One main optimization that we
use here is if you have layers,

00:11:09.500 --> 00:11:13.680
try not to transform them because
it will give you a fairly,

00:11:13.680 --> 00:11:15.610
fairly expensive cost.

00:11:15.920 --> 00:11:17.910
It will be likely to drop frames.

00:11:17.920 --> 00:11:21.250
And, of course,
some operations may not be available

00:11:21.260 --> 00:11:23.100
that are available on OS X.

00:11:23.100 --> 00:11:26.540
And there's a lot of great,
great documentation on the

00:11:26.720 --> 00:11:28.490
iPhone OS programming guide.

00:11:29.600 --> 00:13:13.500
[Transcript missing]

00:13:13.740 --> 00:13:15.680
And then, of course,
you have this poster image.

00:13:15.680 --> 00:13:16.960
That's another view, so that's three.

00:13:16.960 --> 00:13:18.720
You have the title.

00:13:18.720 --> 00:13:19.440
That's four.

00:13:19.440 --> 00:13:21.480
You have the ratings image.

00:13:21.740 --> 00:13:22.370
That's five.

00:13:22.540 --> 00:13:26.120
If you want an intern to spend
a couple hours doing something,

00:13:26.120 --> 00:13:29.540
have them research the font
used for the rating image.

00:13:29.600 --> 00:13:33.160
The cast, of course, that's another one.

00:13:33.470 --> 00:13:37.910
And finally, you have all of your nice
description that we have.

00:13:37.960 --> 00:13:42.730
So from this randomly chosen movie,
we've showed how many views that we have.

00:13:43.600 --> 00:13:47.060
So you don't want to be creating
all of those views as you scroll.

00:13:47.060 --> 00:13:50.300
That's why we have this great
optimization that's super easy to use.

00:13:50.350 --> 00:13:52.010
So always, always use it.

00:13:52.120 --> 00:13:56.290
Now, there's one more optimization that's
a little bit more work and only

00:13:56.290 --> 00:13:58.520
applicable in some special cases.

00:13:58.520 --> 00:14:02.710
And if you have all of that content,
that's a lot of subviews.

00:14:02.820 --> 00:14:07.570
So one thing you can do if you have a
table view that is the plain style table,

00:14:07.670 --> 00:14:10.580
and it doesn't show any
editing or reordering,

00:14:10.660 --> 00:14:14.240
those sorts of controls,
you can actually collapse all of

00:14:14.240 --> 00:14:16.000
these views into a single view.

00:14:16.130 --> 00:14:20.600
And that actually makes core animation
do a little bit less work as you

00:14:20.600 --> 00:14:21.900
are scrolling through the system.

00:14:21.900 --> 00:14:25.790
And we'll show you what that
optimization looks like in a little bit.

00:14:27.530 --> 00:14:30.960
So now that we've shown you a few
things that you can do for performance,

00:14:30.970 --> 00:14:33.950
how do you figure out which one
of these things that I just showed

00:14:33.950 --> 00:14:35.690
you actually applies to your app?

00:14:35.840 --> 00:14:39.660
Well, we have the absolute best set
of performance tools that are

00:14:39.660 --> 00:14:41.990
available on any mobile platform.

00:14:42.090 --> 00:14:43.640
And we've had a couple
of sessions on them.

00:14:43.640 --> 00:14:46.700
There's some sessions later on
about these performance tools.

00:14:46.780 --> 00:14:48.740
The first one is Instruments.

00:14:49.040 --> 00:14:51.370
Now,
Instruments gives you a nice suite of

00:14:52.100 --> 00:14:57.140
instruments that helps you figure out
what's going wrong in your application.

00:14:57.440 --> 00:14:58.860
So we have a sampling tool.

00:14:58.860 --> 00:15:03.350
We have an object allocation tool
to track your memory usage so that

00:15:03.350 --> 00:15:06.800
when your memory is high and you
don't know exactly why it's high,

00:15:06.810 --> 00:15:09.980
it will actually tell you what
classes are currently in use

00:15:09.980 --> 00:15:10.960
and where they were allocated.

00:15:10.990 --> 00:15:12.860
It gives you a lot of great information.

00:15:12.860 --> 00:15:16.480
An activity monitor tool to figure
out what's going on in the system.

00:15:16.480 --> 00:15:19.240
A leaks tool,
because memory leaks are very,

00:15:19.240 --> 00:15:20.700
very bad for this device.

00:15:20.700 --> 00:15:24.400
And you want to never,
ever have memory leaks when you submit

00:15:24.400 --> 00:15:27.290
your application to the iTunes store.

00:15:27.600 --> 00:15:30.140
And we have a core animation
tool that will show you a lot

00:15:30.140 --> 00:15:34.500
about the core animation layers,
and we'll demo that in a moment,

00:15:34.610 --> 00:15:37.870
and an OpenGL tool so that you
can optimize your great games.

00:15:37.880 --> 00:15:42.650
In addition to Instruments,
we brought Shark over to iPhone.

00:15:42.660 --> 00:15:45.420
So Shark will give you a breakdown.

00:15:45.420 --> 00:15:48.370
For those many of you who have
developed on Mac OS X before are very,

00:15:48.370 --> 00:15:49.920
very familiar with this tool.

00:15:50.700 --> 00:15:54.140
The great thing about Shark and
Instruments too is that neither of those

00:15:54.140 --> 00:15:57.660
applications forces you to recompile
your application and then run them

00:15:57.660 --> 00:15:59.760
in some special programming environment.

00:15:59.760 --> 00:16:01.860
Both of them,
you can take already compiled

00:16:01.870 --> 00:16:05.220
applications and just run these
performance tools against them.

00:16:05.220 --> 00:16:07.710
And in the case of Shark,
it will give you a time profile

00:16:08.040 --> 00:16:11.260
so that you can figure out what
your program is doing at many,

00:16:11.260 --> 00:16:12.620
many points in time.

00:16:12.620 --> 00:16:17.780
And it will also have sophisticated data
mining technologies that will allow you

00:16:17.780 --> 00:16:20.680
to figure out exactly what's going wrong.

00:16:20.700 --> 00:16:22.520
in your program.

00:16:22.520 --> 00:16:25.290
And we'll show you
Shark in a moment as well.

00:16:25.990 --> 00:16:27.710
So now the question is,
we have all these great

00:16:27.710 --> 00:16:28.630
performance tools.

00:16:28.790 --> 00:16:30.540
Some of them apply to the simulator.

00:16:30.540 --> 00:16:31.900
Some of them apply for the phone.

00:16:31.900 --> 00:16:34.940
So which tool should
you use for performance?

00:16:34.940 --> 00:16:38.430
Well, on the simulator,
object alloc and leaks are the

00:16:38.430 --> 00:16:42.690
great instruments that work both
on the simulator and the device.

00:16:42.690 --> 00:16:45.750
Memory allocations are often
roughly comparable on the

00:16:45.750 --> 00:16:48.360
simulator and the device,
as are memory leaks.

00:16:48.500 --> 00:16:50.950
If you have a leak in
your own code on Mac OS X,

00:16:50.950 --> 00:16:54.940
it's fairly likely that you have a
leak on the device and vice versa.

00:16:54.940 --> 00:16:57.280
But always run it in
both just to be sure.

00:16:57.280 --> 00:17:00.360
And also we have,
if you went to the instruments

00:17:00.360 --> 00:17:03.590
talk earlier today,
there are also the Mac OS X set

00:17:03.670 --> 00:17:07.630
of tools that allow you to do
some fairly sophisticated things

00:17:07.630 --> 00:17:12.340
like detrace even in the simulator
because it is just a Mac OS X app.

00:17:12.360 --> 00:17:16.480
On the device, of course,
we have Shark that's available.

00:17:16.480 --> 00:17:21.000
And, of course,
we have... have all the instruments too.

00:17:21.620 --> 00:17:25.130
So the main thing that I want to get
across is that things like sampling

00:17:25.370 --> 00:17:30.020
aren't quite as applicable on the
Mac as they are on the device.

00:17:30.190 --> 00:17:33.790
In fact, a sample that you get
from the Mac OS X may be,

00:17:33.840 --> 00:17:35.660
in fact,
completely different from a sample

00:17:35.660 --> 00:17:37.530
you would get on the device.

00:17:37.660 --> 00:17:41.060
So you should always run your sampling,
your Shark,

00:17:41.110 --> 00:17:44.120
on the device and not on the simulator.

00:17:44.120 --> 00:17:46.520
We make it really,
really easy for you to do this.

00:17:46.520 --> 00:17:51.190
So always run your performance
tools on the device.

00:17:51.410 --> 00:17:54.210
And so now with all of
those things in mind,

00:17:54.400 --> 00:17:57.010
let's actually take the app
that we showed before and

00:17:57.010 --> 00:17:58.730
let's make it a lot better.

00:17:58.880 --> 00:18:05.120
So to demonstrate this,
Peter is going to show us the app.

00:18:05.120 --> 00:18:07.040
Hi again.

00:18:08.100 --> 00:18:11.820
So at the end of the last demonstration,
our movies app was in pretty bad shape.

00:18:12.000 --> 00:18:14.840
You guys remember we'd scroll around
on it and it was just real chunky.

00:18:14.840 --> 00:18:17.070
And that's not really the
first impression that we

00:18:17.070 --> 00:18:18.560
want to leave our users with.

00:18:18.690 --> 00:18:22.680
So how do we go about finding that
performance issue and then fixing it?

00:18:22.800 --> 00:18:25.020
Well, let's take a look here.

00:18:28.500 --> 00:18:30.400
We're going to go ahead
and open up Xcode again.

00:18:30.400 --> 00:18:33.710
I'll bring up our project here.

00:18:34.740 --> 00:18:37.400
And this time I'm going
to go ahead and say,

00:18:37.560 --> 00:18:42.120
start with Performance tool
and say Core Animation.

00:18:42.170 --> 00:18:46.380
The Core Animation instrument is a
great tool for understanding what and

00:18:46.380 --> 00:18:49.060
how often we're drawing to the screen.

00:18:49.130 --> 00:18:53.980
It's also great to help diagnose
the most common issue that we see,

00:18:54.040 --> 00:18:56.460
the most common performance
issue that we see,

00:18:56.510 --> 00:18:59.760
which is unnecessary blending
of transparent layers.

00:18:59.800 --> 00:19:02.660
This is very computationally
intensive and will lead to

00:19:02.730 --> 00:19:04.560
dropped frames when we do this.

00:19:04.700 --> 00:19:07.290
So here we have instruments.

00:19:07.520 --> 00:19:10.300
You'll notice in the top right
hand corner we have a large

00:19:10.340 --> 00:19:11.880
frames per second indicator.

00:19:12.630 --> 00:19:15.730
Since we update the screen,
as Dave mentioned,

00:19:15.740 --> 00:19:20.070
60 times per second on the device,
you'll want to be as close to 60 frames

00:19:20.070 --> 00:19:22.730
per second here as you're scrolling.

00:19:23.100 --> 00:19:26.580
Next, we're going to go ahead down here
under the Debug Options portion

00:19:26.960 --> 00:19:29.910
and check Color Blended Layers.

00:19:30.070 --> 00:19:33.280
What this will do is for any
subviews that are transparent,

00:19:33.340 --> 00:19:35.100
it'll color them red.

00:19:35.170 --> 00:19:38.320
Let's see what our application
looks like on the device.

00:19:38.320 --> 00:19:42.470
So can we switch to the-- whoops,
in here?

00:19:42.600 --> 00:19:44.040
That's pretty red, huh?

00:19:44.090 --> 00:19:46.130
So in other words,
we're spending a lot of time

00:19:46.180 --> 00:19:48.870
blending all these layers together.

00:19:50.880 --> 00:19:52.800
So that's the Core Animation tool.

00:19:52.900 --> 00:19:56.350
Let's go ahead and
switch back here to this.

00:19:56.360 --> 00:19:58.350
And quit this.

00:20:00.490 --> 00:20:01.960
Next, Shark.

00:20:02.060 --> 00:20:05.640
Shark is an incredibly powerful
performance analysis tool that helps

00:20:05.640 --> 00:20:07.600
you find hotspots in your code.

00:20:07.720 --> 00:20:11.250
If you've used Shark in the past,
you'll find it's on the device,

00:20:11.370 --> 00:20:13.920
it's just like running
it on the computer.

00:20:13.990 --> 00:20:17.390
To get a better understanding of why
our movie's apps is scrolling slowly,

00:20:17.390 --> 00:20:19.160
let's take a look at this in Shark.

00:20:19.160 --> 00:20:22.150
So I'm going to go ahead
and bring this up here.

00:20:25.120 --> 00:20:28.840
Now, notice here under the sampling menu,
we have an option called

00:20:28.840 --> 00:20:30.890
Network and iPhone Profiling.

00:20:31.200 --> 00:20:32.180
So we'll select that.

00:20:32.320 --> 00:20:35.340
And notice, here's our device right here.

00:20:35.340 --> 00:20:37.320
When I check that,
I'm going to go ahead and tell

00:20:37.350 --> 00:20:42.180
Shark that I'd like to use this,
use this phone that I have right here.

00:20:43.140 --> 00:20:44.480
And there it is.

00:20:44.640 --> 00:20:50.010
So to debug our scrolling issue,
I would launch my application,

00:20:50.040 --> 00:20:53.960
hit Start here, this button right here,
scroll around a bit, hit Stop,

00:20:53.960 --> 00:20:57.340
and then take a look at
the resulting profile.

00:20:57.390 --> 00:20:59.160
Now in the interest of time,
I've already got that

00:20:59.200 --> 00:21:01.460
shark trace right here.

00:21:02.310 --> 00:21:04.960
So we're in the tree top-down view.

00:21:05.120 --> 00:21:06.200
Dave, what's your favorite view?

00:21:06.200 --> 00:21:08.730
What do you like to use when
you're just taking a look at

00:21:08.730 --> 00:21:09.710
an application real quick?

00:21:09.920 --> 00:21:11.880
DAVE MYERS: So usually the first time
I look at an application,

00:21:11.880 --> 00:21:14.470
I look at the top-down view just
to give me an idea about where

00:21:14.860 --> 00:21:16.840
time is spent in the application.

00:21:16.860 --> 00:21:20.320
The second view, the heavy view,
which is sort of a bottom-up view,

00:21:20.650 --> 00:21:23.370
lets you find if there's a
particular function that's a very,

00:21:23.370 --> 00:21:25.060
very hot spot in your code.

00:21:25.080 --> 00:21:27.480
It often finds that one really,
really quickly so that

00:21:27.480 --> 00:21:30.460
you'll know if you have a
computationally expensive function,

00:21:30.460 --> 00:21:32.400
which one to optimize.

00:21:33.100 --> 00:21:35.980
We're looking at the top down view here,
which gives us, like Dave said,

00:21:36.050 --> 00:21:39.140
a good high level view of
where our app's spending time.

00:21:39.160 --> 00:21:42.410
We can drill down and see one
function call another here.

00:21:42.510 --> 00:21:44.910
So for example,
we have the UI application main,

00:21:45.330 --> 00:21:48.880
which eventually calls this
UI table view layout subviews,

00:21:49.070 --> 00:21:51.780
where it's decided whether
or not we need to bring in a

00:21:51.780 --> 00:21:53.570
new cell as we're scrolling.

00:21:53.710 --> 00:21:57.040
So when we look at this,
it looks like we're spending 22.2% of our

00:21:57.180 --> 00:22:01.770
time in this movies view controller table
view cell for row index path function,

00:22:01.960 --> 00:22:04.700
which then itself calls this
movie summary cell in it

00:22:04.720 --> 00:22:07.490
with frame reuse identifier.

00:22:08.110 --> 00:22:12.720
So let's go ahead and switch to the
chart view and take a look at this here.

00:22:12.790 --> 00:22:15.980
In the chart view,
we have a graphical way of seeing

00:22:15.980 --> 00:22:18.640
how much time our program is running.

00:22:18.690 --> 00:22:22.460
Notice that whenever you see blue,
that's our movies application running.

00:22:22.550 --> 00:22:27.300
And when you see yellow,
it's that movie summary cell

00:22:27.740 --> 00:22:31.350
function that we had highlighted
in the previous window.

00:22:31.350 --> 00:22:31.350
So let's zoom in here and see
how long we're running for.

00:22:33.080 --> 00:22:34.760
So looking at this,
this is a pretty long time.

00:22:34.760 --> 00:22:38.580
We're running for, from here to here,
we're running a little

00:22:38.700 --> 00:22:40.070
over 30 milliseconds.

00:22:40.170 --> 00:22:43.600
If we want to be at 60 frames
per second in our scrolling,

00:22:43.650 --> 00:22:48.140
then we only have about 16.6 milliseconds
for each frame to update our table view.

00:22:48.150 --> 00:22:52.160
So we're going to have to spend a
lot less time in this table view

00:22:52.160 --> 00:22:54.630
and movie summary cell function.

00:22:55.300 --> 00:22:58.470
So the two big problems we've
found in our code so far is that,

00:22:58.500 --> 00:23:01.640
number one,
we have transparent layers that

00:23:01.640 --> 00:23:05.010
don't need to be transparent,
which can lead to expensive

00:23:05.110 --> 00:23:06.730
and unnecessary blending.

00:23:06.900 --> 00:23:11.900
And number two,
we're spending too much time

00:23:11.900 --> 00:23:11.900
in this table view function.

00:23:12.080 --> 00:23:14.460
Let's find and fix these in our code.

00:23:14.600 --> 00:23:18.770
So to fix the transparency issue,
I'm going to go ahead and do

00:23:18.770 --> 00:23:20.630
a search here for clear color.

00:23:20.970 --> 00:23:22.820
And here it is in our code.

00:23:22.870 --> 00:23:26.360
We're setting this background
color of this label to clear.

00:23:26.500 --> 00:23:28.770
So if we were to switch that, we

00:23:29.530 --> 00:23:33.270
So, oftentimes,
you will select your table cells.

00:23:33.380 --> 00:23:35.570
That's what they're there for.

00:23:35.570 --> 00:23:38.660
You use it in the navigation hierarchy.

00:23:38.660 --> 00:23:43.890
And when you select a table view cell,
of course, you have your content,

00:23:44.020 --> 00:23:45.430
which is in a label.

00:23:45.520 --> 00:23:50.100
And beneath it,
you'll have the blue selection on iPhone.

00:23:50.640 --> 00:23:54.000
Now, of course, conceptually,
your label is basically a

00:23:54.000 --> 00:23:55.500
square with some text in it.

00:23:55.730 --> 00:23:58.770
And so, if you make that opaque,
then conceptually,

00:23:58.770 --> 00:24:01.740
it seems as though when
you put it on your table,

00:24:01.740 --> 00:24:05.840
you would get, when the user selects
your table view cell,

00:24:05.840 --> 00:24:09.500
that you would actually have a giant,
big rectangle that would look really,

00:24:09.580 --> 00:24:11.170
really ugly when you select it.

00:24:11.460 --> 00:24:15.070
But because this is really,
really common, the UI table view actually

00:24:15.080 --> 00:24:17.690
is really smart about this,
and it will actually swap

00:24:17.850 --> 00:24:20.920
that label's color to clear
when you make the selection.

00:24:20.950 --> 00:24:23.760
So, when you set it to white,
you'll have the great scrolling

00:24:23.760 --> 00:24:26.270
performance that you have,
which is identical to your

00:24:26.270 --> 00:24:27.980
table cell's background color.

00:24:27.980 --> 00:24:30.460
And when you have selection,
you'll get all of the great

00:24:30.460 --> 00:24:32.800
benefits of translucency,
which is a view that looks

00:24:32.800 --> 00:24:34.270
exactly as you want it to look.

00:24:34.360 --> 00:24:38.290
So, always make sure that if you have a
label that's on a white background,

00:24:38.290 --> 00:24:40.650
just set it to the white color,
and you'll get your better

00:24:40.650 --> 00:24:41.320
scrolling performance.

00:24:41.460 --> 00:24:44.910
performance with just
that one line of code.

00:24:45.070 --> 00:24:48.320
So going from clear to white fixes
the issue that we saw earlier

00:24:48.320 --> 00:24:50.040
in the Core Animation tool.

00:24:50.510 --> 00:24:53.850
Next, how do we speed up our
usage of the table view?

00:24:53.960 --> 00:24:57.790
Let's take a look at the method that
provides the cell to the table view.

00:24:58.730 --> 00:25:00.830
And looking at this function,
it looks like we're not

00:25:00.840 --> 00:25:02.600
reusing the table view.

00:25:02.600 --> 00:25:05.800
The table cells, excuse me.

00:25:05.800 --> 00:25:08.580
Reuse identifier set to nil right here.

00:25:09.300 --> 00:25:13.460
But rather, we're creating a new
table row for each cell.

00:25:13.480 --> 00:25:15.440
A new table cell for each row, excuse me.

00:25:15.460 --> 00:25:16.800
This is really important.

00:25:16.860 --> 00:25:19.710
You cannot get smooth
scrolling without cell reuse.

00:25:19.820 --> 00:25:20.760
Let me repeat that.

00:25:20.820 --> 00:25:25.060
You cannot get smooth
scrolling without cell reuse.

00:25:25.110 --> 00:25:30.540
So we'll go ahead and change
our code here to do cell reuse.

00:25:30.950 --> 00:25:33.540
comment out this guy up here.

00:25:33.650 --> 00:25:36.100
See, we have this movie string,
a summary identifier,

00:25:36.110 --> 00:25:40.750
and a string that we then pass into
the reuse identifier right here.

00:25:41.960 --> 00:25:44.500
Now, there's one more optimization
that I don't have time to show

00:25:44.550 --> 00:25:48.050
you that Dave mentioned earlier,
and that's the consolidation of

00:25:48.220 --> 00:25:49.960
all the layers into one layer.

00:25:50.150 --> 00:25:52.510
Depending on your application,
this may or may not

00:25:52.610 --> 00:25:54.140
make a big difference.

00:25:54.290 --> 00:25:57.690
In this case, in this application,
it actually ends up

00:25:57.690 --> 00:25:59.620
making a big difference.

00:25:59.740 --> 00:26:03.110
So I've got another
version here on the device,

00:26:03.110 --> 00:26:09.180
on the phone, that has all three of
these optimizations.

00:26:09.180 --> 00:26:13.580
So if we could switch to the device here.

00:26:16.120 --> 00:26:20.640
And when we scroll now,
it's a lot smoother.

00:26:20.770 --> 00:26:23.000
Dave?

00:26:23.110 --> 00:26:24.830
Thanks, Peter.

00:26:28.780 --> 00:26:32.050
So the first thing that I always
look at every time somebody says,

00:26:32.110 --> 00:26:33.480
I have a scrolling problem.

00:26:33.480 --> 00:26:35.380
What do we need to do to make it better?

00:26:35.400 --> 00:26:38.180
I make sure that that view is opaque.

00:26:38.280 --> 00:26:41.540
So make sure you always
mark your views as opaque.

00:26:41.540 --> 00:26:44.630
Draw minimally, so don't draw anything
more than you need to.

00:26:44.750 --> 00:26:47.500
And for games,
drawing minimally also expands to when

00:26:47.660 --> 00:26:50.380
the screen isn't actually changing,
don't draw.

00:26:50.380 --> 00:26:52.330
It will reduce your battery life.

00:26:53.600 --> 00:26:55.430
Reuse table cells, always.

00:26:55.670 --> 00:26:59.280
I tend to consider this as not so
much an optimization as a requirement

00:26:59.280 --> 00:27:01.250
when you're using table views.

00:27:01.280 --> 00:27:04.720
Reuse is so important for
good scrolling performance.

00:27:04.720 --> 00:27:05.650
You should always use it.

00:27:05.700 --> 00:27:09.000
And for some applications,
you may want to collapse the

00:27:09.070 --> 00:27:12.670
cell layer hierarchy for,
again, the plain style table when

00:27:12.670 --> 00:27:14.620
you don't support editing.

00:27:14.620 --> 00:27:17.110
And if you have something that's really,
really complicated,

00:27:17.120 --> 00:27:19.270
sometimes that will be a
good optimization for you.

00:27:20.780 --> 00:27:24.280
So that's drawing and scrolling,
where we took an application that was

00:27:24.280 --> 00:27:29.580
probably a free app and made it into
something that maybe we could charge for.

00:27:29.670 --> 00:27:33.600
So now that was drawing and scrolling,
let's talk about application launch.

00:27:33.730 --> 00:27:36.540
Now,
application launch on iPhone is super,

00:27:36.550 --> 00:27:38.240
super critical.

00:27:38.460 --> 00:27:42.000
On Mac OS X,
say some Hollywood director living in

00:27:42.000 --> 00:27:47.480
Hollywood is working on their Macintosh,
they may have Final Cut Pro open all day

00:27:47.480 --> 00:27:50.960
and just be living in that application,
and that's their job.

00:27:51.130 --> 00:27:54.540
On iPhone,
the most common user scenario is to

00:27:54.540 --> 00:27:58.410
take your iPhone out of your pocket,
maybe check the weather,

00:27:58.460 --> 00:28:01.290
and then brag to all your friends
about how good it is here,

00:28:01.420 --> 00:28:03.610
and then put it back in your pocket.

00:28:03.730 --> 00:28:07.910
So you really want to have a very,
very fast application launch.

00:28:08.030 --> 00:28:10.020
So when you are designing
your application,

00:28:10.020 --> 00:28:12.530
both the UI and the
actual implementation,

00:28:12.720 --> 00:28:16.780
consider what the user needs immediately
when they launch to their app.

00:28:16.830 --> 00:28:20.230
You want to make your app launch and
quit as quick as possible so that

00:28:20.230 --> 00:28:23.800
users can get what they need done very,
very quickly.

00:28:23.890 --> 00:28:26.920
So get your UI on the screen
as quickly as possible,

00:28:26.980 --> 00:28:29.910
and that means don't load
data until you need it.

00:28:30.120 --> 00:28:34.370
Now, UI view controller has a lot of
wonderful optimizations that do

00:28:34.370 --> 00:28:37.660
all the stuff for you so that we
don't actually load the view until

00:28:37.800 --> 00:28:39.800
the view appears on the screen.

00:28:39.920 --> 00:28:44.380
And make sure that if you have a large,
large list, maybe you don't want to

00:28:44.380 --> 00:28:45.640
load all 500 records.

00:28:45.640 --> 00:28:50.040
Maybe you just want to load the
first 20 or 30 or some small subset.

00:28:50.200 --> 00:28:54.370
You just want to make every optimization
you can make so that the application

00:28:54.370 --> 00:28:57.390
will appear on screen really,
really quickly.

00:28:57.620 --> 00:29:00.170
We've done this in
basically all of our apps,

00:29:00.170 --> 00:29:03.050
but a couple of great
examples are the phone.

00:29:03.050 --> 00:29:07.770
If you launch to, say, the context view,
you don't really want to spend time

00:29:07.770 --> 00:29:11.760
loading all of this keyboard stuff
or keypad stuff and vice versa.

00:29:11.760 --> 00:29:15.480
So this is an example of that
UI view controller optimization

00:29:15.480 --> 00:29:17.960
where we only load what's on screen.

00:29:17.960 --> 00:29:20.920
And the same goes for your
back-end data structures.

00:29:20.920 --> 00:29:25.110
Not only do we not load the actual views,
we don't load any of the data that we do

00:29:25.110 --> 00:29:27.360
not need when you launch to this view.

00:29:27.500 --> 00:29:28.600
Amen.

00:29:28.870 --> 00:29:33.510
Now, most of the applications on iPhone,
if you just take a rundown of them,

00:29:33.510 --> 00:29:35.640
access the internet right away.

00:29:35.920 --> 00:29:38.440
YouTube, basically every other app does.

00:29:38.440 --> 00:29:42.220
And what we do in our applications,
and we suggest you do too,

00:29:42.220 --> 00:29:46.170
is we try to quickly display all
the user interface that we can.

00:29:46.170 --> 00:29:48.280
So we have the bottom button bar.

00:29:48.280 --> 00:29:51.640
We have our nice little
segmented control at the top.

00:29:51.640 --> 00:29:56.080
And we give the user some feedback,
both in the status bar with our little

00:29:56.080 --> 00:29:58.780
loading spinner and in our actual app.

00:29:58.800 --> 00:30:01.980
And we have our little view saying that,
oh, we're loading this data.

00:30:01.980 --> 00:30:04.350
So if you launch and display
everything that you can,

00:30:04.350 --> 00:30:06.940
but then as you're doing the
expensive network operations,

00:30:07.030 --> 00:30:10.540
provide some feedback to the user
that you are actually doing something.

00:30:10.540 --> 00:30:14.230
That will make the user experience a lot
better when you don't have control over

00:30:14.230 --> 00:30:16.330
how quickly those resources will load.

00:30:16.340 --> 00:30:20.480
And also keep in mind that you have
different connection types on iPhone.

00:30:20.580 --> 00:30:23.650
You could be on Edge if you're
in my home state of Wyoming.

00:30:23.860 --> 00:30:27.440
You could be on 3G if you're in
a lot of places in the country.

00:30:27.440 --> 00:30:28.780
Or you could be on Wi-Fi if you're
in a lot of places in the country.

00:30:28.780 --> 00:30:31.390
which is your best case scenario.

00:30:32.700 --> 00:30:37.970
So defer as much as you can and
show everything that you can on

00:30:37.970 --> 00:30:42.010
application launch that doesn't
require going over the network.

00:30:42.020 --> 00:30:44.750
So that's a quick summary
of application launch.

00:30:44.840 --> 00:30:49.500
And now on to a very big topic,
which may be new to a lot of people,

00:30:49.500 --> 00:30:51.630
and that's memory usage.

00:30:51.640 --> 00:30:54.880
Now, memory usage is important
on any computing device,

00:30:54.880 --> 00:30:59.960
but on iPhone, it's very, very,
very important because the memory

00:30:59.960 --> 00:31:03.300
that you use will directly impact
both the performance and the

00:31:03.300 --> 00:31:04.800
stability of your applications.

00:31:04.800 --> 00:31:07.470
In particular,
as you are using more and more

00:31:07.470 --> 00:31:11.140
memory in your application,
we send out memory warnings that

00:31:11.140 --> 00:31:15.200
will tell you you're reaching a
high watermark in memory usage.

00:31:15.200 --> 00:31:16.350
You may want to free some memory.

00:31:16.360 --> 00:31:18.700
If you ignore that and
keep going and keep going,

00:31:18.700 --> 00:31:21.420
then eventually the system will say, hey,
I'm out of memory.

00:31:21.500 --> 00:31:22.200
I can't do anything.

00:31:22.200 --> 00:31:23.960
We must quit that frontmost application.

00:31:23.960 --> 00:31:26.870
So memory usage is really,
really important to

00:31:26.870 --> 00:31:28.640
optimize on your iPhone.

00:31:28.640 --> 00:31:31.050
And so let's talk a
little bit about that.

00:31:31.150 --> 00:31:35.270
So why do we have these memory warnings
and maybe kill the frontmost app?

00:31:35.390 --> 00:31:36.600
Well, there's no swap file.

00:31:36.600 --> 00:31:39.940
So we have all the great virtual
memory and all the other modern

00:31:39.940 --> 00:31:43.100
features of this modern OS,
but there's no swap file.

00:31:43.100 --> 00:31:45.980
So that means that any
application pages that you dirty,

00:31:45.990 --> 00:31:49.270
any of your data models or things
like that that aren't statically

00:31:49.480 --> 00:31:51.480
loaded code or statically loaded data,
you can't do anything about that.

00:31:51.480 --> 00:31:51.480
So that means that any
application pages that you dirty,

00:31:51.480 --> 00:31:51.480
any of your data models or things
like that that aren't statically

00:31:51.480 --> 00:31:51.480
loaded code or statically loaded data,
you can't do anything about that.

00:31:51.480 --> 00:31:52.800
So you have to stay in memory.

00:31:52.800 --> 00:31:57.570
And all of your pages that are
read-only will be evicted and reloaded.

00:31:57.580 --> 00:31:59.420
So if you're up at that
threshold at the top,

00:31:59.490 --> 00:32:02.420
then your performance may degrade
if you have to bring in new code.

00:32:02.420 --> 00:32:05.190
So you want to use a
small amount of memory,

00:32:05.190 --> 00:32:08.500
as small amount of memory
as you can at the time.

00:32:08.500 --> 00:32:15.120
Now, the one optimization that's really
important for iPhone is memory mapping.

00:32:15.120 --> 00:32:18.520
And I'll talk a little about that in
the files and data loading segment.

00:32:18.520 --> 00:32:21.420
But it's a technique where you
can use a small amount of memory.

00:32:21.470 --> 00:32:24.400
memory for large data sets.

00:32:25.300 --> 00:32:26.990
So of course,
we have all the normal things

00:32:27.000 --> 00:32:29.480
that you are familiar with,
with C and Objective-C.

00:32:29.700 --> 00:32:32.280
We manage memory with
alloc init autorelease,

00:32:32.280 --> 00:32:35.670
retain release autorelease
to manage reference counts.

00:32:35.700 --> 00:32:38.280
We don't have garbage
collection on the phone.

00:32:38.280 --> 00:32:42.100
But of course, we have the standard C,
malloc and free, C++, new and delete,

00:32:42.120 --> 00:32:44.120
all the things that you're used to.

00:32:44.120 --> 00:32:48.920
So this is the same model that
you're used to on other platforms.

00:32:48.920 --> 00:32:54.060
So we're going to talk about three
different memory optimization classes.

00:32:54.320 --> 00:32:57.170
The first is static memory,
which is memory that you can

00:32:57.170 --> 00:32:59.300
optimize before your code even runs.

00:32:59.600 --> 00:33:05.880
Then dynamic memory,
the code that all of the memory

00:33:05.880 --> 00:33:08.240
that you use in the application.

00:33:08.270 --> 00:33:11.780
And of course,
how to cover the new feature on iPhone,

00:33:11.860 --> 00:33:13.830
which is memory warnings.

00:33:15.200 --> 00:33:17.260
So the first thing we
actually do for you for free,

00:33:17.390 --> 00:33:20.220
which is we try to reduce code size.

00:33:20.220 --> 00:33:24.300
And we do this with the
-mthumb compiler flag.

00:33:24.570 --> 00:33:27.120
So what is this thumb thing?

00:33:27.120 --> 00:33:31.240
Well, our ARM core actually supports
two different instruction sets.

00:33:31.240 --> 00:33:36.530
One is the normal ARM 32-bit instructions
and another is this subset called thumb,

00:33:36.530 --> 00:33:38.680
which is 16 bits.

00:33:38.680 --> 00:33:42.810
And of course, if you do the math,
if your code size is half the size,

00:33:42.810 --> 00:33:45.490
then that's going to give you
a nice performance benefit

00:33:45.490 --> 00:33:48.720
because you won't have to read
as much code to launch your app.

00:33:48.720 --> 00:33:53.690
Less code will give you less code
that's being executed - sorry,

00:33:53.690 --> 00:33:58.290
a smaller code size will often equal
better performance because we won't have

00:33:58.290 --> 00:34:01.180
to evict code pages as your memory grows.

00:34:01.180 --> 00:34:04.550
And so thumb is a really nice
optimization and it's so important to

00:34:04.550 --> 00:34:08.090
us that we make it the default in Xcode.

00:34:08.370 --> 00:34:10.610
So then the question becomes,
if this optimization is so great,

00:34:10.690 --> 00:34:12.560
why not do it for
everything all the time,

00:34:12.650 --> 00:34:14.310
and why even have a compiler flag?

00:34:14.320 --> 00:34:18.180
Well, there's one little catch to Thumb,
and that's that if you have

00:34:18.180 --> 00:34:21.930
intensive floating point operations,
you may notice a small

00:34:21.930 --> 00:34:23.480
performance difference.

00:34:23.500 --> 00:34:28.360
So things like games,
Thumb may not be suitable for them.

00:34:28.360 --> 00:34:32.990
But for many things like UI layouts,
basically all the apps that you can think

00:34:33.100 --> 00:34:37.010
of that just do some basic UI layout,
interact with UIKit,

00:34:37.580 --> 00:34:40.400
those sorts of applications,
Thumb will be a great optimization,

00:34:40.400 --> 00:34:42.220
and you won't notice a
performance difference.

00:34:42.310 --> 00:34:43.860
Performance difference isn't big.

00:34:43.860 --> 00:34:46.430
If you have a really, really,
really intensive

00:34:46.430 --> 00:34:50.200
floating point operation,
you can actually do one neat thing,

00:34:50.200 --> 00:34:53.350
which is compile just single
files for ARM and compile

00:34:53.350 --> 00:34:55.200
everything else for Thumb.

00:34:55.200 --> 00:34:59.230
So we give you a lot of control
over this compiler optimization.

00:34:59.300 --> 00:35:02.110
A second one,
since we are in the business

00:35:02.110 --> 00:35:06.580
of decreasing code size,
one nice easy one is another checkbox,

00:35:06.790 --> 00:35:08.280
which is dead code stripping.

00:35:08.280 --> 00:35:10.940
So when your application is linked,
it will try to figure out if

00:35:10.940 --> 00:35:14.540
there are any functions that are
implemented but not referenced,

00:35:14.540 --> 00:35:16.020
and just eliminate those.

00:35:16.210 --> 00:35:19.400
And so that's a nice quick
optimization for you.

00:35:20.360 --> 00:35:23.950
Another couple of compiler
flags for anybody who uses C++

00:35:24.100 --> 00:35:28.020
are Objective-C exceptions and
run type type identification,

00:35:28.020 --> 00:35:30.140
which is used for things
like dynamic cast.

00:35:30.140 --> 00:35:34.950
So if you're using C++ code,
you may consider not using either of

00:35:35.360 --> 00:35:39.720
these features because on the limited
processing power that we have on iPhone,

00:35:39.720 --> 00:35:42.400
we really need all the
horsepower that we can get.

00:35:42.500 --> 00:35:45.770
If you can do it by clicking a checkbox,
that's often really, really good.

00:35:46.800 --> 00:35:49.790
So if you can disable
those when applicable,

00:35:49.790 --> 00:35:52.420
you'll get a performance benefit.

00:35:53.080 --> 00:35:55.540
And of course,
we have the built-in optimization

00:35:55.540 --> 00:35:57.480
that we talked about before,
which are pings are

00:35:57.480 --> 00:35:58.560
optimized at build time.

00:35:58.560 --> 00:36:01.380
In addition to that,
property lists are converted

00:36:01.380 --> 00:36:04.220
to a compact binary format,
which gives you two wins.

00:36:04.220 --> 00:36:06.030
The first is a nice size win.

00:36:06.290 --> 00:36:08.660
The files will be a little bit smaller.

00:36:08.660 --> 00:36:12.310
And the second one,
which is really critical at app launch,

00:36:12.460 --> 00:36:14.960
is actually a CPU win,
which is parsing the

00:36:15.020 --> 00:36:17.850
binary files is much,
much faster than parsing

00:36:18.100 --> 00:36:19.460
the large XML files.

00:36:19.470 --> 00:36:22.980
So that's two wins for property lists
that you get for free with the app.

00:36:23.020 --> 00:36:24.670
text code.

00:36:25.680 --> 00:36:29.100
And now, we need to talk a little
bit about dynamic memory.

00:36:29.240 --> 00:36:33.940
So, dynamic memory, of course,
as your application is running,

00:36:33.940 --> 00:36:36.680
you want to have as small
a footprint as possible.

00:36:36.930 --> 00:36:40.440
And in Leopard, we introduced these nice
Objective-C2 properties,

00:36:40.670 --> 00:36:44.920
which allow you to basically
have accessors and getters

00:36:44.920 --> 00:36:46.590
without actually writing them,
which is really nice,

00:36:46.600 --> 00:36:50.360
or just have a nice little syntax.

00:36:50.670 --> 00:36:52.910
One thing that we recommend,
especially as the

00:36:52.910 --> 00:36:56.380
applications grow and grow,
is to mark the properties as non-atomic.

00:36:56.700 --> 00:37:01.530
We've done this all over our system,
and this gives you a couple of benefits.

00:37:01.630 --> 00:37:06.050
The first is that access is up to
10 times faster because we don't

00:37:06.070 --> 00:37:09.840
need to worry about thread safety,
and the objects are not auto-released,

00:37:10.050 --> 00:37:12.280
so it actually saves you some
memory as you're going on.

00:37:12.450 --> 00:37:15.890
And that's more important as
your applications grow in size,

00:37:15.900 --> 00:37:17.500
as inevitably they will.

00:37:19.220 --> 00:37:23.520
The next thing that you
can do is cache wisely.

00:37:23.630 --> 00:37:26.540
Now, we have a very,
very limited amount of memory on iPhone,

00:37:26.810 --> 00:37:28.690
but that memory is available.

00:37:28.810 --> 00:37:31.980
And so if regenerating
something takes a long time,

00:37:32.080 --> 00:37:35.490
then we might make the trade-off
to actually cache that object so

00:37:35.500 --> 00:37:38.820
that we don't have to compute it and
so that when the user goes to that

00:37:38.830 --> 00:37:42.720
view or performs some operation,
it will be really, really fast.

00:37:42.840 --> 00:37:45.150
So don't be afraid to
cache the right objects.

00:37:45.280 --> 00:37:48.680
But when you decide when you've
measured that CPU win and decided

00:37:48.820 --> 00:37:52.780
you will make that decision to cache
the objects and keep it in memory,

00:37:52.820 --> 00:37:55.140
design your application so
that you can release those

00:37:55.140 --> 00:37:56.400
objects when they're needed.

00:37:56.450 --> 00:37:59.720
And we'll tell you how to
do that in a little bit.

00:37:59.780 --> 00:38:03.990
And the other thing is to free objects
when you're actually done with them.

00:38:04.050 --> 00:38:08.550
So we don't want memory
hanging around as we're going.

00:38:08.790 --> 00:38:13.150
And a nice example of
that is auto-release.

00:38:13.260 --> 00:38:15.420
So auto-release is this
wonderful mechanism,

00:38:15.420 --> 00:38:18.740
particularly for APIs,
where you can just pass objects around.

00:38:18.740 --> 00:38:21.880
And you don't have to worry about
the details of how it was allocated

00:38:21.880 --> 00:38:23.850
or I don't need to release this.

00:38:24.010 --> 00:38:25.540
It's really easy to use.

00:38:25.550 --> 00:38:27.870
But auto-release has
a couple of penalties.

00:38:27.970 --> 00:38:32.580
The first is a CPU penalty because
that auto-release pool has to be freed.

00:38:32.620 --> 00:38:36.800
And the second is a memory penalty where
if that object could have been released,

00:38:36.800 --> 00:38:39.660
but because it's on the auto-release
pool it hasn't been yet,

00:38:39.720 --> 00:38:43.310
then you actually will be carrying
along a little bit more memory until

00:38:43.320 --> 00:38:45.870
the auto-release pool is freed.

00:38:45.990 --> 00:38:49.020
So to optimize for-- for
the use of auto-release,

00:38:49.020 --> 00:38:50.080
we do two things.

00:38:50.180 --> 00:38:53.240
The first one is you're really,
really familiar,

00:38:53.240 --> 00:38:56.440
if you developed on Mac OS X,
with these convenience methods,

00:38:56.500 --> 00:38:58.550
such as NSString, string with format.

00:38:58.850 --> 00:39:00.930
So you might do something
like create a string,

00:39:01.120 --> 00:39:03.340
stuff it into a dictionary,
and then not worry about it

00:39:03.340 --> 00:39:05.330
for later with that method.

00:39:05.490 --> 00:39:07.690
Now, in this case,
auto-release isn't actually

00:39:07.690 --> 00:39:09.330
necessary to get this job done.

00:39:09.340 --> 00:39:12.630
We can actually allocate the string
and then directly release it once

00:39:12.730 --> 00:39:16.480
we've transferred ownership to,
say, the NSDictionary.

00:39:16.620 --> 00:39:21.010
So this gives you the memory
win such that if this dictionary

00:39:21.010 --> 00:39:25.120
goes away at some point,
then all that memory will be gone.

00:39:25.190 --> 00:39:27.440
And additionally, the CPU benefit,
because you don't have to spend

00:39:27.440 --> 00:39:31.440
time draining the auto-release pool,
it will just go away when it goes away.

00:39:32.650 --> 00:39:35.620
And when you are using
the auto release pools,

00:39:35.620 --> 00:39:39.990
there may be times when you want
to prevent object accumulation.

00:39:40.270 --> 00:39:43.420
So, for example,
a tight loop or there may be a

00:39:43.420 --> 00:39:47.540
lot of our system APIs will return
auto released objects to make

00:39:47.540 --> 00:39:49.480
memory management easy for you.

00:39:49.520 --> 00:39:52.090
In some cases,
you may want to have your own auto

00:39:52.090 --> 00:39:54.660
release pool to prevent object buildup.

00:39:54.660 --> 00:39:58.270
And the object instrument will
give you a really nice view of how

00:39:58.270 --> 00:40:01.820
your object hierarchy is building
up and give you some good examples

00:40:01.820 --> 00:40:03.840
of when that might be important.

00:40:04.010 --> 00:40:07.060
Now, of course,
one of the important things on iPhone

00:40:07.060 --> 00:40:09.050
is to eliminate all memory leaks.

00:40:09.050 --> 00:40:12.930
It's really, really important on all
platforms to eliminate leaks.

00:40:12.930 --> 00:40:16.320
But on iPhone, it can actually be pretty
deadly to have memory leaks,

00:40:16.320 --> 00:40:21.080
particularly as they build up over time
as the user is using your application.

00:40:21.080 --> 00:40:24.840
So, it's really,
really important to eliminate all memory

00:40:24.840 --> 00:40:27.460
leaks before you ship your application.

00:40:27.460 --> 00:40:30.070
And of course, we want to make this as
easy for you as possible.

00:40:30.070 --> 00:40:30.390
So, let's go ahead and start.

00:40:30.410 --> 00:40:30.700
So, let's go ahead and start.

00:40:30.710 --> 00:40:31.020
So, let's go ahead and start.

00:40:31.020 --> 00:40:31.090
So, let's go ahead and start.

00:40:31.090 --> 00:40:31.160
So, let's go ahead and start.

00:40:31.160 --> 00:40:31.380
So, let's go ahead and start.

00:40:31.380 --> 00:40:31.380
So, let's go ahead and start.

00:40:31.380 --> 00:40:31.710
So, let's go ahead and start.

00:40:31.760 --> 00:40:31.820
So, let's go ahead and start.

00:40:31.820 --> 00:40:33.940
So, naturally,
we have a leaks instrument.

00:40:33.940 --> 00:40:37.970
And Peter Handel will
demo that to you now.

00:40:44.720 --> 00:40:46.880
As Dave mentioned,
memory is a very precious

00:40:46.900 --> 00:40:48.440
resource on our system.

00:40:48.640 --> 00:40:52.240
So memory leaks are deadly,
not just to performance,

00:40:52.420 --> 00:40:54.760
but also to the stability
of our application.

00:40:54.930 --> 00:40:57.520
Because you can imagine, like Dave said,
if our application starts

00:40:57.530 --> 00:41:00.260
gobbling up lots of memory,
leaking all over the place,

00:41:00.390 --> 00:41:02.360
it may be asked to leave the party.

00:41:02.520 --> 00:41:06.800
So let's go ahead and see how can
we find these leaks and fix them.

00:41:10.660 --> 00:41:14.820
So here we are in Xcode again.

00:41:14.960 --> 00:41:17.920
And this time,
we have a slightly different application.

00:41:17.950 --> 00:41:21.540
What this one does is it
shows time zone information.

00:41:21.570 --> 00:41:24.870
And now what I'm going
to go ahead and do is--

00:41:25.100 --> 00:41:30.400
Click up here on-- make sure
the simulator is selected.

00:41:30.460 --> 00:41:32.160
Build and go.

00:41:33.410 --> 00:41:34.770
And here it is.

00:41:35.030 --> 00:41:35.960
We see time zones.

00:41:35.960 --> 00:41:41.290
We see what you'd see if
you look out the window.

00:41:41.290 --> 00:41:41.290
And

00:41:42.920 --> 00:41:43.760
There we have it.

00:41:43.830 --> 00:41:48.220
Now let's go ahead and open
this guy up in the leaks tool.

00:41:48.330 --> 00:41:52.270
So we're going to say start
with performance tool and leaks.

00:41:58.660 --> 00:41:59.080
So here we are.

00:41:59.100 --> 00:42:00.760
Instruments is opened up.

00:42:00.810 --> 00:42:01.840
Here's the leaks instrument.

00:42:01.920 --> 00:42:03.780
We'll click on that.

00:42:04.750 --> 00:42:08.240
And we see, uh-oh,
we have a couple leaks down here.

00:42:08.310 --> 00:42:08.970
What are we going to do?

00:42:09.140 --> 00:42:12.240
So let's click on one of these.

00:42:12.330 --> 00:42:15.240
And down here,
we have a handy little box,

00:42:15.310 --> 00:42:16.880
extend detail view.

00:42:17.010 --> 00:42:20.890
When we check that, on the right side,
we see the actual backtrace

00:42:20.890 --> 00:42:22.800
of the memory allocation.

00:42:22.860 --> 00:42:26.800
This is incredibly useful.

00:42:26.800 --> 00:42:32.090
And notice that these frames
are colored by a framework.

00:42:32.340 --> 00:42:35.700
Now, let's scroll to the bottom and look
at the first frame in our program,

00:42:35.730 --> 00:42:37.850
which happens to be purple here.

00:42:38.020 --> 00:42:40.140
This is the region sort zones.

00:42:40.250 --> 00:42:43.340
If we double-click on it,
it will take us straight to the line

00:42:43.560 --> 00:42:46.280
where that piece of memory was allocated.

00:42:46.330 --> 00:42:48.860
In this situation,
it was an NS sort descriptor that

00:42:48.860 --> 00:42:50.890
we allocated called sort descriptor.

00:42:51.000 --> 00:42:54.640
And next, we allocate an NSArray,
sort descriptors, plural.

00:42:54.680 --> 00:42:57.960
A little further down,
we release the sort descriptor.

00:42:58.020 --> 00:43:00.540
But there's no release
of the sort descriptors,

00:43:00.540 --> 00:43:01.180
plural.

00:43:01.330 --> 00:43:03.330
So to fix this,

00:43:04.640 --> 00:43:06.770
Add a little s there.

00:43:06.890 --> 00:43:07.380
And there we go.

00:43:07.380 --> 00:43:10.050
We're releasing the
NSArray that we allocated.

00:43:10.220 --> 00:43:13.190
So I'll go ahead and save that.

00:43:13.240 --> 00:43:15.280
Quit out of this.

00:43:16.500 --> 00:43:19.000
Here.

00:43:19.020 --> 00:43:21.470
And this time, I'm going to build this.

00:43:21.580 --> 00:43:27.690
Start with Performance Tool leaks.

00:43:30.500 --> 00:43:31.820
Our application starts again.

00:43:31.820 --> 00:43:36.890
We scroll around a little bit,
cross our fingers, hit the leaks button.

00:43:37.360 --> 00:43:40.960
and... two leaks.

00:43:41.060 --> 00:43:44.050
But we've gotten rid
of the main other leak,

00:43:44.050 --> 00:43:50.160
so... Dave?

00:43:51.600 --> 00:43:54.360
Sometimes in my interviews,
I'll ask people, how do you find leaks?

00:43:54.490 --> 00:43:56.220
And well,
now you know the answer for iPhone.

00:43:56.220 --> 00:43:58.940
You just click Run in Leaks,
and you're pretty much done.

00:43:58.940 --> 00:44:02.870
It's actually surprising how many leaks
happen because of something like that,

00:44:02.870 --> 00:44:05.590
where you have transferred
ownership to another object

00:44:05.590 --> 00:44:07.100
and just forgot to release it.

00:44:07.280 --> 00:44:10.270
Another common case in Cocoa is
just forgetting to release your

00:44:10.270 --> 00:44:12.060
instance variable in the alloc.

00:44:12.060 --> 00:44:14.670
So it's really,
really easy to find them and to find your

00:44:14.670 --> 00:44:16.850
allocation points through instruments.

00:44:17.540 --> 00:44:20.210
So always make sure to run this as
you are testing your application,

00:44:20.210 --> 00:44:21.780
and it's really, really helpful.

00:44:21.780 --> 00:44:22.890
I've done this about 40 times.

00:44:23.200 --> 00:46:36.800
[Transcript missing]

00:46:38.850 --> 00:46:42.050
So to summarize,
purge all of your off-screen views

00:46:42.050 --> 00:46:45.690
and any layers that you have built up
that aren't visibly on the screen when

00:46:45.690 --> 00:46:47.610
you receive these memory warnings.

00:46:47.740 --> 00:46:50.080
Remove any cached objects that you have.

00:46:50.080 --> 00:46:52.650
And if you have any
cached resource files,

00:46:52.650 --> 00:46:54.070
get rid of those too.

00:46:54.160 --> 00:46:56.360
That's three things to do
for low memory warnings.

00:46:57.500 --> 00:46:59.700
So there's a lot about memory.

00:46:59.860 --> 00:47:02.460
The first is make sure you use
the right compiler settings.

00:47:02.460 --> 00:47:05.600
You get Thumb for free and some
other optimizations for free.

00:47:05.600 --> 00:47:08.980
The second is minimize object lifetimes.

00:47:08.980 --> 00:47:12.660
So that goes for memory that is
auto-released and cached objects.

00:47:12.660 --> 00:47:15.440
When you're done with memory,
get rid of them.

00:47:16.910 --> 00:47:18.950
Eliminate all memory leaks,
which is really easy

00:47:18.960 --> 00:47:23.300
to do with instruments,
and respond to low memory notifications.

00:47:23.390 --> 00:47:27.210
All of these things will help you
write a good iPhone application that

00:47:27.330 --> 00:47:29.390
will use a small amount of memory.

00:47:31.910 --> 00:47:36.190
Next, we'll talk a little bit
about files and data.

00:47:36.240 --> 00:47:40.980
So the first thing is large files.

00:47:40.980 --> 00:47:42.740
Because you have a
limited amount of memory,

00:47:42.740 --> 00:47:45.960
you may not be able to read all
of them in just main memory.

00:47:45.960 --> 00:47:49.420
So we have the same APIs that
are available on Mac OS X,

00:47:49.420 --> 00:47:53.490
but are even more important on iPhone,
and that's MMAP.

00:47:53.490 --> 00:47:56.680
And of course,
one of the higher level interfaces

00:47:56.680 --> 00:48:01.250
to this is NSData init with contents
of mapped file if you're in Cocoa.

00:48:02.500 --> 00:49:47.800
[Transcript missing]

00:49:48.680 --> 00:49:51.300
That's files and data.

00:49:51.350 --> 00:49:54.760
The last one is power and battery life,
where we have really,

00:49:54.760 --> 00:49:57.240
really good battery life on our iPhone.

00:49:57.270 --> 00:49:59.620
And it's important that all
applications that we write

00:49:59.960 --> 00:50:02.420
also have great battery life.

00:50:03.140 --> 00:50:05.850
Everything that you do
on iPhone consumes power,

00:50:06.100 --> 00:50:09.710
whether it's the CPU, your GPU,
or any other part of the

00:50:09.710 --> 00:50:10.940
hardware that you're using.

00:50:10.940 --> 00:50:12.040
It will consume power.

00:50:12.040 --> 00:50:15.480
And so we want to make sure
that all of our – that our

00:50:15.480 --> 00:50:17.900
power is as optimal as possible.

00:50:17.900 --> 00:50:21.310
Now, to show you a little bit,
we'll go into detail about

00:50:21.320 --> 00:50:23.080
a couple of these things.

00:50:23.080 --> 00:50:26.400
But the CPU, GPU takes power,
any radio that you have,

00:50:26.400 --> 00:50:30.590
so your Wi-Fi and your data connection
over the cell phone network.

00:50:30.800 --> 00:50:34.980
The display takes memory – or, sorry,
takes power, and so does GPS.

00:50:34.980 --> 00:50:39.060
Everything consumes power,
and so we need to optimize the things

00:50:39.470 --> 00:50:42.200
that we can as application developers.

00:50:42.200 --> 00:50:46.670
So what are some of the high-level
things that we can get rid of?

00:50:46.870 --> 00:50:50.640
Well, first off is the network is very,
very expensive.

00:50:50.740 --> 00:50:53.550
So that means we don't want to
constantly be transmitting and

00:50:53.550 --> 00:50:55.410
receiving data in our application.

00:50:55.420 --> 00:50:58.600
And, in fact,
transmitting data is the most

00:50:58.690 --> 00:51:00.780
expensive operation that we can do.

00:51:00.780 --> 00:51:02.800
And that's what we do on iPhone.

00:51:02.830 --> 00:51:05.920
So if we do not need to transmit data,
then don't.

00:51:05.920 --> 00:51:09.340
And when we transmit data,
if you have a choice in the file formats,

00:51:09.340 --> 00:51:11.040
use the compact file formats.

00:51:11.250 --> 00:51:16.160
And chatty protocols also have a
significant impact on battery life.

00:51:16.160 --> 00:51:20.090
Our power management model
is based on shutting things

00:51:20.090 --> 00:51:22.280
off when we don't need them.

00:51:22.280 --> 00:51:25.350
So if you know that you don't
need them as quickly as possible,

00:51:25.470 --> 00:51:27.620
do a quick burst of all
of your network data,

00:51:27.620 --> 00:51:29.400
and then don't do network data.

00:51:29.400 --> 00:51:30.720
It turns out that often,
you don't need them.

00:51:30.720 --> 00:51:35.770
Often times just chatting, chatting,
chatting can have a significant

00:51:35.880 --> 00:51:37.840
impact on battery life.

00:51:38.980 --> 00:51:41.360
So transmission is very, very expensive.

00:51:41.390 --> 00:51:43.770
Now,
Core Location gives you a great set of

00:51:43.770 --> 00:51:49.140
features that will enable you to write
really good location-based applications.

00:51:49.140 --> 00:51:53.220
And there are a couple of optimizations
we can make in Core Location.

00:51:53.220 --> 00:51:58.710
The first one is to stop the location
service once you have a location fix.

00:51:58.840 --> 00:52:00.990
So once I know that I'm
in the Moscone Center,

00:52:00.990 --> 00:52:03.610
then you don't need to have
any more updates to know that

00:52:03.700 --> 00:52:05.480
Starbucks is across the street.

00:52:06.110 --> 00:52:09.150
So stop the location service,
and that will save battery life.

00:52:09.220 --> 00:52:14.260
And the second thing is only request
the location accuracy that you need.

00:52:14.280 --> 00:52:18.300
So if I'm trying to figure out services
that are in my general vicinity,

00:52:18.300 --> 00:52:24.100
but I don't need to know which corner
block I am and get that accurate GPS fix,

00:52:24.100 --> 00:52:28.630
then we can request a location accuracy
that's a little bit wider and still

00:52:29.190 --> 00:52:31.770
provide the same high-quality service.

00:52:31.800 --> 00:52:34.260
So those are a couple things
you can do in Core Location

00:52:34.340 --> 00:52:35.980
to optimize your battery life.

00:52:36.000 --> 00:52:39.630
So for battery life,
you have the few optimizations

00:52:39.630 --> 00:52:41.820
that we told you about.

00:52:41.820 --> 00:52:44.160
One is, of course,
performance improvements.

00:52:44.320 --> 00:52:47.170
If you're not doing things on the CPU,
that actually saves battery life.

00:52:47.240 --> 00:52:51.350
So anything you do in Shark to reduce
the amount of CPU that you're using

00:52:51.490 --> 00:52:53.350
will improve battery life for the users.

00:52:53.580 --> 00:52:54.090
And that's great.

00:52:54.180 --> 00:52:56.390
They want their phone to last the
whole day and a lot longer than that,

00:52:56.390 --> 00:52:56.910
hopefully.

00:52:56.920 --> 00:53:01.230
Minimize the amount of network traffic
that you have and transmit data in

00:53:01.230 --> 00:53:03.490
bursts and receive data in bursts.

00:53:03.540 --> 00:53:05.650
Configure Core Location.

00:53:05.740 --> 00:53:09.180
Optimally for your app so that it only
does exactly what you need it to do.

00:53:09.200 --> 00:53:12.140
And your users will
have good battery life.

00:53:14.670 --> 00:53:17.160
So we've talked about
several things today.

00:53:17.190 --> 00:53:20.540
We showed you an application whose
scrolling performance was terrible.

00:53:20.560 --> 00:53:24.770
And with all the advice that we gave
you with the drawing optimizations,

00:53:24.770 --> 00:53:27.520
the opaque subviews,
the table cell reuse,

00:53:27.690 --> 00:53:30.080
we made that application great.

00:53:30.080 --> 00:53:33.890
We talked a little bit about what we have
to do as developers to make applications

00:53:33.890 --> 00:53:38.580
launch quickly so that users will want
to use them over and over and over again.

00:53:38.580 --> 00:53:42.420
We optimized memory and showed you when
you do use a large amount of memory,

00:53:42.420 --> 00:53:46.120
as some applications inevitably will,
how to remove caches,

00:53:46.120 --> 00:53:48.960
delete any memory that we don't need.

00:53:48.960 --> 00:53:52.440
We talked a little bit about files
and data and the importance of

00:53:52.440 --> 00:53:55.740
using M mapping so that you don't
have large data sets in your file.

00:53:55.750 --> 00:53:58.480
And of course, power and battery life.

00:53:58.500 --> 00:54:00.320
Users want their phone to last.

00:54:00.320 --> 00:54:02.450
It's their connection
to the outside world.

00:54:02.520 --> 00:54:05.440
It's very important to users that
their phone be able to last the day

00:54:05.440 --> 00:54:08.460
and that they'll be able to call
their wife or their husband when

00:54:08.460 --> 00:54:12.510
they get home and talk about their
day and do whatever they want to do.

00:54:12.760 --> 00:54:14.640
So there are a few sessions.

00:54:14.640 --> 00:54:15.960
Most of them have happened already.

00:54:15.960 --> 00:54:20.430
The 3G graphics for iPhone using
OpenGL ES has some great slides and

00:54:20.430 --> 00:54:24.240
a lot of detail about performance
characteristics of OpenGL ES.

00:54:24.340 --> 00:54:27.770
There's one session at 5 o'clock today,
Performance Tuning

00:54:27.860 --> 00:54:31.360
Your Application with Shark,
which they'll have demos on

00:54:31.360 --> 00:54:34.000
both the Mac and the iPhone,
and they'll go into a lot

00:54:34.000 --> 00:54:34.880
of detail about Shark.

00:54:35.450 --> 00:54:37.700
Getting Starting with Instruments,
which is early today,

00:54:37.700 --> 00:54:41.120
2D graphics and animation for iPhone,
and debugging and profiling

00:54:41.140 --> 00:54:42.710
your iPhone application.

00:54:42.750 --> 00:54:45.800
So check out all of those videos
after the session if you're

00:54:45.800 --> 00:54:47.510
interested in more details.

00:54:47.520 --> 00:54:51.740
And there are two labs that
we'd love to see you at.

00:54:51.870 --> 00:54:53.700
The first one is right
after this session,

00:54:53.800 --> 00:54:55.920
the iPhone Application Optimization Lab.

00:54:55.920 --> 00:54:56.360
I'll be there.

00:54:56.360 --> 00:54:57.500
Lots of other people will be there.

00:54:57.500 --> 00:55:01.260
And tomorrow, we'll also have an iPhone
Performance Optimization Lab,

00:55:01.630 --> 00:55:04.760
where we'll have, if you have games that
you want to optimize,

00:55:04.940 --> 00:55:07.790
we'll have a lot of graphics
people there and a lot more

00:55:07.790 --> 00:55:09.730
people there tomorrow as well.

00:55:09.870 --> 00:55:12.470
So there are a lot of opportunities
for you to get one-on-one

00:55:12.490 --> 00:55:13.760
help on your application.

00:55:13.760 --> 00:55:16.220
And of course,
our standard documentation,

00:55:16.220 --> 00:55:19.320
and you can contact Vicky
Murley for more information.

00:55:20.820 --> 00:55:25.940
So now we can handle some questions.
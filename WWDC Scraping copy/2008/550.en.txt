---
Title:  Integrating with Final Cut Server
Year:   2008
Web:    https://nonstrict.eu/wwdcindex/wwdc2008/550/

[!] This transcript was generated using Whisper, it has known transcription errors.
---

What we're going to show today, or by the way, I'm Matthew McManuus. I'm from the Final Cut Server engineering team. And to help me, I've got Eryk Vershen as well. So, today, yesterday we saw what was in some of the aspects of Final Cut Server with regard to the pieces you need to actually deploy it, as well as some things involved in the actual deployment.

So today, I'm going to show how to-- the mechanisms to actually integrate with Final Cut Server. And then I'll show you some ways to actually do the integration. So, I'm going to give you a brief product overview, just for those who didn't see it yesterday. Then I'll show you the mechanisms of integration. And finally, I'll show you some integration examples.

So Final Cut Server was released a few months ago, and it was to address two main areas. So media asset management, and to do that, we connect two devices, so an AFP share, an XAN, so forth and so on. And then we catalog the files on those devices, and we can move files to and from those devices as well.

There's also a very customizable metadata model, and we'll see that during the talk today and how we can use that to drive events and other such responses. It's a client-server model, so the server runs on Leopard, either client or server, and the client, the client itself, runs on either Tiger, Leopard, or XP or Vista.

And the key component which we're going to use with the integration is the subscription and response workflow. So this is comprised-- there's 14 different responses in Final Cut Server to do everything from do a copy and transcode, send an email, do a scan, all these other different responses.

And they can be triggered by three different mechanisms. There's a schedule, so you can do a response on a timed basis. Or a watch folder. So Final Cut Server can be monitoring a folder on a connected device and do some of these actions or responses when it sees a new file go into that folder.

And finally, there's subscriptions. My personal favorite. You're able to subscribe to events in Final Cut Server. And events are things like when an asset is created, or when an asset is modified or deleted, or when a user logs in. Each of these are different events. And then when you're building these workflows and subscriptions, You can subscribe to the events, so when an asset is modified, and then you can further filter what you're trying to catch to trigger the response.

So you can say, I am going to look for all assets that are modified on my exan. "Where the status equals ready for review. And when all of that matches, I'm going to do the actions I assign to that subscription." And we'll see that in a lot of detail as we go through the examples today.

So the mechanisms of integration that we have in Final Cut Server, there's three of them that I'm going to show today. We've got the ability to read and write metadata in files. There's also the ability to read and write XML content, so to export XML and to import XML to change assets.

And there's also the very powerful ability to run an external script or command on the local machine. So let's talk about the reading and writing of metadata and files first. So there's two types of files that we support, QuickTime as well as XMP metadata, which is contained in files.

So I'll talk about QuickTime metadata first. So when Final Cut Server catalogs a file, for example, a QuickTime file, it reads the metadata from that QuickTime file. So that's then available in Final Cut Server. And you can map the QuickTime metadata to whatever fields you like in Final Cut Server. And then when you're writing out QuickTime files from Final Cut Server, you can also map metadata from Final Cut Server to the QuickTime files. Now let's talk about what you can actually do. So QuickTime 7 and above has some very extensible metadata support.

It can contain any sort of metadata. There is some metadata which you can set using, say, the QuickTime Pro application. So in QuickTime, they're called annotations. But the actual metadata that you can put in is completely definable. So there's actually a wide range of support of metadata in cameras, like cameras from, say, Sony or Panasonic, the P2 or XD Cam, or the RED Camera. As well as other devices which put metadata into QuickTime files.

Now, if you're ingesting with the Final Cut Pro Login Transfer Tool, the metadata from those files gets written to the QuickTime files that are written as part of the ingest process. So for example, in a P2 file, there's some 14 or 17 different fields. All of those get written to the QuickTime file. So Final Cut Server reads that metadata from the QuickTime file.

But there are certain, you know, if there are new fields in the QuickTime file, what Final Cut Server is able to do is dynamically add those new QuickTime fields to files that it understands. And you can create mappings from the metadata in the QuickTime files. to fields inside of Final Cut Server.

So you need to create these mappings. There are some mappings which exist already. So the mappings, for example, from the QuickTime Pro annotations will map directly into an asset of, say, media metadata type. But you can build whatever mappings you like to go from the QuickTime fields to the Final Cut Server fields and back again.

So let's actually have a look about how to actually do this. So here I've got a file which I had ingested from a P2 card. It's a motorcycle head-on. So if I want to have a look at the metadata in a file, I can use the Final Cut Server search devices option.

So Search Devices allows you to just view the files that are on a given device. So this is what I've done here. I have ingested, using Final Cut Pro, a P2 file to my local machine. I copied it to my media device, and now I'm doing a device search on my media device. So when I double-click on my MOV, I get my dynamic metadata.

So you can see here we have some default QuickTime metadata, some metadata which came from the Final Cut Pro log and transfer window, so things like the reel and the shot and the take, as well as The 17 different fields which came from the P2. Now, if we look at that a bit closer, we've got the dynamic metadata, as well as all of the possible fields in the QuickTime file that we can view.

So here I've got some things like the creation date on the camera itself, the model name, the serial number, and many other fields. So what I can do is I can choose some of these fields to map into my internal Final Cut Server fields. So here I want to choose my original format field, which is our dynamic metadata QuickTime field.

And then I need to map it to an internal Final Cut Server field. So I have a original format custom metadata field. And I give it a priority. The priority dictates if there's a collision, so if there's metadata from two sources trying to go into the one custom metadata field, so the one internal field, which one takes priority.

And I can select the two-way map checkbox. So this means that when I write back to a QuickTime file, my internal custom metadata field will write back to my QuickTime metadata. So when I actually do this, I've created five different internal fields. I've done my mapping from my P2 fields to my internal fields. And I've put all of that into a separate metadata group.

So if I zoom in on that, I can see now for all of my media which I've ingested from P2, I've now got original format, camera model, the serial number, the data source, as well as the unique P2 ID. So this is extensible to any kind of metadata field that you can find in QuickTime. So for cameras, as I said, XDCAM, RED, and many other different QuickTime files. If you're a vendor wanting to integrate with Final Cut Server, if you put metadata into the QuickTime files, then that's easily read and mapped into fields in Final Cut Server.

So now I'm going to talk a bit about XMP metadata. So XMP metadata can be put in many different file types.

[Transcript missing]

You'll find an XMP metadata in, say, JPEG or raw camera files, Photoshop, TIFF, HTML, or a few other different file types. And what Final Cut Server can do, it's going to read, just like we did with QuickTime, read those XMP fields and map them into Final Cut Server. And just like with QuickTime, you can write back from Final Cut Server to the XMP fields.

Now, there's a few differences. So the XMP, as I said, the support for many different image formats, as well as a few other file formats, and the support for, as I said, Illustrator, HTML, PDF, so anything which contains an XMP. And the raw camera files. So there's a wide range of schemas, but the key thing here is that the schemas that we support are fixed. So unlike the schemas for QuickTime or the dynamic mapping for QuickTime, there's some 200 or 300 XMP possible fields that we can map from. So it should be enough to... It basically... understands all of the possible XMP schemas to date.

And there's some default mappings. So from, say, the XMP description field, that will map into the Final Cut Server description field, keywords to keywords, and a few other mappings. And there's the ability to create new mappings, just like we saw with QuickTime, from the external fields to fields in Final Cut Server, and to go back from Final Cut Server to the XMP fields. So I'll show you an example. So here I've got a number of files. I've got some raw images, which I took from my camera of my cat.

And again, I am looking at these files using the search devices in Final Cut Server. If I have a look here, we'll actually see all of the possible XMP schemas that we support. So there's some 12 different groupings of schemas, and each schema has a number of different fields inside of it.

So we can see here there are the possible groups. And here are the fields inside one of the groups. So if I zoom in on that, there's some fields that-- so here we've got the exif, the tif, the gif, so forth and so on. And here is some useful information that I want to actually map into Final Cut Server from my raw camera files. So I'd like to get the, say, the ISO, the F number, the exposure time. So to do that, it's the same mechanism as with the QuickTime. So I choose my From field, which in this case is going to be type XMP metadata.

Then I can choose a two-field, which I've just called Aperture, quite conveniently. And this is going to be, again, a custom metadata field. So a custom metadata field is a field that is used by Final Cut Server internally. I choose my priority, and I choose my two-way mapping.

So once that's done, I've now again got a different metadata group, which I've called Camera Info. And I've mapped in-- So I've got my F number, my exposure time, my ISO, so forth and so on. So you can see how that if metadata is in the file itself, it's very easy to map into Final Cut Server and to get some really useful metadata for the files.

Because as you get more and more files into the system, the more metadata that you have for them, the easier it is to actually find it. And as we'll see during the rest of the talk, you can actually start to use the metadata to actually derive actions in Final Cut Server. So it can be very powerful. So next up, I'd like to talk about reading and writing XML.

So there's the ability to export XML, and to do this, there's a write XML response. There's also the ability to import XML. And for that, there's a read XML response. So with the right XML response, that exports all of the metadata for a given entity. And by entity, I mean either an asset, a production, or a job. Three different kinds of entities in Final Cut Server.

There's just one parameter for the response, and that's the destination where you actually want to write the XML file to. And it's triggered by a subscription. So I discussed subscriptions earlier. So whatever triggers the subscription, will actually write the metadata for that entity. So if I have an asset triggering a subscription, then all of the metadata for that asset will be written out to the XML file.

So to import-- so the importing imports any metadata for an entity. So you can change the metadata of an asset or a production. And so it must match the schema of the entity that you're trying to set. So if the XML that's being used by the read XML response has additional fields that aren't in the asset that you're trying to change, they'll be ignored.

And this is triggered from a watch folder. So a watch folder is set up. The read XML response is attached to it. And XML files, which get put into that watch folder, then are able to change the metadata for the given entity. So let's have a look a bit closer. If we look at the write XML response, this is an example of an exported XML file from Final Cut Server. So at the top, we've got the opening of the XML. And the critical piece of information is the entity ID. So here we've got asset 2858.

So every entity, every asset, or every production in Final Cut Server has this unique identifier. So there's this ID. So here-- I am getting-- I've had a subscription which has triggered the exporting of XML for this asset. In the next section, I've actually got the actual metadata. So between the two metadata tags, I've got all of the possible fields. And in a typical asset, this would be much larger. I've just made it a bit smaller for presentation. And down the bottom, I'm just closing out the XML file.

Now, when you're setting metadata in Final Cut Server, there's the read XML response. So here, again, we're opening the XML file. Again, the very important thing here is I've got my set MD as well as the entity ID. So I'm changing asset of ID 11447. And then between the params, I have the fields that I'm going to change. So here I'm changing my title, keywords, description, and status.

Then I'm just closing out the-- Closing out the XML. So quite straightforward, and we're going to see a lot more of that as we look at our examples. So the final method of integration that I want to talk about is the ability to run external scripts or commands.

So this allows for the running of a local executable on the machine running the Final Cut Server server component. So the response has two settings. The first one is the command path, so the path to the executable to be run. And the second one is the parameters. So what parameters do you want to give the command?

And the interesting thing about this one is it actually accepts metadata field substitutions in the same way that we saw with email yesterday. So you can actually put in--

[Transcript missing]

So the effective UID of the executable is going to be the UID that's associated with Final Cut Server. So that's important to keep in mind if there's any sort of permission issues or that sort of thing.

Yes, it's triggered from either a watcher, a schedule, or a subscription. So let me give you an example. There's the Graal application, which allows for notifications. So have any of you used Graal? Great. So you know what Graal can do. So there's a command, which is Graal Notify, which allows you to actually set notifications.

So what I can do is I can set a... "Response, which is going to call Growl Notify. And then in my parameters, I can set what the message is. So here I've got, you know, '-m'. Then Final Cut Server, and you can see I have title in square brackets. So what's going to happen there is the contents of the title metadata field will be substituted in to the parameters when the command is run.

So to actually trigger this response, I need to make a subscription. So the details here are I am subscribing to an asset. And then we've got the event types. So I'm looking for when assets are either created-- or slightly under the scroll bar-- is created or modified. And then I have the responses that I want to run as part of the subscription.

So right now, for the filtering, any time that any asset was either created or modified, my response would run. So I get lots and lots of notifications. So I then want to filter down what my subscription is going to trigger on. So to do that, I use asset filtering. So here I'm going to filter. I want to actually only get events when the status equals ready for review. So let's actually have a look at that.

So here I've got Final Cut Server, and I have a single asset. So then if I... So I've got everything set up the way we just saw. So if I then change this asset and make it status, ready for review, I'll actually see up here I now have my Grail notification.

So it's a really simple way to just build out notifications. And we've seen some great talks this week on how to integrate with things like iChat and other technologies. So this kind of notification support can be leveraged in many different ways to suit how you're going to deploy in a given situation. So if we go back to the slides.

So now I'm going to, we're actually, so I've gone through the three. different methods of integration. So we've got reading and writing of metadata in files. We've got the reading and writing of XML, and we've got the ability to run executables as part of a workflow that you've set up in Final Cut Server.

So now we're going to look at three examples of how these mechanisms can be used. We'll look at how to exchange metadata with external systems. How to integrate with Podcast Producer and how to integrate with a web application. And for this, we'll use Ruby on Rails. So, exchanging metadata with external systems.

There's many cases that you might want to actually do this with Final Cut Server. In a lot of cases, there might be existing repositories of metadata. that you will have before you deploy Final Cut Server. Or there's some other systems that do part of the asset management that you want to hand off to.

Or in the example that we'll see, there's additional sources of metadata that can actually get more information than what Final Cut Server can do. So one example of an external system that has lots of extensible metadata is Spotlight. So Spotlight, as we know, comes with the Macs, and it's got very extensible metadata support. So there are-- in Spotlight, you can query some 140--

[Transcript missing]

The metadata support for a given file, plugins can be made for that purpose.

So there's the mdls command, which is a command line tool to query Spotlight metadata on a given file. So, the way this works with Final Cut Server, so I've got Final Cut Server and I've got Spotlight. So what I do in Final Cut Server is to get metadata, I run a script. In this case, it's a Ruby script. I also export some XML.

And then that runs against a file which has been given to the Ruby script, which gets the metadata from Spotlight using the NBLS command, and writes back an XML file using the method we just saw earlier to then set the metadata for that asset in Final Cut Server. So I'll now bring Eryk Vershen up on stage to show that out.

Can we switch to the demo? There we go. Okay, here's my Final Cut Server. There's nothing in here at the moment, so let's switch over to the Finder and bring a song in. Now, I'm going to show you how Spotlight metadata is brought in, so let's go ahead and upload this file. It uploads very quickly. Now, Final Cut Server doesn't understand Spotlight metadata out of the box. We've gone ahead and added a metadata group for Spotlight and also all the metadata fields.

You notice I've got a variety of fields, TIDEM and ALBUM and whatnot. The names here are all the names that they'd have in Spotlight, and the reason I did that was just to eliminate one level of translation. Now, that file doesn't have the right metadata, so let's go ahead and just get rid of him I'm going to our administration window. Let's go ahead and trigger the schedule that I have that's going to scan my iTunes library.

This is scheduled ordinarily to happen in the middle of the night. Let's go ahead and set this up for 11:03 instead. So that's going to trigger in a few seconds. And what it's going to do is execute a response, which is this response down here. I actually built this response initially

[Transcript missing]

Go back and look at any of the songs and look at their metadata.

So let's go ahead and look at how that works in a little more detail. So the scans are simply going to scan the iTunes device. So I created a device in Final Cut Server that points at my iTunes. And if we go over and look at the device, we can see it's pointing at users, demo music, iTunes, iTunes music.

The, um, the, so that, that scan is just going to bring in the assets, but it's not going to pick up the spotlight metadata. In order to do that, what we're doing is we're running a subscription. And that subscription is going to trigger, as Matt said, on created assets. And it's going to have an asset filter and say, I only want to pick up things that are stored on my I-Tunes volume and things that are actually document resources.

Once that triggers, it's going to do two responses. It's going to do a write XML response. Now, the write XML response is going to dump all the metadata for that asset. And the reason we're doing that is simply we want to pick up more than just a couple of fields from the metadata.

And it's much easier to just dump the entire XML than to pass all those on the command line to the script. So then it's going to execute our script, this getMetadata script. Let's go ahead and look at what that looks like. And here's the script. Not much of anything in here. It's just calling my mdimport command and passing it the title.

Let's go ahead and go over to TextMate and take a look at that script. So it's a Ruby script. The front's the, you know, standard set of things. I'm picking up my argument here, and I'm going to open up the file, which is actually the XML file that Final Cut Server has written out. And then I'm going to use a library that I have here. to just simply pull in all of the metadata from that file as a Ruby object. Now, the next thing I have to do is I actually have to pull in my Spotlight metadata.

Well, the Spotlight metadata, as Matt said, comes in from the mdls command. So we can do mdls on this file that's here, and as you can see, What we're getting is all the various metadata. There's the album, audio bit rate, et cetera. Now, the first problem I had was, well, OK, how am I going to parse this spotlight metadata?

Well, it turns out that the format that MDLS is putting out is very close to something called YAML. Now, I know about YAML because I worked with Rails, and I use it quite a bit. YAML stands for YAML Ain't Markup Language. And what it is is a data serialization language that's intended to be human readable. So what I did is I wrote a little script.

That converts the MDLS output into YAML output. And you notice that looks almost identical to what I had before. There's not much going on there. If we go ahead and look at my script there, we can see that it's very simple. It's just running the MDLS, and then it's just running it through a set to change a few characters in order to make it valid. So let's go back to our script, take a look. So that means that I can pull in all of my spotlight metadata with just those two lines.

The first line's pointing at the actual file in my iTunes library. I know where the iTunes library is. That's in this variable. And I'm pulling the location within the iTunes library from this Final Cut Server metadata, and I'm pulling the file name. And then I can just do one command, and I've pulled in all of my spotlight metadata. So I can just go ahead and pull in all of my spotlight metadata as Ruby objects.

But I don't want all of my spotlight metadata to go back to Final Cut Server. So I've got an array of data types here, letting me know just the fields that I'm interested in. If I hadn't named those fields identically, I'd have to have another layer mapping in here to go from the spotlight name into the name that Final Cut Server was using.

Then at the bottom here, all I'm doing is just copying the-- using that set of fields that I'm interested in, copying those fields from the object that has the spotlight metadata into an object that I'm going to use to write out metadata for Final Cut Server. Then I just simply open up a file in a location where Final Cut Server is going to be running a watcher. I pass it some values. I pass it the data types. I pass it the entity ID that I picked up and just tell it to write it out, and now it's all the way out there.

So back in Final Cut Server, what happened was I had a watcher. Here's the spotlight watcher, and all it's doing, it's looking at the It's looking at the volume where I'm writing out the XML. It does a read XML and then deletes the file so it's not sitting around. And read XML just simply pulls in that XML file and does whatever the XML file tells it to you. I'll go into a little more detail on what the XML looks like and how I'm picking those up from the library in the next demo.

So we can see from that there's now the ability to integrate with all manner of different other systems that might have metadata or other information that you want to integrate with your assets. And this mechanism could be extended to integrate with maybe a FileMaker Pro system or some other such systems that you want to use as part of your entire workflow.

Or if there's metadata in some other file format, then some other command line tool can be used to query that metadata and put it back into Final Cut Server. Maybe you want to get metadata from Word documents or something else. These sort of mechanisms can allow you to do that.

So let's have a look at our next example, which is to integrate with Podcast Producer. So who's using Podcast Producer? A few of you? OK. So there's a number of different ways that you can actually leverage Final Cut Server and Podcast Producer together. So, as you know, Podcast Producer is included with Leopard Server.

And one easy way to integrate is to actually use Final Cut Server to actually catalog your podcast content. So you can set your podcast repository as a device. And you can scan that device and any new podcasts automatically get added as assets in Final Cut Server, which can then be used in your Final Cut Server workflows.

You can use the various, the Java clients, so forth and so on, to look at the assets, to do things, to download them, to have metadata about them. Now, one important thing is when you're actually, in your podcast repository, you might actually have a number of different file types for a given podcast.

So, you know, large, small, iPhone, so forth and so on. What you can do is when you set up a scan in Final Cut Server is you can use regular expression matching to actually match only a given size. So, say you only want to catalog the large files.

Now, if you went to the podcast integration talks, Or if you've used Podcast before, you might be aware of the command line tools that are available in Podcast Producer. These are very powerful and allow you to do a lot of very interesting things. So there's the podcast, and you can do lots of things with that, including submit podcasts. And then there's PCAST Action that allows you to process audio and video.

So what we can do from Final Cut Server is we can leverage these commands to do some very interesting things with our assets. So, what I've done here is I've made a Podcast Producer metadata group, and I've made a number of fields for that group. And I've got subscriptions which trigger either using a user-bind podcast or a PCAST action.

"Depending on whether I check one of these check boxes. So for example, I'm able to use PCAST action to add a watermark to a given asset. Or I could submit that asset to a podcast workflow. or add a slate, or merge two clips together if I know the asset ID of another clip, or even use pick-ass action to actually title.

So these are just some of the possibilities. There's much more you can do. And the great thing is that you can then integrate these actions into a given workflow. So say, for example, that you wanted to add a slate to everything going to a Playout server. Then you can have your response, which goes to the Playout server, run the Add Slate command to call PCAST action to add a given slate, and your slate could be populated with metadata, which has come in from the actual asset itself.

So let's actually have a look at that. So again, I've got Final Cut Server here. And what I can do is I can search for some content here. I've got my Podcast Producer. Let me just use this one here. And so I can see I've got my various things I can do.

I can submit this to a podcast, and then it can choose my different podcasts. So I can configure a lookup to match the various podcast options I have. Or maybe you want to add two clips together, so I've got my, I can choose merge clips. And I can choose, say, look at this one and see the asset ID is 118.

So if I do 118 and save changes, then what happens is I've got a subscription. Looking for when I have the merge clips selected. And then it calls a script which calls PCAST action to then merge this asset as well as my asset with the ID of 118. It should be done by about now. So if I then have a look at my merged clips, so here we are. So I've now got a new asset with the two of them merged together.

So I really, I've got a simple, very simple merge. So that's just one of the many, many, many things you can do with integrating. But you can see how you can then leverage the command line tools of Podcast Producer and the ability to then run the scripts or commands from Final Cut Server and build them into a workflow. So if we go back to the slides, please.

So the next example we're going to talk about is how to integrate with a web application. Now, we're going to use Ruby on Rails for this. Ruby on Rails is great because it's included with Leopard. It's really easy to work with and deploy. And there was a fantastic talk yesterday afternoon on how to actually use Ruby on Rails and build Ruby on Rails to do some very interesting websites. So, you can use Ruby on Rails to, or other applications, to make some media-rich web applications. Then you can leverage Final Cut Server to actually generate the web formats and exchange metadata from Final Cut Server to the web application.

And the key thing is that the asset on Final Cut Server is linked to the clip in Ruby on Rails by the asset ID. So we keep on seeing that asset ID. We saw it in the XML. So the asset ID is very, very important to us. And is the way to link external applications and Final Cut Server.

So, in addition, so changes in metadata on the website can then be used to trigger automations in Final Cut Server. So, for example, let's say you change the status on the website to, say, rejected. or approved. Then it can then send back to Final Cut Server To then, you know, send out emails or do whatever has been set up when your asset is set to rejected.

So let's have a look at how this works. So we've got Final Cut Server and our Rails website. Now, Final Cut Server, based upon a subscription, which we've seen earlier, will export both XML, the required QuickTime formats for the website, as well as run a script. And all this then generates a clip in the Rails application.

So the key thing is these are two separate repositories. You can have your web app on a completely different system. And in addition, you can leverage the compressor options in Final Cut Server to go out to different formats as well. So one thing I discussed yesterday is Compressor has additional plug-in support. So if your web application requires something like Flash or Windows Media, you can use the plug-in support in Compressor to use something like Episode Pro from Telestream to go to those additional formats.

So then, from the Rails application to get back to Final Cut Server, we're just using the mechanisms that we've seen earlier. So the Rails application writes an XML, which can then change the metadata for the asset in Final Cut Server. So let's actually have a look at that. And we've got Eryk back to give you a demo.

Okay, so here we are in our Final Cut Server again. You see I've got a few clips in here. Now, if I go and look at this clip, once again, in order to make things happen, we need to have a metadata group. So we have this website metadata group. And as you can see, we have the center web. I already clicked on the center web, which has already caused things to happen. Let's go ahead and take a look at our... Well, actually, I want to leave that up.

Just for grins, you can see, by the way, our status is none. Let's go over and look at our web app. Here's our simple web app that we made where I can get clips in and review them. So let's click over and take a look at our clip.

Now, if I was actually reviewing this clip, I might want to play it. And then down here at the bottom, I can make some comments. So I'm just going to say that's a... I'll have to learn how to type first. And let's see, we'll pretend I'm Bob. Let's go ahead and add a comment. That comment gets added. And now I want to update. I'm going to say, oh, yes, I'm approving this. If we go back and look in Final Cut Server and see, well, it hasn't updated yet. Let's click on the reload.

And there we go. Now it says approved, and I look at the website information, and I see the comments coming back. So let's see, how did that actually work? Let's go to our administration pane. I want to mention that the administration pane is something that you can turn off for a particular user, so that's not something that everybody necessarily gets, and you certainly wouldn't want everybody to get it.

So if we go ahead and look at this, the first thing that we're going to look at is the subscription, which is the main thing that triggers this. So the subscription is looking at both created and modified modification events on assets, and the only thing we're looking at here is the send to web. If send to web equals true, we're going to trigger the subscription, and it's going to do the responses we have in this list. It's going to do a number of things. So number one, we're going to do some transcodes.

So that the web app doesn't have to do that. So we're going to make a JPEG thumbnail. We're going to make a couple of QuickTimes in different sizes. Then I'm going to write out the XML again, just because I want to pick up a number of fields, and it's much easier to do it that way. And then we're going to go ahead and call our last response, which is a script response.

If we go over and look at the responses, I can show you one of those, like the JPEG thumbnail. That's pretty straightforward. It's got a destination, a device that we're actually going to be copying stuff to and a particular relative path within that device, and then transcode settings.

When I create a device, I can set up a number of different transcode settings, and I can change that after the fact if I want. In this case, for this device, since I know these are the only transcodes I want to do, I make those the only ones that are available in the list.

Don't save that. And let's go ahead and look at our script again. Here's the script. The script looks pretty simple, just like the last one did. It's calling a particular script, our little add asset script that we've distributed as part of the Rails application. Let's go over and look and see what that looks like.

It's another Ruby script doing typical Ruby things at the front end. In this case, because we're talking to Rails, we're actually connecting to the database. Those of you who are familiar with Rails will realize that I'm only connecting to the development database, and that really needs to be configurable. So we pick up the title from the arguments.

We're using that again to pick up the file. And you notice in this case, the path looks a little bit different. This time we're pointing at where, again, we're pointing at where Final Cut Server wrote out that XML. And we're using the title that we were passed because we know that's going to be the name that Final Cut Server is going to give that file.

We just open up the file, and then we use our little library to pull in all the values as hash. And I promised I'd talk about that a little bit more, so let's go look at that library. Just a little bit of Ruby code. It's not that big. And when I'm pulling the values back, what it's really doing is getting the document if it doesn't have it and extracting the hashes. And what that's doing, if we look down here, we're using the RexML library. That's built in that comes with the Ruby distribution.

And we're simply creating a RexML document. Then when we want to extract the values, We're simply using RuxML allows us to type an XPath expression to pick up the values that we're interested in, and then we store the text into one hash, and we store the data type into another hash.

Back in here, we've picked that up. Now, ordinarily, I would be deleting the file after I was done with it because there's no reason to have it around, but I'm leaving it around so we can take a look at the file that actually got generated. I'm picking up the asset ID. I'm doing a little fix-up here, and then I'm copying the files over from where... Final Cut Server wrote them out to where my Rails application wants them to be.

Then as the last thing I'm doing, I'm just going to use Rails, use Active Record to create a new record in the database that has the title, has the asset ID, because I'm going to need that when I go back to Final Cut Server and a few other fields that I'm interested in. Now, you'll remember that when we were over here in the web application, we clicked on Update. So what happened when we hit Update?

Well, in the Rails application, that update's going to happen in Clips Controller. Here's the update. And the write-out is just happening right here. I've got one line that's calling a little library routine. So we'll look at that library routine. And all it's doing is first reformatting the web comments from the list that's available in the JavaScript world over into a single string for Final Cut Server. I make a hash with the values that I want to send back to Final Cut Server.

I undo some of that normalization I was doing before, and I set up data types as well. Then to write it out, I'm simply Opening up a file using my little library. You can see I'm setting the entity ID, using the asset ID to recreate the entity ID that Final Cut Server wants in order to make sure that we're going back to the asset that we originated from.

Setting the values, setting the data types, and then writing that out. Let's look at the library again and see what happens when we write out. Here's the write. Again, it's using RexML, creating a document. It's putting in the Final Cut Server element, putting in the request elements. It says we're setting the metadata and the entity ID. And then we're going ahead and adding the individual elements, the MD value, file name, and data type. Let's go ahead and look at those files. So here's the file that we got from Final Cut Server.

As you can see, it has a few more fields than we saw in the slides, but the structure here is very regular, right? All I'm doing is every time there's a field name that tells me what it is, a data type to tell me what kind of thing it is, and then the value. So when I generate the XML, oh, I want to do one thing, and notice our asset here is asset 23.

So here's the file that I'm sending back. That's formatted a little funny, so let's fix that up real quick. As you can see, the request is saying, OK, I want to alter entity ID asset 23, and I want to do a set metadata. And as you notice, what I'm sending back here, I'm only sending back the values I want to change. And the structure here is exactly the same as the structure was when I was getting things from Final Cut Server. MD value is the element. It has a data type, it has a field name, and it has the actual value of the data.

So that's brought everything back and gone around in the whole loop, and that's the way you typically do things in this loop. You have some subscription, it's got a response, it's sending stuff out to whatever your external application is, and when that application wants to send things back, it's putting that stuff into a watch folder that's coming back in.

The watcher, again, like the other watcher, is really simple. The watcher is just simply pointing at a particular location within the file system, in this case, the review file system. And ordinarily, I would do a delete, but in this case, I wasn't doing delete because I wanted to be able to show you what the file looked like.

And that's pretty much it. Erk Vershen So you can see this is very, very powerful. What Eryk didn't mention is all of this Rails application, all the sample code, is now up on the WWDC site, and it's associated with this talk. So all of the Rails code as well as how to actually do it all. You can now grab and download and start to do some interesting things. So we've showed here-- Just a simple example of how you might use a Rails app for some clip review and approve.

But there's plenty of other very interesting possibilities. So the talk yesterday talked about how you could make an iPhone interface using Ruby on Rails. And if you didn't see that, then grab it on iTunes after the show. So you can actually start to very easily make iPhone assets, clips for the iPhone available through some very simple mechanisms.

Perhaps you want to integrate into a content management system. So you want some way to get your assets into that world. Or maybe job tracking with asset management. So you might have a web app or some other application that does job tracking and you want to leverage the power of Final Cut Server to do the asset management and workflow.

Or another very simple example, you could take the Rails code, extend it a bit more, and say you're at an art college and had an end-of-year show. And you wanted a simple way to have students submit work for that show. You could have a watch folder. They could drop their completed work into that watch folder.

The lecturers could review and approve using the Final Cut Server client. And when it was approved, it could automatically be generated into the correct web formats and sent to the web application. So some very exciting things here, and some really interesting ways that you can start to leverage.

Final Cut Server with other applications. And we have talked about Rails, but obviously this can work with any other type of web technologies. And it doesn't even need to be a web technology. This shows how you can then send clips, send metadata, exchange information with other systems. Just by using this sort of mechanism where you can have responses in Final Cut Server to trigger actions, be they make QuickTime files, be they run scripts, and then get back into Final Cut Server with XML.

So there's a few related sessions that if you haven't seen them, you can get-- are going to be available after the show. So there's the Deploying Final Cut Server, which a lot of you were at, as well as the 426, so the Creating Rails Applications. and the integrating with Podcast Producer.

So if you're unable to see those, I recommend trying to get them after the show. And we've got a lab this afternoon at 2 o'clock, so if you want to go into depth in any of these particular integration issues, then we can discuss those at 2 o'clock. And we'll have some more of the engineering team with me down there.

So in summary, what we saw is the mechanisms of integration. So we saw embedding metadata in files, Reading and writing of XML content and executing scripts or commands. And then we saw the ability to exchange metadata with external systems, to integrate with Podcast Producer, and to integrate it with web applications like Ruby on Rails.

So these are only some of the many possibilities. You can do much, much more with the type of interactions that I've shown you today. So if you want some more information, we've got Mark Malone, who is the evangelist for this area. There's also documentation available on the apple.com/finalcutserver, so you can find links to various resources and other...

[Transcript missing]

If you want to learn a bit more about deployment, I can highly recommend the Getting Started with Final Cut Server book, which came out about two weeks ago. This goes into some great depth in how to do some workflows and other deployments and how to leverage some of the subscriptions and responses to do some interesting things.

WEBVTT

00:00:20.400 --> 00:02:28.900
[Transcript missing]

00:02:29.600 --> 00:02:34.530
So the guts of the API then is really
this kind of layers and animations.

00:02:34.530 --> 00:02:38.080
And these are basically the
main Objective-C objects you're

00:02:38.110 --> 00:02:38.740
going to be dealing with.

00:02:38.850 --> 00:02:41.520
So that's what we're going to
start talking about in a minute.

00:02:41.520 --> 00:02:45.050
But just one final thought is that
another way of looking at CA is

00:02:45.050 --> 00:02:48.640
that it's kind of one of the few
OS X technologies that really lets

00:02:48.640 --> 00:02:51.840
you kind of easily combine all
the different kind of graphics

00:02:52.160 --> 00:02:55.760
frameworks that we have available,
whether that be Quartz 2D or

00:02:55.760 --> 00:02:59.140
Quartz Composer or Core Image,
OpenGL, QuickTime.

00:02:59.140 --> 00:03:02.870
You name it,
you probably have a way to let

00:03:02.870 --> 00:03:04.220
you display it through a CA layer.

00:03:05.260 --> 00:03:06.680
Okay, so what is a layer?

00:03:06.680 --> 00:03:10.990
So a layer is the thing that lets
you describe your graphical scene.

00:03:11.010 --> 00:03:14.880
As we want to be able to
have lots of these things,

00:03:14.880 --> 00:03:16.400
we try to make them fairly lightweight.

00:03:16.400 --> 00:03:20.550
It has a bunch of different properties,
so you can describe things like,

00:03:20.550 --> 00:03:23.680
you know, where is it on screen,
what does it contain,

00:03:23.680 --> 00:03:26.040
how long does it play for, how fast.

00:03:26.040 --> 00:03:28.730
You can arrange them in a hierarchy,
so you can have, you know,

00:03:28.730 --> 00:03:31.840
you typically have a root layer,
and then the root layer has sub-layers,

00:03:31.840 --> 00:03:34.770
and then the sub-layers have sub-layers,
and so on and so forth.

00:03:35.200 --> 00:03:40.990
And this content, it's basically just the
bitmap in the final analysis,

00:03:40.990 --> 00:03:43.690
but there's a lot of places
that bitmap can come from.

00:03:43.780 --> 00:03:46.640
So you can have Core Graphics
or Quartz 2D rendering,

00:03:46.640 --> 00:03:50.220
you can have Core Graphics images,
you can have OpenGL rendering,

00:03:50.220 --> 00:03:52.590
you can have Quartz
Composer compositions,

00:03:52.590 --> 00:03:53.960
QuickTime movies.

00:03:53.960 --> 00:03:57.280
The list is pretty wide-ranging.

00:03:57.280 --> 00:04:02.350
And so the kind of the application
programming model that we provide

00:04:02.350 --> 00:04:06.700
you is that you basically get to
arrange these little layer objects,

00:04:06.750 --> 00:04:08.830
you know, to describe exactly what
you want to see on screen,

00:04:08.830 --> 00:04:12.860
and then you kind of hand it off to us,
and then we will take over

00:04:12.860 --> 00:04:15.010
from that point and basically
make sure that it's rendered,

00:04:15.520 --> 00:04:18.180
you know,
as often or as seldom as necessary

00:04:18.180 --> 00:04:19.600
to give you the best output.

00:04:19.600 --> 00:04:22.050
You know, we care about the refresh
rates of the display,

00:04:22.050 --> 00:04:24.460
how the animations are running,
all this kind of stuff.

00:04:24.480 --> 00:04:27.990
And the idea is we also do that
in a background thread so that

00:04:28.070 --> 00:04:30.840
you really don't have to care,
and it never even

00:04:30.840 --> 00:04:32.550
blocks your application.

00:04:34.480 --> 00:04:38.680
Okay, so the second half of the API I'm
putting is the animations.

00:04:38.680 --> 00:04:43.120
And so as I was kind of describing,
layers are basically these

00:04:43.120 --> 00:04:44.010
little bags of properties.

00:04:44.020 --> 00:04:47.040
So obviously,
kind of the obvious way to do animations

00:04:47.040 --> 00:04:50.940
is that you have things that can
describe how properties change over time.

00:04:50.960 --> 00:04:52.610
So that could be something like,
you know,

00:04:52.620 --> 00:04:55.640
the layer has a position property which
describes where it is on the screen.

00:04:55.640 --> 00:05:00.040
And so you may want to say, you know,
starting at time T for the next second,

00:05:00.040 --> 00:05:01.780
I want this thing to
move from here to here.

00:05:02.520 --> 00:05:04.290
So that's the kind of thing
we let you kind of wrap up

00:05:04.290 --> 00:05:05.520
in these animation objects.

00:05:05.520 --> 00:05:11.180
The details here are that, you know,
there's lots, well, not lots,

00:05:11.180 --> 00:05:13.280
but there's a few different
types of animation class.

00:05:13.280 --> 00:05:17.250
And they all do this kind of same thing,
but they let you compute those kind of

00:05:17.470 --> 00:05:19.840
state changes in slightly different ways.

00:05:19.840 --> 00:05:22.700
So for example,
we have this in code of basic animation,

00:05:22.700 --> 00:05:27.180
which literally does just let
you have a formula to position,

00:05:27.180 --> 00:05:29.050
which is what you want
in kind of a lot of,

00:05:29.120 --> 00:05:30.880
you know, 80% of cases maybe.

00:05:32.540 --> 00:05:34.840
Then there's kind of a parallel
class called the keyframe animation,

00:05:34.840 --> 00:05:40.310
which lets you describe these
kind of state changes as a kind

00:05:40.310 --> 00:05:41.790
of a list of keyframe values.

00:05:41.840 --> 00:05:45.270
And then we will kind of interpolate
between the keyframes based on how,

00:05:45.270 --> 00:05:48.160
you know, based on how far you are
along in the timeline.

00:05:48.160 --> 00:05:52.820
And then finally, there's another type of
animation called a transition.

00:05:52.820 --> 00:05:55.620
And then transition is
not used that often,

00:05:55.620 --> 00:06:00.280
but it's used when you're unable
to animate the properties directly.

00:06:00.280 --> 00:06:02.410
For example, you may have a list.

00:06:02.470 --> 00:06:04.510
The filter's on the last, say,
and it contains maybe

00:06:04.560 --> 00:06:05.740
a Gaussian blur filter.

00:06:05.740 --> 00:06:09.860
And then you change that, and you say,
now I want to have a crystallized filter.

00:06:09.890 --> 00:06:12.020
And obviously,
there's no way we can just kind of

00:06:12.070 --> 00:06:15.070
animate property changes to kind of
map from one to the other because

00:06:15.070 --> 00:06:16.210
they're fundamentally different.

00:06:16.220 --> 00:06:18.520
But what we can do is
we can add a transition,

00:06:18.520 --> 00:06:22.630
and that basically takes the before and
after kind of image representations of

00:06:22.660 --> 00:06:26.740
what you see on screen and does some
kind of transition effect between them.

00:06:26.760 --> 00:06:29.110
So these are kind of the things
you would see in Keynote,

00:06:29.110 --> 00:06:31.520
like cube transitions and
crossfades and dissolves.

00:06:32.360 --> 00:06:34.360
And that kind of thing.

00:06:34.370 --> 00:06:38.280
Also, animations are not limited to
just changing a single property

00:06:38.280 --> 00:06:39.840
or having a single effect.

00:06:39.840 --> 00:06:41.940
Just like layers,
you can group them hierarchically,

00:06:41.940 --> 00:06:45.160
and that is typically
done for timing control.

00:06:45.160 --> 00:06:48.520
You know, you can create a group and
have a group of subanimations,

00:06:48.520 --> 00:06:52.110
and then you can kind of define the
timing curves on the group rather

00:06:52.110 --> 00:06:54.160
than each individual animation.

00:06:54.160 --> 00:06:58.740
And finally, again, just like rendering,
all of these animations run

00:06:58.830 --> 00:07:00.680
entirely in the background.

00:07:00.680 --> 00:07:02.280
So once you add an animation to a layer,
you can kind of create a subanimation.

00:07:02.280 --> 00:07:03.390
And then once you add
an animation to a layer,

00:07:03.390 --> 00:07:04.640
then you really don't need
to care much about it.

00:07:04.680 --> 00:07:08.010
You can get notifications or
delegate callbacks when the

00:07:08.360 --> 00:07:11.000
animation starts and stops,
and you can remove them

00:07:11.000 --> 00:07:12.390
and you can query them.

00:07:12.470 --> 00:07:15.220
But other than that, you don't have to do
anything every frame.

00:07:15.320 --> 00:07:18.130
Just like you heard in the
session earlier this morning,

00:07:18.170 --> 00:07:20.190
you know,
the whole idea is we want to free your

00:07:20.190 --> 00:07:23.670
application from having to care anything
about what happens at frame rate.

00:07:23.720 --> 00:07:27.510
Because we think we can do it faster.

00:07:28.170 --> 00:07:30.540
Okay, so just briefly,
this is the kind of overview

00:07:30.540 --> 00:07:31.750
of all these animation classes.

00:07:31.750 --> 00:07:34.200
And you don't really need
to absorb anything here,

00:07:34.370 --> 00:07:37.230
just to see that there are, you know,
this kind of class hierarchy

00:07:37.280 --> 00:07:39.550
with different types of animation
and different properties.

00:07:39.550 --> 00:07:42.400
And that's about it.

00:07:42.460 --> 00:07:46.220
So let's wrap up this section just
by giving you a little example of,

00:07:46.220 --> 00:07:48.740
you know, how do you code to this stuff.

00:07:48.800 --> 00:07:51.500
So our example here is two halves.

00:07:51.500 --> 00:07:55.330
The first half is going to create
a layer and basically attach it to

00:07:55.330 --> 00:07:57.410
a parent who we hope is on screen.

00:07:58.100 --> 00:07:59.650
So we're going to create a layer.

00:07:59.710 --> 00:08:02.320
We're going to set its frame,
which is its geometry.

00:08:02.320 --> 00:08:05.600
And in this case, we're going to say,
you know, you have this rectangle, which,

00:08:05.600 --> 00:08:08.880
because we're setting the frame,
that is in the parent's coordinate space.

00:08:08.880 --> 00:08:10.970
And then we're going to give it an image.

00:08:11.140 --> 00:08:14.080
This is just some CG image we
loaded off disk or whatever.

00:08:14.080 --> 00:08:18.410
And so the final statement there is we're
going to add this layer to its parent,

00:08:18.580 --> 00:08:20.740
to the parent's list of sub-layers.

00:08:20.760 --> 00:08:23.210
It will be appended at
the end of this model one.

00:08:24.480 --> 00:08:26.790
And so at this point,
assuming the parent is visible,

00:08:26.790 --> 00:08:28.270
then our layer is now on screen.

00:08:28.270 --> 00:08:31.170
So that really is what there is to it.

00:08:31.220 --> 00:08:33.800
Just to make it a little
more of an example,

00:08:33.800 --> 00:08:37.030
then we're going to say, well,
now we've added it,

00:08:37.030 --> 00:08:40.140
we really want it to fade
in over the first second.

00:08:40.140 --> 00:08:43.830
So the way we can do that is by
creating one of these animation objects,

00:08:43.830 --> 00:08:46.140
setting its keypath
property to be opacity,

00:08:46.420 --> 00:08:49.720
because we want to animate the
opacity property of the layer,

00:08:49.720 --> 00:08:53.370
and then giving it a formula
to value of zero to one.

00:08:53.440 --> 00:08:54.670
So that's going to take... So the
way we can do that is by creating

00:08:54.670 --> 00:08:55.010
one of these animation objects,
setting its keypath

00:08:55.020 --> 00:08:55.370
property to be opacity,
because we want to animate the

00:08:55.370 --> 00:08:58.660
opacity from zero to one over
the time period of the animation,

00:08:58.660 --> 00:09:00.380
which you can see the
next line is set to one,

00:09:00.380 --> 00:09:00.600
i.e.

00:09:00.600 --> 00:09:01.460
one second.

00:09:01.460 --> 00:09:06.000
And since the default start time
for animations is when you add it,

00:09:06.000 --> 00:09:08.210
then when we add that to the
layer in the next statement,

00:09:08.210 --> 00:09:10.790
what will happen is that
as the layer appears,

00:09:10.790 --> 00:09:14.010
because we just added it,
its opacity will ramp up from

00:09:14.070 --> 00:09:16.000
zero to one over a second.

00:09:16.210 --> 00:09:20.090
Once the animation is finished,
it will be deleted from the layer and

00:09:20.090 --> 00:09:22.490
everything will just go on as normal.

00:09:23.310 --> 00:09:30.880
Okay, so now we're going to talk more
about the details of how CA works.

00:09:30.880 --> 00:09:35.860
And the first thing I want to talk
about is this idea of having two trees.

00:09:35.860 --> 00:09:38.570
And so, you know,
we think about the layer

00:09:38.570 --> 00:09:40.070
tree a lot because it's,
you know,

00:09:40.070 --> 00:09:41.800
it's the object to see data structure.

00:09:41.800 --> 00:09:42.980
It's the thing you can modify.

00:09:44.600 --> 00:09:47.020
And so in this case here, we have,
you know, several layers and

00:09:47.020 --> 00:09:48.200
I arranged the hierarchy.

00:09:48.200 --> 00:09:50.000
And the content, you know,
can be different things.

00:09:50.080 --> 00:09:51.080
It really doesn't matter.

00:09:51.080 --> 00:09:53.250
But always behind the scenes,
we have this thing

00:09:53.250 --> 00:09:54.520
called the render tree.

00:09:54.520 --> 00:09:58.000
And the render tree is kind of
our lower-level representation

00:09:58.040 --> 00:09:59.860
of this same data structure.

00:09:59.860 --> 00:10:03.070
You know, every time you make a change in
the layer tree at some point,

00:10:03.100 --> 00:10:06.390
we're going to have to try and do a
corresponding change to kind of update

00:10:06.390 --> 00:10:08.990
the render tree to be the same thing,
effectively.

00:10:09.060 --> 00:10:12.120
And this is the thing
we actually render from.

00:10:12.120 --> 00:10:16.080
And the reason for that is that,
you know, as I keep saying,

00:10:16.080 --> 00:10:18.240
we want to be rendering on a
background thread at all times.

00:10:18.240 --> 00:10:21.800
And so we don't want you to be able to
lock us out of rendering ever because,

00:10:21.810 --> 00:10:23.340
you know,
that would be bad and we'd drop frames.

00:10:23.360 --> 00:10:26.100
So the render thread is really
this thing that keeps spinning,

00:10:26.100 --> 00:10:29.160
keeps looking at this render tree
and kind of pulling frames of it

00:10:29.160 --> 00:10:30.140
and putting them on the screen.

00:10:30.220 --> 00:10:33.420
So then the question then becomes,
I guess, is that, you know,

00:10:33.420 --> 00:10:36.220
we have a layer tree and a render tree.

00:10:36.220 --> 00:10:39.000
And how do we get state
changes from one to the other?

00:10:39.920 --> 00:10:41.400
Well,

00:10:41.780 --> 00:10:45.390
We had this idea of transactions,
and transactions obviously

00:10:45.430 --> 00:10:47.110
come from database theory.

00:10:47.120 --> 00:10:50.890
And ours is kind of a very
weak attempt at writing on

00:10:50.910 --> 00:10:55.410
their coattails or something,
because our transactions are really just

00:10:55.410 --> 00:10:59.360
a way to batch up state changes in such a
way that they get copied from one to the

00:10:59.360 --> 00:11:01.400
other in a single kind of atomic unit.

00:11:01.400 --> 00:11:04.520
So what this means for you
is that every time you're

00:11:04.750 --> 00:11:08.450
spinning around your event loop,
your run loop in Cocoa or whatever,

00:11:08.450 --> 00:11:11.300
then you're making changes to
these layers for every event.

00:11:11.800 --> 00:11:14.900
And so by default,
we will set things up so that

00:11:15.030 --> 00:11:18.490
every time around that event loop,
we will create a single transaction,

00:11:18.500 --> 00:11:21.650
kind of batch up all the changes,
and then when your event loop

00:11:21.890 --> 00:11:25.130
gets back to the run loop,
we can say, oh, we saw they've done kind

00:11:25.130 --> 00:11:28.000
of some unit of stuff,
and we will take that stuff and throw

00:11:28.000 --> 00:11:29.360
it over the wall to the render tree.

00:11:29.360 --> 00:11:32.070
So that's kind of what we
call an implicit transaction,

00:11:32.100 --> 00:11:36.180
but that's not really necessary
to know that right now.

00:11:36.220 --> 00:11:41.410
But the thing to take away is that this
doesn't have an automatically... Sorry,

00:11:41.410 --> 00:11:42.480
I just said it did have an automatically.

00:11:42.590 --> 00:11:45.810
So the thing to take away
is that there are two trees,

00:11:45.820 --> 00:11:47.200
and every now and then
you may have to care,

00:11:47.200 --> 00:11:49.460
although hopefully not very often,
that you have to push things

00:11:49.460 --> 00:11:50.600
from one to the other.

00:11:50.600 --> 00:11:52.640
And like I said,
it does have an automatically

00:11:52.640 --> 00:11:53.570
most of the time.

00:11:53.580 --> 00:11:56.810
So next I want to talk about geometry.

00:11:56.850 --> 00:11:59.580
Obviously,
geometry is very important for layers,

00:11:59.580 --> 00:12:02.180
because geometry is how
things are arranged on screen,

00:12:02.180 --> 00:12:04.560
and without this, we would see nothing.

00:12:04.560 --> 00:12:09.090
So every layer has a bounds rectangle,
and the bounds rectangle,

00:12:09.090 --> 00:12:10.640
which is the bounds
property of the layer,

00:12:10.700 --> 00:12:13.800
defines kind of the layer's
internal coordinate space.

00:12:13.800 --> 00:12:17.100
What that means is that any
drawing you do within the layer,

00:12:17.100 --> 00:12:20.880
or any positioning of sublayers,
is within that kind of local coordinate

00:12:20.880 --> 00:12:22.480
space defined by the bounds rectangle.

00:12:22.480 --> 00:12:26.840
And you can see in the picture here,
we have a dotted line, or a dotted box,

00:12:26.840 --> 00:12:28.540
which is trying to
represent our superlayer,

00:12:28.560 --> 00:12:32.990
and we have a smaller graphic,
which represents the

00:12:32.990 --> 00:12:34.090
layer we're talking about.

00:12:34.220 --> 00:12:36.470
And you can see we've
highlighted its width and height,

00:12:36.540 --> 00:12:38.800
and those are the two subparts
of the bounds rectangle.

00:12:40.490 --> 00:12:44.180
So every layer also has a position,
and the position is not defined in

00:12:44.180 --> 00:12:45.600
the layer's own coordinate space.

00:12:45.600 --> 00:12:47.260
It's defined in the
parent's coordinate space,

00:12:47.260 --> 00:12:48.560
the super layer's coordinate space.

00:12:48.560 --> 00:12:51.850
And what that means is that when you,
because keep in mind that all the

00:12:51.920 --> 00:12:55.630
time we're trying to take this little
layer and map it into its super layer.

00:12:55.640 --> 00:12:58.180
I mean, that's basically what
we're talking about here.

00:12:58.180 --> 00:13:01.190
So the layer has a position,
and it also has an anchor point,

00:13:01.270 --> 00:13:03.890
which is the frame of
reference for the position.

00:13:04.560 --> 00:13:06.350
And in this case,
we've drawn a crosshair in the

00:13:06.350 --> 00:13:09.230
middle of this little graphic,
which is trying to represent

00:13:09.300 --> 00:13:10.930
that the anchor point is
in the center of the layer.

00:13:10.960 --> 00:13:13.360
And that basically means that
all transform and positioning

00:13:13.370 --> 00:13:16.030
is happening relative to that
anchor point center in this case.

00:13:16.040 --> 00:13:20.800
So you can see that when we take this
thing and map it into its super layer,

00:13:20.800 --> 00:13:23.620
the first thing we do is align
the anchor point in the layer eye,

00:13:23.620 --> 00:13:27.500
the center,
with the position in its super layer.

00:13:27.720 --> 00:13:31.140
Next, there's also a transform
property on the layer.

00:13:31.140 --> 00:13:33.670
What the transform does is
once it's been positioned,

00:13:33.670 --> 00:13:35.640
it gives you a chance to kind
of scale and rotate and all

00:13:35.640 --> 00:13:36.880
those kind of fun 3D things.

00:13:36.880 --> 00:13:41.400
So you can see that the transform gets
applied once it's been positioned,

00:13:41.400 --> 00:13:43.020
and in this case,
we're just going to rotate

00:13:43.070 --> 00:13:44.020
and scale a little bit.

00:13:44.060 --> 00:13:48.260
And that's basically the 90%
cases of all the geometry

00:13:48.260 --> 00:13:50.540
stuff you want to care about.

00:13:51.060 --> 00:13:53.190
Obviously,
we've only talked about 2D right now,

00:13:53.190 --> 00:13:54.880
but 3D works in just the same way.

00:13:54.880 --> 00:13:57.510
It's just that the matrices have
an extra column or something.

00:13:59.280 --> 00:14:06.700
So now we talked about how this layer
graphic gets mapped from one from itself

00:14:06.700 --> 00:14:09.160
its own coordinate space into its parent.

00:14:09.160 --> 00:14:13.360
So let's talk a little bit more
about you know what is in that layer.

00:14:13.360 --> 00:14:16.810
So there are a number of sub components
which come together to form the

00:14:16.930 --> 00:14:19.620
layer image as I like to call it
and so these are things like the

00:14:19.620 --> 00:14:22.110
background color property of the layer,
the contents,

00:14:22.110 --> 00:14:24.080
the sub layers and the border color.

00:14:24.080 --> 00:14:27.560
In this graphic they're actually
flipped upside down for some reason

00:14:27.560 --> 00:14:31.200
but basically they're sover together,
sover compositing to give you

00:14:31.280 --> 00:14:34.140
one image representing all
of the things in that layer.

00:14:34.260 --> 00:14:36.450
So you know if you have any
drawn content and a border then

00:14:36.530 --> 00:14:42.120
obviously the border will be
layered on top of the drawn content.

00:14:42.120 --> 00:14:44.920
So at the end of that we have an image
but what do we do with that image?

00:14:44.920 --> 00:14:48.230
Well there are a number of other
properties which can then modify

00:14:48.230 --> 00:14:49.800
this thing we're creating.

00:14:49.810 --> 00:14:53.230
So for example we can apply a list of
core image filters to do things like you

00:14:53.290 --> 00:14:58.400
know blurring the contents of the layer
or changing its color for some reason.

00:14:58.400 --> 00:15:01.260
We can also apply a 2D drop shadow
to give you know the standard kind

00:15:01.260 --> 00:15:04.840
of drop shadow effects and then
finally we can apply some kind of

00:15:04.850 --> 00:15:08.820
opacity fading and this basically
are all the effects that run in the

00:15:08.820 --> 00:15:11.100
coordinate space of the layer itself.

00:15:11.100 --> 00:15:13.180
So they're kind of the little the
things that fit in within that

00:15:13.180 --> 00:15:14.630
little box of the previous diagram.

00:15:17.350 --> 00:15:20.300
So the next part of this trip
to the compositing model,

00:15:20.300 --> 00:15:23.070
I guess, is the compositing model itself.

00:15:23.070 --> 00:15:27.100
And typically what you see on
screen is the 90% case again.

00:15:27.100 --> 00:15:29.230
We have the layer image,
which is that little thing

00:15:29.330 --> 00:15:30.530
we were just talking about.

00:15:30.530 --> 00:15:34.370
We have the superlayer transform,
which is some matrix we're constructing

00:15:34.430 --> 00:15:37.820
to represent all of that geometry
mapping we were talking about.

00:15:37.820 --> 00:15:39.600
And then we have the backdrop.

00:15:39.600 --> 00:15:43.130
The backdrop is everything that
has been rendered up to this

00:15:43.130 --> 00:15:45.170
point from its sibling layers.

00:15:45.240 --> 00:15:48.530
So if you have a parent
layer with five sublayers,

00:15:48.780 --> 00:15:50.940
then we're going to render the first one,
then the next, and the next.

00:15:50.940 --> 00:15:53.580
And then for each one,
the things that have been rendered

00:15:53.650 --> 00:15:55.090
before it constitute its backdrop.

00:15:55.100 --> 00:15:58.970
And so you can see that typically
we just do source over compositing,

00:15:58.990 --> 00:16:02.260
because again,
that's what you want most of the time.

00:16:02.260 --> 00:16:07.030
But there are a number of ways in
which we can modify this diagram.

00:16:07.040 --> 00:16:09.960
So firstly,
you can add a compositing filter,

00:16:09.960 --> 00:16:14.120
which is just a regular core image
filter with two input images.

00:16:14.790 --> 00:16:16.910
And the idea of this is that
you can replace that source over

00:16:16.940 --> 00:16:20.940
compositing by something more complex.

00:16:20.940 --> 00:16:23.340
So you could think,
I think there are core image

00:16:23.340 --> 00:16:27.090
filters which represent all of the,
for example, the PDF blend modes and

00:16:27.090 --> 00:16:28.760
the Portaduff blend modes.

00:16:28.760 --> 00:16:30.640
And you could even invent your own here.

00:16:30.640 --> 00:16:32.490
So that's the idea.

00:16:33.000 --> 00:16:38.440
So the next thing is we can add
a list of background filters.

00:16:38.440 --> 00:16:40.760
And the background filters run
on the backdrop of the layer.

00:16:40.760 --> 00:16:43.000
So it's kind of under siblings.

00:16:43.000 --> 00:16:46.260
And this, again, is a list of filters.

00:16:46.380 --> 00:16:50.270
And they're applied 1 through n.

00:16:50.280 --> 00:16:53.790
And then the result of that is kind
of fed into the compositing filter.

00:16:54.510 --> 00:16:57.860
So far, we've only talked about
two of these image inputs,

00:16:57.860 --> 00:16:58.880
but there's actually a third one.

00:16:58.880 --> 00:17:01.020
You also have a mask.

00:17:01.030 --> 00:17:03.910
Every layer has a mask,
and it comes from two

00:17:03.950 --> 00:17:05.170
separate components.

00:17:05.240 --> 00:17:10.270
The layer has a mask layer, potentially,
and it also has this property

00:17:10.270 --> 00:17:12.290
called masks-to-bounds.

00:17:12.380 --> 00:17:16.190
And if masks-to-bounds is set,
then it says there's an implicit mask,

00:17:16.190 --> 00:17:18.100
which is the shape of the layer.

00:17:18.720 --> 00:17:20.800
And if the mask layer is set,
then it says, you know,

00:17:20.860 --> 00:17:23.300
take the alpha channel of
this layer and treat that as

00:17:23.400 --> 00:17:25.020
the mask of the layer itself.

00:17:25.100 --> 00:17:27.030
And so both of those are set.

00:17:27.120 --> 00:17:30.050
We'll just multiply them together to get,
you know, the cumulative mask.

00:17:30.080 --> 00:17:32.110
And so what do we do with this?

00:17:32.240 --> 00:17:34.650
First of all,

00:17:34.600 --> 00:18:56.400
[Transcript missing]

00:18:57.160 --> 00:19:03.340
Okay, so moving away from geometry,
now we're going to look at timing.

00:19:03.340 --> 00:19:06.850
Timing is a very important
part of Core Animation because,

00:19:06.920 --> 00:19:08.580
you know, we're animating,
so we have to have

00:19:08.580 --> 00:19:09.600
some kind of time base.

00:19:09.600 --> 00:19:12.880
So to that end,
every object in our object hierarchy,

00:19:12.910 --> 00:19:16.150
be that layers and animations,
they all have local,

00:19:16.150 --> 00:19:19.030
what we call timing spaces,
just like they have

00:19:19.030 --> 00:19:20.940
local coordinate spaces.

00:19:22.100 --> 00:19:26.600
And the way we deal with that is
when we start to render a frame,

00:19:26.600 --> 00:19:30.200
you know, we have a global time,
which is wall clock time typically.

00:19:30.200 --> 00:19:35.490
And so just like we map
geometry across the layer tree,

00:19:35.490 --> 00:19:37.600
we also map timing or time.

00:19:37.620 --> 00:19:40.340
So we'll start at the root
and then for every layer,

00:19:40.340 --> 00:19:43.580
we'll map the time from its parent into
itself and then into its sub layers.

00:19:43.600 --> 00:19:48.580
And so this lets you do very
interesting things because the

00:19:48.610 --> 00:19:51.300
timing model is pretty rich.

00:19:51.300 --> 00:19:53.490
and his list of properties
on the bottom bullet,

00:19:53.490 --> 00:19:54.610
I guess.

00:19:54.620 --> 00:19:57.060
So, you know,
things you can set are things like,

00:19:57.120 --> 00:19:59.470
you can set the delay,
which is the begin time.

00:19:59.480 --> 00:20:02.040
You can set the duration,
which is the length of time

00:20:02.040 --> 00:20:03.610
the thing is gonna run for.

00:20:03.620 --> 00:20:05.680
And then you can do
some other things like,

00:20:05.680 --> 00:20:07.250
you know,
change the rate at which it progresses,

00:20:07.280 --> 00:20:11.360
change the number of times it repeats,
and some other things.

00:20:11.400 --> 00:20:14.840
This scary looking block of code is
basically the entire timing model.

00:20:15.030 --> 00:20:17.260
So it's really just
here to show you that,

00:20:17.280 --> 00:20:21.820
although this stuff may seem complex,
it's really kind of easy to reason

00:20:21.880 --> 00:20:25.620
about because typically you only need
to look at some little parts of it.

00:20:25.860 --> 00:20:29.540
So for example, if you wanted to pause
a movie or something,

00:20:29.540 --> 00:20:32.320
you know, some open jail rendering
or a course composer,

00:20:32.340 --> 00:20:34.320
then by looking at this
little kind of math,

00:20:34.320 --> 00:20:37.740
you can see that what you do is
set speed to zero on the layer and

00:20:37.740 --> 00:20:40.370
then change the time offset to kind
of push you along the timeline.

00:20:40.560 --> 00:20:44.720
Obviously, when you set speed to zero,
because it's multiplying the parent time,

00:20:44.720 --> 00:20:47.550
it's gonna clamp you to the start time.

00:20:49.200 --> 00:20:52.810
The rest of that code is basically
just dealing with repeats and

00:20:52.810 --> 00:20:54.910
playing backwards and forwards.

00:20:54.910 --> 00:20:57.500
So now we can look at
an example of all this.

00:20:57.500 --> 00:21:01.210
So here we have some kind of object,
you know, the round dot.

00:21:01.210 --> 00:21:02.820
And we have its timeline.

00:21:02.820 --> 00:21:05.240
And the timeline is going left to right.

00:21:05.240 --> 00:21:08.690
And you can see in this block
there's kind of a diagonal line

00:21:08.700 --> 00:21:11.170
showing progression of local time.

00:21:12.460 --> 00:21:13.780
So that's all one that we have.

00:21:13.830 --> 00:21:15.980
An object that's going
to run for 20 seconds.

00:21:16.090 --> 00:21:17.620
And so let's add a child.

00:21:18.250 --> 00:21:22.290
The child's timing properties are a
little different in that it's set to

00:21:22.300 --> 00:21:25.890
begin two seconds after its parent began.

00:21:26.510 --> 00:21:28.980
is the creator of Core Animation.

00:21:28.980 --> 00:21:32.180
He is the creator of the
first ever video game,

00:21:32.180 --> 00:21:32.510
and

00:21:32.720 --> 00:21:38.070
- So adding a third sub-layer,

00:21:39.100 --> 00:22:55.400
[Transcript missing]

00:22:56.650 --> 00:23:02.220
Okay, so again, thinking about time,
I wanted to talk about how

00:23:02.220 --> 00:23:05.790
animations are applied to layers.

00:23:06.150 --> 00:23:10.800
Now,
we have this idea of a sandwich model,

00:23:10.800 --> 00:23:10.800
which

00:23:10.880 --> 00:23:11.910
basically comes from Smile.

00:23:11.990 --> 00:23:16.330
Smile is a web, W3C animation standard,
and they kind of first,

00:23:16.410 --> 00:23:17.820
at least what I first saw it.

00:23:17.860 --> 00:23:20.920
And the idea is that you have model
layers and presentation layers.

00:23:20.950 --> 00:23:24.940
Now, the model layer is the thing you
modify in your data structures.

00:23:24.990 --> 00:23:27.740
That's why it's called the model,
it's your data model.

00:23:27.950 --> 00:23:29.390
At least for the graphics.

00:23:29.480 --> 00:23:32.220
And the presentation layer is
kind of a version of that with all

00:23:32.250 --> 00:23:35.260
the current animations applied,
which may modify its properties

00:23:35.260 --> 00:23:38.100
so that things that are animating
from A to B have intermediate

00:23:38.310 --> 00:23:40.760
values to that position,
for example.

00:23:40.760 --> 00:23:44.400
And then in between those two kind
of bottom to top of the sandwich,

00:23:44.400 --> 00:23:46.990
we have all the animations that
have been attached to this object.

00:23:47.180 --> 00:23:48.940
So in this case,
you can see we have four and

00:23:48.940 --> 00:23:51.000
they have various timelines.

00:23:51.010 --> 00:23:52.560
Again, time is left to right.

00:23:52.560 --> 00:23:58.080
And so then it's pretty obvious, I guess,
how we're gonna evaluate this,

00:23:58.100 --> 00:24:02.030
but we're gonna take a slice for a
particular time and then sample each of

00:24:02.030 --> 00:24:04.630
these animation objects for that time.

00:24:04.670 --> 00:24:06.910
And when we sample them,
that basically means doing the

00:24:06.910 --> 00:24:10.280
interpolation and producing that,
and then the value of

00:24:10.280 --> 00:24:13.340
that interpolated value,
which they wanna apply into the layer.

00:24:13.650 --> 00:24:16.560
And obviously,
so we take the model layer,

00:24:16.570 --> 00:24:19.350
and then after applying
all the animation values,

00:24:19.380 --> 00:24:20.880
we end up with this presentation layer.

00:24:20.910 --> 00:24:23.050
And that's the thing we're gonna,
you know,

00:24:23.100 --> 00:24:44.500
[Transcript missing]

00:24:50.550 --> 00:25:05.530
This section is trying to get away
from this kind of high-level view

00:25:05.530 --> 00:25:05.530
we've just been talking about and
actually go straight to the bottom

00:25:05.530 --> 00:25:05.530
and talk about lots of little details
that will be important to you.

00:25:06.100 --> 00:25:07.740
We want to talk about subclassing.

00:25:07.920 --> 00:25:09.430
So why would you subclass the layer?

00:25:09.560 --> 00:25:11.500
Typically,
you want to subclass because you

00:25:11.500 --> 00:25:13.180
want to add your own behavior.

00:25:13.350 --> 00:25:17.470
So two common examples are you may
want to add your own drawing code or

00:25:17.470 --> 00:25:19.150
you may want to add your own layout.

00:25:19.250 --> 00:25:22.310
And by layout,
I mean potentially adding sublayers

00:25:22.320 --> 00:25:26.090
and positioning them somewhere
within your local coordinate space.

00:25:26.390 --> 00:25:29.450
So obviously the way we do this
is subclass in the normal way,

00:25:29.450 --> 00:25:32.210
in the normal Objective-C way,
and then add properties.

00:25:32.220 --> 00:25:34.700
Because if you want to have behavior,
you typically want to

00:25:34.710 --> 00:25:35.620
customize that somehow.

00:25:35.620 --> 00:25:37.850
So in this case,
we're going to add a single floating

00:25:37.880 --> 00:25:39.550
point property in that interface.

00:25:39.560 --> 00:25:42.150
And then in the implementation,
we're going to do something slightly

00:25:42.150 --> 00:25:44.860
different in that we're not going
to try and implement it ourselves.

00:25:44.860 --> 00:25:46.920
We're going to allow
Core Animation to do that for us.

00:25:47.590 --> 00:25:52.010
And so by declaring the property dynamic,
it tells CA and Objective-C that you

00:25:52.240 --> 00:25:54.800
don't have to do this at compile time,
but at run time,

00:25:54.800 --> 00:25:58.130
we will synthesize all the methods
or everything that has to be done to

00:25:58.130 --> 00:26:00.120
make this property actually exist.

00:26:01.870 --> 00:26:04.320
So the next thing you may
want to do is look at this

00:26:04.320 --> 00:26:05.630
default value for key method.

00:26:05.660 --> 00:26:09.550
Default value for key is a
way of providing the initial

00:26:09.550 --> 00:26:10.510
value of your property.

00:26:10.520 --> 00:26:13.620
If you don't do this,
you'll just get some kind of

00:26:13.620 --> 00:26:17.520
zero-like value or identity-like
in terms of matrices.

00:26:17.520 --> 00:26:21.200
But if you want to have it default
to something other than a zero,

00:26:21.200 --> 00:26:25.760
this is the way to do it because it's
much better than actually setting the

00:26:26.030 --> 00:26:29.900
value to be its default value because
there is no storage associated with this.

00:26:30.500 --> 00:26:31.940
So anyway,
so you would override the method,

00:26:31.940 --> 00:26:34.140
check the key that you're
giving isn't my property,

00:26:34.140 --> 00:26:35.970
and if it is, return some value.

00:26:35.980 --> 00:26:39.440
And then any objects you
instantiate from this class,

00:26:39.440 --> 00:26:44.180
if you actually looked at the
property values after being created,

00:26:44.180 --> 00:26:46.080
they would have whatever default you set.

00:26:47.980 --> 00:26:51.040
The next thing you can look at
in subclassing is the Will and

00:26:51.080 --> 00:26:52.900
Did Change KBO methods.

00:26:53.020 --> 00:26:56.140
These are a really good way
to get notifications when your

00:26:56.140 --> 00:26:57.900
properties have been changed.

00:26:57.910 --> 00:27:01.390
Continuing with this line width example,
if our line width changes and

00:27:01.480 --> 00:27:04.900
presumably we want to use this to draw
a bunch of lines using Core Graphics,

00:27:05.010 --> 00:27:09.300
then we really need to tell the layer,
"You need to redraw yourself because

00:27:09.370 --> 00:27:13.560
you're out of date now." Again,
CoolSuper.

00:27:14.600 --> 00:27:17.190
And finally, you know,
get to the meat of this in that the

00:27:17.220 --> 00:27:20.660
reason we've done everything so far is
so we can override the draw method and

00:27:20.670 --> 00:27:22.760
actually provide our custom drawing code.

00:27:22.760 --> 00:27:25.010
And so to do that,
you will override this drawing

00:27:25.010 --> 00:27:26.390
context method typically.

00:27:26.390 --> 00:27:29.420
And so again, with this line width thing,
we're going to take the

00:27:29.420 --> 00:27:32.550
current value of the property,
set it as the CG context line width,

00:27:32.630 --> 00:27:35.220
and then presumably go
off and draw some lines.

00:27:35.290 --> 00:27:37.750
One thing to bear in mind is
that if you don't use the dynamic

00:27:37.810 --> 00:27:40.500
properties and you do implement
them statically using instance

00:27:40.500 --> 00:27:43.860
variables or something like that,
you're going to have to do a lot of work.

00:27:45.060 --> 00:27:49.180
And you should look at the documentation
on the net width layer method because you

00:27:49.180 --> 00:27:55.070
have to implement that if you want to be
able to use kind of presentation layers

00:27:55.070 --> 00:27:58.470
and animations in the best possible way.

00:28:05.860 --> 00:28:07.720
So next, let's talk a little bit
more about animation.

00:28:07.740 --> 00:28:10.160
So mostly so far,
we've been talking about

00:28:10.160 --> 00:28:11.800
animation in terms of objects.

00:28:11.940 --> 00:28:15.090
Now, objects you create and
attach to your layers,

00:28:15.090 --> 00:28:17.320
and then they will go
off and do something.

00:28:17.370 --> 00:28:19.960
And that's great,
and that's an underlying

00:28:19.960 --> 00:28:22.620
fundamental model,
but a lot of the time,

00:28:22.620 --> 00:28:25.650
you just want to set a
property and make it animate.

00:28:25.960 --> 00:28:29.360
So by default,
we have a way of letting you do that,

00:28:29.360 --> 00:28:32.310
and that's called implicit animation.

00:28:32.400 --> 00:28:35.320
And what that really means is that
when you set properties of layers,

00:28:35.340 --> 00:28:37.860
by default,
the engine will go away and create one

00:28:37.860 --> 00:28:42.740
of these animation objects for you,
and then attach it to the layer.

00:28:42.750 --> 00:28:44.840
And so typically,
we use basic animations here,

00:28:44.840 --> 00:28:47.910
which are these from-to animating things,
because that's kind

00:28:47.910 --> 00:28:49.250
of what we want to do.

00:28:49.330 --> 00:28:52.550
And the from value is always
the current screen value,

00:28:52.570 --> 00:28:55.640
and the to value is obviously
the new layer value.

00:28:55.820 --> 00:28:58.470
And it's worth emphasizing
the screen value thing.

00:28:58.690 --> 00:29:02.300
What this really means is that we're
going to take the value of the property,

00:29:02.370 --> 00:29:05.300
and then we're going to animate
the property at the previous frame,

00:29:05.300 --> 00:29:06.890
previous transaction,
and animate from that.

00:29:07.090 --> 00:29:10.270
If you've already modified it,
so say you were to say letter

00:29:10.270 --> 00:29:13.470
position equals 100 to 100,
and then the next line,

00:29:13.620 --> 00:29:16.770
letter position equals 200 to 200,
you won't get an animation

00:29:16.780 --> 00:29:19.080
from 100 to 100 to 200 to 200.

00:29:19.240 --> 00:29:22.740
You'll get an animation from
wherever it used to be to 200 to 200.

00:29:22.930 --> 00:29:24.840
Because typically,
we feel that's really what you want.

00:29:24.840 --> 00:29:27.880
I mean, you don't want things to jump and
then animate from where they are now.

00:29:27.880 --> 00:29:31.170
You want them to animate from where
they were to where they're going to be.

00:29:32.120 --> 00:29:34.940
So finally,
one more point here is that we're

00:29:34.970 --> 00:29:38.740
talking about numeric animations so far,
but a lot of the properties,

00:29:38.740 --> 00:29:40.640
as I mentioned earlier,
don't support numeric animation,

00:29:40.640 --> 00:29:42.610
things like filter
lists and what have you.

00:29:42.640 --> 00:29:44.630
And in these cases,
the default will be to

00:29:44.720 --> 00:29:47.490
create a transition here,
which will just cross-rate from

00:29:47.490 --> 00:29:49.320
one state of the layer to the next.

00:29:51.290 --> 00:29:53.520
And that's all great,
but every now and then,

00:29:53.520 --> 00:29:55.480
the implicit animations
become kind of annoying.

00:29:55.480 --> 00:29:58.360
You know, every now and then,
you don't want every property to animate,

00:29:58.410 --> 00:30:00.090
or you want it to animate
in a different way.

00:30:00.100 --> 00:30:05.580
And so when that happens,
the best thing is to turn them off

00:30:05.670 --> 00:30:07.840
and then add your own animations
or don't add anything at all.

00:30:07.840 --> 00:30:11.600
And there's a number of ways
in which you can add things.

00:30:11.600 --> 00:30:14.840
Sorry, there's a number of ways in which
you can replace the existing ones.

00:30:14.840 --> 00:30:17.740
The simplest is to basically just
set this transaction property to,

00:30:17.780 --> 00:30:20.400
say, disable actions,
actions are kind of animations.

00:30:21.200 --> 00:30:23.920
But the other way,
if you want a more persistent thing,

00:30:23.920 --> 00:30:26.740
is you can actually subclass
the layer and implement some of

00:30:26.750 --> 00:30:29.280
these action for key methods,
which actually give you a

00:30:29.300 --> 00:30:33.360
chance to return any animation
object for any property change.

00:30:35.600 --> 00:30:39.340
Okay,
so following on from the animation theme,

00:30:39.340 --> 00:30:42.590
as I mentioned earlier,
one of the things you often want

00:30:42.640 --> 00:30:45.120
to do is look at the current
state of the layer with its

00:30:45.120 --> 00:30:46.510
animations already applied to it.

00:30:46.520 --> 00:30:50.890
You know, if you want to hit test,
then you need to know exactly

00:30:50.900 --> 00:30:53.590
where that thing is now,
not where it was before

00:30:53.690 --> 00:30:54.700
the animation started.

00:30:54.700 --> 00:30:58.760
So what the presentation layer does,
the presentation tree,

00:30:58.800 --> 00:31:02.300
is it gives you a way to
get access to these objects.

00:31:03.180 --> 00:31:05.310
So typically what you will do
is you will get a layer and say,

00:31:05.310 --> 00:31:06.660
I want to know its current state.

00:31:06.700 --> 00:31:09.300
So you will then call its
presentation layer method.

00:31:09.300 --> 00:31:12.990
And what that does is it gives
you a copy of the layer back.

00:31:13.060 --> 00:31:16.740
And the copy has already had
all the animations applied

00:31:16.760 --> 00:31:19.560
to it for the current frame,
the current thing that's

00:31:19.560 --> 00:31:20.420
probably on the screen.

00:31:20.420 --> 00:31:22.170
So then you can go in
and look at it and say,

00:31:22.170 --> 00:31:24.370
you know,
if I know I have an opacity animation,

00:31:24.400 --> 00:31:26.460
then I want to look at the
opacity property to see,

00:31:26.550 --> 00:31:28.910
you know,
what is the current value on the screen.

00:31:30.760 --> 00:31:33.260
One other interesting point
about these presentation layers

00:31:33.260 --> 00:31:35.150
is they actually form a tree,
which is why we call it

00:31:35.150 --> 00:31:35.980
the presentation tree.

00:31:35.980 --> 00:31:39.870
And what that means is if you get the
presentation layer and then ask it

00:31:39.870 --> 00:31:44.160
for its sublayers or its superlayer,
then those things you get back will also

00:31:44.160 --> 00:31:46.370
have their animations applied to them.

00:31:46.450 --> 00:31:49.940
And that makes it pretty easy to
do certain types of operations on

00:31:49.940 --> 00:31:53.930
the regular layer tree and certain
types on the animating layer tree,

00:31:53.950 --> 00:31:55.460
the screen layer tree.

00:31:55.460 --> 00:31:58.710
So the two examples we have here,
which are the most common

00:31:58.750 --> 00:32:01.780
uses for this thing,
are that you can use it to produce

00:32:01.780 --> 00:32:03.160
the form values for animations.

00:32:03.160 --> 00:32:05.980
And this is obviously what
the implicit animation does.

00:32:05.980 --> 00:32:08.380
So in this case,
we say we create an animation,

00:32:08.380 --> 00:32:10.910
we set its keypad,
and then we'll set its form value

00:32:10.910 --> 00:32:14.470
to be the current presentation value
of the property we're animating.

00:32:14.480 --> 00:32:17.640
And then obviously add it to the layer.

00:32:17.640 --> 00:32:20.040
And that's exactly what the
implicit animation is doing.

00:32:20.040 --> 00:32:23.100
That's why I was stressing that
they animate from the current

00:32:23.100 --> 00:32:26.220
screen value to the new value,
because they use the presentation tree.

00:32:27.790 --> 00:32:31.000
So secondly, hit testing is the other
big use case for this.

00:32:31.000 --> 00:32:33.710
So when hit testing,
you would just use the

00:32:33.970 --> 00:32:36.550
normal hit test method,
but actually hit test on the

00:32:36.580 --> 00:32:38.270
result of the presentation layer.

00:32:38.280 --> 00:32:42.260
And because, as I said,
this gets you the animating sub-layers,

00:32:42.260 --> 00:32:45.650
then you will actually basically
hit test across the entire tree in

00:32:45.650 --> 00:32:47.260
its kind of current screen state.

00:32:47.300 --> 00:32:51.270
And that will give you back something,
and that will still be a

00:32:51.270 --> 00:32:53.510
presentation layer that you get back.

00:32:53.580 --> 00:32:56.450
So that's why at the bottom we have
this call to the model layer method.

00:32:57.010 --> 00:33:00.010
And what that does is it takes
the presentation layer we have

00:33:00.020 --> 00:33:03.690
and gives you back the original
underlying model object.

00:33:03.700 --> 00:33:06.330
So obviously if you're hit testing,
you want to find exactly

00:33:06.330 --> 00:33:07.510
where you are or what you hit.

00:33:07.540 --> 00:33:11.420
But you typically want to know, you know,
what is that in the layers I created,

00:33:11.420 --> 00:33:13.480
not these ones we've just
been copied from somewhere.

00:33:14.940 --> 00:33:18.740
and again the presentation tree is
really why you want to implement that

00:33:18.770 --> 00:33:20.340
initWithLayer method I mentioned.

00:33:20.350 --> 00:33:23.280
If you don't do that and you
have local state in your layers,

00:33:23.280 --> 00:33:25.710
then things may not work quite right.

00:33:26.900 --> 00:33:30.560
- Okay, so now we're gonna switch gears
and move away from animations

00:33:30.560 --> 00:33:32.200
and talk about Tiled Layers.

00:33:32.200 --> 00:33:36.700
So, you know,
we have this base class here layer,

00:33:36.720 --> 00:33:39.560
and it can display, you know,
most types of, well,

00:33:39.560 --> 00:33:42.320
pretty much any CG image.

00:33:42.690 --> 00:33:45.060
There are problems in
terms of graphics cards.

00:33:45.060 --> 00:33:48.790
Graphics cards can only really
display what they can texture from.

00:33:48.790 --> 00:33:52.750
They typically put limits on the
size of the images you can display,

00:33:52.870 --> 00:33:56.280
which is normally somewhat
bigger than your screen,

00:33:56.280 --> 00:33:59.340
but not as big as the
largest camera picture today,

00:33:59.380 --> 00:34:00.300
typically.

00:34:00.300 --> 00:34:03.330
Other problems we have with
the base class layer are that

00:34:03.330 --> 00:34:06.890
you don't have the ability to
provide multiple levels of detail,

00:34:06.930 --> 00:34:11.120
or you don't have the ability to
provide the image data in little chunks.

00:34:11.120 --> 00:34:11.810
It's all or nothing.

00:34:12.670 --> 00:34:16.680
So what the Tiled Light does is
it gives you a way to define this

00:34:16.680 --> 00:34:18.950
kind of tiled image pyramid thing.

00:34:19.320 --> 00:34:21.780
and that means that we can get
the image data in lots of little

00:34:21.780 --> 00:34:25.000
chunks and we also get them,
you know, not all ahead of time but we

00:34:25.000 --> 00:34:26.910
get those little chunks from
you when we know we need them.

00:34:26.950 --> 00:34:31.090
So you can imagine you could create a
million by a million pixel image through

00:34:31.090 --> 00:34:35.270
one of these tile layers and then,
you know, scroll around the screen

00:34:35.270 --> 00:34:38.330
and we will find out,
you know, exactly which tiles we need and

00:34:38.640 --> 00:34:40.720
then ask you for them at that time.

00:34:40.920 --> 00:34:43.550
Obviously, that has a lot of advantages.

00:34:43.940 --> 00:34:47.060
One big change, I guess,
and you have to be aware of is that

00:34:47.060 --> 00:34:50.740
if you buy into this tile layer model,
then you're also buying into the

00:34:50.740 --> 00:34:53.080
fact that your drawing is now
all going to be asynchronous.

00:34:53.080 --> 00:34:55.900
That means that, you know,
your drawing context method will no

00:34:55.960 --> 00:34:57.730
longer be called on the main thread.

00:34:57.740 --> 00:35:00.410
It will be called on
some background thread,

00:35:00.410 --> 00:35:02.710
potentially more than one at a time.

00:35:02.720 --> 00:35:05.850
And obviously, the reason for that,
again, is that, you know,

00:35:05.970 --> 00:35:08.430
we want this thing to be kind
of smooth and fluid and we

00:35:08.530 --> 00:35:09.940
don't want the UI to block.

00:35:09.940 --> 00:35:13.920
And we want the images to come in
over time and in lots of levels.

00:35:13.940 --> 00:35:15.640
pieces.

00:35:15.840 --> 00:35:16.800
Here's a code example.

00:35:16.800 --> 00:35:19.240
Basically,
what we're going to do here is just

00:35:19.240 --> 00:35:22.570
create one of these tile layers,
set its levels of detail to say we have

00:35:22.570 --> 00:35:24.080
eight layers in this image pyramid.

00:35:24.360 --> 00:35:27.920
Obviously, any kind of pyramidal scheme,
it's going to be top level will

00:35:28.050 --> 00:35:32.660
be 100%, then the next one will
be 50% scale factors and so on.

00:35:32.680 --> 00:35:35.060
In this case,
we're also going to say bias

00:35:35.110 --> 00:35:37.130
those scale factors up by three.

00:35:37.190 --> 00:35:40.710
What that means is that we're actually
requesting the pyramid to store three

00:35:40.830 --> 00:35:45.730
levels that are greater than 100%.
We're also going to get a 200% level,

00:35:45.730 --> 00:35:49.620
a 400%, and an 800% level of detail.

00:35:49.620 --> 00:35:51.910
The reason we're doing that
is because in this case,

00:35:51.920 --> 00:35:56.180
we could be drawing things from
a PDF or from vector artwork.

00:35:56.180 --> 00:35:58.250
In those cases,
we know that we can draw those as

00:35:58.250 --> 00:36:00.060
finely as we want at any resolution.

00:36:00.060 --> 00:36:04.570
If you zoom right in to 1,000%, then you
don't want the pixels to be blown up.

00:36:04.580 --> 00:36:09.680
You want the tiles to be redrawn
for the current level of detail.

00:36:09.700 --> 00:36:33.000
[Transcript missing]

00:36:33.130 --> 00:36:36.700
The main thing about a Core Image,
a CI image,

00:36:36.700 --> 00:36:38.980
is that it's not a Raster data structure.

00:36:38.980 --> 00:36:39.600
It's not pixels.

00:36:39.600 --> 00:36:41.940
It's kind of a recipe to produce pixels.

00:36:41.960 --> 00:36:44.510
And that's great and
has a lot of advantages.

00:36:44.510 --> 00:36:47.510
But it's not so great for
Core Animation because Core Animation is

00:36:47.510 --> 00:36:49.930
totally built around this
idea of having things we can

00:36:49.930 --> 00:36:51.690
give the graphics card to texture from.

00:36:51.700 --> 00:36:56.190
So there is no way to just take a
CI image and put it into a layer.

00:36:56.190 --> 00:36:58.500
You have to draw it
into that layer somehow.

00:36:59.260 --> 00:37:02.280
And the most simplest way we can
find to do that is basically just

00:37:02.280 --> 00:37:06.610
create a tile layer and just draw
the CI image into that tile layer.

00:37:06.620 --> 00:37:10.540
The other method you
could use is using OpenGL.

00:37:10.540 --> 00:37:13.820
And in some cases that can get
you a little more performance.

00:37:13.860 --> 00:37:16.700
But again,
it has all these kind of GPU limits

00:37:16.700 --> 00:37:18.580
and you have to use OpenGL.

00:37:18.580 --> 00:37:22.270
You have to be aware of if
I create an image 10,000 by 10,000,

00:37:22.270 --> 00:37:24.140
is that going to work on my current GPU?

00:37:24.140 --> 00:37:27.560
So really we recommend you
just use the tile layer.

00:37:28.620 --> 00:37:31.550
And then maybe think about other options
if that really doesn't cut it for you,

00:37:31.560 --> 00:37:32.710
which we think it will.

00:37:32.720 --> 00:37:36.620
So back, this is the kind of following
from the previous example.

00:37:36.620 --> 00:37:40.240
So here we're going to actually
implement the draw method to draw

00:37:40.240 --> 00:37:42.660
a CI image into our tile layer.

00:37:42.660 --> 00:37:45.660
And you can see it really has
literally one long line of code.

00:37:45.720 --> 00:37:50.480
So we're going to take the CI image
and draw it into the tile layer.

00:37:50.560 --> 00:37:54.680
And because before the tile layer
handed us off our CG context,

00:37:54.750 --> 00:37:57.980
it actually set up the scale
factors and the clipping rectangles

00:37:57.980 --> 00:37:59.270
and all the kind of CTM stuff.

00:37:59.280 --> 00:38:01.330
So all you really have to do
in the tile layer is just draw

00:38:01.330 --> 00:38:02.640
whatever you're going to draw.

00:38:02.640 --> 00:38:06.260
And then everything just works and
you only really draw the tile we care

00:38:06.310 --> 00:38:07.960
about and at the right level of detail.

00:38:07.960 --> 00:38:10.230
So at this point,
I want to show you a quick

00:38:10.230 --> 00:38:12.140
demo of what I'm talking about.

00:38:13.500 --> 00:40:52.600
[Transcript missing]

00:40:52.720 --> 00:41:09.780
This is a 20-megapixel image.

00:41:09.780 --> 00:41:09.780
You can see now we're showing at 12%.
This is like 80 megabytes of data.

00:41:09.780 --> 00:41:09.780
And at all times, you know,
things stay pretty smooth and fluid and,

00:41:09.780 --> 00:41:09.780
you know, the filters kind of still work.

00:41:10.320 --> 00:41:11.970
You can see right now the
GPU is actually being pretty

00:41:11.970 --> 00:41:13.060
taxed to render these filters.

00:41:13.060 --> 00:41:19.600
You can see by the length of time
it takes the tiles to show up.

00:41:20.040 --> 00:41:25.290
So anyway,
we think the title layer is pretty cool,

00:41:25.290 --> 00:41:26.800
and we recommend you use it.

00:41:26.800 --> 00:41:30.300
So back to the slides.

00:41:30.300 --> 00:41:30.300
Thanks.

00:41:36.300 --> 00:41:39.810
Okay, so next topic is 3D
because as everyone knows,

00:41:39.860 --> 00:41:41.270
Core Animation is a 3D engine.

00:41:41.500 --> 00:41:44.580
Well, it's not,
but a lot of the demos we show

00:41:44.580 --> 00:41:46.620
you may give you that impression.

00:41:46.620 --> 00:41:49.910
But so we should really
stress that CA is a 2D,

00:41:49.910 --> 00:41:54.180
2.5D engine,
which means that it's lots of planes,

00:41:54.180 --> 00:41:56.000
but they can be arranged in 3D space.

00:41:56.000 --> 00:42:00.410
So what I want to talk about
is how you actually do that.

00:42:00.570 --> 00:42:02.690
You know, how do you create these
demos or these planes?

00:42:03.800 --> 00:42:06.110
And the way you do that is
you set up some kind of camera

00:42:06.110 --> 00:42:07.720
matrix on your container layer.

00:42:07.720 --> 00:42:12.600
And the way you do that is you use
the sublayer transform property.

00:42:12.600 --> 00:42:16.680
Now, the sublayer transform was expressly
added just so you can have some matrix

00:42:16.720 --> 00:42:18.860
which affects all of your sublayers.

00:42:18.860 --> 00:42:22.150
And this is basically ideal for doing
kind of camera perspective type things

00:42:22.190 --> 00:42:23.970
because that's really what you want.

00:42:23.980 --> 00:42:27.040
I guess I should also say that this
is applied relative to the center

00:42:27.040 --> 00:42:30.220
of the layer it's attached to,
just like the other transforms.

00:42:31.330 --> 00:42:33.540
So in this case,
this little code example is going

00:42:33.540 --> 00:42:36.620
to show you how to set up the
typical kind of camera matrix

00:42:36.620 --> 00:42:38.290
which we use on all these 3D demos.

00:42:38.300 --> 00:42:42.020
So the first couple of lines are
going to create the perspective

00:42:42.020 --> 00:42:43.540
component of our matrix.

00:42:43.540 --> 00:42:46.460
Currently we don't have a
function to do that for you,

00:42:46.620 --> 00:42:48.290
but given that it's
only one line of code,

00:42:48.290 --> 00:42:50.040
I'm not sure it's really worth it.

00:42:50.040 --> 00:42:52.690
So anyway,
so you do this minus one over depth

00:42:52.690 --> 00:42:55.040
thing in the right matrix component.

00:42:55.080 --> 00:42:57.620
And this is basically going to
get you this perspective effect.

00:42:57.620 --> 00:43:02.120
Because what this does is the, you know,
M three four basically means

00:43:02.120 --> 00:43:05.860
take the Z component of my model,
divide it by something and

00:43:05.900 --> 00:43:06.860
then add it to something else.

00:43:06.860 --> 00:43:10.500
And then you get kind of the
perspective foreshortening effect.

00:43:10.700 --> 00:43:18.450
The next two lines are applying
some kind of camera orientation

00:43:18.450 --> 00:43:20.200
and positioning effect.

00:43:20.200 --> 00:43:23.000
You do this after the projection,
after the perspective.

00:43:23.000 --> 00:43:25.260
So in this case we have some
pre-cooked rotation matrix which

00:43:25.310 --> 00:43:30.500
presumably we created through the
CA Transform 3D Rotate functions.

00:43:30.500 --> 00:43:33.910
And then we're going to just offset
some XYZ amounts and then add

00:43:34.070 --> 00:43:36.140
that to the sub-layer transform.

00:43:36.140 --> 00:43:37.970
Once we've done that,
any sub-layer we put,

00:43:38.040 --> 00:43:41.350
any layer we put as a sub-layer of
this guy with the sub-layer transform,

00:43:41.350 --> 00:43:44.670
when we move him around and rotate him,
the perspective effects and

00:43:44.670 --> 00:43:47.250
the camera effects will all
be applied to him pretty much,

00:43:47.250 --> 00:43:51.160
you know, they just will.

00:43:51.170 --> 00:43:54.310
So then the next part is
once you have this 3D space,

00:43:54.310 --> 00:43:57.280
then you need to position
things within it.

00:43:57.280 --> 00:44:00.160
The way you do that is with
the standard position property,

00:44:00.160 --> 00:44:01.820
but also with the Z position.

00:44:01.820 --> 00:44:05.230
You know, now we're in 3D space,
so the Z component of the layers

00:44:05.230 --> 00:44:07.840
becomes important because that's
where the foreshortening and

00:44:07.840 --> 00:44:08.940
the perspective comes from.

00:44:08.940 --> 00:44:17.800
So then you can also use the anchor point
again to control the reference point.

00:44:17.800 --> 00:44:19.840
And in New and Snow Leopard we've
added this anchor point Z thing,

00:44:19.840 --> 00:44:24.390
which means you can actually now
get full kind of 3D control of your

00:44:24.390 --> 00:44:27.260
reference point for transforms.

00:44:27.260 --> 00:44:29.180
And that's very nice because
that means you can now have,

00:44:29.180 --> 00:44:32.720
you know, 3D layers which rotate about
an arbitrary point in space.

00:44:32.720 --> 00:44:35.940
You know, not their center, but,
you know, some point elsewhere.

00:44:35.940 --> 00:44:37.710
Also, as was mentioned earlier,
we're now trying to add some of the

00:44:37.710 --> 00:44:39.270
3D layers to the reference point.

00:44:39.350 --> 00:44:41.640
So we're now trying to add support
for true intersections between layers.

00:44:41.690 --> 00:44:43.400
So, you know,
if you have two layers which

00:44:43.510 --> 00:44:45.970
kind of look like this,
then we will slice them up in

00:44:46.020 --> 00:44:49.940
the right way and render the
slices in the right order.

00:44:49.940 --> 00:44:52.630
And again, that's something that's
expensive for us to do,

00:44:52.630 --> 00:44:54.840
so, you know,
only do that if you have to,

00:44:54.880 --> 00:44:58.530
but it can make things look a
lot better when they intersect.

00:44:59.160 --> 00:45:06.200
Okay, so next on our whirlwind tour
of random topics is threading.

00:45:06.430 --> 00:45:08.640
I don't think we've talked a
whole lot about this in the past.

00:45:08.690 --> 00:45:14.250
Basically, you may want to use threads
for drawing these days.

00:45:14.260 --> 00:45:16.460
You have lots of cores,
and lots of them are going

00:45:16.460 --> 00:45:19.780
to be used for data work,
but graphics can be threaded as well.

00:45:19.800 --> 00:45:23.930
To that end, CA Layer is itself basically
entirely thread-safe.

00:45:24.020 --> 00:45:27.160
This means you can set any property,
you can get any property,

00:45:27.160 --> 00:45:30.660
you can do basically any restructuring,
changing the sub-layers,

00:45:30.660 --> 00:45:31.440
all these kind of things.

00:45:31.440 --> 00:45:33.990
We will pretty much guarantee
that when you do that,

00:45:34.070 --> 00:45:35.800
you're never going to
corrupt our data structures.

00:45:36.450 --> 00:45:40.860
And we will pretty much do that
until you get the right results.

00:45:42.440 --> 00:45:46.720
So the one thing that isn't done for you,
though, is that when you fetch

00:45:46.840 --> 00:45:51.700
a property of a layer,
the value you get back is not guaranteed

00:45:51.700 --> 00:45:55.940
to be valid if another thread is setting
the same property at the same time.

00:45:55.980 --> 00:45:58.140
Now, you can imagine two threads come in.

00:45:58.140 --> 00:46:00.150
They both set the background
color of a particular layer.

00:46:00.160 --> 00:46:02.930
And then one of them fetches
that property while the

00:46:03.040 --> 00:46:04.580
other one is about to set it.

00:46:04.640 --> 00:46:06.710
And now you're kind of in
this window of uncertainty.

00:46:06.720 --> 00:46:10.210
And the object you get back may
or may not still be valid because,

00:46:10.210 --> 00:46:12.120
you know,
we don't auto-release things when we give

00:46:12.120 --> 00:46:13.720
them back to you for performance reasons.

00:46:13.720 --> 00:46:16.780
So it's kind of up to
you to guarantee that,

00:46:17.040 --> 00:46:22.150
you know, anything you fetch remains good
for the lifetime you need it.

00:46:25.170 --> 00:46:27.300
We now have a way to let you do that,
which is by adding

00:46:27.300 --> 00:46:28.700
these transaction locks.

00:46:28.700 --> 00:46:32.520
The idea here is that these are
the same locks we use internally.

00:46:32.520 --> 00:46:36.510
You can take the transaction lock,
do any kind of

00:46:36.830 --> 00:46:40.530
read-modify-write style code,
and then unlock the transaction lock.

00:46:40.540 --> 00:46:42.990
It has to be emphasized
that this is a spin lock.

00:46:43.060 --> 00:46:45.250
If you hold this thing
for a long period of time,

00:46:45.250 --> 00:46:48.180
everything is going to grind to
a halt in a pretty nasty way.

00:46:49.290 --> 00:46:52.100
But the idea is you can at least
have enough synchronization

00:46:52.100 --> 00:46:54.510
to let you query a property,
retain it,

00:46:54.670 --> 00:46:59.200
or set something else based on its value,
before you then unlock and then

00:46:59.200 --> 00:47:02.560
use your retained value or go
along and do something else.

00:47:02.560 --> 00:47:05.810
One other thing worth mentioning
about threading is that you may

00:47:05.810 --> 00:47:09.330
be able to avoid it entirely just
by using the set-by-the-key path.

00:47:09.400 --> 00:47:12.720
Obviously, if you were going to set a
sub-property of an object,

00:47:12.720 --> 00:47:16.560
like a filter, for example,
then filters are not thread-safe.

00:47:18.080 --> 00:47:20.690
So you can't just go off and set
those properties directly if multiple

00:47:20.760 --> 00:47:22.230
threads are going to be doing that.

00:47:22.260 --> 00:47:24.720
However,
if you use the set-value-of-key-path

00:47:24.720 --> 00:47:29.470
with the right current construction of a
key-path to reference the right property,

00:47:29.480 --> 00:47:31.390
then we will make sure,
because we have copies

00:47:31.470 --> 00:47:33.730
of all these filters,
that we will make sure that

00:47:33.730 --> 00:47:35.420
everything works as intended.

00:47:35.440 --> 00:47:38.130
And I guess the side effect of that
is you'll also be able to get implicit

00:47:38.310 --> 00:47:41.800
animations on these filter properties,
because that's kind of done the same way.

00:47:41.800 --> 00:47:48.060
One more point about threading is that
we try to guarantee that when you call,

00:47:48.060 --> 00:47:52.320
"Send these display on a layer," then we
will call your display or drawing context

00:47:52.370 --> 00:47:55.820
method on exactly the same thread,
because that's pretty important if

00:47:55.820 --> 00:47:57.610
you want to multi-thread your drawing.

00:47:57.620 --> 00:48:00.860
That also holds for the layout
methods and basically any other

00:48:00.920 --> 00:48:02.740
callbacks we might be issuing.

00:48:02.760 --> 00:48:05.780
And finally,
this is back to the two trees thing.

00:48:05.800 --> 00:48:08.260
As I said earlier,
we need a run loop to be able to

00:48:08.270 --> 00:48:10.110
flush out your updates for you.

00:48:10.120 --> 00:48:13.690
So if you're on a background thread
and you're making layer changes,

00:48:13.720 --> 00:48:17.950
then you may not have a run loop,
or if you do, it may not be running.

00:48:18.080 --> 00:48:20.990
Or running fast often enough
to push your changes out.

00:48:21.040 --> 00:48:25.500
So the simple solution there is
that every time you do something

00:48:25.500 --> 00:48:28.370
and you're about to block,
or sleep, or whatever,

00:48:28.450 --> 00:48:30.920
then you can just call this
transaction flush method,

00:48:30.920 --> 00:48:34.040
and that will basically push any
cute changes that are in your

00:48:34.040 --> 00:48:35.710
current thread off to the screen.

00:48:35.760 --> 00:48:39.120
And that's the thing we're going to
be doing automatically in most cases,

00:48:39.210 --> 00:48:41.800
but you need to do it sometimes.

00:48:44.230 --> 00:48:46.780
Okay, so most of, up to this point,
what I've been talking

00:48:46.780 --> 00:48:48.230
about has been very general.

00:48:48.250 --> 00:48:51.830
You know, just CA as an API,
no real platform dependencies,

00:48:51.830 --> 00:48:53.460
apart from things like Core Image.

00:48:53.460 --> 00:48:56.430
But so, obviously,
CA runs on both platforms

00:48:56.460 --> 00:48:59.740
we have these days,
you know, iPhone and Mac.

00:48:59.740 --> 00:49:04.250
And iPhone is a lot smaller a
platform than the Macintosh,

00:49:04.290 --> 00:49:05.180
the Mac.

00:49:05.180 --> 00:49:09.600
So, when we took CA to the iPhone,
we really decided that, you know,

00:49:09.600 --> 00:49:11.840
we could only afford to take the
bits of it that we really needed.

00:49:12.620 --> 00:49:15.170
Or that we really thought that
were things we could do with

00:49:15.270 --> 00:49:16.770
the most possible performance.

00:49:16.860 --> 00:49:20.790
So, anything else we kind of left behind,
at least for now.

00:49:23.320 --> 00:49:28.800
There's this list of properties which
were removed from the Mac version

00:49:28.800 --> 00:49:30.330
as we took it to the iPhone.

00:49:30.330 --> 00:49:31.980
You can't do things like
rounded corners yet,

00:49:32.000 --> 00:49:35.520
you can't do borders, masks, shadows,
filters, obviously, layout managers.

00:49:35.520 --> 00:49:38.260
We really don't think
this is a big problem.

00:49:38.260 --> 00:49:41.120
Most of these things,
if we did implement them,

00:49:41.120 --> 00:49:43.000
they'd be so slow you
wouldn't use them anyway.

00:49:43.560 --> 00:49:45.750
And the other thing is, you know,
they're just kind of convenience things.

00:49:45.780 --> 00:49:51.090
Like, layout managers can be implemented
just by subclassing and using

00:49:51.090 --> 00:49:54.300
the layout sublets method.

00:49:55.000 --> 00:49:58.370
So the next point is,
I'm sure you're aware of this,

00:49:58.370 --> 00:50:01.180
but the coordinate system
or the coordinate space in

00:50:01.180 --> 00:50:05.060
the iPhone is upside down,
at least to us Mac people.

00:50:05.060 --> 00:50:09.910
And what that means is that, you know,
if you have code that you

00:50:10.060 --> 00:50:13.660
want to run in both places,
then you need to deal with that somehow.

00:50:13.660 --> 00:50:17.130
And so up to this point,
it was kind of hard to do that because

00:50:17.200 --> 00:50:20.560
if you just flip the transform,
that doesn't do the right thing because,

00:50:20.560 --> 00:50:21.800
you know, your images flip as well.

00:50:22.470 --> 00:50:24.640
Whereas images have a native
kind of memory ordering,

00:50:24.640 --> 00:50:26.560
which, you know, needs to remain static.

00:50:26.560 --> 00:50:30.220
So we added in 10.6 this new
property called Geometry Flipped.

00:50:30.240 --> 00:50:32.790
And what that does is when
you set that on a layer,

00:50:32.790 --> 00:50:35.600
the entire subtree from
that point becomes flipped,

00:50:35.600 --> 00:50:37.060
but only for geometry.

00:50:37.060 --> 00:50:40.280
And so the idea here is that
you can take code that runs on

00:50:40.280 --> 00:50:43.520
the iPhone for the producer's,
say, layer subtree,

00:50:43.520 --> 00:50:47.650
and take it back to the Mac, you know,
attach it to some layer you have,

00:50:47.700 --> 00:50:50.500
set the Geometry Flipped
property to be yes.

00:50:50.500 --> 00:50:52.340
And then hopefully
everything will just work.

00:50:52.440 --> 00:50:55.030
work correctly.

00:50:55.430 --> 00:50:56.100
- This is the idea.

00:50:56.270 --> 00:50:59.350
So again,
it's worth emphasizing that the images

00:50:59.440 --> 00:51:00.980
will not be flipped by this thing.

00:51:01.150 --> 00:51:05.360
You know, because images are images and
they have just the standard order,

00:51:05.360 --> 00:51:08.710
and you always want them to
come up the right way up.

00:51:08.900 --> 00:51:12.820
So now let's talk a little
bit about performance.

00:51:12.840 --> 00:51:16.080
And these things apply mostly
both to the Mac and the iPhone.

00:51:16.080 --> 00:51:18.700
Obviously, performance is more of an
issue on iPhone because,

00:51:18.700 --> 00:51:21.030
you know,
it has a lot less capable hardware,

00:51:21.060 --> 00:51:23.150
although it does also
have a smaller screen,

00:51:23.150 --> 00:51:23.800
of course.

00:51:24.560 --> 00:51:27.430
So firstly,
the number one thing you want to do,

00:51:27.510 --> 00:51:30.640
if you can,
is avoid all off-screen rendering.

00:51:30.640 --> 00:51:33.600
And what off-screen rendering is,
is that every now and then,

00:51:33.620 --> 00:51:36.360
most of the time we're going
along happily using OpenGL when

00:51:36.430 --> 00:51:39.030
we're rendering things,
and we're just taking the layers

00:51:39.220 --> 00:51:41.590
you give us and just drawing
them straight to the screen.

00:51:41.600 --> 00:51:44.530
But every now and then,
there are certain types of effects,

00:51:44.530 --> 00:51:46.940
which means we have to
halt the screen rendering,

00:51:46.940 --> 00:51:49.810
create a new buffer to draw into,
a new image, if you like,

00:51:49.810 --> 00:51:53.030
draw things into this,
and then copy that to the screen.

00:51:54.050 --> 00:51:55.020
And that works out fine.

00:51:55.020 --> 00:51:58.420
It's really still a lot faster than,
you know, anything else we could do.

00:51:58.710 --> 00:52:01.090
But there is a bottleneck there.

00:52:01.090 --> 00:52:03.950
I mean, it does, you can noticeably see
the speed dropping,

00:52:03.960 --> 00:52:06.850
especially on the iPhone,
where it's much more of a cliff than a,

00:52:06.850 --> 00:52:08.400
you know, bump or something.

00:52:08.400 --> 00:52:12.180
So the list of things you should avoid
if you want to avoid off-screen rendering

00:52:12.180 --> 00:52:15.180
is having group opacity effects,
where you have, you know,

00:52:15.180 --> 00:52:17.900
a layer and a bunch of sub-layers,
and then you change the

00:52:17.900 --> 00:52:19.760
opacity of the parent layer.

00:52:19.800 --> 00:52:21.180
Obviously,
what we have to do to render that

00:52:21.180 --> 00:52:23.360
is we can't just multiply the
opacity through all the layers.

00:52:23.360 --> 00:52:24.800
Because we'll get the wrong result.

00:52:24.860 --> 00:52:26.800
So we have to, you know,
do off-screen rendering.

00:52:26.950 --> 00:52:29.860
Similarly, any kind of masking,
which isn't particularly simple.

00:52:29.860 --> 00:52:31.860
Any type of core image
filters or shadows,

00:52:31.860 --> 00:52:33.750
although those are already
only on the Mac right now.

00:52:33.860 --> 00:52:37.310
And certain types of transition effects
and certain types of 3D transforms.

00:52:37.370 --> 00:52:41.360
If you have a layer and a sub-layer
and they both have a 3D matrix,

00:52:41.360 --> 00:52:43.730
then because we're a 2D model,
they have to be kind of

00:52:43.790 --> 00:52:45.360
projected back into 2D space.

00:52:45.360 --> 00:52:48.440
And then we have to do that twice,
then we have to render

00:52:48.440 --> 00:52:50.080
one of them off-screen.

00:52:53.180 --> 00:52:57.560
The next performance rule
is minimize blending.

00:52:57.560 --> 00:53:01.980
Blending is where you see
translucency in your UI.

00:53:02.000 --> 00:53:04.800
The way graphics cards work is if
you're just drawing opaque data,

00:53:04.800 --> 00:53:07.100
you can splat it straight
to the destination.

00:53:07.100 --> 00:53:11.450
But if you're drawing things which are
translucent or have an alpha channel,

00:53:11.570 --> 00:53:14.000
when you're drawing them,
the graphics card will

00:53:14.000 --> 00:53:17.220
have to look at the pixel,
take the value of the destination,

00:53:17.220 --> 00:53:19.620
read it back,
and then do some math between

00:53:19.660 --> 00:53:21.480
the two and then copy that
back to the destination again.

00:53:21.480 --> 00:53:26.550
And that kind of costs quite a lot,
especially because it also means that

00:53:26.550 --> 00:53:30.070
we have to actually draw the things
that are underneath translucent content,

00:53:30.070 --> 00:53:31.760
whereas if we know
that things are opaque,

00:53:31.780 --> 00:53:36.270
then we can just most of the time avoid
entirely drawing anything underneath it.

00:53:36.280 --> 00:53:39.000
So this is really key,
and especially on the iPhone where,

00:53:39.070 --> 00:53:42.230
again, the hardware is more limited,
so the amount of throw rate,

00:53:42.230 --> 00:53:45.060
the amount of blending bandwidth
you have is a lot less.

00:53:45.060 --> 00:53:48.260
So what do we want to do to avoid this?

00:53:48.260 --> 00:53:51.360
Basically, we just want to get rid of the
alpha channel from our layers.

00:53:51.540 --> 00:53:57.140
So if we're drawing into the layer,
the way we would do that is we

00:53:57.140 --> 00:54:02.900
will basically set the opaque
property of the layer to be yes.

00:54:03.080 --> 00:54:06.290
And that basically tells CA that
when it's asking you to draw into the

00:54:06.290 --> 00:54:09.000
backing store of the image of the layer,
then don't bother

00:54:09.050 --> 00:54:10.450
creating an alpha channel.

00:54:10.650 --> 00:54:13.240
Similarly,
if you're providing CG image data

00:54:13.240 --> 00:54:16.800
by just sending the contents of
the layer to this image object,

00:54:16.840 --> 00:54:20.040
then you need to make sure
that it has no alpha channel.

00:54:20.500 --> 00:54:22.910
I should just say that setting the
opaque property on these kind of

00:54:22.910 --> 00:54:24.650
layers has absolutely no effect.

00:54:24.650 --> 00:54:27.140
So how do you create an image
without an alpha channel?

00:54:27.140 --> 00:54:29.290
Well, obviously,
if you're reading an image from a

00:54:29.290 --> 00:54:33.410
disk or a flash or some kind of file,
then you need to make sure that the

00:54:33.780 --> 00:54:35.830
image format does the right thing.

00:54:35.910 --> 00:54:39.200
So you may want to use a JPEG because
they don't have alpha channels.

00:54:39.200 --> 00:54:40.850
Apparently,
there may be some ways you can

00:54:40.860 --> 00:54:42.520
create pings without alpha channels.

00:54:43.520 --> 00:54:45.730
And then, alternatively,
if you're going to create

00:54:45.780 --> 00:54:48.480
the image from data,
you know, you have some raster in memory,

00:54:48.480 --> 00:54:52.180
then just use the image alpha
none bitmap formats in CG.

00:54:52.180 --> 00:54:55.630
That tells us that you
have no alpha data.

00:54:55.640 --> 00:54:58.120
So one thing I should also say is that,
you know,

00:54:58.120 --> 00:55:01.200
if you're drawing into the layer and you,
well, if you're,

00:55:01.200 --> 00:55:04.300
for some reason you can't remove
the alpha channel because,

00:55:04.300 --> 00:55:06.870
you know,
you need these things to blend together

00:55:06.870 --> 00:55:10.370
and performance is still too bad,
then you may want to consider

00:55:10.370 --> 00:55:12.330
collapsing some of your layer trees.

00:55:13.610 --> 00:55:16.060
So, you know,
anything we can composite at runtime,

00:55:16.070 --> 00:55:18.770
if it's not animating,
you can composite at draw time.

00:55:18.820 --> 00:55:21.720
So now you can have one layer and
draw two images into it rather than

00:55:21.720 --> 00:55:23.540
having two layers with an image each.

00:55:23.540 --> 00:55:27.090
And obviously anything you can do
ahead of time once rather than us

00:55:27.090 --> 00:55:31.190
doing it a million times every frame
is going to make things a lot faster.

00:55:32.810 --> 00:55:36.170
Okay, so, you know,
this is kind of hard to actually

00:55:36.170 --> 00:55:37.540
even discover when this is happening.

00:55:37.540 --> 00:55:38.700
You just see things are slow.

00:55:38.700 --> 00:55:40.820
So we do give you some debugging options.

00:55:41.000 --> 00:55:43.840
And so basically you just
set the CA color opaque

00:55:43.840 --> 00:55:46.120
environment variable on the Mac.

00:55:46.120 --> 00:55:48.550
And on the iPhone,
the way to set the same option

00:55:48.550 --> 00:55:50.340
is via the Instruments panel.

00:55:50.340 --> 00:55:53.920
So you can see I've highlighted it on
screen here just so you know where it is.

00:55:53.920 --> 00:55:56.470
And Instruments actually
has a number of interesting

00:55:56.470 --> 00:56:00.340
Core Animation options to do things like,
you know, flashing random parts of the

00:56:00.490 --> 00:56:02.220
layers when you're drawing them.

00:56:02.800 --> 00:56:06.720
Highlighting things in other
colors based on what's happening.

00:56:06.940 --> 00:56:10.820
But this diagram really just shows you
this opaque opacity blending thing.

00:56:10.820 --> 00:56:16.380
And so what you can see here is
I cooked up some boring Nib file

00:56:16.380 --> 00:56:19.190
in IB and then put it up on the
iPhone and turned on this option.

00:56:19.190 --> 00:56:21.650
And you can see here that, you know,
the green things are good,

00:56:21.650 --> 00:56:22.300
they're opaque.

00:56:22.350 --> 00:56:25.360
And the red things are bad,
they're translucent.

00:56:25.360 --> 00:56:30.040
And so this is what you'll see if you
turn on this option with the UI running.

00:56:30.040 --> 00:56:33.440
And the idea here is, or the goal,
I guess, is to make basically get rid of

00:56:33.440 --> 00:56:35.130
all the red as much as possible.

00:56:35.270 --> 00:56:36.700
And if you do that,
you should see frame rates

00:56:36.700 --> 00:56:41.110
improve pretty dramatically.

00:56:42.710 --> 00:56:46.780
Okay, so we're on to the last
section of the talk now.

00:56:46.810 --> 00:56:50.100
And finally,
I wanted to talk about what is

00:56:50.100 --> 00:56:52.620
coming up in the next OS release.

00:56:52.620 --> 00:56:55.020
So just a few of the key features.

00:56:55.050 --> 00:56:56.720
So first of all,
we're going to add support

00:56:56.800 --> 00:56:58.940
for trilinear filtering,
and this is really just exposing

00:56:58.940 --> 00:57:00.690
a graphics card feature.

00:57:00.730 --> 00:57:03.930
Trilinear filtering is a way to get
good quality downsampling of images

00:57:03.930 --> 00:57:08.180
because it's also called MIP mapping,
and the image you pass the GPU then

00:57:08.180 --> 00:57:12.260
has multiple levels of detail,
again, kind of similar to the tile layer.

00:57:12.290 --> 00:57:16.460
And the graphics card will
select the most optimal level,

00:57:16.460 --> 00:57:20.120
and this basically means you get better
quality images on the screen because

00:57:20.170 --> 00:57:24.210
there's a lot less alienating if you pick
a small image if you need a small image.

00:57:24.360 --> 00:57:27.490
And also it's faster because you
can minimize the bandwidth the

00:57:27.490 --> 00:57:29.200
graphics card is actually using.

00:57:29.400 --> 00:57:30.690
So this is very easy for you to set up.

00:57:30.780 --> 00:57:34.030
It works on all types of layers,
or all types of image-based layers,

00:57:34.110 --> 00:57:34.730
I should say.

00:57:35.060 --> 00:57:38.190
But the one drawback is that
not all graphics cards support

00:57:38.190 --> 00:57:39.470
this on all images yet.

00:57:39.690 --> 00:57:45.430
So you can... see the
OpenGL documentation.

00:57:45.540 --> 00:57:49.300
But basically,
if you have a power of two size image,

00:57:49.300 --> 00:57:53.860
it's 256 by 256, or 256 by 128,
or something like that,

00:57:53.860 --> 00:57:56.060
then it's pretty much
guaranteed to always work.

00:57:56.140 --> 00:58:00.130
If your image is not power of two size,
then it will work on some graphics cards,

00:58:00.140 --> 00:58:05.110
and anything else will just
fall back to the regular method,

00:58:05.180 --> 00:58:06.780
so it's not terrible.

00:58:06.780 --> 00:58:11.380
There's also an LOD bias property,
and that is kind of a graphics-y term,

00:58:11.380 --> 00:58:13.840
but it basically means
you have the slider,

00:58:13.850 --> 00:58:16.600
and one end is sharp, one end is blurry,
and you can kind of move

00:58:16.600 --> 00:58:18.620
yourself along the slider.

00:58:18.650 --> 00:58:22.060
Oh, I should also point out that
this now works with Tidal layer.

00:58:22.080 --> 00:58:28.890
So you can kind of get some level of
trilinear three-way filtering by setting

00:58:29.370 --> 00:58:31.500
that property on the Tidal layer.

00:58:31.530 --> 00:58:34.020
And in this case,
it's not a true per-pixel

00:58:34.020 --> 00:58:35.400
graphics card-based property.

00:58:36.500 --> 00:59:06.800
[Transcript missing]

00:59:07.270 --> 00:59:09.600
So, secondly, we added a gradient layer.

00:59:09.600 --> 00:59:13.050
The gradient layer is just
a subclass of the CA layer.

00:59:13.050 --> 00:59:16.250
And as its name suggests,
it will draw a gradient into its shape.

00:59:16.250 --> 00:59:18.700
So it's just an axial gradient right now.

00:59:18.740 --> 00:59:20.910
And you get to specify
an array of colors,

00:59:20.920 --> 00:59:23.360
an array of locations
for those color stops.

00:59:23.450 --> 00:59:25.620
You can say this one is
here to here and then here.

00:59:25.620 --> 00:59:29.390
And you also get to specify two
two-dimensional points within

00:59:29.480 --> 00:59:33.100
the layer shape to give kind
of the endpoints of the axis.

00:59:33.100 --> 00:59:35.120
So then that defines your gradient.

00:59:35.120 --> 00:59:37.180
And then what we do then is just
draw that using the gradient layer.

00:59:37.200 --> 00:59:39.510
So, basically,
we're just going to use the gradient

00:59:39.510 --> 00:59:41.200
layer to draw the gradient in the GPU.

00:59:41.200 --> 00:59:44.170
And obviously, because these are just
kind of numeric properties,

00:59:44.190 --> 00:59:46.790
you can animate all of them
using the regular CA animation.

00:59:46.800 --> 00:59:48.680
So you can animate
colors fading in and out,

00:59:48.680 --> 00:59:51.370
the gradient spinning around
or moving the gradient stops.

00:59:51.370 --> 00:59:53.340
Kind of everything is up for grabs.

00:59:53.840 --> 00:59:56.610
Another example should be
fairly self-explanatory.

00:59:56.620 --> 01:00:00.260
We're just really creating layers,
setting up much properties again.

01:00:00.430 --> 01:00:02.300
So let's not dwell on that.

01:00:03.400 --> 01:00:07.240
So the next new subclass is
called the CA Transform layer.

01:00:07.240 --> 01:00:10.260
This is a little different.

01:00:10.260 --> 01:00:12.220
So up to this point,
we've talked about 3D and

01:00:12.270 --> 01:00:14.060
we've talked about 2 and 1/2D.

01:00:14.060 --> 01:00:18.550
And layers, we've always said, are 2D,
which means that you take this

01:00:18.600 --> 01:00:22.310
2D graphic element and then you
push it into its parent in some

01:00:22.310 --> 01:00:26.800
three-dimensional space and then
flatten it into the parent's plane,

01:00:26.800 --> 01:00:29.640
thus preserving the 2D-ness
throughout the entire pipeline.

01:00:29.640 --> 01:00:30.450
And that's great.

01:00:30.460 --> 01:00:33.450
It means you can do kind of
2D imaging effects on 3D,

01:00:33.450 --> 01:00:35.220
pseudo-3D content.

01:00:35.250 --> 01:00:38.650
But it means you can't set up very
complex hierarchical models of 3D

01:00:38.650 --> 01:00:41.060
elements and transform them as groups.

01:00:41.060 --> 01:00:43.480
So for example,
you wouldn't be able to create

01:00:43.480 --> 01:00:47.060
a cube out of six faces and
then rotate the entire thing.

01:00:47.060 --> 01:00:50.730
You'd have to create those six layers
and then rotate each one of them

01:00:50.820 --> 01:00:52.500
separately about some center point.

01:00:52.500 --> 01:00:55.350
And as you can imagine,
that's either impossible or gets really,

01:00:55.400 --> 01:00:57.300
really complex really quickly.

01:00:57.300 --> 01:01:00.950
So what a transform layer does is it
basically extends the layer model a

01:01:00.950 --> 01:01:04.340
little bit and says these are layers
which are only grouping constructs.

01:01:04.360 --> 01:01:06.060
They don't have any content of their own.

01:01:06.070 --> 01:01:08.300
You set the image to be something,
you'll get a warning

01:01:08.300 --> 01:01:09.850
and nothing will happen.

01:01:09.970 --> 01:01:12.200
But their geometry does
apply into their sub-layers,

01:01:12.310 --> 01:01:14.800
but without this flattening step.

01:01:14.800 --> 01:01:18.980
So now you can see that you can do
these kind of cube-like effects in

01:01:19.280 --> 01:01:23.230
this model because you can create
a transform layer and give it six

01:01:23.270 --> 01:01:27.370
faces and animate the rotation
properties of the transform layer.

01:01:27.390 --> 01:01:32.550
And everything will rotate without being
flattened into some kind of mushy mess.

01:01:33.220 --> 01:01:35.300
The way we do that internally,
which is worth bearing in mind

01:01:35.300 --> 01:01:39.160
for things like depth sorting,
is that any sub-layers of the transform

01:01:39.160 --> 01:01:42.710
layer are effectively hoisted up
into its super layer before we do

01:01:42.710 --> 01:01:43.880
any of this kind of processing.

01:01:43.900 --> 01:01:46.090
We take the matrix from
the transform layer,

01:01:46.090 --> 01:01:49.090
concatenate it into the layer itself,
and then push it all back

01:01:49.120 --> 01:01:50.460
up to the next level.

01:01:50.460 --> 01:01:53.140
So we'll have a demo of
this in a little bit.

01:01:53.140 --> 01:01:57.620
Finally,
the last feature is our particle systems.

01:01:57.660 --> 01:02:00.520
You've probably seen these
things in any number of movies,

01:02:00.530 --> 01:02:02.220
and ours is not quite that cool.

01:02:03.130 --> 01:02:07.160
It's basically a way to kind of spew
out lots of little images and have some

01:02:07.160 --> 01:02:08.490
kind of control over where they go.

01:02:08.500 --> 01:02:10.650
And so, you know,
you see a lot of the keynote

01:02:10.650 --> 01:02:13.550
presentations you see at this
conference have these little

01:02:13.550 --> 01:02:16.370
kind of sparkly effects,
and that's kind of things you

01:02:16.370 --> 01:02:17.930
can do with particle systems.

01:02:17.980 --> 01:02:21.230
So our particle system is
structured as another layer

01:02:21.230 --> 01:02:25.120
subclass called the emitter layer,
and then each emitter layer

01:02:25.120 --> 01:02:26.660
has a number of cells.

01:02:26.700 --> 01:02:30.720
And a cell is basically a way to kind of
a template for particles being emitted.

01:02:31.160 --> 01:02:33.580
Now, the layer has what we
call an emission shape,

01:02:33.680 --> 01:02:36.560
which a number of different options,
things like, you know, rectangles,

01:02:36.560 --> 01:02:38.120
circles, spheres, cubes, etc.

01:02:38.120 --> 01:02:42.410
And then the cells then define how
particles are emitted from those

01:02:42.470 --> 01:02:45.200
shapes over time and at certain rates.

01:02:45.200 --> 01:02:47.820
And obviously,
since the cells have these kind

01:02:47.860 --> 01:02:51.010
of template-like properties,
every particle will have some

01:02:51.010 --> 01:02:54.150
set of these properties with some
kind of randomization factors.

01:02:54.160 --> 01:02:58.820
And one really interesting feature
is that cells are not limited

01:02:58.840 --> 01:03:01.120
to just emitting particles.

01:03:01.140 --> 01:03:05.310
The particles they can emit can also
emit particles themselves because

01:03:05.730 --> 01:03:07.900
cells can have subcells and so on.

01:03:07.960 --> 01:03:12.250
So you can kind of create these nice
organic-like effects with things emitting

01:03:12.250 --> 01:03:14.740
things emitting things and what have you.

01:03:14.760 --> 01:03:19.380
Finally, emitter layers are also kind
of similar to transform layers

01:03:19.380 --> 01:03:22.410
in that they have this 2D,
3D option.

01:03:22.420 --> 01:03:26.270
If you choose by default that 2D,
and that basically means that, again,

01:03:26.270 --> 01:03:30.560
all of their particles are flattened into
their layer plane as they're rendered,

01:03:31.310 --> 01:03:34.160
but if you say,
"I want a 3D particle emitter,"

01:03:34.160 --> 01:03:37.060
then what actually happens is they
act kind of like a transformer,

01:03:37.060 --> 01:03:39.970
and their particles are all
rendered into the parent,

01:03:40.060 --> 01:03:43.960
which means they preserve the 3D geometry
into whatever else is in the parent.

01:03:44.060 --> 01:03:49.410
So now, I want to show you a couple of
demos of these new features.

01:03:51.200 --> 01:03:53.490
Okay, so first of all,
this is the example of

01:03:53.520 --> 01:03:54.370
the transform layer.

01:03:54.380 --> 01:03:56.540
And so you can see now
we have these two cubes.

01:03:56.540 --> 01:03:57.520
This is a very quick demo.

01:03:57.520 --> 01:03:59.080
So we have these two cubes.

01:03:59.080 --> 01:03:59.580
They're spinning.

01:03:59.580 --> 01:04:03.880
You can see they're spinning separately,
but they're living in the

01:04:03.910 --> 01:04:05.000
same kind of 3D space.

01:04:05.000 --> 01:04:08.270
And this is really very simple
now because we just have

01:04:08.270 --> 01:04:10.330
animations on the two layers.

01:04:10.340 --> 01:04:12.730
But then we thought, well,
let's take it up another level and

01:04:12.790 --> 01:04:15.180
put them inside another transform
layer with another cube and then

01:04:15.200 --> 01:04:16.820
just kind of rotate that as well.

01:04:16.820 --> 01:04:20.320
And you can see the things inside are
still rotating in their own little space,

01:04:20.540 --> 01:04:23.420
but now they're being kind
of modified by the bitcube.

01:04:23.440 --> 01:04:26.850
And this is the kind of thing which,
you know, I'm not even sure if you could

01:04:26.890 --> 01:04:28.630
do this with the old model,
but it would be a lot of

01:04:28.750 --> 01:04:29.720
math and a lot of pain.

01:04:29.720 --> 01:04:31.220
Okay.

01:04:31.220 --> 01:04:34.460
So now let's look at the particle system.

01:04:37.400 --> 01:04:40.520
So this is a pretty
simple particle system.

01:04:40.520 --> 01:04:41.520
It has three objects.

01:04:41.520 --> 01:04:45.000
It has an emitter layer, a cell,
which is emitting the

01:04:45.000 --> 01:04:47.210
first big blobby spark.

01:04:47.230 --> 01:04:51.510
And then that also has a subcell,
which is emitting the spark,

01:04:51.510 --> 01:04:54.230
the little shower of fireworks.

01:04:54.530 --> 01:04:59.600
And so we do something where we play with
the timing of the subcell so that it only

01:04:59.700 --> 01:05:03.190
fires for a very brief period of time,
when the other one gets

01:05:03.240 --> 01:05:04.100
to a certain point.

01:05:04.100 --> 01:05:07.540
And then there's this big kind of shower,
because we set the emission rate,

01:05:07.540 --> 01:05:11.780
which is the thing that controls how
many particles are emitted per second,

01:05:11.780 --> 01:05:14.400
to some big value.

01:05:14.430 --> 01:05:20.500
So if I highlight the layer here,
you can see that the emitter

01:05:20.500 --> 01:05:22.220
layer is not clipping right now.

01:05:22.220 --> 01:05:24.180
But we can turn that on if we want.

01:05:24.280 --> 01:05:29.240
So now the emitter is
clipping its boundaries.

01:05:29.240 --> 01:05:31.840
And as I said,
it's being flattened into 2D space.

01:05:31.840 --> 01:05:33.600
So you can see it really
is acting like a plane.

01:05:36.820 --> 01:05:39.260
So,
it's kind of more fun though if I turn

01:05:39.280 --> 01:05:42.340
off the clipping and turn on the 3D.

01:05:42.340 --> 01:05:44.200
And that doesn't really do
anything now because we're face-on,

01:05:44.250 --> 01:05:50.270
but you can see when I start to rotate
this thing that now we have a kind of a

01:05:50.270 --> 01:05:57.720
3D kind of particle thing going on here.

01:05:57.720 --> 01:05:57.720
And I guess I can also
animate this thing.

01:05:57.850 --> 01:06:00.240
So, I mean, like I said,
this is very little amount of code,

01:06:00.240 --> 01:06:03.340
and we have these kind of nice
effects going on with nice,

01:06:03.340 --> 01:06:04.240
lots of smooth animation.

01:06:07.500 --> 01:06:10.270
So one other example of these,
which is basically the same demo app,

01:06:10.270 --> 01:06:15.500
so don't expect anything new,
is another kind of particle system.

01:06:15.500 --> 01:06:19.400
Again,
we have this kind of rotation feature.

01:06:19.900 --> 01:06:31.900
[Transcript missing]

01:06:32.630 --> 01:06:56.940
So I guess one other thing
worth mentioning is I'm doing

01:06:56.940 --> 01:06:56.940
this kind of pausing thing.

01:06:56.940 --> 01:06:56.940
And that's basically done with a timing
model where when I'm starting to scrub,

01:06:56.940 --> 01:06:56.940
I'm just setting the time,
the speed of the emission layer to

01:06:56.940 --> 01:06:56.940
be zero and changing the time offset
to clamp me to my current point

01:06:56.940 --> 01:06:56.940
as I tried to describe earlier.

01:06:56.940 --> 01:06:56.940
So it's kind of a nice effect.

01:06:56.940 --> 01:06:56.940
Okay, so...

01:07:04.900 --> 01:07:08.190
So with that, I think we're about done.

01:07:08.220 --> 01:07:11.020
Tomorrow, there's another
Core Animation related session,

01:07:11.050 --> 01:07:13.240
which is Troy's
layer-backed view session,

01:07:13.240 --> 01:07:16.320
which has a lot of NSV type stuff,
but also a lot of just

01:07:16.440 --> 01:07:18.560
general Core Animation things.

01:07:18.560 --> 01:07:19.650
So you should definitely go to that.

01:07:19.880 --> 01:07:26.080
Finally,
we're going to have a lab after this,

01:07:26.080 --> 01:07:26.080
which I guess is downstairs
in the graphics lab.
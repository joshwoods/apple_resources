WEBVTT

00:00:20.310 --> 00:00:22.090
So the lights are up
and the music is down,

00:00:22.090 --> 00:00:24.470
and I think that's my cue to get started.

00:00:24.840 --> 00:00:27.970
So this is session 922,
Creating Efficient

00:00:28.020 --> 00:00:30.150
Data Models with Core Data.

00:00:30.210 --> 00:00:31.120
I'm Melissa Turner.

00:00:31.120 --> 00:00:34.120
I'm one of the software
engineers on the Core Data team,

00:00:34.130 --> 00:00:38.180
and I'm here to tell you all about how
to make your data models nice and shiny.

00:00:38.580 --> 00:00:40.440
During this session,
we're going to do an overview

00:00:40.480 --> 00:00:43.120
of some of the basics,
both of Core Data modeling and

00:00:43.120 --> 00:00:44.980
relational databases in general.

00:00:45.050 --> 00:00:47.580
We're going to walk through a
fairly extensive modeling example,

00:00:47.590 --> 00:00:51.440
show you how to take a data set
and put it into a database schema.

00:00:51.710 --> 00:00:53.820
We're going to talk a little bit
about some performance issues

00:00:53.870 --> 00:00:57.530
that come up when you've got a lot
of data that you need to manage,

00:00:58.000 --> 00:01:00.180
and go through a couple of tricks
that will help you do some debugging

00:01:00.180 --> 00:01:03.220
on your application once you've
got something that you think you

00:01:03.220 --> 00:01:06.590
want to try turning into a real app.

00:01:09.220 --> 00:01:13.380
So Core Data, well,
it's technology that has some

00:01:13.480 --> 00:01:15.980
very old roots and really,

00:01:16.320 --> 00:01:18.120
We have multiple stores in Core Data.

00:01:18.120 --> 00:01:20.780
We have an XML store,
we have a binary store,

00:01:20.890 --> 00:01:23.900
we support your custom atomic stores.

00:01:23.930 --> 00:01:26.780
But conceptually, really,
Core Data was designed to work

00:01:26.780 --> 00:01:28.340
around a relational database.

00:01:28.530 --> 00:01:30.100
We've made it work with
all of the other stores,

00:01:30.100 --> 00:01:32.260
and it works really
well with all of them.

00:01:32.310 --> 00:01:37.900
But some of the core concepts,
the entity description,

00:01:37.900 --> 00:01:40.100
the property descriptions,
these are from the relational

00:01:40.100 --> 00:01:40.100
data modeling world.

00:01:40.130 --> 00:01:43.380
Core Data takes care of doing
all of the infrastructure work,

00:01:43.430 --> 00:01:45.940
putting stuff into databases,
pulling stuff out, keeping track,

00:01:45.970 --> 00:01:47.180
managing relationships.

00:01:47.180 --> 00:01:51.330
But there's no way for us to
take away the fact that in

00:01:51.330 --> 00:01:55.590
order to do a good model design,
you need to have some awareness

00:01:55.590 --> 00:01:58.900
of the underlying technology
you're working with and how to

00:01:58.950 --> 00:02:01.730
most efficiently make that work.

00:02:02.520 --> 00:02:04.420
And the techniques are
useful across all stores.

00:02:04.420 --> 00:02:08.140
Just because I'm talking about
something that's in all of my

00:02:08.220 --> 00:02:11.740
examples using a SQLite store,
and we're looking at tables

00:02:11.740 --> 00:02:14.430
in a SQLite database,
there's no reason those

00:02:14.430 --> 00:02:18.300
wouldn't also apply to an XML or
binary or an in-memory store.

00:02:18.300 --> 00:02:22.230
A lot of the same performance
hurdles are in those other stores.

00:02:25.220 --> 00:02:26.100
Data modeling basics.

00:02:26.100 --> 00:02:27.580
What is data modeling?

00:02:27.630 --> 00:02:31.970
It's the art of taking a large blob
of conceptual data and fiddling it

00:02:32.030 --> 00:02:36.450
and tweaking it and turning it into
something that's nice and efficient

00:02:36.550 --> 00:02:41.840
and can be used to make an application
that's as optimized and quick and

00:02:41.840 --> 00:02:44.680
responsive as your user wants it to be.

00:02:45.660 --> 00:02:47.490
If you've got a bad data model,
that can really hurt

00:02:47.580 --> 00:02:48.440
database performance.

00:02:48.440 --> 00:02:51.120
If you've got a good one,
or your application performance,

00:02:51.200 --> 00:02:53.480
simply because you're spending
a lot of time doing things you

00:02:53.500 --> 00:02:54.800
really don't need to be doing.

00:02:54.870 --> 00:02:58.680
Likewise, or inversely,
it can also really help your application

00:02:58.800 --> 00:03:02.490
performance when you've got your
schema laid out as neatly as you can.

00:03:03.510 --> 00:03:07.730
Your data model is going to
be heavily influenced by your

00:03:07.730 --> 00:03:09.940
interface and vice versa.

00:03:09.940 --> 00:03:13.470
One of the primary mistakes a lot
of people make is to go off and

00:03:13.560 --> 00:03:17.600
do a lot of design at the database
level without ever really thinking

00:03:17.600 --> 00:03:20.070
about the application that they're
going to be putting on top of it.

00:03:21.040 --> 00:03:24.480
A canonical example of this,
for those of you who are familiar

00:03:24.500 --> 00:03:27.500
with the Microsoft world,
is the kitchen sink window

00:03:27.500 --> 00:03:29.230
that has everything on it.

00:03:29.430 --> 00:03:32.740
Well, one, that's really hard for the
developer or the end user to

00:03:33.020 --> 00:03:36.360
figure out what they're supposed
to be focused on in any one place.

00:03:36.540 --> 00:03:39.870
And two, it means you have to haul all of
that data out of the database and

00:03:40.010 --> 00:03:43.600
put it there in front of the user
who doesn't need 90% of it when

00:03:43.610 --> 00:03:46.250
they're looking at that window.

00:03:46.570 --> 00:03:50.590
There's two core techniques used
when you're doing data modeling.

00:03:50.740 --> 00:03:53.780
There's normalization,
which is all about pushing data out,

00:03:53.940 --> 00:03:57.320
and there's denormalization,
which is all about pulling data in.

00:03:57.320 --> 00:04:01.280
And we'll go into those
in a bit more depth later.

00:04:02.400 --> 00:04:05.540
As for relational databases,
this is pretty much all you

00:04:05.540 --> 00:04:07.240
need to know about them.

00:04:07.250 --> 00:04:09.680
Relational databases are tables.

00:04:09.730 --> 00:04:12.760
They're collections of tables
containing information.

00:04:12.900 --> 00:04:16.960
Each table represents one entity,
or as we'll see later,

00:04:17.030 --> 00:04:18.780
it can possibly represent
multiple entities.

00:04:18.780 --> 00:04:23.240
Each column represents an
attribute on that entity,

00:04:23.240 --> 00:04:27.720
and each row represents a
single instance of an object.

00:04:27.720 --> 00:04:30.420
In the Core Data case,
each row would represent

00:04:30.420 --> 00:04:31.760
one managed object.

00:04:34.410 --> 00:04:36.710
That's really all you need
to know about Core Data,

00:04:36.950 --> 00:04:39.770
data modeling,
and databases in order to get

00:04:39.770 --> 00:04:41.590
some use out of this session.

00:04:42.000 --> 00:04:46.390
Up front, I'm going to say this:
There are many right answers.

00:04:46.480 --> 00:04:47.400
What does this mean?

00:04:47.480 --> 00:04:50.760
Well,
it means that for any given data set,

00:04:50.810 --> 00:04:55.200
there's multiple different applications
that can be used and built to handle

00:04:55.200 --> 00:04:58.320
and model and manage that data set.

00:04:58.380 --> 00:05:01.230
And for each and every single
one of those applications,

00:05:01.230 --> 00:05:03.880
the schema may need to be
a little bit different.

00:05:04.260 --> 00:05:08.780
You may build an iTunes application
that's focused on managing songs.

00:05:09.070 --> 00:05:12.700
You may build one that's
focused on managing albums.

00:05:12.810 --> 00:05:18.790
Somebody back there may build one
that's focused on managing artists.

00:05:18.790 --> 00:05:18.790
And all of these

00:05:19.100 --> 00:05:22.840
has subtle implications as to what
your schema needs to look like,

00:05:23.020 --> 00:05:25.400
where the primary entities
in your schema are,

00:05:25.400 --> 00:05:28.270
and what the relationships
off them need to be.

00:05:29.470 --> 00:05:31.290
As in so many things,
there's probably a few of you

00:05:31.290 --> 00:05:33.300
in the audience who are familiar
with data modeling going,

00:05:33.450 --> 00:05:38.520
"But, but, but!" Because there's always
the theory and practice bridge.

00:05:38.590 --> 00:05:41.980
In theory,
there is actually one perfect model:

00:05:42.000 --> 00:05:46.360
purely normalized, shiny, clean,
and completely and utterly

00:05:46.360 --> 00:05:49.810
inefficient because every
single table has one column.

00:05:50.610 --> 00:05:53.280
And frankly, this means that every single
window you want to load is

00:05:53.280 --> 00:05:57.210
going to be a 15-way join,
and that's slow.

00:05:59.960 --> 00:06:03.660
The optimal model is clean
and purely normalized.

00:06:03.730 --> 00:06:06.720
Normalization is the only strategy
you'll ever hear about in a lot

00:06:06.720 --> 00:06:10.410
of relational data modeling books,
and you can forget that.

00:06:10.630 --> 00:06:13.260
Really, honestly,
denormalization is where it's at.

00:06:13.300 --> 00:06:14.260
It's the useful thing.

00:06:14.260 --> 00:06:16.400
It's bringing information
back to where you want it.

00:06:18.000 --> 00:06:19.380
There's always a tension.

00:06:19.380 --> 00:06:21.700
Normalization, denormalization.

00:06:21.700 --> 00:06:24.140
There's a lot of tensions in data
modeling and in coding in general,

00:06:24.140 --> 00:06:25.390
I'm sure you're familiar with.

00:06:25.490 --> 00:06:28.690
You want to do one thing for efficiency,
and another thing also

00:06:28.720 --> 00:06:31.140
has a call on efficiency,
and you have to decide

00:06:31.140 --> 00:06:32.760
which one is right for you.

00:06:35.560 --> 00:06:36.500
Some rules of thumb.

00:06:36.500 --> 00:06:38.330
Design with your interface in mind.

00:06:38.580 --> 00:06:42.850
Start building your data model.

00:06:43.320 --> 00:06:46.610
What is the main window
in your application?

00:06:46.680 --> 00:06:49.220
What data do you want to see there?

00:06:49.320 --> 00:06:51.240
Put that down in an entity.

00:06:51.330 --> 00:06:53.150
And then build out from there.

00:06:53.150 --> 00:06:56.120
Minimize duplication of
data as much as you can.

00:06:56.120 --> 00:06:57.900
That's where normalization comes in.

00:06:57.900 --> 00:07:01.160
It's all about minimizing
duplication of data for saving space,

00:07:01.160 --> 00:07:03.530
for preserving data integrity.

00:07:03.530 --> 00:07:06.070
You want to maximize locality data.

00:07:06.070 --> 00:07:08.240
That's where denormalization comes in.

00:07:08.240 --> 00:07:10.920
You've got more duplicated data,
more risk,

00:07:11.270 --> 00:07:12.320
but sometimes it can be faster.

00:07:16.060 --> 00:07:21.120
So, as some of you might have guessed,
because I used it as an example earlier,

00:07:21.120 --> 00:07:25.710
we're going to work through our
example using a data set involving

00:07:25.710 --> 00:07:28.330
a lot of information about songs.

00:07:28.610 --> 00:07:32.120
Songs ripped out of my
personal iTunes library,

00:07:32.120 --> 00:07:33.080
actually.

00:07:33.090 --> 00:07:35.510
So, no criticism of my taste.

00:07:36.750 --> 00:07:40.770
As a first pass, because I'm building an
application to manage songs,

00:07:40.860 --> 00:07:42.700
this is the root entity
I've come up with.

00:07:42.710 --> 00:07:45.000
I thought,
I want a window that can manage songs,

00:07:45.000 --> 00:07:47.830
so I'm going to stick
everything on one entity.

00:07:50.070 --> 00:07:51.420
What's that going to look
like in the database?

00:07:51.510 --> 00:07:53.970
Because a lot of data modeling
starts to make a lot more sense

00:07:54.170 --> 00:07:56.540
when you think about what the
tables are going to look like,

00:07:56.690 --> 00:07:59.760
what the information in
those tables is going to be.

00:07:59.870 --> 00:08:02.340
So our root table is going to be songs.

00:08:02.410 --> 00:08:06.510
I've added a few fields,
added a few attributes: albums, artists,

00:08:06.510 --> 00:08:07.980
titles, song data.

00:08:08.370 --> 00:08:12.220
And the first thing I'd like you
to see when you look at this is

00:08:12.220 --> 00:08:14.300
the stuff down in this corner here.

00:08:14.370 --> 00:08:18.540
What you'll notice is that I've got
multivalued entries in these tables.

00:08:18.630 --> 00:08:22.630
I've got multiple songs
and multiple song data.

00:08:23.070 --> 00:08:25.280
If you ever see this in
a relational database,

00:08:25.310 --> 00:08:28.500
it's generally a sign that
somebody has done something wrong.

00:08:29.070 --> 00:08:32.570
Multivalues are generally a
bad idea because relational

00:08:32.620 --> 00:08:35.400
databases are all about searching.

00:08:35.460 --> 00:08:38.370
They're about being able
to find field values very,

00:08:38.370 --> 00:08:39.400
very quickly.

00:08:39.460 --> 00:08:42.630
And by shoving multiple
values into a single field,

00:08:42.630 --> 00:08:44.350
you interfere with that.

00:08:44.600 --> 00:08:49.500
Every time I want to look for the
song "Vow" off the album "Garbage,"

00:08:49.500 --> 00:08:54.000
I'm going to have to go off and do a
substring search in that title field.

00:08:54.140 --> 00:08:57.000
And that's going to slow
things down for no good reason.

00:08:57.070 --> 00:09:01.710
So I'm going to put, as my first step,
all of those in separate rows.

00:09:03.120 --> 00:09:05.900
Now I've got another problem,
which is this block down here.

00:09:06.180 --> 00:09:09.370
And this should be one of your first
instincts whenever you're looking

00:09:09.370 --> 00:09:11.700
at a table in a relational database.

00:09:12.790 --> 00:09:17.410
If you ever see duplicate data,
this is a cue that there

00:09:17.410 --> 00:09:19.700
may be room to normalize.

00:09:19.780 --> 00:09:22.240
Get rid of duplicate information.

00:09:22.370 --> 00:09:23.260
Why do you want to do this?

00:09:23.440 --> 00:09:26.600
Well,
the first and most obvious reason is,

00:09:26.600 --> 00:09:28.460
well, it saves on space.

00:09:28.600 --> 00:09:31.640
Every time I duplicate that string,
I've got another copy of it

00:09:31.640 --> 00:09:33.260
sitting down in the database.

00:09:33.260 --> 00:09:36.950
I've got another copy of it pulled
up into the Core Data object layer.

00:09:37.120 --> 00:09:40.980
For, you know, the string garbage,
that may not be important,

00:09:41.090 --> 00:09:43.900
but if I've got the
entire text of my thesis,

00:09:43.910 --> 00:09:47.390
that becomes more of a problem
if it's in 10 different places,

00:09:47.390 --> 00:09:49.040
20 different places.

00:09:49.050 --> 00:09:50.820
There's also a data integrity issue.

00:09:50.880 --> 00:09:52.900
And what do I mean by that?

00:09:53.070 --> 00:09:59.910
Well, if I've got,
in the case of my example, garbage in

00:10:00.140 --> 00:10:19.370
I'm going to show you how to do that.

00:10:19.370 --> 00:10:20.380
I'm going to show you how
to do that in a few minutes.

00:10:20.380 --> 00:10:20.380
I'm going to show you how
to do that in a few minutes.

00:10:20.610 --> 00:10:22.610
You'll think, "Yeah,
why would that happen?" Well,

00:10:22.610 --> 00:10:24.810
iTunes is actually a
great example for this.

00:10:25.040 --> 00:10:29.680
There's a certain subset of people
who like to go off and fill CDDB with

00:10:29.680 --> 00:10:31.950
random garbage just for fun.

00:10:33.140 --> 00:10:36.600
So if I download some
corrupt data from CDDB,

00:10:36.600 --> 00:10:38.750
I'm going to have to go off
and change it everywhere.

00:10:39.040 --> 00:10:40.900
That's not a huge issue with
a model the size of the one

00:10:40.900 --> 00:10:42.980
we're going to be talking about,
but most models really

00:10:42.980 --> 00:10:45.140
have more than two,
three, four entities.

00:10:45.140 --> 00:10:48.380
Some of them get up to 50, 100,
200 entities.

00:10:48.440 --> 00:10:52.550
And it can be hard to track where all of
that duplicate information is unless you

00:10:52.550 --> 00:10:55.020
normalize it out and keep it in one spot.

00:10:55.090 --> 00:10:56.250
So how do you do that?

00:10:56.310 --> 00:10:57.300
What does that really mean?

00:10:57.350 --> 00:11:01.190
Well, it means you make a separate table.

00:11:02.600 --> 00:11:05.420
And get rid of all the duplicates.

00:11:05.810 --> 00:11:07.200
But at this point,
you're probably thinking,

00:11:07.260 --> 00:11:09.920
but you've lost something there.

00:11:09.980 --> 00:11:12.150
The previous table,
it was very easy to tell

00:11:12.700 --> 00:11:15.790
what artist and what song,
or what artist and what

00:11:15.790 --> 00:11:17.650
album a given song was from.

00:11:17.770 --> 00:11:22.210
You'd just follow across the row,
and there it was.

00:11:22.480 --> 00:11:24.960
But we've lost that
relationship information here.

00:11:25.010 --> 00:11:27.090
It doesn't exist anymore.

00:11:27.200 --> 00:11:29.370
So how do we get that back?

00:11:29.900 --> 00:12:32.200
[Transcript missing]

00:12:32.530 --> 00:12:35.670
Pessimal choices would be strings,
because you've got a number of,

00:12:35.670 --> 00:12:38.710
there's actually a number of
reasons for which strings are bad.

00:12:38.830 --> 00:12:43.960
You've got representation issues, EBCD,
ASCII, you've got Unicode issues,

00:12:43.960 --> 00:12:45.260
normalization issues.

00:12:45.260 --> 00:12:48.780
Floats are bad because, well,
they've also got representation issues.

00:12:48.860 --> 00:12:51.280
And byte arrays, well,
they have some of the same problems

00:12:51.280 --> 00:12:54.300
with strings where you have to compare
every single byte in the string to

00:12:54.300 --> 00:12:56.260
determine if two byte arrays are equal.

00:12:57.480 --> 00:13:02.070
We will laugh at you if you basically
send us a problem and are doing this,

00:13:02.070 --> 00:13:04.640
and not in a Core Data app,
but in a non-Core Data app.

00:13:04.880 --> 00:13:08.830
Don't pick database internal values that
are not guaranteed to remain the same.

00:13:08.860 --> 00:13:10.220
Seriously.

00:13:10.220 --> 00:13:13.210
Because your relationships will
all get messed up for reasons

00:13:13.260 --> 00:13:14.860
you're about to understand.

00:13:14.860 --> 00:13:18.080
Relationships in a
relational database are,

00:13:18.080 --> 00:13:24.220
describe the link between two tables,
and they're basically, they're key-based.

00:13:24.220 --> 00:13:27.460
You take a primary key from one
table and insert it into a database.

00:13:27.460 --> 00:13:30.850
You can imagine if the primary
key on one table got changed

00:13:30.850 --> 00:13:34.880
because your database went off and
did something behind your back,

00:13:34.880 --> 00:13:37.640
all of your relationships
are now messed up.

00:13:37.640 --> 00:13:38.800
Don't do that.

00:13:42.130 --> 00:13:43.370
So how do we use keys?

00:13:43.680 --> 00:13:44.600
How do keys really work?

00:13:44.780 --> 00:13:49.600
Well, I need to put a primary
key on one of these tables.

00:13:49.610 --> 00:13:52.330
In this case,
I'm going to put it on the albums table,

00:13:52.380 --> 00:13:55.100
because there's one album
can have many songs,

00:13:55.290 --> 00:13:57.280
and it's easier to do it that way.

00:13:57.480 --> 00:14:02.730
So we'll just assign an integer,
one per row on the table.

00:14:03.150 --> 00:14:06.560
And we'll assign a foreign key
column over in the other table,

00:14:06.640 --> 00:14:09.610
call it Album,
and enter the primary key of

00:14:09.750 --> 00:14:12.030
the album that each song is on.

00:14:12.030 --> 00:14:17.500
And this way I can go from Album
5 over to the songs table and say,

00:14:17.600 --> 00:14:20.680
which songs are on Album 5,
and find those very easily.

00:14:20.680 --> 00:14:24.020
So that's a relationship
in a relational database.

00:14:25.020 --> 00:14:29.260
And having said all of that,
you can mostly forget about it because

00:14:29.380 --> 00:14:31.020
Core Data does all of this for you.

00:14:31.020 --> 00:14:34.420
We assign primary keys,
we do all of your foreign key handling,

00:14:34.420 --> 00:14:37.830
all of your relationship management,
updates, inserts,

00:14:37.830 --> 00:14:39.760
we clean it up if you do deletes.

00:14:39.760 --> 00:14:43.840
For those of you who are familiar with
printing out Core Data objects in GDB,

00:14:43.840 --> 00:14:47.110
you've probably seen how our
relationships are represented

00:14:47.110 --> 00:14:48.560
by NS Managed Objects.

00:14:48.760 --> 00:14:50.630
You've got a fault and
it has a relationship,

00:14:50.650 --> 00:14:52.650
it's just got a UID,
and that's the UID of the

00:14:52.650 --> 00:14:53.990
object at the other end.

00:14:54.020 --> 00:14:55.890
the relationship.

00:14:58.800 --> 00:15:00.430
So, where are we now?

00:15:00.630 --> 00:15:02.510
We had this originally.

00:15:02.670 --> 00:15:05.290
This was our original entity.

00:15:05.490 --> 00:15:06.650
We've turned it into this.

00:15:06.900 --> 00:15:08.970
Now we've got two entities and
a relationship between them.

00:15:08.990 --> 00:15:12.430
You can see the relationship here has

00:15:12.700 --> 00:15:15.590
One arrow on one end and
two arrows on the other end.

00:15:15.590 --> 00:15:19.180
That's the way of specifying that
it's a one-to-many relationship.

00:15:20.900 --> 00:15:21.800
So what next?

00:15:21.800 --> 00:15:23.980
Where are we going next?

00:15:24.010 --> 00:15:28.710
Well,
I said when we first started this up,

00:15:28.710 --> 00:15:29.820
started

00:15:31.670 --> 00:15:33.600
The duplicate data was a bad thing.

00:15:33.620 --> 00:15:37.120
It was always a cue that you wanted
to look at whatever it was you had

00:15:37.120 --> 00:15:39.600
and contemplate normalizing it.

00:15:39.740 --> 00:15:42.150
And we have more duplicate data here.

00:15:42.520 --> 00:15:45.040
This is where I talk about identity.

00:15:45.160 --> 00:15:48.320
Duplicate data is really only
bad if it truly is duplicate.

00:15:48.320 --> 00:15:51.240
It's two copies of the
same piece of information.

00:15:51.330 --> 00:15:53.590
But some information
is duplicate because,

00:15:53.590 --> 00:15:56.560
well, there's two copies of
different information that

00:15:56.560 --> 00:15:58.330
are coincidentally the same.

00:15:58.780 --> 00:16:00.750
For example,
it looks like I have two songs

00:16:00.750 --> 00:16:02.500
here whose title is Dare.

00:16:02.590 --> 00:16:05.500
But if I go off to Amazon.com
and do a little bit of research,

00:16:05.530 --> 00:16:08.840
I'll find out that one of these,
the one that's off the album D-side,

00:16:08.930 --> 00:16:11.620
is actually Dare Remix.

00:16:12.090 --> 00:16:15.700
Now, changing that, correcting it,
doesn't automatically imply that

00:16:15.920 --> 00:16:17.540
I need to correct the other one.

00:16:17.720 --> 00:16:22.000
They're actually two separate,
identity separate, pieces of information.

00:16:22.000 --> 00:16:24.900
And if you have that kind of a case
where you have information that's

00:16:24.900 --> 00:16:28.030
sort of coincidentally the same,
that's not usually the best

00:16:28.050 --> 00:16:29.640
case for normalization.

00:16:29.770 --> 00:16:32.320
So we're just going to
leave that the way it is.

00:16:32.430 --> 00:16:37.720
But there's other interesting
stuff in this table,

00:16:37.720 --> 00:16:37.720
and that would be this column.

00:16:39.400 --> 00:16:41.270
It looks kind of obscure
to you when you look at it,

00:16:41.270 --> 00:16:43.400
because, well, it's just a blob.

00:16:43.400 --> 00:16:48.290
It's actually the beginning of
the MP3 that is the song data.

00:16:50.250 --> 00:16:51.040
Why is that interesting?

00:16:51.040 --> 00:16:53.670
Well,
because when I think of my interface,

00:16:53.670 --> 00:16:56.660
my songs interface
that I want to display,

00:16:56.920 --> 00:16:59.800
It's not necessary for that interface.

00:16:59.870 --> 00:17:04.620
I don't need to load the MP3 data for
a song in order to show somebody that

00:17:04.630 --> 00:17:06.970
they have that song in their library.

00:17:08.510 --> 00:17:11.400
It's an excellent thing to break out.

00:17:11.570 --> 00:17:13.790
This is some other cues for
when you want a normalization.

00:17:13.890 --> 00:17:17.680
Duplicates or to push out
extra or expensive information.

00:17:17.790 --> 00:17:20.760
It will be data that's not
used in the main interface or

00:17:20.840 --> 00:17:22.660
in a lot of cases blob data.

00:17:22.900 --> 00:17:24.530
Especially large blob data.

00:17:24.560 --> 00:17:28.490
What's large blob data?

00:17:28.490 --> 00:17:28.490
Well,

00:17:29.110 --> 00:17:31.520
Small blob data is
something like a color,

00:17:31.520 --> 00:17:33.320
stuff that's down around a K.

00:17:33.350 --> 00:17:36.140
That's actually okay to
have on the main table,

00:17:36.140 --> 00:17:38.860
might be worth considering
pushing it out.

00:17:39.050 --> 00:17:42.780
If you've got a medium-sized blob,
you pretty much always want

00:17:43.080 --> 00:17:47.420
that to be on a separate table,
especially if you don't always need it.

00:17:47.560 --> 00:17:50.320
If you've got a large blob,
which is something over a megabyte,

00:17:50.320 --> 00:17:52.710
there is no good reason to
have that on the main table.

00:17:52.750 --> 00:17:55.390
It's going to interfere
with all of your searching.

00:17:55.390 --> 00:17:57.270
Because when you think about how
a database has to be represented,

00:17:57.350 --> 00:17:58.970
it's going to interfere
with all of your searching.

00:17:59.000 --> 00:18:03.820
Each row is actually
going to be a structure.

00:18:03.830 --> 00:18:05.000
It's going to be a record.

00:18:05.160 --> 00:18:07.420
And in order to look at
any field in that record,

00:18:07.420 --> 00:18:09.890
I'm going to have to
load the entire record.

00:18:10.110 --> 00:18:12.330
And you can see where this is going,
because if I'm going to be

00:18:12.420 --> 00:18:15.370
looking through a lot of different
records in order to find,

00:18:15.370 --> 00:18:18.860
you know, the name of a song,
and I've got the blob that is the

00:18:18.860 --> 00:18:22.520
song data sitting in that record,
I'm actually going to have to

00:18:22.560 --> 00:18:26.110
load all of that song data in
order to look at the song titles.

00:18:26.120 --> 00:18:27.100
Move that out.

00:18:27.320 --> 00:18:28.400
Push that somewhere else.

00:18:28.400 --> 00:18:32.080
Make it easy for me to look at the
titles of my songs by getting all of

00:18:32.080 --> 00:18:35.320
the information that I don't need,
that the user is never

00:18:35.320 --> 00:18:38.140
going to search on,
out of the main table.

00:18:38.680 --> 00:18:40.360
So I'm going to do that.

00:18:40.360 --> 00:18:42.480
We already know how the keys
are going to be set up for this,

00:18:42.480 --> 00:18:45.710
so we don't need to see those.

00:18:46.110 --> 00:18:48.120
Let's have a look at our model now.

00:18:48.380 --> 00:18:50.000
Now we've gone here.

00:18:50.070 --> 00:18:50.810
Song data is out.

00:18:51.030 --> 00:18:54.400
It's now on the destination
of a one-to-one relationship.

00:18:54.400 --> 00:18:57.320
Things are getting cleaner.

00:18:57.960 --> 00:18:59.420
Of course, we're not done yet.

00:18:59.420 --> 00:19:03.010
We have a bunch of other attributes
that I haven't even started to look at.

00:19:04.130 --> 00:19:07.010
Like this column here,
the lyrics for each song.

00:19:07.010 --> 00:19:14.750
Well, there's a few interesting things
to note about this column,

00:19:14.750 --> 00:19:14.750
one of which is that, well,

00:19:14.860 --> 00:19:16.550
A lot of the fields are empty.

00:19:16.570 --> 00:19:18.720
And this brings us to nulls.

00:19:18.790 --> 00:19:21.790
Null in your average
database is undefined.

00:19:21.800 --> 00:19:26.000
It is not equal to
anything except itself,

00:19:26.060 --> 00:19:28.160
and it is not not equal
to anything itself.

00:19:28.300 --> 00:19:30.970
If I try and do a search
that says title in dare,

00:19:30.970 --> 00:19:34.660
dare remix, and null,
your average database is never going

00:19:34.660 --> 00:19:37.320
to return anything for that third hit.

00:19:37.850 --> 00:19:39.960
You have to have to do special
queries to determine whether

00:19:39.960 --> 00:19:41.280
or not something is null.

00:19:41.430 --> 00:19:46.770
So having a null in a column is
really an excellent sign that

00:19:47.560 --> 00:19:51.300
this is a good candidate for
being normalized off the table.

00:19:53.500 --> 00:19:55.300
In this particular case,
I've kind of got a

00:19:55.330 --> 00:19:59.400
special problem because,
well, when I envision the interface that

00:19:59.410 --> 00:20:02.870
I'm putting on my application,
I see I've got, you know,

00:20:03.020 --> 00:20:05.680
the song here and the length here.

00:20:05.680 --> 00:20:08.100
And over here,
I've got a little badge that tells me

00:20:08.100 --> 00:20:09.960
whether or not the song has lyrics.

00:20:09.960 --> 00:20:13.910
So the user can click on
that and see the lyrics.

00:20:15.200 --> 00:20:17.040
If I push that all off
into a separate table,

00:20:17.040 --> 00:20:20.520
I'm going to have to go look at that
other table in order to decide whether

00:20:20.520 --> 00:20:22.230
or not I want to put a badge there.

00:20:22.310 --> 00:20:24.550
This is where denormalization comes in.

00:20:24.730 --> 00:20:27.920
Denormalization is all
about pulling data in,

00:20:27.920 --> 00:20:31.840
duplicating it in some way to
improve my locality of reference.

00:20:31.840 --> 00:20:34.680
So instead of having to go both
to my main table and to a separate

00:20:34.680 --> 00:20:37.780
table to look at lyrics to find out
whether I need to put a badge on,

00:20:37.820 --> 00:20:39.640
I can just look at the main table.

00:20:39.650 --> 00:20:43.280
Some common uses are for flags
or for derived attributes where

00:20:43.280 --> 00:20:47.000
I may want to have multiple
copies for performance reasons.

00:20:47.830 --> 00:20:49.180
So let's do that here.

00:20:49.310 --> 00:20:52.750
Instead of having the lyrics
stored directly on that table,

00:20:52.910 --> 00:20:56.380
I'm going to put just a badge there
saying whether or not there's lyrics,

00:20:56.500 --> 00:21:01.500
and I'm going to have lyrics off in
their entirely separate table like this.

00:21:01.530 --> 00:21:03.220
Gets the best of both worlds.

00:21:03.220 --> 00:21:05.500
I've got the normalization
and move the data.

00:21:05.500 --> 00:21:07.990
I don't particularly need to
search through all the time there.

00:21:08.080 --> 00:21:12.900
And I still have information about
whether there is data or not.

00:21:12.900 --> 00:21:14.780
So where next?

00:21:16.230 --> 00:21:17.560
This is always an interesting thing.

00:21:17.720 --> 00:21:20.960
Text is always interesting.

00:21:20.970 --> 00:21:22.920
Let's go look at our lyrics
table in more detail.

00:21:22.920 --> 00:21:25.900
Let's try and imagine the data
that could be in that table.

00:21:25.930 --> 00:21:28.390
Well, here's the stuff we saw originally.

00:21:28.440 --> 00:21:30.400
But there could be more in there.

00:21:30.690 --> 00:21:32.660
More with interesting characteristics.

00:21:32.740 --> 00:21:35.960
It's not all going to be the
case I'm expecting all the time.

00:21:36.120 --> 00:21:38.840
Some of it may actually
be in foreign languages.

00:21:39.000 --> 00:21:42.370
Why is this important?

00:21:42.370 --> 00:21:42.370
Well,

00:21:42.840 --> 00:21:46.280
For a couple of reasons,
because when your customers search,

00:21:46.280 --> 00:21:48.960
they're going to be searching
in probably all lowercase,

00:21:48.960 --> 00:21:52.890
and they want hits to come back,
whether you're camel case, lowercase,

00:21:52.890 --> 00:21:53.720
uppercase.

00:21:53.730 --> 00:21:55.640
They're not going to have
to want to type in accents.

00:21:55.640 --> 00:21:57.980
They may not know how to type
in accents because they may

00:21:57.980 --> 00:21:59.360
be using an English keyboard.

00:21:59.360 --> 00:22:03.750
And there's other reasons,
like iHeart Unicode.

00:22:06.160 --> 00:22:11.300
There's actually multiple
representations for certain characters.

00:22:11.340 --> 00:22:15.730
E-accent aigu can be represented
both as a single character and as

00:22:15.820 --> 00:22:17.620
a combining mark followed by an E.

00:22:17.680 --> 00:22:20.860
It's a combining accent
aigu followed by an E.

00:22:20.860 --> 00:22:24.660
And if you're doing simple
string matching in a database,

00:22:24.710 --> 00:22:27.600
those are going to compare differently,
even though they represent

00:22:27.710 --> 00:22:28.610
the same character.

00:22:28.670 --> 00:22:30.900
This is especially bad
if you're doing regex,

00:22:30.940 --> 00:22:34.020
because most regex engines are very,
very literal.

00:22:34.090 --> 00:22:37.900
They'll take you at your word if
you say you want single character E.

00:22:38.960 --> 00:22:41.220
So when you're doing searching,
and if you haven't

00:22:41.260 --> 00:22:45.100
pre-canonicalized your database,
you may not get all the hits

00:22:45.200 --> 00:22:48.740
because there may be representation
issues down in the database.

00:22:48.780 --> 00:22:51.350
So something that's usually a really
good idea if you know you're going to

00:22:51.350 --> 00:22:54.770
be searching on string data like this,
is to create a copy of

00:22:54.780 --> 00:22:57.220
it and strip it out,
all of these little

00:22:57.610 --> 00:22:59.540
impurities and annoyances.

00:22:59.580 --> 00:23:05.580
Move it down into a canonical form,
strip out the diacritics, case fold it,

00:23:08.100 --> 00:23:15.650
in one of those lovely
moments in computer science,

00:23:15.650 --> 00:23:15.650
normalize it,
'cause we can always reuse the same

00:23:15.650 --> 00:23:15.650
word for completely different concepts,
right?

00:23:16.510 --> 00:23:21.570
So over here we see a canonicalized text
column that contains the information that

00:23:21.620 --> 00:23:24.340
was in the other table in a form that's
going to be much more easily searchable.

00:23:24.390 --> 00:23:27.030
You're much more quickly
searchable at that.

00:23:27.030 --> 00:23:29.760
Whenever I do the search,
I'm just going to be able to

00:23:29.880 --> 00:23:32.170
strip information out of what
the user's given me and pass that

00:23:32.170 --> 00:23:34.750
directly down to the database,
rather than having to look

00:23:34.750 --> 00:23:37.420
at every individual row,
transform the data there,

00:23:37.420 --> 00:23:38.810
and then do a comparison.

00:23:49.770 --> 00:23:50.190
Because over time that really
builds up as you normalize and

00:23:50.190 --> 00:23:50.190
normalize and normalize and
normalize and normalize those

00:23:50.190 --> 00:23:50.190
strings over and over and over again.

00:23:50.190 --> 00:23:50.190
Just do it once up front,
never do it again.

00:23:51.040 --> 00:23:53.940
So instead of just having
one attribute on our lyrics,

00:23:54.000 --> 00:23:55.000
we're going to have two.

00:23:55.000 --> 00:23:58.480
We're going to have text,
and we're going to have canonical text.

00:24:03.110 --> 00:24:06.020
So now we're going to go off
and look at something else,

00:24:06.020 --> 00:24:07.880
other things that can be interesting.

00:24:07.890 --> 00:24:09.270
Artists.

00:24:09.350 --> 00:24:11.540
Our album has an artist field.

00:24:11.580 --> 00:24:12.690
But what is an artist?

00:24:12.970 --> 00:24:15.350
Let's go look at this table here.

00:24:15.640 --> 00:24:17.480
There's some interesting stuff in here.

00:24:17.490 --> 00:24:23.350
Namely,
we've got some artists who are groups.

00:24:23.420 --> 00:24:26.990
I seem to have completely lost
the thread of my presentation.

00:24:29.040 --> 00:24:30.800
I'm leaping ahead.

00:24:30.870 --> 00:24:34.520
We've got more duplicate data here.

00:24:34.520 --> 00:24:36.920
And we already know what
to do with duplicate data.

00:24:36.980 --> 00:24:40.440
Break it out,
move it into separate tables.

00:24:42.900 --> 00:24:46.800
And I'm going to bring back the
primary and foreign keys at this point,

00:24:46.800 --> 00:24:48.930
because I'm going to show
you how a many-to-many

00:24:48.930 --> 00:24:51.400
relationship works in a database.

00:24:51.400 --> 00:24:56.080
And this is really kind of tricky unless
you can actually see it happening.

00:24:56.900 --> 00:24:59.160
So I've now got my relationship set up.

00:24:59.330 --> 00:25:02.110
One artist, many albums.

00:25:02.930 --> 00:25:04.970
Well,
except my iTunes library at least has

00:25:04.970 --> 00:25:06.880
a lot of stuff that looks like this.

00:25:06.880 --> 00:25:10.720
I mean, the original data set was chosen
specifically to fit on a slide,

00:25:10.830 --> 00:25:13.510
but I've got more room here so
I can bring in some of my art,

00:25:13.510 --> 00:25:14.740
more interesting music.

00:25:14.740 --> 00:25:14.950
Like,

00:25:16.800 --> 00:25:18.800
Albums that have multiple artists.

00:25:18.800 --> 00:25:26.010
But we already saw on the earlier slide
that having multi-values is a bad idea.

00:25:27.750 --> 00:25:28.940
So what do we do?

00:25:28.970 --> 00:25:31.860
Well, we want to split those out,
give it two separate rows.

00:25:31.900 --> 00:25:34.990
One for each artist.

00:25:36.440 --> 00:25:38.980
Now we've got a problem because we
know we need to take our primary

00:25:38.980 --> 00:25:43.710
key and store it in the foreign
key column on a separate table,

00:25:43.900 --> 00:25:48.350
but now we're back to multi-values
because the artist's foreign

00:25:48.350 --> 00:25:49.840
key already has a value there.

00:25:49.840 --> 00:25:53.160
Now what do I do?

00:25:54.910 --> 00:25:58.250
Well,
this is where more primary keys come in.

00:25:58.510 --> 00:25:59.440
Add one to this table.

00:25:59.440 --> 00:26:06.630
Break that artist primary key off,
put it in its own separate table,

00:26:08.120 --> 00:26:09.760
Copy the artist foreign keys over there.

00:26:09.760 --> 00:26:12.480
Copy the album keys here.

00:26:12.480 --> 00:26:14.830
That's how a many-to-many
relationship looks.

00:26:14.920 --> 00:26:18.230
You've actually got three tables at play.

00:26:19.420 --> 00:26:22.320
And you can figure out
which songs are on,

00:26:22.340 --> 00:26:28.550
or which artists put out
which albums by following from

00:26:29.210 --> 00:26:30.040
He's over here.

00:26:30.100 --> 00:26:34.080
From the artist table,
over to the correlation table,

00:26:34.490 --> 00:26:37.990
and off from the correlation
table to the albums.

00:26:40.200 --> 00:26:44.030
So whenever you do a query
in Core Data that goes across

00:26:44.030 --> 00:26:47.430
a many-to-many relationship,
we actually have to write SQL to

00:26:47.430 --> 00:26:49.310
handle this in the background.

00:26:49.400 --> 00:26:52.120
That's going to be a little bit
slower than just looking up an

00:26:52.120 --> 00:26:54.480
attribute on a single table.

00:26:57.720 --> 00:26:58.930
So what have we done now?

00:26:58.940 --> 00:27:01.860
Well, we had our artists,
and now we've broken it

00:27:01.860 --> 00:27:03.790
out into a separate table.

00:27:03.920 --> 00:27:07.300
But like I said earlier,
there's many right answers.

00:27:07.340 --> 00:27:10.140
There's no particular reason
that that's a better way,

00:27:10.170 --> 00:27:13.950
that this here is a better way,
better design of your model,

00:27:13.950 --> 00:27:15.100
than this is.

00:27:15.180 --> 00:27:17.440
In some ways,
this actually makes more sense.

00:27:17.510 --> 00:27:22.970
Artists are more likely to collaborate
on individual songs than they are

00:27:22.970 --> 00:27:22.970
to collaborate on entire albums.

00:27:23.200 --> 00:27:24.950
So like I said, there's a play.

00:27:25.120 --> 00:27:28.710
Depends on how you envision your data,
how you want your users

00:27:28.780 --> 00:27:30.520
to interact with it.

00:27:31.570 --> 00:27:33.830
And now we're back to
where I jumped ahead to.

00:27:33.970 --> 00:27:36.810
But artists are kind of
interesting in another way.

00:27:37.300 --> 00:27:39.990
Because if you look at this table,
you'll see that we've got

00:27:39.990 --> 00:27:41.620
two kinds of artists here.

00:27:41.670 --> 00:27:45.390
We've got groups,
and we've got individuals.

00:27:47.070 --> 00:27:50.680
Individuals tend to have things like
birthdays that groups really don't have,

00:27:50.680 --> 00:27:54.330
although they've got names.

00:27:54.380 --> 00:27:59.770
If you look at groups, well,
they tend to have formation dates and

00:27:59.770 --> 00:28:03.040
members in addition to their names.

00:28:03.160 --> 00:28:05.250
And if you're familiar
with object modeling,

00:28:05.250 --> 00:28:08.580
you've probably immediately thought,
well, I want my object model to

00:28:08.580 --> 00:28:10.030
look something like this.

00:28:11.910 --> 00:28:14.240
I'm going to put the name up
there on my parent entity and

00:28:14.240 --> 00:28:18.550
have two sub-entities come,
or subclasses coming off it.

00:28:19.090 --> 00:28:20.990
This is a pretty good instinct.

00:28:21.000 --> 00:28:24.390
Entity relational modeling can
have inheritance in it as well.

00:28:24.400 --> 00:28:26.570
It's very similar to object inheritance.

00:28:26.640 --> 00:28:30.020
Although something important to notice
is that it does not need to reflect

00:28:30.020 --> 00:28:31.890
your object inheritance hierarchy.

00:28:31.980 --> 00:28:35.690
Just because your objects
in your model in memory are

00:28:35.850 --> 00:28:39.080
in an inheritance hierarchy,
the data in the database does

00:28:39.080 --> 00:28:40.310
not need to be stored that way.

00:28:40.420 --> 00:28:46.640
You can actually have two entirely
separate inheritance hierarchies.

00:28:46.670 --> 00:28:48.420
Core Data,
there's multiple ways to represent

00:28:48.420 --> 00:28:50.690
inheritance in a database,
and Core Data has chosen to

00:28:50.690 --> 00:28:53.540
do single table inheritance,
which means that for given

00:28:53.540 --> 00:28:58.950
inheritance hierarchy,
all of the entities in that hierarchy

00:28:58.950 --> 00:28:58.950
will be stored in a single table.

00:28:59.560 --> 00:29:03.280
This is actually most efficient
for doing searches which could

00:29:03.280 --> 00:29:05.000
potentially return values.

00:29:05.220 --> 00:29:13.090
An invaluable session for developers
new to Core Data and for experienced

00:29:13.090 --> 00:29:13.090
Core Data developers looking
to get the best performance

00:29:13.090 --> 00:29:13.090
out of their application.

00:29:13.090 --> 00:29:13.090
Melissa Turner

00:29:13.820 --> 00:29:16.560
Got my artists,
and let's add those extra fields,

00:29:16.560 --> 00:29:18.900
and let's populate them with some data.

00:29:18.910 --> 00:29:22.240
And immediately you're going to
see something we discussed earlier.

00:29:22.700 --> 00:29:23.860
Nulls.

00:29:23.900 --> 00:29:27.240
We've got empty fields in the database,
up here and down here.

00:29:27.370 --> 00:29:30.820
And in this particular case,
those fields can never have data in them.

00:29:30.830 --> 00:29:33.210
A group is never going
to have a birthday,

00:29:33.270 --> 00:29:36.290
an artist is never going
to have a formation date.

00:29:38.900 --> 00:29:43.720
So nulls are bad and may
lead to normalization,

00:29:43.720 --> 00:29:47.940
but on the other hand,
inheritance works this way.

00:29:47.970 --> 00:29:49.200
Where do you balance it?

00:29:49.220 --> 00:29:53.940
Well, a good way to tell how you
should be balancing it is by

00:29:53.940 --> 00:29:58.900
looking at how your entities,
how your instances are going

00:29:58.900 --> 00:30:00.490
to be used in your model.

00:30:00.520 --> 00:30:03.360
In this particular case,
I've got the artist's relationship,

00:30:03.390 --> 00:30:07.080
which is going to want to return
a heterogeneous collection.

00:30:07.550 --> 00:30:11.360
Artist is going to want to return
both songs and individuals.

00:30:11.390 --> 00:30:14.340
I'm not going to need
to care or want to care.

00:30:14.670 --> 00:30:22.080
I'm going to go ahead and add that
inheritance hierarchy to my model.

00:30:23.090 --> 00:30:25.120
But, you know,
there's potential for other things

00:30:25.140 --> 00:30:29.070
that could have shared information,
like I could go through and add a

00:30:29.070 --> 00:30:32.420
notes field to all of my entities.

00:30:32.480 --> 00:30:33.990
And, well, it's a notes field.

00:30:34.010 --> 00:30:37.050
It's going to be serving the
exact same purpose in every

00:30:37.050 --> 00:30:39.380
single one of those entities.

00:30:39.940 --> 00:30:42.890
But really,
it doesn't make sense because apart

00:30:42.990 --> 00:30:46.320
from the fact that it's notes,
it's called notes.

00:30:46.370 --> 00:30:50.720
There's no shared behavior or
shared real state across all of

00:30:50.720 --> 00:30:53.490
the disparate entities in my model.

00:30:53.560 --> 00:30:56.900
And most importantly,
there's no place in the model where

00:30:56.900 --> 00:31:01.720
it's important to return instances of
all of those entities at the same time.

00:31:02.880 --> 00:31:06.200
So I'm just going to leave these
and leave with a final thought,

00:31:06.200 --> 00:31:09.870
which is that if you ever realize that
you've built a model where everything

00:31:09.870 --> 00:31:12.240
is in one inheritance hierarchy,
that means you're putting all

00:31:12.240 --> 00:31:13.340
of your data in a single table.

00:31:13.340 --> 00:31:15.320
And that means you've
probably done something wrong,

00:31:15.410 --> 00:31:17.840
unless you've only got one entity,
if you've only got one table.

00:31:20.900 --> 00:31:22.400
That's not good.

00:31:22.400 --> 00:31:24.820
So that actually covers most
of what you need to know,

00:31:24.820 --> 00:31:26.730
the basics of data modeling.

00:31:26.960 --> 00:31:30.370
From here on in,
it becomes just a lot of trial and error

00:31:30.370 --> 00:31:33.830
and trying to develop instincts for,
you know, what's good,

00:31:33.850 --> 00:31:36.000
what's not so good,
when you need to use normalization,

00:31:36.000 --> 00:31:39.440
when you need to use denormalization,
and how to best balance the

00:31:39.560 --> 00:31:41.710
competing needs for your application.

00:31:41.710 --> 00:31:47.390
There's a few other things that
are down in the database layer

00:31:47.390 --> 00:31:47.390
that we're going to talk about.

00:31:47.850 --> 00:31:49.750
First of which is indices.

00:31:49.760 --> 00:31:51.560
An index,
as you might guess from the name,

00:31:51.560 --> 00:31:54.250
is a quick way to look up information.

00:31:54.480 --> 00:31:57.720
Sort of like an index in a book.

00:31:57.860 --> 00:32:00.820
Tradeoffs with setting up --
you set up an index either on a

00:32:00.820 --> 00:32:02.920
column or a collection of columns.

00:32:02.950 --> 00:32:07.560
And you can -- from the index,
you can basically look at a value,

00:32:07.560 --> 00:32:10.400
find a value in that,
and quickly move to the row in the

00:32:10.400 --> 00:32:13.000
table that's associated with that value.

00:32:13.000 --> 00:32:18.900
There's tradeoffs,
both in speed and in space.

00:32:18.900 --> 00:32:18.900
The first tradeoff is that

00:32:19.430 --> 00:32:20.490
Indexes aren't free.

00:32:20.710 --> 00:32:24.840
You have to actually maintain them
when you change data in the table.

00:32:24.990 --> 00:32:30.990
It's no good if my index
contains stale information.

00:32:31.080 --> 00:32:33.040
So every time I change
a row in the table,

00:32:33.040 --> 00:32:36.200
every time I add a row,
every time I delete a row,

00:32:36.250 --> 00:32:39.360
I'm going to have to go
off and update the index.

00:32:39.430 --> 00:32:45.900
If I've got an application
that's used 95% of the time for

00:32:45.900 --> 00:32:47.040
writing data to the database,

00:32:48.200 --> 00:32:49.460
I don't need an index.

00:32:49.460 --> 00:32:54.440
I probably don't want to spend the
time updating my indexes regularly.

00:32:54.440 --> 00:32:56.360
And there's also a size tradeoff.

00:32:56.360 --> 00:32:58.400
Indexes don't come for free space-wise.

00:32:58.410 --> 00:33:00.440
I need to store them somewhere,
and that's on disk.

00:33:00.440 --> 00:33:02.480
It's going to increase
the size of your database.

00:33:02.480 --> 00:33:05.910
If I've got an application that's
being used 95% of the time to

00:33:05.910 --> 00:33:09.500
do reads and the customer is
constantly querying and searching on,

00:33:09.500 --> 00:33:11.620
that may be a worthwhile tradeoff.

00:33:11.630 --> 00:33:13.070
It probably is a worthwhile tradeoff.

00:33:13.180 --> 00:33:15.600
It will really speed
up their data access,

00:33:15.600 --> 00:33:17.280
but it will increase
the size of your file.

00:33:17.280 --> 00:33:23.780
So, again, you have the tension.

00:33:23.780 --> 00:33:23.780
Size, speed, customer performance.

00:33:24.110 --> 00:33:27.180
One thing to note in SQLite is
that the indices are binary only,

00:33:27.180 --> 00:33:29.960
so you don't get fancy substring
searching or text comparisons.

00:33:29.960 --> 00:33:33.470
It's going to be purely equal to,
greater than, or less than.

00:33:35.450 --> 00:33:38.370
How do you decide or how do you
tell Core Data that you want an

00:33:38.370 --> 00:33:40.080
index on a particular column?

00:33:40.100 --> 00:33:45.800
Well, in the modeling tool,
it's up here in the model inspector.

00:33:45.820 --> 00:33:47.850
In the attribute inspector,
you can just go up and there's a

00:33:47.850 --> 00:33:49.450
field that allows you to tick it.

00:33:49.610 --> 00:33:52.610
And if you check that checkbox,
Core Data will create an

00:33:52.650 --> 00:33:54.530
index on that column for you.

00:33:57.710 --> 00:33:58.390
Relationships.

00:33:58.470 --> 00:34:01.460
Well, you've seen what they
look like in the database.

00:34:01.470 --> 00:34:05.070
And that may have made you think,
and I have alluded to the fact,

00:34:05.210 --> 00:34:06.980
that there can be performance
issues with relationships.

00:34:06.980 --> 00:34:08.940
If you're doing a lot of
searching across them,

00:34:08.940 --> 00:34:12.200
or if you're deleting an object,
for example.

00:34:12.300 --> 00:34:14.120
Deletion is a really excellent example.

00:34:15.040 --> 00:34:17.870
We've got primary keys living
on one table and foreign

00:34:17.870 --> 00:34:19.660
keys living on another table.

00:34:19.660 --> 00:34:22.180
In order to delete an
object on the source table,

00:34:22.330 --> 00:34:25.460
the one with the primary key,
I'm going to have to go through

00:34:25.510 --> 00:34:29.690
and clean up all references in the
foreign key column in the other table.

00:34:29.840 --> 00:34:33.330
This is why Core Data has to load
managed objects in order to propagate

00:34:33.400 --> 00:34:37.510
deletes from an object being deleted
to an object it's related to.

00:34:37.610 --> 00:34:40.330
We need to do that cleanup,
and the only way we can do that

00:34:40.390 --> 00:34:42.270
is by loading objects into memory.

00:34:43.830 --> 00:34:45.680
You can do unidirectional relationships.

00:34:45.800 --> 00:34:47.890
If you try this,
the modeling tool will warn you.

00:34:48.060 --> 00:34:49.220
It's kind of an advanced feature.

00:34:49.220 --> 00:34:52.930
And be warned, if you try and do this,
there are some very specific

00:34:52.960 --> 00:34:55.930
cases in which it makes sense,
but you have to be really,

00:34:55.930 --> 00:34:59.730
really careful because we won't know
how to go clean up the information at

00:34:59.730 --> 00:35:01.910
the other end of that relationship.

00:35:01.940 --> 00:35:07.940
And that introduces the possibility of a
data integrity problem in your database.

00:35:07.940 --> 00:35:10.440
If you don't do the cleanup,
then at some point you

00:35:10.440 --> 00:35:12.990
may load an object,
try and follow a relationship,

00:35:13.050 --> 00:35:15.610
and discover that the object
at the other end of that

00:35:15.740 --> 00:35:17.610
relationship isn't there anymore.

00:35:21.560 --> 00:35:22.500
Other things to think about.

00:35:22.540 --> 00:35:24.500
Data set management.

00:35:24.530 --> 00:35:28.040
Try and minimize the number of objects
you're having to load into memory.

00:35:28.260 --> 00:35:30.390
Minimize your working set.

00:35:31.680 --> 00:35:33.320
Think about your where clause ordering.

00:35:33.350 --> 00:35:35.050
It's sort of related
to data set management,

00:35:35.270 --> 00:35:37.040
only data sets in the database.

00:35:37.110 --> 00:35:38.600
What do I mean by that?

00:35:38.810 --> 00:35:42.800
Well, here's a hybridized,
here's pseudocode for a select.

00:35:43.010 --> 00:35:46.040
I want to select songs where
the lyrics text contains you

00:35:46.070 --> 00:35:49.430
and the title is like dare,
case and die critic insensitive,

00:35:49.510 --> 00:35:51.370
and the rating is equal to five.

00:35:51.940 --> 00:35:54.430
If I just pass that down to
the database the way it is,

00:35:54.430 --> 00:35:55.170
what happens?

00:35:55.270 --> 00:35:58.740
Well, here's my three predicates.

00:35:58.980 --> 00:36:00.800
And let's look at the join.

00:36:00.800 --> 00:36:03.420
First, I'm going to go through and
look at my lyrics table.

00:36:03.420 --> 00:36:07.270
And I'm going to go look for all
lyrics that contain the word you

00:36:07.270 --> 00:36:09.120
or contain the substring you.

00:36:09.190 --> 00:36:10.950
I'm going to find four of them.

00:36:10.950 --> 00:36:14.440
And then I'm going to go join
those with the songs table.

00:36:14.440 --> 00:36:15.750
And then I'm going to go look for
all the lyrics that contain the word

00:36:15.750 --> 00:36:15.750
you or contain the substring you.

00:36:15.960 --> 00:36:19.540
and find all of the songs
whose title is like dare,

00:36:19.560 --> 00:36:21.980
which is two songs.

00:36:22.060 --> 00:36:24.200
And then I'm going to go off
and look at the ratings and find

00:36:24.290 --> 00:36:26.390
out that there's only one song

00:36:26.730 --> 00:36:31.800
It has you in the lyrics, title is Dare,
and the rating is 5.

00:36:31.800 --> 00:36:36.650
That doesn't look too bad,
but really it's kind of completely nasty,

00:36:36.760 --> 00:36:39.720
because I've front-loaded
all of the really heavy work.

00:36:39.720 --> 00:36:45.850
I've done a regex table scan across
the lyrics table as my first operation.

00:36:45.870 --> 00:36:49.620
I've done substring matching
across my second operation,

00:36:49.620 --> 00:36:53.460
and I've done my integer
comparisons last.

00:36:53.460 --> 00:36:56.070
Let's invert those for a second.

00:36:57.560 --> 00:36:59.500
Let's do the ratings first.

00:36:59.540 --> 00:37:02.400
There's only two potential songs
I'm ever going to have to look at,

00:37:02.450 --> 00:37:05.600
because there's only two
songs with rating five.

00:37:05.670 --> 00:37:09.270
Well, only one of those songs
has the title there.

00:37:10.280 --> 00:37:12.470
At which point,
I only have to do one regex

00:37:12.470 --> 00:37:17.320
search to discover whether or
not the lyrics meet my criteria.

00:37:17.410 --> 00:37:20.660
This is going to be a much
faster responding application

00:37:21.080 --> 00:37:24.410
than one going the other way,
because, well,

00:37:24.410 --> 00:37:27.410
the first one has to do a lot more work.

00:37:28.600 --> 00:37:32.840
And that's something to think about
when you're building your where clauses.

00:37:32.860 --> 00:37:36.190
Minimize the amount of work you
can do by front-loading your

00:37:36.400 --> 00:37:40.480
predicates with integer comparisons,
particularly attributes that

00:37:40.480 --> 00:37:41.950
are on the source table.

00:37:42.020 --> 00:37:43.990
And only after you've
passed through that,

00:37:44.140 --> 00:37:48.560
start following relationships and
doing heavier text comparisons.

00:37:48.590 --> 00:37:50.670
Your users will thank you.

00:37:52.400 --> 00:39:02.900
[Transcript missing]

00:39:03.320 --> 00:39:07.710
There's no particular reason that
just because you use one technology,

00:39:07.830 --> 00:39:10.670
you're bound to do everything
in that technology.

00:39:10.880 --> 00:39:12.190
Pick the best of both worlds.

00:39:12.230 --> 00:39:14.440
Let the database do what it's good at.

00:39:14.610 --> 00:39:16.820
Let another technology
do what it's good at.

00:39:16.960 --> 00:39:17.750
Hybridize.

00:39:18.160 --> 00:39:21.960
Store object URIs in whatever
the external store is,

00:39:22.070 --> 00:39:25.960
or URIs out to paths in the file system.

00:39:25.990 --> 00:39:27.480
Let everybody be happy.

00:39:27.480 --> 00:39:29.310
Let everybody be efficient.

00:39:31.380 --> 00:39:34.250
Sometimes you've got data
coming from multiple places.

00:39:34.410 --> 00:39:36.890
You can actually have one
model with many configurations.

00:39:36.890 --> 00:39:40.310
The configurations are set on
the panel that I believe has

00:39:40.310 --> 00:39:42.480
the wrench in the modeling tool.

00:39:42.480 --> 00:39:46.060
This allows you to direct specific
entities to specific stores.

00:39:46.060 --> 00:39:48.970
For example, you can have some public
data in one store,

00:39:48.970 --> 00:39:50.780
private data in another store.

00:39:51.690 --> 00:39:54.420
Again, you end up using URIs to do
cross-store relationships,

00:39:54.420 --> 00:39:58.710
but it allows you to partition your
data sometimes more efficiently and

00:39:58.710 --> 00:40:04.700
allows you to use multiple stores
with relationships between them.

00:40:05.990 --> 00:40:08.470
Once you've got everything set up,
you need to find out if you've

00:40:08.480 --> 00:40:10.860
got the best performance,
you know, find out if there's any

00:40:10.860 --> 00:40:12.740
performance gotchas and widgets.

00:40:12.820 --> 00:40:15.240
Miguel talked in his last session,
in the last session,

00:40:15.240 --> 00:40:17.290
which unfortunately you've
missed and will need to catch

00:40:17.420 --> 00:40:21.100
on video when it's released,
about debugging your application

00:40:21.100 --> 00:40:25.440
and using instruments to determine,
you know, if you're hitting the database

00:40:25.440 --> 00:40:29.190
too often or not enough,
or if you're loading too much data.

00:40:30.810 --> 00:40:32.040
Here's where you would start.

00:40:32.070 --> 00:40:38.090
Turn on the com.apple/cordea/sqldebug
flag that will tell you when

00:40:38.090 --> 00:40:40.380
you're hitting the database,
what kind of queries you're

00:40:40.380 --> 00:40:42.700
doing against the database,
how much data you're pulling

00:40:42.700 --> 00:40:44.440
back and how long it's taken.

00:40:44.480 --> 00:40:48.340
That'll allow you sort of
an entree into figuring out,

00:40:48.350 --> 00:40:50.840
you know, what you might be able
to do to tweak things.

00:40:50.920 --> 00:40:55.200
If you realize you're loading
lots and lots of one record,

00:40:55.210 --> 00:40:58.120
or if you're loading one record
as the result of a lot of queries,

00:40:58.290 --> 00:40:59.830
you may be able to batch that.

00:41:00.000 --> 00:41:04.080
There's also the core data instruments in
instruments that allow you to get a sense

00:41:04.080 --> 00:41:05.960
of when you're hitting the database,
where you're spending all of

00:41:05.960 --> 00:41:08.200
your time in your application.

00:41:09.340 --> 00:41:13.650
So we've gone through how model design
affects application performance,

00:41:13.900 --> 00:41:16.680
or at least I've told you that it does,
and you'll have to take my word for

00:41:16.680 --> 00:41:17.810
it and play with it a little bit.

00:41:17.920 --> 00:41:21.780
We've talked about normalization
and denormalization,

00:41:21.780 --> 00:41:24.870
competing strategies that
sort of allow you to move data

00:41:24.870 --> 00:41:27.750
around in your data model,
try and figure out how to best

00:41:27.750 --> 00:41:30.380
make your data model suit the
needs of your application.

00:41:30.580 --> 00:41:34.720
I'll give you a few tips about
things that you can also do to help

00:41:34.720 --> 00:41:39.270
improve performance that aren't
directly related to the schema,

00:41:39.270 --> 00:41:39.270
but

00:41:39.530 --> 00:41:41.350
That are down at the
database layer as well.

00:41:41.370 --> 00:41:44.010
And I believe at this
point I go off into the,

00:41:44.140 --> 00:41:47.130
for more information,
talk to these people.

00:41:47.140 --> 00:41:50.410
Michael Jurowicz,
who is the developer tools evangelist.

00:41:50.500 --> 00:41:53.470
There's the Cocoa Dev mailing
list is an excellent place to get

00:41:53.470 --> 00:41:55.500
answers about technical questions.

00:41:55.500 --> 00:41:57.360
And talk to us people.

00:41:57.360 --> 00:42:00.480
If there's something you don't
understand in our documentation,

00:42:00.500 --> 00:42:03.170
if you find a bug in our technology,
if there's just a feature you really,

00:42:03.170 --> 00:42:05.520
really want, I think that would be
really cool in Core Data.

00:42:07.460 --> 00:42:09.140
We can't read minds,
especially we can't read minds of

00:42:09.140 --> 00:42:10.400
people we don't know at a distance.

00:42:10.450 --> 00:42:14.340
bugreporter.apple.com.

00:42:14.350 --> 00:42:18.790
Send us radar reports, send us emails,
let us know what you're thinking.

00:42:21.160 --> 00:42:23.900
A great place to start
learning about Core Data,

00:42:23.900 --> 00:42:27.310
get lots and lots of details,
is the Core Data documentation

00:42:27.310 --> 00:42:29.480
on developer.apple.com.

00:42:29.590 --> 00:42:34.510
Wikipedia actually has an excellent
article on relational databases

00:42:34.510 --> 00:42:38.000
and some links off to things like
normalization and denormalization.

00:42:38.140 --> 00:42:40.550
It will give you a bit more depth,
a bit more understanding,

00:42:40.580 --> 00:42:43.330
help you go further in the
field than I can give you

00:42:43.330 --> 00:42:44.870
in a one hour long session.

00:42:45.140 --> 00:42:49.510
And if you're going off and having
to write your own SQL database,

00:42:49.800 --> 00:42:51.540
for whatever reason
Core Data doesn't work for you,

00:42:51.540 --> 00:42:54.500
you need cross platform.

00:42:55.050 --> 00:42:58.140
You need to do cross-platform
solution or whatever have you.

00:42:58.270 --> 00:43:00.320
I highly recommend the
SQL Practical Guide for

00:43:00.320 --> 00:43:02.030
Developers by Donahue and Spiegel.

00:43:02.140 --> 00:43:06.470
It's a great hands-on book full of
lots of examples about what SQL looks

00:43:06.910 --> 00:43:09.340
like for doing all kinds of queries.

00:43:09.340 --> 00:43:13.330
It's been immensely
useful over the years.

00:43:14.640 --> 00:43:17.350
As I said earlier,
you've kind of missed our other sessions.

00:43:17.390 --> 00:43:19.030
You'll have to catch them on video.

00:43:19.140 --> 00:43:21.660
We had a what's new in
Core Data for Snow Leopard

00:43:21.680 --> 00:43:23.780
and Core Data tips and tricks.

00:43:23.810 --> 00:43:26.360
But what you haven't
missed is the lab tomorrow.

00:43:26.380 --> 00:43:28.320
If you're a Core Data developer
and you've got questions,

00:43:28.320 --> 00:43:31.780
if you're thinking about using Core Data,
you've got questions,

00:43:31.810 --> 00:43:35.800
we'll be in the OS X lab tomorrow,
from two until six,

00:43:35.800 --> 00:43:39.170
if I remember correctly,
before we run off and get drunk.

00:43:39.230 --> 00:43:42.070
And we'll be happy to
answer your questions.

00:43:42.130 --> 00:43:44.120
The entire Core Data team will be there.

00:43:44.600 --> 00:43:45.630
Come see us.
WEBVTT

00:00:20.410 --> 00:00:21.890
Good afternoon, everyone.

00:00:22.110 --> 00:00:24.640
I'm Doug Davidson,
and I'm here to talk to you about

00:00:24.810 --> 00:00:27.590
polishing your Cocoa application.

00:00:29.430 --> 00:00:33.800
So we all know that Cocoa is designed
for rapid application development.

00:00:33.860 --> 00:00:38.340
It should make it easy to get
your application up and running.

00:00:38.390 --> 00:00:40.380
But does that mean you're done?

00:00:40.430 --> 00:00:40.920
Well, no.

00:00:40.920 --> 00:00:43.580
Usually what it means is
that our customers just

00:00:43.600 --> 00:00:45.520
increase their expectations.

00:00:45.560 --> 00:00:49.010
But the good news is you're
going to spend your time not so

00:00:49.080 --> 00:00:53.610
much on making your application
run as on making it run great.

00:00:53.700 --> 00:00:56.130
And that's going to be
our theme for today.

00:00:56.320 --> 00:01:00.090
We have a number of topics that
we're going to talk about today.

00:01:00.090 --> 00:01:01.510
We'll talk about 64-bit.

00:01:01.510 --> 00:01:04.740
We'll talk about performance,
responsiveness, security,

00:01:04.740 --> 00:01:07.080
localization and internationalization.

00:01:07.080 --> 00:01:11.710
We'll talk about usability and
about scripting and accessibility.

00:01:11.710 --> 00:01:15.650
And now that happens,
I have a little sample application

00:01:15.650 --> 00:01:17.900
that we're going to be working on.

00:01:17.900 --> 00:01:19.610
It's called Zip Browser.

00:01:19.610 --> 00:01:24.880
And what this little app does is to let
you look inside a Zip archive without

00:01:24.950 --> 00:01:29.540
having to unarchive the whole thing.

00:01:29.540 --> 00:01:32.990
Now, this is not available
as sample code just yet.

00:01:33.090 --> 00:01:36.030
We're going to try to have
it out as soon as possible.

00:01:36.030 --> 00:01:38.660
Look for the Zip Browser example.

00:01:38.660 --> 00:01:40.480
So I'd like to show it to you.

00:01:40.620 --> 00:01:43.600
Let's go over to the demo
machine and take a look.

00:01:50.700 --> 00:01:56.500
[Transcript missing]

00:01:58.100 --> 00:01:59.290
I'll show you an action.

00:01:59.370 --> 00:02:00.880
Open something up.

00:02:00.900 --> 00:02:05.030
Let's pick a zip archive and open
it up and there are the contents.

00:02:05.170 --> 00:02:08.040
And you'll see we're using
an NSBrowser to display the

00:02:08.100 --> 00:02:09.620
contents of the zip archive.

00:02:09.820 --> 00:02:13.410
Now, those of you who have been using
Cocoa for some time might remember

00:02:13.410 --> 00:02:17.740
that NSBrowser is one of the first
and oldest of the Cocoa controls.

00:02:17.800 --> 00:02:20.430
And in recent years,
it's maybe lagged a little behind

00:02:20.510 --> 00:02:23.740
some of the more modern controls
like the Table View and Outline View.

00:02:23.760 --> 00:02:25.900
Well, no longer.

00:02:25.930 --> 00:02:29.430
In Snow Leopard,
we have added a new set of methods

00:02:29.600 --> 00:02:33.040
to NSBrowser that we call the
Item-Based API for NSBrowser.

00:02:33.060 --> 00:02:35.480
Makes it really easy to use NSBrowser.

00:02:35.480 --> 00:02:36.870
Makes it a joy to use.

00:02:37.130 --> 00:02:39.650
And that's a good thing
because with NSBrowser,

00:02:39.920 --> 00:02:42.020
you get a ton of functionality for free.

00:02:42.230 --> 00:02:45.400
You get things like expansion tool tips.

00:02:45.550 --> 00:02:48.220
You get the arrow key navigation.

00:02:48.220 --> 00:02:50.320
You get type ahead.

00:02:50.740 --> 00:02:53.400
And let's take a look at this.

00:02:53.440 --> 00:02:55.780
You get this little preview.

00:02:55.900 --> 00:02:59.140
This is the preview column here.

00:02:59.140 --> 00:03:02.830
With NSBrowser,
all you have to do is provide the

00:03:02.830 --> 00:03:04.840
view that does the drawing in this.

00:03:04.850 --> 00:03:09.870
And NSBrowser does all the
management of bringing it in and out.

00:03:09.940 --> 00:03:12.800
And here we've chosen to show a
little bit of information about

00:03:12.800 --> 00:03:16.210
each entry in the zip archive,
just an icon, a name,

00:03:16.210 --> 00:03:20.010
and the sizes within
and out of the archive.

00:03:20.080 --> 00:03:21.020
OK.

00:03:21.130 --> 00:03:23.050
So here's our application.

00:03:23.220 --> 00:03:24.310
It compiles.

00:03:24.320 --> 00:03:25.120
It launches.

00:03:25.120 --> 00:03:25.750
It runs.

00:03:25.760 --> 00:03:27.320
It's a little bit of a mess.

00:03:27.320 --> 00:03:29.440
But it's a lot of work.

00:03:29.440 --> 00:03:31.790
We have a lot of work
to do on this app today.

00:03:31.890 --> 00:03:34.670
So let's take a look at some code.

00:03:35.290 --> 00:03:37.960
Let's go into Xcode.

00:03:38.380 --> 00:03:42.290
Now, this is a very simple
document-based application.

00:03:42.290 --> 00:03:44.630
As it stands,
it's about 200 lines of code

00:03:44.630 --> 00:03:48.460
and has three custom classes,
a model, a view, and a controller.

00:03:48.460 --> 00:03:52.950
And what we're looking at right now
is a header for our model class,

00:03:53.040 --> 00:03:57.080
zip entry, which models an individual's
entry in the zip archive,

00:03:57.080 --> 00:03:59.780
and it stores some basic
information about it,

00:03:59.780 --> 00:04:03.660
a name, a location in the archive,
the sizes, and so on.

00:04:03.720 --> 00:04:08.360
And because there's an implicit tree
structure to these things that's

00:04:08.390 --> 00:04:13.010
used to store directory hierarchies,
we have leaf and non-leaf entries,

00:04:13.010 --> 00:04:16.280
and the non-leaf entries have
an array of child entries.

00:04:16.280 --> 00:04:17.420
They're all very simple.

00:04:17.420 --> 00:04:20.530
So let's take a look at our view class.

00:04:20.530 --> 00:04:25.530
And our view class is the class
that does the drawing for that

00:04:25.530 --> 00:04:27.760
preview column in the browser.

00:04:28.500 --> 00:04:31.940
And again, it's extremely simple.

00:04:31.940 --> 00:04:37.330
In our -- see, in our draw rect,
we use very standard Cocoa methods

00:04:37.350 --> 00:04:40.660
to take this image that we
got from NSWorkspace -- it's

00:04:40.660 --> 00:04:44.210
an icon -- and to draw it,
and then to take these various

00:04:44.210 --> 00:04:47.990
pieces of text and to draw them,
and there's a little extra

00:04:47.990 --> 00:04:51.900
code to calculate the sizes
so we can lay them out.

00:04:51.920 --> 00:04:55.440
Perfectly standard Cocoa view techniques.

00:04:55.440 --> 00:04:59.880
And then our model -- because we're
using a very simple document-based app,

00:05:00.000 --> 00:05:04.510
we just have a subclass of NSDocument
that acts as -- I'm sorry -- that

00:05:04.520 --> 00:05:06.710
acts as a controller for everything.

00:05:06.900 --> 00:05:11.080
And so the main thing we have here
is the read from URL method that

00:05:11.250 --> 00:05:14.380
gets the contents of the zip archive,
goes through it,

00:05:14.800 --> 00:05:20.570
looking for all these entries,
creates the model objects,

00:05:20.570 --> 00:05:22.870
and adds them to us.

00:05:22.920 --> 00:05:26.490
And then I mentioned about the
item-based API for NSBrowser.

00:05:26.570 --> 00:05:29.040
So let me show it to you.

00:05:29.170 --> 00:05:34.080
Here it is.

00:05:34.660 --> 00:05:34.680
This is the complete -- this is

00:05:34.930 --> 00:05:39.010
This is all we do here as
the delegate of the browser.

00:05:39.100 --> 00:05:42.730
I note, what is it, six one-line methods.

00:05:42.780 --> 00:05:46.060
That's all we have to do,
and this browser does all the rest.

00:05:46.980 --> 00:05:51.000
So what is it that we want
to do to this application?

00:05:51.000 --> 00:05:54.960
So the first thing I'd like
to do is make it 64-bit.

00:05:55.360 --> 00:05:58.920
Now, if you have been waiting to
make your app 64-bit ready,

00:05:58.920 --> 00:05:59.950
now is the time.

00:06:00.430 --> 00:06:02.860
64-bit is a big emphasis in Snow Leopard.

00:06:02.860 --> 00:06:04.470
You heard Bertrand talk about it.

00:06:04.560 --> 00:06:06.260
He explained why you want to do this.

00:06:06.410 --> 00:06:09.280
Now, of course,
we're not making our apps 64-bit only.

00:06:09.280 --> 00:06:12.710
We need them to run as
32-bit on 32-bit machines,

00:06:12.710 --> 00:06:15.060
64-bit on 64-bit machines.

00:06:15.060 --> 00:06:18.430
So what is it that we do for that?

00:06:18.500 --> 00:06:21.760
First of all,
make a copy of your project.

00:06:21.890 --> 00:06:23.440
Then we have a script.

00:06:23.440 --> 00:06:26.340
In Snow Leopard,
we have a new Ruby-based script

00:06:26.410 --> 00:06:31.150
that you run on all your source code
and that does some straightforward

00:06:31.150 --> 00:06:34.600
substitutions to do the conversion.

00:06:34.690 --> 00:06:37.770
And then you take a look at
all the differences between the

00:06:37.770 --> 00:06:39.420
original and the modified version.

00:06:39.420 --> 00:06:41.070
Yes, you have to look at all the diffs.

00:06:41.200 --> 00:06:43.480
Now,
I've already done that for this project.

00:06:43.680 --> 00:06:47.610
So let's take a look
at some of those diffs.

00:06:49.950 --> 00:06:52.800
What sort of things are you going to see?

00:06:52.800 --> 00:06:57.170
So the most common sort of thing
you'll see is that the script

00:06:57.300 --> 00:07:02.720
has replaced 32-bit integers,
signed or unsigned, with things like

00:07:02.750 --> 00:07:08.480
NSU integer and NSInteger,
which are the Cocoa integer types

00:07:08.480 --> 00:07:14.780
for integers that are 32-bit
on 32-bit and 64-bit on 64-bit.

00:07:14.960 --> 00:07:18.190
And usually this is exactly
the right thing to do.

00:07:18.240 --> 00:07:19.870
In most cases, this is just fine.

00:07:19.870 --> 00:07:23.020
But I've been looking through this,
and I noticed there are a few

00:07:23.020 --> 00:07:27.650
places here where these values
actually represent things that I am

00:07:27.650 --> 00:07:32.400
getting out of the zip archive that
are defined by the zip format to

00:07:32.400 --> 00:07:37.600
be specifically sized quantities,
either 16 or 32-bit.

00:07:37.720 --> 00:07:39.970
Now, it's not wrong what's done here.

00:07:39.970 --> 00:07:41.840
I certainly could use
NSU integer for those.

00:07:41.930 --> 00:07:43.690
It's plenty big enough.

00:07:43.780 --> 00:07:47.280
But when I was looking at this,
I decided that it would more accurately

00:07:47.450 --> 00:07:52.160
represent the intent of the code if
I used fixed-size types for these.

00:07:52.160 --> 00:07:55.580
So I chose to use uint16t and uint32t.

00:07:55.640 --> 00:07:58.340
Maybe I should have done
that from the beginning,

00:07:58.380 --> 00:08:02.230
but in any event,
now is a good time to make that change.

00:08:02.340 --> 00:08:04.580
What else are you going to see?

00:08:05.730 --> 00:08:12.640
Here's another common thing where you run
into printf-style formatting integers.

00:08:12.640 --> 00:08:18.520
Now, the script tags these cases because
printf-style formatting doesn't really

00:08:18.520 --> 00:08:24.580
play very well with variable size
types like NSInteger and NSUInteger.

00:08:24.580 --> 00:08:26.740
So you need to look at
these and do something.

00:08:26.930 --> 00:08:30.660
And what I'm going to do is something
that's fairly straightforward,

00:08:30.660 --> 00:08:32.980
sort of brute force,
but what I'm going to do

00:08:32.980 --> 00:08:35.240
is take the arguments,
these integral arguments,

00:08:35.320 --> 00:08:38.900
and cast them to something that
I know is big enough and that I know

00:08:38.900 --> 00:08:43.070
printf-style formatting will understand,
usually a long or a long long.

00:08:43.200 --> 00:08:47.120
And I've made those changes,
so let's look at the changes

00:08:47.120 --> 00:08:49.640
that I've made after the script.

00:08:49.800 --> 00:08:54.750
So here in this case,
what I've done is to take

00:08:54.750 --> 00:08:56.890
the %u and add an l quality.

00:08:56.980 --> 00:08:58.900
So I've added a modifier to it,
make it long,

00:08:58.900 --> 00:09:04.900
and then cast the argument to an unsigned
long to make sure that the printf-style

00:09:04.930 --> 00:09:07.580
formatting will understand it.

00:09:07.980 --> 00:09:10.450
In the other cases,
I looked at through it and decided

00:09:10.450 --> 00:09:14.370
which ones should be Uint32T and which
ones should be Uint16T and replaced

00:09:14.370 --> 00:09:17.490
those uniformly throughout the project.

00:09:18.040 --> 00:09:26.400
So let's take a look at that
updated version after 64-bit.

00:09:26.400 --> 00:09:28.450
Let's try running it.

00:09:31.670 --> 00:09:36.760
See if we can open up a zip archive.

00:09:36.760 --> 00:09:37.360
And there we go.

00:09:37.360 --> 00:09:43.480
We're writing in 64 bits.

00:09:43.480 --> 00:09:46.510
Now let's go back to the slides.

00:09:52.370 --> 00:09:55.290
And let me reprise those
steps for 64-bit Redius.

00:09:55.420 --> 00:09:58.950
First one, make a copy of your project,
run the script on it.

00:09:58.950 --> 00:10:02.640
Here's the location of the
script in Snow Leopard.

00:10:02.640 --> 00:10:06.660
Then examine all the diffs and approve,
disapprove, or modify them.

00:10:06.970 --> 00:10:11.200
There are some things that you
need to keep a special eye on.

00:10:11.200 --> 00:10:13.380
As we saw,
uses of printf-style formatting may

00:10:13.380 --> 00:10:16.420
require some judgment for converting.

00:10:16.590 --> 00:10:20.720
Any cases where you're dealing with
formats on disk or that otherwise

00:10:20.810 --> 00:10:23.640
go outside your application,
like the zip archive

00:10:23.740 --> 00:10:29.290
format that I discussed,
those may need specifically sized types.

00:10:29.720 --> 00:10:33.690
If you're doing archiving,
you may need to look at instances of

00:10:33.690 --> 00:10:37.510
that to make sure that your archives
can be read and written on both

00:10:37.510 --> 00:10:41.820
16 and 32 and 64 bit consistently.

00:10:42.160 --> 00:10:45.800
Cases where you're dealing with pointers,
you need to make sure that

00:10:45.800 --> 00:10:49.200
all your references to the
pointers are consistent.

00:10:49.510 --> 00:10:54.180
And in one particular case,
if you're still using the

00:10:54.180 --> 00:10:58.160
old non-keyed archiving,
you're going to have to deal with

00:10:58.160 --> 00:11:00.160
both of these issues at once.

00:11:00.230 --> 00:11:01.970
It could be done.

00:11:02.070 --> 00:11:04.400
Maybe you want to consider whether
you really need to keep using

00:11:04.400 --> 00:11:08.400
non-keyed archiving anymore.

00:11:08.700 --> 00:11:10.040
You need to examine your dependencies.

00:11:10.040 --> 00:11:13.970
If you're using somebody else's code,
then you need to look at that and make

00:11:13.970 --> 00:11:16.540
sure that it is 64-bit ready as well.

00:11:16.660 --> 00:11:18.590
And then finally,
you need to make sure you

00:11:18.590 --> 00:11:20.130
thoroughly test the result.

00:11:20.230 --> 00:11:26.180
And that's what you need to do to make
your app ready to run at 32 and 64-bit.

00:11:27.800 --> 00:11:31.900
All right, let's go on to our next topic,
which is performance and responsiveness.

00:11:32.020 --> 00:11:35.990
Now, performance is something that you
probably shouldn't be thinking a

00:11:35.990 --> 00:11:39.860
great deal about while you're just
getting your app up and running.

00:11:39.960 --> 00:11:42.510
But once you have it running,
it's time to look at it.

00:11:42.510 --> 00:11:48.340
Now, I'm a great believer in testing
performance using user-level scenarios.

00:11:48.430 --> 00:11:50.700
If you don't have a specific
user-level scenario that

00:11:50.700 --> 00:11:52.710
shows a performance problem,
maybe there isn't a

00:11:52.710 --> 00:11:54.040
performance problem there.

00:11:54.040 --> 00:11:57.020
But if you have a user-level
scenario that shows a problem,

00:11:57.020 --> 00:11:58.980
then you need to attack it.

00:11:58.980 --> 00:12:03.650
And the mechanisms for attacking
performance problems are

00:12:03.750 --> 00:12:05.080
probably pretty familiar to you.

00:12:05.270 --> 00:12:08.580
Some of you may have gone to
the previous session upstairs,

00:12:08.580 --> 00:12:11.840
the performance technique session
that showed some of these things.

00:12:11.960 --> 00:12:15.690
Basically,
the guidelines for dealing with

00:12:15.990 --> 00:12:20.740
performance issues are very simple,
three simple rules.

00:12:20.740 --> 00:12:22.780
First, don't touch the disk.

00:12:22.990 --> 00:12:24.560
Second, don't use memory.

00:12:24.850 --> 00:12:27.410
And third, don't do work.

00:12:28.570 --> 00:12:30.960
Now, this may not be quite
as simple as it sounds.

00:12:31.020 --> 00:12:34.240
Let me explain what I mean.

00:12:34.280 --> 00:12:35.300
Don't touch the disk.

00:12:35.430 --> 00:12:39.000
Well, the disk is one of the slowest
components of a modern computer

00:12:39.140 --> 00:12:40.970
by many orders of magnitude.

00:12:41.100 --> 00:12:44.580
So every file system access
that you can get out of your

00:12:44.820 --> 00:12:49.200
program is that much to the good.

00:12:49.240 --> 00:12:51.890
This, for example,
is one of the main keys of

00:12:51.960 --> 00:12:55.500
our file system efficiency
program for Snow Leopard that

00:12:55.500 --> 00:13:00.040
we've been talking about,
that is to remove any redundant or

00:13:00.040 --> 00:13:02.150
unnecessary file system accesses.

00:13:02.320 --> 00:13:04.170
Now,
you might not think that your app has

00:13:04.170 --> 00:13:07.670
any redundant file system accesses,
but maybe you should take a

00:13:07.670 --> 00:13:08.980
look and check and find out.

00:13:08.980 --> 00:13:11.180
You might be surprised.

00:13:11.380 --> 00:13:13.300
Second thing, don't use memory.

00:13:13.300 --> 00:13:17.110
Well, memory is a lot faster than disk,
but still it's a lot

00:13:17.110 --> 00:13:18.520
slower than the processor.

00:13:18.560 --> 00:13:22.900
So every bit of memory you can avoid
using is that much to the good.

00:13:22.900 --> 00:13:25.240
Now, of course,
it's perfectly okay to use

00:13:25.240 --> 00:13:28.790
memory if it's a substitute for
something that's more expensive,

00:13:29.000 --> 00:13:32.140
like going to the disk or doing
a lot of expensive computation,

00:13:32.180 --> 00:13:35.150
especially if you are willing
to give that memory back to

00:13:35.160 --> 00:13:37.020
the system when it needs it.

00:13:37.080 --> 00:13:39.400
And if you went to the
performance session earlier,

00:13:39.400 --> 00:13:43.630
it was discussed,
the new caching and discardable contents

00:13:43.630 --> 00:13:49.070
mechanisms for Snow Leopard that allow
you to give memory back to the system

00:13:49.090 --> 00:13:52.190
when the system is under pressure.

00:13:52.490 --> 00:13:54.080
And don't do work.

00:13:54.230 --> 00:13:58.280
Well, sometimes it's unavoidable,
but we've all seen cases where a simple

00:13:58.340 --> 00:14:03.200
change in algorithm or maybe doing
something lazily can get the same

00:14:03.640 --> 00:14:08.450
task done by doing a lot less work.

00:14:08.450 --> 00:14:08.460
And then when you come,

00:14:08.700 --> 00:14:11.130
To the end of these techniques,
it's time to start

00:14:11.210 --> 00:14:13.440
considering concurrency.

00:14:13.440 --> 00:14:16.960
The way we want you to think about
concurrency in your app is not

00:14:16.960 --> 00:14:21.600
so much as a series of threads,
but rather as a series of work

00:14:21.660 --> 00:14:26.990
queues on which work units arrive,
they're scheduled, they're processed,

00:14:26.990 --> 00:14:28.520
they're handled, they're done.

00:14:28.590 --> 00:14:34.840
And this operation queue in Cocoa makes
it very easy to think this way.

00:14:34.840 --> 00:14:38.010
But also,
and as run loop is a different sort

00:14:38.010 --> 00:14:42.110
of work queue on which things arrive,
they're scheduled, they're processed,

00:14:42.110 --> 00:14:42.860
they're handled.

00:14:42.870 --> 00:14:47.570
Now, in an application,
the main thread with the main run loop

00:14:47.640 --> 00:14:53.780
is special in that it is the work queue
on which user interaction events arrive.

00:14:53.780 --> 00:14:57.170
And in a simple application,
maybe all the work is

00:14:57.230 --> 00:14:59.060
done on the main run loop.

00:14:59.060 --> 00:15:03.600
But in a more sophisticated application,
you would typically want to move

00:15:03.970 --> 00:15:04.810
some work off of the main run loop.

00:15:04.820 --> 00:15:10.650
So as to leave it free to do its main
job of handling user interaction,

00:15:10.650 --> 00:15:15.860
and that's what keeps
your app responsive.

00:15:15.860 --> 00:15:15.860
So, let's look at the next slide.

00:15:16.140 --> 00:15:21.210
Now, you've probably heard Bertrand talk
about the Grand Central Dispatch

00:15:21.210 --> 00:15:22.600
push for Snow Leopard.

00:15:22.730 --> 00:15:25.020
Well, as Cocoa developers,
if you're using

00:15:25.020 --> 00:15:27.600
NSOperationQueue and NSRunLoop,
you're in luck.

00:15:27.600 --> 00:15:31.140
These are the classes that will
be the Cocoa interface to the

00:15:31.140 --> 00:15:33.100
Grand Central Dispatch functionality.

00:15:33.140 --> 00:15:38.880
You're already thinking in the right
way about handling work queues.

00:15:39.330 --> 00:15:45.160
Now, one big point from the
previous performance session,

00:15:45.220 --> 00:15:50.640
one point to take away is that you
want to avoid as much as possible any

00:15:50.640 --> 00:15:55.040
concurrent access to shared mutable data.

00:15:55.200 --> 00:15:59.650
Because whenever you have
contention for shared resource,

00:15:59.770 --> 00:16:02.810
you're going to lose the
benefits of concurrency.

00:16:03.350 --> 00:16:10.000
It's possible to lock, but as I say,
the contention for the lock

00:16:10.320 --> 00:16:12.910
is going to degrade your
performance and your concurrency.

00:16:13.320 --> 00:16:15.160
Fortunately, there is an alternative.

00:16:15.220 --> 00:16:19.800
What you can do is create a
single-threaded operation queue,

00:16:20.050 --> 00:16:24.920
and then for a specific shared resource,
make sure that the work on that

00:16:24.990 --> 00:16:29.350
resource is sent -- always sent to
that particular operation queue.

00:16:29.610 --> 00:16:33.450
Then the operation queue will
automatically take care of serializing

00:16:33.500 --> 00:16:36.910
access to that resource for you,
and you don't have to

00:16:36.920 --> 00:16:38.420
worry about locking.

00:16:41.210 --> 00:16:43.900
Now, the final thing I want to
mention is that in a Cocoa app,

00:16:43.900 --> 00:16:46.340
there are many potential
sources of concurrency,

00:16:46.340 --> 00:16:47.450
implicit and explicit.

00:16:47.460 --> 00:16:51.240
You can use NSThread if you need to,
but we really want to thank you

00:16:51.320 --> 00:16:54.900
more in terms of work queues,
like at its operation queue,

00:16:54.900 --> 00:16:57.300
especially for concurrency in your model.

00:16:57.300 --> 00:17:02.750
In Snow Leopard,
we have some new sets of concurrent APIs.

00:17:02.760 --> 00:17:06.720
If you saw the What's New talk,
we discussed the concurrent

00:17:06.720 --> 00:17:09.950
collection APIs for things like
searching and sorting and iterating.

00:17:11.240 --> 00:17:16.100
NSDocument has a new concurrent document
opening API so that you can make sure

00:17:16.100 --> 00:17:18.700
if you're opening a number of documents,
that can all be done concurrently

00:17:18.750 --> 00:17:19.780
with respect to each other.

00:17:19.780 --> 00:17:26.420
NSView has a concurrent view drawing
API so that perhaps some of the

00:17:26.420 --> 00:17:29.860
views in your window can be drawn
concurrently with respect to each other.

00:17:29.860 --> 00:17:32.030
And there are other
sources of concurrency.

00:17:32.040 --> 00:17:35.240
For example, if you use Core Animation,
that's an implicit source of concurrency.

00:17:35.240 --> 00:17:38.260
The animation is done concurrently with
respect to whatever else you're doing.

00:17:38.260 --> 00:17:41.040
And you can also use the GPU.

00:17:41.100 --> 00:17:44.580
Concurrently with the CPU with OpenGL,
Core Image, Core Video,

00:17:44.580 --> 00:17:47.590
and now in Snow Leopard with OpenCL.

00:17:49.520 --> 00:17:54.230
So let's go over to our application
and go over to the demo.

00:17:54.450 --> 00:17:56.560
We'll take a look at it.

00:18:01.930 --> 00:18:07.400
And as it happens,
I do have a performance testing scenario,

00:18:07.400 --> 00:18:08.900
user scenario.

00:18:08.920 --> 00:18:13.590
And my scenario is to successively
open larger and larger zip documents

00:18:13.630 --> 00:18:15.280
and see how the app handles it.

00:18:15.280 --> 00:18:19.690
So if I start with a very small one,
that's pretty quick.

00:18:20.480 --> 00:18:25.470
If I go to a little bit larger one,
that takes a little longer.

00:18:25.600 --> 00:18:29.880
And then I could go to a really huge one.

00:18:29.970 --> 00:18:31.580
Do I dare open this one?

00:18:31.670 --> 00:18:33.080
Actually,
I think I better not try to open it.

00:18:33.080 --> 00:18:35.900
I tried this before,
and really it's not pretty.

00:18:35.900 --> 00:18:38.210
It just hangs the whole app.

00:18:38.630 --> 00:18:41.160
Fortunately,
I managed to do some sampling.

00:18:41.230 --> 00:18:45.550
And the sampling will show where
the problem lies pretty quickly.

00:18:45.770 --> 00:18:48.040
In this case,
we take a look at the samples,

00:18:48.110 --> 00:18:52.560
and we can go right down to the
document method and see what it's doing.

00:18:52.680 --> 00:18:53.950
It's calling an NSData method.

00:18:54.020 --> 00:18:57.130
The first thing this app does
is to load the whole contents

00:18:57.210 --> 00:18:59.420
of the zip archive into memory.

00:18:59.470 --> 00:19:04.230
Now, it's a really convenient API,
but it doesn't scale.

00:19:04.650 --> 00:19:10.120
And furthermore, as it happens,
we don't really need access to all

00:19:10.120 --> 00:19:13.020
the contents of the zip archive,
at least not at once.

00:19:13.020 --> 00:19:15.300
We just need little bits
and pieces here and there,

00:19:15.300 --> 00:19:18.100
mostly toward the end of the document,
actually, but still.

00:19:18.100 --> 00:19:21.480
So we can try to solve that
and just look at the pieces

00:19:21.750 --> 00:19:23.760
that we want when we want them.

00:19:23.760 --> 00:19:28.170
That will remove great
many file system accesses.

00:19:28.170 --> 00:19:29.890
It will greatly reduce the use of memory.

00:19:29.920 --> 00:19:32.940
Now, is that enough?

00:19:32.940 --> 00:19:34.190
Maybe.

00:19:34.420 --> 00:19:39.140
But we can't necessarily rely on that,
because we don't know how many entries

00:19:39.140 --> 00:19:40.340
are going to be in a zip archive.

00:19:40.340 --> 00:19:41.390
It could be thousands of them.

00:19:41.390 --> 00:19:44.600
We don't know how slow our
file system is going to be.

00:19:44.610 --> 00:19:46.910
It might be on a USB drive.

00:19:46.920 --> 00:19:47.790
It might be over the network.

00:19:47.800 --> 00:19:53.010
So to be sure,
what we're going to do is take our

00:19:53.010 --> 00:19:59.900
file system access and move it off
of the main run loop to maintain.

00:19:59.920 --> 00:20:01.920
responsiveness in our application.

00:20:02.060 --> 00:20:04.140
Let's see how that works.

00:20:11.290 --> 00:20:14.700
Let me go to the improved
version of the application.

00:20:14.820 --> 00:20:17.350
Now, what I've done here is
to add another class,

00:20:17.350 --> 00:20:20.920
which I called FileBuffer.

00:20:21.250 --> 00:20:23.460
What this is,
is just a very simple wrapper

00:20:23.550 --> 00:20:29.640
around an NSFile handle that handles
access to the contents of the file,

00:20:29.800 --> 00:20:33.670
and it does a little buffering that's
specialized for the uses of this app,

00:20:33.880 --> 00:20:38.180
just to reduce the number of file
system accesses to a minimum.

00:20:38.890 --> 00:20:43.400
And, oh, it does one other thing as well.

00:20:43.400 --> 00:20:45.460
Because the Zip Archive
format is a little Indian,

00:20:45.460 --> 00:20:49.790
I've written the API for this in
such a way that this class does

00:20:49.790 --> 00:20:53.490
all of the byte swapping for me,
so there is absolutely no way

00:20:53.490 --> 00:20:55.560
I can forget about Indian-ness.

00:20:56.660 --> 00:20:59.800
And one thing I should
mention about this class,

00:20:59.830 --> 00:21:03.600
a very simple class,
it is deliberately not thread safe.

00:21:03.680 --> 00:21:05.340
Why is that?

00:21:05.450 --> 00:21:10.960
Because access to a file descriptor,
which is what this does,

00:21:11.240 --> 00:21:14.050
is something that inherently
has to be serialized.

00:21:14.110 --> 00:21:17.240
I could make it thread safe by locking,
but I really don't want to lock.

00:21:17.530 --> 00:21:19.710
Locking is difficult.

00:21:19.810 --> 00:21:21.570
It's expensive.

00:21:21.570 --> 00:21:23.180
It's hard to get right.

00:21:23.180 --> 00:21:23.180
It's difficult to debug.

00:21:23.430 --> 00:21:26.010
Instead, what I'm going to do is
what I mentioned before.

00:21:26.100 --> 00:21:29.800
I'm going to use an NSOperation queue,
a single thread,

00:21:29.980 --> 00:21:34.500
to serialize the access to this object.

00:21:34.650 --> 00:21:36.800
Let's see how that works.

00:21:38.700 --> 00:21:41.600
I'll go over to my document class.

00:21:41.730 --> 00:21:46.810
Now, when I set up my document object,
I'm going to create an operation

00:21:46.810 --> 00:21:51.360
queue for this document and
make it single-threaded.

00:21:51.460 --> 00:21:55.660
Okay.

00:21:55.660 --> 00:21:56.710
And then when I go

00:21:57.070 --> 00:21:57.590
to read.

00:21:57.760 --> 00:22:01.710
Oh, notice I'm going to use the
new Snow Leopard API for

00:22:01.710 --> 00:22:05.370
concurrent document opening,
just for another extra whammy.

00:22:05.580 --> 00:22:09.090
Document opening is going to be
concurrent with respect to each other.

00:22:10.230 --> 00:22:14.220
Now, then when I go to read
one of these documents,

00:22:14.250 --> 00:22:19.820
what I'm going to do is just to create
one of these file buffer objects.

00:22:20.030 --> 00:22:25.900
And then I'm going to go and read
just a very little bit out of it,

00:22:26.030 --> 00:22:29.940
just enough to make sure this
thing looks like a zip archive.

00:22:30.380 --> 00:22:35.800
And then after that, after that,
I'm going to create an NS operation.

00:22:35.910 --> 00:22:38.610
After that,
all the access to this file buffer is

00:22:38.670 --> 00:22:41.810
going to occur on our operation queue.

00:22:41.850 --> 00:22:43.760
I'm sure to maintain that.

00:22:43.870 --> 00:22:45.260
So I created this operation.

00:22:45.260 --> 00:22:48.410
It's a pretty trivial
subclass of NSOperation.

00:22:48.420 --> 00:22:51.020
All it does is call
back into the document,

00:22:51.070 --> 00:22:53.890
and it calls a particular method.

00:22:54.160 --> 00:22:59.800
called read entries for "operation."
And this is the method that actually does

00:22:59.890 --> 00:23:04.680
the work of going through and reading all
of the entries out of the zip archive,

00:23:04.680 --> 00:23:07.530
and it reads everything
about the archive,

00:23:07.530 --> 00:23:10.730
the location, the name, the size,
and so forth,

00:23:10.730 --> 00:23:14.630
and then it creates that model object,
the zip entry object for

00:23:14.630 --> 00:23:16.200
that entry in the archive.

00:23:16.430 --> 00:23:19.040
And then it does something interesting.

00:23:19.040 --> 00:23:23.040
What it does is to add that
entry object to an array.

00:23:23.300 --> 00:23:25.940
And when we get enough
entries in the array,

00:23:25.940 --> 00:23:30.130
then we call back to the main thread,
to the main run loop with

00:23:30.150 --> 00:23:34.880
that array of entries,
and we call back to the main run loop

00:23:34.880 --> 00:23:39.480
so that those entries can be added back
into the document and added to the UI,

00:23:39.710 --> 00:23:47.120
because it's the main thread
that does the user interaction.

00:23:47.150 --> 00:23:49.260
Let's see how well this works.

00:23:52.900 --> 00:23:59.280
So now what I'm going to do is open
all three of these things at once.

00:23:59.280 --> 00:24:00.920
Ready, set, go.

00:24:01.200 --> 00:24:02.520
Boom.

00:24:03.080 --> 00:24:06.740
All of them opened at once,
including this giant one, which contains,

00:24:06.740 --> 00:24:10.640
I think it's all of GarageBand's data.

00:24:10.730 --> 00:24:14.720
And if you look very closely,
you may have seen a bit of a flash where

00:24:14.720 --> 00:24:16.760
the UI came up before it was populated.

00:24:16.760 --> 00:24:20.340
That is the effect of doing
this in the background.

00:24:21.170 --> 00:24:26.880
So that is our performance
work on this application.

00:24:26.880 --> 00:24:29.800
And let us go back to the slides.

00:24:35.290 --> 00:24:39.040
So the next thing I want
to talk about is security.

00:24:39.050 --> 00:24:42.120
Now, I can remember a time not
so very long ago when,

00:24:42.140 --> 00:24:44.450
particularly for a simple
little app like this,

00:24:44.460 --> 00:24:47.610
nobody would have thought
very much about security.

00:24:47.830 --> 00:24:50.980
That time is long past.

00:24:51.090 --> 00:24:55.910
In particular, it is not possible to take
a data file from somewhere,

00:24:55.920 --> 00:24:59.020
who knows where,
assume it's a particular data format,

00:24:59.140 --> 00:25:02.180
read bytes out of it,
and just take them for granted,

00:25:02.290 --> 00:25:04.600
assume they mean what they say.

00:25:04.740 --> 00:25:06.150
No, you can't do that.

00:25:06.460 --> 00:25:09.760
The right attitude is
external data is poison.

00:25:09.800 --> 00:25:10.700
It's radioactive.

00:25:10.700 --> 00:25:14.190
You handle it with rubber gloves,
with a 10-foot pole.

00:25:14.610 --> 00:25:20.260
So much so that even if you don't
have any poison data on hand,

00:25:20.310 --> 00:25:24.440
you need to create some yourself
through a process called fuzzing.

00:25:24.460 --> 00:25:28.400
And what fuzzing is,
is you take a good data file and you

00:25:28.400 --> 00:25:31.930
modify it by putting in random bits.

00:25:31.980 --> 00:25:33.950
And you don't modify just any part of it.

00:25:33.950 --> 00:25:36.890
You modify the most sensitive parts,
the ones that determine the

00:25:36.890 --> 00:25:38.240
structure of the document.

00:25:38.280 --> 00:25:40.070
You change the bytes.

00:25:40.100 --> 00:25:41.610
You insert bytes.

00:25:41.700 --> 00:25:43.260
You remove bytes.

00:25:43.360 --> 00:25:47.760
You create a whole set of bad data
and see how your app handles them.

00:25:49.410 --> 00:25:51.880
So I happen to have done that
for this particular application.

00:25:51.880 --> 00:25:53.530
Let's see how it handles it.

00:25:53.560 --> 00:25:55.890
Let's go back over to the demo.

00:26:05.430 --> 00:26:07.580
Okay, here's our original Zip browser.

00:26:07.760 --> 00:26:10.660
Let's run it.

00:26:10.660 --> 00:26:15.940
And here's a particular piece of
fuzzed data that we've produced.

00:26:16.000 --> 00:26:16.990
Let's try it.

00:26:17.080 --> 00:26:19.540
And boom.

00:26:19.540 --> 00:26:23.530
We get back into the debugger.

00:26:26.300 --> 00:26:29.800
And here we are at this particular line.

00:26:29.820 --> 00:26:32.980
And let's look at this directory index.

00:26:33.020 --> 00:26:37.540
And it looks like directory index
is some completely wild value.

00:26:37.560 --> 00:26:40.520
Well, it turns out the directory
index is a value that we

00:26:40.520 --> 00:26:42.680
happen to get out of the file.

00:26:42.700 --> 00:26:43.730
And we trusted it.

00:26:43.760 --> 00:26:46.760
What were we thinking?

00:26:46.760 --> 00:26:49.140
So what are we going to do about this?

00:26:49.840 --> 00:26:54.980
What we're going to do about
this is introduce some paranoia.

00:26:56.210 --> 00:26:59.210
Here's our updated document.

00:26:59.290 --> 00:27:03.340
And here is the method we were
looking at a little before,

00:27:03.450 --> 00:27:06.590
an updated version of the application.

00:27:06.910 --> 00:27:10.700
This reads the entries
from the zip archive.

00:27:10.780 --> 00:27:15.610
And then whenever it reads a value,
it checks it every possible way.

00:27:16.110 --> 00:27:21.340
Now remember that integral arithmetic
can cause values to wrap around,

00:27:21.340 --> 00:27:25.640
so you need to check everything not
only to make sure to take it above,

00:27:25.640 --> 00:27:28.690
but also check it below because
it might have wrapped around.

00:27:28.790 --> 00:27:33.590
You check and make sure every value
is same before you ever try to use it.

00:27:34.310 --> 00:27:41.140
You might worry a bit about performance
with adding all these extra checks.

00:27:41.170 --> 00:27:42.480
Well, there are a couple answers to that.

00:27:42.610 --> 00:27:46.460
First of all,
first answer is that you shouldn't

00:27:46.460 --> 00:27:51.770
worry too much about your performance
if your app wants crashing.

00:27:51.770 --> 00:27:51.770
The second one...

00:27:52.360 --> 00:27:56.290
The second one is that these
sorts of checks don't really

00:27:56.290 --> 00:27:58.240
touch the disk anymore.

00:27:58.240 --> 00:28:00.200
They don't really use any more memory.

00:28:00.200 --> 00:28:02.330
They just use a little
bit of processor time.

00:28:02.470 --> 00:28:06.370
So they shouldn't make a great deal
of difference to your performance.

00:28:06.550 --> 00:28:08.400
And in the case of this app, they don't.

00:28:08.400 --> 00:28:15.780
So let's try this on that same
piece of data and see how it works.

00:28:17.550 --> 00:28:19.340
There's that poison piece of data.

00:28:19.480 --> 00:28:20.440
Try it.

00:28:20.560 --> 00:28:28.080
And ah, we recognize that it's bad,
and we refuse to open it.

00:28:28.210 --> 00:28:29.580
So that is security.

00:28:29.630 --> 00:28:32.600
Let's go back to the slides.

00:28:37.160 --> 00:28:38.090
And to our next topic.

00:28:38.090 --> 00:28:42.590
So the next thing I want to talk about
is localization and internationalization.

00:28:42.590 --> 00:28:46.680
Now, this is something that's very
important to Apple because we know

00:28:46.750 --> 00:28:49.280
that most of our customers are not U.S.

00:28:49.280 --> 00:28:51.100
English-only customers.

00:28:51.100 --> 00:28:54.850
And it should be important to you because
it could be that most of your customers,

00:28:54.850 --> 00:28:58.070
if you were interested in
internationalization and localization,

00:28:58.070 --> 00:29:00.810
it could be that most of your
customers would not be U.S.

00:29:00.810 --> 00:29:02.120
English-only, too.

00:29:02.120 --> 00:29:08.120
Now, in general,
internationalization is difficult.

00:29:08.120 --> 00:29:12.670
Fortunately,
what we have done in Cocoa is we have

00:29:12.670 --> 00:29:15.780
done almost all the hard work for you.

00:29:15.780 --> 00:29:20.200
It makes it easy if you just use
the classes as they're intended

00:29:20.570 --> 00:29:22.780
to be international ready.

00:29:22.850 --> 00:29:23.820
It's not free.

00:29:23.820 --> 00:29:28.480
In particular,
you still need to test your application.

00:29:28.480 --> 00:29:31.630
You need to test with your localizations.

00:29:31.800 --> 00:29:36.540
You need to test with various locales,
as we'll be discussing.

00:29:36.540 --> 00:29:41.500
You need to test with content
that comes from other places that

00:29:41.570 --> 00:29:43.640
are in many different languages.

00:29:43.700 --> 00:29:48.920
And also, international content can
stress different failure

00:29:48.920 --> 00:29:50.200
modes in your application.

00:29:50.200 --> 00:29:53.290
So things like that fuzzing testing,
you should probably do it over

00:29:53.290 --> 00:29:55.020
again with international data.

00:29:55.050 --> 00:29:56.020
There was a very good study that
showed that there was a very good

00:29:56.020 --> 00:29:58.110
study that showed that there was
a very good session yesterday on

00:29:58.140 --> 00:30:00.200
internationalizing your software.

00:30:00.200 --> 00:30:02.060
You may be able to look at that.

00:30:02.060 --> 00:30:04.310
I hope some of you intended it.

00:30:04.430 --> 00:30:07.590
Let me talk about some of
these topics specifically.

00:30:07.730 --> 00:30:10.440
So first of all, about localization.

00:30:10.510 --> 00:30:14.000
Now, the things you need to do for
localization are things that

00:30:14.110 --> 00:30:15.800
are good practice generally.

00:30:15.800 --> 00:30:17.180
You're probably already doing them.

00:30:17.300 --> 00:30:19.730
Things that you should be doing,
even if you don't have

00:30:19.740 --> 00:30:21.950
any immediate plans,
to ship localized versions

00:30:21.950 --> 00:30:22.980
of your application.

00:30:23.160 --> 00:30:26.820
These are things like putting
most of your UI into your nibs,

00:30:26.820 --> 00:30:31.490
making the nibs localized resources so
that potentially your localizers could

00:30:31.540 --> 00:30:36.020
produce localized versions of them,
making sure that all user-visible

00:30:36.020 --> 00:30:37.580
strings are localized.

00:30:37.600 --> 00:30:40.370
So the first thing you need to do
is to create a localizable string

00:30:40.370 --> 00:30:43.500
in a not-strings file that's a
localized resource in your bundle.

00:30:43.700 --> 00:30:49.320
And you need to be a little careful
about how you construct these strings.

00:30:49.380 --> 00:30:51.980
In particular,
you don't want to be making assumptions

00:30:52.470 --> 00:30:55.100
about what the strings might look like.

00:30:55.100 --> 00:30:59.870
So you shouldn't, in general,
try to programmatically construct things

00:30:59.870 --> 00:31:04.710
like construct sentences from their parts
because you don't know how that would

00:31:04.720 --> 00:31:08.500
behave in the wide variety of languages.

00:31:08.500 --> 00:31:14.000
For example, these strings here all mean,
I believe, allow editing.

00:31:14.120 --> 00:31:18.890
But if you were to try to construct
these from parts like allow and editing,

00:31:19.250 --> 00:31:21.880
maybe you wanted to construct
allow editing and deny editing,

00:31:21.880 --> 00:31:25.100
there is no way that you are going
to be able to tell in advance

00:31:25.100 --> 00:31:29.080
which of these pieces of the string
mean allow and which mean editing.

00:31:29.100 --> 00:31:32.510
So you should just use the
whole string and let your

00:31:32.510 --> 00:31:34.990
localizers handle that for you.

00:31:35.990 --> 00:31:37.200
Locale.

00:31:37.300 --> 00:31:42.740
Now, on Mac OS X we think of locale as
something different from localization.

00:31:42.800 --> 00:31:46.430
Localization is the language
that your application uses

00:31:46.510 --> 00:31:48.660
to communicate with the user.

00:31:48.770 --> 00:31:52.800
Locale has to do with the way
that the user's data is formatted.

00:31:52.940 --> 00:31:57.020
These are things like date formats,
number formats, calendars,

00:31:57.310 --> 00:31:59.030
sort and order and so forth.

00:31:59.140 --> 00:32:04.120
And the biggest thing to remember
when you're using these is to make

00:32:04.120 --> 00:32:08.210
use of the appropriate system classes,
things like NSDate formatter,

00:32:08.350 --> 00:32:09.600
NSNumber formatter.

00:32:09.740 --> 00:32:14.040
These will automatically
handle the proper formatting.

00:32:14.140 --> 00:32:14.920
You should create them.

00:32:14.920 --> 00:32:20.420
Don't try to use -- as much as possible
try to avoid hardcoded format strings.

00:32:20.520 --> 00:32:22.480
And just let these
classes do their thing.

00:32:22.480 --> 00:32:25.520
They know how the user wants
these pieces of data presented.

00:32:25.520 --> 00:32:29.040
They usually have various different
options that you can turn on and off.

00:32:29.040 --> 00:32:31.010
For different kinds of formats.

00:32:31.040 --> 00:32:33.010
Shorter formats,
longer formats and so forth.

00:32:33.070 --> 00:32:35.900
And don't make assumptions about
how they're going to end up

00:32:35.900 --> 00:32:39.040
formatting the dates or the numbers.

00:32:39.250 --> 00:32:40.950
Here are some various examples.

00:32:41.050 --> 00:32:44.980
Along the top we have
various number formats.

00:32:45.100 --> 00:32:48.030
Some of them using the
Indo-Arabic digits.

00:32:48.040 --> 00:32:51.030
Some of them using the Arabic digits.

00:32:51.040 --> 00:32:53.040
We have some date formats.

00:32:53.040 --> 00:32:56.210
In general you're not going to
be able to predict what these

00:32:56.210 --> 00:32:58.040
will look like across languages.

00:32:58.040 --> 00:32:59.040
So don't try to do it.

00:32:59.040 --> 00:33:00.370
good.

00:33:01.470 --> 00:33:02.510
Text handling.

00:33:02.630 --> 00:33:07.490
A great deal of international
data is international data in

00:33:07.490 --> 00:33:10.860
many different languages and
many different writing systems.

00:33:10.860 --> 00:33:14.800
To handle that, I shouldn't need to
mention you use Unicode.

00:33:14.800 --> 00:33:18.290
In particular, in Cocoa,
you use the classes

00:33:18.370 --> 00:33:22.470
NSString and its allies,
NSAttributedString and so forth.

00:33:22.530 --> 00:33:25.270
If you want to display these things,
you can

00:33:25.360 --> 00:33:29.630
If you want to have your users edit text,
please, I recommend using the

00:33:29.630 --> 00:33:31.340
Cocoa text system for this.

00:33:31.400 --> 00:33:35.590
We have done a lot of hard work to
make sure that international text

00:33:35.720 --> 00:33:38.990
can be displayed and edited properly.

00:33:39.460 --> 00:33:45.900
You should not just use NSString and
NSAttributedString classes,

00:33:46.020 --> 00:33:50.170
but you should make sure you use
their APIs for things like searching,

00:33:50.260 --> 00:33:53.440
sorting, casing, substrings,
and so forth.

00:33:53.510 --> 00:33:56.710
You don't want to be in a position
where you are trying to go through

00:33:56.710 --> 00:33:58.420
a string character by character.

00:33:58.640 --> 00:34:05.250
For Unicode,
that doesn't even work generally,

00:34:05.250 --> 00:34:05.250
because in Unicode,

00:34:05.730 --> 00:34:11.480
A particular visible character may be
made up of many characters in the string.

00:34:11.820 --> 00:34:15.880
There might be, for example,
a base letter and its accents

00:34:15.930 --> 00:34:18.080
as separate characters.

00:34:18.080 --> 00:34:24.290
In Korean, you might have a hangul jamul
separately that combine to form a

00:34:24.290 --> 00:34:27.720
single user visible we call graphene.

00:34:27.720 --> 00:34:33.810
So if you have to deal with strings,
in Cocoa these are referred to

00:34:33.810 --> 00:34:35.210
as composed character sequences.

00:34:35.210 --> 00:34:37.020
If you're going to take
a substring of a string,

00:34:37.210 --> 00:34:40.820
make sure it lies on composed
character sequence boundaries.

00:34:40.820 --> 00:34:43.030
And then a string has APIs for these.

00:34:43.110 --> 00:34:46.740
And finally,
don't make assumptions about how

00:34:46.800 --> 00:34:49.300
the text is going to display.

00:34:49.300 --> 00:34:50.990
Some text displays left to right.

00:34:51.000 --> 00:34:52.360
Some text displays right to left.

00:34:54.390 --> 00:34:56.620
Here's an example I've given before.

00:34:56.770 --> 00:35:01.000
So at the top, we have the characters as
they appear in the string,

00:35:01.110 --> 00:35:03.900
some English text, some Arabic text.

00:35:03.960 --> 00:35:05.620
At the bottom,
we have the glyphs as they're

00:35:05.620 --> 00:35:07.680
displayed by the text system.

00:35:07.830 --> 00:35:09.870
There isn't a one-to-one
mapping between the characters

00:35:10.230 --> 00:35:12.100
and the displayed elements.

00:35:12.160 --> 00:35:15.250
And it doesn't go uniformly
from left to right.

00:35:15.360 --> 00:35:17.850
It starts out going from left to right,
then it turns around and

00:35:17.850 --> 00:35:19.360
goes back from right to left.

00:35:19.480 --> 00:35:23.860
So you can't necessarily assume how
strings are going to be displayed.

00:35:24.810 --> 00:35:29.550
Something new we have in Snow Leopard,
talking about composed

00:35:29.610 --> 00:35:33.880
character sequences,
is a block-based API for

00:35:33.880 --> 00:35:36.090
enumerating through a string.

00:35:36.100 --> 00:35:38.360
And you can go through the
string many different ways.

00:35:38.430 --> 00:35:40.630
You can do it by composed
character sequences,

00:35:40.630 --> 00:35:44.180
by words, by sentences, by lines,
by paragraphs, just by passing different

00:35:44.240 --> 00:35:45.280
options to this API.

00:35:45.280 --> 00:35:51.700
And we have an even simpler convenience
API that just goes through a string

00:35:52.000 --> 00:35:56.360
by lines if you want to go through
the lines in a piece of text.

00:35:56.740 --> 00:36:01.110
Very simple, easy to use,
based on blocks.

00:36:01.990 --> 00:36:05.770
One last thing, encodings.

00:36:05.900 --> 00:36:09.500
And a string is what you use for
text inside your application.

00:36:09.540 --> 00:36:12.900
If you want to write something
out in persistent format,

00:36:12.900 --> 00:36:15.880
if you need to deal with anything
that goes outside your application,

00:36:15.890 --> 00:36:18.910
then you're going to need some
encoding form for the text.

00:36:18.910 --> 00:36:21.370
And of course,
we strongly recommend that you

00:36:21.370 --> 00:36:25.460
use one of the Unicode encodings,
UTF-8 or UTF-16 particularly.

00:36:27.160 --> 00:36:34.080
And a string will easily do a conversion
between any encoding that you may want

00:36:34.390 --> 00:36:37.200
and the internal form in a string.

00:36:37.200 --> 00:36:40.400
We have a specific API,
the file system representation

00:36:40.400 --> 00:36:51.110
APIs for strings that are considered
as names in the file system.

00:36:51.110 --> 00:36:51.110
UTF-8 is used for most other purposes.

00:36:51.280 --> 00:36:54.370
But you're probably going to
occasionally encounter legacy

00:36:54.530 --> 00:36:56.400
formats with other encodings.

00:36:56.470 --> 00:36:59.510
Again, you can use NSString to
do the conversion.

00:36:59.820 --> 00:37:03.770
Now, sooner or later,
you'll probably run into a case where you

00:37:03.770 --> 00:37:07.980
have some bytes that you think are text,
but you don't know what

00:37:08.070 --> 00:37:08.970
encoding they're in.

00:37:09.160 --> 00:37:11.010
But what do you do then?

00:37:11.340 --> 00:37:14.000
You have to guess.

00:37:14.150 --> 00:37:18.540
You may be able to guess something based
on the context in which the text appears.

00:37:18.620 --> 00:37:21.580
You might be able to guess
something based on its contents,

00:37:21.580 --> 00:37:22.640
maybe not.

00:37:22.680 --> 00:37:26.410
We recommend a good thing to
do is try UTF-8 first because

00:37:26.410 --> 00:37:29.960
it's a very specific encoding,
very difficult to mistake

00:37:30.040 --> 00:37:32.370
anything else for it,
very stringent.

00:37:32.370 --> 00:37:36.940
Then you might try something else
that you might have guessed based

00:37:36.940 --> 00:37:40.140
on the context in which it appears.

00:37:40.140 --> 00:37:41.950
And you might try some other fallbacks.

00:37:42.140 --> 00:37:44.720
We recommend that as
a very final fallback,

00:37:44.720 --> 00:37:48.260
you use Mac Roman because that's
always going to succeed with

00:37:48.260 --> 00:37:50.270
any random string of bytes.

00:37:50.560 --> 00:37:56.400
And, but you have to understand that if
you're going to guess the encoding,

00:37:56.400 --> 00:37:58.880
sometimes you might get it wrong.

00:37:58.880 --> 00:38:05.090
So one final thing that you can do is to
allow the user to change the encoding,

00:38:05.380 --> 00:38:11.290
to take what you have guessed and change
it to something else and reinterpret

00:38:11.620 --> 00:38:12.940
And I have an example of that.

00:38:12.940 --> 00:38:14.680
Let's go on to the demo.

00:38:14.960 --> 00:38:16.910
We'll take a look at it.

00:38:22.130 --> 00:38:27.820
So let's go back to Xcode and take
a look at our original example.

00:38:31.260 --> 00:38:34.310
And down at the bottom here,
I have a couple of

00:38:35.610 --> 00:38:36.620
international zip archives.

00:38:36.690 --> 00:38:40.410
Now, I want to say something
about the zip archive format.

00:38:41.800 --> 00:38:44.570
In spite of the fact that it is
included by reference in a couple of

00:38:44.570 --> 00:38:48.010
-- several different ISO standards,
the zip format is not

00:38:48.010 --> 00:38:49.700
itself standardized.

00:38:49.800 --> 00:38:54.700
What we have is a set of notes from the
people who implemented it originally.

00:38:54.950 --> 00:38:58.090
And up until very recently,
these notes didn't really say

00:38:58.290 --> 00:39:03.700
anything about the encoding of the
names inside the zip archive files.

00:39:03.720 --> 00:39:06.530
Originally, actually,
they used -- the first

00:39:06.530 --> 00:39:11.700
implementation used a DOS encoding,
CodePage 437.

00:39:11.820 --> 00:39:14.290
But I think in practice what
most people have done is just

00:39:14.290 --> 00:39:16.650
take their file system names,
byte for byte,

00:39:16.650 --> 00:39:19.570
copy them into the files without
worrying about encodings.

00:39:19.700 --> 00:39:23.700
So you might encounter just
about anything in there.

00:39:23.700 --> 00:39:25.690
Mac OS X uses UTF-8.

00:39:25.730 --> 00:39:28.690
And more and more things
are using UTF-8 now.

00:39:28.730 --> 00:39:33.700
Actually, the format now has a little
bit for specifying UTF-8.

00:39:33.700 --> 00:39:36.700
I don't know that anyone uses it yet,
but it's there.

00:39:36.700 --> 00:39:40.690
So this leaves us with
something of a conundrum.

00:39:40.700 --> 00:39:41.700
We have to do something about it.

00:39:41.700 --> 00:39:47.700
We have these bytes in the
document format that are names,

00:39:47.700 --> 00:39:51.700
and we don't necessarily know
what encoding they might be in.

00:39:51.700 --> 00:39:56.570
So let's see what our original
application does with one of these.

00:39:57.940 --> 00:39:59.690
And it fails to open it.

00:39:59.950 --> 00:40:02.060
Let's see what it does with this one.

00:40:02.130 --> 00:40:03.640
And it fails to open it.

00:40:03.680 --> 00:40:07.400
And the reason it does this is
because when we originally wrote this

00:40:07.400 --> 00:40:11.880
first version of the application,
it just assumes that the contents of

00:40:11.970 --> 00:40:14.620
these names are going to be UTF-8.

00:40:14.970 --> 00:40:15.990
That's what Mac OS X does.

00:40:16.060 --> 00:40:17.560
That's what it assumes.

00:40:17.560 --> 00:40:22.600
If it can't, it fails.

00:40:24.910 --> 00:40:29.540
Let's take a look at
how we can improve that.

00:40:29.570 --> 00:40:34.050
And let's go to the updated version.

00:40:35.400 --> 00:40:37.090
And try to open these same documents.

00:40:37.110 --> 00:40:39.160
Let's start with this one.

00:40:39.250 --> 00:40:41.540
And this one opens correctly.

00:40:41.540 --> 00:40:44.090
I see I have a name with a
couple of accented Es in it.

00:40:44.260 --> 00:40:48.070
And the reason it opens correctly is
because we have some fallbacks here.

00:40:48.170 --> 00:40:51.870
If UTF-8 doesn't work,
we try some other encodings.

00:40:53.080 --> 00:40:55.700
Let's try this other one.

00:40:55.930 --> 00:41:00.480
This one opens,
but it doesn't look quite right.

00:41:00.560 --> 00:41:03.500
I don't think that's really
the name that was intended.

00:41:03.690 --> 00:41:06.180
So in addition,

00:41:06.440 --> 00:41:09.050
We've used our fallbacks,
and they produce something,

00:41:09.090 --> 00:41:10.100
but it doesn't seem to be right.

00:41:10.100 --> 00:41:15.000
So we've added a Reopen with
Encoding menu to this application,

00:41:15.000 --> 00:41:16.390
so we can try a different encoding.

00:41:16.400 --> 00:41:18.600
UTF-8 is the default.

00:41:18.730 --> 00:41:20.060
Let's try Windows.

00:41:20.270 --> 00:41:23.100
No, that doesn't seem right.

00:41:23.240 --> 00:41:25.200
Try that old DOS encoding.

00:41:25.330 --> 00:41:27.800
That still doesn't look quite right.

00:41:28.390 --> 00:41:29.790
Maybe Mac?

00:41:29.840 --> 00:41:31.130
No.

00:41:31.180 --> 00:41:35.180
I think maybe it's a Japanese file,
so let's try some Japanese encodings.

00:41:35.260 --> 00:41:37.830
That one doesn't look right.

00:41:38.040 --> 00:41:40.020
Hey, that one looks pretty good.

00:41:40.040 --> 00:41:43.070
OK,
so we've given the user the ability to

00:41:43.070 --> 00:41:47.700
correct our guess if the guess was wrong.

00:41:47.700 --> 00:41:51.010
Let's see how that works, the code.

00:41:53.440 --> 00:41:58.570
So we're back to the method that reads
the entries out of the zip archive.

00:41:58.740 --> 00:42:01.870
And here's where we're
interpreting the name.

00:42:02.320 --> 00:42:06.120
So we start off,
each document has an encoding.

00:42:06.140 --> 00:42:07.580
The default encoding is UTF-8.

00:42:07.580 --> 00:42:09.740
We start off by interpreting it,
trying to interpret the

00:42:09.740 --> 00:42:11.260
data without encoding.

00:42:11.270 --> 00:42:14.380
If that doesn't work,
we use the file system representation,

00:42:14.380 --> 00:42:16.800
which is a form of UTF-8.

00:42:16.800 --> 00:42:22.350
If that still doesn't work,
we'll try the standard Windows Latin.

00:42:23.090 --> 00:42:23.990
and Cody.

00:42:24.110 --> 00:42:27.440
And as a final ultimate fallback,
we fall back to Mac Roman,

00:42:27.440 --> 00:42:31.240
as we know that always succeeds.

00:42:31.310 --> 00:42:33.810
And how about the reopening?

00:42:36.290 --> 00:42:42.100
We've added some support
for an action method,

00:42:42.100 --> 00:42:43.630
reopen with encoding.

00:42:43.730 --> 00:42:49.180
And what this method does is,
first of all, remember that all the file

00:42:49.180 --> 00:42:54.390
operations for this document take
place on our operation queue.

00:42:54.390 --> 00:42:58.100
So if the document is still being
-- in the process of being read,

00:42:58.100 --> 00:43:00.360
we have to stop that and
wait until it's done.

00:43:00.360 --> 00:43:04.270
And then we're going to try to
re-read it using a different encoding.

00:43:04.270 --> 00:43:08.350
And the way I chose to do
this was to make the encoding

00:43:08.870 --> 00:43:11.270
as the tag on the menu item.

00:43:11.350 --> 00:43:17.560
And so we set the document's
encoding to that specified encoding,

00:43:17.570 --> 00:43:20.600
and then we reopen the document
using the standard read method,

00:43:20.890 --> 00:43:23.830
which goes back through
and then reads the document

00:43:24.250 --> 00:43:26.780
again using the new encoding.

00:43:26.820 --> 00:43:31.060
And that is how we enable support
for these different encodings.

00:43:31.060 --> 00:43:39.980
And then we're going to go ahead and run
the process of re-reading the document.

00:43:39.980 --> 00:43:41.280
And then,

00:43:41.790 --> 00:43:44.860
You remember that we had
some numbers in there.

00:43:44.960 --> 00:43:50.760
And you'll remember the way we
were presenting those numbers,

00:43:50.760 --> 00:43:55.870
we were using present-half
style formatting with percent,

00:43:55.910 --> 00:43:56.350
and ultimately

00:43:57.700 --> 00:43:59.760
These are numbers that are going
to be presented to the user.

00:43:59.860 --> 00:44:02.680
So we want to make sure they're
properly formatted for that.

00:44:02.840 --> 00:44:06.170
So for that,
we use an NSNumber formatter.

00:44:06.520 --> 00:44:09.120
So I've created code that
creates an NSNumber format

00:44:09.120 --> 00:44:11.870
or sets an appropriate style,
decimal

00:44:13.210 --> 00:44:16.900
And I decided to not use
the grouping separator.

00:44:17.130 --> 00:44:20.000
The grouping separator is
like a comma in English usage.

00:44:20.000 --> 00:44:23.500
Some other places,
a period is a thousand separator.

00:44:23.600 --> 00:44:27.010
And then for each of these numbers,
we're just calling string from

00:44:27.010 --> 00:44:29.560
number to get an appropriate
string from that formatter.

00:44:29.560 --> 00:44:33.960
And then in our methods
that produce these strings

00:44:33.960 --> 00:44:36.180
that we're going to display,
first of all,

00:44:36.180 --> 00:44:38.040
we make sure they're localized.

00:44:38.040 --> 00:44:42.100
And this localized string makes
sure that these format strings

00:44:42.100 --> 00:44:43.080
come from a localized string.

00:44:43.100 --> 00:44:45.330
So we've got a localizable.strings file.

00:44:45.440 --> 00:44:48.560
And then we use present at as a format.

00:44:48.600 --> 00:44:52.780
And in it, we get the string value that
we got from a number formatter.

00:44:52.780 --> 00:44:56.640
That makes sure that the numbers are
properly formatted for international use.

00:44:56.640 --> 00:44:59.810
So let's go back to the slides.

00:45:03.400 --> 00:45:04.920
And on to our next topic.

00:45:05.000 --> 00:45:07.060
The next topic is usability.

00:45:07.160 --> 00:45:09.620
Now, this is a very broad topic,
and everybody has their

00:45:09.620 --> 00:45:11.080
own opinions about it.

00:45:11.240 --> 00:45:14.840
But in general,
what happens is that most applications

00:45:15.320 --> 00:45:18.730
are going to be originally developed
and used by a small group of people

00:45:18.740 --> 00:45:20.180
who know the app really well.

00:45:20.180 --> 00:45:23.440
And in order to understand
more about their usability,

00:45:23.440 --> 00:45:27.400
you need to see how they are used
by larger groups of people who

00:45:27.410 --> 00:45:31.740
may work in many different ways,
people who don't necessarily

00:45:31.740 --> 00:45:32.900
know the app really well.

00:45:33.300 --> 00:45:37.670
So you should try your app out with
groups of people and see what they do,

00:45:37.790 --> 00:45:40.300
see what they understand,
see what they don't understand.

00:45:40.480 --> 00:45:45.720
Pay particular attention to the
defining features of the Mac interface,

00:45:46.150 --> 00:45:51.870
simplicity of interface with direct
manipulation at the heart of it.

00:45:52.160 --> 00:45:55.990
And when you find that you can do
something automatically for your users,

00:45:56.060 --> 00:45:57.910
you may provide a way
for them to opt out.

00:45:58.040 --> 00:45:59.000
It's a good idea to do it.

00:45:59.330 --> 00:46:03.220
We spent a lot of effort, for example,
making sure that you can do things

00:46:03.220 --> 00:46:06.720
like saving state so when your users
come back into your application,

00:46:06.720 --> 00:46:09.930
it's easier for them to
get back where they were.

00:46:10.140 --> 00:46:12.450
Now, there are a lot of things
that I could show for this,

00:46:12.480 --> 00:46:13.850
but I picked one.

00:46:13.930 --> 00:46:17.820
And let's go over to the demo machine,
and I'll take a look at the one

00:46:17.830 --> 00:46:20.380
thing that I decided to show here.

00:46:23.840 --> 00:46:28.940
Let's go to our original application,
launch it again, run it,

00:46:28.940 --> 00:46:32.400
open a zip archive.

00:46:32.400 --> 00:46:32.400
Now,

00:46:32.990 --> 00:46:38.300
One thing I know is that Mac users
being used to direct manipulation,

00:46:38.400 --> 00:46:42.380
when they see something like this,
they're going to want to try and

00:46:42.380 --> 00:46:45.370
pick up this thing and drag it.

00:46:45.880 --> 00:46:46.920
You know, it doesn't drag.

00:46:46.990 --> 00:46:48.550
I can't drag this thing
out to the desktop.

00:46:48.560 --> 00:46:53.000
I didn't add support for
drag out of my application.

00:46:53.150 --> 00:46:54.880
So let's do it.

00:46:56.590 --> 00:46:58.130
Let's go into Xcode.

00:46:58.210 --> 00:47:01.560
Let's take a look at the updated
version of the application.

00:47:01.560 --> 00:47:06.300
And let's see what we needed to do in
order to add drag and drop support.

00:47:06.320 --> 00:47:08.000
Let's go into the document class.

00:47:08.000 --> 00:47:11.280
And now there are several
different code paths for this,

00:47:11.420 --> 00:47:14.500
depending on exactly where
you're dragging from.

00:47:14.500 --> 00:47:18.000
But I'm going to show you how you
add dragging support using the

00:47:18.000 --> 00:47:20.350
browser with the new item-based API.

00:47:20.360 --> 00:47:23.380
And that's very simple.

00:47:23.380 --> 00:47:25.120
We have a few methods.

00:47:25.170 --> 00:47:26.480
One of them is canDrag.

00:47:26.500 --> 00:47:30.460
And I decided to implement
dragging of just a single item,

00:47:30.460 --> 00:47:32.640
if a single item is selected.

00:47:32.640 --> 00:47:37.400
And I implemented a common method
that returns the entry that is

00:47:37.400 --> 00:47:42.510
selected if dragging is allowed
for that particular selection.

00:47:44.340 --> 00:47:49.460
And then you get to provide
an image for the drag.

00:47:49.470 --> 00:47:53.040
And I chose to use that
icon from NS Workspace.

00:47:53.040 --> 00:47:56.770
It's the same thing which
we're showing in the view.

00:47:56.880 --> 00:48:01.710
And so I get the entry,
and I get the icon from NS Workspace.

00:48:01.730 --> 00:48:03.880
And I return it.

00:48:06.530 --> 00:48:14.400
Then, when eventually we're going to be
called to actually write these things

00:48:14.400 --> 00:48:15.820
out to the pasteboard for dragging.

00:48:15.820 --> 00:48:19.710
And for dragging to the finder,
I'm using the file

00:48:19.710 --> 00:48:21.060
promise pasteboard type.

00:48:21.110 --> 00:48:25.140
I'm going to be really lazy about
doing my pasteboard operations.

00:48:25.160 --> 00:48:31.050
With the file promise pasteboard type,
all you do at the original

00:48:31.050 --> 00:48:35.400
drag time is you declare types,
including the file's promise types.

00:48:35.600 --> 00:48:38.250
And for the file promise types,
you add an array.

00:48:38.360 --> 00:48:41.460
And the only contents of the
array are the type of the file.

00:48:41.890 --> 00:48:50.430
You don't have to write the file
out until it's actually dropped.

00:48:50.430 --> 00:48:50.430
And then when it's actually dropped,

00:48:54.630 --> 00:49:01.760
We got another browser-delicate
method that-- sorry.

00:49:04.220 --> 00:49:06.860
that calls on us to redeem our promise.

00:49:06.860 --> 00:49:10.140
It's called names of promised
files dropped at destination,

00:49:10.200 --> 00:49:17.410
which means we have to write the
file out in the destination folder.

00:49:17.590 --> 00:49:22.080
And I implemented a
method that does that.

00:49:22.400 --> 00:49:25.240
Write drag rows with indexes.

00:49:25.680 --> 00:49:31.670
That does the writing of the file,
the entry in the archive.

00:49:32.030 --> 00:49:33.700
Actually, it doesn't do it.

00:49:33.940 --> 00:49:38.640
Remember that all the file
access in this class has been

00:49:38.660 --> 00:49:41.420
sent to our operation queue.

00:49:41.580 --> 00:49:46.300
So what this method does is create
an operation and put it on the queue.

00:49:46.370 --> 00:49:49.400
We create a write operation.

00:49:49.400 --> 00:49:52.720
And again, this is a trivial
subclass of NS4 operation.

00:49:52.720 --> 00:49:56.830
All it does is call back into the
document as a particular method.

00:49:57.040 --> 00:49:59.190
Let me show you that method.

00:50:03.900 --> 00:50:06.200
There's the write entry method.

00:50:06.210 --> 00:50:09.400
And what this will do,
it'll be called on the operation queue,

00:50:09.420 --> 00:50:14.000
and its job is to take that
entry in the zip archive.

00:50:14.030 --> 00:50:16.140
It may be compressed,
and if it's compressed,

00:50:16.190 --> 00:50:19.020
it'll have to expand it,
and then write it out

00:50:19.020 --> 00:50:20.840
to our destination URL.

00:50:20.840 --> 00:50:26.230
So remember, again,

00:50:27.490 --> 00:50:30.960
We take a look at every value
that we get out of the file,

00:50:30.970 --> 00:50:33.460
and we treat it with
the utmost suspicion.

00:50:33.560 --> 00:50:35.860
We have to check it above and
below and make sure it makes sense

00:50:35.930 --> 00:50:38.300
before we do anything with it.

00:50:38.450 --> 00:50:40.770
If we think it makes sense,

00:50:41.350 --> 00:50:47.500
Then we are going to take a look and
get the actual data out of the archive.

00:50:48.340 --> 00:50:50.560
As I said, it might be compressed,
it might not be.

00:50:50.560 --> 00:50:52.520
If it's not compressed,
we simply write it out.

00:50:52.570 --> 00:50:56.480
If it is compressed,
we're using the libz here

00:50:56.480 --> 00:50:57.770
to do the uncompression.

00:50:57.770 --> 00:51:01.500
And it has a fairly straightforward API.

00:51:01.500 --> 00:51:06.270
In this case, we're uncompressing it
out into another data,

00:51:06.300 --> 00:51:07.860
immutable data.

00:51:07.860 --> 00:51:13.000
And we were sure to check all the return
values to make sure they make sense.

00:51:13.000 --> 00:51:15.890
There's actually a CRC value.

00:51:15.890 --> 00:51:18.280
So we check the CRC in each case.

00:51:18.300 --> 00:51:21.640
To make sure that it agrees
with the values of the store.

00:51:21.640 --> 00:51:23.210
And if it's not,
we don't trust that data.

00:51:23.210 --> 00:51:26.020
And then we write it out to our file.

00:51:29.470 --> 00:51:32.980
And let's see how that works.

00:51:33.060 --> 00:51:35.020
Launch and run.

00:51:35.130 --> 00:51:37.840
Open up the zip archive again.

00:51:38.460 --> 00:51:39.340
Take a look.

00:51:39.370 --> 00:51:40.960
Try to drag it out.

00:51:41.000 --> 00:51:42.260
It's going.

00:51:42.270 --> 00:51:43.400
Now we're on the desktop.

00:51:43.410 --> 00:51:43.770
Let it go.

00:51:43.820 --> 00:51:44.290
There it is.

00:51:44.320 --> 00:51:46.320
Let's make sure that file's really there.

00:51:46.320 --> 00:51:47.180
Open it up.

00:51:47.180 --> 00:51:48.120
There it is.

00:51:48.120 --> 00:51:51.460
So our drag and drop works.

00:51:55.920 --> 00:52:01.220
Let's go back to the slides.

00:52:01.220 --> 00:52:05.350
And the next topic I want to deal
with is scripting and accessibility.

00:52:05.400 --> 00:52:08.290
But in order to do that,
I've asked our accessibility guru,

00:52:08.290 --> 00:52:11.820
James Dempsey,
to come up and talk about that for us.

00:52:11.820 --> 00:52:13.940
So welcome, James.

00:52:20.170 --> 00:52:22.910
Thank you very much, Doug.

00:52:23.080 --> 00:52:28.240
So usually when we think about users
interacting with our applications,

00:52:28.240 --> 00:52:32.250
we think about them with an
input device and mouse events,

00:52:32.530 --> 00:52:35.560
key events,
multi-touch gesture events even.

00:52:35.560 --> 00:52:39.550
But on Mac OS X,
there are two additional ways that users

00:52:39.550 --> 00:52:44.880
can interact with your applications,
scripting and accessibility.

00:52:44.880 --> 00:52:51.270
And in fact, it's two ways that users can
interact with your application

00:52:52.040 --> 00:52:54.840
from a separate process.

00:52:54.930 --> 00:52:56.640
And so here we have your application.

00:52:57.020 --> 00:52:59.770
And let's say the user
starts running a script.

00:53:00.410 --> 00:53:06.690
And using inter-process communications,
they're driving your application.

00:53:08.420 --> 00:53:10.650
And from accessibility,
it's the same way.

00:53:10.940 --> 00:53:16.500
We call an application or process using
accessibility an assistive application.

00:53:16.590 --> 00:53:21.290
And through IPC,
it can also drive your application.

00:53:21.710 --> 00:53:24.760
Let's take a little bit closer
look at your application.

00:53:24.870 --> 00:53:30.230
We'll go down to a kind of well-factored
Cocoa app with model view and controller.

00:53:31.300 --> 00:53:38.320
So scripting, the IPC method that it
uses is Apple Events.

00:53:38.380 --> 00:53:41.360
And your application provides
a scripting dictionary,

00:53:41.360 --> 00:53:46.120
which is essentially a set of
classes and commands that are

00:53:46.120 --> 00:53:49.680
a scripting representation of
the model in your application.

00:53:49.680 --> 00:53:52.350
And so when a user is
scripting your application,

00:53:52.450 --> 00:53:56.250
they're interacting with your app,
driving it through the model.

00:53:57.940 --> 00:54:03.970
With accessibility and
assistive application,

00:54:03.970 --> 00:54:03.970
the IPC mechanism that it's using,

00:54:04.380 --> 00:54:10.240
Our Mac OS X's accessibility client APIs,
the AX APIs.

00:54:10.300 --> 00:54:16.380
And an assistive application is
getting information about and driving

00:54:16.380 --> 00:54:19.460
your application through the view.

00:54:20.760 --> 00:54:25.860
So they both drive your
app from another process,

00:54:25.930 --> 00:54:27.830
but they do so in very different ways.

00:54:28.150 --> 00:54:31.070
And they do that because
scripting and accessibility,

00:54:31.080 --> 00:54:36.340
while similar in some respects,
have very different purposes on Mac OS X.

00:54:36.530 --> 00:54:38.900
Let's talk about scriptability first.

00:54:38.920 --> 00:54:42.720
It's the foundation for building
automated workflows on Mac OS X.

00:54:42.720 --> 00:54:47.760
And since workflows,
taking some data from one application,

00:54:47.860 --> 00:54:51.490
moving it along from app to app,
processing it along the way,

00:54:51.500 --> 00:54:54.620
it's a very data-centric activity.

00:54:54.620 --> 00:55:00.160
It makes a lot of sense that scripting
deals with the model of your application.

00:55:00.160 --> 00:55:03.450
It's not about selecting this
menu or it's about grabbing the

00:55:03.450 --> 00:55:06.450
people out of your address book,
doing something with them

00:55:06.710 --> 00:55:08.600
in this word processor,
doing something else

00:55:08.600 --> 00:55:09.600
with them in a database.

00:55:12.910 --> 00:55:15.620
Scriptability, as you might imagine,
gives users a great deal of

00:55:15.620 --> 00:55:20.120
flexibility to work your application
into all kinds of workflows,

00:55:20.120 --> 00:55:23.680
things you might not have even imagined
your application would be used for.

00:55:23.680 --> 00:55:27.980
Now, back at the turn of the century,
scriptability essentially

00:55:28.090 --> 00:55:30.290
meant users using AppleScript.

00:55:30.420 --> 00:55:35.740
But since the turn of the century,
we have a lot of additions to this.

00:55:35.830 --> 00:55:38.080
When you make your
application scriptable,

00:55:38.160 --> 00:55:42.360
that also forms the basis for you
to provide automator actions so that

00:55:42.360 --> 00:55:46.300
users of automator can build kind
of higher-level automated workflows.

00:55:46.300 --> 00:55:50.880
And with the Apple Event Bridge,
not only AppleScript as a language,

00:55:50.880 --> 00:55:55.700
but use Ruby or Python or even a
compiled language like Objective-C.

00:55:57.310 --> 00:56:00.380
Now, we don't have a great deal of
time in this session to get

00:56:00.480 --> 00:56:02.830
into making your app scriptable.

00:56:02.990 --> 00:56:06.760
But fortunately-- oh,
I forgot one small point,

00:56:06.910 --> 00:56:09.670
which is scriptability is
a feature you implement.

00:56:09.940 --> 00:56:14.280
Your application opts
in to scriptability.

00:56:14.810 --> 00:56:19.650
And we do have a session just happened,
but it'll be coming out on your

00:56:19.650 --> 00:56:24.440
IDC on iTunes subscription,
Making Your Application Scriptable.

00:56:24.440 --> 00:56:28.080
I highly recommend taking a
look at that session and doing

00:56:28.080 --> 00:56:29.660
just what its title says.

00:56:32.230 --> 00:56:36.760
So if scriptability and
scripting deals with your model,

00:56:36.760 --> 00:56:40.980
and it kind of makes sense why,
why does anybody need

00:56:40.980 --> 00:56:43.420
access to my view anyway?

00:56:44.200 --> 00:56:48.640
So what I'd like you to do is just
consider for a moment the case of

00:56:48.640 --> 00:56:51.770
a user with a visual disability.

00:56:52.900 --> 00:56:56.660
Trying to use a graphical user interface.

00:56:56.660 --> 00:57:00.440
The user is unable to see
what is on the screen.

00:57:00.440 --> 00:57:04.760
And so that user needs to have what's
going on in the interface described.

00:57:04.760 --> 00:57:08.260
They need to be able to navigate
and interact with applications

00:57:08.260 --> 00:57:10.040
without using the mouse.

00:57:10.040 --> 00:57:13.130
And they also need to get
notified when things change,

00:57:13.130 --> 00:57:16.150
like when windows and sheets come and go.

00:57:17.040 --> 00:57:21.510
And so the primary purpose of the
Accessibility API is to provide

00:57:22.380 --> 00:57:25.940
users with this alternate interface.

00:57:26.010 --> 00:57:31.440
Now Mac OS X ships a built-in screen
reader application called VoiceOver.

00:57:31.530 --> 00:57:33.480
It's been shipping since Tiger.

00:57:33.560 --> 00:57:37.560
But there are also many other third-party
applications that use the Accessibility

00:57:37.560 --> 00:57:41.570
API to provide this alternate interface.

00:57:43.020 --> 00:57:46.880
Now the way it works is it's a
collaboration between two processes,

00:57:47.010 --> 00:57:50.500
your application and the
assistive application.

00:57:50.640 --> 00:57:54.690
So your application provides
accessibility information about

00:57:54.690 --> 00:57:58.680
what's going on in the UI,
and then an assistive app like

00:57:58.880 --> 00:58:03.430
VoiceOver takes that information
and presents a unified,

00:58:03.930 --> 00:58:07.730
specialized interface for users.

00:58:08.660 --> 00:58:14.420
Now, this is a public API,
and in addition to its primary purpose,

00:58:14.540 --> 00:58:17.600
there are other uses of
that accessibility API.

00:58:17.600 --> 00:58:22.860
So if you've seen demos in
Instruments or Automator,

00:58:22.860 --> 00:58:26.340
there's a record and playback
of the interface feature.

00:58:26.340 --> 00:58:28.740
That is using accessibility.

00:58:28.740 --> 00:58:33.670
GUI scripting is using accessibility,
which is a handy way to build

00:58:33.670 --> 00:58:38.150
automated user interface test
suites for your application.

00:58:38.810 --> 00:58:44.530
And then numbers of third-party apps
and utilities also use this API.

00:58:46.640 --> 00:58:52.000
Now, not everybody realizes it,
even Cocoa developers that may have

00:58:52.000 --> 00:58:56.130
been around the block a few times,
that it's not opt-in.

00:58:56.180 --> 00:58:58.630
Your application,
if it's out there in the world,

00:58:58.630 --> 00:59:01.460
it's already reporting
accessibility information.

00:59:01.460 --> 00:59:05.600
VoiceOver users have already
downloaded it and taken a look.

00:59:05.720 --> 00:59:10.640
And if you've done no
accessibility work on your app,

00:59:10.790 --> 00:59:13.780
then the results will be somewhat good,
bad, or ugly.

00:59:13.780 --> 00:59:17.070
But if you've done no
accessibility work at all,

00:59:17.070 --> 00:59:18.810
there'll be your share of ugly in there.

00:59:18.820 --> 00:59:22.960
So let's talk about how
we would address that.

00:59:24.520 --> 00:59:27.810
Actually, before we do that,
one more point about

00:59:27.810 --> 00:59:31.500
application accessibility,
which is, what is this information that

00:59:31.500 --> 00:59:32.840
my app's already given out?

00:59:32.910 --> 00:59:34.360
I didn't even know it was.

00:59:34.360 --> 00:59:35.880
What's going on?

00:59:35.910 --> 00:59:40.450
It's a lightweight representation
of your user interface.

00:59:40.450 --> 00:59:43.930
So that accessibility
client gets a small thing,

00:59:44.050 --> 00:59:47.440
a UI element ref,
which is essentially a small token

00:59:47.640 --> 00:59:53.760
or a small proxy back to a real user
interface element in your application.

00:59:53.770 --> 00:59:57.460
Each of these little UI elements
that the accessibility client has

00:59:57.460 --> 01:00:01.980
has a particular role that lets
you know what the type of thing is.

01:00:01.980 --> 01:00:06.460
Is it the application itself, a window,
a button?

01:00:06.460 --> 01:00:13.680
And this forms a hierarchy of user
interface elements that describe your UI.

01:00:13.680 --> 01:00:17.900
Now what does that map back
to in your application?

01:00:18.330 --> 01:00:25.430
It maps back to actual NSObjects
and NSObjects subclasses.

01:00:25.570 --> 01:00:29.750
That accessibility information is
provided by objects that implement

01:00:29.750 --> 01:00:32.240
the NSAccessibility protocol.

01:00:32.350 --> 01:00:34.420
Now,
all the heavy hitters in AppKit already

01:00:34.620 --> 01:00:40.450
implement this application,
NSWindow, NSCell, NSView, NSControl.

01:00:40.670 --> 01:00:43.800
And so in AppKit,
there's already a great deal

01:00:43.800 --> 01:00:46.840
of accessibility built in.

01:00:46.930 --> 01:00:51.790
So you're already getting a good
default amount of accessibility.

01:00:52.970 --> 01:00:55.420
However, there's always more to be done.

01:00:55.420 --> 01:00:57.550
There's always a little
more you can provide.

01:00:57.560 --> 01:01:00.850
So some examples are,
if there are images in

01:01:00.900 --> 01:01:04.640
your user interface,
it's easy for us to describe a button

01:01:04.730 --> 01:01:06.790
to somebody if it has a text title.

01:01:06.800 --> 01:01:11.300
But if it's a picture of something,
we don't know what that something is.

01:01:11.300 --> 01:01:15.130
We need you to go into Interface Builder,
select that button,

01:01:15.130 --> 01:01:19.940
type in a title in the accessibility
inspector portion of the inspector.

01:01:20.810 --> 01:01:25.580
Connecting related UI elements like what
text fields go with what static text.

01:01:25.600 --> 01:01:28.010
Full keyboard navigation.

01:01:28.020 --> 01:01:34.950
A user who has a visual disability
isn't able to use the mouse.

01:01:35.040 --> 01:01:37.940
They need to use the keyboard
to get everything done.

01:01:37.940 --> 01:01:40.340
And then finally,
if you've created a custom

01:01:40.340 --> 01:01:43.980
view or a custom control,
the default work we can do

01:01:44.050 --> 01:01:46.520
in the kit only goes so far.

01:01:46.520 --> 01:01:49.920
We don't know what you're doing
in that control or that view.

01:01:50.420 --> 01:01:53.550
So you need to provide the
accessibility information for us.

01:01:53.640 --> 01:01:57.000
And the tools you can use
to test that accessibility,

01:01:57.000 --> 01:02:00.640
accessibility inspector,
accessibility verifier,

01:02:00.640 --> 01:02:05.580
or turning on voiceover and navigating
around to see how your app appears.

01:02:07.180 --> 01:02:08.290
in VoiceOver.

01:02:08.430 --> 01:02:10.610
Now,
we're just scratching the surface here.

01:02:10.750 --> 01:02:15.520
I would very much encourage you to take
a look at the application accessibility

01:02:15.880 --> 01:02:18.220
session from earlier this week.

01:02:18.220 --> 01:02:21.300
But for now,
I'd like to show a little demo.

01:02:24.400 --> 01:02:39.500
[Transcript missing]

01:02:49.800 --> 01:02:52.860
And in the doc is
Accessibility Inspector.

01:02:52.970 --> 01:02:56.040
And as I point to various
things on the screen,

01:02:56.130 --> 01:03:01.580
it uses the Accessibility API to give
me information about those elements.

01:03:01.710 --> 01:03:05.220
And so if I take a look at the window,
I'm getting a lot of

01:03:05.220 --> 01:03:09.090
information about its size,
its position, et cetera.

01:03:09.460 --> 01:03:13.680
If I look within the view,
all of the standard controls I'm seeing,

01:03:13.680 --> 01:03:16.280
okay, these are all nicely accessible.

01:03:16.300 --> 01:03:22.780
If I go to our custom view, however,
you'll notice it doesn't believe

01:03:22.780 --> 01:03:25.420
anything is there at all.

01:03:26.610 --> 01:03:30.690
And so what I'm going to do is let's
take a look at how we'd fix that in code.

01:03:30.730 --> 01:03:35.710
Let me close the inspector here.

01:03:38.900 --> 01:03:47.150
Now if we just peek very quickly
at what that custom view is,

01:03:48.510 --> 01:03:50.400
Let's see.

01:03:50.400 --> 01:03:53.900
Go to draw rect.

01:03:54.750 --> 01:03:59.160
And you'll notice here that
it's a fairly simple draw rect.

01:03:59.260 --> 01:04:02.990
However, I mentioned that what we would
like -- or I didn't mention --

01:04:03.120 --> 01:04:06.820
what we would like to happen is for
that image to show up as an image,

01:04:06.820 --> 01:04:12.260
each of those static elements in the
inspector to show up as static text.

01:04:12.260 --> 01:04:16.620
Yet we don't have an object
on the back end to implement

01:04:16.710 --> 01:04:19.590
the NS Accessibility Protocol.

01:04:19.910 --> 01:04:22.940
So we have two options.

01:04:22.940 --> 01:04:28.710
We could either create some NSObject
subclasses whose only job in life

01:04:28.710 --> 01:04:32.690
is to implement the Accessibility
Protocol and report the correct

01:04:32.690 --> 01:04:38.040
information for those classes,
or we could take another approach,

01:04:38.040 --> 01:04:43.870
which is let's take our custom view and
replace it with standard Cocoa views.

01:04:43.870 --> 01:04:47.720
Because this custom view
isn't doing a great deal.

01:04:47.770 --> 01:04:50.430
It's just a view,
and then from that view it's drawing

01:04:50.430 --> 01:04:53.000
an image and a few pieces of text.

01:04:53.000 --> 01:04:56.180
If we were to replace that with
a view that just had an image

01:04:56.180 --> 01:05:00.240
view and some text fields in it,
we would pick up the

01:05:00.260 --> 01:05:02.460
accessibility for free.

01:05:03.270 --> 01:05:09.240
So sometimes the best way to implement
accessibility is to just use kit classes.

01:05:09.240 --> 01:05:13.560
To that end, let's go with that approach.

01:05:15.840 --> 01:05:22.800
So I'm now going to switch over to after,
do a build and go.

01:05:27.600 --> 01:05:47.900
[Transcript missing]

01:05:55.000 --> 01:05:57.900
Set our inspector up.

01:05:57.900 --> 01:06:00.540
And you'll notice now we
are getting an AX image,

01:06:00.540 --> 01:06:03.160
we are getting a static text,
and so we are reporting

01:06:03.160 --> 01:06:06.060
accessibility information.

01:06:06.060 --> 01:06:08.000
And that's all I have.

01:06:08.000 --> 01:06:13.430
Back to slides, please.

01:06:21.510 --> 01:06:24.620
So here are some take-home points.

01:06:24.650 --> 01:06:26.580
Once you've got your
application up and running,

01:06:26.580 --> 01:06:29.460
there's usually a lot more to be done.

01:06:29.980 --> 01:06:32.910
Important thing is to test
your application with a wide

01:06:32.930 --> 01:06:36.830
variety of scenarios and data,
and consider these various points:

01:06:36.930 --> 01:06:41.220
64-bit, performance, responsiveness,
security, localization,

01:06:41.380 --> 01:06:45.060
internationalization, usability,
scripting, and accessibility.

01:06:45.590 --> 01:06:48.600
For more information,
you can contact Derek Horne.

01:06:48.760 --> 01:06:50.540
We have documentation and sample code.

01:06:50.540 --> 01:06:53.520
This should be up soon as sample code.

01:06:54.860 --> 01:06:57.340
There are a number of other related
sessions that we've been discussing.

01:06:57.340 --> 01:06:59.390
Most of them have already taken place.

01:06:59.510 --> 01:07:01.730
There's a session after
this on performance and

01:07:01.730 --> 01:07:03.490
document-centric Cocoa Apps.

01:07:03.600 --> 01:07:08.130
Now, we were going to do some Q&A,
but since James is here,

01:07:08.400 --> 01:07:14.600
I thought maybe we'd get a song instead.

01:07:14.600 --> 01:07:18.500
So, let's welcome up James Dempsey
and the Breakpoints.

01:07:28.600 --> 01:07:29.040
Great.

01:07:29.260 --> 01:07:32.480
So for those of you,
from the sound of it,

01:07:32.810 --> 01:07:35.440
somebody's seen something
like this before at WWDC.

01:07:35.440 --> 01:07:38.740
And you may notice that there
are a few things missing.

01:07:38.740 --> 01:07:42.290
One, no guitars and no lead guitarist.

01:07:42.420 --> 01:07:46.310
So this year, Gordy Friedman,
who is our lead guitarist

01:07:46.320 --> 01:07:49.680
for the Breakpoints,
about a week, week and a half ago,

01:07:49.680 --> 01:07:53.280
found out he was not going to
be able to make it to WWDC.

01:07:54.840 --> 01:08:01.090
So we, through the magic of GarageBand,
he's going to be with us in

01:08:01.090 --> 01:08:02.380
both sound and in spirit.

01:08:02.380 --> 01:08:04.670
We figured since we
were mixing things up,

01:08:04.770 --> 01:08:07.380
maybe this year I'd get out from
behind the guitar as well and

01:08:07.380 --> 01:08:09.160
just try to belt one out for you.

01:08:10.550 --> 01:08:12.920
So, let's see.

01:08:13.320 --> 01:08:16.850
Oh, so I just wanted to get a
show of hands real quick.

01:08:17.010 --> 01:08:21.180
How many folks here are
pretty new to Objective-C,

01:08:21.180 --> 01:08:22.880
like in the last six months to a year?

01:08:22.880 --> 01:08:24.110
So, a few folks.

01:08:24.110 --> 01:08:24.760
Great.

01:08:24.760 --> 01:08:28.350
How many folks have been doing
Objective-C for at least a year?

01:08:28.720 --> 01:08:29.200
Awesome.

01:08:29.520 --> 01:08:31.240
Three years.

01:08:31.410 --> 01:08:33.200
Five years.

01:08:33.340 --> 01:08:36.020
How many folks are named Oli Ozer?

01:08:37.010 --> 01:08:38.480
Excellent.

01:08:38.480 --> 01:08:39.390
All seven of you.

01:08:39.390 --> 01:08:46.780
So I think it's extremely exciting
at WWDC this year because with

01:08:46.780 --> 01:08:53.210
Mac sales increasing all the time,
it seems, with the new iPhone SDK,

01:08:53.340 --> 01:08:58.340
I think this is perhaps the
time in Objective-C's history

01:08:58.340 --> 01:09:02.120
where the most new people have
been coming into the language,

01:09:02.120 --> 01:09:03.950
which I think is fantastic.

01:09:04.020 --> 01:09:07.390
What I wanted to do this year was a
little something that maybe will give

01:09:07.390 --> 01:09:10.150
a little advice to some newcomers,
but also do something

01:09:10.150 --> 01:09:13.240
that the old-timers,
I hope, will really appreciate.

01:09:13.240 --> 01:09:17.770
So without further ado, let's hit it.

01:09:28.300 --> 01:09:35.370
♪ Designated initializer ♪ ♪
It got the better of me ♪ ♪ Yeah,

01:09:35.370 --> 01:09:35.910
yeah ♪

01:09:36.300 --> 01:09:43.330
Designated Initializer Oh,
it got the better of me

01:09:43.500 --> 01:09:48.760
♪ It's a cautionary tale,
my friend ♪ ♪ I'm sure

01:09:48.760 --> 01:09:53.140
you will agree ♪ ♪ Well,
don't do what I did do ♪

01:09:53.140 --> 01:09:55.850
♪ Or it'll happen to you ♪

01:09:56.360 --> 01:10:01.600
♪ Like it happened to me ♪
Let's start at the beginning.

01:10:01.650 --> 01:10:09.100
♪ Well when you unlock a memory block
♪ ♪ It's allocated with precision ♪

01:10:09.180 --> 01:10:14.910
♪ That is a pointer's assigned ♪ ♪
So your instance can find its class's

01:10:14.910 --> 01:10:22.370
definition ♪ ♪ All the other i-vars are
filled up with zeros ♪ ♪ Thus nil-dip

01:10:22.370 --> 01:10:28.310
to objects they refer ♪ ♪ And then your
instance must wait ♪ ♪ To be put in a

01:10:28.310 --> 01:10:33.990
good state ♪ ♪ By an object initializer ♪

01:10:39.500 --> 01:10:46.200
[Transcript missing]

01:10:50.500 --> 01:11:10.000
[Transcript missing]

01:11:34.300 --> 01:11:41.720
♪ You got the better of me ♪ ♪
No I didn't forget ♪ ♪ But I did forget ♪

01:11:42.220 --> 01:11:46.240
♪ We'll get there soon,
just wait and see ♪ ♪ A class with

01:11:46.240 --> 01:11:53.590
many a nits ♪ ♪ Use the one that best
fits ♪ ♪ There's power in the variety ♪

01:11:53.910 --> 01:11:58.130
♪ I could be subclassed right
♪ ♪ Or be debugging all night

01:11:58.130 --> 01:12:01.570
♪ ♪ Like what happened to me ♪

01:12:06.200 --> 01:12:14.000
[Transcript missing]

01:12:19.500 --> 01:12:21.650
as a funnel point.

01:12:21.670 --> 01:12:24.520
Its setup logic makes it much wiser.

01:12:24.520 --> 01:12:29.230
That funnel point, well,
it passes to its superclass's

01:12:29.230 --> 01:12:31.900
designated favorite son.

01:12:31.900 --> 01:12:38.050
Though it may sound like a blooper,
the rest don't call super.

01:12:38.050 --> 01:12:40.700
They call your chosen one.

01:12:40.700 --> 01:12:43.790
Now here's what happened to me.

01:12:43.790 --> 01:12:45.960
I wrote a subclass.

01:12:45.960 --> 01:12:49.740
I initialized a set of critical states.

01:12:49.740 --> 01:12:50.930
Critical.

01:12:50.930 --> 01:12:54.780
I didn't override my
super's init methods,

01:12:54.780 --> 01:12:57.060
which was ill-advised.

01:12:57.060 --> 01:12:58.510
Ill-advised.

01:12:58.510 --> 01:13:05.400
Anyone calling those init methods doomed
the new instance to a crashing face.

01:13:05.400 --> 01:13:09.840
My superclass's code was called,
but never mind.

01:13:09.840 --> 01:13:14.760
My critical state was not initialized.

01:13:14.780 --> 01:13:19.700
I initialized that
designated initializer.

01:13:19.700 --> 01:13:22.230
It got the better of me.

01:13:22.300 --> 01:13:27.060
It was a subtle catch
with dynamic dispatch.

01:13:27.070 --> 01:13:29.700
Yeah, it got the better of me.
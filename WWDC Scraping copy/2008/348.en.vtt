WEBVTT

00:00:20.360 --> 00:00:22.540
- Okay, welcome to Cocoa Fundamentals.

00:00:22.620 --> 00:00:24.320
This is session 348.

00:00:24.560 --> 00:00:25.670
My name is Peter Ammon.

00:00:25.810 --> 00:00:28.680
I'm an engineer on the
Cocoa Frameworks team.

00:00:30.130 --> 00:00:33.590
Today we're going to answer some of
the fundamental questions about Cocoa.

00:00:33.690 --> 00:00:35.570
Right, like, what is Cocoa?

00:00:35.920 --> 00:00:38.000
And why should I use Cocoa?

00:00:38.000 --> 00:00:40.000
And how can I use Cocoa?

00:00:40.000 --> 00:00:44.530
And how do I write a program that
makes the groovy sort of Eye of Sauron

00:00:44.640 --> 00:00:49.900
type images during the 75-minute
demo portion of a Cocoa presentation?

00:00:52.890 --> 00:00:56.900
So this app is called Squiggles,
and it's a very simple app,

00:00:56.970 --> 00:00:59.360
but it'll have a lot of sort
of nice Mac-like features,

00:00:59.360 --> 00:00:59.840
right?

00:00:59.840 --> 00:01:01.130
It'll support multiple documents.

00:01:01.220 --> 00:01:04.980
You can save a document and reopen
it so you can work on it later.

00:01:05.030 --> 00:01:08.770
It will have support for lots, you know,
multiple levels of undo and redo.

00:01:09.040 --> 00:01:13.340
It'll have a nice,
resizable window and a lot more.

00:01:13.350 --> 00:01:16.790
And what's great about Cocoa is
these features are really easy.

00:01:16.840 --> 00:01:18.460
And sometimes they're automatic.

00:01:18.490 --> 00:01:20.460
You get them for free.

00:01:21.890 --> 00:01:25.330
And a corollary of this is,
if it seems too hard,

00:01:25.400 --> 00:01:34.570
you may be doing it wrong.

00:01:34.790 --> 00:01:34.790
Right?

00:01:34.790 --> 00:01:34.790
If, if, uh, excuse me.

00:01:36.940 --> 00:01:40.850
This slide went away.

00:01:40.950 --> 00:01:41.240
Right.

00:01:41.310 --> 00:01:43.470
When something seems more
difficult than it needs to be,

00:01:43.560 --> 00:01:45.400
we refer to that as
fighting the framework.

00:01:45.400 --> 00:01:53.660
And when you're fighting the framework,
that's a good indication that you need

00:01:53.660 --> 00:01:53.660
to take a step back and think about the
way you're designing your application.

00:01:55.570 --> 00:01:57.000
So, what is Cocoa?

00:01:57.000 --> 00:02:01.830
Well, Cocoa is an object-oriented
application framework.

00:02:01.900 --> 00:02:02.950
What's a framework?

00:02:03.140 --> 00:02:05.380
Well, a framework is something
very literal in Mac OS X,

00:02:05.390 --> 00:02:05.900
right?

00:02:05.900 --> 00:02:09.890
There is a Cocoa.framework in the
system library frameworks directory.

00:02:10.200 --> 00:02:17.000
And this contains, you know,
compiled executable code and headers and

00:02:17.000 --> 00:02:17.000
resources and other things used by Cocoa.

00:02:18.580 --> 00:02:21.620
More generally,
a framework is like a library.

00:02:21.810 --> 00:02:24.820
For example, OpenGL.

00:02:24.920 --> 00:02:27.160
And you use a library
by calling its code.

00:02:27.270 --> 00:02:28.570
So how do you use OpenGL?

00:02:28.700 --> 00:02:30.640
You call OpenGL functions.

00:02:30.640 --> 00:02:35.120
You can think of OpenGL as sort of
being embedded in your application.

00:02:35.140 --> 00:02:38.490
But Cocoa calls your code.

00:02:38.850 --> 00:02:42.720
So you could think of your application
as being embedded in Cocoa.

00:02:42.750 --> 00:02:46.160
And the overall structure of your
application is determined by Cocoa.

00:02:46.170 --> 00:02:48.920
For example, Cocoa tells your windows
when they need to draw.

00:02:48.920 --> 00:02:51.600
It tells your application
when it receives an event.

00:02:51.620 --> 00:02:55.600
It tells you when you're ready to quit,
and things like that.

00:02:55.600 --> 00:02:58.080
As a result of this,
most Cocoa applications have

00:02:58.080 --> 00:03:00.160
a very similar structure.

00:03:01.790 --> 00:03:03.680
So, why should you use Cocoa?

00:03:03.780 --> 00:03:07.100
Well, Cocoa is a very mature framework,
right?

00:03:07.100 --> 00:03:11.330
It's been around for one form
or another for nearly 20 years,

00:03:11.330 --> 00:03:12.910
and it's driven by developer needs.

00:03:13.070 --> 00:03:15.640
So when developers are
writing applications,

00:03:15.640 --> 00:03:18.570
they discover they need, you know,
some functionality a lot.

00:03:18.570 --> 00:03:23.970
If it's something that
many applications need,

00:03:23.970 --> 00:03:23.970
then that's something we
consider adding to Cocoa.

00:03:24.560 --> 00:03:27.500
And it's optimized for Mac OS X.

00:03:27.570 --> 00:03:30.220
So when you draw an image,
it uses the most efficient path

00:03:30.220 --> 00:03:31.900
for drawing images on Mac OS X.

00:03:31.900 --> 00:03:34.990
If you draw text, if you, you know,
manipulate files,

00:03:35.040 --> 00:03:38.890
it's going to do the right
thing on Mac OS X specifically.

00:03:39.660 --> 00:03:41.140
It's very consistent, too.

00:03:41.420 --> 00:03:44.190
By this,
I mean all the APIs work very similarly.

00:03:44.200 --> 00:03:49.710
There are very strong
Cocoa conventions that the

00:03:49.710 --> 00:03:49.710
Cocoa frameworks follow very closely.

00:03:50.770 --> 00:03:52.690
And it's full-featured and complete.

00:03:52.710 --> 00:03:56.200
It's not just a framework for drawing,
you know, widgets and controls.

00:03:56.200 --> 00:04:01.000
It also supports localization and
accessibility and printing and scripting.

00:04:01.510 --> 00:04:05.640
In fact, it supports these because
Mac OS X applications

00:04:05.640 --> 00:04:08.940
need these features,
and the applications we ship with

00:04:08.940 --> 00:04:11.190
the system all use these features.

00:04:11.300 --> 00:04:14.130
So Cocoa is our dog food, right?

00:04:16.900 --> 00:04:18.540
Let's look at some of the
classes we have in Cocoa.

00:04:18.680 --> 00:04:21.730
And there's a bunch.

00:04:21.810 --> 00:04:23.000
So here's some of the functionality.

00:04:23.000 --> 00:04:24.560
And there's so much there,
it's hard to get our

00:04:24.560 --> 00:04:25.480
hands on it sometimes.

00:04:25.590 --> 00:04:30.970
So we like to organize it into what
we call App Kit and Foundation.

00:04:31.090 --> 00:04:36.440
And App Kit supports
some of the more-- oh,

00:04:36.440 --> 00:04:38.080
and this, of course,
this list is not exhaustive.

00:04:38.080 --> 00:04:38.080
There's plenty more here.

00:04:39.300 --> 00:04:43.660
And AppKit supports controls and windows
and some of the graphical classes

00:04:44.150 --> 00:04:47.000
and functionality that you'd expect.

00:04:47.200 --> 00:04:50.180
And much of the consistency
of the Mac OS X user interface

00:04:50.260 --> 00:04:52.290
is due to the use of Cocoa.

00:04:52.470 --> 00:05:01.240
If Mac OS X applications seem
to look and work the same way,

00:05:01.240 --> 00:05:01.240
a lot of that is due to Cocoa providing
the functionality for them.

00:05:01.930 --> 00:05:05.060
And Foundation provides more
system-level functionality,

00:05:05.060 --> 00:05:09.170
like working with files
and collections and XML.

00:05:09.270 --> 00:05:13.030
And it's possible to write, for example,
a command line application that would

00:05:13.030 --> 00:05:15.970
use Foundation and not use AppKit.

00:05:17.730 --> 00:05:19.260
So, let's move to a demo.

00:05:19.440 --> 00:05:22.880
Let's make our very
first Cocoa application.

00:05:24.520 --> 00:05:26.010
Here's the first iteration of Squiggles.

00:05:26.060 --> 00:05:30.110
This is just what you get when
you say Xcode new application.

00:05:30.220 --> 00:05:33.290
And we'll build and run it.

00:05:34.080 --> 00:05:35.810
We have a window, right?

00:05:35.880 --> 00:05:38.720
The window can be resized,
it can be minimized.

00:05:38.880 --> 00:05:42.890
We have the color panel here.

00:05:44.300 --> 00:05:46.990
There's an about box.

00:05:46.990 --> 00:05:49.570
The application can be quit.

00:05:51.490 --> 00:05:55.060
So, let's go back to slides.

00:05:55.370 --> 00:05:57.470
So there was a lot there.

00:05:59.890 --> 00:06:03.900
There's all this functionality,
but there was only one line of code,

00:06:03.900 --> 00:06:05.750
and that's this NSApplicationMain.

00:06:06.490 --> 00:06:08.410
So, that's great,
we get all this for free, right?

00:06:08.500 --> 00:06:11.140
But the next question is, you know,
where does my code go?

00:06:11.210 --> 00:06:13.840
And I think this is one of the
most common questions asked

00:06:13.840 --> 00:06:15.400
by developers new to Cocoa.

00:06:15.410 --> 00:06:18.040
They're not sure where
to put their own code.

00:06:18.390 --> 00:06:22.960
And I think developers who ask
this are coming from a sort of

00:06:22.960 --> 00:06:24.400
a code generation perspective,
right?

00:06:24.400 --> 00:06:32.310
A number of other frameworks like
to-- they make their form painters

00:06:32.310 --> 00:06:37.400
or tools just generate code for them.

00:06:37.410 --> 00:06:37.750
And you can view that
code and you can edit it.

00:06:37.750 --> 00:06:37.750
But Cocoa does not use code generators.

00:06:38.310 --> 00:06:39.890
Instead,
you want to think about your application

00:06:39.900 --> 00:06:42.000
from a more object-oriented perspective,
right?

00:06:42.000 --> 00:06:44.680
So you think about the different
classes in your applications and

00:06:44.680 --> 00:06:49.680
the instances of those classes and
their relationships to one another.

00:06:49.840 --> 00:06:53.110
And then you start by setting
these up in Interface Builder.

00:06:53.420 --> 00:06:56.990
So Interface Builder, if you're not sure,
is a tool that operates on

00:06:56.990 --> 00:06:58.500
what are called nib files.

00:06:58.630 --> 00:07:01.300
And a nib file is just a
serialized object graph.

00:07:01.300 --> 00:07:05.210
So it contains windows and views
that have been serialized to a

00:07:05.210 --> 00:07:07.300
binary format and stored on disk.

00:07:07.430 --> 00:07:11.790
It also contains your own objects and
relationships between the objects.

00:07:12.380 --> 00:07:15.700
Most Cocoa applications
have one nib at least.

00:07:15.700 --> 00:07:18.620
This will typically contain the
main menu and perhaps other windows.

00:07:18.690 --> 00:07:26.310
And most Cocoa applications
also have multiple nibs,

00:07:26.310 --> 00:07:26.310
often as many as one nib per window.

00:07:27.020 --> 00:07:29.060
And you can load a single
Nib file multiple times.

00:07:29.060 --> 00:07:33.640
So here we have mail, three mail windows,
and the way we've achieved

00:07:33.640 --> 00:07:37.130
this is by loading the Nib
containing the window three times.

00:07:38.190 --> 00:07:41.560
So let's think about the relationships
and the objects in Squiggles.

00:07:41.640 --> 00:07:43.900
We'll use a model view controller design.

00:07:43.900 --> 00:07:44.870
I'm sure you've heard of that.

00:07:44.960 --> 00:07:50.090
This is a design which is very
common in Cocoa applications.

00:07:50.090 --> 00:07:53.530
In fact, many Cocoa controls depend
on model view controller.

00:07:53.720 --> 00:07:59.320
For example,
the table view is just a view

00:07:59.320 --> 00:08:00.690
and it depends on having a model
object to supply it with data.

00:08:01.400 --> 00:08:05.190
So we'll have our model object,
which we're calling a squiggle,

00:08:05.310 --> 00:08:07.750
and a squiggle will have a path,
which is just the

00:08:07.750 --> 00:08:11.180
region the user drew in,
and it will have a color and a thickness,

00:08:11.270 --> 00:08:11.840
right?

00:08:11.840 --> 00:08:17.930
And it will support one method,
which is add point,

00:08:17.930 --> 00:08:20.880
and that will-- if the user clicks
or drags to a point on the screen,

00:08:20.880 --> 00:08:20.880
that will be the point
we add to the squiggle.

00:08:21.310 --> 00:08:23.040
And we have our View object, too.

00:08:23.060 --> 00:08:27.460
And the View's responsibility is to draw
the squiggle and also to receive events,

00:08:27.460 --> 00:08:29.900
mouse-down events in particular.

00:08:30.190 --> 00:08:33.280
We have a controller object which
will manage an array of squiggles.

00:08:33.280 --> 00:08:37.480
So, with a bit of abusive notation,
the model is really the array here.

00:08:37.620 --> 00:08:40.100
And it will also trigger redisplays.

00:08:40.100 --> 00:08:43.470
For example, when a squiggle is added,
it will tell the view it needs to redraw.

00:08:43.760 --> 00:08:47.090
So, what kind of relationships
then do we have?

00:08:47.250 --> 00:08:51.100
Well, the controller, as I mentioned,
will manage the array of squiggles,

00:08:51.450 --> 00:08:55.100
while the view and the controller
will each relate to one another.

00:08:55.100 --> 00:08:57.580
So, the controller will tell the
view it needs to redisplay,

00:08:57.580 --> 00:09:01.100
and the view will tell the
controller when it receives an event.

00:09:01.100 --> 00:09:05.550
So, let's go ahead and set these
up in Interface Builder.

00:09:09.120 --> 00:09:12.370
Close this.

00:09:12.510 --> 00:09:13.940
So this is the same application.

00:09:13.940 --> 00:09:17.740
Going to open up Interface Builder here.

00:09:17.740 --> 00:09:19.080
Oops.

00:09:19.610 --> 00:09:22.000
We'll hide everything else.

00:09:22.060 --> 00:09:24.230
So here's our main menu,
and here's our window.

00:09:24.240 --> 00:09:25.700
So now we've begun to
answer the question,

00:09:25.700 --> 00:09:28.160
where did all that
functionality come from?

00:09:28.170 --> 00:09:30.790
A lot of it is just
right here in the nib.

00:09:31.850 --> 00:09:39.290
We'll start by adding a custom view,
which will be our squiggle view.

00:09:39.400 --> 00:09:41.490
We'll put it in the window.

00:09:44.090 --> 00:09:51.610
Then we will make it an
instance of squiggle view,

00:09:52.030 --> 00:09:52.300
right?

00:09:52.300 --> 00:09:54.560
And we'll also have
our controller object,

00:09:54.610 --> 00:09:57.630
which will be just subclassing NSObject.

00:09:58.930 --> 00:10:02.040
And I'll make this an
instance of controller.

00:10:02.050 --> 00:10:03.600
The model will do code.

00:10:03.690 --> 00:10:07.800
So the controller has a
relationship to the squiggle view.

00:10:07.800 --> 00:10:11.780
So we'll call it view,
and this will be of type squiggle view.

00:10:14.090 --> 00:10:17.660
Set this up now.

00:10:17.660 --> 00:10:18.360
There it goes.

00:10:18.490 --> 00:10:19.690
View.

00:10:20.020 --> 00:10:22.700
Likewise, the view will have

00:10:23.260 --> 00:10:29.320
Controller as its relationship,
type Controller.

00:10:29.370 --> 00:10:30.320
We'll set these up.

00:10:30.320 --> 00:10:32.470
We have Controller.

00:10:33.600 --> 00:10:39.330
What we can do now is have it
make these files for us and

00:10:39.420 --> 00:10:41.560
we'll set up the relationships.

00:10:43.650 --> 00:10:47.600
We'll add it to our project.

00:10:47.690 --> 00:10:51.470
And likewise for the controller.

00:10:52.740 --> 00:10:58.600
Center file, write class files,
controller.

00:10:58.600 --> 00:11:00.120
We'll add it.

00:11:01.820 --> 00:11:06.170
Going back to Xcode,
you can see it's added our

00:11:06.230 --> 00:11:07.890
squiggle view and our controller.

00:11:08.090 --> 00:11:11.940
It's got the controller as
an instance variable and the

00:11:12.300 --> 00:11:14.720
controller relates to its view.

00:11:16.830 --> 00:11:21.700
We need to set up the
superclasses and such.

00:11:21.890 --> 00:11:25.520
So the superclass of
controller is NSObject.

00:11:25.560 --> 00:11:30.260
The superclass of view is NSView.

00:11:34.170 --> 00:11:36.340
Okay, so we could build and run
this and it wouldn't look any

00:11:36.340 --> 00:11:39.420
different than what we had before,
right, because we haven't actually

00:11:39.420 --> 00:11:41.200
told the view to draw anything.

00:11:41.440 --> 00:11:46.690
But we set up the basic relationships
and classes in our application.

00:11:46.700 --> 00:11:48.780
Go back to slides, please.

00:11:51.700 --> 00:11:54.600
So I wish I could tell you that you
can write an entire Cocoa application

00:11:54.600 --> 00:11:57.240
with just Interface Builder,
but that would be a lie.

00:11:57.330 --> 00:11:59.590
Eventually,
you're going to have to write some code.

00:11:59.600 --> 00:12:04.450
Just like Java has the Java programming
language and C# has it--excuse me,

00:12:04.460 --> 00:12:08.600
.NET has its C# language,
Cocoa has Objective-C.

00:12:08.600 --> 00:12:12.590
That's the flagship language
for writing Cocoa applications.

00:12:12.870 --> 00:12:19.320
And most applications on this system
are Objective-C Cocoa applications,

00:12:19.320 --> 00:12:19.320
Safari, Mail, Keynote.

00:12:20.740 --> 00:12:23.500
And if you're a little
intimidated by Objective-C,

00:12:23.570 --> 00:12:24.040
don't be.

00:12:24.040 --> 00:12:27.240
Objective-C is a small
programming language and it's

00:12:27.240 --> 00:12:29.040
an easy language to learn.

00:12:29.450 --> 00:12:32.800
So how does it compare to
a language like Java or C#?

00:12:32.930 --> 00:12:34.820
Well, the good news is it's very
similar in a lot of ways,

00:12:34.820 --> 00:12:35.270
right?

00:12:35.330 --> 00:12:37.250
These are all object-oriented language.

00:12:37.340 --> 00:12:40.310
They all have a single
inheritance hierarchy,

00:12:40.310 --> 00:12:44.720
and they all support garbage collection,
although in Objective-C, it's optional.

00:12:45.390 --> 00:12:48.230
But there's some
important differences too.

00:12:48.350 --> 00:12:52.140
The first difference which
people notice is the syntax.

00:12:53.980 --> 00:12:56.120
In Objective-C,
when you're calling a method,

00:12:56.220 --> 00:12:58.630
you do not use commas
to separate arguments,

00:12:58.630 --> 00:13:03.360
and you do not use dot
paren to name the method.

00:13:04.400 --> 00:13:05.860
So let's take a look at this in action.

00:13:05.860 --> 00:13:09.830
So for example,
here's an Objective-C method invocation.

00:13:09.860 --> 00:13:12.360
Cell, draw with frame, in view.

00:13:12.530 --> 00:13:15.130
So the cell here is titled--is
called the receiver.

00:13:15.330 --> 00:13:19.880
This is the object that the
method is being called on.

00:13:20.570 --> 00:13:24.570
Next we have the name of the method:
drawWithFrame:inView:

00:13:24.630 --> 00:13:27.590
The colons are part of the method name.

00:13:27.590 --> 00:13:31.630
If the colons were not there,
it would be a different method.

00:13:31.830 --> 00:13:35.700
You'll notice that the method
name is broken up over multiple

00:13:35.700 --> 00:13:38.470
parts of the actual invocation.

00:13:38.570 --> 00:13:41.490
The parameters here are also
interspersed with the method name.

00:13:41.580 --> 00:13:45.580
So here the parameters are
content-rect and title-view.

00:13:45.610 --> 00:13:50.320
And in Java,
this would be cell.drawWithFrameAndView,

00:13:50.350 --> 00:13:54.860
then parentheses each of the
parameters separated by commas.

00:13:54.910 --> 00:13:57.830
So the syntax is a little different,
but everything you're familiar

00:13:57.830 --> 00:13:59.090
with is already there.

00:13:59.700 --> 00:14:01.260
Why do we have this crazy syntax?

00:14:01.260 --> 00:14:05.250
Well, one good reason is it helps
to disambiguate parameters.

00:14:05.260 --> 00:14:11.420
So if you said in Java you say array.set,
for example, on an array list,

00:14:11.420 --> 00:14:14.340
and you have foo and bar,
it's not really clear which is the

00:14:14.340 --> 00:14:17.300
index into the array and which one's
the object you're trying to store.

00:14:17.300 --> 00:14:21.180
But in Objective-C,
replace object and index

00:14:21.180 --> 00:14:24.620
foo with object bar,
it's clear that foo is the

00:14:24.620 --> 00:14:26.600
index and bar is the new object.

00:14:27.380 --> 00:14:30.630
And you'll find that we often,
most methods in Objective-C are

00:14:30.650 --> 00:14:32.370
fairly verbose like this.

00:14:32.400 --> 00:14:34.180
This helps to improve the readability.

00:14:36.160 --> 00:14:39.520
Another advantage is that it
helps you write longer methods.

00:14:39.670 --> 00:14:43.090
Now, this isn't always a good idea,
but if you decide to do this,

00:14:43.090 --> 00:14:45.820
it's easier in Objective-C than
it would be in Java.

00:14:45.950 --> 00:14:50.240
Imagine this method in Java,
you would have 100 and 300 and all

00:14:50.260 --> 00:14:53.210
these numbers just in a big list,
and you wouldn't know

00:14:53.630 --> 00:14:54.850
what number means what.

00:14:55.200 --> 00:15:00.860
In Objective-C, it's clear that,
for example, 100 is the number of pixels

00:15:00.860 --> 00:15:00.860
high for the new image.

00:15:02.180 --> 00:15:04.800
So how do you declare a method?

00:15:04.830 --> 00:15:10.480
Well, here we have a method declaration,
drawWithFrame, in view again.

00:15:10.820 --> 00:15:12.650
The first thing you'll
see is the return type.

00:15:12.800 --> 00:15:13.950
This is in parenthesis.

00:15:14.060 --> 00:15:16.440
This is just the ordinary C cast syntax.

00:15:16.440 --> 00:15:19.800
So if you know C,
you know how to type cast.

00:15:19.920 --> 00:15:23.150
That's how you declare the
return type for the method.

00:15:24.390 --> 00:15:26.140
Next we have the method name.

00:15:26.250 --> 00:15:28.450
Again,
it's broken up into separate portions,

00:15:28.450 --> 00:15:31.800
and again,
the colons are part of the method name.

00:15:31.820 --> 00:15:33.300
We have the parameter type.

00:15:33.300 --> 00:15:37.130
So here we take two parameters,
NSRect and NSView,

00:15:37.130 --> 00:15:38.240
and the variable names.

00:15:38.320 --> 00:15:40.740
The formal parameters are frame and view.

00:15:40.940 --> 00:15:46.110
So in Java, this would be void,
draw with frame and view, parenthesis,

00:15:46.190 --> 00:15:51.370
parameter type, parameter name, comma,
etc.

00:15:51.920 --> 00:15:55.380
One last part that's important
is that leading minus sign.

00:15:55.530 --> 00:16:00.000
This just indicates
it's an instance method.

00:16:00.000 --> 00:16:01.800
You would call it a
non-static method in Java.

00:16:01.800 --> 00:16:04.960
If it were a plus,
it would be a static method

00:16:05.050 --> 00:16:06.830
like you know in Java.

00:16:09.570 --> 00:16:13.800
How does Objective-C relate to C?

00:16:13.800 --> 00:16:15.300
Well, very well, it turns out.

00:16:15.310 --> 00:16:18.150
The good news is
Objective-C is a superset of C,

00:16:18.150 --> 00:16:20.400
and all C code just works.

00:16:20.500 --> 00:16:23.820
You don't have to mess with, you know,
P invoke or JNI.

00:16:23.980 --> 00:16:30.160
Even in C++, most C code will work,
but you might have to typecast

00:16:30.250 --> 00:16:33.520
some mallocs or things like that.

00:16:33.520 --> 00:16:33.520
In Objective-C, it just works.

00:16:33.520 --> 00:16:33.520
It's a true superset.

00:16:33.690 --> 00:16:37.100
And in fact,
Cocoa uses-- depends heavily on C.

00:16:37.100 --> 00:16:42.620
So if you know C,
you're most of the way there towards

00:16:42.620 --> 00:16:42.620
being able to write an Objective-C.

00:16:43.700 --> 00:16:47.360
It's also fully compatible with C,
not just source code like we mentioned,

00:16:47.430 --> 00:16:48.820
but compiled libraries too.

00:16:48.960 --> 00:16:57.100
So if you want to use OpenGL,
you'd use OpenGL from an

00:16:57.100 --> 00:16:57.100
Objective-C program exactly the same
way as you'd use it from a C program.

00:16:57.840 --> 00:17:00.090
And it's also compatible with C++.

00:17:00.140 --> 00:17:03.870
Just like Objective-C is a superset of C,
you can take those same

00:17:03.910 --> 00:17:06.440
extensions and apply them to C++.

00:17:06.460 --> 00:17:10.040
Then you have a language
called Objective-C++,

00:17:10.040 --> 00:17:12.250
and they have two disjoint object models.

00:17:12.420 --> 00:17:15.950
So you can't, for example,
have an Objective-C object

00:17:15.950 --> 00:17:18.790
inherit from a C++ object.

00:17:18.860 --> 00:17:21.840
But there's some interoperability.

00:17:21.990 --> 00:17:25.920
For example,
you can have a C++ object embedded in

00:17:25.920 --> 00:17:27.770
an Objective-C class as a variable.

00:17:27.770 --> 00:17:30.490
Then when you instantiate
the Objective-C class,

00:17:30.490 --> 00:17:33.240
it will call the constructor
for your C++ object.

00:17:33.290 --> 00:17:35.320
And when your
Objective-C object goes away,

00:17:35.320 --> 00:17:38.810
the destructor will be
called for you automatically,

00:17:38.810 --> 00:17:39.390
too.

00:17:39.730 --> 00:17:42.650
And I know that a lot of you have,
maybe you like to use Boost or you

00:17:42.650 --> 00:17:47.380
have a lot of C++ code you have for
your cross-platform application,

00:17:47.470 --> 00:17:51.950
and Objective-C++ is a great way to take
advantage of that while also using Cocoa.

00:17:53.780 --> 00:17:58.200
So you'll notice that the
NSView has an asterisk next to it,

00:17:58.260 --> 00:18:03.200
and this means it's
an Objective-C object,

00:18:03.200 --> 00:18:08.840
but just like it means in C,
it means it's also a pointer.

00:18:08.840 --> 00:18:11.060
In fact,
all Objective-C objects are pointers,

00:18:11.060 --> 00:18:14.140
and this is, of course,
true in a language like Java as well,

00:18:14.140 --> 00:18:17.190
except it's explicit in Objective-C,
and it's hidden in Java.

00:18:17.200 --> 00:18:21.430
And there's no stack allocation in
Objective-C like you can do in C++,

00:18:21.430 --> 00:18:22.300
for example.

00:18:23.630 --> 00:18:25.300
In fact,
if you try to allocate on the stack,

00:18:25.360 --> 00:18:26.600
you get an error message.

00:18:26.600 --> 00:18:30.320
We have statically allocated
instance of Objective-C class NSView.

00:18:30.320 --> 00:18:31.890
We forgot the asterisk.

00:18:34.320 --> 00:18:36.850
but there's no asterisk next to NSRect.

00:18:36.900 --> 00:18:37.880
This is not a pointer.

00:18:37.880 --> 00:18:39.330
So how does this work?

00:18:39.460 --> 00:18:41.480
Well, it's just an ordinary C struct.

00:18:41.480 --> 00:18:47.810
Cocoa uses some C structs for efficiency,
right, because using a struct can be more

00:18:47.810 --> 00:18:49.140
efficient than using an object.

00:18:49.230 --> 00:18:50.890
You can allocate it
on the stack and such.

00:18:50.920 --> 00:18:53.360
And there's only a few
you're likely to encounter,

00:18:53.360 --> 00:18:55.120
so you'll get familiar
with them very quickly.

00:18:55.120 --> 00:18:58.020
There's NSPoint,
which represents a two-dimensional

00:18:58.020 --> 00:18:59.580
point in floating point coordinates.

00:18:59.620 --> 00:19:02.180
NSSize is a two-dimensional size.

00:19:02.540 --> 00:19:04.540
NSRect combines a point to NSSize.

00:19:04.580 --> 00:19:08.720
And NSRange is an integer
range of a list or an array.

00:19:11.890 --> 00:19:16.040
Lastly, the last important difference
is dynamic binding.

00:19:16.110 --> 00:19:17.680
What is this about?

00:19:17.770 --> 00:19:21.700
Well, in a language like Java,
methods are resolved at compile time.

00:19:21.700 --> 00:19:24.620
So if you call the name
method on an object,

00:19:24.780 --> 00:19:28.560
the compiler has to know
that this name method exists.

00:19:28.710 --> 00:19:32.150
And all it can do is
call the name method.

00:19:32.770 --> 00:19:35.320
So if we--if object does not
have--it's not of a type that

00:19:35.370 --> 00:19:38.000
supports the name method,
you're going to get an error

00:19:38.000 --> 00:19:39.580
like this at compile time.

00:19:39.730 --> 00:19:41.970
You cannot find symbol.

00:19:43.790 --> 00:19:47.460
But in Objective-C,
methods are resolved at runtime.

00:19:47.640 --> 00:19:51.320
So if you call the name
method on an object,

00:19:51.320 --> 00:19:54.310
if the name method exists,
it will call it just

00:19:54.340 --> 00:19:55.700
like it does in Java.

00:19:55.700 --> 00:19:58.620
But if the name method does not exist,
then some more interesting

00:19:58.620 --> 00:19:59.700
things can happen.

00:19:59.700 --> 00:20:03.680
The object can actually store that
method invocation and play it back later.

00:20:03.750 --> 00:20:06.870
It can pass it on to another object.

00:20:06.870 --> 00:20:10.700
It can pick it apart and run some other
crazy code to interpret it in some way.

00:20:10.990 --> 00:20:13.930
So the lesson here is that objects
can handle arbitrary methods,

00:20:13.930 --> 00:20:17.100
even if they aren't
defined at compile time.

00:20:17.290 --> 00:20:20.370
And we refer to this, therefore,
as sending a message.

00:20:20.520 --> 00:20:23.240
So here we're sending the
name message to this object,

00:20:23.240 --> 00:20:28.390
and if the object responds to name,
it will call the name method.

00:20:29.660 --> 00:20:33.830
We'll see a use case for this
sort of dynamic feature a

00:20:33.830 --> 00:20:36.120
bit later on in the session.

00:20:36.600 --> 00:20:38.120
Now,
I know a lot of you are familiar with

00:20:38.210 --> 00:20:40.540
dynamic languages like Python and think,
"Oh, great,

00:20:40.540 --> 00:20:43.780
if I have to use this dynamic language,
I'm not going to have static type

00:20:43.810 --> 00:20:45.830
checking." But you actually do.

00:20:46.110 --> 00:20:49.140
For example,
here's a variable called array.

00:20:49.140 --> 00:20:52.170
We meant it to be an array,
but we typed it as NSString by mistake.

00:20:52.420 --> 00:20:56.190
We're calling an array method on it,
Object.Index.

00:20:56.350 --> 00:20:57.460
The compiler's going to catch this.

00:20:57.550 --> 00:20:59.860
It's going to say, "Hey,
NSString may not respond to this method.

00:20:59.860 --> 00:21:03.310
Are you sure you wanted to
send this message to it?"

00:21:03.690 --> 00:21:07.250
If it's an error, you can fix it.

00:21:07.300 --> 00:21:11.580
And if it's not, you can, you know,
we'll see how to shut it up later.

00:21:11.590 --> 00:21:14.200
So the code will still compile.

00:21:14.200 --> 00:21:16.330
This is just a warning.

00:21:18.360 --> 00:21:21.730
Now, if you really wanted
to invoke this method,

00:21:21.730 --> 00:21:24.790
which the compiler is not
convinced actually exists,

00:21:24.790 --> 00:21:25.460
you can do it.

00:21:25.780 --> 00:21:29.920
For example,
here's the last object method on NSArray.

00:21:29.980 --> 00:21:33.280
And as you can see, it returns this type,
id.

00:21:33.540 --> 00:21:34.270
What is id?

00:21:34.380 --> 00:21:37.980
Well, id is an object of any type.

00:21:38.030 --> 00:21:40.100
And this allows you to
avoid the typecasting.

00:21:40.210 --> 00:21:42.720
So I know in Java,
if you want to take an object

00:21:42.720 --> 00:21:46.400
out of an array-- or excuse me,
out of an array list,

00:21:46.430 --> 00:21:49.330
in the battle days before generics,
you'd have to do the typecast

00:21:49.330 --> 00:21:50.310
of the type you want.

00:21:50.480 --> 00:21:53.780
In Objective-C, that's not necessary
because of this id type.

00:21:53.860 --> 00:21:56.600
For example, if we call the last
object method on an array,

00:21:56.600 --> 00:21:58.720
we can call string
methods on this object,

00:21:58.820 --> 00:22:01.050
such as character at index.

00:22:01.110 --> 00:22:05.380
And the compiler is just going to
trust us that this object in the array

00:22:05.380 --> 00:22:08.470
is really an instance of NSString.

00:22:10.330 --> 00:22:13.240
Well, that's Objective-C,
but there's also other languages

00:22:13.330 --> 00:22:14.740
you can use with Cocoa.

00:22:14.740 --> 00:22:16.000
Leopard ships with three of them.

00:22:16.000 --> 00:22:18.770
There's Python, Ruby, and AppleScript.

00:22:19.030 --> 00:22:21.390
And these are great options.

00:22:22.010 --> 00:22:25.410
Because they have really good
interoperability with Objective-C,

00:22:25.470 --> 00:22:28.800
you can have a Python object which
subclasses an Objective-C object.

00:22:29.100 --> 00:22:30.900
You can go the other way, too.

00:22:30.900 --> 00:22:34.740
And you can use any Objective-C code
and libraries from within Python.

00:22:34.860 --> 00:22:36.740
And the user can't tell the difference.

00:22:36.740 --> 00:22:39.460
These are launched by
double-clicking in the finder.

00:22:39.460 --> 00:22:41.550
They are bundled applications.

00:22:41.560 --> 00:22:44.900
They work just like any
other Mac application.

00:22:45.080 --> 00:22:49.300
So these are completely reasonable
ways to write applications

00:22:49.660 --> 00:22:51.900
for Mac OS X that use Cocoa.

00:22:51.900 --> 00:22:56.650
Let's go back to our demo and look
at how we do some custom drawing.

00:23:02.900 --> 00:23:05.530
So here we're back in Xcode.

00:23:05.540 --> 00:23:06.890
We've got our squiggle.

00:23:06.980 --> 00:23:10.790
We're going to define this addPoint
method we talked about before.

00:23:11.700 --> 00:23:14.910
So when the user clicks on the view,
it's going to add a point

00:23:14.910 --> 00:23:16.370
to the current squiggle.

00:23:16.570 --> 00:23:18.090
What does add point do?

00:23:18.380 --> 00:23:22.390
Well, if there's not a path already,
remember the path variable,

00:23:22.390 --> 00:23:25.760
we'll create a path and start
us off at that location.

00:23:25.760 --> 00:23:28.150
There already is a path.

00:23:28.150 --> 00:23:31.630
We will just add a line to that point.

00:23:36.300 --> 00:23:40.300
Our controller, what we're going to do is
just for testing purposes,

00:23:40.300 --> 00:23:45.620
define a squiggle and give it a certain
number of points that will form a square.

00:23:45.700 --> 00:23:49.800
So we'll make our array,
we'll make it instance of squiggle.

00:23:50.050 --> 00:23:51.560
- We'll set it to an orange color.

00:23:51.560 --> 00:23:54.080
We'll set its thickness
to something reasonable.

00:23:54.200 --> 00:23:57.850
And we'll add a bunch of points,
and these points will describe a square.

00:23:58.050 --> 00:24:00.150
Once we've done that,
we'll add it to our array.

00:24:00.270 --> 00:24:04.390
We're done with the squiggle.

00:24:04.390 --> 00:24:04.390
This is our return self.

00:24:05.230 --> 00:24:10.260
Likewise, we have a squiggles property
that the view will call in us

00:24:10.260 --> 00:24:13.080
so it can draw these squiggles.

00:24:13.600 --> 00:24:16.400
Save that.

00:24:17.100 --> 00:24:17.130
And in our view,

00:24:17.830 --> 00:24:20.430
We're just going to define a gradient,
and the gradient will just give

00:24:20.430 --> 00:24:23.040
us a nice background for our view.

00:24:23.220 --> 00:24:26.470
Here we'll draw the gradient,
and then for every squiggle,

00:24:26.470 --> 00:24:28.140
we'll get its path out.

00:24:28.400 --> 00:24:32.350
We'll set it to a given line width,
the width of the squiggle.

00:24:32.490 --> 00:24:35.510
We'll set it to the
color of the squiggle.

00:24:35.600 --> 00:24:39.750
And then we'll stroke,
so we'll draw a line around the squiggle,

00:24:39.760 --> 00:24:41.290
and we're done.

00:24:42.530 --> 00:24:45.800
So when we run this,
what we expect to see is a view

00:24:45.800 --> 00:24:49.840
with a gradient background,
which we see, and an orange square,

00:24:50.100 --> 00:24:51.740
which is the one squiggle.

00:24:52.460 --> 00:24:56.150
Okay, this isn't very exciting yet,
but we'll get there.

00:24:56.200 --> 00:24:57.200
Let's go back to slides.

00:24:57.360 --> 00:25:00.590
So, what did we just do?

00:25:01.150 --> 00:25:05.420
Well, first we have to talk about
the class hierarchy of Cocoa,

00:25:05.420 --> 00:25:06.100
right?

00:25:06.150 --> 00:25:10.840
Cocoa has, for most use cases,
a single root class, which is NSObject.

00:25:11.320 --> 00:25:20.490
And NSObject provides facilities
like allocation and deallocation,

00:25:20.490 --> 00:25:20.610
reflection, some logging,
and reference counting

00:25:20.610 --> 00:25:20.610
for memory management.

00:25:21.320 --> 00:25:23.700
So here's part of the
class hierarchy of Cocoa,

00:25:23.700 --> 00:25:24.960
a very small part.

00:25:25.020 --> 00:25:26.160
NSObject is at the root.

00:25:26.370 --> 00:25:30.750
It's got NSView and NSWindow
inherit ultimately from NSObject.

00:25:31.100 --> 00:25:33.340
Because they both sort
of respond to events,

00:25:33.340 --> 00:25:35.630
they have an NSResponder intermediary.

00:25:35.760 --> 00:25:43.020
And there's other classes, NSArray,
which is an array of objects, NSLock,

00:25:43.020 --> 00:25:43.020
which is used for synchronization.

00:25:43.920 --> 00:25:45.750
And there's also some C structs,
as we saw,

00:25:45.760 --> 00:25:48.410
which don't participate in the class
hierarchy because they're structs,

00:25:48.500 --> 00:25:49.400
they're not objects.

00:25:49.520 --> 00:25:51.770
So, NS size, NS point, and NS range.

00:25:53.770 --> 00:25:56.820
So we saw NSView,
and NSView was doing the drawing.

00:25:57.050 --> 00:26:00.480
So a view is a rectangular
portion of the window,

00:26:00.720 --> 00:26:02.600
and it's not itself a window.

00:26:02.850 --> 00:26:06.730
I know in Windows, for example,
a region of a window is

00:26:06.740 --> 00:26:08.330
also itself a window.

00:26:08.340 --> 00:26:11.200
In Cocoa, they are unrelated.

00:26:11.200 --> 00:26:14.890
And the view will draw within the
region of the window it describes,

00:26:14.890 --> 00:26:17.810
which refers to its bounds,
and it can also respond to

00:26:17.810 --> 00:26:19.640
events in that same region.

00:26:19.660 --> 00:26:21.180
And it can contain other views.

00:26:21.180 --> 00:26:23.700
So here is a picture of one
of the preference panes.

00:26:24.820 --> 00:26:26.740
This is the screensaver preference pane.

00:26:26.870 --> 00:26:28.700
And there's a bunch of
views within this window,

00:26:28.700 --> 00:26:31.000
as you can see, the rectangular regions.

00:26:31.150 --> 00:26:34.040
So the OpenGL view is
drawing the OpenGL portion,

00:26:34.130 --> 00:26:36.660
and there's a table drawing--
showing you all the different

00:26:36.800 --> 00:26:38.540
screensavers you have available.

00:26:38.660 --> 00:26:41.680
And, of course, each of these views is
embedded in a larger view.

00:26:41.820 --> 00:26:45.550
Here we have the tab view,
which contains multiple tabs.

00:26:45.680 --> 00:26:47.890
Each tab has views inside it.

00:26:48.050 --> 00:26:51.440
And the root-most public view
is called the content view,

00:26:51.660 --> 00:26:54.340
and you can get the content view
for a window by just asking it,

00:26:54.510 --> 00:26:55.980
sending it the content view message.

00:27:00.000 --> 00:27:03.580
Most widgets, controls in AppKit are
subclasses of NSView.

00:27:03.720 --> 00:27:08.140
So TableView and OpenGLView and TextView,
all subclass NSView.

00:27:08.610 --> 00:27:12.090
But don't think that every
subclass also has view in its name.

00:27:12.240 --> 00:27:19.610
So ColorWell and PopupButton
are all subclasses of NSView,

00:27:19.610 --> 00:27:19.610
but they do not have view in their name.

00:27:20.850 --> 00:27:22.590
And it's very common to subclass NSView.

00:27:22.600 --> 00:27:25.140
Most Cocoa applications will do it.

00:27:25.300 --> 00:27:29.020
And the reason you subclass NSView is
so you can override some of its methods.

00:27:29.160 --> 00:27:33.280
For example, drawRect is one we overrode,
which will be called when the

00:27:33.330 --> 00:27:35.200
view is told to draw by Cocoa.

00:27:35.200 --> 00:27:38.680
MouseDown is called when the
user clicks in your view,

00:27:38.680 --> 00:27:43.000
of course, and KeyDown is called when
the user types a character.

00:27:43.110 --> 00:27:47.330
And you get things done with the
view by overriding these methods.

00:27:47.330 --> 00:27:50.620
And Cocoa will call them
for you at the right time.

00:27:52.930 --> 00:27:56.280
So for example, with DrawRect,
all we had to do was implement DrawRect,

00:27:56.280 --> 00:27:59.650
and Cocoa will automatically call
it when the view needs to redraw.

00:27:59.720 --> 00:28:03.430
For example,
when the window is resized so

00:28:03.690 --> 00:28:09.730
our view changes its dimensions,
or when our view gets moved within the

00:28:09.730 --> 00:28:13.200
window so it might appear different.

00:28:13.200 --> 00:28:13.950
And you can also trigger your own
redisplays with the setNeedsDisplay

00:28:13.950 --> 00:28:13.950
method by sending that to the view.

00:28:15.710 --> 00:28:19.210
The draw rect has a single parameter
which we're not using here,

00:28:19.210 --> 00:28:21.340
which contains the actual
region needing redraw,

00:28:21.410 --> 00:28:24.640
so you can optimize your drawing
to only draw the portion that

00:28:24.680 --> 00:28:26.790
actually needs to be drawn.

00:28:30.150 --> 00:28:32.730
On to memory management,
and there's two different ways

00:28:32.780 --> 00:28:34.140
to manage memory in Cocoa.

00:28:34.140 --> 00:28:37.100
There's reference counting and
there's garbage collection.

00:28:37.120 --> 00:28:42.470
And reference counting
is an older method,

00:28:42.530 --> 00:28:50.840
which is available in every version
of Mac OS X and also the iPhone.

00:28:50.840 --> 00:28:51.470
Garbage collection is new in Leopard
and is not available on the iPhone.

00:28:52.780 --> 00:28:54.360
The way you choose is very easy.

00:28:54.360 --> 00:28:56.820
In Xcode,
you just pick from pop-up whether

00:28:56.820 --> 00:29:00.580
you want the first option here,
which is reference counting,

00:29:00.580 --> 00:29:03.730
where it says unsupported,
or garbage collection,

00:29:03.730 --> 00:29:05.360
which is the last option.

00:29:05.400 --> 00:29:07.690
And the middle option is sort of a mode.

00:29:07.690 --> 00:29:11.780
It supports both methods,
which is useful for

00:29:11.780 --> 00:29:14.180
frameworks like AppKit.

00:29:14.180 --> 00:29:16.180
But if you're writing an application,
it's only the first or the

00:29:16.180 --> 00:29:16.180
last options you want to use.

00:29:17.180 --> 00:29:20.640
So how does reference counting work?

00:29:20.660 --> 00:29:23.980
Well,
a theory behind reference counting is

00:29:24.030 --> 00:29:26.190
that object lifetime is a global problem,
right?

00:29:26.200 --> 00:29:29.520
How does an object know when
everyone is done with it?

00:29:29.520 --> 00:29:33.770
And the hope for reference counting
is to make it into a local problem,

00:29:33.770 --> 00:29:38.140
where every object that uses another
object just indicates when it's

00:29:38.140 --> 00:29:40.410
using it and when it's done with it.

00:29:40.530 --> 00:29:43.780
When everyone is done using that object,
it knows it can deallocate

00:29:43.780 --> 00:29:43.780
itself and free up the memory.

00:29:45.220 --> 00:29:49.390
And a lot of you have maybe experience
with reference counting and you think,

00:29:49.460 --> 00:29:52.940
you know, I'll have to constantly be
adding and removing references.

00:29:53.130 --> 00:29:56.220
And the good news is you
will not have to do this.

00:29:56.380 --> 00:30:02.550
Due to a feature called
NRS Auto Release Pool,

00:30:02.550 --> 00:30:04.550
which we'll talk about,
it's fairly uncommon to have to

00:30:04.550 --> 00:30:04.550
add or remove a reference count.

00:30:04.910 --> 00:30:07.170
Another objection is,
"I'll never know what

00:30:07.170 --> 00:30:08.240
it's actually doing.

00:30:08.630 --> 00:30:12.410
It'll constantly be doing this
behind my back." The good news

00:30:12.410 --> 00:30:13.740
is it won't do that either.

00:30:13.810 --> 00:30:18.640
This is not like AutoPointer from C++,
where there's all these implicit changes.

00:30:19.770 --> 00:30:21.800
Everything is very explicit.

00:30:21.880 --> 00:30:23.790
So if you understand the rules,
which are very simple,

00:30:23.800 --> 00:30:26.860
and you follow the rules,
it will work consistently

00:30:26.890 --> 00:30:28.410
and well for you.

00:30:31.320 --> 00:30:32.060
What are these rules?

00:30:32.290 --> 00:30:34.590
Well, every object has a reference count,
right?

00:30:34.600 --> 00:30:36.790
An object starts with a
reference count of one.

00:30:36.920 --> 00:30:39.930
So here we have an instance
of box called myBox,

00:30:39.950 --> 00:30:43.910
and we've knitted it,
so we have a reference count of one.

00:30:44.920 --> 00:30:48.000
Now, if we send it a retain message,
it will then up its

00:30:48.000 --> 00:30:49.800
reference count to two.

00:30:49.800 --> 00:30:52.020
If we send it a release message,
of course,

00:30:52.020 --> 00:30:54.200
the reference count will go back to one.

00:30:54.420 --> 00:30:57.180
If you have an object with a
reference count of one and you

00:30:57.270 --> 00:31:01.440
send it the release message,
well, it's not going to go down to zero.

00:31:01.450 --> 00:31:03.010
Instead, it will free itself.

00:31:03.100 --> 00:31:05.880
It will call dealloc on itself.

00:31:06.230 --> 00:31:08.900
So, dialog is always called
for you by NSObject.

00:31:08.990 --> 00:31:12.430
It is never something you
want to call yourself.

00:31:16.190 --> 00:31:19.060
The third piece here is
what's called auto-release.

00:31:19.100 --> 00:31:22.880
What auto-release does is it will
send a release message later.

00:31:22.880 --> 00:31:24.870
What does later mean?

00:31:25.010 --> 00:31:27.960
Well, if you send auto-release,
it will not change the retain count now,

00:31:28.080 --> 00:31:29.780
so it's still going to stay at one.

00:31:29.850 --> 00:31:38.240
But what it will do is add a reference to
your object to this sort of global pool,

00:31:38.240 --> 00:31:38.240
a per-thread pool,
called the NS Auto-Release Pool.

00:31:39.460 --> 00:31:41.950
Then,
when the auto-release pool is torn down,

00:31:41.950 --> 00:31:47.290
which happens automatically
at the end of every event,

00:31:47.610 --> 00:31:54.050
although you can set them up yourself,
each object in the pool will

00:31:54.050 --> 00:31:54.050
be sent a release message,
and the pool itself will be destroyed.

00:31:55.610 --> 00:31:58.660
So this is very handy because it
allows you to return objects and

00:31:58.660 --> 00:32:00.840
also clean them up yourselves.

00:32:00.860 --> 00:32:03.660
Callers aren't burdened with
the details of managing memory

00:32:03.770 --> 00:32:06.500
for these transient objects,
which is most objects.

00:32:06.580 --> 00:32:13.580
So for example, if you call the uppercase
string method on an NSString,

00:32:13.580 --> 00:32:17.870
you get back a string
which is an uppercase,

00:32:17.870 --> 00:32:19.810
but the string you called it on is
responsible for destroying that object.

00:32:20.380 --> 00:32:22.060
If you do not want to
keep the object around,

00:32:22.060 --> 00:32:24.650
if you just want to draw it or
log it or write it to a file,

00:32:24.650 --> 00:32:27.240
you do not have to retain
or release it at all.

00:32:27.240 --> 00:32:28.030
You can just use it.

00:32:28.210 --> 00:32:30.340
It will be cleaned up for you.

00:32:33.100 --> 00:32:35.700
So, in summary,
when you pass an object to a method,

00:32:35.700 --> 00:32:37.740
you do not retain it or release it.

00:32:37.740 --> 00:32:42.000
The object that you're passing it to
will retain or release it if it wants to.

00:32:42.220 --> 00:32:44.880
When you get an object back,
you need to retain it if you

00:32:44.880 --> 00:32:46.890
want to keep the object around,
which is uncommon,

00:32:47.010 --> 00:32:49.310
release it if you don't.

00:32:50.510 --> 00:32:52.210
And if you just want to use
the object and forget it,

00:32:52.300 --> 00:32:55.960
you do not have to send any
memory management messages at all.

00:32:56.380 --> 00:32:58.310
The exception here are
the allocation primitives.

00:32:58.420 --> 00:33:01.970
These return objects which
are not auto-released,

00:33:01.970 --> 00:33:06.320
so alloc, copy, and new are the only
three examples of these,

00:33:06.320 --> 00:33:10.310
or methods that have these,
start with these words.

00:33:12.020 --> 00:33:14.490
Okay,
let's talk about garbage collection now.

00:33:14.590 --> 00:33:16.380
And garbage collection,
like you might expect,

00:33:16.380 --> 00:33:20.700
means that objects are cleaned
up for you automatically.

00:33:20.750 --> 00:33:24.500
This is only available
in 10.5 in Leopard.

00:33:25.180 --> 00:33:27.060
And it's a modern and
full-featured collector.

00:33:27.060 --> 00:33:28.840
So if you know something
about garbage collection,

00:33:28.840 --> 00:33:31.040
the good news is it's very modern.

00:33:31.040 --> 00:33:33.180
It's generational,
which means it doesn't have to scan

00:33:33.180 --> 00:33:35.700
your entire heap every time through.

00:33:35.700 --> 00:33:36.870
It wants to collect objects.

00:33:36.900 --> 00:33:37.750
It's exact.

00:33:37.840 --> 00:33:41.100
So if you have an integer,
which happens to reference an object,

00:33:41.100 --> 00:33:43.200
you know, that happens to have the
same value as a pointer,

00:33:43.200 --> 00:33:45.700
that integer isn't going
to keep that object around.

00:33:45.700 --> 00:33:46.820
It's not going to root it.

00:33:46.900 --> 00:33:49.940
It's concurrent,
so it operates on a separate

00:33:49.940 --> 00:33:50.800
thread in the background.

00:33:50.800 --> 00:33:53.130
Your application isn't going
to have to pause and wait

00:33:53.220 --> 00:33:54.370
while it collects the garbage.

00:33:55.070 --> 00:33:57.610
It's multi-threaded, so it supports
multi-threaded applications.

00:33:57.690 --> 00:34:00.860
And it supports finalization
and weak references,

00:34:00.860 --> 00:34:05.280
which are the semantics you want
from a modern garbage collector.

00:34:05.280 --> 00:34:07.260
So it's a very good collector.

00:34:07.260 --> 00:34:10.710
And under garbage collection,
these reference counting methods,

00:34:10.830 --> 00:34:13.240
like retain and release,
are not called like you'd expect.

00:34:13.240 --> 00:34:17.040
But another method which
is not called is dialog.

00:34:19.020 --> 00:34:20.500
This might be surprising.

00:34:20.540 --> 00:34:22.840
And instead of dialog,
finalize is called.

00:34:22.840 --> 00:34:26.610
And finalize is a chance to do
sort of last-minute cleanup,

00:34:26.620 --> 00:34:29.990
for example,
closing file descriptors or sockets.

00:34:30.100 --> 00:34:33.220
And most classes do not
need to implement finalize.

00:34:33.220 --> 00:34:37.750
In fact, you should try to avoid it
because finalize can be a

00:34:37.750 --> 00:34:37.750
drag on your performance.

00:34:40.920 --> 00:34:45.150
So you might expect, you know,
Objective-C supports garbage collection,

00:34:45.150 --> 00:34:48.450
I don't have to worry about
any memory management,

00:34:48.450 --> 00:34:48.450
but

00:34:48.880 --> 00:34:52.380
C and C++ code still uses the
traditional memory management.

00:34:52.440 --> 00:34:54.620
So if you call malloc,
and you wanna get a bunch

00:34:54.620 --> 00:34:58.900
of memory back from malloc,
this memory you will still have to free.

00:34:58.990 --> 00:35:02.480
It was not freed automatically
for you by the garbage collector.

00:35:02.480 --> 00:35:05.900
And likewise,
if you store an object into this memory,

00:35:05.900 --> 00:35:08.660
well that memory's not scanned,
so it's not going to count as

00:35:08.660 --> 00:35:10.120
a reference to your object.

00:35:10.120 --> 00:35:12.560
Your object may still be collected.

00:35:12.560 --> 00:35:16.460
And this may seem like counter-intuitive,
but this really is something you want,

00:35:16.460 --> 00:35:20.850
because it means that C libraries are
not changed by garbage collection.

00:35:20.910 --> 00:35:24.380
This isn't gonna interfere
with a library like OpenGL.

00:35:25.530 --> 00:35:29.610
But if you do want to use garbage
collection with these C-type functions,

00:35:29.610 --> 00:35:30.200
you can.

00:35:30.200 --> 00:35:31.150
There's a way to do this.

00:35:31.220 --> 00:35:33.140
There's a parallel set of functions.

00:35:33.280 --> 00:35:40.180
So there's NSAllocateCollectible,
which allocates memory which is

00:35:40.180 --> 00:35:40.180
then reclaimed by the garbage
collector when it's unreferenced.

00:35:40.620 --> 00:35:43.170
And if you store an object
into memory that you allocated

00:35:43.310 --> 00:35:47.350
with nsallocate collectible,
it will count as a root and your

00:35:47.350 --> 00:35:49.740
object will not be deallocated.

00:35:49.740 --> 00:35:54.770
All right, let's go back to the machine
and do some event handling.

00:35:59.530 --> 00:36:06.770
So we're going to start
by adding two new methods,

00:36:06.770 --> 00:36:13.610
start new squiggle,
which will be called when

00:36:13.610 --> 00:36:14.180
the user clicks on the view,
and continue squiggle,

00:36:14.180 --> 00:36:14.180
which will be called when
the user drags the mouse.

00:36:14.580 --> 00:36:20.320
is the founder of Cocoa Touch,
and he's the founder of

00:36:20.320 --> 00:36:20.320
the Google Cloud Platform.

00:36:23.540 --> 00:36:25.430
We'll add some helper functions here.

00:36:25.530 --> 00:36:28.180
So we'll start by
saying current squiggle,

00:36:28.180 --> 00:36:30.310
which is whatever we're
drawing right now,

00:36:30.310 --> 00:36:32.500
and that will be the
last one in our array.

00:36:32.820 --> 00:36:39.490
We'll have methods addSquiggle,
which will allow us to add a squiggle to

00:36:39.490 --> 00:36:39.490
the array and likewise remove squiggle.

00:36:41.120 --> 00:36:44.960
The two methods we just declared
will have start new squiggle.

00:36:45.070 --> 00:36:48.100
We'll make a random color,
so we'll just pick random floating

00:36:48.100 --> 00:36:49.840
point values for the color.

00:36:49.840 --> 00:36:51.380
We'll make an instance of this squiggle.

00:36:51.380 --> 00:36:54.030
Because we're calling alloc,
we'll have to make sure

00:36:54.030 --> 00:36:55.330
to release this later.

00:36:56.390 --> 00:36:57.670
We'll set it to the current color.

00:36:57.860 --> 00:37:03.400
We'll set the thickness to another
random value between one and four.

00:37:03.800 --> 00:37:08.340
We'll add the point that the
user clicked to the squiggle.

00:37:08.340 --> 00:37:09.390
We'll add the squiggle to ourselves.

00:37:09.920 --> 00:37:12.260
Then we'll tell the
view it needs to redraw.

00:37:12.340 --> 00:37:15.400
And I see I forgot to
actually release this.

00:37:16.530 --> 00:37:18.770
Likewise,
Continuous Squiggle will get the current

00:37:18.770 --> 00:37:23.580
squiggle that we're drawing and add
the point that the user dragged to that

00:37:23.580 --> 00:37:26.140
squiggle and tell the view to redraw.

00:37:30.230 --> 00:37:34.900
The view needs to call these
new add and continue methods.

00:37:34.900 --> 00:37:38.470
So we have in mouse down,
which is called in the user clicks,

00:37:38.610 --> 00:37:41.760
we'll get the location the
user clicked on and we'll call

00:37:41.760 --> 00:37:43.860
this start new squiggle method.

00:37:43.920 --> 00:37:51.740
Likewise, with mouse dragged,
we'll get the point the user

00:37:51.750 --> 00:37:51.980
dragged to and we'll call
continue squiggle with that point.

00:37:54.300 --> 00:37:59.060
So now we should have an application
where you can do some basic drawing.

00:37:59.180 --> 00:38:04.050
So now if I click,
I can draw with random colors,

00:38:04.050 --> 00:38:06.580
different designs.

00:38:06.690 --> 00:38:09.170
Okay,
so it's getting more interesting now.

00:38:15.310 --> 00:38:18.700
We saw this,
the way we handled these mouse down

00:38:18.700 --> 00:38:22.300
and mouse dragged events was just
by overriding methods on NSView.

00:38:22.480 --> 00:38:25.090
So we override,

00:38:26.210 --> 00:38:28.600
And the event that's passed
to them is a single event

00:38:28.600 --> 00:38:31.490
type for every possible event,
and it has methods like

00:38:31.490 --> 00:38:32.550
the type of the event.

00:38:32.560 --> 00:38:34.020
Is it a mouse down?

00:38:34.020 --> 00:38:36.270
Is it a, you know, a key event?

00:38:36.270 --> 00:38:38.950
And when it happened and where
in the window it happened,

00:38:39.100 --> 00:38:42.050
what the user typed and things like this.

00:38:42.100 --> 00:38:45.210
And the way you handle these events,
as I said, is to override methods such

00:38:45.220 --> 00:38:46.980
as mouse down in your view.

00:38:47.110 --> 00:38:50.560
Cocoa will call these methods
for you at the right time.

00:38:50.560 --> 00:39:00.800
Let's go back to a demo now.

00:39:00.800 --> 00:39:03.730
So now what I want is to have the

00:39:14.290 --> 00:39:18.620
We want to draw this squiggle multiple
times to get that sort of vortex effect.

00:39:18.640 --> 00:39:21.290
And to do that, we're going to define

00:39:21.790 --> 00:39:25.230
will be using a change rotation
count method on our controller.

00:39:25.280 --> 00:39:27.140
This will be called when
the user drags a slider.

00:39:27.140 --> 00:39:31.170
So here we're going to
uncomment change rotation count.

00:39:32.500 --> 00:39:33.360
Here we're going to define it.

00:39:33.440 --> 00:39:37.300
When the change rotation count is called,
we're just going to get the

00:39:37.310 --> 00:39:41.530
value of the slider and store
that and call setNeedsDisplay

00:39:41.530 --> 00:39:43.720
to tell the view to redraw.

00:39:44.920 --> 00:39:49.640
When the view uses this,
it will be in draw rect.

00:39:49.640 --> 00:39:53.420
What it will do is-- I didn't comment
this out-- it will make a rotation,

00:39:53.490 --> 00:39:56.420
an NS affine transform,
and it will rotate by a

00:39:56.420 --> 00:39:58.360
certain number of degrees.

00:39:58.530 --> 00:40:04.520
And all that will do is,
every time we use this,

00:40:04.520 --> 00:40:07.320
it will cause the content
of the view to rotate a bit,

00:40:07.320 --> 00:40:07.320
and then we will redraw it.

00:40:08.140 --> 00:40:11.930
For every value, every number rotation
that we set in the slider,

00:40:11.990 --> 00:40:17.100
it will cause it to draw
the squiggle multiple times.

00:40:17.100 --> 00:40:20.890
We'll see how to set up the slider now.

00:40:26.200 --> 00:40:27.100
Here's our window.

00:40:27.100 --> 00:40:29.940
We'll drag out some space for the slider.

00:40:29.940 --> 00:40:37.540
We've got a horizontal slider.

00:40:37.540 --> 00:40:40.620
We'll give it a size
so it spans the view.

00:40:48.900 --> 00:40:56.090
And we'll set as its action...
this method we just defined,

00:40:56.190 --> 00:40:57.760
changeRotationCount.

00:40:57.760 --> 00:41:03.170
So now...

00:41:06.830 --> 00:41:10.070
When I draw this, I can have it-- oh,
it didn't work.

00:41:10.180 --> 00:41:11.940
I forgot.

00:41:16.100 --> 00:41:19.340
It took a second?

00:41:19.340 --> 00:41:19.980
Oh, there it goes.

00:41:19.990 --> 00:41:22.690
Oh, I didn't make it continuous.

00:41:26.690 --> 00:41:31.490
So, as a... Oh, it doesn't matter.

00:41:31.490 --> 00:41:35.350
Okay, let's go back.

00:41:37.290 --> 00:41:38.500
So what do we just do here?

00:41:38.580 --> 00:41:43.700
Well, let's say you have a button
and you put it in a window.

00:41:43.700 --> 00:41:45.720
And that's really easy to
do in Interface Builder,

00:41:45.720 --> 00:41:46.240
right?

00:41:46.300 --> 00:41:49.890
And the next question is,
"Now what?" Where does my code go?

00:41:49.980 --> 00:41:53.780
This is just a variation of the
question we asked at the very beginning.

00:41:53.780 --> 00:41:56.520
How do I make the button do
something when it's clicked?

00:41:57.660 --> 00:42:00.400
Well, you might think, well, hey,
NSButton subclasses NSView.

00:42:00.400 --> 00:42:02.190
I know how to handle mouse events.

00:42:02.300 --> 00:42:04.090
I'll just subclass mouse down.

00:42:04.100 --> 00:42:08.620
And that would work,
but that's a lot of subclasses, right?

00:42:08.620 --> 00:42:11.510
If you have to subclass NSButton
every time you want to have it do

00:42:11.510 --> 00:42:14.130
something else when you click on it,
you're going to wind up

00:42:14.130 --> 00:42:15.520
with dozens of subclasses.

00:42:15.540 --> 00:42:18.340
And besides,
this is the wrong place for this code.

00:42:18.340 --> 00:42:23.240
NSButton has enough to worry about
just showing the user interface.

00:42:23.330 --> 00:42:26.160
It doesn't need to have all
your business logic in it.

00:42:27.100 --> 00:42:30.430
So Cocoa has better ways to separate
what happens when you click on

00:42:30.440 --> 00:42:31.860
a button from the button itself.

00:42:33.970 --> 00:42:36.590
Subclassing is not
necessary for most classes.

00:42:36.670 --> 00:42:39.550
You have a subclass and its view,
most of the time you

00:42:39.550 --> 00:42:41.380
don't have the subclass.

00:42:41.380 --> 00:42:45.370
We have three different methods for
separating the logic from the actual,

00:42:45.370 --> 00:42:46.230
from the class.

00:42:46.510 --> 00:42:51.490
So we call these target/action,
delegation and notifications.

00:42:52.150 --> 00:42:54.800
So target/action means that
when you click a button,

00:42:54.800 --> 00:42:57.300
it needs to make something happen.

00:42:57.330 --> 00:42:59.920
And the way it does that is
by every control having what's

00:42:59.920 --> 00:43:01.430
called a target and an action.

00:43:01.580 --> 00:43:05.960
So the target is the object that
will be receiving the method,

00:43:06.070 --> 00:43:10.940
the object where your code lives,
and the action is just the name

00:43:10.940 --> 00:43:15.970
of the method that will be called
when the user clicks on the button.

00:43:15.970 --> 00:43:15.970
And you can set these up very
easily in Interface Builder,

00:43:15.970 --> 00:43:15.970
as you saw.

00:43:17.250 --> 00:43:20.710
So, for example,
our button could have a target of the

00:43:20.710 --> 00:43:23.440
NS application and an action of hide.

00:43:23.440 --> 00:43:26.260
Then, as you might expect,
you click on the button,

00:43:26.260 --> 00:43:28.200
it makes your application hide.

00:43:28.410 --> 00:43:32.270
In our case, we have a slider and
we have our controller,

00:43:32.270 --> 00:43:35.720
and the target of the slider is
the controller and the action is

00:43:35.720 --> 00:43:37.890
this change rotation count method.

00:43:39.390 --> 00:43:43.170
What we did was we declared this
method change rotation count.

00:43:43.240 --> 00:43:45.800
Oops.

00:43:45.870 --> 00:43:48.130
Gotta go through this again.

00:43:50.700 --> 00:43:54.580
We declared change rotation count.

00:43:54.800 --> 00:43:58.270
This IB action thing might be a
little confusing to you at first,

00:43:58.270 --> 00:44:01.490
but all this is is an annotation for
Interface Builder and also for you.

00:44:01.560 --> 00:44:04.420
So when you get a Cocoa application
you're not familiar with,

00:44:04.430 --> 00:44:06.870
you can look in the header
files and it's really clear,

00:44:06.870 --> 00:44:08.600
"Hey, this method has IB action.

00:44:08.600 --> 00:44:14.470
I know this is a method that's called
from a control that the developer

00:44:14.470 --> 00:44:14.470
set up in Interface Builder."

00:44:15.910 --> 00:44:19.040
And these are not some sort of
weird extension to Objective-C.

00:44:19.040 --> 00:44:21.040
All these are are defined.

00:44:21.140 --> 00:44:25.800
IB action is defined to be void,
so all action messages return void.

00:44:25.860 --> 00:44:27.300
And IB outlet is something else.

00:44:27.340 --> 00:44:31.090
It uses set-up relationships that
is compiled to nothing at all.

00:44:32.370 --> 00:44:41.380
Now, every action message-- or
method has one parameter,

00:44:41.380 --> 00:44:41.380
which is the sender of the action.

00:44:41.380 --> 00:44:41.380
In our case, it would be the NS slider.

00:44:41.840 --> 00:44:45.470
And this is useful because it
allows you to have one object

00:44:45.650 --> 00:44:49.600
with one action message,
action method, that can be hooked up

00:44:49.670 --> 00:44:51.190
to multiple controls.

00:44:51.310 --> 00:44:53.630
So we could have multiple
sliders or buttons in different

00:44:53.780 --> 00:44:55.190
windows calling the same method.

00:44:55.460 --> 00:44:59.650
And we could figure out which one the
user clicked on by looking at the sender.

00:45:02.200 --> 00:45:05.790
So, just to summarize,
you can define your methods,

00:45:05.910 --> 00:45:10.750
such as change rotation count in Xcode,
and then you can hook these up into

00:45:10.750 --> 00:45:13.550
your controls in Interface Builder.

00:45:15.160 --> 00:45:20.590
So another approach we have for
separating objects and factoring

00:45:20.590 --> 00:45:23.000
applications is called delegation.

00:45:23.000 --> 00:45:28.500
Delegation is when one object assigns
responsibilities to a helper object.

00:45:28.670 --> 00:45:31.630
The helper object is called its delegate.

00:45:32.340 --> 00:45:36.350
And the object with the
delegate will call delegate

00:45:36.770 --> 00:45:39.960
methods on its delegate object.

00:45:40.020 --> 00:45:42.630
And maybe you know C# and you think,
"I know what delegates are," but

00:45:42.630 --> 00:45:44.940
these are something totally different.

00:45:44.980 --> 00:45:51.150
In C#, a delegate is sort of
like a function pointer.

00:45:51.150 --> 00:45:54.760
In Objective-C,
a delegate is just an object which

00:45:54.760 --> 00:45:54.760
provides some functionality for another.

00:45:56.730 --> 00:46:00.790
So every class that has a delegate
has its own list of delegate methods.

00:46:00.970 --> 00:46:04.510
And you're--you use the delegate
methods just by implementing them.

00:46:04.600 --> 00:46:11.150
You don't have to inform the class,
you know, "Make sure to tell me

00:46:11.150 --> 00:46:15.260
when your--you know,
if you're a window,

00:46:15.420 --> 00:46:17.590
when your window is going to close."
And you can implement some of these

00:46:17.590 --> 00:46:17.590
or all of the methods or none at all.

00:46:18.040 --> 00:46:20.990
So for example, Windows should close,
all you have to do is implement

00:46:20.990 --> 00:46:23.310
this and it will be called on
your delegate at the right time.

00:46:23.470 --> 00:46:29.190
Cocoa knows to call it based on
using introspection on your object.

00:46:32.460 --> 00:46:36.080
In your window should close method,
the window is passed to you.

00:46:36.240 --> 00:46:40.830
This is very similar to target/action,
where the control is passed to your

00:46:40.990 --> 00:46:43.630
action message or your action method.

00:46:43.780 --> 00:46:45.060
Excuse me.

00:46:45.220 --> 00:46:50.560
Here the object is passed
to the delegate method,

00:46:50.760 --> 00:46:53.960
and this allows you to disambiguate
between perhaps multiple windows

00:46:53.960 --> 00:46:53.960
that all have the same delegate.

00:46:54.140 --> 00:46:56.620
And it's very easy to set up a
delegate in Interface Builder,

00:46:56.630 --> 00:46:58.100
just like it is in Xcode.

00:46:58.100 --> 00:47:01.070
Excuse me,
just like it is with target/action.

00:47:01.250 --> 00:47:03.520
You can do it by calling
setDelegate in Xcode,

00:47:03.520 --> 00:47:06.800
or you can hook it up by
dragging an interface builder.

00:47:06.900 --> 00:47:10.860
Here we're having our object
as the delegate of the window.

00:47:13.390 --> 00:47:15.350
So once you've done that,
once you've hooked it up,

00:47:15.350 --> 00:47:17.300
you have to implement
your delegate method.

00:47:17.300 --> 00:47:19.360
For example, Windows should close.

00:47:20.070 --> 00:47:22.830
And here we're saying, you know,
if our document has some unsaved changes,

00:47:22.840 --> 00:47:25.360
then we'll confirm unsaved changes.

00:47:25.360 --> 00:47:28.440
And if the user does not want
to actually close the window,

00:47:28.440 --> 00:47:31.190
then we'll return no and
the window won't close.

00:47:31.640 --> 00:47:34.890
So this window will recognize, hey,
this object implemented this

00:47:34.890 --> 00:47:37.350
delegate method and will call it.

00:47:37.970 --> 00:47:38.890
And then you're done.

00:47:38.910 --> 00:47:41.510
You don't have to do anything else.

00:47:41.750 --> 00:47:44.230
So delegation is a good thing.

00:47:44.240 --> 00:47:45.750
Why is it good?

00:47:45.960 --> 00:47:49.780
It helps you factor your application
into separating your business

00:47:49.780 --> 00:47:52.290
logic right from your NS window.

00:47:53.060 --> 00:47:54.390
The logic can live where it belongs.

00:47:54.470 --> 00:47:57.580
You don't have to make a bunch of
subclasses just to change behavior.

00:47:57.710 --> 00:47:59.560
And it's really convenient.

00:47:59.660 --> 00:48:04.120
Often you already have an object which
makes a perfect delegate for the window

00:48:04.120 --> 00:48:06.840
or for whatever has the delegate methods.

00:48:06.840 --> 00:48:10.080
And it's really easy to set
up a delegate relationship.

00:48:12.050 --> 00:48:14.360
So what kind of things
can delegate methods do?

00:48:14.360 --> 00:48:15.940
Well,
sometimes they can influence the object.

00:48:16.060 --> 00:48:17.940
So we saw windowShouldClose.

00:48:17.970 --> 00:48:20.980
That gets called to determine
if the window should close,

00:48:21.000 --> 00:48:24.400
and if the delegate method returns no,
the window won't close.

00:48:24.400 --> 00:48:26.250
But sometimes they're
only purely informative.

00:48:26.400 --> 00:48:30.350
For example, menu has a delegate,
which will tell you when the

00:48:30.350 --> 00:48:32.470
menu is about to open or close.

00:48:32.910 --> 00:48:36.410
Once in a while, some classes,
like NS Toolbar, depend on their delegate

00:48:36.410 --> 00:48:38.330
for lots of functionality,
for everything.

00:48:38.420 --> 00:48:40.920
They can't work with a better delegate.

00:48:45.860 --> 00:48:51.800
The third style of separating the sort
of concerns is called notification.

00:48:51.880 --> 00:48:55.170
And a notification is when an
object just broadcasts events.

00:48:55.320 --> 00:49:02.010
For example, the window has a
notification where it says,

00:49:02.010 --> 00:49:04.670
"I'm going to close." It says,
"Window will close notification."

00:49:04.670 --> 00:49:04.670
And then normally the
window will just go away.

00:49:05.550 --> 00:49:10.160
If an object listens for these events,
if it registers via

00:49:10.160 --> 00:49:14.400
NS Notification Center,
here comes the object and it's listening.

00:49:14.520 --> 00:49:20.010
When the window says,
"I'm going to close," the object will

00:49:20.310 --> 00:49:20.310
hear this and it can take action,
jump up and down.

00:49:21.110 --> 00:49:25.500
And this is really useful compared to
delegation because you can have multiple

00:49:25.500 --> 00:49:27.380
objects listening for one notification.

00:49:27.380 --> 00:49:31.010
So here we have three objects
all listening for the window as

00:49:31.010 --> 00:49:33.250
it broadcasts its notification.

00:49:34.970 --> 00:49:37.800
However, notifications can't be used
to influence the object.

00:49:37.930 --> 00:49:41.160
So the window,
the objects cannot veto closing

00:49:41.480 --> 00:49:46.030
from a notification the same
way they can from a delegate.

00:49:46.660 --> 00:49:49.570
So to use a notification,
you do it by registering with

00:49:49.570 --> 00:49:53.570
NSNotificationCenter and telling it
which notifications you want to receive,

00:49:53.570 --> 00:49:57.150
and you receive a notification the
same way you do with target action

00:49:57.150 --> 00:50:00.880
where you say this is the object I want
to receive the notification on and

00:50:00.880 --> 00:50:02.630
this is the method you should call.

00:50:02.750 --> 00:50:05.820
So, for example,
for the window should close,

00:50:05.940 --> 00:50:07.200
we'll add observer self.

00:50:07.200 --> 00:50:10.140
This is the object that
should receive notification.

00:50:10.250 --> 00:50:12.370
We want to have window
closed called on us.

00:50:12.370 --> 00:50:13.960
That's the name of the method.

00:50:14.000 --> 00:50:17.880
The name of the notification is we'll
close and the name of the object,

00:50:17.980 --> 00:50:22.370
the object itself is the window
we want to be notified for.

00:50:22.980 --> 00:50:29.090
But if you say "null" as the name,
this is very useful because

00:50:29.090 --> 00:50:31.600
it will let you listen for all
notifications for the window.

00:50:31.600 --> 00:50:34.590
So the window will close
and the window will resize.

00:50:34.820 --> 00:50:37.140
The window will become key.

00:50:37.220 --> 00:50:39.410
Everything the window
tells you it's going to do,

00:50:39.530 --> 00:50:40.390
you will receive.

00:50:40.710 --> 00:50:43.540
And likewise,
you can listen for notifications

00:50:44.080 --> 00:50:48.600
from any object by passing "null"
as the object of the notification.

00:50:48.670 --> 00:50:52.210
So this will tell you any time
any window is going to close.

00:50:52.960 --> 00:50:54.940
And the third mode,
which is very rarely used,

00:50:55.030 --> 00:50:57.120
is to say null for both
the name and the object.

00:50:57.230 --> 00:51:00.690
This will tell you every time any
object posts any notification.

00:51:00.790 --> 00:51:03.740
This isn't usually very useful,
but it's there if you

00:51:03.870 --> 00:51:06.230
need it for debugging,
for example.

00:51:07.220 --> 00:51:09.980
And you can hook into the
NS notifications yourself by

00:51:09.990 --> 00:51:11.950
just defining your notifications.

00:51:11.950 --> 00:51:12.740
And this is very easy.

00:51:12.740 --> 00:51:16.400
You just define a string,
and that becomes the

00:51:16.400 --> 00:51:18.490
name of the notification.

00:51:19.990 --> 00:51:22.170
And a nice property of
notifications is they don't

00:51:22.170 --> 00:51:24.280
interfere with garbage collection.

00:51:24.370 --> 00:51:27.610
So, for example, in C#,
it's common to have an object

00:51:27.610 --> 00:51:31.960
listening for an event,
and then that object is never collected.

00:51:32.000 --> 00:51:35.060
It just gets leaked.

00:51:35.280 --> 00:51:39.220
So for example, say you have a button and
it wants to listen for the

00:51:39.220 --> 00:51:41.630
NSControlTintDidChange notification.

00:51:41.890 --> 00:51:44.760
So this is a custom subclass
of button and it needs to draw

00:51:44.760 --> 00:51:48.140
differently depending on if the
user selects Aqua or graphite in

00:51:48.140 --> 00:51:49.960
the appearance preference pane.

00:51:50.270 --> 00:51:55.870
And by listening for this notification,
you can be told when the user changes

00:51:55.870 --> 00:51:55.870
this and you can change the way you draw.

00:51:56.480 --> 00:51:59.490
This will not prevent the object
from being garbage collected,

00:51:59.490 --> 00:52:01.940
so the object can still be
collected even though it's

00:52:02.020 --> 00:52:03.880
listening for this notification.

00:52:05.650 --> 00:52:08.580
Under reference counting, though,
you still must unregister

00:52:08.580 --> 00:52:10.180
with the Notification Center.

00:52:10.180 --> 00:52:12.410
Otherwise,
the Notification Center will try

00:52:12.410 --> 00:52:15.990
to message your deallocated object
and your application will crash.

00:52:16.100 --> 00:52:19.830
Under garbage collection,
you do not have to deregister.

00:52:20.900 --> 00:52:25.020
So notifications are good because they
loosen coupling between the objects,

00:52:25.050 --> 00:52:29.400
so the object can listen for a window
will close notification from anywhere.

00:52:29.400 --> 00:52:32.510
The window doesn't have
to be aware of that fact.

00:52:33.120 --> 00:52:35.850
And it also provides a very
generic interface to system events.

00:52:36.030 --> 00:52:40.430
So we saw the control tint did change,
but there's also disks were

00:52:40.430 --> 00:52:44.000
mounted or unmounted or
applications launched or quit.

00:52:44.090 --> 00:52:46.380
And this is all available
through notifications.

00:52:46.550 --> 00:52:54.940
You do not have to learn some
separate API for every different

00:52:54.940 --> 00:52:56.290
possible event like this.

00:52:56.290 --> 00:52:56.290
Let's go back to demos.

00:53:07.610 --> 00:53:10.040
With this version of the app,
I've changed the controller

00:53:10.040 --> 00:53:15.780
to be an instance of-- or
a subclass of NSDocument.

00:53:15.780 --> 00:53:17.770
And that's mostly all I did.

00:53:19.120 --> 00:53:24.090
So what NS Document has us do
is we have to define methods

00:53:24.180 --> 00:53:26.540
for reading and writing,
and we'll see how we did that.

00:53:26.570 --> 00:53:29.510
Here we used serialization,
although we didn't-- I'm not

00:53:29.590 --> 00:53:31.670
going to talk about serialization.

00:53:34.470 --> 00:53:39.970
And by making that simple change,
we can have multiple windows.

00:53:40.060 --> 00:53:43.610
So here I can draw and--

00:53:44.010 --> 00:53:51.100
"We can also save these,
so I'll call this Vortex for example.

00:53:51.530 --> 00:53:55.230
"And when I quit,
I can double click here and

00:53:55.590 --> 00:54:01.630
my document is available for
me to continue working on.

00:54:01.710 --> 00:54:04.550
And this took very little code to do.

00:54:10.650 --> 00:54:14.600
Go back to slides.

00:54:14.600 --> 00:54:18.900
So, as you know,
a lot of Mac OS X applications

00:54:18.990 --> 00:54:21.190
will view and edit files.

00:54:21.330 --> 00:54:25.530
For example, Xcode and Instruments and
AppleScript and Keynote up here.

00:54:25.610 --> 00:54:29.370
And these are referred to as
document-based applications because

00:54:29.370 --> 00:54:31.360
they use the NSDocument class.

00:54:31.480 --> 00:54:35.750
And the NSDocument class gives them
very rich and uniform behavior.

00:54:35.880 --> 00:54:40.450
So all Cocoa NSDocument-based
applications will work very similarly.

00:54:42.700 --> 00:54:55.330
And it gives you a lot for free.

00:54:55.330 --> 00:54:55.330
So, for example,
if you're working on a file

00:54:55.330 --> 00:54:55.330
and the user moves the file,
the Cocoa Document class will

00:54:55.330 --> 00:54:55.330
notice that and give the user,
you know,

00:54:55.600 --> 00:55:18.100
[Transcript missing]

00:55:19.560 --> 00:55:22.140
And it has a bunch more features,
which just happen for free.

00:55:22.140 --> 00:55:26.170
All the save menu items work
correctly for a Macintosh application.

00:55:26.350 --> 00:55:30.180
It's got auto-save for
backing up the files,

00:55:30.200 --> 00:55:36.770
and it will preserve aliases and get a
lot of difficult functionality correct.

00:55:38.240 --> 00:55:40.500
So to use NSDocument, it's very easy.

00:55:40.520 --> 00:55:43.520
You subclass NSDocument to
support your own file type.

00:55:43.650 --> 00:55:47.680
So for every file type you want your
document to -- your program to support,

00:55:47.710 --> 00:55:50.600
you have a different
subclass of NSDocument.

00:55:50.810 --> 00:55:57.850
Then you override a read method,
which is called when your document

00:55:58.020 --> 00:55:59.730
needs to read from the file,
and the write method when the

00:55:59.730 --> 00:55:59.730
document needs to write to the disk.

00:56:00.580 --> 00:56:03.580
And then you override the window nib
name to show your user interface.

00:56:03.680 --> 00:56:12.140
So this is just the name of the nib,
which-- and its document

00:56:12.140 --> 00:56:12.140
should instantiate to show the
window type for that document.

00:56:12.250 --> 00:56:14.360
And you can set these
up very easily in Xcode.

00:56:14.360 --> 00:56:16.460
This may look like a lot
of work you have to do,

00:56:16.460 --> 00:56:21.340
but you can do most of it
in this window right here.

00:56:21.360 --> 00:56:26.210
The document-based template
in Xcode gets you started.

00:56:28.420 --> 00:56:31.960
So, I'm not sure about you,
but often I'll get to the end of

00:56:32.060 --> 00:56:35.720
an application and I'll think,
"I forgot about undo."

00:56:35.980 --> 00:56:40.270
And I'll try to tack on undo,
but this can be hard to do, right?

00:56:40.610 --> 00:56:42.640
Undo is difficult to tack on at the end.

00:56:42.640 --> 00:56:49.860
You have to think about, "Oh,
I need to have perhaps a command

00:56:49.860 --> 00:56:49.860
pattern and I have to find some
way to make this undo stack."

00:56:50.680 --> 00:56:53.940
It seems like an easy feature,
but it's often not.

00:56:54.080 --> 00:56:56.470
But Cocoa gives you an
undo class for free.

00:56:56.640 --> 00:56:59.870
It's called the NSUndoManager,
and it will handle undo and

00:56:59.870 --> 00:57:01.340
redo to multiple levels.

00:57:01.500 --> 00:57:02.940
But it also does more than that.

00:57:02.940 --> 00:57:07.000
NSDocument will hook into undo,
for example, to know if the document

00:57:07.110 --> 00:57:08.660
has unsaved changes.

00:57:08.840 --> 00:57:12.260
And every document has
its own undo manager.

00:57:12.390 --> 00:57:16.710
You can get at it by calling the
undoManager method of NSDocument.

00:57:16.920 --> 00:57:19.990
So, in our class, our application,
we have this addSquiggle

00:57:20.050 --> 00:57:22.280
and removeSquiggle,
and these methods are

00:57:22.280 --> 00:57:24.190
inverses of each other,
right?

00:57:24.280 --> 00:57:27.800
Every method--each method
will undo the other one.

00:57:30.300 --> 00:57:34.640
So what we'd like to have happen is by
maintaining an undo stack of methods that

00:57:34.830 --> 00:57:36.700
should be called when the user hits undo.

00:57:36.830 --> 00:57:40.530
So when we add a squiggle,
what we'd like to have happen is remove

00:57:40.670 --> 00:57:43.100
squiggle needs to go in the undo stack.

00:57:43.140 --> 00:57:47.150
And similarly, as we add more squiggles,
the stack will get higher

00:57:47.280 --> 00:57:49.190
with these remove messages.

00:57:49.380 --> 00:57:56.100
And then when we start removing them,
the stack will start having these add

00:57:56.330 --> 00:57:58.100
squiggles inverse methods applied to it.

00:58:01.810 --> 00:58:05.810
Well, NSUndoManager will manage
this undo stack for you.

00:58:05.810 --> 00:58:08.300
And the way it does this
is very interesting.

00:58:08.300 --> 00:58:12.380
It does it by you sending
the undo manager the messages

00:58:12.380 --> 00:58:14.650
you want to receive later on.

00:58:14.980 --> 00:58:18.240
So, for example, our addSquiggle method

00:58:18.730 --> 00:58:21.160
We want to have
removeSquiggle called on undo.

00:58:21.190 --> 00:58:22.370
We'll get the undo manager.

00:58:22.540 --> 00:58:24.550
We'll say
prepareWithInvocationTarget self.

00:58:24.680 --> 00:58:28.700
This means I want you to call
the following method on me.

00:58:28.870 --> 00:58:31.020
And then you call the
method you want to receive.

00:58:31.200 --> 00:58:32.680
Right?

00:58:32.680 --> 00:58:37.450
RemoveSquiggle is not an
instance method of undo manager.

00:58:37.450 --> 00:58:37.450
It's an instance method of your class.

00:58:38.840 --> 00:58:44.010
So this is an example of dynamic binding
of Cocoa and Objective-C in action.

00:58:45.730 --> 00:58:47.600
And also, Redo is handled for free.

00:58:47.740 --> 00:58:52.480
So if in--in Add Squiggle,

00:58:52.740 --> 00:58:55.860
When that's undone,
you get a remove squiggle method.

00:58:55.860 --> 00:59:01.940
And then when--within
that remove squiggle,

00:59:01.940 --> 00:59:01.940
when you add to the undo stack,
it will actually add to

00:59:01.940 --> 00:59:01.940
the redo stack for you.

00:59:03.350 --> 00:59:05.630
And as I said,
it also integrates with NSDocument.

00:59:05.740 --> 00:59:09.340
So Undo Manager is not just a
way to handle undo and redo.

00:59:09.340 --> 00:59:12.940
It also lets NSDocument know
if there's unsaved changes.

00:59:12.940 --> 00:59:18.140
That allows it to put the
dirty spot in the close button.

00:59:18.140 --> 00:59:22.240
It allows it to warn you if you try
to quit when there's unsaved changes.

00:59:23.850 --> 00:59:27.340
So if you've seen this
dialogue before from TextEdit,

00:59:27.340 --> 00:59:30.250
for example,
this dialogue appears because you

00:59:30.250 --> 00:59:34.460
tried to quit or close the window
while there were unsaved changes.

00:59:34.590 --> 00:59:36.930
So let's see undo in action.

00:59:42.330 --> 00:59:47.310
So here we have our application again.

00:59:47.310 --> 00:59:48.700
And in the document,
all we're going to do

00:59:48.700 --> 00:59:49.760
is add these two lines.

00:59:49.860 --> 00:59:53.330
So in a remove squiggle,
we will call add squiggle.

00:59:54.120 --> 00:59:56.360
In AddSquiggle,
we'll tell the undo manager,

00:59:56.490 --> 00:59:59.340
"Prepare yourself with an
invocation target of me,"

00:59:59.380 --> 01:00:00.830
and then call RemoveSquiggle.

01:00:01.000 --> 01:00:04.330
So Add will tell the
undo manager to remove,

01:00:04.490 --> 01:00:06.790
and remove tells it to add.

01:00:09.960 --> 01:00:13.940
Now when we run this,
as soon as I start drawing,

01:00:13.940 --> 01:00:17.310
you can see we get this
dirty spot up here.

01:00:17.490 --> 01:00:20.580
Now I can choose Edit/Undo
and it goes away.

01:00:21.690 --> 01:00:24.050
I can do multiple squiggles here.

01:00:24.050 --> 01:00:26.970
Let's make that kind of interesting.

01:00:30.200 --> 01:00:53.200
[Transcript missing]

01:01:08.820 --> 01:01:08.860
So, Undo Manager integrated with
NS Document to support many

01:01:08.860 --> 01:01:08.860
of the Mac-like features,
such as warning you when

01:01:08.860 --> 01:01:08.860
the application is quit.

01:01:10.340 --> 01:01:12.150
All right, so what do we see?

01:01:12.270 --> 01:01:14.950
Well, we saw Objective-C,
the programming language,

01:01:14.950 --> 01:01:16.400
and some of its features.

01:01:16.590 --> 01:01:22.670
We saw nib files,
which are a way to serialize an

01:01:22.700 --> 01:01:27.410
object graph to disk and how you
set up your user interface in Cocoa.

01:01:27.410 --> 01:01:27.410
We learned about the Cocoa memory
management techniques.

01:01:27.670 --> 01:01:31.250
And different ways to factor your
application so you don't have to make

01:01:31.330 --> 01:01:35.100
a bunch of subclasses with delegation,
notification, and target/action.

01:01:35.140 --> 01:01:39.050
We looked at some classes, NSObjects,
NSView, and NSDocument,

01:01:39.150 --> 01:01:41.800
and we saw how to get
work done with them.

01:01:42.790 --> 01:01:44.130
But there's a lot more
to Cocoa we haven't seen,

01:01:44.130 --> 01:01:44.520
right?

01:01:44.520 --> 01:01:47.000
We didn't talk about all
the features of Objective-C.

01:01:47.000 --> 01:01:49.260
There's still properties,
and there's still fast

01:01:49.260 --> 01:01:51.120
enumeration and categories.

01:01:51.120 --> 01:01:54.210
We didn't look at any of the
collections that Cocoa has,

01:01:54.220 --> 01:01:56.390
so there's arrays and
dictionaries and sets.

01:01:56.460 --> 01:02:01.780
We didn't talk about the key value
observing or coding features of Cocoa,

01:02:01.780 --> 01:02:04.800
which are used for binding, for example.

01:02:04.870 --> 01:02:10.750
Binding allows you to have a control
synchronized with your model without

01:02:11.190 --> 01:02:13.400
having to set up explicit target actions.

01:02:13.400 --> 01:02:16.940
We didn't talk about drag
and drop or copy and paste.

01:02:18.500 --> 01:02:21.400
And of course there's scripting
and localization and accessibility,

01:02:21.400 --> 01:02:25.800
and these are all really important
features of a well-polished application.

01:02:26.000 --> 01:02:29.680
And Cocoa's got the serialization,
which we used for our document,

01:02:29.680 --> 01:02:33.470
and it has a remoting feature,
which is useful for objects in remote

01:02:33.590 --> 01:02:36.000
processes or on different computers.

01:02:36.100 --> 01:02:40.920
And of course,
the whole core data framework.

01:02:41.130 --> 01:02:44.210
In closing,
the takeaway is that Cocoa gives

01:02:44.210 --> 01:02:47.410
you the sort of functionality
that Mac OS X users expect from

01:02:47.480 --> 01:02:50.000
a polished Macintosh application.

01:02:50.110 --> 01:02:53.080
And the frameworks are easy to
learn because they consistently

01:02:53.080 --> 01:02:54.590
follow the Cocoa conventions.

01:02:54.930 --> 01:02:59.130
And it's not just AppKit and Foundation,
but also frameworks like

01:02:59.190 --> 01:03:03.590
Core Image or QtKit or Core Data all
follow the Cocoa conventions.

01:03:03.590 --> 01:03:07.300
So if you use -- if you
understand the Cocoa conventions,

01:03:07.300 --> 01:03:09.030
it's very easy to learn
these other frameworks.

01:03:09.320 --> 01:03:12.470
By using Cocoa, you can write amazing
apps in very little time.

01:03:12.490 --> 01:03:14.510
I'm sure you will.

01:03:15.310 --> 01:03:18.560
For more information,
you can contact our Cocoa evangelist,

01:03:18.560 --> 01:03:27.100
Derek Horn, or for questions about the
Xcode and interface builder,

01:03:27.100 --> 01:03:27.100
there's Michael Jurowitz, and of course,
there's the documentation.

01:03:27.960 --> 01:03:30.690
And if you'd like to come talk to
me or the other Cocoa engineers,

01:03:30.800 --> 01:03:34.730
there's a lab on
Thursday from 12:00 to 1:45.
WEBVTT

00:00:20.720 --> 00:00:25.900
Good afternoon, everyone,
and welcome to the end of WWDC 2008.

00:00:25.910 --> 00:00:34.710
My name-- You're not supposed
to cheer so much for the end.

00:00:39.070 --> 00:00:42.020
I want to get some sleep too,
so that's okay.

00:00:42.120 --> 00:00:45.230
My name is Greg Parker,
and today I'm going to talk to you

00:00:45.230 --> 00:00:49.680
about some Objective-C and garbage
collection advanced features.

00:00:50.210 --> 00:00:52.300
So the master's course syllabus.

00:00:52.350 --> 00:00:56.030
We're going to start with some
Objective-C runtime features and

00:00:56.030 --> 00:00:59.880
then go into some GC details,
particularly for low-level

00:00:59.880 --> 00:01:04.910
GC programming for C level,
and upgrading a program to garbage

00:01:04.910 --> 00:01:09.530
collection if you have an existing
code that is not garbage collected.

00:01:09.710 --> 00:01:13.490
And finally, some GC debugging tips
for some hard-to-find and

00:01:13.850 --> 00:01:16.640
hard-to-diagnose crashes.

00:01:16.780 --> 00:01:19.790
So let's start with the
Objective-C runtime.

00:01:20.530 --> 00:01:25.620
The topics I'm going to talk about today
briefly are some dynamic properties

00:01:26.190 --> 00:01:28.570
and the modern Objective-C ABI.

00:01:29.030 --> 00:01:32.380
Both of these are present in Leopard,
but they're a little bit

00:01:32.380 --> 00:01:35.550
different in Snow Leopard,
and they're very different on the iPhone,

00:01:35.600 --> 00:01:38.070
which is why we want to go
over them again this year.

00:01:38.070 --> 00:01:42.170
The other topic is
virtual table dispatch,

00:01:42.170 --> 00:01:45.670
which is a nifty little
addition in Snow Leopard.

00:01:45.670 --> 00:01:45.670
We'll see in a minute.

00:01:45.670 --> 00:01:45.670
Greg Parker

00:01:47.030 --> 00:01:48.570
Dynamic properties.

00:01:48.680 --> 00:01:50.940
If you went to the other
Objective-C sessions,

00:01:50.940 --> 00:01:56.810
you saw some descriptions of basic
property usage using the atSynthesize.

00:01:56.970 --> 00:02:02.990
atSynthesize tells the compiler to
create an implementation of the property,

00:02:03.090 --> 00:02:06.670
to create the getter method,
create the setter method.

00:02:07.010 --> 00:02:08.720
Dynamic is different.

00:02:08.860 --> 00:02:13.090
Dynamic means you promise to
provide an implementation later

00:02:13.880 --> 00:02:17.130
through some unspecified mechanism.

00:02:17.280 --> 00:02:20.900
So that just tells the compiler
there will be an implementation.

00:02:20.920 --> 00:02:24.370
Don't give a compiler warning and
trust you to do the right thing.

00:02:24.650 --> 00:02:25.530
So what is the right thing?

00:02:25.550 --> 00:02:31.400
You have a couple different options for
how to implement the dynamic property.

00:02:31.660 --> 00:02:35.620
One option is basically
creating an abstract property.

00:02:35.930 --> 00:02:39.990
In this case,
the superclass declares the property

00:02:40.580 --> 00:02:44.200
and says @dynamic as the implementation.

00:02:44.510 --> 00:02:47.600
And then at runtime,
there is no superclass implementation.

00:02:47.600 --> 00:02:48.400
It's abstract.

00:02:48.400 --> 00:02:53.320
Instead, the subclass actually
implements the property.

00:02:53.370 --> 00:02:56.520
For example,
it could use atSynthesize in the

00:02:56.600 --> 00:03:02.060
subclass's implementation or could
provide getter setter methods directly,

00:03:02.130 --> 00:03:04.440
any number of alternatives.

00:03:05.520 --> 00:03:08.660
This is a good way to get,
if you have an abstract method

00:03:08.740 --> 00:03:12.320
in C++ and you want the similar
sort of model in Objective-C,

00:03:12.600 --> 00:03:15.430
this is the closest you
can get using a property.

00:03:18.550 --> 00:03:22.350
Another option for implementing
the property is to implement

00:03:22.370 --> 00:03:25.900
it at runtime using the
Objective-C forwarding mechanism.

00:03:25.900 --> 00:03:30.670
If you're unfamiliar with this system,
what happens at runtime if you

00:03:30.750 --> 00:03:34.970
call a method that does not exist
is that instead a message is

00:03:35.070 --> 00:03:40.350
sent called forward invocation,
which creates an NS invocation object,

00:03:40.350 --> 00:03:44.110
which represents the
method that did not exist.

00:03:44.110 --> 00:03:48.050
And your class and your object
can handle it themselves.

00:03:49.400 --> 00:03:52.770
So in this case,
the getter method or the setter

00:03:52.770 --> 00:03:56.510
method would be sent to the
object using forward invocation,

00:03:56.580 --> 00:04:00.060
and you can implement forward
invocation to do whatever property

00:04:00.060 --> 00:04:01.720
access you want to provide.

00:04:01.720 --> 00:04:03.590
This mechanism is easy.

00:04:03.590 --> 00:04:05.850
It's easy to write in your code.

00:04:06.050 --> 00:04:09.430
Forward invocation is an
easy mechanism to use,

00:04:09.430 --> 00:04:10.820
but it's slow.

00:04:10.820 --> 00:04:14.170
Actually creating the invocation
object and calling forward

00:04:14.170 --> 00:04:16.800
invocation takes some time,
and that needs to be

00:04:16.800 --> 00:04:18.380
done every single time.

00:04:18.400 --> 00:04:21.430
every time the property is accessed.

00:04:21.730 --> 00:04:25.340
If you want more speed,
the option is to use the

00:04:25.340 --> 00:04:29.680
new technique in Leopard,
which is a resolved property

00:04:29.680 --> 00:04:32.250
or a resolved method.

00:04:32.640 --> 00:04:36.660
This mechanism kicks in before
the forwarding machinery.

00:04:36.860 --> 00:04:42.500
What it does, it calls the resolve
instance method on the class.

00:04:42.500 --> 00:04:47.520
This mechanism allows the class to
create a method if one did not exist

00:04:47.520 --> 00:04:50.300
just before that method gets called.

00:04:50.390 --> 00:04:54.580
So it's really the last chance for
the class to provide an implementation

00:04:54.580 --> 00:04:56.490
if it didn't have one already.

00:04:56.780 --> 00:05:00.590
In the property case,
you can use the property metadata

00:05:01.200 --> 00:05:03.860
that the runtime created,
that the compiler created,

00:05:03.860 --> 00:05:06.590
to decide what the
implementation should look like.

00:05:06.600 --> 00:05:09.970
So, for example,
CoreData NSManagedObject,

00:05:10.050 --> 00:05:13.490
you can write a property
but not implement it.

00:05:13.550 --> 00:05:18.660
CoreData will use the property metadata
and whatever database backing you're

00:05:18.660 --> 00:05:23.420
using for CoreData to create the
implementation at runtime for you.

00:05:24.390 --> 00:05:26.140
This mechanism is more difficult.

00:05:26.140 --> 00:05:32.120
I believe there is a sample code on the
developer.apple.com to show how to do it,

00:05:32.260 --> 00:05:34.140
but it's a little bit tricky,
but not too hard.

00:05:34.140 --> 00:05:37.320
Once the implementation is added,
it's much faster.

00:05:37.320 --> 00:05:40.940
It works just like an ordinary
method at full method speed.

00:05:44.970 --> 00:05:47.700
Next, let's talk about Vtable Dispatch.

00:05:47.830 --> 00:05:51.870
This is a performance
optimization in Snow Leopard.

00:05:52.210 --> 00:05:56.960
The observation is a small number
of selectors are responsible for

00:05:56.960 --> 00:05:59.830
most calls that your program makes.

00:05:59.910 --> 00:06:04.070
ALEC, ENIT, RETAIN,
all these methods that everybody uses,

00:06:04.080 --> 00:06:06.300
everybody calls them.

00:06:06.400 --> 00:06:11.570
And they account for 50% or more of
the method sends in your process.

00:06:11.570 --> 00:06:14.400
Well, let's make them faster.

00:06:14.400 --> 00:06:16.060
How much faster?

00:06:16.060 --> 00:06:18.260
Something like this.

00:06:18.260 --> 00:06:21.990
Two to three times faster
of method dispatch for the

00:06:22.000 --> 00:06:25.520
small number of selectors,
about a dozen or so,

00:06:25.520 --> 00:06:27.910
that constitute most calls.

00:06:29.600 --> 00:06:32.930
The way this works is
a little bit like C++.

00:06:32.930 --> 00:06:36.350
Dynamic methods in C++
use an array lookup.

00:06:36.350 --> 00:06:39.800
In Objective-C,
we use a hash table to provide

00:06:39.890 --> 00:06:44.500
better compatibility and
more flexibility at runtime.

00:06:44.870 --> 00:06:48.880
But for these methods, retain, release,
and a few others,

00:06:48.920 --> 00:06:51.600
we do create a virtual table at runtime.

00:06:51.600 --> 00:06:55.820
We do an array-based dispatch
instead of a hash table lookup.

00:06:56.500 --> 00:07:00.920
As you can see, the array-based dispatch
is quite a bit faster.

00:07:01.260 --> 00:07:04.600
Unlike C++,
this is Objective-C after all,

00:07:04.600 --> 00:07:07.090
we like compatibility and flexibility.

00:07:07.090 --> 00:07:12.550
The virtual table is not
hard-coded at compile time and

00:07:12.710 --> 00:07:18.380
can be modified at runtime,
actually at application launch time.

00:07:18.400 --> 00:07:22.090
So later on in Snow Leopard,
we expect to provide a mechanism

00:07:22.090 --> 00:07:26.650
where your application can identify
which selectors you call frequently

00:07:26.650 --> 00:07:28.860
and that you want to run faster.

00:07:32.930 --> 00:07:36.530
The final Objective-C runtime
topics have to do with the

00:07:36.530 --> 00:07:40.150
modern and legacy runtime ABI.

00:07:40.150 --> 00:07:40.150
Greg

00:07:40.240 --> 00:07:44.720
This describes the metadata layout,
the format on disk,

00:07:44.970 --> 00:07:48.590
the format in memory of the
runtime's data structures.

00:07:48.820 --> 00:07:52.460
On the iPhone and 64-bit Mac,
we have a new platform.

00:07:52.460 --> 00:07:55.070
We could break binary compatibility.

00:07:55.230 --> 00:08:00.300
So we redesigned all the data structures
in Leopard for better performance,

00:08:00.360 --> 00:08:04.640
better memory usage,
and better forward compatibility

00:08:04.640 --> 00:08:07.010
and forward features.

00:08:07.220 --> 00:08:12.500
The iPhone simulator and 32-bit
Mac still use the legacy ABI.

00:08:12.660 --> 00:08:15.400
Different performance,
different set of features.

00:08:15.400 --> 00:08:17.990
So I'm going to talk about some
of the differences between them,

00:08:18.330 --> 00:08:22.650
because if you're porting
to 64-bit on Snow Leopard,

00:08:22.730 --> 00:08:26.390
or if you're writing
an iPhone application,

00:08:26.390 --> 00:08:32.310
you need to know what the differences
are between those platforms versus

00:08:32.310 --> 00:08:32.630
32-bit Mac and the iPhone simulator.

00:08:32.630 --> 00:08:32.630
Greg Parker

00:08:34.940 --> 00:08:40.680
The modern Objective-C ABI adds
stricter IVAR access control.

00:08:41.210 --> 00:08:47.080
The legacy ABI has private IVARs
using the @private keyword.

00:08:47.220 --> 00:08:50.650
But if you use an @private IVAR,
more specifically,

00:08:50.810 --> 00:08:55.240
if you abuse an @private IVAR,
all you get is a compiler warning.

00:08:55.370 --> 00:08:56.590
Your program still runs.

00:08:56.900 --> 00:08:58.800
It still can use the IVAR.

00:08:58.940 --> 00:09:04.440
And whoever made that private
IVAR is a little bit unhappy

00:09:04.440 --> 00:09:05.990
because they wanted a private IVAR,
and you didn't honor that.

00:09:06.530 --> 00:09:11.190
The modern ABI is a bit
stricter with its IVAR access.

00:09:11.330 --> 00:09:15.240
If you access a private IVAR that
belongs to some other framework

00:09:15.400 --> 00:09:18.770
that is outside of your code,
you may get a link error and

00:09:18.900 --> 00:09:20.800
your program will not run.

00:09:20.980 --> 00:09:27.910
This is an example of the link
error given a class name and

00:09:27.980 --> 00:09:29.110
an IVAR name that you weren't
allowed to use that private IVAR.

00:09:29.720 --> 00:09:33.440
So particularly if you're
porting from 32 to 64-bit,

00:09:33.540 --> 00:09:37.710
or if you're compiling an iPhone
application that you've previously

00:09:37.710 --> 00:09:40.830
only seen on the simulator,
you may see this error.

00:09:40.840 --> 00:09:44.580
So moral of the story,
make sure you run your iPhone

00:09:44.580 --> 00:09:49.600
application on a real iPhone,
or at least compile for a real iPhone,

00:09:49.600 --> 00:09:53.910
to make sure you're not
abusing any private IVARs.

00:09:56.560 --> 00:10:01.470
The other new IVAR access feature
is @Package IVAR protection.

00:10:01.960 --> 00:10:07.340
This is a new qualifier added
in Leopard for the modern ABI.

00:10:08.390 --> 00:10:13.420
The summary of how it behaves inside
your application or your framework

00:10:13.520 --> 00:10:19.160
or wherever your IVAR is defined,
it looks like an at public IVAR.

00:10:19.440 --> 00:10:23.010
Outside that,
it looks like a private IVAR.

00:10:23.390 --> 00:10:27.800
So this is useful if you want more
protection than a public IVAR,

00:10:27.800 --> 00:10:31.800
but less protection than a private IVAR.

00:10:31.850 --> 00:10:35.010
And legacy runtime,
it just looks like a public IVAR.

00:10:35.340 --> 00:10:37.300
The compiler doesn't
give you any warnings.

00:10:37.330 --> 00:10:39.930
The linker doesn't give you any errors.

00:10:41.870 --> 00:10:44.910
The final Objective-C feature
in the modern ABI is

00:10:44.910 --> 00:10:47.280
non-fragile instance variables.

00:10:47.380 --> 00:10:50.020
So let me show you a
fragile instance variable.

00:10:50.140 --> 00:10:54.560
Here's a demonstration of
a subclass of NSWindow.

00:10:54.680 --> 00:10:57.690
You're writing some new pet store
that's going to be the next killer app.

00:10:57.760 --> 00:11:02.170
And you've added IVARs for the
kittens and the puppies that

00:11:02.230 --> 00:11:07.050
are visible in the pet store
window in your NSWindow subclass.

00:11:07.050 --> 00:11:09.570
So this is a diagram of how those
IVARs are laid out in memory.

00:11:09.780 --> 00:11:14.460
Now let's say NS Window itself
wanted to add new IVARs.

00:11:14.530 --> 00:11:18.910
The problem is, in the legacy ABI,
the IVARs collide.

00:11:18.920 --> 00:11:22.850
They try and take the same memory,
and it crushes your kittens.

00:11:22.900 --> 00:11:24.850
Aww.

00:11:26.310 --> 00:11:27.360
We don't want this.

00:11:27.430 --> 00:11:29.040
The modern ABI works better.

00:11:29.040 --> 00:11:31.720
It moves the IVARs out of the way.

00:11:31.740 --> 00:11:37.840
The compiler and the runtime
cooperate so that the IVAR offsets are

00:11:37.840 --> 00:11:43.460
available to be modified at runtime
without recompiling the subclass,

00:11:43.460 --> 00:11:48.190
which means the runtime can notice that
the superclass is now bigger or that

00:11:48.190 --> 00:11:52.650
the IVARs got rearranged or anything
like that and modify the offsets so

00:11:52.650 --> 00:11:55.500
that the code works without recompiling.

00:11:55.940 --> 00:11:56.670
Saves the kittens.

00:11:56.670 --> 00:11:57.520
Everybody's happy.

00:12:02.540 --> 00:12:07.420
Again, this works in 64-bit,
and this works on an iPhone application,

00:12:07.420 --> 00:12:11.520
but it does not work in the 32-bit Mac,
and it does not work on

00:12:11.520 --> 00:12:12.950
the iPhone simulator.

00:12:16.730 --> 00:12:21.470
The last ABI feature is
C++ compatible exceptions.

00:12:21.610 --> 00:12:26.580
Again, let me show you what the
legacy ABI did wrong.

00:12:27.020 --> 00:12:29.060
and how it works better in the modern.

00:12:29.160 --> 00:12:33.260
Here's a simple set of code,
Objective-C++ code,

00:12:33.260 --> 00:12:35.330
that is doing some exception handling.

00:12:35.480 --> 00:12:40.780
We have a C++ try block
and an Objective-C throw.

00:12:41.560 --> 00:12:43.620
The problem in the legacy ABI.

00:12:43.760 --> 00:12:47.100
First of all,
we have a destructor for an object.

00:12:47.650 --> 00:12:53.510
When the exception is thrown,
the destructor is not called because C++

00:12:53.510 --> 00:12:58.240
exceptions and Objective-C exceptions
are not compatible in the legacy ABI.

00:12:58.240 --> 00:13:02.840
We also have this catch block,
also not called when the

00:13:03.270 --> 00:13:06.390
Objective-C exception is thrown.

00:13:06.780 --> 00:13:09.110
The same thing would happen
if you reversed the cases,

00:13:09.190 --> 00:13:13.860
if you had an Objective-C try
and a C++ throw.

00:13:14.340 --> 00:13:17.200
The modern runtime fixes all of this.

00:13:17.320 --> 00:13:21.080
It does call the destructor,
does call the catch block.

00:13:21.240 --> 00:13:25.830
If we reverse the languages
to be Objective-C try,

00:13:25.830 --> 00:13:28.480
C++ throw, it also works.

00:13:28.630 --> 00:13:32.750
The destructor is called the
Objective-C default catch or

00:13:32.750 --> 00:13:35.140
finally block is also called.

00:13:35.310 --> 00:13:39.290
So 64-bit and iPhone,
the exceptions now work the

00:13:39.290 --> 00:13:43.760
way you want if you're writing
C++ and Objective-C code.

00:13:44.990 --> 00:13:48.580
One other detail, zero cost exceptions.

00:13:48.580 --> 00:13:52.860
I put zero cost in quotes because
they're not really zero cost.

00:13:53.020 --> 00:13:59.740
What zero cost means is actually
zero CPU time tri-blocks.

00:13:59.870 --> 00:14:01.570
They still cost a memory.

00:14:01.740 --> 00:14:04.130
Throwing exceptions still
takes a lot of time,

00:14:04.170 --> 00:14:07.850
so you may not actually want to
use exceptions quite so much,

00:14:08.290 --> 00:14:09.710
especially on the iPhone.

00:14:09.770 --> 00:14:12.090
Exceptions are slow in general.

00:14:12.090 --> 00:14:12.090
Greg

00:14:12.360 --> 00:14:17.960
This diagram shows you which exceptions
are zero cost on which platforms.

00:14:18.100 --> 00:14:22.010
64-bit Mac and iPhone
using the modern ABI,

00:14:22.010 --> 00:14:27.520
C++ and Objective-C are either both
zero cost or neither zero cost.

00:14:27.520 --> 00:14:32.530
In the legacy platforms,
the 32-bit Mac and the simulator,

00:14:32.940 --> 00:14:36.040
Objective-C is not zero cost, but C++ is.

00:14:37.610 --> 00:14:42.600
So just keep that in mind if you're
writing exception code and you care

00:14:42.600 --> 00:14:46.130
about that performance of dry blocks.

00:14:47.560 --> 00:14:51.440
So that's all I have to say
about the Objective-C runtime.

00:14:51.440 --> 00:14:55.480
We've seen dynamic properties,
how you can build flexible

00:14:55.480 --> 00:14:57.860
runtime storage for them.

00:14:57.960 --> 00:15:00.980
We've seen Vtable dispatch,
a nice performance boost for you.

00:15:01.190 --> 00:15:04.730
And we've seen the modern ABI,
which improves some features like

00:15:04.730 --> 00:15:08.680
IVARs and exceptions if you're
writing for 64-bit Mac or if you're

00:15:08.680 --> 00:15:10.990
writing for the iPhone platform.

00:15:14.440 --> 00:15:18.060
Next on the agenda,
low-level garbage collection programming.

00:15:18.070 --> 00:15:25.230
So I'm going to go through several topics
of how to write garbage collection code

00:15:25.230 --> 00:15:31.700
at a low level when you're not working
with ordinary Objective-C objects.

00:15:32.260 --> 00:15:35.290
I'll start with the
GC memory system in general.

00:15:35.410 --> 00:15:39.830
Some of this will be familiar if you
saw the earlier garbage collection talk,

00:15:39.940 --> 00:15:43.340
but I'll go to a bit more detail
about how the garbage collector works.

00:15:43.340 --> 00:15:48.490
Objective-C's garbage collector
is designed for Objective-C code

00:15:48.490 --> 00:15:50.740
and Objective-C objects.

00:15:50.740 --> 00:15:54.120
That's where most of the code
to our platform is written.

00:15:54.120 --> 00:15:58.460
That's what we've optimized for
and designed it to work best with.

00:15:59.000 --> 00:16:01.560
It is not a new pointer-safe language.

00:16:01.640 --> 00:16:05.530
We still have C, we still have void stars
we have to deal with.

00:16:05.530 --> 00:16:11.030
And the garbage collector is not trying
to manage all memory in your process.

00:16:11.090 --> 00:16:14.210
In particular,
malloc blocks are not managed.

00:16:14.210 --> 00:16:15.570
They can still leak.

00:16:15.680 --> 00:16:18.830
Malloc blocks are also
not scanned for pointers.

00:16:18.930 --> 00:16:22.140
If you store a pointer to
a garbage-collected object

00:16:22.140 --> 00:16:26.000
inside a malloc block,
the garbage collector may not see that

00:16:26.000 --> 00:16:28.730
pointer and may throw the object away.

00:16:31.120 --> 00:16:34.530
So let's talk about what the
garbage collector does manage.

00:16:34.680 --> 00:16:38.100
It manages all of your
Objective-C objects.

00:16:38.100 --> 00:16:41.100
It manages all of your
core foundation objects,

00:16:41.100 --> 00:16:42.720
CFStrings, CFArray.

00:16:42.720 --> 00:16:47.540
And finally, it manages heap blocks from
a new foundation function

00:16:47.540 --> 00:16:50.160
called NSAllocateCollectible.

00:16:50.160 --> 00:16:55.100
This is basically your malloc replacement
if you want an ordinary block of data,

00:16:55.100 --> 00:16:59.940
but you want the garbage collector to
know about it and to manage it for you.

00:17:00.880 --> 00:17:04.820
Unlike your heap blocks from malloc,
or operator new for that matter,

00:17:04.820 --> 00:17:08.710
the garbage collector will not
destroy those objects for you.

00:17:08.720 --> 00:17:10.970
You're still responsible
for freeing them yourself.

00:17:12.860 --> 00:17:16.040
I mentioned the garbage collector
does not look at all memory,

00:17:16.270 --> 00:17:19.280
primarily for performance,
also because it's hard for the

00:17:19.280 --> 00:17:22.750
garbage collector to know about
all the memory in your process.

00:17:22.870 --> 00:17:24.470
Where does it look?

00:17:24.640 --> 00:17:28.490
It looks in instance variables
and global variables of

00:17:28.490 --> 00:17:33.780
Objective-C types and instance
variables and globals marked strong.

00:17:34.340 --> 00:17:39.750
It also looks in some thread
stacks for NS threads,

00:17:39.780 --> 00:17:44.280
and it looks inside some heap blocks,
the ones allocated with

00:17:44.280 --> 00:17:48.530
NSAllocateCollectible
with the NSScanned option.

00:17:49.380 --> 00:17:51.090
Everywhere else, it doesn't look.

00:17:51.090 --> 00:17:54.120
Doesn't look in divars and
globals of other types.

00:17:54.120 --> 00:17:57.840
Doesn't look inside malloc
memory or whatever other memory

00:17:57.840 --> 00:18:00.240
you've allocated in your process.

00:18:01.730 --> 00:18:05.140
So what does that mean for your
C data structures if you want them

00:18:05.140 --> 00:18:06.790
to work in garbage collection?

00:18:06.900 --> 00:18:10.450
Here's a GC incompatible data structure.

00:18:10.650 --> 00:18:11.970
It's not really incompatible.

00:18:11.980 --> 00:18:19.220
It's just a -- it's partly incompatible
in that it has an ID pointer,

00:18:19.220 --> 00:18:21.270
that value pointer.

00:18:21.420 --> 00:18:24.340
The garbage collector is not going
to look inside that because it's

00:18:24.340 --> 00:18:26.940
allocated with a malloc block.

00:18:27.910 --> 00:18:31.970
So here are the changes you would need to
make it work with the garbage collector.

00:18:32.100 --> 00:18:35.880
The first change is to use
NSAllocateCollectible to

00:18:35.880 --> 00:18:37.830
allocate our structures.

00:18:37.930 --> 00:18:41.920
That way the garbage collector will throw
away these structures when they're done.

00:18:42.040 --> 00:18:46.580
We're also using the NSScanned option
because the structure has a pointer

00:18:46.580 --> 00:18:48.920
to an Objective-C object inside it.

00:18:49.100 --> 00:18:51.740
We need the garbage collector to
know about that pointer and to see

00:18:51.740 --> 00:18:53.970
that pointer when it's scanning.

00:18:54.900 --> 00:18:59.700
The other change we've made is
to mark the C pointers as strong.

00:18:59.780 --> 00:19:04.270
So the garbage collector will look
inside those pointers and also use the

00:19:04.270 --> 00:19:07.720
correct write barrier for those pointers.

00:19:07.850 --> 00:19:10.150
So what is the write barrier?

00:19:10.780 --> 00:19:15.140
The write barrier tells the garbage
collector that you modified a pointer.

00:19:15.200 --> 00:19:19.530
In particular, you modified a pointer
it wants to know about.

00:19:21.500 --> 00:19:25.090
This allows us to implement several
garbage collection algorithms.

00:19:25.370 --> 00:19:28.160
One of them is the
generational algorithm.

00:19:28.290 --> 00:19:31.490
When the write barrier sees
that you assigned an old object

00:19:31.490 --> 00:19:35.560
to point to a young object,
the write barrier tells the

00:19:35.560 --> 00:19:38.900
garbage collection that the old
object now needs to be scanned.

00:19:38.990 --> 00:19:43.080
Otherwise,
the generational algorithm assumes that

00:19:43.670 --> 00:19:47.090
only the young objects are interesting,
and it's going to work harder

00:19:47.090 --> 00:19:47.090
to delete the young objects.

00:19:47.710 --> 00:19:53.550
There's also the ThreadLocal algorithm,
which is a new performance

00:19:53.550 --> 00:19:53.550
optimization in Snow Leopard.

00:19:53.690 --> 00:19:57.350
We keep track of which objects
have only been seen by the

00:19:57.460 --> 00:19:59.180
thread that allocated them.

00:19:59.290 --> 00:20:02.230
But for example,
if a global variable is modified

00:20:02.310 --> 00:20:06.750
to point to a thread local object,
the write barrier sees that and

00:20:07.040 --> 00:20:11.330
tells the garbage collector that
that object is now globally visible.

00:20:11.480 --> 00:20:13.750
It escaped the thread.

00:20:14.650 --> 00:20:18.910
Finally, the garbage collector works
mostly non-stopping in that it

00:20:18.910 --> 00:20:23.010
lets the other threads run while
the garbage collector does work.

00:20:23.270 --> 00:20:28.480
What this means is if the garbage
collector has already scanned an object,

00:20:28.770 --> 00:20:31.830
And then the pointer is changed
while the garbage collector runs.

00:20:32.000 --> 00:20:35.400
The write barrier tells the garbage
collector that it may need to re-scan

00:20:35.400 --> 00:20:39.990
that pointer because it changed
behind the garbage collector's back.

00:20:41.970 --> 00:20:45.290
Ordinarily, the write barrier is
generated by the compiler.

00:20:45.450 --> 00:20:48.660
You don't need to do
any extra work for it.

00:20:48.720 --> 00:20:52.270
This only works for
Objective-C compiled code.

00:20:52.410 --> 00:20:56.300
So if you want to write C code
that uses the garbage collector,

00:20:56.440 --> 00:21:00.770
make sure you compile your C code
with the Objective-C compiler.

00:21:01.710 --> 00:21:05.190
Usually it's automatically inserted
into your assignment statements.

00:21:05.320 --> 00:21:08.920
Here's an example of an instance
variable being assigned a value.

00:21:09.190 --> 00:21:12.730
The compiler inserts this
instead of the assignment.

00:21:12.810 --> 00:21:15.610
It actually calls it runtime function.

00:21:16.210 --> 00:21:20.180
Similarly, if we have a structure,
we're assigning a structure value,

00:21:20.180 --> 00:21:24.090
and the structure contains
an Objective-C variable.

00:21:24.330 --> 00:21:28.580
The compiler will insert a
different structure copy.

00:21:28.780 --> 00:21:32.490
It'll use a memmove
collectible instead of memmove.

00:21:33.490 --> 00:21:37.470
If you want to have ordinary C pointers
that the garbage collection knows about,

00:21:37.610 --> 00:21:39.210
mark them strong.

00:21:39.380 --> 00:21:43.080
Then when you assign them,
the compiler will use another

00:21:43.080 --> 00:21:47.420
write barrier that tells the
runtime and the garbage collector

00:21:47.420 --> 00:21:49.780
that a C pointer has changed.

00:21:50.550 --> 00:21:53.950
Like I said, usually the compiler
does this all for you.

00:21:54.050 --> 00:21:56.740
Sometimes you need to do it yourself.

00:21:56.860 --> 00:21:59.320
The two common examples
for doing it yourself,

00:21:59.480 --> 00:22:00.770
the first one is memmove.

00:22:00.770 --> 00:22:04.700
If you have a memcopy or a memmove
and the memory that you are

00:22:04.700 --> 00:22:07.960
copying might contain pointers,
you need to use this

00:22:07.970 --> 00:22:12.160
memmove function instead,
the memmove collectible function.

00:22:12.160 --> 00:22:15.370
It works just like memmove,
but it also tells the runtime and

00:22:15.370 --> 00:22:19.280
the garbage collector that some
pointer values might have changed.

00:22:19.780 --> 00:22:24.410
So this is what the compiler
uses for structure assignments.

00:22:25.000 --> 00:22:27.960
The other write barrier that
you might need to use by hand

00:22:28.300 --> 00:22:31.040
is atomic compare and swap.

00:22:31.390 --> 00:22:36.360
We have an OBJC compare and swap
that's a replacement for the

00:22:36.360 --> 00:22:40.100
OS Atomic compare and swap pointer.

00:22:40.150 --> 00:22:43.340
It just does an atomic compare and
swap and then tells the garbage

00:22:43.340 --> 00:22:45.760
collector what it just did.

00:22:45.910 --> 00:22:48.040
Point of terminology confusion.

00:22:48.040 --> 00:22:51.640
There's a NOAS atomic compare
and swap pointer barrier.

00:22:51.640 --> 00:22:56.540
This is a memory barrier and a
garbage collection rights barrier.

00:22:56.540 --> 00:22:58.190
Don't get confused.

00:22:59.810 --> 00:23:03.500
There are several other write
barriers in the garbage collector.

00:23:03.750 --> 00:23:06.180
Most of the time you
don't need to call them.

00:23:06.180 --> 00:23:08.450
They are just the
implementation of strong.

00:23:08.480 --> 00:23:13.580
So use the strong keyword instead and
let the compiler do the rest for you.

00:23:14.050 --> 00:23:15.200
When do you need strong?

00:23:15.360 --> 00:23:18.210
When do you need the write barrier?

00:23:18.400 --> 00:23:22.840
This is the magic incantation that
describes what the write barrier is for.

00:23:22.920 --> 00:23:27.540
Use an appropriate write barrier whenever
you write a pointer to the start of a

00:23:27.540 --> 00:23:34.860
GC-managed block into GC-scanned storage
other than the current thread's stack.

00:23:35.530 --> 00:23:37.650
Let's see that again.

00:23:37.930 --> 00:23:40.200
Use an appropriate write barrier.

00:23:40.400 --> 00:23:43.210
There are several
flavors of write barrier.

00:23:43.470 --> 00:23:45.900
If you're writing them by hand,
you need to make sure

00:23:45.900 --> 00:23:47.360
you use the right one.

00:23:47.400 --> 00:23:50.980
Or just use strong,
and it will choose the right one for you.

00:23:51.260 --> 00:23:55.030
Whenever you write,
this means whenever you write.

00:23:55.130 --> 00:23:57.890
If you're writing into any of these
storage classes that the garbage

00:23:57.890 --> 00:24:01.200
collector wants to know about,
you must use a write barrier.

00:24:01.200 --> 00:24:04.540
If the write barrier is absent,
the garbage collector won't

00:24:04.640 --> 00:24:07.760
see your pointer change,
and it might destroy objects

00:24:07.760 --> 00:24:09.400
that you wanted to keep.

00:24:10.390 --> 00:24:13.750
A pointer to the start
of a GC-managed block.

00:24:14.000 --> 00:24:16.100
This is the value being written.

00:24:16.260 --> 00:24:19.500
The garbage collector only
cares about pointers to blocks.

00:24:19.620 --> 00:24:22.950
If you're writing ints, if you're writing
pointers to other blocks,

00:24:22.950 --> 00:24:24.700
you don't need to use the right barrier.

00:24:24.760 --> 00:24:27.410
It's only if the value is a
garbage-collected block and the

00:24:27.410 --> 00:24:30.620
start of a garbage-collected block,
because the garbage collector

00:24:30.620 --> 00:24:32.480
doesn't know about anything else.

00:24:32.480 --> 00:24:33.720
Greg Parker

00:24:34.000 --> 00:24:54.900
[Transcript missing]

00:24:55.080 --> 00:24:59.420
Accept the exception,
which is the current thread's stack.

00:24:59.810 --> 00:25:03.840
You do not need to use a write
barrier for your local variables.

00:25:03.960 --> 00:25:06.040
This is a performance optimization.

00:25:06.110 --> 00:25:08.460
We don't want to slow down
your local variable access.

00:25:08.460 --> 00:25:11.470
So the garbage collector
manages threads specially,

00:25:11.470 --> 00:25:14.230
such that it does not need a
write barrier for the thread

00:25:14.580 --> 00:25:16.280
stack of the current thread.

00:25:19.850 --> 00:25:25.180
So, basic cheat sheet for memory
management of C data structures

00:25:25.250 --> 00:25:28.080
and C data structures
containing Objective-C pointers.

00:25:28.080 --> 00:25:32.120
If you want a garbage
collected CarStar block or

00:25:32.150 --> 00:25:36.540
other ordinary memory block,
use NSAllocateCollectible

00:25:36.540 --> 00:25:37.790
instead of malloc.

00:25:37.880 --> 00:25:40.710
If that block might
contain pointer values,

00:25:40.710 --> 00:25:42.530
use the NSScanned option.

00:25:42.540 --> 00:25:45.230
For the write barriers,
most of the time you can

00:25:45.280 --> 00:25:47.180
mark your pointers as strong.

00:25:47.180 --> 00:25:50.410
There are a few other cases
like memcpy where you might

00:25:50.740 --> 00:25:52.780
need to change the function.

00:25:53.060 --> 00:25:56.030
And finally,
don't store garbage collected pointers

00:25:56.340 --> 00:26:00.610
into unscanned memory or variables
that aren't marked strong because

00:26:00.610 --> 00:26:02.870
the garbage collector won't see them.

00:26:02.990 --> 00:26:06.920
A typical option instead
is to use a weak variable,

00:26:06.980 --> 00:26:11.170
which will create a proper
weak reference instead of just

00:26:11.170 --> 00:26:13.600
an ordinary dangling pointer.

00:26:13.800 --> 00:26:19.450
Another option for unscanned memory
is external reference counts.

00:26:19.450 --> 00:26:19.450
Greg Parker

00:26:20.320 --> 00:26:23.810
External reference count is a
way to keep an object alive,

00:26:23.840 --> 00:26:26.610
even if the garbage collector
would otherwise throw it away.

00:26:26.610 --> 00:26:31.520
You can think of it something like
a classic Objective-C retain count,

00:26:31.520 --> 00:26:34.990
where if the retain count is above zero,
the object lives.

00:26:35.740 --> 00:26:40.230
In the garbage collected case,
if an external reference count is

00:26:40.230 --> 00:26:44.730
not zero and is decremented to zero,
the object might not go away.

00:26:44.730 --> 00:26:48.440
That just means the garbage
collector is now free to delete it,

00:26:48.440 --> 00:26:51.270
but if there are any ordinary
pointers to the value,

00:26:51.270 --> 00:26:54.110
the garbage collector
will still keep it alive.

00:26:54.180 --> 00:26:58.650
Most garbage collected objects still
have an external reference count of zero,

00:26:58.940 --> 00:27:02.610
which means the garbage collector
is fully responsible for it.

00:27:04.770 --> 00:27:09.940
There are several different ways to
modify the external reference count.

00:27:10.170 --> 00:27:14.340
First option is to use the
foundation NSGarbageCollector object.

00:27:14.370 --> 00:27:18.500
Disable collector for pointer,
enable collector for pointer.

00:27:18.530 --> 00:27:21.360
These functions nest,
they just increment and decrement

00:27:21.510 --> 00:27:25.340
the external reference count,
and while the collector is disabled,

00:27:25.490 --> 00:27:27.760
the collector will not
destroy that object.

00:27:27.820 --> 00:27:30.150
Although it will destroy
any other objects,

00:27:30.150 --> 00:27:31.090
it feels like.

00:27:31.860 --> 00:27:42.700
You can also change the reference
count with CFRetain and CFRelease.

00:27:42.700 --> 00:27:42.700
So just like the ordinary
Objective-C non-garbage

00:27:42.700 --> 00:27:42.700
collector retain count.

00:27:42.980 --> 00:27:49.260
But you have to be careful with these two
because the ordinary Objective-C methods,

00:27:49.260 --> 00:27:52.640
retain, release, auto-release,
are ignored when garbage

00:27:52.640 --> 00:27:53.900
collection is on.

00:27:53.900 --> 00:27:58.660
In fact, the Objective-C runtime doesn't
even send those messages.

00:27:58.660 --> 00:27:59.880
It just returns immediately.

00:27:59.970 --> 00:28:03.090
What this means is they don't balance.

00:28:03.200 --> 00:28:08.300
You cannot call cf.retain and
then later the release method.

00:28:09.140 --> 00:28:11.540
In garbage collection,
you'll end up with a

00:28:11.540 --> 00:28:14.350
dangling reference count,
which will just look like a leak.

00:28:14.480 --> 00:28:17.000
You can still have leaks in
garbage collection this way.

00:28:21.030 --> 00:28:24.370
One use for the external reference
counts is interoperating with

00:28:24.380 --> 00:28:26.730
your C code or your C++ code.

00:28:26.730 --> 00:28:30.650
You can use it to keep the object alive
if you're storing it somewhere where

00:28:30.650 --> 00:28:32.560
the garbage collector wouldn't look.

00:28:33.530 --> 00:28:36.940
For example,
if you have some C API that has a void

00:28:36.940 --> 00:28:41.540
star context parameter in its callbacks,
and you want to pass an

00:28:41.540 --> 00:28:45.200
Objective-C object through
that context parameter,

00:28:45.200 --> 00:28:50.180
you can increment the reference
count of the object before

00:28:50.290 --> 00:28:52.290
passing it into the context.

00:28:53.000 --> 00:28:57.430
So the garbage collector will keep it
alive even though it doesn't know what

00:28:57.430 --> 00:28:59.870
that C code is doing with the pointer.

00:29:00.580 --> 00:29:04.220
Other examples of this are
global variables that aren't of

00:29:04.220 --> 00:29:09.500
Objective-C types or malloc blocks
that are not using the new APIs.

00:29:09.560 --> 00:29:12.870
Also,
if you have C++ member variables that

00:29:12.870 --> 00:29:14.860
are storing Objective-C object pointers.

00:29:14.950 --> 00:29:19.160
Unless you do extra work,
your C++ objects are allocated

00:29:19.160 --> 00:29:22.260
on the malloc heap where the
garbage collector isn't looking.

00:29:22.260 --> 00:29:25.830
So you can use the external reference
count to keep the objects alive,

00:29:25.830 --> 00:29:29.180
just like you would in a
non-garbage collected environment.

00:29:31.200 --> 00:29:34.140
One danger of the external
references is you can still

00:29:34.140 --> 00:29:38.700
have reference count cycles,
just like a non-GC application

00:29:38.700 --> 00:29:41.140
would have reference count cycles.

00:29:41.230 --> 00:29:43.880
So you have to be careful that you
don't have an externally retained

00:29:43.880 --> 00:29:47.620
object that then points to some
object that points to something else

00:29:47.740 --> 00:29:52.100
that points back to the original
object and would have decremented

00:29:52.100 --> 00:29:56.210
reference count but can't because
none of them objects will go away.

00:29:56.300 --> 00:29:57.210
So be warned of that.

00:29:57.520 --> 00:30:00.600
It's just like the non-GC case.

00:30:02.720 --> 00:30:06.230
Finally, the reference count is important
if you are interoperating

00:30:06.230 --> 00:30:08.140
with core foundation code.

00:30:08.140 --> 00:30:12.620
For example, if you're calling the
ordinary CF create array,

00:30:12.620 --> 00:30:19.310
CF create string, CFString create, sorry,
create or copy functions.

00:30:19.360 --> 00:30:23.490
In non-GC, they return an object with
a retain count of one.

00:30:23.490 --> 00:30:26.480
In garbage collection,
they return an object with an

00:30:26.560 --> 00:30:29.780
external reference count of one,
and you are responsible

00:30:29.780 --> 00:30:31.620
for releasing them somehow.

00:30:33.520 --> 00:30:37.660
There are three common patterns for
managing that external reference count

00:30:37.800 --> 00:30:40.200
in the garbage collected environment.

00:30:40.370 --> 00:30:44.400
The first one,
if you're creating a temporary CF object,

00:30:44.540 --> 00:30:47.610
is just simply CF release
the object when you're done,

00:30:47.750 --> 00:30:50.840
just like you would if
garbage collection were off.

00:30:51.130 --> 00:30:54.830
The object will not be
destroyed at that point.

00:30:55.040 --> 00:30:58.220
But it will tell the garbage collector
that the garbage collector is free

00:30:58.220 --> 00:31:01.290
to destroy it when it is ready.

00:31:01.730 --> 00:31:05.340
Another alternative,
if you're storing your CF object

00:31:05.450 --> 00:31:09.310
in an instance variable,
for example, is to call CFRelease

00:31:09.310 --> 00:31:11.680
inside the finalize method.

00:31:11.840 --> 00:31:16.280
This works, but you need a finalizer,
which you might not otherwise need.

00:31:16.440 --> 00:31:19.180
And also,
you might create a cycle if your

00:31:19.360 --> 00:31:24.100
CFArray with a retain count points
to an object that points back

00:31:24.100 --> 00:31:28.920
to the object whose finalizer
would have called release.

00:31:29.330 --> 00:31:34.950
The alternative in that case is
to use a new function added in

00:31:34.950 --> 00:31:37.320
Leopard called CFMakeCollectible.

00:31:37.530 --> 00:31:40.550
CF Make Collectible,
when garbage collection is on,

00:31:40.710 --> 00:31:43.240
simply decrements the reference count.

00:31:43.400 --> 00:31:50.390
So the typical use for this is to use
it immediately after calling CF Create.

00:31:50.470 --> 00:31:53.980
So you call CF Create to create your
object with a reference count of one,

00:31:53.980 --> 00:32:00.220
and then call CF Make Collectible to
decrement the reference count back to

00:32:00.300 --> 00:32:02.610
zero and tell the garbage collector
it's free to destroy the object.

00:32:02.610 --> 00:32:02.610
Greg Parker

00:32:03.010 --> 00:32:06.430
There's one caveat to this,
which is there are some CF types

00:32:06.530 --> 00:32:08.520
that don't work in this case.

00:32:08.520 --> 00:32:13.080
CF clay collectible actually
causes the object to self-destruct.

00:32:13.080 --> 00:32:17.170
As far as I know,
there aren't any publicly available

00:32:17.170 --> 00:32:20.960
core foundation types that
you would actually manipulate.

00:32:21.720 --> 00:32:26.110
If you do happen upon one of these,
CF make collectible will call

00:32:26.110 --> 00:32:29.780
to your program at runtime,
so you'll actually know that

00:32:29.780 --> 00:32:33.750
you've called CF make collectible
on a self-destructing CF type.

00:32:35.570 --> 00:32:37.330
Two final CF notes.

00:32:37.490 --> 00:32:40.580
First of all,
don't use any CFAllocators other

00:32:40.580 --> 00:32:42.980
than the default allocator.

00:32:43.030 --> 00:32:45.990
In general,
it makes the garbage collector unhappy.

00:32:46.970 --> 00:32:50.750
Second note, which actually I don't
have a bullet point here,

00:32:50.750 --> 00:32:54.490
your CF types are not considered
garbage collected types.

00:32:54.610 --> 00:32:58.520
So if you have a CFStringRef,
the garbage collector will not

00:32:58.520 --> 00:33:00.550
scan it unless you mark it strong.

00:33:00.550 --> 00:33:04.990
So be aware of that if you have
core foundation variables in

00:33:04.990 --> 00:33:07.790
your garbage collected program.

00:33:09.660 --> 00:33:13.660
Next garbage collected GC topic
related to core foundation

00:33:13.990 --> 00:33:16.890
is weak pointer containers.

00:33:18.280 --> 00:33:22.080
Traditional non-GC programs
use core foundation containers

00:33:22.080 --> 00:33:24.080
for non-retaining references.

00:33:24.330 --> 00:33:27.690
A CFArray with null callbacks,
for example,

00:33:27.690 --> 00:33:30.490
will not retain or release its values.

00:33:30.890 --> 00:33:33.750
It'll just store them as raw pointers.

00:33:34.880 --> 00:33:37.880
In garbage collecting, this doesn't work.

00:33:38.220 --> 00:33:41.600
You must not use a core
foundation container with null

00:33:41.600 --> 00:33:44.510
callbacks to store GC pointers.

00:33:44.640 --> 00:33:47.590
The problem is it's not thread safe.

00:33:47.750 --> 00:33:49.940
And in fact,
it cannot be made thread safe.

00:33:49.940 --> 00:33:54.540
You cannot add any amount of locking
to your program to make it work.

00:33:54.660 --> 00:33:59.580
The problem is the garbage collector
will be modifying these pointers

00:33:59.580 --> 00:34:01.800
and throwing your objects away.

00:34:02.650 --> 00:34:07.490
And you cannot create a lock that
the garbage collector will use.

00:34:07.590 --> 00:34:11.620
So the problem with these containers,
the classic core foundation containers,

00:34:11.680 --> 00:34:13.980
is that they just store
dangling pointers.

00:34:14.130 --> 00:34:17.600
See if the garbage collector
does not scan them.

00:34:17.660 --> 00:34:20.060
They're not weak pointers,
so the garbage collector

00:34:20.060 --> 00:34:21.720
does not erase them.

00:34:21.780 --> 00:34:24.720
And so you end up with a race,
where one thread tries

00:34:24.720 --> 00:34:27.410
to destroy the object,
the other thread tries to

00:34:27.540 --> 00:34:29.410
read it from the container.

00:34:30.770 --> 00:34:35.390
The solution is to use the new
container classes added in Leopard.

00:34:35.500 --> 00:34:40.720
These are the NSMapTable, NSHashTable,
and NSPointerArray.

00:34:40.850 --> 00:34:46.180
These are pretty much direct analogs
for the core foundation container types.

00:34:46.660 --> 00:34:51.860
These container types are customizable
via a type called NSPointer functions,

00:34:52.010 --> 00:34:55.870
which works a lot like the core
foundation callbacks would.

00:34:56.430 --> 00:35:00.190
You can use pointer comparison
to store your values,

00:35:00.190 --> 00:35:04.420
or you can use the object
comparison is equal and hash

00:35:04.420 --> 00:35:07.080
methods to store your values.

00:35:07.120 --> 00:35:10.900
And the containers can
contain any type of reference.

00:35:11.180 --> 00:35:13.320
It can be a strong
reference to the types,

00:35:13.480 --> 00:35:15.720
it can be a weak reference
to the variables,

00:35:15.760 --> 00:35:19.500
or it can be a copied reference.

00:35:20.160 --> 00:35:22.450
So these types work with
garbage collected code.

00:35:22.610 --> 00:35:25.500
They also work with
non-garbage collected code,

00:35:25.500 --> 00:35:26.980
for the most part.

00:35:27.060 --> 00:35:30.540
So you can use them to replace
the core foundation types you

00:35:30.540 --> 00:35:32.890
might be using for the containers.

00:35:34.860 --> 00:35:38.810
So the basic configurations
for the container types using

00:35:38.810 --> 00:35:41.630
NSPointer functions look like this.

00:35:41.740 --> 00:35:45.330
You can store an object value to
use is equal or hash to decide

00:35:45.770 --> 00:35:47.880
whether they're equal or not.

00:35:48.000 --> 00:35:51.700
You can store an object
pointer and just use a pointer

00:35:51.700 --> 00:35:54.090
comparison as the hash value.

00:35:54.470 --> 00:35:58.740
And you can use a strong reference or
a weak reference or a copied reference.

00:35:58.740 --> 00:36:01.110
For example,
if you're storing strings in a

00:36:01.110 --> 00:36:05.200
table and you want to protect
yourself against immutable strings.

00:36:05.280 --> 00:36:06.240
But that's not all.

00:36:06.370 --> 00:36:08.640
They work for more than just objects.

00:36:08.660 --> 00:36:11.980
In fact, they work for just about
anything you can think of.

00:36:11.980 --> 00:36:17.830
NSPointer function-based containers can
source C strings or integers or structs.

00:36:17.870 --> 00:36:19.620
They can use malloc memory.

00:36:19.620 --> 00:36:24.120
They can use custom memory allocator
functions you provide yourself.

00:36:24.120 --> 00:36:26.990
So it's a full suite of
options to replace the core

00:36:26.990 --> 00:36:28.940
foundation container types.

00:36:28.940 --> 00:36:31.130
And they work in garbage collection.

00:36:31.470 --> 00:36:34.030
They work in non-GC in
most configurations.

00:36:35.820 --> 00:36:39.460
So the checkmarked options here are
the configurations that are supported,

00:36:39.460 --> 00:36:41.040
known to work in Leopard.

00:36:41.040 --> 00:36:43.670
It's possible that some
of the others work,

00:36:43.780 --> 00:36:44.910
but we recommend you don't try them.

00:36:49.220 --> 00:36:51.820
Last garbage collection topic
I want to mention is threads.

00:36:51.820 --> 00:36:57.130
The garbage collector handles
threads specially in order to make

00:36:57.130 --> 00:37:00.910
your local variables run fast and
in order for the garbage collector

00:37:01.200 --> 00:37:03.320
not to have to stop your threads.

00:37:03.380 --> 00:37:07.900
The Objective-C garbage collector
is not a world-stopping collector.

00:37:07.900 --> 00:37:11.020
It never needs to stop all
your threads simultaneously.

00:37:12.370 --> 00:37:17.590
Also, it doesn't stop any thread that is
not participating in Objective-C.

00:37:17.840 --> 00:37:20.730
For example,
you might have an audio playback thread

00:37:20.730 --> 00:37:22.980
that wants some real-time guarantees.

00:37:22.980 --> 00:37:27.980
That thread, as long as it does not
use any Objective-C code,

00:37:28.230 --> 00:37:32.160
will not be stopped by the garbage
collector and it will be able to

00:37:32.200 --> 00:37:34.980
run freely without any interruption.

00:37:36.180 --> 00:37:38.720
On the other hand,
that means you need to do some special

00:37:38.720 --> 00:37:42.920
work if you're writing thread code,
particularly if you're

00:37:42.920 --> 00:37:44.800
writing pthread code.

00:37:45.120 --> 00:37:47.140
One example is thread stack scanning.

00:37:47.360 --> 00:37:50.540
The garbage collector does
not look at all threads.

00:37:50.660 --> 00:37:53.650
In particular,
it does not look at P threads if

00:37:53.650 --> 00:37:58.370
they are just raw P threads that
you created with PthreadCreate.

00:37:58.570 --> 00:38:01.160
If you want the garbage collector
to see your local variables,

00:38:01.230 --> 00:38:04.420
you should use an NSThread
to create the thread.

00:38:04.660 --> 00:38:08.840
Or at the start of your thread,
you can call an NSThread method,

00:38:08.900 --> 00:38:13.140
like NSThread current thread,
which will create the NSThread object

00:38:13.140 --> 00:38:17.680
and tell the garbage collector that
your thread is an interesting thread the

00:38:17.680 --> 00:38:20.380
garbage collector might need to look at.

00:38:22.780 --> 00:38:26.660
Another problem with threads
is passing pointers to them.

00:38:26.750 --> 00:38:32.950
You must not write directly to a thread
stack that is not your thread's stack.

00:38:33.060 --> 00:38:35.950
So don't take the address of
a local variable and give that

00:38:35.950 --> 00:38:37.580
to another thread to modify.

00:38:37.850 --> 00:38:42.790
The garbage collector will not see that
change and might destroy the pointer.

00:38:43.330 --> 00:38:46.820
Also, you should not use the
PthreadCreate argument that is

00:38:47.200 --> 00:38:49.020
passed when creating a thread.

00:38:49.020 --> 00:38:53.380
The garbage collector does not see
that value and might destroy the object

00:38:53.450 --> 00:38:57.700
between thread creation and the time
the thread actually starts running.

00:38:59.590 --> 00:39:03.080
The solution, again, use NSThread.

00:39:03.290 --> 00:39:06.330
Several NSThread methods
provide an object parameter.

00:39:06.640 --> 00:39:10.560
You can use that to pass a garbage
collected pointer to a thread.

00:39:10.730 --> 00:39:14.090
If you're using a subclass of NSThread,
or if you're using a

00:39:14.090 --> 00:39:17.810
subclass of NSOperation,
you can use IVARs from those classes.

00:39:18.000 --> 00:39:23.590
Finally, you can use the external
reference count on a thread.

00:39:23.790 --> 00:39:27.500
You can increment the garbage
collected pointer in the parent thread,

00:39:27.550 --> 00:39:30.400
pass it to the child thread,
and have the child thread

00:39:30.400 --> 00:39:32.770
decremented when it's done.

00:39:35.110 --> 00:39:38.540
There are a couple things you might
need to do when running a thread,

00:39:38.540 --> 00:39:43.400
particularly if you are writing a
thread with an event loop or run

00:39:43.400 --> 00:39:48.370
loop or some other top level code
that you are writing yourself.

00:39:49.030 --> 00:39:54.010
First thing you want to do is call
the Objective-C clear stack function.

00:39:54.300 --> 00:39:57.550
Ordinarily, the garbage collector scans
stacks conservatively,

00:39:57.890 --> 00:40:01.200
which means it doesn't look at what
the variable types are on the stacks.

00:40:01.200 --> 00:40:05.200
What that means is that sometimes
the garbage collector will see

00:40:05.330 --> 00:40:09.160
a value that used to be a local
variable but is not anymore.

00:40:09.160 --> 00:40:12.610
The garbage collector will keep
that value alive even though your

00:40:12.610 --> 00:40:14.550
program is actually done with it.

00:40:15.900 --> 00:40:19.340
If you call the clear stack function
at the top of your event loop or

00:40:19.650 --> 00:40:22.680
before blocking in the run loop,
that will erase all those

00:40:23.060 --> 00:40:25.040
stale references on the stack.

00:40:26.710 --> 00:40:30.370
This is particularly important for
compiler optimized code because

00:40:30.370 --> 00:40:34.620
setting local equals nil might be
optimized away by the compiler,

00:40:34.620 --> 00:40:39.070
so the local variable is
still left stale in the stack.

00:40:39.960 --> 00:40:42.390
The other case where you
might need to explicitly help

00:40:42.390 --> 00:40:47.800
the compiler is explicitly
requesting a garbage collection.

00:40:47.900 --> 00:40:51.540
The garbage collector works
fine if you don't ask it to run,

00:40:51.540 --> 00:40:55.030
but it works better sometimes
if you do ask it to run.

00:40:55.380 --> 00:40:58.520
Usually this is the case if
your program has created a large

00:40:58.520 --> 00:41:02.140
number of temporary objects,
or it has some large graph of

00:41:02.140 --> 00:41:04.960
objects that you've just thrown away.

00:41:05.100 --> 00:41:09.220
It may be useful to tell the garbage
collector that you've just thrown

00:41:09.220 --> 00:41:12.860
away a large number of objects,
and it might be profitable to run

00:41:12.860 --> 00:41:15.070
the garbage collector right now.

00:41:15.580 --> 00:41:19.130
The usual way to do this is
use the NSGarbageCollector

00:41:19.130 --> 00:41:21.320
collectifneeded method.

00:41:21.740 --> 00:41:27.220
And typical places you'd want to use
this are at the top of your event loop,

00:41:27.220 --> 00:41:35.100
just before you block,
or in places where your

00:41:35.100 --> 00:41:35.100
non-GC code used to call

00:41:35.270 --> 00:41:37.060
The Auto-Release Pool.

00:41:37.130 --> 00:41:40.610
If your non-garbage collected code
is destroying an auto-release pool,

00:41:40.610 --> 00:41:44.110
there's a good chance that our
auto-release pool used to contain objects

00:41:44.110 --> 00:41:46.300
in your non-garbage collected code.

00:41:46.300 --> 00:41:48.800
And so it would be useful
for the garbage collector to

00:41:48.800 --> 00:41:50.440
run to destroy those objects.

00:41:52.110 --> 00:41:54.870
One caveat here,
you don't want to use this

00:41:54.870 --> 00:41:59.150
if you're holding a lock,
usually, because finalizers might run

00:41:59.150 --> 00:42:01.040
in response to this call.

00:42:01.040 --> 00:42:03.150
And if the finalizers
try and use that lock,

00:42:03.150 --> 00:42:06.500
and you're already holding the lock,
you end up with a deadlock.

00:42:06.500 --> 00:42:07.530
Deadlocks are bad.

00:42:07.530 --> 00:42:08.310
Don't do that.

00:42:11.160 --> 00:42:14.000
Finally, the main thread when
launching your program.

00:42:14.280 --> 00:42:16.400
You want to start the garbage collector.

00:42:16.400 --> 00:42:20.760
In an AppKit program,
this is handled by NS Application Main.

00:42:20.760 --> 00:42:21.930
You don't need to worry about it.

00:42:21.930 --> 00:42:25.820
In a Foundation program,
the garbage collector, by default,

00:42:25.820 --> 00:42:28.040
never runs unless you ask it to run.

00:42:28.040 --> 00:42:30.600
And usually,
this is not the most performant way

00:42:30.600 --> 00:42:32.470
for the garbage collector to run.

00:42:32.470 --> 00:42:34.370
It runs faster on its own thread.

00:42:34.370 --> 00:42:37.410
So if you want the garbage
collector to run faster,

00:42:37.500 --> 00:42:40.980
call the startCollectorThread function
to start the garbage collector.

00:42:41.000 --> 00:42:43.140
If you want to spawn the
garbage collector thread,

00:42:43.140 --> 00:42:45.260
it will start running on
its own when it needs to.

00:42:48.540 --> 00:42:51.570
So that's the summary of
low-level GC programming.

00:42:51.690 --> 00:42:54.730
We've seen the memory layout
the garbage collector uses.

00:42:54.850 --> 00:42:58.290
We've seen the write barrier,
which a garbage collector must see for

00:42:58.530 --> 00:43:01.540
assignments of garbage collected values.

00:43:01.620 --> 00:43:06.120
And we've seen external reference
counts and weak pointer containers,

00:43:06.190 --> 00:43:08.800
if you're dealing with
core foundation objects,

00:43:08.890 --> 00:43:12.020
and a few topics on threads,
if you're writing thread code,

00:43:12.020 --> 00:43:15.470
particularly top-level thread code.

00:43:17.140 --> 00:43:18.770
Upgrading to GC.

00:43:18.960 --> 00:43:23.180
Let's say you have a non-garbage
collector program that you want to start

00:43:23.250 --> 00:43:25.600
using the garbage collector with it.

00:43:25.710 --> 00:43:27.090
It can be done.

00:43:27.300 --> 00:43:33.280
Xcode is an example of a large program
that used to be not garbage collected,

00:43:33.320 --> 00:43:34.630
and now it is.

00:43:34.920 --> 00:43:37.900
The Apple System Frameworks
are another example:

00:43:38.040 --> 00:43:40.450
Foundation, AppKit, WebKit.

00:43:40.610 --> 00:43:43.460
They all need to run in a
garbage-collected program,

00:43:43.650 --> 00:43:48.110
so they all need to be compatible
with garbage collection.

00:43:48.400 --> 00:43:51.360
A new example in
Snow Leopard is Automator.

00:43:51.360 --> 00:43:55.600
The new 64-bit Automator is
a garbage collected program,

00:43:55.600 --> 00:43:57.740
whereas the 32-bit version is not.

00:43:57.820 --> 00:44:00.550
Upgrading to GC can be done.

00:44:01.090 --> 00:44:03.060
However, it may be difficult.

00:44:04.680 --> 00:44:08.500
The difficulty usually depends
on the contents of your code.

00:44:08.500 --> 00:44:10.650
Some warning signs to be aware of.

00:44:10.650 --> 00:44:14.740
If your program uses DLK for things
that aren't memory management,

00:44:14.790 --> 00:44:19.040
you might have some problems
converting to garbage collection.

00:44:19.810 --> 00:44:23.640
If your program uses malloc a lot,
or particularly uses C++

00:44:23.640 --> 00:44:26.840
or Crown Foundation a lot,
you might have trouble

00:44:26.990 --> 00:44:29.360
upgrading to garbage collection.

00:44:29.890 --> 00:44:32.270
Because there will be more work,
more code you need to examine to make

00:44:32.270 --> 00:44:33.940
sure that you're doing the right thing.

00:44:33.960 --> 00:44:38.190
it is compatible with
the garbage collector.

00:44:38.930 --> 00:44:42.960
On the other hand,
the upgrading can be done incrementally.

00:44:43.100 --> 00:44:46.610
What this means is you can gradually
adopt garbage collector patterns

00:44:46.610 --> 00:44:50.890
that are more friendly to the garbage
collector and use mechanisms that work

00:44:50.890 --> 00:44:53.480
whether or not your program is running.

00:44:53.480 --> 00:44:56.730
In particular,
you can leave your source codes,

00:44:56.780 --> 00:45:00.470
retain and release calls alone
so that they'll still work

00:45:00.470 --> 00:45:02.790
with the garbage collector off.

00:45:02.790 --> 00:45:05.680
For example,
if you have a program that you

00:45:05.890 --> 00:45:09.540
want to ship the non-GC version,
but you want to experiment

00:45:09.540 --> 00:45:13.590
with garbage collection,
you can do this in a single source base

00:45:13.590 --> 00:45:17.050
and leave the non-GC version intact,
but experiment with garbage

00:45:17.050 --> 00:45:18.280
collection on the side.

00:45:20.850 --> 00:45:25.330
Here are some GC upgrade tasks,
some types of code you need to look at,

00:45:25.480 --> 00:45:28.570
some changes you might need
to make to your program.

00:45:28.740 --> 00:45:33.260
Most of these have to do with core
foundation or with C objects or with

00:45:33.390 --> 00:45:38.420
things that were non-retained dangling
pointers with the garbage collector off.

00:45:39.120 --> 00:45:42.090
Two particularly important items.

00:45:42.480 --> 00:45:45.240
The first one is finalized methods.

00:45:45.420 --> 00:45:47.700
Your dAlloc methods are not
called with Garbage Collection,

00:45:47.700 --> 00:45:50.510
so you need to write finalizers.

00:45:50.740 --> 00:45:52.100
You can do this incrementally.

00:45:52.220 --> 00:45:55.830
You can take a first pass,
which creates finalizers that

00:45:55.860 --> 00:45:58.860
are just based on dAlloc,
perhaps even copied

00:45:58.860 --> 00:46:01.360
and pasted from dAlloc.

00:46:01.460 --> 00:46:03.800
This is not the best way
to go in the long run,

00:46:03.910 --> 00:46:07.270
but it is a way to get your program
up and running at least a little

00:46:07.600 --> 00:46:09.550
bit under Garbage Collection.

00:46:09.690 --> 00:46:11.970
In the long run, though,
you really want to modify

00:46:11.970 --> 00:46:15.560
your design patterns,
reduce the number of finalizers you need,

00:46:15.560 --> 00:46:18.230
or eliminate them entirely.

00:46:18.470 --> 00:46:22.490
The other primary task that you
need to be aware of for most

00:46:22.490 --> 00:46:27.870
Objective-C code is that retain and
release are not used interchangeably

00:46:27.870 --> 00:46:30.220
with CF retain and CF release.

00:46:30.220 --> 00:46:33.680
This is a case where core
foundation toll-bridged objects,

00:46:33.680 --> 00:46:37.230
the toll-free bridging is not
quite as toll-free as it is in the

00:46:37.230 --> 00:46:39.790
non-garbage collected environment.

00:46:39.790 --> 00:46:41.210
Greg Parker

00:46:43.080 --> 00:46:46.180
If you are writing a framework
or a plugin that needs to be

00:46:46.180 --> 00:46:50.100
loaded into multiple applications,
there are some extra work you

00:46:50.100 --> 00:46:52.060
need to do for garbage collection.

00:46:52.170 --> 00:46:56.310
The problem is you don't get to choose
whether garbage collection is running.

00:46:56.520 --> 00:46:59.440
The application chooses that.

00:47:00.280 --> 00:47:04.160
So what that means is you have one
binary which needs to work whether

00:47:04.160 --> 00:47:07.780
or not garbage collection is on,
and which means you have the same

00:47:07.780 --> 00:47:09.520
source code that needs to support both.

00:47:09.600 --> 00:47:13.640
This is how all of Apple's
system frameworks work.

00:47:15.170 --> 00:47:18.730
Some things to be aware of
there are auto-release pools,

00:47:19.120 --> 00:47:22.460
called the drain method
instead of the release method.

00:47:22.580 --> 00:47:26.030
With garbage collection on,
drain is a hint that garbage collection

00:47:26.030 --> 00:47:28.890
might be useful to run right now,
but otherwise it does nothing.

00:47:28.900 --> 00:47:35.510
With garbage collection off,
drain destroys the

00:47:35.510 --> 00:47:35.510
auto-release pool as normal.

00:47:35.790 --> 00:47:40.510
Other things you need to worry
about are core foundation objects,

00:47:40.510 --> 00:47:44.560
using NSMAP table versus a
core foundation dictionary,

00:47:44.650 --> 00:47:49.190
using CF release in your D-alloc,
and choosing something else

00:47:49.250 --> 00:47:54.050
for the garbage collected case,
like CF make collectible at allocation

00:47:54.270 --> 00:47:57.250
or CF release in your finalized method.

00:47:57.270 --> 00:48:00.650
There are several different
options for doing that.

00:48:01.150 --> 00:48:05.180
Finally, in some cases,
you may need to check whether

00:48:05.200 --> 00:48:06.600
the garbage collector is running.

00:48:06.620 --> 00:48:08.780
We discourage this most of the time,
but it is possible.

00:48:08.780 --> 00:48:14.790
The check is whether the default
collector object is nil or not.

00:48:17.160 --> 00:48:19.600
So that's the summary of upgrading to GC.

00:48:19.600 --> 00:48:20.980
It can be done.

00:48:20.990 --> 00:48:22.060
We've done it for Xcode.

00:48:22.060 --> 00:48:23.540
We've done it for other applications.

00:48:23.540 --> 00:48:25.340
But it may be difficult.

00:48:25.340 --> 00:48:28.700
If you're writing your code in
a high-level Objective-C style,

00:48:28.790 --> 00:48:29.920
it might be easy.

00:48:29.920 --> 00:48:34.640
For example,
when we originally turned on TextEdit GC,

00:48:34.790 --> 00:48:37.570
we required one line of change.

00:48:37.920 --> 00:48:40.910
But if you're writing low-level code,
it might be more difficult.

00:48:41.040 --> 00:48:44.430
Finally, if you're writing a framework,
you need to be careful to write

00:48:44.480 --> 00:48:48.010
code that works whether or not
the garbage collector is running

00:48:48.010 --> 00:48:51.870
if that framework needs to be
loaded into an arbitrary process.

00:48:53.690 --> 00:48:57.630
Finally, let me show you some
GC debugging techniques.

00:48:57.710 --> 00:49:02.480
I'm going to run a demo of several
buggy garbage collection programs

00:49:02.900 --> 00:49:06.070
and show you how to analyze them,
how to debug them.

00:49:06.720 --> 00:49:09.890
This is a garbage collected
version of Sketch.

00:49:10.110 --> 00:49:14.340
It's actually the developer example
Sketch with garbage collection turned on.

00:49:14.340 --> 00:49:15.900
That's all I did.

00:49:15.920 --> 00:49:18.090
And then I introduced a bug.

00:49:18.910 --> 00:49:22.760
So I'm going to run
this under instruments.

00:49:22.800 --> 00:49:25.070
I'm going to show you a leak.

00:49:25.430 --> 00:49:29.250
Leaks do exist in garbage collection,
but they're different than they

00:49:29.250 --> 00:49:31.390
are in non-garbage collection.

00:49:31.510 --> 00:49:38.220
A leak in garbage collection is an object
that you expected to go away but did not.

00:49:38.280 --> 00:49:41.140
So I've created some rectangles.

00:49:41.190 --> 00:49:45.550
And if we look at instruments,
we can see there are now two

00:49:45.640 --> 00:49:48.240
rectangle objects allocated.

00:49:48.390 --> 00:49:50.290
Now I'm going to delete them.

00:49:51.910 --> 00:49:53.850
Go back to instruments.

00:49:53.960 --> 00:49:55.620
There's still two rectangles.

00:49:55.670 --> 00:49:58.510
OK, why are there two rectangles?

00:50:00.850 --> 00:50:03.380
Let me show you the backtraces
where they're allocated.

00:50:03.380 --> 00:50:07.150
Those are the addresses.

00:50:07.200 --> 00:50:09.860
This is the backtrace of
where it was allocated.

00:50:09.860 --> 00:50:11.960
It is, in fact, allocated by my code.

00:50:11.960 --> 00:50:16.230
So what I want to know is what
code is holding on to that.

00:50:16.240 --> 00:50:19.420
What objects are referencing
the rectangle objects such

00:50:19.430 --> 00:50:20.320
that it's still alive?

00:50:20.340 --> 00:50:26.840
I could use the garbage collection
instrument that we've added in Xcode 3.1,

00:50:26.840 --> 00:50:28.600
but I'm going to do it the hard way.

00:50:28.600 --> 00:50:30.060
I'm going to show you
the command line version.

00:50:31.970 --> 00:50:37.720
So I'm going to pull up
GDB on my sketch process.

00:50:39.870 --> 00:50:44.910
And I'm going to ask GDB,
what is referencing?

00:50:46.150 --> 00:50:47.600
My Rectangle Objects.

00:50:47.630 --> 00:50:49.000
I can type the address
of one of them here.

00:50:49.000 --> 00:50:55.010
Info GC references and an address.

00:50:55.260 --> 00:50:57.010
So ignore this warning.

00:50:57.340 --> 00:50:58.620
That is a bug.

00:50:58.630 --> 00:51:00.380
It will be fixed.

00:51:01.590 --> 00:51:04.430
The interesting point
is we have an object.

00:51:04.610 --> 00:51:08.080
There's the address of the object
that is pointing to my rectangle.

00:51:08.160 --> 00:51:09.540
There's some array object.

00:51:09.590 --> 00:51:13.530
I have an array of rectangles somewhere.

00:51:14.190 --> 00:51:15.670
That's not very useful.

00:51:15.830 --> 00:51:18.670
Let me look at the
entire stack of pointers,

00:51:18.810 --> 00:51:24.140
starting at a garbage collector
root and leading to my object.

00:51:24.900 --> 00:51:26.280
This is a longer stack.

00:51:26.480 --> 00:51:31.320
It starts at my rectangle,
and then we have the CFArray.

00:51:31.490 --> 00:51:34.300
And then we see the undo stack.

00:51:34.370 --> 00:51:34.670
Aha!

00:51:34.670 --> 00:51:41.950
The undo manager has kept a pointer
to my rectangle so that I can undo.

00:51:43.560 --> 00:51:46.280
And if I continue the process,
I can actually undo and

00:51:46.280 --> 00:51:47.570
get the rectangles back.

00:51:47.690 --> 00:51:48.440
So that's what happened.

00:51:48.470 --> 00:51:50.140
That's not really a leak.

00:51:50.200 --> 00:51:53.860
That was just a place where I didn't
understand how my program worked.

00:51:55.170 --> 00:51:57.900
So let's see a real leak.

00:51:58.000 --> 00:52:00.550
I'm going to create some circle objects.

00:52:00.560 --> 00:52:05.270
I've introduced a different
bug into the circles.

00:52:07.770 --> 00:52:12.920
And then, let me close my document.

00:52:13.100 --> 00:52:15.370
What I expect to see--

00:52:17.900 --> 00:52:23.700
[Transcript missing]

00:52:24.420 --> 00:52:27.430
So let's do the same trick
with the document object,

00:52:27.530 --> 00:52:32.290
see what code is still holding onto that.

00:52:32.350 --> 00:52:36.010
Info, gcroots, and the address.

00:52:37.850 --> 00:52:41.700
5E0.

00:52:41.740 --> 00:52:42.960
There's the roots.

00:52:43.010 --> 00:52:49.070
We have my document object,
and we have a global variable

00:52:49.070 --> 00:52:52.130
called RecentDocument still
pointing to my document object.

00:52:52.540 --> 00:53:00.010
In fact, if we went and we looked
at the rectangle objects,

00:53:00.010 --> 00:53:00.010
they are also being
referenced through that path.

00:53:11.760 --> 00:53:11.760
Or they would have been
if I hadn't deleted them.

00:53:11.760 --> 00:53:11.760
Oops.

00:53:11.760 --> 00:53:11.760
Never mind.

00:53:11.760 --> 00:53:11.760
They would have been if
I had run the demo properly.

00:53:11.760 --> 00:53:11.760
So let's take a look at my code and
find that recent document variable.

00:53:12.890 --> 00:53:15.550
Find in project, recent document.

00:53:15.560 --> 00:53:20.860
There it is, static global variable,
no surprise.

00:53:21.070 --> 00:53:25.400
For some reason, I was really stupid,
and now my init method,

00:53:25.740 --> 00:53:28.260
I've created a pointer to
the most recent document.

00:53:28.460 --> 00:53:32.300
Well, of course, that pointer will keep
one document alive,

00:53:32.300 --> 00:53:34.650
whichever one is allocated last.

00:53:34.850 --> 00:53:38.240
One fix for this would be to use week.

00:53:38.700 --> 00:53:42.170
Now that global variable will
still point to that document,

00:53:42.170 --> 00:53:45.260
but the garbage collector is
free to destroy it and will

00:53:45.670 --> 00:53:47.490
zero the pointer when it's done.

00:53:47.860 --> 00:53:53.770
So I can rebuild my program
and run instruments again.

00:53:53.810 --> 00:53:55.920
I'll see that I can create my document.

00:53:56.020 --> 00:53:58.380
There it is in the Instruments window.

00:53:59.790 --> 00:54:02.680
When I close it, it goes away.

00:54:02.800 --> 00:54:03.930
Document count is now zero.

00:54:03.930 --> 00:54:07.390
So that bug's fixed.

00:54:07.420 --> 00:54:12.410
But don't applaud yet,
because the program is still buggy.

00:54:15.050 --> 00:54:17.460
Let me bring up my sketch process again.

00:54:17.490 --> 00:54:20.690
Of course, I still have two of them
because GDB is still running.

00:54:24.340 --> 00:54:27.340
I'm going to draw some circles.

00:54:27.370 --> 00:54:30.560
Oops, I'm not going to do that yet,
because I need to be running

00:54:30.600 --> 00:54:32.610
in the Xcode debugger.

00:54:35.430 --> 00:54:39.710
So let me run in the debugger so
I can show you the console message as

00:54:39.810 --> 00:54:42.260
being printed because of the next bug.

00:54:42.500 --> 00:54:45.900
The next bug is because of circles.

00:54:46.000 --> 00:54:49.400
Here's my GDB console.

00:54:49.510 --> 00:54:51.970
I close the document.

00:54:53.240 --> 00:54:59.170
And I get an error in the console
log complaining about resurrection.

00:54:59.410 --> 00:55:01.560
Our garbage collector does
not allow resurrection,

00:55:01.560 --> 00:55:06.890
which is when an object is being
finalized and then somebody tries

00:55:06.960 --> 00:55:10.200
to keep that object alive by
storing it into a global variable

00:55:10.200 --> 00:55:12.230
or otherwise trying to preserve it.

00:55:12.240 --> 00:55:14.300
Our garbage collector doesn't allow that.

00:55:14.570 --> 00:55:16.630
Once you hit finalize,
the object is doomed.

00:55:16.630 --> 00:55:19.190
It will be destroyed no
matter what you try and do.

00:55:20.760 --> 00:55:23.410
In this case,
the garbage collector is complaining,

00:55:23.610 --> 00:55:25.700
particularly the write
barrier is complaining,

00:55:25.700 --> 00:55:31.510
that we wrote an object pointer
to a finalizing object into memory

00:55:31.850 --> 00:55:34.880
that the garbage collector can see.

00:55:35.190 --> 00:55:38.340
In particular,
we can see it's a circle object.

00:55:38.420 --> 00:55:43.980
In this case, it's actually a key value
observed circle object.

00:55:44.080 --> 00:55:48.150
And we can see the address that the
garbage collector complained about.

00:55:52.370 --> 00:55:56.110
There's also a handy function that
the garbage collector calls where you

00:55:56.180 --> 00:55:57.950
can set a breakpoint when this occurs.

00:55:58.150 --> 00:56:00.270
I've already done this,
which is why I'm stopped in

00:56:00.270 --> 00:56:03.430
the debugger instead of having
the program continue to run.

00:56:03.630 --> 00:56:06.660
At this point,
we can look up the backtrace

00:56:06.780 --> 00:56:10.540
of AutoZone ResurrectionError,
and we see that I'm in the

00:56:10.540 --> 00:56:11.990
Circle Finalize method.

00:56:12.140 --> 00:56:16.380
And again, oh gee,
I wrote a broken Finalize method.

00:56:16.380 --> 00:56:17.860
Imagine that.

00:56:17.980 --> 00:56:21.380
In this case,
I've created an NSMutable array,

00:56:21.440 --> 00:56:26.890
which is not dead,
and I've stored the Circle pointer

00:56:27.000 --> 00:56:28.810
into that not-dead array.

00:56:28.820 --> 00:56:34.710
The garbage collector sees this and
complains that you now have a dangling,

00:56:34.710 --> 00:56:38.150
or will, once the object is deleted,
you'll have a dangling

00:56:38.150 --> 00:56:39.990
pointer to the Circle object.

00:56:40.060 --> 00:56:43.300
Obvious solution, don't do that.

00:57:02.180 --> 00:57:02.180
And since this is my test program,
and this is the only reason why

00:57:02.180 --> 00:57:02.180
I wrote this finalized method,
delete it entirely.

00:57:02.180 --> 00:57:02.180
So this is an example of why you
need to make sure your finalizers

00:57:02.180 --> 00:57:02.180
just do as little work as possible,
because they might do work that,

00:57:02.180 --> 00:57:02.180
for example,
stores the object in an array,

00:57:02.180 --> 00:57:02.180
and then you'll get a
resurrection warning.

00:57:03.290 --> 00:57:04.740
So now the program would work.

00:57:04.740 --> 00:57:08.510
I won't bother showing you
the working version now.

00:57:12.920 --> 00:57:16.840
The next example I want to
show you is some crashes due

00:57:16.840 --> 00:57:22.370
to write barrier problems and
due to scanned memory problems.

00:57:22.960 --> 00:57:27.580
This is some C code that I've
converted directly to Objective-C,

00:57:27.580 --> 00:57:31.050
and converted directly to
garbage collection without using

00:57:31.050 --> 00:57:32.740
actually much Objective-C at all.

00:57:32.740 --> 00:57:35.000
It's really mostly a C program.

00:57:35.060 --> 00:57:37.490
I have a C structure.

00:57:38.010 --> 00:57:42.400
indicating a work item
for my work queue program.

00:57:42.460 --> 00:57:46.660
I have a producer thread which
is generating these work objects.

00:57:46.790 --> 00:57:51.230
And I have a consumer thread which
is reading these work objects from

00:57:51.230 --> 00:57:53.190
a list and destroying them later.

00:57:53.510 --> 00:57:56.720
In the garbage collection version,
I actually don't have any free

00:57:56.720 --> 00:58:00.570
calls or any release calls in
this code because I'm trying to

00:58:00.570 --> 00:58:03.310
use garbage collected C objects.

00:58:03.690 --> 00:58:05.870
So in particular,
we can see that I've used

00:58:05.880 --> 00:58:10.510
nsalocate collectible to
create the array of objects.

00:58:10.890 --> 00:58:15.040
And I'm using NSAllocate collectible
for each individual work item structure.

00:58:15.040 --> 00:58:21.100
So if we run this
program in the debugger,

00:58:22.540 --> 00:58:24.400
All will not be happy.

00:58:24.530 --> 00:58:26.000
Bad access.

00:58:26.140 --> 00:58:26.800
That's not good.

00:58:26.800 --> 00:58:29.720
I'm not supposed to get pointer errors
with the garbage collector program,

00:58:29.720 --> 00:58:30.070
am I?

00:58:30.180 --> 00:58:33.060
Well,
I'm writing garbage collected C code,

00:58:33.060 --> 00:58:37.150
and C code is not always as
happy with the garbage collector.

00:58:37.260 --> 00:58:41.400
In this case,
I crashed nobjc-message-send.

00:58:42.170 --> 00:58:44.500
And that's not really a
very useful backtrace.

00:58:44.540 --> 00:58:45.940
Do I have a better one here?

00:58:45.940 --> 00:58:48.600
No.

00:58:49.920 --> 00:58:54.260
Unfortunately, I'm not getting the
friendly backtrace I wanted,

00:58:54.280 --> 00:58:58.670
which actually showed me
where it was crashing.

00:58:58.750 --> 00:59:02.380
So you'll have to take my word for it
when I tell you it's crashing here.

00:59:02.440 --> 00:59:10.180
Maybe I can do it better than that.

00:59:15.110 --> 00:59:16.680
Oh, because I'm in the wrong frame.

00:59:16.680 --> 00:59:21.560
I bet if I rerun it again,
it'll die in a different place.

00:59:31.610 --> 00:59:32.870
That's more like it.

00:59:33.040 --> 00:59:36.970
So here's the instruction
I really wanted to crash on.

00:59:37.360 --> 00:59:40.590
This instruction is checking,
is doing a sanity check

00:59:40.590 --> 00:59:41.500
on my work object.

00:59:41.580 --> 00:59:44.730
I have an index in the work object,
which is the same as

00:59:44.730 --> 00:59:48.760
the index in the array,
or should be, but in this case, it's not.

00:59:48.760 --> 00:59:53.830
So let's look at the
contents of that object.

00:59:58.680 --> 01:00:03.380
So that does not look like
a very friendly index value

01:00:03.380 --> 01:00:06.160
between 1 and about 10,000,
is it?

01:00:06.440 --> 01:00:09.520
So something has destroyed the object.

01:00:09.550 --> 01:00:14.660
Most likely, it destroyed the object and
reallocated it as something else.

01:00:17.340 --> 01:00:22.060
So that means we need to look
at where this pointer came from

01:00:22.060 --> 01:00:24.650
and where it is being stored.

01:00:26.190 --> 01:00:29.050
It was created by my producer, Thread.

01:00:29.240 --> 01:00:31.380
This is the code that's
allocating the object,

01:00:31.460 --> 01:00:33.900
and we're storing it into this array.

01:00:35.300 --> 01:00:41.150
So the array is correctly being
scanned with the NS scanned option.

01:00:41.360 --> 01:00:45.470
So that suggests that it should work,
that the garbage collector

01:00:45.480 --> 01:00:47.050
should see that pointer.

01:00:47.610 --> 01:00:51.450
But it turns out the NSCAN option
is insufficient in this case because

01:00:51.450 --> 01:00:53.960
I'm missing the right barrier.

01:00:54.500 --> 01:00:59.230
Now, the one good way to decide whether
a write barrier is responsible for

01:00:59.300 --> 01:01:03.210
the crash you're seeing is to change
the garbage collector's behavior

01:01:03.210 --> 01:01:06.820
such that it works more reliably
even without a write barrier.

01:01:06.820 --> 01:01:11.030
You can do this by setting a
couple of environment variables.

01:01:12.640 --> 01:01:18.350
Obviously, use TLC, no,
turns off the thread local collector.

01:01:20.210 --> 01:01:24.760
Obc disable generational.

01:01:24.760 --> 01:01:25.710
Yes.

01:01:26.040 --> 01:01:28.810
This turns off the
generational algorithm,

01:01:28.810 --> 01:01:32.040
which means all collections
are full collections,

01:01:32.040 --> 01:01:36.780
which means the write barrier is not
actually necessary some of the time.

01:01:38.390 --> 01:01:40.460
So since I'm having trouble
reproducing this bug,

01:01:40.460 --> 01:01:44.460
I won't try and show you
running with these two set.

01:01:44.620 --> 01:01:47.480
But typically,
a write barrier error will show

01:01:47.550 --> 01:01:53.770
itself when it crashes normally and
does not crash with these values set.

01:01:53.920 --> 01:01:57.750
Turns out the problem
in my program is here.

01:01:58.360 --> 01:02:04.120
This variable is a local variable,
but it is an indirect pointer.

01:02:04.400 --> 01:02:23.700
[Transcript missing]

01:02:24.500 --> 01:02:49.100
[Transcript missing]

01:02:49.520 --> 01:02:52.200
So that's one of the bugs in my program.

01:02:52.240 --> 01:02:54.420
Unfortunately,
it is tricky to track down.

01:02:54.420 --> 01:02:58.200
Right barrier errors are not
the easiest ones to debug with

01:02:58.200 --> 01:03:00.420
our current debugging tools.

01:03:00.540 --> 01:03:03.560
Turns out there's another bug.

01:03:03.610 --> 01:03:05.590
I know this 'cause I wrote it.

01:03:06.780 --> 01:03:09.770
Another bad access.

01:03:09.920 --> 01:03:12.900
This one in a slightly different place.

01:03:16.030 --> 01:03:18.460
We go to our backtrace.

01:03:18.610 --> 01:03:22.400
This time, the item structure is intact.

01:03:22.450 --> 01:03:25.270
The index value is correct.

01:03:26.050 --> 01:03:29.460
First, it doesn't want to tell me that,
but it is correct.

01:03:29.620 --> 01:03:33.260
We're having trouble accessing
the NSNumber that is also

01:03:33.260 --> 01:03:35.770
part of the work item.

01:03:35.920 --> 01:03:38.990
So again, we can print the value.

01:03:41.640 --> 01:03:43.000
Looks like an ordinary pointer value.

01:03:43.000 --> 01:03:46.300
We see the index is reasonable,
so that part is correct now.

01:03:46.300 --> 01:03:51.610
Let's look at the NSNumber object.

01:03:51.610 --> 01:03:51.610
Greg Parker

01:03:54.900 --> 01:03:57.470
Let's do it this way.

01:03:57.560 --> 01:03:58.780
I do XI sub value.

01:03:59.060 --> 01:04:05.690
This should be an NSNumber object,
but that's not an NSNumber class pointer.

01:04:05.880 --> 01:04:09.260
So this NS value has been scrambled.

01:04:09.260 --> 01:04:13.070
If we run it a couple more times,

01:04:16.920 --> 01:04:20.400
We may actually get another
crash I'd like to show you.

01:04:20.460 --> 01:04:24.580
Ignore those.

01:04:24.580 --> 01:04:26.920
Those are another bug I'm
not going to show you.

01:04:30.570 --> 01:04:35.160
So the other case that you'll commonly
see of an is a variable that is

01:04:35.160 --> 01:04:38.160
trashed is one that looks like this.

01:04:38.370 --> 01:04:43.300
Typically, it'll start with some Fs and
then have some random values,

01:04:43.640 --> 01:04:45.600
and it'll end misaligned.

01:04:46.280 --> 01:04:51.980
What is happening here is that
the value is obviously wrong,

01:04:51.980 --> 01:04:57.120
but the bitwise negation of the value
looks more like a reasonable pointer.

01:04:57.120 --> 01:04:59.580
It's actually in your heap.

01:04:59.720 --> 01:05:02.210
It's actually an even-numbered value,
that sort of thing.

01:05:02.220 --> 01:05:08.090
The garbage collector and actually
the C memory manager mangle their

01:05:08.090 --> 01:05:12.790
free list pointers to be negated,
and those free list pointers are

01:05:12.790 --> 01:05:14.370
in the same slot as your ISA.

01:05:14.960 --> 01:05:19.040
So you can frequently tell if an object
is actually a deallocated object because

01:05:19.040 --> 01:05:21.080
it'll look like a mangled pointer.

01:05:24.140 --> 01:05:27.690
So in this case,
I have the NSNumber object,

01:05:27.690 --> 01:05:30.560
which is being prematurely
destroyed before we get here.

01:05:30.990 --> 01:05:32.980
So I need to look at
where it was allocated,

01:05:32.980 --> 01:05:35.350
where it was stored in the meantime.

01:05:35.570 --> 01:05:39.480
In this case,
the NSNumber is being stored in a work T.

01:05:39.730 --> 01:05:44.590
We should be getting the correct
write barrier because this

01:05:44.850 --> 01:05:46.560
is a garbage-collected type.

01:05:46.580 --> 01:05:47.930
The garbage collector
should know about that.

01:05:48.020 --> 01:05:51.390
The compiler should issue
a write barrier for us.

01:05:51.730 --> 01:05:53.150
So this is the assignment.

01:05:53.280 --> 01:05:57.490
If we disassemble the code here,
we would see the write barrier present.

01:05:57.580 --> 01:05:59.780
And this is the memory
where it is stored,

01:05:59.910 --> 01:06:05.180
which is scanned memory, except it's not.

01:06:05.310 --> 01:06:08.680
We should have used an Escand option.

01:06:11.710 --> 01:06:15.590
Because this is an ordinary heap block,
the garbage collector won't look in

01:06:15.590 --> 01:06:21.200
it for my Annis number pointer unless
I allocate it with the scanned option.

01:06:21.290 --> 01:06:24.390
So now my program should really work.

01:06:29.200 --> 01:06:32.100
Runs, it starts up,
and now my producer and consumer

01:06:32.100 --> 01:06:35.700
threads are actually seeing all the
objects properly garbage collected,

01:06:35.700 --> 01:06:36.600
properly managed.

01:06:43.400 --> 01:06:44.520
Not sure why you're plotting.

01:06:44.520 --> 01:06:48.540
It's really easy to fix
bugs you wrote yourself.

01:06:48.650 --> 01:06:54.900
So again, debugging these problems can be
difficult in a large program,

01:06:54.900 --> 01:06:58.970
especially with the write
barriers and trying to diagnose

01:06:59.000 --> 01:07:01.200
which write barrier was missing.

01:07:01.290 --> 01:07:04.800
So the best way to write this program
is to use proper Objective-C objects,

01:07:04.850 --> 01:07:08.770
Objective-C container types,
if I don't need the really

01:07:08.800 --> 01:07:10.790
low level C performance.

01:07:12.410 --> 01:07:15.000
So that's all I have for you today.

01:07:15.000 --> 01:07:20.490
At this point,
let me show you the info slide here.

01:07:23.300 --> 01:07:26.300
Of course,
I left my clicker in this pocket.

01:07:26.470 --> 01:07:30.640
So for more information,
we can talk to Michael Jurowicz

01:07:30.640 --> 01:07:32.940
and the other DevTools evangelists.

01:07:32.950 --> 01:07:36.420
We also have documentation on the
website about the Garbage Collector,

01:07:36.420 --> 01:07:38.320
writing Garbage Collector programs.

01:07:38.390 --> 01:07:41.180
So now,
I'd like to invite Michael Jurowicz

01:07:41.190 --> 01:07:44.930
and the rest of the Garbage
Collection team for some Q&A.
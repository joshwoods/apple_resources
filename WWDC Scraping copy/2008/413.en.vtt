WEBVTT

00:00:20.950 --> 00:00:22.060
Welcome.

00:00:22.060 --> 00:00:26.800
I am Perry 'the Cynic'. I am the senior
architect in the data security group.

00:00:26.800 --> 00:00:32.640
I designed code signing and implemented
it with a lot of help from my friends.

00:00:32.650 --> 00:00:36.460
So I'm yet again here to tell
you about code signing in

00:00:36.460 --> 00:00:39.100
Mac OS X and why it's good for you.

00:00:41.420 --> 00:00:45.240
That's me.

00:00:45.240 --> 00:00:48.640
So I'll tell you about what it is.

00:00:48.640 --> 00:00:54.090
I'll tell you enough about how
it works so you get an idea.

00:00:54.110 --> 00:00:56.510
I'll tell you how to work
with code signatures,

00:00:56.510 --> 00:00:58.620
how to make them, how to verify them.

00:00:58.630 --> 00:01:03.120
I'll tell you about the API,
which has just become public,

00:01:03.120 --> 00:01:08.620
so you too can now call code
signing functions in Snow Leopard.

00:01:08.660 --> 00:01:12.500
I'll tell you what you need to
do to get your program signed and

00:01:12.500 --> 00:01:16.910
I'll tell you what to look out
for so you don't get into trouble.

00:01:23.420 --> 00:01:29.850
Code signing helps seal a
program against modifications.

00:01:30.570 --> 00:01:37.090
So it's first a way to figure
out whether something's changed.

00:01:37.870 --> 00:01:42.600
It's a way of defining what it
means for code to have identity.

00:01:42.600 --> 00:01:48.000
Like what it means to be Apple's
Mail.app versus an imposter Mail.app or,

00:01:48.000 --> 00:01:50.590
heaven forfend, your Mail.app.

00:01:50.910 --> 00:01:55.060
It can verify things on the
hard drive--it's called static

00:01:55.060 --> 00:01:58.730
validation--and it can verify things
that are running in the system.

00:01:58.860 --> 00:02:02.150
We call that dynamic validation,
and it's really what

00:02:02.190 --> 00:02:03.790
code signing is about.

00:02:04.010 --> 00:02:08.650
And finally, to get all of that working,
almost as a side effect,

00:02:08.650 --> 00:02:12.630
we'll provide a way of formally
expressing constraints on

00:02:12.630 --> 00:02:17.150
code--conditions you can impose on
code that it needs to satisfy in

00:02:17.150 --> 00:02:19.640
order to be allowed to do things.

00:02:20.550 --> 00:02:21.970
And what does it not do?

00:02:22.210 --> 00:02:24.400
That's almost as important.

00:02:24.400 --> 00:02:28.910
Just like a lot of the other
security services like authorization,

00:02:29.040 --> 00:02:32.690
signing a program does not get you
automatically any kind of process

00:02:32.690 --> 00:02:35.160
privileges that you don't already have.

00:02:35.340 --> 00:02:39.260
What it does is help other
programs in the system establish

00:02:39.380 --> 00:02:43.040
whether you're really you and
whether you're an acceptable

00:02:43.080 --> 00:02:45.100
candidate for getting services.

00:02:45.990 --> 00:02:50.070
Code signing does not protect
by itself against bugs.

00:02:50.150 --> 00:02:51.550
Because it's about identity.

00:02:51.670 --> 00:02:53.890
It's not about behavior.

00:02:54.080 --> 00:02:56.370
If you write a program,
and you put a bug in

00:02:56.370 --> 00:02:58.570
that erases a hard drive,
and you sign it,

00:02:58.570 --> 00:03:00.690
and you send it to the user,
and the user runs it,

00:03:00.690 --> 00:03:01.740
it will erase the hard drive.

00:03:01.900 --> 00:03:04.790
And that's not a problem
with code signing,

00:03:04.840 --> 00:03:10.160
because nothing in there promised that
it wouldn't erase your hard drive.

00:03:10.250 --> 00:03:14.420
And from the end user's point of view,
code signing does not protect the

00:03:14.420 --> 00:03:17.120
user against trusting the wrong guy.

00:03:17.170 --> 00:03:21.120
If the user says,
hard drive eraser dot app sounds great,

00:03:21.120 --> 00:03:25.380
and I'll run it,
then it will go and erase the hard drive.

00:03:25.580 --> 00:03:27.990
Because that's what
the user said he wants.

00:03:27.990 --> 00:03:30.620
And despite what you
may have heard recently,

00:03:30.620 --> 00:03:33.110
this is really about what the user wants.

00:03:34.670 --> 00:03:41.130
Code signing is meant to be an
integral foundational part of Mac OS.

00:03:41.140 --> 00:03:46.640
And so it's in Mac OS X Leopard and
Snow Leopard and it's on the phone.

00:03:46.700 --> 00:03:49.340
It's really pretty much the
same code signing technology.

00:03:49.600 --> 00:03:52.380
Some of the details are different,
some of the emphasis is different,

00:03:52.490 --> 00:03:53.980
but it's the same technology.

00:03:54.140 --> 00:03:57.890
It works pretty much the
same on the two platforms.

00:03:58.310 --> 00:04:01.350
It obviously applies to programs,
Mac OS processes,

00:04:01.440 --> 00:04:07.440
but it can also apply to libraries and
frameworks and scripts and plugins.

00:04:07.500 --> 00:04:10.880
It's designed to be able
to apply to anything that's

00:04:10.880 --> 00:04:13.040
runnable code on the system.

00:04:14.010 --> 00:04:15.380
And, well, it does.

00:04:15.550 --> 00:04:17.050
Static and dynamic validation.

00:04:17.280 --> 00:04:23.900
The goal going down the road is a
system where everything is signed.

00:04:24.110 --> 00:04:27.140
That's already true on the phone
because the phone enforces it.

00:04:27.350 --> 00:04:29.880
Code just won't run on the
phone unless it's signed.

00:04:30.020 --> 00:04:33.660
It's not true in Mac OS X as of Leopard,
or for that matter, Snow Leopard,

00:04:33.660 --> 00:04:35.800
but it's a goal we're working towards.

00:04:36.040 --> 00:04:38.730
That's where we need your help because,
you know,

00:04:38.910 --> 00:04:40.900
your code wants to run on the system too.

00:04:40.900 --> 00:04:45.960
So in the end, down the road,
it will need to be signed.

00:04:47.220 --> 00:04:48.480
So what are we using it for?

00:04:48.650 --> 00:04:52.940
I mean, obviously now that we have APIs,
you can use it for anything you like.

00:04:52.980 --> 00:04:56.330
But if you just install
Leopard or Snow Leopard,

00:04:56.430 --> 00:04:58.610
what does it use it for?

00:04:58.750 --> 00:05:04.950
Anytime you use Keychain services,
the code signing logic is

00:05:04.950 --> 00:05:09.180
used to identify programs that
ask for Keychain services.

00:05:09.310 --> 00:05:13.840
So when an access control list says,
"Only Apple's mail program is

00:05:13.970 --> 00:05:16.340
allowed to get your mail password,"

00:05:16.610 --> 00:05:22.050
Apple's mail program is really a code
signing constraint that gets evaluated by

00:05:22.050 --> 00:05:27.200
the security server at runtime to decide
whether the program making the request

00:05:27.200 --> 00:05:29.860
is allowed to get access to that item.

00:05:30.270 --> 00:05:33.340
For that matter, any time there's a
dialogue that comes up,

00:05:33.410 --> 00:05:36.650
one of those security dialogues
that says the program so-and-so

00:05:36.790 --> 00:05:39.980
wants to do something--your program,
some other program,

00:05:39.980 --> 00:05:43.440
like for example in an authorization
dialogue--the name of the

00:05:43.530 --> 00:05:47.770
program that's showing up here
is determined by code signing.

00:05:47.850 --> 00:05:52.550
So this is all about program identity,
about code identity,

00:05:52.550 --> 00:05:56.330
and obviously anywhere in the system
where we care about code identity,

00:05:56.330 --> 00:05:56.330
code signing is used.

00:05:56.510 --> 00:05:59.290
The extreme case, of course,
is parental controls,

00:05:59.460 --> 00:06:02.740
which cares about which code
is allowed to run at all if

00:06:02.740 --> 00:06:04.630
you're a restricted user.

00:06:04.630 --> 00:06:08.220
And as of Leopard,
parental controls and MCX are using

00:06:08.310 --> 00:06:12.850
code signing to decide whether
something is allowed to run at all.

00:06:12.930 --> 00:06:20.190
So here's an extreme case of if code
signing doesn't work for a program,

00:06:20.190 --> 00:06:21.740
then a restricted user just
won't be able to run it at all.

00:06:21.900 --> 00:06:27.530
The application firewall is using
code signatures to keep track

00:06:27.530 --> 00:06:29.020
of the identity of programs.

00:06:29.050 --> 00:06:33.340
Once you've answered a dialogue and
said it's okay for that program to

00:06:33.340 --> 00:06:38.670
allow inbound network connections,
the firewall remembers the identity

00:06:38.670 --> 00:06:41.680
of that program so the next
time you don't get asked again.

00:06:41.800 --> 00:06:46.730
There's actually a lot of
situations where it works like this:

00:06:46.820 --> 00:06:51.660
you point at a program and you say,
"This program from now on." And code

00:06:51.660 --> 00:06:56.800
signatures are used to make sure that
the next time the program comes and asks,

00:06:56.800 --> 00:06:58.800
it's still the same program.

00:06:58.800 --> 00:07:01.260
And then there's a couple of
little things like what we

00:07:01.300 --> 00:07:02.790
call developer tools access.

00:07:02.840 --> 00:07:05.390
For example,
the task for PID system call,

00:07:05.390 --> 00:07:08.820
which is extremely powerful
but kind of useful if you write

00:07:08.820 --> 00:07:10.800
debuggers or performance tools.

00:07:11.210 --> 00:07:14.860
Going down the road,
you need to be code signed and marked

00:07:14.860 --> 00:07:17.470
up to be allowed to use that at all.

00:07:18.770 --> 00:07:23.540
Well, let's try the thousand
words for a picture here.

00:07:23.540 --> 00:07:26.540
You have an executable and
if it's not a plain tool,

00:07:26.540 --> 00:07:30.830
it actually has resources and an
Info.plist and maybe a couple of

00:07:30.840 --> 00:07:35.000
helper tools because you're supposed to
factor out your privileged operations.

00:07:35.300 --> 00:07:38.530
So what do we do to sign this?

00:07:38.730 --> 00:07:44.320
Well, we take these files,
we add a unique identifier--you pick

00:07:44.440 --> 00:07:47.620
that one if you're doing the signing--

00:07:48.050 --> 00:07:53.530
And we put a seal on these files
to keep them from being changed.

00:07:53.560 --> 00:07:55.870
But because a seal can
be rebuilt at any time,

00:07:56.060 --> 00:08:01.540
we then use a digital identity
to sign this sealed blob of data.

00:08:01.730 --> 00:08:05.510
The idea of a digital
identity is that only you,

00:08:05.510 --> 00:08:09.260
the developer,
have the private key that can make these.

00:08:09.510 --> 00:08:10.730
You don't give it to anybody.

00:08:10.980 --> 00:08:13.540
It's a secret that only you have.

00:08:13.690 --> 00:08:16.440
And therefore,
as long as you don't mess up and,

00:08:16.600 --> 00:08:22.200
you know, post it on the internet,
nobody else can actually make a

00:08:22.200 --> 00:08:26.040
signature that looks like you made it.

00:08:28.270 --> 00:08:30.740
This part is what we
call a code signature.

00:08:30.800 --> 00:08:33.910
So it's the identifier, it's the seal,
and it's the signature

00:08:33.910 --> 00:08:35.570
that's placed on the seal.

00:08:35.750 --> 00:08:38.420
And usually the signature
gets embedded in the program.

00:08:38.440 --> 00:08:42.290
If it's a MachO binary,
it just goes into the MachO file itself,

00:08:42.290 --> 00:08:45.920
which of course gets
modified during that process.

00:08:46.360 --> 00:08:49.060
Now, you may wonder what happened to
that poor little helper tool off

00:08:49.060 --> 00:08:52.340
there to the side that clearly
isn't part of the code signature.

00:08:52.390 --> 00:08:56.210
No, it isn't,
because we want you to put a separate

00:08:56.210 --> 00:08:58.580
signature on your helper tool.

00:08:58.740 --> 00:09:02.080
That's an important point and I'll
come to that for a couple more times.

00:09:02.380 --> 00:09:05.490
Helpers are not part of the
code signature of the thing

00:09:05.490 --> 00:09:07.240
that they're helpers for.

00:09:07.320 --> 00:09:09.410
They are separate pieces of code.

00:09:09.720 --> 00:09:17.890
They need their own signatures and
it's important not to mix them up

00:09:17.890 --> 00:09:17.890
with the signature of the program and
whose bundle they happen to be in.

00:09:18.370 --> 00:09:22.800
Okay, so now you've signed a program,
now what do you do with it?

00:09:22.800 --> 00:09:27.560
Well, so you start with your code,
as we just discussed, you sign,

00:09:27.560 --> 00:09:30.740
starting with Snow Leopard,
actually starting with the new

00:09:30.740 --> 00:09:32.860
developer tools that just came out.

00:09:32.860 --> 00:09:36.060
Xcode has learned how to sign,
so you don't have to run the

00:09:36.060 --> 00:09:38.820
command line tool anymore,
it still works of course,

00:09:38.940 --> 00:09:42.050
but now you can actually
get Xcode to sign your code.

00:09:42.060 --> 00:09:46.660
So, you sign your program,
and then you ship it.

00:09:46.660 --> 00:09:49.300
And we do not care how you ship it.

00:09:49.620 --> 00:09:52.060
You can have a drag installer,
you can have the Apple installer,

00:09:52.060 --> 00:09:54.860
you can use a third party installer,
you can post it on your website

00:09:54.860 --> 00:09:55.850
and have people download it.

00:09:55.930 --> 00:09:59.350
We absolutely do not care how you
get that code to the end user.

00:09:59.360 --> 00:10:02.860
What we do care about is that what
ends up there is exactly what you said.

00:10:02.930 --> 00:10:04.860
So,
this is the code that you started with.

00:10:04.860 --> 00:10:08.580
So, this signed code on the end user
system better be byte for byte,

00:10:08.580 --> 00:10:10.800
file for file,
the same thing that you made

00:10:11.050 --> 00:10:12.720
when you signed your program.

00:10:12.860 --> 00:10:17.790
But usually it isn't a big problem
if you do an initial installation.

00:10:17.920 --> 00:10:20.930
If you go into incremental
updates in areas where you're only

00:10:20.930 --> 00:10:24.280
shipping the files that changed,
you have to be a bit careful.

00:10:24.460 --> 00:10:27.840
Okay, so then the user runs the program,
and that's fine.

00:10:27.940 --> 00:10:31.410
And there is an API,
the Code Signing Validation API,

00:10:31.410 --> 00:10:34.490
that you can point at a running program,
basically say,

00:10:34.490 --> 00:10:39.170
"Is it okay?" And what you get out is,
"Yes, it's okay," or,

00:10:39.170 --> 00:10:40.590
"Here's the reason why it's not okay."

00:10:40.950 --> 00:10:44.260
And that by itself validates
that the program hasn't been

00:10:44.260 --> 00:10:46.160
modified since it was signed.

00:10:46.180 --> 00:10:47.420
That's useful.

00:10:47.420 --> 00:10:49.710
I mean,
if something corrupts the program,

00:10:49.710 --> 00:10:50.540
you'll know.

00:10:50.540 --> 00:10:53.000
If something intentionally
corrupts the program,

00:10:53.000 --> 00:10:56.360
you'll usually know,
unless the guy doing the corrupting

00:10:56.360 --> 00:11:00.130
is smart enough to corrupt it and then
re-sign it with his own signature,

00:11:00.130 --> 00:11:01.730
which, of course, he can do.

00:11:01.740 --> 00:11:04.060
Anybody can sign a program.

00:11:04.060 --> 00:11:06.370
I mean, there's no secret to it.

00:11:06.840 --> 00:11:09.930
So we need a little bit more to
actually notice that somebody

00:11:09.930 --> 00:11:11.620
changed and then re-signed a program.

00:11:11.620 --> 00:11:15.450
So this is where these
code requirements come in,

00:11:15.460 --> 00:11:19.640
these standardized ways of
expressing constraints on programs.

00:11:19.640 --> 00:11:24.830
Because another input to the
validation API is a requirement object.

00:11:24.920 --> 00:11:26.600
Now, where do you get that from?

00:11:26.600 --> 00:11:28.960
Well,
usually you store it in some database.

00:11:28.960 --> 00:11:31.690
For example,
the keychain API stores it in the

00:11:31.690 --> 00:11:34.180
access control list of a keychain item.

00:11:34.180 --> 00:11:36.700
In some other cases, it's a constant.

00:11:36.840 --> 00:11:40.160
Like, some program may only care
that the program was signed

00:11:40.260 --> 00:11:42.140
by a particular manufacturer,
like you.

00:11:43.550 --> 00:11:46.790
But usually there's some kind
of database involved somewhere.

00:11:47.050 --> 00:11:48.500
So how do you get it into the database?

00:11:48.860 --> 00:11:52.310
Well,
there's actually a call that you can

00:11:52.420 --> 00:11:57.100
apply to a signed program that gets
you one of those code requirements.

00:11:57.100 --> 00:11:59.710
And we'll discuss exactly how
you do that a little bit later.

00:11:59.770 --> 00:12:03.880
But the general idea is that as long
as you just care about continuity,

00:12:04.110 --> 00:12:06.960
about recognizing a
program you've seen before,

00:12:06.980 --> 00:12:08.610
this is the data flow.

00:12:08.780 --> 00:12:11.530
You start with the code when
you see it the first time.

00:12:11.650 --> 00:12:12.820
You get yourself a requirement.

00:12:12.820 --> 00:12:14.900
You store it in the database.

00:12:14.970 --> 00:12:16.770
And then later on,
if you're wondering if it's the

00:12:16.800 --> 00:12:20.780
same program you're looking at,
you pass that to the validation API.

00:12:20.850 --> 00:12:25.690
And it will basically say, "Yeah,
it's the same program," or "No,

00:12:25.690 --> 00:12:26.690
it's not."

00:12:27.490 --> 00:12:31.720
So by now we've figured out that
this is primarily a runtime feature.

00:12:31.780 --> 00:12:34.600
So this is not really about
scouring around the hard drive and

00:12:34.730 --> 00:12:36.000
finding things and kind of going,
"Yeah,

00:12:36.000 --> 00:12:40.780
that looks like mail over there in that
bundle." This is primarily about--there's

00:12:40.780 --> 00:12:43.270
this program running this process.

00:12:43.410 --> 00:12:47.510
And yes, right now,
at this particular point in time

00:12:47.510 --> 00:12:54.060
when you call the validation API,
this is a valid instance of Apple's mail

00:12:54.060 --> 00:12:54.150
or a valid instance of your program.

00:12:55.240 --> 00:12:57.860
Sort of as a side effect,
we do a lot of static validation.

00:12:57.860 --> 00:13:00.940
We do look at the files on the
hard drive because we need it

00:13:00.940 --> 00:13:02.860
as part of the implementation.

00:13:03.030 --> 00:13:06.000
And we give you API for actually
looking at the disk and checking

00:13:06.070 --> 00:13:09.340
the static validity of code on
disk because the functionality

00:13:09.340 --> 00:13:10.660
is already there and it's handy.

00:13:10.860 --> 00:13:14.300
But the focus of this whole
feature is a runtime focus.

00:13:14.520 --> 00:13:17.050
It's about running code.

00:13:19.190 --> 00:13:24.100
One thing that is part of
the architecture and we're

00:13:24.170 --> 00:13:28.200
not doing a lot of yet,
but we will do a lot more in the future,

00:13:28.270 --> 00:13:30.420
is dealing with hierarchies of code.

00:13:30.580 --> 00:13:33.960
I mean, in the simplest case,
you've got a process running and

00:13:33.960 --> 00:13:38.120
you know the kernel manages it,
but, you know, we know that.

00:13:38.210 --> 00:13:41.060
And so that's all we care about,
a process.

00:13:41.130 --> 00:13:45.050
But then sometimes your code is a script,
and the script is being

00:13:45.920 --> 00:13:48.150
interpreted by another program.

00:13:48.600 --> 00:13:50.500
Or managed or supervised.

00:13:50.500 --> 00:13:52.780
Think of an applet running in Safari.

00:13:52.970 --> 00:13:57.500
The applet really is code
conceptually and Safari is a program.

00:13:57.510 --> 00:14:00.500
So the two have a relationship and
one of the features of code signing

00:14:00.500 --> 00:14:04.950
is called code hosting where you
essentially can express to the system

00:14:04.950 --> 00:14:12.490
a relationship between a code host,
a piece of code that's managing another

00:14:12.490 --> 00:14:12.490
piece of code which we call the guest.

00:14:13.000 --> 00:14:17.980
And lastly, it's kind of important
for this to be efficient.

00:14:18.100 --> 00:14:22.180
There's a lot of code signing
machinery out there and other

00:14:22.190 --> 00:14:26.440
operating systems that works okay,
as long as you really don't

00:14:26.440 --> 00:14:29.900
care about performance,
because it basically sucks.

00:14:29.950 --> 00:14:38.230
So there's a lot of emphasis in our
implementation on making this work

00:14:38.260 --> 00:14:44.180
without there being this big momentary
impact when you run a program or when you

00:14:44.310 --> 00:14:47.410
call a verification API where everything
comes to a screeching halt while we're

00:14:47.540 --> 00:14:49.900
thinking about whether this is okay.

00:14:50.090 --> 00:14:53.990
There's a lot of trickery in there,
and if you want to know,

00:14:54.180 --> 00:14:55.900
ask questions later.

00:14:56.050 --> 00:14:59.900
But the one point that explains
most of what we're doing is

00:14:59.900 --> 00:15:01.900
that we're signing a code,
we're spreading stuff out.

00:15:02.230 --> 00:15:05.900
There is no one point
where a validation happens.

00:15:05.900 --> 00:15:10.010
There's a lot of stuff that happens
incrementally as the program runs,

00:15:10.010 --> 00:15:14.880
and the real magic--and, well,
we did patent it--is how you can

00:15:14.980 --> 00:15:18.280
string these little incremental
verification operations together without

00:15:18.310 --> 00:15:22.720
having a hole in the middle that the
attacker can drive some truck through.

00:15:23.430 --> 00:15:26.250
Okay,
that's just a little bit of graphic.

00:15:26.270 --> 00:15:27.640
This is the classic case.

00:15:27.640 --> 00:15:29.680
You have a program like Mail.app.

00:15:29.750 --> 00:15:31.300
The kernel runs it.

00:15:31.440 --> 00:15:32.860
That's the code signing view.

00:15:32.900 --> 00:15:34.690
Basically, you have the running process.

00:15:34.720 --> 00:15:36.940
The system knows where it
came from on the hard drive.

00:15:36.940 --> 00:15:39.710
It picks up the signature.

00:15:39.710 --> 00:15:41.020
Verifies.

00:15:41.420 --> 00:15:43.800
If you happen to be
running a PowerPC program,

00:15:43.870 --> 00:15:46.500
you may know that there's
this thing called Rosetta

00:15:46.530 --> 00:15:48.300
that actually runs your code.

00:15:48.390 --> 00:15:50.540
So it's not the kernel
running your PowerPC program,

00:15:50.540 --> 00:15:54.050
it's something called Translate,
which is the name of the

00:15:54.060 --> 00:15:55.900
program that implements Rosetta.

00:15:56.040 --> 00:16:00.540
So code signing sees it like this:
the kernel actually runs Translate,

00:16:00.650 --> 00:16:03.360
and Translate is code signed and
has a little mark on it saying

00:16:03.460 --> 00:16:07.580
"I'm a code host," and Translate
is managing the PowerPC code.

00:16:07.700 --> 00:16:10.340
So you can see this chain being built.

00:16:10.410 --> 00:16:12.100
Code signing understands this.

00:16:12.140 --> 00:16:15.100
I mean, it's already implemented
in Leopard this way.

00:16:15.170 --> 00:16:17.400
So this is covered territory.

00:16:17.400 --> 00:16:20.780
And if you want to see it any deeper,
it can go deeper if you're unfortunate

00:16:20.780 --> 00:16:25.500
enough to run Windows 2004 still,
which happens to be a CFM application.

00:16:25.560 --> 00:16:27.600
If you don't know what that is,
don't worry about it,

00:16:27.690 --> 00:16:30.190
but it needs a special
interpreter called LaunchCFMApp,

00:16:30.190 --> 00:16:33.180
which just happens to be a PowerPC binary
because it's really a legacy feature,

00:16:33.260 --> 00:16:34.410
so now we're 3D.

00:16:34.760 --> 00:16:36.400
And the machinery still works.

00:16:36.420 --> 00:16:37.440
Code signing can deal with this.

00:16:37.500 --> 00:16:42.180
If you have an interpreter,
there is API that you can

00:16:42.180 --> 00:16:46.530
call to tell the system,
"Hello, I'm managing other code,

00:16:46.530 --> 00:16:50.770
and I'd like to be a code host," and
you'll just fit into the machinery.

00:16:51.210 --> 00:16:52.780
No problem.

00:16:53.720 --> 00:16:57.580
Okay, so code requirements.

00:16:57.590 --> 00:17:02.160
It turns out from the two years that
I've talked about this now that that

00:17:02.160 --> 00:17:05.420
is the sleeper feature of code signing.

00:17:05.600 --> 00:17:08.910
This is the thing that a lot of
people don't even realize is there

00:17:08.910 --> 00:17:13.600
and yet in many ways it's the most
important single part of the machinery.

00:17:13.600 --> 00:17:18.480
A code requirement is sort
of like a little formula,

00:17:18.480 --> 00:17:21.910
a little expression that
contains conditions that a

00:17:21.910 --> 00:17:23.600
program needs to satisfy.

00:17:23.890 --> 00:17:27.380
Things like this is its name
or this is who signed it or,

00:17:27.380 --> 00:17:31.800
you know, there's this key in the
info.p list of the program.

00:17:33.510 --> 00:17:35.940
And you can match against
all kinds of things.

00:17:35.940 --> 00:17:43.920
The really important part to understand
is that a code requirement really defines

00:17:43.920 --> 00:17:46.880
what it means to have code identity.

00:17:46.880 --> 00:17:50.990
When you're talking about, like,
what is mail.app?

00:17:51.080 --> 00:17:52.590
Apple's mail.app.

00:17:52.650 --> 00:17:56.880
Codesigning answers,
it's this requirement right here.

00:17:56.880 --> 00:17:59.580
It's signed by Apple,
and it's called com.apple.mail.

00:17:59.580 --> 00:18:02.000
That's not just an approximation.

00:18:02.000 --> 00:18:03.300
That's not just a good idea.

00:18:03.400 --> 00:18:04.160
That's the rule.

00:18:04.160 --> 00:18:07.540
That's what it means to be mail.app
as far as codesigning is concerned.

00:18:07.540 --> 00:18:13.750
If you have your program,
your program's identity is probably going

00:18:13.750 --> 00:18:17.340
to be defined as it's signed by you,
and it's got whatever

00:18:17.340 --> 00:18:18.410
name you assigned it.

00:18:18.480 --> 00:18:22.290
com.yourcompany.magicalfoodprogram.

00:18:22.300 --> 00:18:28.100
So a code requirement is a
definition of what it means to

00:18:28.100 --> 00:18:30.490
have a particular form of identity,
and it doesn't have to

00:18:30.490 --> 00:18:31.610
be an individual program.

00:18:31.620 --> 00:18:34.220
You can make a code requirement,
and it's a code requirement that says,

00:18:34.450 --> 00:18:37.830
signed by me,
and it'll cover all the programs you will

00:18:37.830 --> 00:18:39.640
ever sign in your life by definition.

00:18:39.640 --> 00:18:44.300
So it's not necessarily the identity
of a particular instance of program.

00:18:44.300 --> 00:18:46.150
It could be a group of programs.

00:18:46.160 --> 00:18:47.840
It could be an open-ended
group of programs.

00:18:47.840 --> 00:18:49.230
It's a very powerful feature.

00:18:51.830 --> 00:18:55.700
Code requirements can be
stored pretty much anywhere.

00:18:55.720 --> 00:18:56.700
There's two forms of it.

00:18:56.700 --> 00:19:00.000
You can write them as text and you
can store them as a binary blob,

00:19:00.090 --> 00:19:04.280
which is just a variable
length binary array of bytes.

00:19:04.390 --> 00:19:05.200
You can stick it anywhere.

00:19:05.200 --> 00:19:07.590
You can stick it in a file,
you can stick it in a database.

00:19:07.590 --> 00:19:09.430
We don't care.

00:19:09.550 --> 00:19:14.090
And there's API for converting
between text and binary.

00:19:15.910 --> 00:19:21.710
And there's a particular class of
requirements that we call internal

00:19:21.710 --> 00:19:25.040
requirements because they're
actually embedded in code signatures.

00:19:25.070 --> 00:19:28.860
They're requirements that
programs have on other programs,

00:19:28.860 --> 00:19:30.750
that code has on other code.

00:19:30.970 --> 00:19:36.450
For example, if you happen to be signing
an interpreted script,

00:19:36.540 --> 00:19:40.400
you can probably imagine that it wouldn't
be good for security if your script

00:19:40.400 --> 00:19:42.640
gets run by some unfriendly interpreter.

00:19:42.860 --> 00:19:47.840
So if you want to secure your script,
you need to say, "I need to be run by an

00:19:47.840 --> 00:19:50.420
interpreter that I trust." Well,
guess what?

00:19:50.440 --> 00:19:51.790
It's code identity again.

00:19:51.910 --> 00:19:56.230
So you can embed an internal
requirement in the signature

00:19:56.230 --> 00:20:02.090
of your script that says,
"This is the identity of the interpreter

00:20:02.090 --> 00:20:05.070
that I'm willing to run with."

00:20:05.440 --> 00:20:08.020
internal requirements.

00:20:08.050 --> 00:20:11.900
And this is the most important
one requirement of them all.

00:20:12.100 --> 00:20:16.540
We call it the designated requirement
because it's a requirement you get

00:20:16.540 --> 00:20:19.530
from a program when you ask it,
"Who are you?

00:20:19.630 --> 00:20:21.420
What are you?"

00:20:21.660 --> 00:20:26.200
You point at signed code,
you get back a requirement.

00:20:26.200 --> 00:20:31.840
The API makes one up if there is no
explicit one specified by the signer,

00:20:31.900 --> 00:20:35.190
or if you know better when you sign,
you can explicitly craft one,

00:20:35.260 --> 00:20:38.980
stick it in, and you'll just get it
back out from the API.

00:20:38.980 --> 00:20:44.650
And you know, the meaning of this API,
the meaning of the designated

00:20:44.650 --> 00:20:48.700
requirement is how -- if
I look at the program later on,

00:20:48.810 --> 00:20:51.200
how can I tell whether it's you?

00:20:51.200 --> 00:20:53.950
It's a designated requirement.

00:20:54.000 --> 00:20:57.590
This is how the program
designates its identity.

00:20:58.310 --> 00:21:04.520
Oh, and, uh, sort of almost incidentally,
designated requirements define what it

00:21:04.520 --> 00:21:08.530
means to be a software update--an update.

00:21:08.660 --> 00:21:12.530
Because think about the
definition of Apple's mail--signed

00:21:12.530 --> 00:21:14.540
by Apple and called mail.

00:21:14.540 --> 00:21:17.530
If Apple makes a new one and ships it,
it's still signed by

00:21:17.600 --> 00:21:19.420
Apple and called mail.

00:21:19.670 --> 00:21:20.960
It's the same program.

00:21:20.990 --> 00:21:24.600
Code signing understands that even
though not a single byte might be

00:21:24.690 --> 00:21:28.150
the same between these two programs,
they are meant to be the same program

00:21:28.220 --> 00:21:30.200
because of the way they're signed.

00:21:30.200 --> 00:21:32.690
So almost incidentally,
sort of as a side effect,

00:21:32.700 --> 00:21:37.310
we solved the software update
problem in terms of tracking what

00:21:37.310 --> 00:21:42.100
it means to be a continuation,
an extension of another program.

00:21:46.700 --> 00:24:22.000
[Transcript missing]

00:24:23.320 --> 00:24:28.600
Oh, and obviously you can combine these
conditions with AND and OR and

00:24:28.600 --> 00:24:31.930
parentheses in the perfectly obvious way.

00:24:34.960 --> 00:24:39.930
If you dig down to the elements
of the requirement language,

00:24:40.510 --> 00:24:44.510
you can match for exact string values.

00:24:44.570 --> 00:24:47.900
And we mean exact,
case sensitive and all.

00:24:47.910 --> 00:24:50.850
You can match for prefixes
and postfixes and substrings.

00:24:51.050 --> 00:24:54.940
There's no regular expression facility
in there right now because we tend

00:24:54.940 --> 00:24:59.900
not to trust the security of regular
expression evaluators all that much.

00:24:59.980 --> 00:25:05.240
And as of Snow Leopard,
you can actually compare for inequality.

00:25:05.240 --> 00:25:08.900
If you use inequality like
greater and less than,

00:25:08.900 --> 00:25:11.900
what you actually get is string
comparison with the numeric option.

00:25:11.900 --> 00:25:14.850
Look it up in the
Core Foundation CFString documentation

00:25:14.850 --> 00:25:19.330
so that if you're comparing,
for example, version strings like 7.4.3,

00:25:19.550 --> 00:25:20.900
you actually get what you want.

00:25:20.900 --> 00:25:25.390
You get the numbers sorted right.

00:25:26.840 --> 00:25:30.430
Okay, if you want to play
around with requirements,

00:25:30.430 --> 00:25:32.650
either because you're just
curious or because you're trying

00:25:32.650 --> 00:25:35.530
to make up just the right one,
there's this little utility

00:25:35.670 --> 00:25:39.430
Swiss Army Knife program called
CSREC that lets you convert

00:25:39.430 --> 00:25:44.080
between the text form and the
binary form of requirements.

00:25:44.080 --> 00:25:49.420
You basically can pass it either and
you can ask for either form as output.

00:25:49.420 --> 00:25:52.020
You can actually ask it to
convert from text to text,

00:25:52.320 --> 00:25:55.320
which is useful because it
internally compiles it and then

00:25:55.800 --> 00:25:57.560
uncompiles it back to text.

00:25:57.560 --> 00:26:00.890
So it reads you back
what it thinks you said,

00:26:01.090 --> 00:26:04.790
which is useful if you're a
little bit wondering whether

00:26:04.790 --> 00:26:06.850
you're saying it the right way.

00:26:06.860 --> 00:26:09.040
So that's CSREC.

00:26:09.040 --> 00:26:13.240
And if you're actually trying to
evaluate a requirement to see if

00:26:13.240 --> 00:26:17.460
it applies properly to a program
on disk or to a running program,

00:26:17.640 --> 00:26:21.080
there is the dash capital
R option to code sign.

00:26:21.080 --> 00:26:24.020
You can ask code sign for a
verification and pass any requirement.

00:26:24.020 --> 00:26:28.360
You like it and it will tell you whether
the program is intact and whether it

00:26:28.360 --> 00:26:31.880
satisfies the requirement you passed.

00:26:34.470 --> 00:26:41.580
So the whole thing is based on signing
your code with digital identities.

00:26:41.580 --> 00:26:45.500
And, you know, I could do an hour on what
digital identities are,

00:26:45.500 --> 00:26:50.240
but thank God I don't have to
because Ken MacLeod over there

00:26:50.240 --> 00:26:54.840
has an entire session on digital
identities and X.509 certificates.

00:26:54.890 --> 00:26:58.670
So if this is news for you,
you probably want to go to his session

00:26:59.140 --> 00:27:03.130
where he will explain what those are,
how you make them in detail,

00:27:03.190 --> 00:27:04.520
how you manage them.

00:27:04.520 --> 00:27:06.840
And this isn't code signing specific.

00:27:06.840 --> 00:27:09.440
Digital identities are used
for all kinds of stuff.

00:27:09.440 --> 00:27:11.280
Any time you use SSL, you use them.

00:27:11.280 --> 00:27:12.960
Any time you sign email, you use them.

00:27:12.960 --> 00:27:14.400
It's the same machinery.

00:27:14.440 --> 00:27:16.360
As a matter of fact,
it really is the same machinery.

00:27:16.360 --> 00:27:19.720
We're using the same cryptographic
libraries for making code signatures

00:27:19.720 --> 00:27:23.240
as we're using to sign email--CMS.

00:27:23.270 --> 00:27:24.110
So if digital identities are
used for all kinds of things,

00:27:24.110 --> 00:27:24.150
they're not necessarily
used for the same purpose.

00:27:24.240 --> 00:27:24.240
So if this is news for you,
you probably want to go to his session

00:27:24.240 --> 00:27:24.240
where he will explain what those are,
how you make them in detail,

00:27:24.240 --> 00:27:24.240
how you manage them,
and this isn't code signing specific.

00:27:24.240 --> 00:27:24.240
Digital identities are used
for all kinds of stuff.

00:27:24.310 --> 00:27:26.440
digital identities are
a big mystery for you.

00:27:26.650 --> 00:27:30.300
Can session, I think,
at five is definitely

00:27:30.300 --> 00:27:30.970
where you want to go.

00:27:30.990 --> 00:27:33.570
So for the rest of you who
pretty much think you know

00:27:33.840 --> 00:27:37.060
what a digital identity is,
let me just run through this.

00:27:37.060 --> 00:27:41.930
Anything that's marked in as in the
extended key usage as can code sign

00:27:42.050 --> 00:27:44.830
is okay for making code signatures.

00:27:44.830 --> 00:27:48.340
There is a little utility inside
of keychain access to make

00:27:48.340 --> 00:27:50.420
these identities from scratch.

00:27:50.420 --> 00:27:53.040
It's called the certificate assistant.

00:27:53.130 --> 00:27:56.490
Doesn't call you anything,
and in 30 seconds you

00:27:56.490 --> 00:28:01.560
can have a perfectly good
tested identity for signing.

00:28:01.950 --> 00:28:06.010
If you are not planning to
turn into a large enterprise,

00:28:06.110 --> 00:28:08.520
that's pretty much all you need.

00:28:08.520 --> 00:28:13.120
If you are working for a large enterprise
or you're planning to turn into one,

00:28:13.120 --> 00:28:16.430
you want to go a little bit further
down the road and perhaps make yourself

00:28:16.430 --> 00:28:20.300
your own certificate authority,
which in the certificate system

00:28:20.440 --> 00:28:24.750
takes maybe five minutes,
which is a lot better than the five

00:28:24.750 --> 00:28:28.300
hours of OpenSSL you probably need.

00:28:28.300 --> 00:28:30.660
But anyway, you can make your own.

00:28:30.660 --> 00:28:33.170
Or you can go out to
various companies out there,

00:28:33.170 --> 00:28:36.270
commercial certificate authorities,
and you can buy a code

00:28:36.350 --> 00:28:37.880
signing certificate from them.

00:28:38.060 --> 00:28:38.900
That's fine with us too.

00:28:38.950 --> 00:28:42.760
As long as they're properly structured,
they'll work.

00:28:42.760 --> 00:28:46.500
If you happen to have an
identity called Authenticode,

00:28:46.540 --> 00:28:50.980
that's something that Microsoft invented
as a trademark a while ago,

00:28:50.980 --> 00:28:54.780
if you have an Authenticode identity,
it'll work for code signing because

00:28:54.780 --> 00:28:56.350
it's following the same standards.

00:28:56.400 --> 00:28:59.900
It's a box standard
RFC internet standard.

00:28:59.900 --> 00:29:00.660
Okay.

00:29:00.660 --> 00:29:02.120
Um...

00:29:02.490 --> 00:29:08.840
In the special case of the iPhone,
Apple issues identities as part of

00:29:08.840 --> 00:29:13.900
the way we're controlling what gets
installed where and who trusts who.

00:29:14.000 --> 00:29:18.260
So if you are developing for the iPhone,
you are going to use

00:29:18.280 --> 00:29:19.890
Apple-issued identities.

00:29:19.970 --> 00:29:22.040
You don't get a choice there.

00:29:22.930 --> 00:29:25.330
No matter what kind of
identity you're using,

00:29:25.490 --> 00:29:28.670
you end up storing them in a
keychain because that's the

00:29:28.670 --> 00:29:29.740
way it works on Mac OS X.

00:29:29.800 --> 00:29:33.800
If you get it from somewhere else,
you have to import it into your keychain.

00:29:33.800 --> 00:29:36.800
If you generate it in your keychain
and you want to send it somewhere else,

00:29:36.800 --> 00:29:38.800
you have to export it from your keychain.

00:29:38.800 --> 00:29:42.800
Ken will explain all of these
things in beautiful detail.

00:29:42.800 --> 00:29:46.890
If you just need a hint,
if somebody sends you something that's

00:29:46.890 --> 00:29:49.600
supposed to contain that identity,
you're looking for

00:29:49.600 --> 00:29:50.800
something called PKCS12.

00:29:50.860 --> 00:29:54.090
That's the name of the standard
file that's usually used

00:29:54.090 --> 00:29:55.750
to transfer these things.

00:29:58.970 --> 00:30:04.270
Okay, this is another question that came
up a lot in the last two years,

00:30:04.270 --> 00:30:07.530
so I'm dedicating a slide to it.

00:30:08.120 --> 00:30:14.720
People talk a lot about code signatures
being trusted by a particular system,

00:30:14.720 --> 00:30:19.500
like, you know,
"Does this system trust my signature?"

00:30:19.590 --> 00:30:24.960
And the question usually is mistaken,
but let me tell you why.

00:30:25.050 --> 00:30:29.970
There's a feature in Mac OS X--it's
been there for a while,

00:30:30.230 --> 00:30:35.000
but it got revamped for
Leopard--it's called Trust Settings.

00:30:35.230 --> 00:30:39.520
What Trust Settings does is,
for any certificate, but particularly for

00:30:39.950 --> 00:30:44.000
Anchor root certificates,
it attaches a marker saying

00:30:44.000 --> 00:30:48.000
whether the system trusts that
certificate for a particular purpose.

00:30:48.000 --> 00:30:50.800
You can actually--in the simplest case,
you can just say,

00:30:50.800 --> 00:30:53.330
"I trust this thing." You know,
"It's from Apple.

00:30:53.330 --> 00:30:54.000
I trust it." Cool.

00:30:54.000 --> 00:30:56.830
Or you can say, "It's from Adobe.

00:30:56.830 --> 00:30:59.000
I'll trust it." Okay.

00:30:59.920 --> 00:31:01.240
But you can also be more specific.

00:31:01.240 --> 00:31:05.860
You can say, I trust it for the purposes
of SSL server authentication.

00:31:06.020 --> 00:31:12.470
So you don't have to-- if some company,
some bank is giving you a particular

00:31:12.800 --> 00:31:16.800
certificate and saying this is how you
can tell that we're not being spoofed,

00:31:16.800 --> 00:31:19.850
you can put a trust setting
marker on it and say,

00:31:19.850 --> 00:31:22.460
trust this for SSL,
but don't trust it for

00:31:22.460 --> 00:31:25.400
email or code signing,
because that would be excessive.

00:31:25.500 --> 00:31:27.700
So anyway,
that's a mechanism for putting markers

00:31:27.760 --> 00:31:32.070
on certificates to say whether the system
trusts them for a particular purpose

00:31:32.070 --> 00:31:33.870
or to say whether a user trusts them.

00:31:33.970 --> 00:31:35.860
There are user-specific
versions of those,

00:31:35.940 --> 00:31:36.280
too.

00:31:36.430 --> 00:31:40.550
And that's a great feature,
and it does not apply to code signing,

00:31:40.550 --> 00:31:45.490
usually, at all, even though that has
the word trust in it.

00:31:46.130 --> 00:31:51.740
Because code signing, for the most part,
cares about continuity of identity

00:31:51.780 --> 00:31:58.980
rather than origin of identity.

00:31:58.990 --> 00:31:58.990
Now those are big words,
but this matters.

00:32:00.350 --> 00:32:06.380
Usually, you only care whether a program
is the same as the one was before.

00:32:06.380 --> 00:32:09.380
Like, is the mail that's trying to
get a keychain password the

00:32:09.550 --> 00:32:11.280
same as the mail that stored it?

00:32:11.280 --> 00:32:15.250
Or is the program that's trying to
retrieve the .mac password one that's

00:32:15.370 --> 00:32:19.220
in the group of programs that's
allowed to access the .mac password?

00:32:19.300 --> 00:32:23.340
This does not, by itself,
depend on who signed the program

00:32:23.340 --> 00:32:25.300
or whether you like them.

00:32:25.320 --> 00:32:27.290
It's about, is it the same program?

00:32:27.300 --> 00:32:30.430
And for that,
we don't need to consult the

00:32:30.490 --> 00:32:33.270
System Trust Settings database.

00:32:33.270 --> 00:32:37.300
We just care whether it's still the same.

00:32:37.300 --> 00:32:41.750
So, code signing by itself,
at its core level, does not use the

00:32:41.750 --> 00:32:44.280
Trust Settings database at all.

00:32:44.290 --> 00:32:47.300
It doesn't mind if a certificate
is trusted by the system.

00:32:47.300 --> 00:32:49.120
It just doesn't care.

00:32:49.350 --> 00:32:54.420
Now, there is an element in the
requirement language that says,

00:32:54.420 --> 00:32:57.420
"And the certificate in the
signature has to be trusted by

00:32:57.420 --> 00:33:00.740
the system." If you put that in,
or if somebody else puts that in,

00:33:00.740 --> 00:33:03.280
then it matters because
the requirement says so.

00:33:03.300 --> 00:33:07.090
But it's important to understand
that this code signing infrastructure

00:33:07.090 --> 00:33:09.300
does not impose any such requirement.

00:33:09.300 --> 00:33:14.020
It's a particular code requirement
that may or may not say so.

00:33:16.650 --> 00:33:20.640
So most of the time,
designated requirements just work.

00:33:20.640 --> 00:33:20.860
Good.

00:33:21.050 --> 00:33:24.580
Because those of you who are signing your
program probably didn't even think about

00:33:24.580 --> 00:33:27.180
whether you needed to do anything there.

00:33:27.500 --> 00:33:32.900
[Transcript missing]

00:33:33.240 --> 00:33:36.350
types of certificate
chains we know what to do.

00:33:36.670 --> 00:33:39.440
If you're making yourself
your own signing identity,

00:33:39.640 --> 00:33:41.900
just a self-signed certificate,
it's easy.

00:33:42.040 --> 00:33:44.080
That certificate,
it's the only one you got.

00:33:44.140 --> 00:33:49.350
If you make your own CA and issue
yourself signing certificates

00:33:49.350 --> 00:33:52.260
and then you sign your code,
you'll be OK, too,

00:33:52.310 --> 00:33:57.020
as long as you put your name unchanged
into all of the organization fields.

00:33:57.170 --> 00:33:57.780
So here's a hint.

00:33:57.840 --> 00:34:00.450
If you build your own CA for
code signing purposes,

00:34:00.550 --> 00:34:04.100
put in an organization field
into all the certificates and

00:34:04.260 --> 00:34:05.270
give them all the same name.

00:34:05.330 --> 00:34:06.260
Doesn't matter what it is.

00:34:06.410 --> 00:34:09.820
It's your company name, usually,
in some legally acceptable form.

00:34:09.860 --> 00:34:13.540
But make them all be the same,
because that's how the designated

00:34:13.670 --> 00:34:15.800
requirement generator figures this out.

00:34:15.800 --> 00:34:18.190
It starts at the leaf and kind of goes,
those all seem to come

00:34:18.190 --> 00:34:19.140
from the same company.

00:34:19.140 --> 00:34:21.860
I'll just go all the way
to the root and use that.

00:34:21.900 --> 00:34:26.560
If you change it, it assumes,
because it's trying to be conservative,

00:34:26.560 --> 00:34:28.860
that going up the chain-- oh,
it changed here.

00:34:28.860 --> 00:34:30.310
I guess they bought
that from someone else,

00:34:30.340 --> 00:34:30.820
so we'll stop.

00:34:30.820 --> 00:34:32.270
here.

00:34:32.500 --> 00:34:35.450
And that's also the point where
you may have to explicitly write

00:34:35.450 --> 00:34:37.220
your own designated requirement.

00:34:37.430 --> 00:34:40.940
If you buy a signing
certificate from a company,

00:34:41.040 --> 00:34:44.400
we have no clue what that
company's policies are.

00:34:44.530 --> 00:34:46.600
Particularly,
we have no idea what they do when

00:34:46.630 --> 00:34:48.400
they reissue your certificates.

00:34:48.400 --> 00:34:50.880
These things expire and
then you get a new one,

00:34:50.960 --> 00:34:52.310
of course you pay again.

00:34:52.390 --> 00:34:53.400
Duh.

00:34:53.400 --> 00:34:57.400
So, since we don't know how
they reissue certificates,

00:34:57.410 --> 00:34:59.340
we don't know what they
change when they do that,

00:34:59.410 --> 00:35:02.640
we can't automatically
write a requirement that

00:35:02.980 --> 00:35:04.290
says what that policy is.

00:35:04.400 --> 00:35:07.430
So,
in the case where you're buying yourself

00:35:07.430 --> 00:35:11.270
a certificate from someone else,
you need to write one.

00:35:11.510 --> 00:35:15.920
You can either do that yourself or
you could actually try to call up

00:35:15.920 --> 00:35:18.400
your vendor and ask them what to use.

00:35:18.400 --> 00:35:21.880
I have no idea whether they
can give you an answer,

00:35:21.980 --> 00:35:23.280
but they should.

00:35:23.400 --> 00:35:24.750
Thank you.

00:35:25.040 --> 00:35:28.720
The general process is look at
the certificate chain that you're

00:35:28.720 --> 00:35:32.610
getting when you sign with one of
those certificates issued from a

00:35:32.670 --> 00:35:36.880
company that has their own policies,
and then try to write a code

00:35:36.880 --> 00:35:41.590
requirement that basically nails down
the parts that you know won't change.

00:35:41.670 --> 00:35:45.950
Like if they're always using the
same subject common name for you,

00:35:46.130 --> 00:35:51.000
then you want to put the subject common
name of that certificate is this.

00:35:51.030 --> 00:35:54.240
Or if there is a particular
marker extension that they

00:35:54.260 --> 00:35:56.580
put into an intermediate,
you want to say that.

00:35:56.580 --> 00:36:01.570
In the demo in a little bit,
I'll show you one example of that.

00:36:03.370 --> 00:36:07.200
Another little incidental thing:
when you're signing code,

00:36:07.200 --> 00:36:11.140
one of the arguments that you can
pass into the signing operation is

00:36:11.140 --> 00:36:16.880
called the "signing flags," which
you can ignore for the most part.

00:36:16.960 --> 00:36:19.550
If you are making a code host,
there's a flag that says "I'm a

00:36:19.580 --> 00:36:21.200
code host" that you need to set.

00:36:21.200 --> 00:36:23.900
But other than that,
if you don't pass any flags,

00:36:23.900 --> 00:36:26.200
you'll just get the default behavior.

00:36:26.200 --> 00:36:30.380
There are two flags that are interesting,
though, if you want to achieve

00:36:30.380 --> 00:36:32.190
a particular effect.

00:36:32.460 --> 00:36:37.200
There's a "force_kill" flag that
if you pass it during signing,

00:36:37.200 --> 00:36:42.740
sets a flag in the signature
that immediately causes the

00:36:42.740 --> 00:36:46.200
system to kill your program
if it ever loses its identity.

00:36:46.200 --> 00:36:48.200
Oh yeah, that's harsh.

00:36:48.200 --> 00:36:52.850
But sometimes it's exactly what you want,
because by exclusion, it means as long as

00:36:52.850 --> 00:36:55.200
your program is running,
it's valid.

00:36:55.200 --> 00:36:57.180
And sometimes that's kind of handy.

00:36:57.180 --> 00:37:00.720
It means you never have to worry
about "have I been hacked?" Well,

00:37:01.000 --> 00:37:04.240
if you have been hacked,
and the system actually

00:37:04.240 --> 00:37:05.860
managed to detect it,
you'd be dead.

00:37:05.890 --> 00:37:07.120
So you haven't been hacked.

00:37:07.520 --> 00:37:09.190
Case closed.

00:37:09.500 --> 00:37:12.640
There is a slightly milder
version of this called the "hard

00:37:12.640 --> 00:37:15.080
flag," and you can force that on,
too.

00:37:15.250 --> 00:37:24.200
The meaning of the hard flag is if I ever
have a choice between getting a resource,

00:37:24.200 --> 00:37:24.200
like loading a resource
file or paging in a page,

00:37:24.200 --> 00:37:28.330
or loading a library,
and that makes me invalid,

00:37:28.330 --> 00:37:31.200
because we can't trust the
thing we're going to load,

00:37:31.200 --> 00:37:34.090
or just not getting this
thing but staying valid,

00:37:34.220 --> 00:37:36.200
I'd rather not get this thing.

00:37:36.200 --> 00:37:40.200
So if you set the hard flag on a program,
it may be told by the system

00:37:40.200 --> 00:37:43.200
that you can't page in this page,
you can't read this resource,

00:37:43.200 --> 00:37:46.190
you can't load this library,
but you'll stay valid.

00:37:46.200 --> 00:37:49.740
If the flag is off,
the default behavior is, "Here,

00:37:49.740 --> 00:37:53.590
have your library," and
you just got invalidated.

00:37:55.440 --> 00:37:57.590
Okay, API.

00:37:57.640 --> 00:38:00.720
The API itself is at least
a year and a half old,

00:38:00.870 --> 00:38:05.300
but until a month ago
it was private to Apple.

00:38:05.420 --> 00:38:11.040
We've just managed to publish, I think,
about 60% of it.

00:38:11.070 --> 00:38:14.980
And so I'm going to give you a quick
run-through just to give you a guide to

00:38:14.980 --> 00:38:19.460
what to look for while you're reading
the header files and trying out things.

00:38:20.520 --> 00:38:23.370
The API objects are
core foundation objects.

00:38:23.650 --> 00:38:27.040
They really are core foundation objects,
the genuine article.

00:38:27.220 --> 00:38:30.820
So when you get them,
you can use them for as long as you

00:38:30.820 --> 00:38:32.440
want and then you CF release them.

00:38:32.440 --> 00:38:36.810
You can stick them into CFArrays and
CFDictionary's and CF sets

00:38:36.810 --> 00:38:38.740
if you absolutely have to.

00:38:39.000 --> 00:38:42.230
You can treat them like core
foundation objects in all

00:38:42.230 --> 00:38:45.230
respects because they really,
really are.

00:38:45.870 --> 00:38:50.420
These are the three types:
a SecCodeRef is a

00:38:50.500 --> 00:38:52.560
reference to running code.

00:38:52.560 --> 00:38:55.560
So that's the ones you usually
are going to throw around.

00:38:55.570 --> 00:39:00.240
A SecStaticCode is a reference
to code stored on disk.

00:39:00.240 --> 00:39:02.790
That's usually a single tool or a bundle.

00:39:03.030 --> 00:39:06.720
And a SecRequirement
is a code requirement.

00:39:07.560 --> 00:39:12.160
So in order to do validation,
which is the reason for

00:39:12.160 --> 00:39:14.790
existence for this whole thing,
where you're checking that

00:39:14.970 --> 00:39:17.770
a program can be accessed,
that it has integrity,

00:39:17.770 --> 00:39:21.220
and that it conforms with a requirement,
that's the call you're going to make.

00:39:21.220 --> 00:39:22.940
It's really quite innocent looking.

00:39:22.940 --> 00:39:26.380
Basically, you pass a code reference
and a requirement reference.

00:39:26.400 --> 00:39:30.260
All of the APIs have a flag argument,
and usually you just pass

00:39:30.260 --> 00:39:33.140
kseccs default flags,
which says I'll take

00:39:33.190 --> 00:39:35.280
the default thank you.

00:39:35.350 --> 00:39:39.870
There are API-specific flags you
can pass into change behavior,

00:39:39.870 --> 00:39:43.290
and if we ever need to do the
backward compatible thing,

00:39:43.340 --> 00:39:45.320
that's how we'll do it.

00:39:46.810 --> 00:39:50.350
These are a couple of
errors that you might find.

00:39:50.450 --> 00:39:54.990
There's this list of 50 errors
that code signing can return to

00:39:54.990 --> 00:39:56.700
you telling you what went wrong.

00:39:56.700 --> 00:40:00.050
And it can also return to you all
kinds of other OS status error

00:40:00.050 --> 00:40:01.700
codes from other subsystems.

00:40:01.750 --> 00:40:04.700
But these are the ones you're
most likely going to find.

00:40:04.820 --> 00:40:07.580
Error status 'unsigned'
means this wasn't signed,

00:40:07.580 --> 00:40:08.660
so I can tell you whether it's valid.

00:40:08.760 --> 00:40:10.650
Error status 'failed' means it's broken.

00:40:10.790 --> 00:40:13.910
It's signed, but there's something
wrong with the signature,

00:40:13.910 --> 00:40:16.700
and so you don't want to trust it.

00:40:16.700 --> 00:40:19.930
Error status 'failed' means
that the signature is fine,

00:40:19.930 --> 00:40:22.420
the program has integrity,
everything's cool,

00:40:22.420 --> 00:40:25.700
except the requirement you passed in
doesn't actually match the program.

00:40:25.700 --> 00:40:29.700
So you probably don't want to accept it.

00:40:29.700 --> 00:40:34.700
Okay, so that means you need a code
reference and a requirement reference.

00:40:34.700 --> 00:40:36.690
Well, how do you get a code reference?

00:40:36.700 --> 00:40:40.840
There is one API function that pretty
much does it for you all the time,

00:40:40.840 --> 00:40:43.520
and since we're being
Core Foundation-like,

00:40:43.700 --> 00:40:44.660
we give it a long name.

00:40:44.700 --> 00:40:50.700
Basically,
you pass it a CFDictionary of attributes.

00:40:50.700 --> 00:40:53.700
And, for example,
if you're after a process,

00:40:53.700 --> 00:40:58.010
you would be passing in a dictionary
with one entry that says 'the pit is

00:40:58.010 --> 00:41:01.690
this'. There's other possibilities,
of course.

00:41:01.870 --> 00:41:05.700
You can either specify a
particular code host and say,

00:41:05.700 --> 00:41:09.790
'I'm only looking for guests of this
host', but if you pass null for the host,

00:41:09.820 --> 00:41:13.700
you'll just basically start at the
kernel and you'll find what you can

00:41:13.700 --> 00:41:15.700
with the attributes that you passed in.

00:41:15.700 --> 00:41:17.700
And that's almost always what you do.

00:41:17.720 --> 00:41:20.640
You just pass null for the host,
you pass in everything

00:41:20.640 --> 00:41:22.640
you know about the code,
starting with the pit,

00:41:22.690 --> 00:41:24.640
and you let the system figure it out.

00:41:24.740 --> 00:41:28.050
You get back a set code ref,
or if it doesn't work,

00:41:28.050 --> 00:41:29.860
you get back an error code.

00:41:30.800 --> 00:43:15.900
[Transcript missing]

00:43:18.170 --> 00:43:22.420
And finally,
we have the Omnibus Information Call.

00:43:22.420 --> 00:43:26.140
You pass a bunch of flags,
we'll give you a CFDictionary with

00:43:26.140 --> 00:43:31.660
more than you ever wanted to
know about a code signature.

00:43:32.030 --> 00:43:35.440
Some of the things in the
information dictionary you're

00:43:35.440 --> 00:43:38.900
getting back are actually live
API objects from other subsystems.

00:43:39.090 --> 00:43:42.090
Like, one of them is a SecTrustDraft.

00:43:42.170 --> 00:43:44.640
If you know what that is
or you want to look it up,

00:43:44.640 --> 00:43:50.410
this is the actual validation object
that is used internally to validate the

00:43:50.480 --> 00:43:51.900
cryptographic part of the signature.

00:43:51.940 --> 00:43:56.860
So if you are maximum amount of
extra information out of the system,

00:43:57.070 --> 00:44:00.090
you can then in turn apply
information calls to that

00:44:00.090 --> 00:44:01.900
and get even more stuff out.

00:44:01.900 --> 00:44:07.730
Okay,
let's take a break and do some demo.

00:44:09.050 --> 00:44:11.230
I'm still demoing with
a command line tool.

00:44:11.230 --> 00:44:12.410
I hope you don't mind.

00:44:12.450 --> 00:44:14.460
It's just a lot easier.

00:44:14.610 --> 00:44:21.940
So here's a little program that basically
doesn't do anything except it can

00:44:21.940 --> 00:44:25.760
create a keychain item and retrieve it.

00:44:25.760 --> 00:44:29.280
So we have something that we can
actually apply code signing to.

00:44:29.490 --> 00:44:34.600
So for those of you who aren't
actually signing your programs yet,

00:44:34.600 --> 00:44:37.730
let's just explore what
happens if you don't sign it.

00:44:40.800 --> 00:44:48.300
So here is the tool and let's
say we want a test Keychain item

00:44:48.320 --> 00:44:54.870
which creates a Keychain item
called test in the Keychain and

00:44:57.820 --> 00:45:00.420
If we retrieve it again,
it comes back out because

00:45:00.420 --> 00:45:03.320
when you make a Keychain item,
the application that created

00:45:03.320 --> 00:45:04.470
it is allowed to access it.

00:45:04.510 --> 00:45:06.300
Everything's fine, right?

00:45:06.300 --> 00:45:12.930
And then you update your program.

00:45:12.930 --> 00:45:15.460
And now it's version 1.1.

00:45:16.940 --> 00:45:23.800
And you go and you run the program
again and you get this dialog which

00:45:23.800 --> 00:45:27.550
you're all painfully familiar with.

00:45:27.950 --> 00:45:31.060
And the dialogue really,
if you read between the lines, says,

00:45:31.140 --> 00:45:35.140
"Okay, there's a different thing here,
but it kind of looks like it

00:45:35.440 --> 00:45:39.000
wants to be the previous one,
so tell me, is this the same program?

00:45:39.000 --> 00:45:41.740
Do you want me to treat
this like the same program,

00:45:41.810 --> 00:45:44.670
or what do you want to do?"
And it's annoying because,

00:45:44.670 --> 00:45:48.280
of course, almost always you want to say,
"Yes, of course it's the same program.

00:45:48.280 --> 00:45:55.080
I just built it." And, of course,
then perhaps once in a blue moon,

00:45:55.080 --> 00:45:58.200
it's not because some hacker
sent you a hacked version.

00:45:58.240 --> 00:45:59.980
And how is the user supposed to know?

00:45:59.990 --> 00:46:02.150
It's not a good situation.

00:46:02.380 --> 00:46:04.630
So what do you do?

00:46:04.730 --> 00:46:08.680
You can hand sign it,
but with the awesome power of Xcode,

00:46:08.810 --> 00:46:10.880
you can do better than that.

00:46:10.910 --> 00:46:12.980
You can actually tell Xcode to sign.

00:46:13.020 --> 00:46:14.620
Ah, but what do you sign with?

00:46:14.710 --> 00:46:15.050
Right.

00:46:15.290 --> 00:46:16.710
Let's make an identity.

00:46:16.860 --> 00:46:18.820
So here's Keychain Access,
which you'll find in

00:46:18.820 --> 00:46:20.140
the application utility.

00:46:20.140 --> 00:46:22.150
So you'll find the key
to the key directory,

00:46:22.150 --> 00:46:23.930
and there is a certificate assistant.

00:46:24.170 --> 00:46:29.140
And you can ask the certificate
assistant to make you a certificate.

00:46:29.180 --> 00:46:32.220
The only trick you need here is
you need to check the "Let me

00:46:32.220 --> 00:46:34.640
override the defaults" checkbox.

00:46:34.840 --> 00:46:37.640
And, yes,
this just warns you that you probably

00:46:37.810 --> 00:46:39.640
should know what you're doing.

00:46:39.870 --> 00:46:43.040
And you can ask for a
certificate type code signing.

00:46:43.090 --> 00:46:45.740
And then you can just keep on going.

00:46:45.920 --> 00:46:48.670
It knows what the other defaults are.

00:46:49.030 --> 00:46:52.180
And before... you know it.

00:46:53.070 --> 00:46:55.360
You have a signing
identity in your Keychain.

00:46:55.360 --> 00:46:58.240
Here's test the Keychain ID we just made.

00:46:58.240 --> 00:47:04.520
And a signing identity looks like
a private key and a certificate.

00:47:04.520 --> 00:47:07.720
Keychain Assistant makes you the
public key just in case you care.

00:47:07.810 --> 00:47:10.820
So now we have a signing
identity called Demo.

00:47:10.820 --> 00:47:18.080
So let's go to Keychain Access, Xcode,
and

00:47:18.500 --> 00:47:21.210
If you have the latest version of Xcode,
you'll notice there's this new

00:47:21.210 --> 00:47:23.160
section here called Code Signing.

00:47:23.390 --> 00:47:26.910
All you really have to do is...

00:47:29.150 --> 00:47:32.780
put in the name of the signing identity.

00:47:32.830 --> 00:47:34.280
Demo.

00:47:35.470 --> 00:47:40.510
And then build your program.

00:47:40.510 --> 00:47:40.510
Let's--better safe than
sorry--clean it first.

00:47:46.100 --> 00:47:48.720
OK, what happened here?

00:47:48.720 --> 00:47:52.020
Internally,
Xcode is running the code sign command.

00:47:52.020 --> 00:47:55.840
And the code sign command has
no particular access to the

00:47:55.840 --> 00:47:57.800
identity that you're signing with.

00:47:57.830 --> 00:47:59.440
So the system gives you this dialogue.

00:47:59.440 --> 00:48:01.680
And this dialogue is not superfluous.

00:48:01.680 --> 00:48:02.920
This is a really good dialogue.

00:48:03.030 --> 00:48:05.940
It says,
do you really want the code sign command

00:48:05.940 --> 00:48:08.340
to have access to the signing identity?

00:48:08.340 --> 00:48:10.720
And you can either say, yeah, allow,
which means you'll get

00:48:10.720 --> 00:48:11.580
asked the next time.

00:48:11.580 --> 00:48:14.820
Or you can say, always allow,
which is easier in the long run

00:48:14.820 --> 00:48:16.800
if you're just testing around.

00:48:16.800 --> 00:48:22.160
OK, so now we've signed the program,
which you can verify by asking for

00:48:22.160 --> 00:48:25.420
a verification of the Frop tool.

00:48:25.420 --> 00:48:27.510
Code sign is a typical Unix command.

00:48:27.520 --> 00:48:30.800
So by default, if everything's fine,
it doesn't say anything.

00:48:31.040 --> 00:48:34.930
But if you add more verbose flags,
it will actually tell you

00:48:34.930 --> 00:48:36.600
that everything's fine.

00:48:36.610 --> 00:48:38.320
So let's run it again.

00:48:38.360 --> 00:48:40.240
So here.

00:48:40.450 --> 00:48:44.360
You get this dialogue because what
you've done now is you're trying

00:48:44.360 --> 00:48:48.800
to access a Keychain item that
was made by an unsigned program,

00:48:48.970 --> 00:48:50.300
your old FROP tool.

00:48:50.400 --> 00:48:55.000
Now there's a signed version and
since we don't yet know whether those

00:48:55.000 --> 00:48:59.240
two are supposed to be the same,
we have to ask one more time.

00:48:59.300 --> 00:49:03.300
So we're saying yes and
now everything's fine.

00:49:03.520 --> 00:49:06.300
And this time,
if we are changing the program,

00:49:06.300 --> 00:49:10.310
we're going to version 2.0.

00:49:18.040 --> 00:49:22.080
No dialogue,
because now we use code signing.

00:49:22.080 --> 00:49:25.470
And now we understand--the system
understands without having to

00:49:25.470 --> 00:49:28.760
guess or without having to make
any dangerous assumptions that

00:49:28.760 --> 00:49:30.380
it's really the same program.

00:49:30.650 --> 00:49:35.580
Because you said so.

00:49:35.580 --> 00:49:36.810
You said it's PropTool and
it's signed by the same guy.

00:49:38.470 --> 00:49:39.310
Let's see.

00:49:39.420 --> 00:49:42.890
We are, as always,
a little bit behind on our schedule.

00:49:43.140 --> 00:49:48.350
So let me just show you a couple
of potentially useful things if

00:49:48.350 --> 00:49:51.000
you're working with keychains.

00:49:51.000 --> 00:49:51.000
If you are--

00:49:51.320 --> 00:49:54.300
Looking at the access control
list of a Keychain item,

00:49:54.300 --> 00:49:57.090
you'll see there are two
entries for the tool now.

00:49:57.200 --> 00:50:02.260
One is the old one that applied
to the unsigned program and

00:50:02.380 --> 00:50:03.200
the other one is the new one.

00:50:03.200 --> 00:50:05.050
How can you tell the difference?

00:50:05.230 --> 00:50:09.000
Actually, usually you can't,
but there is an undocumented little

00:50:09.330 --> 00:50:12.200
preference which you can set.

00:50:12.200 --> 00:50:15.330
It's called Distinguished Legacy ACLs.

00:50:15.330 --> 00:50:17.200
Yeah, put the spaces and all
in there like that.

00:50:17.200 --> 00:50:19.950
If you set that to true,
then Legacy ACLs,

00:50:19.950 --> 00:50:23.200
the ones for unsigned programs,
turn italic.

00:50:23.200 --> 00:50:25.200
So you can tell the difference.

00:50:25.200 --> 00:50:29.130
I don't think that's documented anywhere,
so bonus.

00:50:29.230 --> 00:50:31.200
Actually, I'll give you a better bonus.

00:50:31.230 --> 00:50:36.430
If you select a Keychain ACL entry
that's for a signed program and

00:50:36.680 --> 00:50:40.280
you hold down the Option key
and you hit the plus button,

00:50:40.300 --> 00:50:44.200
it will actually show you the code's
requirement that's hidden in there.

00:50:44.200 --> 00:50:47.200
So this is what really happens.

00:50:47.200 --> 00:50:52.100
When the system is trying to figure
out whether FropTool is supposed to

00:50:52.160 --> 00:50:54.200
get access to this Keychain item.

00:50:54.200 --> 00:50:56.150
This is the requirement.

00:50:56.210 --> 00:51:00.270
It says this is the identifier
and the leaf anchor,

00:51:00.350 --> 00:51:02.200
which since it's a
self-signed certificate,

00:51:02.240 --> 00:51:05.160
it's the same as the root anchor,
has this hash.

00:51:05.220 --> 00:51:07.180
We don't store the whole certificate.

00:51:07.200 --> 00:51:09.190
Certificates are pretty big,
like a kilobyte.

00:51:09.250 --> 00:51:11.200
Instead, we store the hash of it.

00:51:11.200 --> 00:51:14.980
And if you actually want to,
you can edit this and hit

00:51:14.980 --> 00:51:17.200
OK inside of Keychain Access.

00:51:17.200 --> 00:51:20.790
and basically change it to
whatever you want it to be.

00:51:21.810 --> 00:51:26.810
And, oh yeah,
we were talking about how to

00:51:26.810 --> 00:51:28.360
make designated requirements.

00:51:28.420 --> 00:51:33.410
Let me show you how some
parts of Apple do that.

00:51:35.560 --> 00:51:41.890
Okay, this is a phone application that
I just got from one of my colleagues.

00:51:42.420 --> 00:51:48.500
And if we take a look at
the signature of this,

00:51:49.200 --> 00:51:54.440
This is the designated requirement
that's generated by the system

00:51:54.570 --> 00:51:56.120
for this phone application.

00:51:56.120 --> 00:52:01.010
It looks a heck of a lot more complicated
than anything you've seen so far because

00:52:01.010 --> 00:52:03.170
the situation is more complicated.

00:52:03.250 --> 00:52:08.020
Remember, this is a signing identity that
Apple issued to a developer.

00:52:08.140 --> 00:52:13.080
So what we're seeing
here is the identifier,

00:52:13.170 --> 00:52:18.210
which is just like the
identifier in the Frop tool.

00:52:18.330 --> 00:52:24.200
And it needs to be signed by Apple here,
except we don't actually care

00:52:24.200 --> 00:52:28.600
whether it's signed by Apple for
itself or for developers,

00:52:28.600 --> 00:52:31.200
so that's why the generic clause is here.

00:52:31.200 --> 00:52:34.200
And then we're seeing things about
the certificates in the chain.

00:52:34.200 --> 00:52:39.350
We're seeing that the leaf must
have a subject of this string,

00:52:39.350 --> 00:52:42.800
which just happens to be the
signing identity for the guy who

00:52:42.800 --> 00:52:44.200
signed this phone application.

00:52:44.200 --> 00:52:48.580
And we're seeing that an
intermediate--the first intermediate

00:52:48.580 --> 00:52:54.200
in the signing chain--has to have
this particular certificate extension.

00:52:54.200 --> 00:52:56.960
Now,
we generate this automatically because

00:52:57.030 --> 00:52:59.180
Apple knows how Apple does this.

00:52:59.230 --> 00:53:03.090
We understand the rules that we
made for ourselves for issuing

00:53:03.090 --> 00:53:05.200
certificates to developers.

00:53:05.670 --> 00:53:09.120
Something like that will need
to be written if you buy your

00:53:09.200 --> 00:53:13.110
certificates from VeriSign,
except the actual contents

00:53:13.110 --> 00:53:14.180
need to reflect that.

00:53:14.280 --> 00:53:17.200
So, we need to protect VeriSign's
policies rather than Apple's policies.

00:53:17.320 --> 00:53:20.200
And that's the point where
we can't guess for you.

00:53:20.290 --> 00:53:22.900
Okay.

00:53:31.740 --> 00:53:37.620
I promised you some information about
gotchas and things to watch out for.

00:53:37.710 --> 00:53:41.260
So let's talk about what could go wrong.

00:53:41.310 --> 00:53:43.810
First of all,
what happens if you don't sign

00:53:43.810 --> 00:53:46.020
your code and you keep shipping it?

00:53:46.050 --> 00:53:50.320
Not that you would, but, you know,
what would happen if you did?

00:53:51.730 --> 00:53:58.310
The system believes that unsigned
code has no reliable identity.

00:53:58.520 --> 00:54:02.170
Or perhaps you could say
no verifiable identity.

00:54:02.170 --> 00:54:05.940
I mean it can claim to be a particular
program but there is not very much we

00:54:05.940 --> 00:54:08.160
can do to actually verify such a claim.

00:54:08.300 --> 00:54:11.370
So the system proceeds on
the assumption that yeah,

00:54:11.370 --> 00:54:14.800
it could be that program
but then it could not.

00:54:14.920 --> 00:54:18.210
And when we have to present
the user with a dialogue,

00:54:18.210 --> 00:54:20.360
that's what we'll tell them.

00:54:20.520 --> 00:54:26.430
So if you run an unsigned program and
there's a Keychain dialogue coming up,

00:54:26.430 --> 00:54:30.360
you'll find a little fine print in the
dialogue basically says that the identity

00:54:30.360 --> 00:54:34.120
of this application cannot be verified,
which is exactly true.

00:54:34.220 --> 00:54:35.650
Well, we don't know.

00:54:35.830 --> 00:54:36.130
Could be.

00:54:36.360 --> 00:54:37.310
Could be not.

00:54:37.420 --> 00:54:40.120
But in the end,
the user just has to decide whether

00:54:40.120 --> 00:54:44.030
to trust this thing based on
something that he knows that we don't.

00:54:45.050 --> 00:54:48.590
There are situations where
an unsigned program will be

00:54:48.590 --> 00:54:51.780
automatically signed by the system.

00:54:53.100 --> 00:54:55.990
Because you are about to
interact with a subsystem that

00:54:56.080 --> 00:54:57.680
can deal with unsigned code.

00:54:58.910 --> 00:55:03.000
Parental Controls is one example,
the Application Firewall is another.

00:55:03.140 --> 00:55:05.950
Now this may sound like
a good thing at first,

00:55:06.020 --> 00:55:09.000
but it turns out not to be
for a number of reasons.

00:55:09.000 --> 00:55:13.000
I'll talk specifically about ad
hoc signatures in a little bit.

00:55:13.370 --> 00:55:18.830
But generally,
this automatic signing trick is trying

00:55:18.830 --> 00:55:24.000
to tide the user over until you can
ship a signed version of your program.

00:55:24.100 --> 00:55:28.140
It's not a replacement for you
signing your program because,

00:55:28.140 --> 00:55:31.000
well,
we don't have your signing identity.

00:55:31.070 --> 00:55:32.950
We can't make any statements for you.

00:55:33.000 --> 00:55:36.540
We can only say, "Okay,
we've nailed this program down in

00:55:36.550 --> 00:55:40.770
this spot and we can track that it
hasn't changed until it changes."

00:55:41.040 --> 00:55:42.000
And I will just have to assume it got
hacked because we've already signed it.

00:55:42.000 --> 00:55:42.000
But generally,
this automatic signing trick is trying

00:55:42.000 --> 00:55:42.000
to tide the user over until you can
ship a signed version of your program.

00:55:42.000 --> 00:55:42.000
It's not a replacement for you
signing your program because,

00:55:42.000 --> 00:55:42.000
well,
we don't have your signing identity.

00:55:42.000 --> 00:55:42.000
We can't make any statements for you.

00:55:42.000 --> 00:55:42.000
We can only say, "Okay,
we've nailed this program down

00:55:42.000 --> 00:55:42.000
in this spot and we can track
that it hasn't changed until it

00:55:42.000 --> 00:55:42.470
changes." And I will just have
to assume it got hacked because,

00:55:42.470 --> 00:55:43.000
well,
we don't have your signing identity.

00:55:43.000 --> 00:55:43.470
And I will just have to
assume it got hacked because,

00:55:43.470 --> 00:55:44.000
well,
we don't have your signing identity.

00:55:44.000 --> 00:55:44.980
But the other thing is it got hacked
because we don't know any better.

00:55:45.000 --> 00:55:49.550
If this had been your code signature and
the hack actually was a software update,

00:55:49.550 --> 00:55:54.000
then we could say, "Yeah, okay,
satisfies the designated requirement.

00:55:54.000 --> 00:55:54.970
Everything's cool here.

00:55:55.020 --> 00:55:57.910
We don't need to bother the
user." But we can't do that if

00:55:57.950 --> 00:56:01.000
you don't sign your code because
we don't know what your rules are.

00:56:01.000 --> 00:56:03.000
We don't know what you did to your code.

00:56:03.000 --> 00:56:04.990
All we know is it changed.

00:56:05.010 --> 00:56:08.790
So one of the sort of implicit side
effects of ad hoc signing is we always

00:56:08.790 --> 00:56:13.650
take the pessimistic assumption that
any time the program changes at all,

00:56:13.650 --> 00:56:20.000
it's probably a hack because, you know,
you need to be conservative here.

00:56:21.610 --> 00:56:28.030
If an unsigned program uses the Keychain,
you essentially get shunted into

00:56:28.030 --> 00:56:32.500
a legacy path that tries to behave
as much as possible as Tiger did.

00:56:32.500 --> 00:56:36.110
I don't know if you still remember Tiger,
but there were a lot

00:56:36.110 --> 00:56:37.500
of dialogues in there.

00:56:37.500 --> 00:56:41.500
And you'll get every last one of
them because they're still in there,

00:56:41.500 --> 00:56:44.030
complete with little notes in them
saying that the identity of the

00:56:44.030 --> 00:56:45.490
application cannot be verified.

00:56:45.500 --> 00:56:48.880
And that means, in particular,
that if you are issuing software updates,

00:56:48.880 --> 00:56:51.500
you get those lovely "is this
still the same program?" dialogues.

00:56:51.500 --> 00:56:54.500
And, you know, it's just not a really
great user experience.

00:56:54.500 --> 00:56:58.840
And I don't know about you,
but I've gotten sort of addicted

00:56:58.840 --> 00:57:01.430
to not getting those dialogues.

00:57:02.360 --> 00:57:05.700
And some of the new subsystems
will just basically give you the

00:57:05.700 --> 00:57:10.000
raspberry and not give you service,
like the Developer Tools Access.

00:57:10.000 --> 00:57:16.910
If you want to call task for PID,
you pretty much have to

00:57:16.910 --> 00:57:16.910
sign your code because,
well, that's just the way it is.

00:57:17.270 --> 00:57:21.890
And as I said,
if you don't sign your code,

00:57:21.970 --> 00:57:25.330
we don't know what a software
update for your code looks like.

00:57:25.440 --> 00:57:28.290
So we'll just assume that it isn't.

00:57:28.970 --> 00:57:32.140
There's one class of
programs that absolutely,

00:57:32.140 --> 00:57:35.720
positively need to get signed,
because otherwise they won't work,

00:57:35.720 --> 00:57:39.370
and that is programs, paradoxically,
that self-check with their

00:57:39.370 --> 00:57:40.990
own self-check trickery.

00:57:41.460 --> 00:57:44.960
Because they want to defend
themselves against evil hackers.

00:57:45.090 --> 00:57:49.360
If they're unsigned and they self-check
and they touch something like the

00:57:49.360 --> 00:57:53.510
application firewall because they
make an inbound connection or because

00:57:53.510 --> 00:57:56.390
they're running under parental controls,
they will get ad hoc signed and the ad

00:57:56.450 --> 00:57:58.300
hoc signature will change the program.

00:57:58.430 --> 00:58:00.690
And then the self-check will fail.

00:58:01.130 --> 00:58:01.940
That's not good.

00:58:01.970 --> 00:58:05.150
So paradoxically,
if you are writing the kinds of

00:58:05.150 --> 00:58:08.820
programs that perform self-checks,
you absolutely positively

00:58:08.820 --> 00:58:12.060
need to sign them right now
or your users will be--well,

00:58:12.140 --> 00:58:14.470
your users already are very unhappy.

00:58:15.070 --> 00:58:17.160
Now, there's a flip side to this.

00:58:17.380 --> 00:58:19.230
So you go and you sign your program.

00:58:19.450 --> 00:58:21.960
You are very conscientious about it.

00:58:22.020 --> 00:58:24.600
You do everything right.

00:58:24.650 --> 00:58:28.560
But then something happens
and the code signature breaks.

00:58:29.770 --> 00:58:33.700
A program that is signed but has
an invalid signature is considered

00:58:33.780 --> 00:58:35.500
to have no identity at all.

00:58:35.500 --> 00:58:39.660
Because clearly whatever claim to
identity it has made with the code

00:58:39.660 --> 00:58:43.980
signature cannot be believed because,
you know, it's broken.

00:58:43.980 --> 00:58:49.960
So obviously that means that any
time that program makes a request on

00:58:50.130 --> 00:58:54.660
the basis of "I get this because I'm
me" like requesting a keychain item,

00:58:54.660 --> 00:58:58.800
requesting developer tools access,
requesting to be allowed to run

00:58:58.800 --> 00:59:03.280
because of parental controls and so on,
it just won't--it will be denied.

00:59:03.390 --> 00:59:06.050
As a matter of fact,
the system is currently shipped in a

00:59:06.050 --> 00:59:09.360
state both in Leopard and Snow Leopard
where you don't even get a dialogue.

00:59:09.360 --> 00:59:16.160
You just--the retrieval call for the
keychain item gets denied automatically.

00:59:17.590 --> 00:59:20.920
Unless, obviously,
a program like that can't make

00:59:20.920 --> 00:59:22.460
a new keychain item either.

00:59:22.460 --> 00:59:23.880
Why is that?

00:59:23.980 --> 00:59:26.000
Because when you're
making a keychain item,

00:59:26.000 --> 00:59:32.390
you are making an access control
list for the new item that says,

00:59:32.580 --> 00:59:34.880
and the creator has free
access to this item.

00:59:34.920 --> 00:59:39.610
But the creator is a code signing
requirement for the creating program.

00:59:39.620 --> 00:59:42.230
And if you don't have an identity,
we can't make a code signing

00:59:42.230 --> 00:59:44.450
requirement for your identity
because you don't have one.

00:59:44.970 --> 00:59:48.640
So a program with a broken signature
cannot make keychain items.

00:59:48.680 --> 00:59:51.430
And there's a number of other
things that it can't do either.

00:59:51.440 --> 00:59:56.510
If the breakage is...

00:59:57.050 --> 00:59:58.000
Oh, okay.

00:59:58.000 --> 01:00:00.820
You can usually run on Leopard,
personal Leopard,

01:00:00.890 --> 01:00:05.900
because we don't currently
on Mac OS X simply deny

01:00:06.330 --> 01:00:10.990
launch for broken programs,
for programs with broken signatures.

01:00:11.220 --> 01:00:15.550
Except in the case of parental controls,
obviously.

01:00:15.990 --> 01:00:20.150
There is no mechanism in the system that
will repair a broken signature because

01:00:20.150 --> 01:00:22.400
we have no idea how we would do this.

01:00:22.440 --> 01:00:24.970
Because for one,
we don't have your code signing identity,

01:00:25.120 --> 01:00:28.720
which is a good thing,
which means that we couldn't fake a

01:00:28.720 --> 01:00:32.280
repair for you even if we wanted to,
which we don't.

01:00:32.920 --> 01:00:37.090
So once a program is broken on disk,
it'll stay broken because presumably

01:00:37.090 --> 01:00:40.740
something painted over it,
intentionally or not, and, you know,

01:00:41.030 --> 01:00:43.460
restore a backup or
reinstall the program.

01:00:43.460 --> 01:00:45.240
That's basically the options.

01:00:45.290 --> 01:00:48.980
Now there's a second type of breakage
which is dynamic invalidation,

01:00:49.020 --> 01:00:55.630
where a program does something at runtime
that makes it lose its validity bit,

01:00:55.700 --> 01:00:58.050
its, you know,
its state in the system that says,

01:00:58.180 --> 01:01:01.840
"I am still valid." If that's the
only thing that happened to a program,

01:01:01.840 --> 01:01:04.260
you can actually quit it and
relaunch it and not do that thing

01:01:04.260 --> 01:01:08.060
again that lost its identity
because the thing on disk is fine.

01:01:08.130 --> 01:01:11.600
So here's another example
where static and dynamic has

01:01:11.610 --> 01:01:14.140
slightly different consequences.

01:01:14.210 --> 01:01:16.080
So that's your options.

01:01:16.140 --> 01:01:17.860
Reinstall,
which can mean restore the backup,

01:01:17.910 --> 01:01:18.480
obviously.

01:01:18.480 --> 01:01:21.560
That's Time Machine, you know, try it.

01:01:21.800 --> 01:01:26.280
And if it's a dynamic breakage,
then relaunch.

01:01:26.280 --> 01:01:30.950
When you are issuing software updates
that do more complicated things than

01:01:30.950 --> 01:01:34.610
just replacing the whole application,
you have to be careful that

01:01:34.750 --> 01:01:37.690
you are really shipping all of
the files that have changed.

01:01:37.770 --> 01:01:43.900
That includes the files that
code signing made in your bundle.

01:01:43.900 --> 01:01:43.900
If

01:01:44.480 --> 01:01:47.670
Generally,
any update mechanism that faithfully

01:01:47.850 --> 01:01:53.120
replicates your desired state onto
the end user system will work fine.

01:01:53.210 --> 01:01:55.550
Because code signing absolutely
doesn't even understand what

01:01:55.670 --> 01:01:57.420
your transport mechanism is.

01:01:57.500 --> 01:01:58.700
It just cares about the end result.

01:01:58.760 --> 01:02:02.360
And the end result has to be exactly
the same files that were signed on your

01:02:02.360 --> 01:02:04.550
system when you signed your program.

01:02:04.690 --> 01:02:08.370
So if you're having
complicated update scenarios,

01:02:08.610 --> 01:02:10.280
be careful and just test.

01:02:10.430 --> 01:02:12.180
It's really quite simple.

01:02:12.310 --> 01:02:16.270
So ad hoc signatures--

01:02:16.540 --> 01:02:21.360
This particular type of signature
which is--remember the picture

01:02:21.390 --> 01:02:24.400
with the seal and then the
signature applied to the seal?

01:02:24.400 --> 01:02:27.360
An ad hoc signature is a seal
without an actual digital signature.

01:02:27.360 --> 01:02:28.900
We don't use identities at all.

01:02:29.120 --> 01:02:34.950
We just stop after the making the seal
part and we just take the seal as given.

01:02:35.470 --> 01:02:39.130
The minimum amount of code signing
you can possibly get away with to

01:02:39.130 --> 01:02:41.830
notice that a program has changed.

01:02:42.080 --> 01:02:45.540
So the parental controls on
the firewall currently do that.

01:02:45.570 --> 01:02:50.090
And there are two obvious
gotchas with this.

01:02:50.260 --> 01:02:54.210
The really obvious one is that since we
are nailing down exactly this program,

01:02:54.220 --> 01:02:57.990
software updates can't be tracked.

01:02:58.030 --> 01:03:01.480
If the program changes in any way at all,
we'll just say it's a different program.

01:03:01.630 --> 01:03:05.800
The thing that is not perhaps
obvious is that because of

01:03:05.800 --> 01:03:08.750
the way these things are made,
they're architecture specific.

01:03:08.820 --> 01:03:13.670
So if your users end up getting
your program ad hoc signed because

01:03:13.670 --> 01:03:15.080
of something they're doing,
like, you know,

01:03:15.080 --> 01:03:18.240
network connections or parental controls,
and then they switch

01:03:18.240 --> 01:03:22.820
from PowerPC to Intel,
or from Intel to Intel 64-bit--heard

01:03:22.910 --> 01:03:28.000
about it-- then these ad hoc
signatures will no longer verify.

01:03:28.010 --> 01:03:31.600
And that will probably
lead to complaints.

01:03:31.620 --> 01:03:33.570
from your users.

01:03:33.730 --> 01:03:35.690
I did mention you should sign your code,
right?

01:03:35.810 --> 01:03:39.140
Because obviously, if you sign your code,
you will never get ad hoc

01:03:39.140 --> 01:03:42.300
signed and all of this problem
will just not happen to you.

01:03:42.320 --> 01:03:48.200
Okay, frequently asked questions before
we take your real questions.

01:03:48.250 --> 01:03:53.480
No, we do not decide what code is
good and what code isn't good.

01:03:53.520 --> 01:03:57.570
We very, very intentionally do not have
anything in our code signing code

01:03:57.710 --> 01:04:01.300
that makes any judgments as to
whether your code is acceptable or

01:04:01.340 --> 01:04:04.820
good or nice or otherwise qualified.

01:04:04.820 --> 01:04:07.740
That's what the code
requirements are for.

01:04:08.440 --> 01:04:11.600
All of the policy is in
the code requirements.

01:04:11.800 --> 01:04:12.800
Everything.

01:04:13.320 --> 01:04:18.380
There's no policy in the core
code signing code other than,

01:04:18.380 --> 01:04:21.610
you know, the seal can't be broken.

01:04:22.860 --> 01:04:27.180
Nor does the system as a whole--the
system that you're running on,

01:04:27.180 --> 01:04:29.700
generally--make this judgment.

01:04:29.730 --> 01:04:31.690
Remember I told you about trust settings?

01:04:31.810 --> 01:04:36.120
No, the trust settings configuration of
the system or any other configuration

01:04:36.120 --> 01:04:41.580
database in the system does not a priori
decide whether a program is good or not.

01:04:41.720 --> 01:04:45.700
Again, it's in the code requirements,
and that means it's individual.

01:04:45.700 --> 01:04:51.690
I get the question a lot,
"So does the system trust my program?"

01:04:51.760 --> 01:04:53.700
I don't know which part of the system.

01:04:53.700 --> 01:04:56.030
Each of the different parts
has a different idea of how

01:04:56.030 --> 01:04:57.700
to make up code requirements.

01:04:57.790 --> 01:05:01.130
It's perfectly possible for your
program to be trusted by parental

01:05:01.130 --> 01:05:03.700
controls and the firewall,
but not the keychain.

01:05:03.710 --> 01:05:08.000
So, the system is probably
the wrong question.

01:05:08.610 --> 01:05:13.160
Mac OS X will in general still run
your program if it's not signed.

01:05:13.280 --> 01:05:15.440
And as a matter of fact,
because some parts of it

01:05:15.440 --> 01:05:18.970
don't like unsigned code,
it will sign your program for you,

01:05:19.120 --> 01:05:22.510
and we've just discussed
that that's not a good thing.

01:05:22.970 --> 01:05:26.650
Well, if you don't know my
answer to that one yet,

01:05:26.660 --> 01:05:28.090
I'm not going to repeat it.

01:05:28.200 --> 01:05:32.600
And, yeah,
we don't get that one much anymore.

01:05:32.600 --> 01:05:35.590
Yes,
you can buy yourself a digital identity

01:05:35.640 --> 01:05:39.080
from a professional commercial provider.

01:05:39.080 --> 01:05:40.360
That's fine with us.

01:05:40.360 --> 01:05:40.900
We support it.

01:05:41.020 --> 01:05:44.010
But we don't require it.

01:05:44.040 --> 01:05:48.310
You can do anything that you can
do with a professionally sold

01:05:48.310 --> 01:05:51.020
identity with an identity you
make yourself with Apple tools.

01:05:51.020 --> 01:05:52.600
And in the end, it's up to you.

01:05:52.900 --> 01:05:53.950
- Yeah.

01:05:54.730 --> 01:05:58.310
Um, that question will
recede into the distance.

01:05:58.430 --> 01:06:03.840
Signed code actually runs fine on Tiger,
in case you still wonder about that,

01:06:03.990 --> 01:06:06.120
because Tiger just ignores
the code signature.

01:06:06.200 --> 01:06:11.360
With one exception,
you don't want to ship frameworks

01:06:11.360 --> 01:06:16.670
into Tiger because the linker
actually complains that it doesn't

01:06:16.670 --> 01:06:16.670
understand what those strange bits are.

01:06:17.360 --> 01:06:20.690
Top problems, again,
these are things that people have

01:06:20.690 --> 01:06:24.480
run into often enough that I'll
just tell you upfront about it.

01:06:24.530 --> 01:06:29.000
If you have helper tools,
don't put them in resources.

01:06:29.070 --> 01:06:30.920
Put them somewhere else.

01:06:30.970 --> 01:06:32.990
We don't really care
where somewhere else.

01:06:33.200 --> 01:06:37.620
Typical places are the Mac OS directory
or perhaps the contents directory.

01:06:37.620 --> 01:06:39.360
Just don't put them in resources.

01:06:39.360 --> 01:06:44.940
I realize Xcode makes it excruciatingly
easy to put things into resources,

01:06:44.940 --> 01:06:46.350
but helpers don't go there.

01:06:46.760 --> 01:06:50.130
If you change anything on your
program after you sign it as

01:06:50.130 --> 01:06:52.590
part of your mastering process,
you know,

01:06:52.590 --> 01:06:55.230
putting them on DVDs or uploading
on your website or whatever,

01:06:55.290 --> 01:06:59.730
be really careful that you don't change
the program because a modification

01:06:59.730 --> 01:07:04.120
is a modification and the signing
system can't tell whether it's okay.

01:07:04.280 --> 01:07:06.670
If you meant to make a change,
that's okay.

01:07:06.690 --> 01:07:10.000
Just make the change and
then sign the program.

01:07:10.070 --> 01:07:12.280
If your installer
allows partial installs,

01:07:12.350 --> 01:07:16.670
you know, like optional modules and
optional parts of the program,

01:07:16.980 --> 01:07:23.180
then it's not a good idea to have these
optional parts be resources in your

01:07:23.320 --> 01:07:28.000
resources folder because when you sign,
you have to sign the whole thing.

01:07:28.070 --> 01:07:32.490
There is a facility for saying these
resources over there are optional.

01:07:32.490 --> 01:07:35.600
This is called a resource specification.

01:07:35.670 --> 01:07:40.000
But it's usually a much better idea to
just make those optional parts optional.

01:07:40.050 --> 01:07:43.500
and then we can do a
little bit of coding.

01:07:43.500 --> 01:07:44.230
So we can

01:07:44.890 --> 01:07:48.020
Obviously,
it's a bad idea to change the code on

01:07:48.060 --> 01:07:50.560
the end user system for any reason.

01:07:50.560 --> 01:07:56.240
What I usually recommend is that just
imagine that your program gets installed

01:07:56.240 --> 01:07:58.560
on a read-only file system or on a DVD.

01:07:58.560 --> 01:08:02.510
And if something in your program's
operation breaks because you

01:08:02.530 --> 01:08:06.560
can't write to your bundle,
you probably need to redesign it.

01:08:06.560 --> 01:08:08.760
Localizations.

01:08:08.760 --> 01:08:12.560
You need to make sure that what
you're signing is the whole thing,

01:08:12.560 --> 01:08:14.560
including all localizations.

01:08:14.560 --> 01:08:18.040
So if you have optional localizations,
pile them all in before you

01:08:18.040 --> 01:08:19.490
make the code signature.

01:08:19.570 --> 01:08:24.300
Localizations are automatically optional,
so they can be stripped out later.

01:08:24.560 --> 01:08:26.790
If your localizations
are optional installs,

01:08:26.790 --> 01:08:27.560
that's fine.

01:08:27.560 --> 01:08:29.440
We know about that.

01:08:29.590 --> 01:08:30.550
It'll work fine.

01:08:30.560 --> 01:08:36.140
But you cannot sign your program,
ship it, and then have some third

01:08:36.140 --> 01:08:36.560
party make the changes.

01:08:36.560 --> 01:08:40.800
So make more localizations and just stuff
them in because those are new files and

01:08:40.820 --> 01:08:43.560
the system will complain about them.

01:08:43.730 --> 01:08:46.200
And if you still make
self-modifying code,

01:08:46.200 --> 01:08:47.560
well, never mind.

01:08:48.780 --> 01:08:52.960
Okay, and more information.

01:08:53.390 --> 01:08:58.260
Greg Keithley,
who I can't actually see right now,

01:08:58.260 --> 01:09:02.720
is the omnibus technology evangelist,
including data security.

01:09:02.720 --> 01:09:07.300
So if you need evangelism services,
he's your one-stop shop.

01:09:07.300 --> 01:09:10.890
There are perfectly good man pages for
CodeSign and CSREC that are actually

01:09:10.910 --> 01:09:15.000
right now your best documentation
for how they work and what they do.

01:09:15.000 --> 01:09:18.910
There is a conceptual code
signing documentation part

01:09:18.910 --> 01:09:22.460
in the developer library,
and there is a tech note that's

01:09:22.460 --> 01:09:25.020
been held up since December that
still hasn't been published.

01:09:25.020 --> 01:09:27.610
So it's not on this list yet.

01:09:28.670 --> 01:09:33.130
As I said,
Ken is giving a presentation entirely

01:09:33.130 --> 01:09:38.500
dedicated to X.509 certificates and
digital identities today at 5:00.

01:09:38.510 --> 01:09:41.940
So if you need any help with that,
please go.

01:09:42.050 --> 01:09:43.500
He loves to answer questions.

01:09:43.500 --> 01:09:51.240
There is a data security lab right after
this session down on the first floor.

01:09:51.730 --> 01:09:55.500
Since, as expected,
we won't have much time for Q&A,

01:09:55.500 --> 01:09:58.500
I invite all of you to
come down with me there.

01:09:58.500 --> 01:10:01.630
I'll be there and you can
spend the entire lab asking

01:10:01.630 --> 01:10:03.500
me questions if you want to.

01:10:03.500 --> 01:10:07.580
And if you have phone-specific questions,
you're unfortunately too late because

01:10:07.660 --> 01:10:13.810
there was a phone-specific security
session that you've already missed.

01:10:15.540 --> 01:10:18.210
They asked me to put a summary in.

01:10:18.300 --> 01:10:23.960
So code signing is about
defining code identity,

01:10:24.060 --> 01:10:28.310
about what it means for code to
have identity and about tracking

01:10:28.320 --> 01:10:30.110
this identity at runtime.

01:10:30.990 --> 01:10:34.230
You, as the company,
the person who signs the code,

01:10:34.300 --> 01:10:36.530
define what that identity means.

01:10:36.540 --> 01:10:40.290
So you actually get to define
what it means for your program

01:10:40.290 --> 01:10:42.220
to have software updates.

01:10:42.460 --> 01:10:46.530
And conversely,
the user on the end user system makes

01:10:46.530 --> 01:10:51.610
the policy decisions because he directly
or indirectly specifies what code

01:10:51.690 --> 01:10:53.980
requirements get applied to the code.

01:10:54.110 --> 01:10:56.800
So neither of these two roles is Apple's.

01:10:57.040 --> 01:11:01.260
Neither the defining role nor
the policy-making verifying role.

01:11:01.420 --> 01:11:03.660
Unless, of course,
one of us happens to be Apple.

01:11:03.660 --> 01:11:08.210
If Apple makes the code,
obviously we're the manufacturer.

01:11:09.210 --> 01:11:10.760
Sign your code.

01:11:10.760 --> 01:11:14.420
If you haven't done it yet,
you really want to get going on this.

01:11:14.520 --> 01:11:17.440
Right now, we're transitioning.

01:11:17.580 --> 01:11:18.690
Transition is good.

01:11:18.690 --> 01:11:20.200
It gives you some breathing room.

01:11:20.710 --> 01:11:24.170
Eventually, the transition will be over
and then it'll be an emergency

01:11:24.310 --> 01:11:26.200
and it'll be your emergency.

01:11:26.450 --> 01:11:29.180
Please, don't let it be an emergency.
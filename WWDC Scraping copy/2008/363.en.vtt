WEBVTT

00:00:20.450 --> 00:00:22.300
Good morning.

00:00:22.300 --> 00:00:24.300
This is session 363.

00:00:24.300 --> 00:00:25.300
You might be in the wrong place.

00:00:25.300 --> 00:00:26.060
Take a quick check.

00:00:26.140 --> 00:00:28.180
It's still okay to get up and leave.

00:00:28.180 --> 00:00:29.230
I won't be hurt.

00:00:29.240 --> 00:00:30.700
My name is Chris Parker.

00:00:30.780 --> 00:00:32.940
I work on the Cocoa frameworks team.

00:00:32.940 --> 00:00:35.380
And today I'm going to talk
to you about what we've been

00:00:35.380 --> 00:00:37.020
doing in Cocoa for Snow Leopard.

00:00:37.020 --> 00:00:41.920
And that usually works out
to be a whole bunch of API.

00:00:41.920 --> 00:00:44.780
I don't have Steve's cool
thunk sound effect here.

00:00:44.780 --> 00:00:46.400
I couldn't get that
in time for this talk.

00:00:46.460 --> 00:00:48.680
So just imagine that happening there.

00:00:49.350 --> 00:00:53.320
We've been spending a lot of time in the
Cocoa frameworks group working on a lot

00:00:53.320 --> 00:00:56.900
of the things that you heard Bertrand
talk about in his talk on Monday.

00:00:56.900 --> 00:01:00.040
And that's going to include some things
like better coverage in the kit and

00:01:00.050 --> 00:01:03.600
foundation on technologies that you would
have had to go to other frameworks for.

00:01:03.600 --> 00:01:05.560
And all the slides that
we talk about that,

00:01:05.560 --> 00:01:08.900
and we'll have this nifty little
Cocoa icon in the upper corner there.

00:01:10.520 --> 00:01:15.210
We also are looking at incorporating
concurrency directly into the

00:01:15.210 --> 00:01:16.900
APIs in the Kit and in Foundation.

00:01:16.900 --> 00:01:19.300
And these will all take advantage of,
you know,

00:01:19.300 --> 00:01:24.040
these multiprocessor machines that we've
got with eight cores and the laptops

00:01:24.130 --> 00:01:26.650
with dual cores and stuff like that.

00:01:26.780 --> 00:01:29.420
We're also incorporating Sudden
Termination directly into

00:01:29.420 --> 00:01:30.750
Foundation in the App Kit.

00:01:30.880 --> 00:01:33.930
So this is a technology that's
going to allow users to speed up

00:01:34.000 --> 00:01:39.620
their log-out and shutdown process,
as well as quit apps very quickly.

00:01:39.780 --> 00:01:43.100
We're also spending a bunch of time
looking at file system efficiency.

00:01:43.280 --> 00:01:45.040
There are a lot of different
places you can go to get

00:01:45.050 --> 00:01:48.560
metadata about files in OS X,
and we're looking at consolidating all

00:01:48.560 --> 00:01:52.030
of those into one API and also make
sure that we're taking advantage of

00:01:52.090 --> 00:01:56.240
any work that anybody else has done in
the course of doing file system work.

00:01:56.300 --> 00:01:57.950
So we're going to do some
caching there as well.

00:01:58.110 --> 00:02:00.730
And we're, of course,
also going to talk about this guy here.

00:02:00.740 --> 00:02:05.710
If you were here for the previous talk,
Blaine's What's New in Objective-C talk,

00:02:05.740 --> 00:02:09.680
this is the new syntax for
declaring and using blocks in API.

00:02:09.700 --> 00:02:11.040
This is not the scale.

00:02:11.040 --> 00:02:14.130
It doesn't actually show up
this large in your source code.

00:02:15.090 --> 00:02:18.120
Let's get started with foundation.

00:02:18.130 --> 00:02:21.480
We're going to start off with blocks.

00:02:21.500 --> 00:02:24.990
Blocks are small snippets of code
that capture the lexical scope.

00:02:25.090 --> 00:02:29.180
If you were here for Blaine's talk,
you talked about being able to

00:02:29.240 --> 00:02:33.600
use local variables directly in
the block that is in that scope.

00:02:33.680 --> 00:02:35.190
I'll show you some examples of that.

00:02:35.280 --> 00:02:37.090
They're inline,
so you'll write them right in your code.

00:02:37.090 --> 00:02:38.590
They're also copyable.

00:02:39.460 --> 00:02:41.030
Here's a new method.

00:02:41.140 --> 00:02:42.830
It's on NSDictionary.

00:02:42.980 --> 00:02:46.830
It's called Enumerate
Keys and Objects Using Block.

00:02:46.880 --> 00:02:48.680
This is the method definition.

00:02:48.690 --> 00:02:52.030
There's the selector,
and there's the entire declaration of

00:02:52.080 --> 00:02:54.390
the single parameter that this takes.

00:02:54.390 --> 00:02:55.450
It's a block.

00:02:55.540 --> 00:02:57.640
Here's how you know it's a block.

00:02:57.640 --> 00:02:59.740
This is just the little up caret.

00:02:59.740 --> 00:03:04.480
You may have seen it in other great
operators like Bitwise Exclusive or.

00:03:04.480 --> 00:03:06.910
Its name is block.

00:03:06.980 --> 00:03:08.600
It returns nothing.

00:03:08.600 --> 00:03:09.440
This is a void return.

00:03:09.510 --> 00:03:09.860
Block.

00:03:09.860 --> 00:03:15.000
And each time this block is invoked,
there will be three parameters

00:03:15.080 --> 00:03:16.400
that are passed to this block.

00:03:16.400 --> 00:03:17.320
One will be the key.

00:03:17.320 --> 00:03:20.150
The other will be the value for that key,
the object for that key,

00:03:20.300 --> 00:03:22.400
and this by reference
Boolean called stop.

00:03:22.400 --> 00:03:26.680
And this is how you'll be able to
stop the enumeration midstream.

00:03:26.680 --> 00:03:30.710
So rather than have something where
you had to write boilerplate to return

00:03:30.710 --> 00:03:33.670
a value to tell us when not to stop,
you'll just set what

00:03:33.690 --> 00:03:37.200
stop points to to yes,
and that will end that enumeration.

00:03:37.200 --> 00:03:39.430
So this is a pattern that you'll see
throughout all of the enumerations.

00:03:39.460 --> 00:03:42.490
enumeration code and iteration code
and searching code that we have

00:03:42.570 --> 00:03:45.220
that are using blocks in foundation.

00:03:45.220 --> 00:03:49.490
So remember how we used to do
enumeration of dictionaries,

00:03:49.490 --> 00:03:49.770
right?

00:03:49.770 --> 00:03:50.840
We have 4n in Leopard.

00:03:50.840 --> 00:03:52.530
It's the fast enumeration protocol.

00:03:52.650 --> 00:03:54.760
It allows you to iterate
through the dictionary,

00:03:54.760 --> 00:03:58.300
and you'd have to write a 4n
loop against your dictionary,

00:03:58.300 --> 00:04:00.290
and 4n only returns the keys.

00:04:00.300 --> 00:04:04.230
So you'd have to go through
and call object for key

00:04:04.230 --> 00:04:06.590
for each item and use that.

00:04:06.910 --> 00:04:09.430
So in a block,
you would just use enumerate

00:04:09.430 --> 00:04:13.480
keys and objects using block,
and there's the entire block,

00:04:13.480 --> 00:04:16.300
and this means that you get the
key and object at the same time.

00:04:16.300 --> 00:04:18.280
So this is a little bit more expressive.

00:04:18.280 --> 00:04:21.040
It's a little nicer to use than
having to make that additional

00:04:21.070 --> 00:04:22.110
message send each time.

00:04:23.960 --> 00:04:27.620
We've also added some conveniences
to other classes that take blocks.

00:04:27.750 --> 00:04:29.100
This one's on NSString.

00:04:29.140 --> 00:04:32.500
And this is a very common
thing that people want to do.

00:04:32.500 --> 00:04:35.300
They want to enumerate the lines
that are in a particular string.

00:04:35.400 --> 00:04:37.500
So you'd call components
separated by string.

00:04:37.500 --> 00:04:40.880
You might pass it the backslash
and the carriage return there,

00:04:40.880 --> 00:04:42.300
or the new line.

00:04:42.360 --> 00:04:45.700
And this winds up creating a whole
new array that's populated by

00:04:45.700 --> 00:04:50.100
copies of those sub-strings in the
array that have separated by line.

00:04:50.190 --> 00:04:52.300
And then you have to iterate over that.

00:04:52.350 --> 00:04:55.300
What we do now is use
enumerate lines using block.

00:04:55.320 --> 00:04:58.730
And each time through that block,
you'll just get a new NSString that

00:04:58.730 --> 00:05:00.300
has just that line in it.

00:05:00.370 --> 00:05:01.800
This avoids the intermediate array.

00:05:01.800 --> 00:05:03.210
It's better for performance.

00:05:03.370 --> 00:05:06.370
And the kit's actually going to go ahead
and do a much better job of figuring

00:05:06.370 --> 00:05:08.300
out what all the line endings are,
right?

00:05:08.300 --> 00:05:10.130
Because there are a lot of
different ways to break it up.

00:05:10.330 --> 00:05:12.300
This takes care of all of those.

00:05:14.220 --> 00:05:18.130
: This is the first time
I've seen these slides.

00:05:18.130 --> 00:05:21.300
I'm really sorry.

00:05:21.300 --> 00:05:23.610
One of the other things that you
do is with NS attributed strings,

00:05:23.610 --> 00:05:24.100
right?

00:05:24.130 --> 00:05:26.800
A lot of people want to be able to
go through the attributed string

00:05:26.810 --> 00:05:29.910
and figure out what attribute
is in each range of the string.

00:05:30.090 --> 00:05:33.120
And so you might call something
like attribute at index with

00:05:33.120 --> 00:05:35.100
longest effective range in range.

00:05:35.100 --> 00:05:38.230
So you have to set up this method
call and write a while loop that

00:05:38.230 --> 00:05:40.100
iterates through these things.

00:05:40.290 --> 00:05:40.690
Right?

00:05:40.690 --> 00:05:44.480
What we're going to do instead
now is use enumerate attribute

00:05:44.480 --> 00:05:46.980
in range options using block.

00:05:47.170 --> 00:05:49.100
And the block is right here.

00:05:49.100 --> 00:05:53.100
So what I've done here
is renamed the key,

00:05:53.100 --> 00:05:57.080
the ID object to font so that it's a
little more obvious what I'm doing.

00:05:57.110 --> 00:06:00.190
And this code just goes through,
runs through all the attributes in

00:06:00.190 --> 00:06:03.100
the string and compares it to find
out if the font size is less than 10.

00:06:03.100 --> 00:06:05.100
And if it is,
we'll just go ahead and print it out.

00:06:05.100 --> 00:06:07.010
We can do other things with it as well.

00:06:07.180 --> 00:06:10.080
This is a much easier way to be
able to enumerate in NS attribute.

00:06:10.100 --> 00:06:11.100
So we're going to go ahead and print
out the attribute in the string.

00:06:11.100 --> 00:06:14.350
And in order to also provide
a wider range of API,

00:06:14.470 --> 00:06:17.100
we have two new methods that do this.

00:06:17.100 --> 00:06:20.740
One is the one that I just showed you,
which is enumerate attributes

00:06:20.860 --> 00:06:23.100
in range options using block.

00:06:23.100 --> 00:06:23.100
That's the one on the bottom.

00:06:23.100 --> 00:06:27.100
And enumerate attributes in
range options using block.

00:06:27.190 --> 00:06:30.290
Each time through that block,
you're going to get an NSDictionary that

00:06:30.290 --> 00:06:34.100
has the entire set of attributes
that are applied to that string,

00:06:34.100 --> 00:06:36.100
to that substring in that range.

00:06:36.100 --> 00:06:38.460
It's a much faster way to be able to
go through an entire string and get

00:06:38.510 --> 00:06:40.100
all of the attributes that are there.

00:06:40.100 --> 00:06:43.830
Blocks are letting us be a little
more expressive and allow you guys to

00:06:43.830 --> 00:06:46.090
write less code in your applications.

00:06:46.100 --> 00:06:48.060
So it's nice for us.

00:06:48.100 --> 00:06:49.100
It's nice for you.

00:06:49.100 --> 00:06:53.100
We're also adding API to
allow sorting using blocks.

00:06:53.100 --> 00:06:56.910
This is the type definition of
basically a named block here.

00:06:57.100 --> 00:06:58.840
The name is NS comparator.

00:06:59.100 --> 00:07:01.780
Each time the comparator
block is invoked,

00:07:01.780 --> 00:07:04.030
it'll take two objects to compare.

00:07:04.130 --> 00:07:07.100
And you'll return an
NS comparison result from that.

00:07:07.100 --> 00:07:09.040
And there are sort options that you
can pass to all of these things.

00:07:09.110 --> 00:07:13.100
The sort concurrent flag
and the sort stable flag.

00:07:13.100 --> 00:07:15.130
So now with the block API,
we have a stable sorting

00:07:15.270 --> 00:07:17.110
API in foundation,
which is not a guarantee

00:07:17.110 --> 00:07:18.100
that we made before.

00:07:18.100 --> 00:07:22.650
So if you pass the sort stable flag,
you'll get a sort that the

00:07:22.650 --> 00:07:27.070
results have the elements in their
relative positions correctly.

00:07:27.100 --> 00:07:29.100
Those are NS sort options.

00:07:29.240 --> 00:07:32.100
Also, that concurrent flag is interesting
because in Bertrand's example,

00:07:32.100 --> 00:07:35.100
he had some dispatch call
going on and things like that.

00:07:35.100 --> 00:07:38.100
And this basically reduces most of
the concurrent API in foundation.

00:07:38.100 --> 00:07:40.380
So you can take the API in
foundation for all of these

00:07:40.380 --> 00:07:45.100
kinds of sorts and selections to
a bit flag that you pass into it.

00:07:45.100 --> 00:07:47.100
So we'll take care of all the
concurrency in the background.

00:07:48.820 --> 00:07:53.900
You'll use these things with sorted array
using -- with options using comparator.

00:07:53.900 --> 00:07:56.440
And this -- for an array
that's large enough,

00:07:56.550 --> 00:07:59.250
we actually go through,
split it up into a bunch

00:07:59.250 --> 00:08:02.770
of different threads,
let those threads do all the work.

00:08:04.020 --> 00:08:08.100
We're also doing searching in
Foundation now using blocks.

00:08:08.280 --> 00:08:13.670
Index of objects passing test and indexes
of objects with options passing test.

00:08:13.680 --> 00:08:16.400
And you can pass a number of
different options to this.

00:08:16.440 --> 00:08:18.560
Enumeration concurrent
and enumeration reverse.

00:08:18.560 --> 00:08:22.540
If you want to do the enumeration
backwards for the options,

00:08:22.540 --> 00:08:24.130
you can do that for indexes.

00:08:24.230 --> 00:08:28.910
This also applies to all of the enumerate
objects using block APIs that are

00:08:28.910 --> 00:08:30.480
against NSArray and things like that.

00:08:31.520 --> 00:08:34.140
The interesting thing about
these blocks is that these are

00:08:34.210 --> 00:08:35.510
the ones that return a bool.

00:08:35.520 --> 00:08:38.630
And here, if the object or the
index is being passed in,

00:08:38.720 --> 00:08:39.800
you'll do your test.

00:08:39.800 --> 00:08:42.570
And then you'll return a yes
in order to get that object's

00:08:42.570 --> 00:08:44.460
index included in the NSIndexSet.

00:08:45.910 --> 00:08:49.140
This is a quick way to
build up those index sets.

00:08:49.200 --> 00:08:53.190
You can write your test in line
there and it's very expressive.

00:08:53.460 --> 00:09:16.500
: NSIndexSet now also does enumeration.

00:09:16.500 --> 00:09:16.500
If you try to do 4N
enumeration with an NSIndexSet,

00:09:16.500 --> 00:09:16.500
you can't.

00:09:16.500 --> 00:09:16.500
Enumerating an NSIndexSet is
a little bit inconvenient.

00:09:16.500 --> 00:09:16.500
These are enumerate indexes
using block and enumerate

00:09:16.500 --> 00:09:16.500
indexes with options using block,
and these are a much easier

00:09:16.500 --> 00:09:16.500
way to actually run over
each index in the NSIndexSet.

00:09:16.500 --> 00:09:16.500
You'll get the index of each
object going through it.

00:09:19.690 --> 00:09:20.600
Okay.

00:09:20.600 --> 00:09:23.310
I can slow down for a second.

00:09:23.580 --> 00:09:24.590
Sudden termination.

00:09:24.860 --> 00:09:28.230
What we're trying to do here is
enable fast exit for applications

00:09:28.230 --> 00:09:29.600
and log out and shut down.

00:09:29.600 --> 00:09:33.520
We've all seen this where the user goes
up to the Apple menu and they pull down

00:09:33.520 --> 00:09:37.630
shut down and you kind of sit there and
twiddle your thumbs while an application

00:09:37.630 --> 00:09:39.460
does a bunch of work in order to quit.

00:09:40.900 --> 00:09:57.400
[Transcript missing]

00:09:58.310 --> 00:10:02.420
The way you do this is by
using NSProcessInfo API.

00:10:02.640 --> 00:10:07.410
An application launches,
sudden termination is disabled.

00:10:07.530 --> 00:10:09.080
When the app knows that
it's in a clean state,

00:10:09.080 --> 00:10:10.860
you'll call enable sudden termination.

00:10:10.860 --> 00:10:13.230
And this is how you signal
to the operating system that

00:10:13.460 --> 00:10:16.200
you're ready to be killed.

00:10:16.260 --> 00:10:19.320
If you have data that's being saved
and it hasn't made it out to disk yet,

00:10:19.320 --> 00:10:21.880
you should disable sudden termination.

00:10:21.930 --> 00:10:23.110
Wait until that work happens.

00:10:23.240 --> 00:10:26.200
When you know the work has happened,
re-enable sudden termination.

00:10:26.250 --> 00:10:28.850
We take care of a bunch of this for you.

00:10:28.940 --> 00:10:32.150
So if you're using set object for key
and you just sort of take your hands

00:10:32.150 --> 00:10:34.820
off and you wait for the auto sync
timer to come around and synchronize

00:10:34.820 --> 00:10:39.040
your NS user defaults out to disk,
we'll disable sudden termination

00:10:39.040 --> 00:10:41.600
while those haven't been written.

00:10:41.790 --> 00:10:43.390
And we'll re-enable it
when it does get set.

00:10:43.490 --> 00:10:45.600
So we're doing a bunch of the work.

00:10:45.610 --> 00:10:47.710
NSDocument does a bunch
of work for you as well.

00:10:48.070 --> 00:10:52.830
So there may only be a few places in
your code that you'll need to adopt this.

00:10:52.990 --> 00:10:55.780
If you want to opt your app into it
by default so that when it launches,

00:10:55.810 --> 00:10:58.470
it's clean right from the start,
you'll use this

00:10:58.510 --> 00:11:02.910
NSSupportSuddenTermination
key in your Info.plist,

00:11:02.910 --> 00:11:04.690
set the value to yes,

00:11:04.990 --> 00:11:17.270
will talk about this in session 425,
Performance in Document-Centric

00:11:17.370 --> 00:11:18.090
Cocoa Applications.

00:11:18.090 --> 00:11:22.430
That's right here tomorrow at 5.

00:11:22.430 --> 00:11:24.930
Makes for a long day,
but you should come see it.

00:11:24.940 --> 00:11:25.610
It'll be a good talk.

00:11:26.920 --> 00:11:30.820
We also have now automatic cache
management in Foundation via

00:11:30.820 --> 00:11:32.180
the NS Cache class.

00:11:32.240 --> 00:11:34.460
And this is something that
works a lot like a dictionary.

00:11:34.460 --> 00:11:36.900
Objects that are put into the
cache are indexed by keys.

00:11:36.900 --> 00:11:40.230
You'll do some search
object for key request.

00:11:40.590 --> 00:11:42.780
That'll give the object back.

00:11:42.830 --> 00:11:45.630
There's some built-in policy,
least recently used in frequency.

00:11:45.680 --> 00:11:48.090
There's also a cost factor
that we're building into this

00:11:48.170 --> 00:11:49.400
as well as account limit.

00:11:49.400 --> 00:11:51.710
And these are sort of not hard limits.

00:11:51.710 --> 00:11:56.440
We'll get close to them and then we'll
start taking some additional behavior.

00:11:56.940 --> 00:12:00.450
Object for key and set object for key,
obviously the main setters and getters

00:12:00.450 --> 00:12:04.260
for objects that you're going to put
into the cache and remove from the cache.

00:12:04.260 --> 00:12:06.050
Remove object for key takes them out.

00:12:06.090 --> 00:12:08.810
Set object for key cost is
how you associate a cost

00:12:08.810 --> 00:12:10.400
with a particular object.

00:12:10.450 --> 00:12:13.940
And that works in conjunction
with the set total cost limit API.

00:12:13.940 --> 00:12:15.870
So you can set an upper
bound for the cost.

00:12:16.000 --> 00:12:18.050
And as soon as we hit
that bound or go over it,

00:12:18.160 --> 00:12:19.560
again, it's not a hard limit.

00:12:19.560 --> 00:12:22.850
We'll start evicting items from
the cache based on their cost.

00:12:22.850 --> 00:12:25.000
And the set count limit
is the same thing.

00:12:26.180 --> 00:12:28.550
you probably want to know
when something's going to

00:12:28.640 --> 00:12:30.780
get evicted from the cache.

00:12:31.000 --> 00:12:46.600
[Transcript missing]

00:12:47.490 --> 00:12:51.340
There's also now at the low level
a purgeable memory facility.

00:12:51.340 --> 00:12:53.720
The kernel has a way to be able
to allocate a special kind of

00:12:53.720 --> 00:12:57.690
memory that if it's not in use,
if you haven't indicated it's in use,

00:12:57.690 --> 00:13:00.970
then, well, it'll go ahead and rip it out
from under you when there's

00:13:01.030 --> 00:13:02.680
memory pressure on the system.

00:13:04.030 --> 00:13:06.590
We've implemented that as part
of an NSMutableData subclass.

00:13:06.680 --> 00:13:09.310
It's a special kind of mutable
data called purgeable data,

00:13:09.510 --> 00:13:11.510
and this takes care of
managing this for you.

00:13:11.560 --> 00:13:14.390
So we'll do the allocations
and things like that.

00:13:14.480 --> 00:13:17.800
And what we've done in order to
make this discardable content

00:13:18.320 --> 00:13:21.900
idea abstract is we have now an
NSDiscardableContent protocol,

00:13:21.900 --> 00:13:25.140
and these methods are
for content management.

00:13:25.140 --> 00:13:27.560
It's how you'll indicate that
you're still interested in the

00:13:27.560 --> 00:13:30.130
backing store of an object,
and when you remove that interest,

00:13:30.130 --> 00:13:32.260
the backing store of
the object may go away.

00:13:32.820 --> 00:13:33.520
We also have an automatic
management method.

00:13:33.660 --> 00:13:53.570
We also have an automatic
management method.

00:13:54.670 --> 00:13:57.140
One of the other things that we
noticed in working on Snow Leopard

00:13:57.140 --> 00:14:00.360
and other operating system releases
is that there are places where we

00:14:00.360 --> 00:14:04.510
could be a lot more efficient in
terms of our use of the file system.

00:14:05.700 --> 00:16:19.000
[Transcript missing]

00:16:19.590 --> 00:16:38.310
: Thank you, Chris.

00:16:38.310 --> 00:16:38.310
I'm going to start with a quick excerpt
of all the properties that are available,

00:16:38.310 --> 00:16:38.310
and there are more of them
that you can see in this URL.h.

00:16:38.310 --> 00:16:38.310
The effective icon key is the one
that's displayed for the user,

00:16:38.310 --> 00:16:38.310
and the custom icon key is whether
or not the user has pasted a

00:16:38.310 --> 00:16:38.310
new icon onto that resource.

00:16:38.310 --> 00:16:38.310
So it will be able to tell the
difference between what's being

00:16:38.310 --> 00:16:38.310
displayed and whether the user
has a preference for that icon.

00:16:39.710 --> 00:16:41.660
We also have a new file URL type.

00:16:41.840 --> 00:16:43.890
File URLs are interesting
because they're path-based,

00:16:43.910 --> 00:16:44.080
right?

00:16:44.210 --> 00:16:52.100
So volumes/users/chris_talk.rtf points
to a specific file in my home directory,

00:16:52.130 --> 00:16:56.470
in that user's directory,
and if I move that file,

00:16:56.470 --> 00:17:00.600
I'm not going to be able to locate it
with this resource locator anymore.

00:17:00.660 --> 00:17:04.600
We're introducing a new type of
file URL called a file resource URL.

00:17:04.600 --> 00:17:08.490
And when I call file resource URL,
I get something that looks like this.

00:17:08.680 --> 00:17:10.600
The format of this isn't important.

00:17:10.600 --> 00:17:12.600
What really is important is the behavior.

00:17:12.600 --> 00:17:15.500
And if you've done
Carbon File Manager programming,

00:17:15.610 --> 00:17:18.600
this basically functions
exactly like an FSREF.

00:17:18.600 --> 00:17:22.600
So if the file moves on to
the local disk someplace,

00:17:22.600 --> 00:17:23.600
we're going to track that.

00:17:23.600 --> 00:17:25.800
So here's a file in my home directory.

00:17:25.800 --> 00:17:27.310
I have this path-based URL.

00:17:27.590 --> 00:17:29.600
I call file resource URL on it.

00:17:29.600 --> 00:17:31.600
I get this nice different kind of URL.

00:17:31.600 --> 00:17:33.280
It's still a file URL.

00:17:33.660 --> 00:17:38.690
I can still pass this URL to things
like NSData's init with contents of URL,

00:17:38.820 --> 00:17:41.600
any of the URL-taking methods that
are in Foundation and the kit.

00:17:41.600 --> 00:17:44.760
But if I move that,
one of these actually tracks

00:17:44.860 --> 00:17:46.580
the file when it moves.

00:17:46.590 --> 00:17:49.750
So now you'll be able to get this
functionality right from NSURL and

00:17:49.750 --> 00:17:52.600
use it all the way up through
the Foundation and AppKit stack.

00:17:59.470 --> 00:18:03.650
is the talk about this today
at 2:00 in North Beach,

00:18:03.690 --> 00:18:06.340
using file system APIs efficiently.

00:18:06.400 --> 00:18:07.970
Chris Lynn will talk about this.

00:18:08.130 --> 00:18:13.030
Keith will also explain about bookmarks,
which are a new kind of data that

00:18:13.400 --> 00:18:18.980
we're using as basically the follow
on to the alias manager for very

00:18:18.980 --> 00:18:21.510
rich aliasing experience also.

00:18:21.510 --> 00:18:25.700
So that's also being
introduced today at 2:00.

00:18:27.640 --> 00:18:29.940
As part of all this,
we've been introducing new

00:18:29.940 --> 00:18:33.400
APIs in-- we introduced new
APIs in Leopard that took URLs.

00:18:33.470 --> 00:18:35.200
We're actually doing a
lot more of this now.

00:18:35.200 --> 00:18:39.150
We're adding more URL-based
API to Foundation.

00:18:39.220 --> 00:18:43.900
So NSBundle grows a bunch
of new NSURL methods that

00:18:43.920 --> 00:18:45.670
return these populated NSURLs.

00:18:45.830 --> 00:18:49.480
URL for resource with extension,
subdirectory, isBundleWithURL,

00:18:49.480 --> 00:18:53.040
all the different URL subfolders,
things like that.

00:18:53.040 --> 00:18:56.100
And these are all things that you'll
be able to use directly in the new

00:18:56.100 --> 00:18:58.730
Foundation APIs and the new Kit.

00:18:58.870 --> 00:19:03.540
So NSURL, also we've put a number
of these on NSFileManager.

00:19:03.630 --> 00:19:08.550
So all the copy item at path,
all the at path APIs are now at URL APIs.

00:19:08.680 --> 00:19:13.810
So copy item at URL to URL error,
move item, link item, and remove item,

00:19:13.810 --> 00:19:16.030
all of their delegate methods
have been updated as well to

00:19:16.130 --> 00:19:18.320
hand you URLs to the delegate.

00:19:18.480 --> 00:19:21.070
And these will all be ways that
we'll be able to take advantage

00:19:21.160 --> 00:19:23.640
of some of the data sharing
that we can do with the NSURLs.

00:19:26.200 --> 00:19:29.000
We've also enhanced
property list parsing,

00:19:29.000 --> 00:19:30.090
some of the APIs there.

00:19:30.100 --> 00:19:34.240
So if you're working with an NSData,
these two new methods on the

00:19:34.760 --> 00:19:38.090
property list serialization headers,
data with property list format

00:19:38.240 --> 00:19:42.100
options error and property list
with data options format error,

00:19:42.290 --> 00:19:44.600
those two methods allow you to
switch back and forth between

00:19:44.600 --> 00:19:46.100
NSDatas and property list classes.

00:19:46.230 --> 00:19:48.630
And the important thing here is
the error parameter because we're

00:19:48.630 --> 00:19:51.430
going to put better errors in
there to talk about what went wrong

00:19:51.430 --> 00:19:53.100
in parsing that plist and where.

00:19:53.100 --> 00:19:57.170
So whether something's not a plist
type or if you have an XML plist,

00:19:57.170 --> 00:19:59.100
something's wrong with the XML,
that kind of thing.

00:19:59.210 --> 00:20:02.100
And those are also suitable
for presentation to the user.

00:20:02.100 --> 00:20:04.100
If you know something more about it,
though, as usual,

00:20:04.100 --> 00:20:07.030
you should wrap those up and
put a more descriptive error

00:20:07.030 --> 00:20:08.780
in yourself if you need to.

00:20:09.080 --> 00:20:10.110
We've also done it for streams.

00:20:10.320 --> 00:20:13.820
So if you have a stream that the mark is
sitting at the beginning of a property

00:20:13.960 --> 00:20:16.810
list data that you know in the protocol
you're working with via the stream,

00:20:16.810 --> 00:20:20.270
you'll be able to write the property list
to the stream or read the property list

00:20:20.300 --> 00:20:22.260
from the stream using these two new APIs.

00:20:22.440 --> 00:20:27.030
Write property list to stream format
options error and property list

00:20:27.050 --> 00:20:28.690
with stream options format error.

00:20:28.830 --> 00:20:34.080
So those are a set of property list
APIs that give you much better errors.

00:20:34.240 --> 00:20:37.920
So-- oh, yeah,
there's that App Kit thing.

00:20:39.180 --> 00:20:43.340
The Kit is getting a number of new
methods and functionality that also

00:20:43.340 --> 00:20:47.580
incorporates some API that you would
have had to go to other frameworks for.

00:20:47.580 --> 00:20:50.380
And we tried to be very careful
about the API that we're drawing in.

00:20:50.470 --> 00:20:54.620
The first is being able to get at the
finder labels right from NS Workspace.

00:20:54.620 --> 00:20:55.720
So you've seen this in the finder.

00:20:55.720 --> 00:21:00.290
The user has a bunch of labels that
are set up with colors and text.

00:21:00.290 --> 00:21:03.840
You'll call file labels or
file label colors against the

00:21:03.840 --> 00:21:05.180
shared workspace instance.

00:21:05.340 --> 00:21:06.610
And you'll get that list.

00:21:06.670 --> 00:21:11.400
And if you register with NS Workspace's
shared workspace instance,

00:21:11.470 --> 00:21:15.520
you can also get this notification about
the fact that the file labels change.

00:21:15.520 --> 00:21:17.870
So if the user goes and tweaks those,
you'll get the notification

00:21:17.870 --> 00:21:20.130
that says maybe you should go
back and read that list again.

00:21:22.390 --> 00:21:24.290
Workspace also can show query results.

00:21:24.380 --> 00:21:30.730
So something you would have had to
go to HLTB for the Carbon UI Kit for.

00:21:30.740 --> 00:21:33.120
Show search results for query string.

00:21:33.120 --> 00:21:35.880
You give it a query string that's
formatted the way Spotlight expects it,

00:21:35.880 --> 00:21:38.690
and this will tell the finder to
go ahead and put that search window

00:21:39.170 --> 00:21:40.940
up and start doing that search.

00:21:40.940 --> 00:21:44.500
This is a nice little
convenience method there.

00:21:45.380 --> 00:21:47.380
There are also new
notifications for NS Workspace.

00:21:47.400 --> 00:21:49.190
And these will be available at all times.

00:21:49.200 --> 00:21:51.220
At one time, you would have had to be
the frontmost app for this.

00:21:51.280 --> 00:21:52.490
Now you can get them all the time.

00:21:52.590 --> 00:21:54.990
Did hide app, did unhide app,
the activation and

00:21:54.990 --> 00:21:56.600
deactivation notifications.

00:21:56.790 --> 00:21:58.780
These work now for all
running applications.

00:21:58.810 --> 00:22:03.690
This includes anything with a full
UI or LSUI element applications and

00:22:03.690 --> 00:22:07.370
LS background only applications.

00:22:10.530 --> 00:22:15.740
: I'm glad to see there are
four of you who need that.

00:22:15.780 --> 00:22:17.680
There's now also desktop image support.

00:22:17.680 --> 00:22:20.320
So now right from NS Workspace
you'll be able to set the desktop

00:22:20.320 --> 00:22:22.340
image URL for a given screen.

00:22:22.340 --> 00:22:25.440
Set desktop image URL for
screen options error.

00:22:25.440 --> 00:22:27.530
Give us a URL that points in an image.

00:22:27.540 --> 00:22:30.870
Which screen you want it on is
the NS screen instance there.

00:22:30.870 --> 00:22:33.120
The options are things like, well,
it's what you see in the desktop

00:22:33.170 --> 00:22:34.690
and screen saver control panel.

00:22:34.690 --> 00:22:37.220
When you set a desktop image
you can choose whether it

00:22:37.350 --> 00:22:40.160
fills the screen or centers,
things like that.

00:22:40.190 --> 00:22:43.330
You can also find out what the URL is,
desktop image URL for screen and

00:22:43.330 --> 00:22:45.300
desktop image options for screen.

00:22:45.300 --> 00:22:47.320
So you'll know exactly how
the user has their desktop set

00:22:47.340 --> 00:22:48.520
up if you want to change it.

00:22:51.140 --> 00:22:54.590
We also now can vend information
about other running applications.

00:22:54.690 --> 00:22:57.140
NS Workspace has this new method
called running applications,

00:22:57.140 --> 00:22:59.380
and this includes all
running applications again.

00:22:59.380 --> 00:23:01.850
So this is anything that checks in
with the Windows Server and says,

00:23:01.970 --> 00:23:02.420
hey, I'm an app.

00:23:02.460 --> 00:23:05.240
So this will be
LSUI element applications,

00:23:05.240 --> 00:23:07.620
LS background only applications.

00:23:07.620 --> 00:23:10.430
This is any Ruby Cocoa application
that checks in,

00:23:10.430 --> 00:23:14.500
PyObjc, all of those things that actually
make a point of working with the

00:23:14.500 --> 00:23:18.070
Windows Server to tell us that
it's an app will report here.

00:23:20.590 --> 00:23:23.040
That running applications
method returns an NSArray.

00:23:23.040 --> 00:23:26.080
Each element in that NSArray is an
instance of one of these things,

00:23:26.080 --> 00:23:27.660
which is an NS running application.

00:23:27.700 --> 00:23:31.160
And this is all stuff you probably
would have had to go to another API for.

00:23:31.160 --> 00:23:34.560
The property declarations here
are things like terminated.

00:23:34.560 --> 00:23:37.990
So if you have an instance
of one and it ends,

00:23:38.020 --> 00:23:40.290
the terminated state will change to yes.

00:23:40.360 --> 00:23:42.820
You may not be able to get
information about it after that,

00:23:42.990 --> 00:23:46.220
but all of these things are available
while the app is still running.

00:23:46.220 --> 00:23:48.540
Hidden, whether or not the app
is hidden or active,

00:23:49.090 --> 00:23:51.580
the localized name of the app,
launch date, the icon,

00:23:51.580 --> 00:23:55.270
what executable architecture is it,
and this includes whether

00:23:55.270 --> 00:23:59.250
it's a 64-bit app,
32-bit app, translated app,

00:23:59.250 --> 00:24:00.270
things like that.

00:24:00.430 --> 00:24:03.120
If you wanted to tell one
of those applications to do

00:24:03.120 --> 00:24:05.830
something like hide or unhide,
previously you would have had to

00:24:05.830 --> 00:24:08.280
roll up an Apple event and send
that Apple event to the application

00:24:08.350 --> 00:24:09.220
and get it to do something.

00:24:09.220 --> 00:24:12.540
Now you can call hide or unhide
directly on one of these instances,

00:24:12.540 --> 00:24:14.440
and that will just take
care of it for you.

00:24:14.480 --> 00:24:17.310
You can tell it to terminate
if you're feeling particularly

00:24:17.310 --> 00:24:18.460
vindictive toward another app.

00:24:19.000 --> 00:24:22.210
You can also tell other apps
to activate with options.

00:24:22.240 --> 00:24:24.650
So if you just call this with zero,
it will bring the key

00:24:24.650 --> 00:24:25.980
and main windows front.

00:24:25.980 --> 00:24:30.060
There's also an option there
to be able to bring all the

00:24:30.060 --> 00:24:31.320
windows of the app to the front.

00:24:31.340 --> 00:24:33.920
So there are some options there.

00:24:33.920 --> 00:24:35.120
You can look at those up in the header.

00:24:35.120 --> 00:24:37.080
So that's an NS running application.

00:24:41.080 --> 00:24:42.350
Do I even have to present this slide?

00:24:42.440 --> 00:24:45.120
Somebody already knows what's coming.

00:24:45.120 --> 00:24:46.060
You may have seen this in mail.

00:24:46.060 --> 00:24:50.840
Somebody sends you an email and they
send you an address and a website.

00:24:50.840 --> 00:24:53.960
Mail takes care of figuring out
where the address is and it goes

00:24:54.160 --> 00:24:57.560
through and it nicely URLifies
all the URLs and things like that.

00:24:57.640 --> 00:25:00.560
If you've done this yourself,
it's a lot of work.

00:25:00.640 --> 00:25:04.180
You go through and you have to
find everything that looks like

00:25:04.280 --> 00:25:06.100
an address or looks like a URL.

00:25:06.110 --> 00:25:07.820
It's really frustrating.

00:25:07.820 --> 00:25:10.980
We're actually bringing this right
into the App Kit in Snow Leopard.

00:25:10.980 --> 00:25:12.760
With a unified text checking API.

00:25:12.890 --> 00:25:15.430
So in Leopard,
we were doing spelling and grammar.

00:25:15.470 --> 00:25:18.630
Now we'll do dates, times, addresses,
and phone numbers.

00:25:18.660 --> 00:25:19.500
We'll do URLs.

00:25:19.500 --> 00:25:23.460
We'll find your smart quotes and any of
the smart dashes and things like that.

00:25:23.460 --> 00:25:25.010
Interesting text features.

00:25:25.010 --> 00:25:26.100
Text replacements.

00:25:26.120 --> 00:25:29.940
So if you've typed in something that we
know that could be replaced by a nifty

00:25:29.940 --> 00:25:33.360
or Unicode glyph or something like that,
we'll put that in and we'll

00:25:33.360 --> 00:25:34.980
also enable auto correction.

00:25:34.980 --> 00:25:39.220
So all of these things will be available
in the text system in Snow Leopard.

00:25:46.940 --> 00:25:47.900
How are they available?

00:25:47.900 --> 00:25:48.900
I hear you cry.

00:25:48.900 --> 00:25:54.180
NS Text Checking Results are basically
the object that's going to wrap this up.

00:25:54.180 --> 00:25:57.680
So an NS Text Checking Result
has two primary accessors.

00:25:57.680 --> 00:26:02.060
That's going to be the read-only property
for the result type and the range.

00:26:02.110 --> 00:26:04.630
And that's the range in the
string that you checked that

00:26:04.810 --> 00:26:06.360
contains that result type.

00:26:07.030 --> 00:26:12.320
These nine are text type spelling,
grammar, date, address, link.

00:26:12.390 --> 00:26:13.880
Link is the URL one.

00:26:13.880 --> 00:26:17.030
So once we autofind the URL,
that'll be the link type.

00:26:17.030 --> 00:26:20.220
And it matches with the NS Attributed
String attribute for that.

00:26:20.270 --> 00:26:23.480
Quotes, dashes, the replacement type,
and the correction type.

00:26:23.510 --> 00:26:26.320
So whenever you get a
text checking result,

00:26:26.320 --> 00:26:28.600
you'll be able to interrogate it
for what kind of thing it is and

00:26:28.600 --> 00:26:30.510
where in the string that appeared.

00:26:30.510 --> 00:26:34.120
If it's one of those other special types,
like a grammar type or a date,

00:26:34.120 --> 00:26:37.300
we've put some conveniences on
NS Text Checking Results to be able

00:26:37.300 --> 00:26:39.220
to just pull those things right out.

00:26:39.220 --> 00:26:41.330
So if we saw a date,
you can call date on the

00:26:41.330 --> 00:26:42.480
NS Text Checking Result.

00:26:42.480 --> 00:26:43.980
You'll get a fully cooked NSDate.

00:26:44.130 --> 00:26:46.790
But if you call URL, you'll get a URL.

00:26:46.920 --> 00:26:51.100
The address components one is interesting
because addresses are fairly rich things,

00:26:51.390 --> 00:26:51.700
right?

00:26:51.700 --> 00:26:54.990
The address components
accessor returns a dictionary.

00:26:54.990 --> 00:26:58.930
That dictionary contains all of
these things if we found them.

00:26:58.930 --> 00:27:03.870
So the name, what the job title is,
the organization, street, city, state,

00:27:03.950 --> 00:27:06.930
zip, country, and the phone number.

00:27:06.930 --> 00:27:10.070
So you get full information
about all the addresses and

00:27:10.070 --> 00:27:11.210
things like that that are in.

00:27:13.100 --> 00:27:14.520
A text checking result.

00:27:14.520 --> 00:27:17.370
One of the other really
interesting things that text

00:27:17.370 --> 00:27:20.860
checking results come with,
and this is the tenth result type,

00:27:20.860 --> 00:27:22.670
is this NS Orthography object.

00:27:22.730 --> 00:27:26.610
And NS Orthography objects describe
what the script system and language

00:27:26.610 --> 00:27:28.270
is that are in use in the text.

00:27:28.270 --> 00:27:31.880
So when you ask us to check a string,
we're also going to go ahead and

00:27:31.880 --> 00:27:35.370
figure out what that string looks
like in terms of what the script

00:27:35.370 --> 00:27:37.300
system in use is and the language.

00:27:37.300 --> 00:27:42.360
And the two primary accessors on that are
the dominant script and the language map.

00:27:43.240 --> 00:27:45.950
And this is interesting because this is
what's going to allow us to be able to

00:27:45.950 --> 00:27:50.530
do things like spell checking and stuff
like that against sections of the text

00:27:50.530 --> 00:27:52.970
without having to switch your language.

00:27:57.480 --> 00:27:58.320
NS Text Checking.

00:27:58.320 --> 00:28:00.380
These aren't hooked up yet in the seed.

00:28:00.380 --> 00:28:01.300
The API is there.

00:28:01.300 --> 00:28:03.200
But just to give you an
idea of what will happen,

00:28:03.200 --> 00:28:06.120
you'll be able to toggle all
of these automatic behaviors

00:28:06.120 --> 00:28:07.700
right on NS Text Views.

00:28:07.720 --> 00:28:11.470
So if you want these things to happen
automatically in any of the NS Text Views

00:28:11.570 --> 00:28:14.370
that you've got in your code already,
you can call something like set

00:28:14.640 --> 00:28:16.860
automatic data detection enabled.

00:28:16.860 --> 00:28:21.600
And we'll go ahead and search
all the text that's in that

00:28:21.600 --> 00:28:22.700
text view automatically.

00:28:22.780 --> 00:28:24.560
And you can turn these things
on and off individually.

00:28:24.720 --> 00:28:28.000
So there's one for dashes and quotes
and URLs if you want to just do

00:28:28.000 --> 00:28:29.910
certain subsets of those things.

00:28:29.920 --> 00:28:33.420
It's not turned on in the seed right now,
so you can't play with this directly.

00:28:33.420 --> 00:28:37.340
But you can use this new
API and a spell checker.

00:28:37.380 --> 00:28:42.870
And this is check string range types,
options in spell document with tag,

00:28:42.880 --> 00:28:44.510
orthography word count.

00:28:44.560 --> 00:28:48.850
The big hitters here are
the check string range.

00:28:48.900 --> 00:28:51.780
So obviously the string that you
want to pass us and the range that

00:28:51.780 --> 00:28:53.600
you want to search in that string.

00:28:54.210 --> 00:28:57.510
The types are a bit mask of what
things you want to look for.

00:28:57.520 --> 00:29:02.000
So tell us that you're looking
for URLs and addresses,

00:29:02.010 --> 00:29:03.520
and we'll only look for those things.

00:29:03.520 --> 00:29:06.280
The orthography is interesting.

00:29:06.280 --> 00:29:10.230
If you pass us a by reference
pointer to an NS orthography object,

00:29:10.300 --> 00:29:14.590
we'll take the entire range of that
and figure out what the dominant script

00:29:14.590 --> 00:29:18.990
and language are and return that in
that top level NS orthography object.

00:29:19.250 --> 00:29:22.820
will also return word
count if you want it.

00:29:22.820 --> 00:29:29.480
The array that's returned here is an
array of those NS text checking results.

00:29:29.480 --> 00:29:35.310
So each of those will have their
own orthography information in them.

00:29:35.550 --> 00:29:37.720
So not only do you get an overall
sense of the dominant language,

00:29:37.720 --> 00:29:37.720
but you'll be able to pick
out all the languages in each

00:29:37.720 --> 00:29:37.720
individual text checking result.

00:29:40.820 --> 00:29:43.710
In past years,
NS Browser has maybe lagged a little

00:29:43.710 --> 00:29:47.800
bit behind the other collection viewers.

00:29:48.530 --> 00:29:50.720
and we're addressing that
in Snow Leopard also.

00:29:50.720 --> 00:29:53.360
There's a new item-based
set of delegate methods.

00:29:53.360 --> 00:29:57.280
And if your object,
if your NS Browser data source delegate

00:29:57.280 --> 00:30:02.020
object implements these four methods,
browser number of children of item,

00:30:02.020 --> 00:30:05.300
browser child of item,
browser is leaf item,

00:30:05.300 --> 00:30:07.330
and browser object value for item.

00:30:07.330 --> 00:30:09.970
If you implement those four things,
you're going to get a very rich set

00:30:09.970 --> 00:30:13.700
of APIs that are available to you on
NS Browser that allow you to change back

00:30:13.700 --> 00:30:16.680
and forth very easily between what's
being shown in the browser and the

00:30:16.680 --> 00:30:18.330
model objects that are underneath it.

00:30:18.360 --> 00:30:23.210
So things like item and index
path now will work if those

00:30:23.210 --> 00:30:24.600
methods are implemented.

00:30:24.600 --> 00:30:29.410
Index path for item,
index path for column, current...

00:30:30.840 --> 00:30:31.710
is a parent for item.

00:30:31.820 --> 00:30:32.800
I need glasses.

00:30:33.000 --> 00:30:36.620
Is leaf item and parent
for items in column.

00:30:36.620 --> 00:30:39.470
All these methods work in conjunction
with your data source delegate

00:30:39.600 --> 00:30:41.410
to be able to return those items.

00:30:41.410 --> 00:30:46.260
And it's much easier to switch
back and forth with these.

00:30:46.260 --> 00:30:48.550
Selection index path and
set selection index path,

00:30:48.650 --> 00:30:51.880
these APIs allow you to be able to
set up exactly the path of things

00:30:51.880 --> 00:30:55.300
that are selected all the way
down that NS Browser in one call.

00:30:55.300 --> 00:30:58.600
So this is also pretty easy to use.

00:30:58.600 --> 00:31:02.460
We're also offering header and
preview views in NS Browser now.

00:31:02.460 --> 00:31:05.880
And this is the header
things up over each column.

00:31:05.880 --> 00:31:08.950
And if you've seen what the finder
does when you click on a leaf item,

00:31:09.050 --> 00:31:11.350
it shows that view in
the last column there.

00:31:11.350 --> 00:31:13.240
This is how you'll be
able to do the same thing.

00:31:13.240 --> 00:31:16.130
And all you have to do is return
us an NS View controller for a

00:31:16.380 --> 00:31:19.850
particular leaf item for either
the preview view or that header

00:31:19.850 --> 00:31:21.390
view that goes up in the top there.

00:31:21.390 --> 00:31:24.470
So this will be a much easier way
to be able to use NS Browser to show

00:31:24.470 --> 00:31:30.000
those kind of rich browsing experiences
when people click on their leaf items.

00:31:31.160 --> 00:31:33.690
A couple of other
enhancements on NS Browser.

00:31:33.920 --> 00:31:36.290
Scroll row to visible of columns.

00:31:36.390 --> 00:31:39.500
So before you could bring a column in,
now you can actually select a specific

00:31:39.550 --> 00:31:42.410
row and bring that in so that the
user can see it without having to make

00:31:42.410 --> 00:31:45.500
any UI changes to figure out where
their selection is in the browser.

00:31:45.500 --> 00:31:49.320
And the clicked column and clicked
row methods work in conjunction

00:31:49.320 --> 00:31:51.440
with the NS Browser set menu API.

00:31:51.440 --> 00:31:54.390
So if you have a contextual menu,
you'll be able to find out

00:31:54.390 --> 00:31:57.780
exactly which column and row was
clicked on to determine that.

00:31:58.600 --> 00:32:01.170
Doug Davidson will be giving a
talk about all of this stuff and is

00:32:01.230 --> 00:32:03.030
polishing your Cocoa application talk.

00:32:03.100 --> 00:32:04.700
That's tomorrow right here.

00:32:04.700 --> 00:32:06.470
You don't have to stay
in your seats until then.

00:32:06.540 --> 00:32:08.010
You can go and come back if you want.

00:32:08.040 --> 00:32:12.790
And he'll talk about all of this and
a number of other things in his talk.

00:32:12.840 --> 00:32:15.910
I'm not even going to
say anything right away.

00:32:16.000 --> 00:32:19.270
NS Event and NS Responder
now do multi-touch gestures.

00:32:19.270 --> 00:32:24.050
So everything that's available now for
the MacBook Air and the newer MacBooks,

00:32:24.050 --> 00:32:25.600
the trackpad events.

00:32:25.620 --> 00:32:28.120
This is magnify with event,
rotate with event.

00:32:28.520 --> 00:32:30.510
Swipe with event,
begin gesture with event,

00:32:30.520 --> 00:32:31.560
and end gesture with event.

00:32:31.560 --> 00:32:34.400
And these are how you're going to be
able to hook up in the event system all

00:32:34.460 --> 00:32:36.480
of those events into your application.

00:32:36.480 --> 00:32:41.710
So if you're working with swipes,
typically, if you do a right swipe,

00:32:41.710 --> 00:32:43.660
you go forward in your browser history.

00:32:43.660 --> 00:32:45.440
This is how you do something like that.

00:32:45.530 --> 00:32:46.460
So swipe with event.

00:32:46.490 --> 00:32:47.730
You get the NS event in it.

00:32:47.730 --> 00:32:49.510
You can check the delta X of the event.

00:32:49.570 --> 00:32:51.850
If it's greater than zero,
it's a left swipe.

00:32:51.860 --> 00:32:54.610
If it's less than zero,
it's a right swipe.

00:32:54.710 --> 00:32:56.970
So this will be how you can wire
up your interface to be able to

00:32:56.980 --> 00:32:58.490
take advantage of those things.

00:32:58.520 --> 00:32:59.520
Thanks.

00:33:01.090 --> 00:33:04.210
We have some new behavior in NS Drawing,
and this is kind of interesting.

00:33:04.490 --> 00:33:08.700
NS Drawing lock focus used to
go to an off-screen window where

00:33:08.700 --> 00:33:11.490
the image would be contained,
and now we've stopped doing that.

00:33:11.530 --> 00:33:16.000
We're actually doing direct memory
buffers with NS Image lock focus.

00:33:16.000 --> 00:33:18.350
So this is actually a good performance
win for us because it means that

00:33:18.400 --> 00:33:23.100
we're not using the Windows Server to
hold the window references for this.

00:33:23.100 --> 00:33:25.760
It does mean NS Cache
image rep is deprecated.

00:33:25.760 --> 00:33:29.210
It's still there for compatibility,
but the lock focus code is

00:33:29.210 --> 00:33:33.370
definitely going through a different
buffering mechanism for that.

00:33:33.430 --> 00:33:35.540
If you see any behavior
changes on the seed,

00:33:35.690 --> 00:33:36.780
please let us know.

00:33:36.830 --> 00:33:39.690
And there's a bigger discussion of
this in the App Kit release notes.

00:33:39.770 --> 00:33:43.870
So we'd really like to know if
something goes south with this.

00:33:44.180 --> 00:33:50.620
We're also trying to make it easier to
work with NS Image and CG Image refs.

00:33:53.800 --> 00:33:55.630
There are a lot of places where the
API takes a CG image ref or expects

00:33:55.730 --> 00:33:58.780
a CG image ref and maybe you've
got the other thing in NSImage.

00:33:58.950 --> 00:34:02.120
In it with CG image size,
this new API in Snow Leopard

00:34:02.200 --> 00:34:04.810
that pulls in a CG image ref,
wraps it and makes it

00:34:04.900 --> 00:34:05.800
an appropriate NSImage.

00:34:05.800 --> 00:34:08.780
These next two methods work in
conjunction with each other.

00:34:08.980 --> 00:34:13.350
CG image for proposed rec context
hints and best representation

00:34:13.360 --> 00:34:14.800
for rec contents hints.

00:34:14.800 --> 00:34:19.390
NSImage really tries to be a
resolution independent drawing image

00:34:19.640 --> 00:34:22.800
representation and CG images are
a little bit more pixel oriented.

00:34:22.800 --> 00:34:26.480
So this is how you'll be able to
generate a CG image as if it were

00:34:26.480 --> 00:34:28.800
drawn in a particular rectangle.

00:34:29.040 --> 00:34:34.790
So this is an easy way to get a
CG image out of an NSImage ref.

00:34:34.800 --> 00:34:36.790
A CG image ref out of an NSImage.

00:34:36.790 --> 00:34:39.220
There we go.

00:34:39.910 --> 00:34:43.210
We now also have some more
support for NS Cursors,

00:34:43.270 --> 00:34:44.910
new kinds of Cursors.

00:34:44.910 --> 00:34:49.680
Drag Link Cursor, the Drag Copy Cursor,
Contextual Menu Cursors,

00:34:49.710 --> 00:34:52.660
and the Operation Not Allowed Cursor.

00:34:52.660 --> 00:34:55.950
That last one is the one where, you know,
if you drag out of the finder

00:34:55.950 --> 00:34:59.100
into something else and the user's
not allowed to make that drag,

00:34:59.100 --> 00:35:01.910
we'll put the little circle
with a slash through it.

00:35:02.240 --> 00:35:04.520
We've also introduced something
you would have had to go to

00:35:04.590 --> 00:35:05.750
Quick Draw for previously.

00:35:05.750 --> 00:35:11.190
And Quick Draw would have required
you to get the current system cursor.

00:35:11.280 --> 00:35:14.690
This actually gets you the
current system cursor right away.

00:35:14.690 --> 00:35:17.020
It includes any,
no matter what app has set

00:35:17.020 --> 00:35:21.820
the current system cursor,
and no matter what that cursor looks

00:35:21.820 --> 00:35:24.820
like or whether or not it's hidden,
this will give you the image and

00:35:24.820 --> 00:35:26.300
the hotspot for it right there.

00:35:29.730 --> 00:35:30.360
And NSError.

00:35:30.360 --> 00:35:33.750
NSError is a class that
actually lives in Foundation.

00:35:33.830 --> 00:35:37.850
That class allows you to produce
user visible errors that are suitable

00:35:38.010 --> 00:35:40.200
for presentation right to the user.

00:35:40.220 --> 00:35:42.080
It contains a bunch of things.

00:35:42.230 --> 00:35:46.460
Here's one that I got at some point
trying to open up that talk.rtf file.

00:35:46.570 --> 00:35:49.550
I don't have the appropriate
access privileges.

00:35:49.550 --> 00:35:53.900
It has the localized failure
reason and the recovery suggestion.

00:35:53.920 --> 00:35:57.190
Now,
if you add the NSHelpAnchorError key,

00:35:57.190 --> 00:36:01.660
we'll actually put the little
help anchor right there in the

00:36:01.670 --> 00:36:04.410
presentation machinery for you.

00:36:04.450 --> 00:36:08.020
So that's very handy.

00:36:08.020 --> 00:36:13.310
NSDocument now supports the
concurrent loading of documents.

00:36:16.360 --> 00:36:22.210
This is a class method on this document
that will be called repeatedly with each

00:36:22.340 --> 00:36:24.300
type of document that's being opened.

00:36:24.600 --> 00:36:25.220
Right?

00:36:25.300 --> 00:36:28.900
So this is interesting
because if you return yes for

00:36:28.980 --> 00:36:31.820
this from a particular type,
we'll go ahead and possibly

00:36:31.960 --> 00:36:35.300
schedule the opening of that
document on a background thread.

00:36:35.330 --> 00:36:38.570
And this is going to allow your
application to stay much more responsive

00:36:38.600 --> 00:36:40.300
all the way through that process.

00:36:40.300 --> 00:36:44.490
So if you select, say, 50 documents,
49 of those documents are

00:36:44.490 --> 00:36:48.640
little 500K documents,
and the 50th one is some 600 megabyte

00:36:48.640 --> 00:36:50.250
monstrosity that needs to load.

00:36:50.300 --> 00:36:53.300
We're not going to block the main
thread loading that document.

00:36:53.300 --> 00:36:54.280
We'll do it in the background.

00:36:54.440 --> 00:36:56.760
The user can actually interact
with all the other documents in

00:36:56.760 --> 00:36:58.260
the application and do their work.

00:36:58.500 --> 00:37:02.890
And when that 600 meg document loads up,
it'll come into the front and then

00:37:02.890 --> 00:37:05.290
you'll be able to work with that also.

00:37:05.300 --> 00:37:08.320
So we're trying to make
sure that it's easy to write

00:37:08.320 --> 00:37:10.300
document-based applications.

00:37:10.300 --> 00:37:11.030
And we're trying to make sure that it's
easy to write document-based applications

00:37:11.030 --> 00:37:15.300
that respond well and continue to respond
well even under heavy opening load.

00:37:16.000 --> 00:37:20.400
: NS File Wrapper now also
has efficient saving support.

00:37:20.400 --> 00:37:23.570
So a lot of times you'll
have an NS File Wrapper,

00:37:23.570 --> 00:37:29.140
you make two or three changes to files
and there are 400 things in the wrapper.

00:37:29.140 --> 00:37:38.420
If you call write to URL options
original contents URL error,

00:37:38.420 --> 00:37:38.420
that original contents URL is

00:37:38.740 --> 00:37:41.580
The pointer to where the
original document is.

00:37:41.720 --> 00:37:45.420
What we'll do is we will compare
everything that changed and figure

00:37:45.440 --> 00:37:48.550
out that all we have to do is create a
bunch of hard links to the new location

00:37:48.550 --> 00:37:50.090
on file systems that support it.

00:37:50.160 --> 00:37:51.940
And then we'll tear
down the old one there.

00:37:51.940 --> 00:37:56.440
So it's a very efficient way to be able
to write file wrapper changes to disk.

00:37:56.510 --> 00:38:01.130
Mark Picciarelli will talk
about this in his performance in

00:38:01.130 --> 00:38:04.500
document-centric Cocoa applications.

00:38:04.500 --> 00:38:06.150
And that's also here in
Russian Hill Thursday.

00:38:06.150 --> 00:38:06.150
So

00:38:07.980 --> 00:38:10.090
We also have concurrent drawing
support now in Snow Leopard.

00:38:10.100 --> 00:38:15.290
So NSWindow has a top-level call,
allows current view drawing.

00:38:15.300 --> 00:38:21.600
That allows current view drawing
tells the window that its contained

00:38:21.600 --> 00:38:26.220
views may be able to have their
drawRect methods called in concurrency.

00:38:26.220 --> 00:38:29.380
So they may be called on different
threads on the same time.

00:38:29.380 --> 00:38:34.480
NSView has a canDrawConcurrently method
and a setCanDrawConcurrently method.

00:38:35.240 --> 00:38:40.880
And these things opt the NSViews into
this draw and concurrent behavior.

00:38:40.880 --> 00:38:43.520
So Aliozer will be talking about this.

00:38:43.670 --> 00:38:47.120
Cocoa performance techniques
in the marina Thursday at 2.

00:38:47.120 --> 00:38:51.040
And this is a very good way to
be able to get some extra drawing

00:38:51.120 --> 00:38:53.390
performance if you know that you
can draw in background threads.

00:38:55.220 --> 00:39:01.300
I have a quick little demo here.

00:39:01.300 --> 00:39:01.300
If I could have demo one, please.

00:39:02.640 --> 00:39:04.840
Gosh, I hope this looks okay.

00:39:04.860 --> 00:39:06.410
Okay.

00:39:06.660 --> 00:39:09.250
Let me get this so you can
actually see what's going on.

00:39:20.570 --> 00:39:31.680
Pay no attention to this
man behind the curtain.

00:39:31.680 --> 00:39:33.180
They always ask you,
"What are you going to do when the

00:39:33.180 --> 00:39:36.770
demo goes wrong?" They never ask you,
"What are you going to do when the

00:39:36.770 --> 00:39:41.710
machine doesn't display the way you
think it should?" If I launch this,

00:39:41.710 --> 00:39:44.430
do you guys see that?

00:39:44.430 --> 00:39:44.430
Let's

00:39:48.740 --> 00:39:52.270
The code is bouncing.

00:39:52.290 --> 00:39:55.700
If I create a new project, no.

00:39:55.700 --> 00:39:59.320
All right, let's try this again.

00:40:05.600 --> 00:40:35.900
[Transcript missing]

00:40:55.040 --> 00:40:56.550
You guys throw the fruit,
I'm walking off stage.

00:40:56.600 --> 00:40:57.600
Yay!

00:40:57.600 --> 00:40:58.600
Thank you, sir.

00:40:58.600 --> 00:41:09.390
Boy, it's a good thing there are people
who know computers around here.

00:41:11.560 --> 00:41:15.040
Well, now what else can go wrong?

00:41:15.050 --> 00:41:18.820
So I'm going to just fire up
a new Cocoa application here.

00:41:18.870 --> 00:41:22.950
And I'll call this AppLister.

00:41:23.500 --> 00:41:30.020
And here we have our blank Cocoa project.

00:41:31.110 --> 00:41:33.680
Let me create a new class here.

00:41:33.680 --> 00:41:39.640
I can't put instances
of NSWorkspace in nibs,

00:41:39.730 --> 00:41:44.820
so I have to create a little
controller object here.

00:41:45.730 --> 00:41:50.430
To create our AL controller,
I'll use our new Objective

00:41:50.470 --> 00:41:53.950
C 2.0 property syntax here.

00:41:54.030 --> 00:41:57.590
To create a property,
we'll make it a read-only property.

00:41:57.590 --> 00:42:01.590
This will return an NS workspace.

00:42:05.800 --> 00:42:12.100
[Transcript missing]

00:42:13.100 --> 00:42:24.000
[Transcript missing]

00:42:26.030 --> 00:42:28.600
So all this does is when you call it,
we call shared workspace

00:42:28.600 --> 00:42:29.500
and feed it back to you.

00:42:29.500 --> 00:42:36.680
And let's add some stuff to a nib.

00:42:38.070 --> 00:42:42.600
So here's our main menu and our window.

00:42:42.600 --> 00:42:45.500
Let's start throwing some stuff in here.

00:42:45.520 --> 00:42:47.790
We'll put a table view in.

00:42:50.260 --> 00:42:55.040
Get this all nicely lined up.

00:42:55.060 --> 00:42:58.120
I like to have the spacing correct,
so we'll make this so that

00:42:58.120 --> 00:43:00.750
it's all nicely resizable.

00:43:00.970 --> 00:43:04.840
And let's set up our object also.

00:43:04.840 --> 00:43:08.630
So I'll get an NSObject instance here.

00:43:08.680 --> 00:43:09.880
We'll throw it in.

00:43:10.110 --> 00:43:12.590
And here in the object inspector,
I'm going to go ahead and set

00:43:12.590 --> 00:43:15.420
its class to be ALController.

00:43:15.420 --> 00:43:20.230
Now, what I want to try and do is hook
up to the NSWorkspace instance.

00:43:20.240 --> 00:43:24.190
So I'll use an NSArrayController here.

00:43:25.480 --> 00:43:27.260
to bring that in.

00:43:27.330 --> 00:43:31.700
What we'll do is we'll use Cocoa bindings
and grab the content array.

00:43:32.290 --> 00:43:35.720
We'll bind that to the controller here,
and the model key path will be

00:43:35.720 --> 00:43:40.500
workspace running applications.

00:43:42.880 --> 00:43:44.430
And what else do I need to do here?

00:43:44.500 --> 00:43:46.770
Oh, let's make this look good.

00:43:46.810 --> 00:43:53.800
Let's get an image, an NSImage cell,
and we'll assign that to this.

00:43:55.460 --> 00:43:58.820
: Thank you, Chris.

00:43:58.820 --> 00:44:05.670
I'm going to go ahead
and start the session.

00:44:05.670 --> 00:44:16.490
I'm going to start the session with
a quick summary of what we've done.

00:44:16.490 --> 00:44:21.190
The first thing we're going to
do is we're going to go to the

00:44:22.200 --> 00:44:23.890
We build and go.

00:44:24.010 --> 00:44:26.800
And what we have now is,
by binding to the NS running

00:44:26.800 --> 00:44:31.570
applications instance,
our very own low budget activity monitor.

00:44:36.370 --> 00:44:38.000
So if I launch TextEdit, it shows up.

00:44:38.000 --> 00:44:41.340
And if I quit Interface Builder,
you see Interface Builder leave.

00:44:41.340 --> 00:44:43.740
If I quit TextEdit,
the running applications

00:44:43.740 --> 00:44:47.080
instance is key value observable,
as are the NS running

00:44:47.080 --> 00:44:48.650
application instances as well.

00:44:48.820 --> 00:44:52.640
So you'll be able to get some interesting
notifications out of all of that.

00:44:52.790 --> 00:44:55.460
The other thing I wanted to show
you was the text checking APIs.

00:44:55.480 --> 00:44:59.470
And it sounds like-- I mentioned
that a lot of this stuff was a lot

00:44:59.470 --> 00:45:02.770
of work to be able to go through
and search through all of that text.

00:45:02.980 --> 00:45:05.810
And what I have here is just
a little short demo of using

00:45:06.270 --> 00:45:08.920
the text checking APIs.

00:45:08.920 --> 00:45:12.520
And I threw this together in much
the same way in Interface Builder.

00:45:12.550 --> 00:45:17.420
I just typed some text directly into the
Interface Builder text view right in IB.

00:45:17.810 --> 00:45:18.790
So here's a bunch of text.

00:45:18.800 --> 00:45:21.670
There's a URL.

00:45:22.750 --> 00:45:26.060
Oh, it's that thing where people
send you mail your address.

00:45:26.270 --> 00:45:30.520
And a possible replacement text and
just some grossly misspelled words.

00:45:30.560 --> 00:45:33.250
And if I hit Check Text here.

00:45:33.760 --> 00:45:36.060
This goes ahead and
recognizes all of that.

00:45:36.150 --> 00:45:38.870
And we've also gone ahead
and I've assigned some tool

00:45:38.870 --> 00:45:40.910
tips and things like that.

00:45:40.920 --> 00:45:45.490
And here the tool tip over the little
C that's been underlined is actually,

00:45:45.490 --> 00:45:48.150
it's hard to see up there,
it's actually the

00:45:48.150 --> 00:45:50.080
little copyright symbol.

00:45:50.080 --> 00:45:55.130
And I can add some stuff to this,
put a registered trademark thing there,

00:45:55.490 --> 00:45:58.870
hit check text again,
and the tool tip has that.

00:46:00.260 --> 00:46:02.320
How much code did this wind up being?

00:46:02.510 --> 00:46:05.180
Oh, not much.

00:46:06.430 --> 00:46:08.960
Here's where all the hard work really is.

00:46:09.270 --> 00:46:12.560
This is my text check--
check text method.

00:46:12.560 --> 00:46:14.720
Say that five times fast.

00:46:14.830 --> 00:46:17.920
I grab the Layout Manager to be
able to do some attributed string,

00:46:18.020 --> 00:46:20.830
setting temporary
attributes on the string.

00:46:21.000 --> 00:46:24.510
I grab the string out of the text view,
clean up any attributes

00:46:24.510 --> 00:46:29.270
that might have been there,
and then this is me doing-- well,

00:46:29.370 --> 00:46:29.960
actually, I'm sorry.

00:46:29.960 --> 00:46:33.320
It's the text system doing all
of the work for checking all

00:46:33.420 --> 00:46:35.220
the possible types in that text.

00:46:35.360 --> 00:46:37.570
So that one line of code gets everything.

00:46:37.690 --> 00:46:42.300
And here I've just used the for in
statement to run over that array

00:46:42.300 --> 00:46:47.380
and just assign some different
attributes depending on what the

00:46:47.810 --> 00:46:51.840
different text checking things are.

00:46:51.840 --> 00:46:54.500
So it's a really, really easy way to be
able to do all of this.

00:46:54.500 --> 00:46:57.030
So if you don't want to do it
automatically in NSTextView,

00:46:57.160 --> 00:47:00.190
it's pretty much one line of
code to find out what's in your

00:47:00.190 --> 00:47:03.590
text there using our text system.

00:47:03.690 --> 00:47:07.100
So-- Can I please have-- do
I have the other one back now?

00:47:07.100 --> 00:47:08.090
I hope.

00:47:08.510 --> 00:47:09.540
All right.

00:47:09.630 --> 00:47:10.270
The slides are back.

00:47:10.350 --> 00:47:11.890
Yay.

00:47:12.820 --> 00:47:17.300
Core Data has also been busy.

00:47:17.300 --> 00:47:18.920
There's more than I can
possibly talk about here,

00:47:18.920 --> 00:47:20.390
but let me hit the highlights.

00:47:20.410 --> 00:47:22.080
There's now Spotlight
integration in Core Data,

00:47:22.080 --> 00:47:26.870
so you'll be able to do searchable
records from your Core Data database.

00:47:28.400 --> 00:47:30.810
So there's a support directory
that will automatically get

00:47:30.810 --> 00:47:32.270
maintained when you opt into this.

00:47:32.360 --> 00:47:35.340
There's tool support to mark properties,
so when you have properties

00:47:35.340 --> 00:47:37.980
inside your model,
you can check off those properties

00:47:37.980 --> 00:47:41.240
to say index and spotlight,
and it'll just take care of that.

00:47:41.240 --> 00:47:43.870
And it's got all the support for
generating the SQL for all of that stuff.

00:47:44.790 --> 00:47:47.390
There are also read-only properties now,
which is a big performance

00:47:47.470 --> 00:47:48.500
opportunity for you.

00:47:48.500 --> 00:47:51.390
And the new fetch requests that
do read-only properties support

00:47:51.650 --> 00:47:55.400
composites of function expressions,
individual properties, key paths,

00:47:55.400 --> 00:47:59.780
the aggregate functions for sum, average,
max, min, count, things like that.

00:48:00.590 --> 00:48:05.130
And there's also a way to be able to get
distinct results out of your databases.

00:48:05.130 --> 00:48:07.920
So this is a property fetch that allows
you to go out and find out what's in

00:48:07.970 --> 00:48:11.130
your database without having to get every
single object and then do the uniking,

00:48:11.130 --> 00:48:11.680
right?

00:48:11.880 --> 00:48:14.080
So if you were picking, oh,
let me do something.

00:48:16.590 --> 00:48:25.700
So if you were picking, oh,
let me do something.

00:48:25.780 --> 00:48:28.170
And there's also support
for lightweight migration.

00:48:28.280 --> 00:48:31.070
So automatic schema change
support for simple model changes.

00:48:31.120 --> 00:48:33.660
If you tack on a new
property for something,

00:48:33.840 --> 00:48:35.610
Cordato will go ahead and figure

00:48:36.770 --> 00:48:40.700
So there's also in-place migrations for
SQL Lite data stores and tool support

00:48:40.800 --> 00:48:44.000
for also renaming your attributes,
relationships, and entities.

00:48:44.000 --> 00:48:46.000
So all of that stuff is
built right into Core Data.

00:48:46.000 --> 00:48:49.290
The Core Data team will be
talking about that today at 2

00:48:49.290 --> 00:48:51.040
p.m., What's New in Core Data.

00:48:51.040 --> 00:48:55.380
There is a lot more than
I could possibly fit in here.

00:48:55.380 --> 00:48:57.650
You know,
we could talk for a few days on all

00:48:57.650 --> 00:48:59.590
of this stuff just by ourselves.

00:48:59.600 --> 00:49:02.840
One of the things that we
are doing in the future,

00:49:02.840 --> 00:49:05.060
if you heard Blaine's talk,
he touched on this.

00:49:06.130 --> 00:49:10.020
In delegates and data sources,
things that we did before Snow Leopard

00:49:10.020 --> 00:49:14.400
was define what the methods were by
using what we called informal protocols,

00:49:14.400 --> 00:49:16.790
which was really just a fancy
way for saying categories

00:49:16.880 --> 00:49:18.320
with a lot of documentation.

00:49:18.320 --> 00:49:22.640
So this is the NS TableView data
source informal protocol.

00:49:22.640 --> 00:49:24.180
It has some required methods.

00:49:24.180 --> 00:49:25.280
It has some optional methods.

00:49:25.320 --> 00:49:27.690
And if you've ever mistyped one
of those required methods and then

00:49:27.760 --> 00:49:30.340
sat there for a while and gone,
why isn't my TableView working?

00:49:30.340 --> 00:49:34.260
That's where this can come in handy.

00:49:35.420 --> 00:49:38.420
So we're going to go through the
foundation and the app kit and

00:49:38.420 --> 00:49:42.640
define those as formal protocols
using the @required keyword

00:49:42.640 --> 00:49:43.920
and the @optional keyword.

00:49:43.920 --> 00:49:46.820
And this will be a way that we'll
also annotate the delegate and data

00:49:46.820 --> 00:49:51.250
source methods with those angle
brackets indicating protocol adoption

00:49:51.350 --> 00:49:54.170
so that you'll be able to get some
compiler and tool support out of making

00:49:54.170 --> 00:49:56.630
sure that you've got all of those
methods spelled correctly or actually

00:49:56.640 --> 00:49:59.510
implemented that have to be required.

00:50:03.400 --> 00:51:08.200
[Transcript missing]

00:51:08.290 --> 00:51:10.840
Ken Ferry, tomorrow morning,
bright and early at 9:00 AM,

00:51:10.840 --> 00:51:15.410
will talk about Cocoa tips and tricks
using Snow Leopard features effectively.

00:51:15.500 --> 00:51:17.020
This was actually labeled
as Leopard features.

00:51:17.110 --> 00:51:19.000
No, we're actually going to talk
about Snow Leopard features.

00:51:19.100 --> 00:51:21.780
Custom bindings,
some interesting things you can

00:51:21.780 --> 00:51:25.080
do with obviously 2.0 properties
and key value observing.

00:51:25.140 --> 00:51:30.190
He'll also talk a lot about some of
the drawing stuff that you can do.

00:51:30.510 --> 00:51:34.610
Leveraging Cocoa's layer-backed views,
tomorrow morning in the mission at 10:30.

00:51:34.890 --> 00:51:39.690
Troy Stevens will talk about subpixel
LCD anti-aliasing in the App Kit.

00:51:40.070 --> 00:51:42.630
Grouping and sequencing animations,
getting things to happen

00:51:42.630 --> 00:51:43.580
in the right order.

00:51:43.720 --> 00:51:45.880
Switching between layer-backed
and regular views.

00:51:45.980 --> 00:51:48.520
There are times to do it and
times maybe not to do it,

00:51:48.520 --> 00:51:49.680
and he'll talk about that.

00:51:49.820 --> 00:51:52.020
Mapping view to layer geometry
can be a little tricky.

00:51:52.020 --> 00:51:57.220
He'll have some tips for that
and also some performance ideas

00:51:57.320 --> 00:51:59.970
in the Cocoa drawing system.

00:52:00.820 --> 00:52:06.740
will be talking about
Cocoa performance techniques.

00:52:06.800 --> 00:52:10.500
These are a bunch of things we
haven't talked about before at WWDC.

00:52:10.500 --> 00:52:12.980
Multithreading atomicity
and synchronization in the

00:52:13.120 --> 00:52:14.950
collections and your objects.

00:52:15.040 --> 00:52:16.260
Computational complexity.

00:52:16.260 --> 00:52:19.400
He will also talk in
detail about the NSCache,

00:52:19.400 --> 00:52:22.860
NSPurgable data and
NSDiscardable content API.

00:52:22.860 --> 00:52:26.070
So all the new caching and purging
techniques that we're adopting

00:52:26.450 --> 00:52:31.930
in Cocoa in the AppKit and
Foundation and also some drawing stuff.

00:52:32.420 --> 00:52:36.260
Doug Davidson, right here in
Russian Hill tomorrow at 3:30.

00:52:36.420 --> 00:52:38.790
We'll talk about polishing
your Cocoa application.

00:52:38.810 --> 00:52:41.360
Once you get it working,
there are a lot of things you

00:52:41.360 --> 00:52:42.290
can do to really make it shine.

00:52:42.300 --> 00:52:43.830
And 64-bit readiness.

00:52:43.830 --> 00:52:48.110
You heard Bertrand's talk about asking
for plug-ins now to be 64 and 32-bit

00:52:48.110 --> 00:52:50.290
capable as well as the applications.

00:52:50.350 --> 00:52:52.200
So these are some things that
you'll be able to learn about there.

00:52:52.320 --> 00:52:56.790
Performance and responsiveness, security,
localization and internationalization,

00:52:56.790 --> 00:52:59.260
usability and accessibility
and scripting.

00:52:59.300 --> 00:53:03.290
I think Doug and James will probably
be talking as fast as I was here.

00:53:03.300 --> 00:53:09.300
And tomorrow also performance and
document-centric Cocoa applications.

00:53:09.300 --> 00:53:11.760
Our very own Mark Picciarelli
will be talking about

00:53:11.760 --> 00:53:15.340
concurrent document opening,
our NSURL usage everywhere in

00:53:15.430 --> 00:53:16.300
the Foundation and the App Kit.

00:53:16.320 --> 00:53:20.300
Fast document saving with the new
File Package API on File Wrapper.

00:53:20.300 --> 00:53:24.390
And all the sudden termination stuff
and how adopting sudden termination

00:53:24.400 --> 00:53:28.290
can really help your app as well
as the operating system as a whole.

00:53:28.300 --> 00:53:32.300
If you're just dying to meet us,
we have two labs remaining.

00:53:32.340 --> 00:53:38.140
The Carbon to 64-bit Cocoa Lab in
OS X Foundation's Lab B.

00:53:38.300 --> 00:53:41.270
As far as I can tell,
that's a fancy name for that back

00:53:41.430 --> 00:53:43.300
left corner when you walk in.

00:53:43.570 --> 00:53:48.250
And we also have a
Cocoa Open Lab tomorrow at 2:00.

00:53:48.290 --> 00:53:48.300
I'm sorry, tomorrow at 12:00.

00:53:48.300 --> 00:53:49.140
That's in London.

00:53:49.330 --> 00:53:50.300
And we have a
Cocoa Open Lab tomorrow at 2:00.

00:53:50.300 --> 00:53:50.300
I'm sorry, tomorrow at 12:00.

00:53:50.300 --> 00:53:54.100
Lab C, which is a fancy name for
the other back corner.

00:53:54.100 --> 00:53:56.860
So please come and ask
us questions there.

00:53:56.950 --> 00:53:58.540
For more information,
you can write to Mr.

00:53:58.540 --> 00:54:00.900
Derek Horn,
who is our Application Frameworks

00:54:00.940 --> 00:54:01.760
evangelist.

00:54:01.760 --> 00:54:04.730
And also we're going to be updating
the AppKit and Foundation release

00:54:04.730 --> 00:54:05.940
notes as we add new things.

00:54:05.940 --> 00:54:07.940
So please keep an eye out on those.

00:54:08.160 --> 00:54:11.520
And now we have time for some Q&A.
WEBVTT

00:00:19.100 --> 00:00:20.810
Good afternoon.

00:00:20.830 --> 00:00:26.020
There has never been a better
time to be a Mac developer.

00:00:26.130 --> 00:00:28.330
Now, why is that?

00:00:28.430 --> 00:00:32.780
Well, because we've been selling
tons and tons of computers.

00:00:32.780 --> 00:00:36.860
In fact, if you look at our growth rate,
the Mac growth rate

00:00:36.930 --> 00:00:41.480
compared to the PC industry,
we've outperformed the PC industry

00:00:41.580 --> 00:00:43.370
for the last two years.

00:00:43.510 --> 00:00:48.370
And it's kind of like 3X or 4X
for the last couple of quarters.

00:00:48.470 --> 00:00:52.450
And so the net result of this is
that we have a lot more people

00:00:52.450 --> 00:00:56.080
using Macs and using Mac OS X.

00:00:56.080 --> 00:00:59.430
In fact, if you look at the
installed base of Mac OS X,

00:00:59.430 --> 00:01:04.200
it's been going up and up
and up to 27.5 million.

00:01:04.200 --> 00:01:09.490
This is active users,
people who use Mac OS X day in, day out.

00:01:09.490 --> 00:01:14.740
And if you step back and look at
the earlier years of Mac OS X,

00:01:14.740 --> 00:01:20.260
the growth was due to people coming
from 9 and upgrading to Mac OS X.

00:01:20.380 --> 00:01:23.590
While in the last few years,
the growth has come from

00:01:23.640 --> 00:01:28.470
people using Windows switching
to a better OS to Mac OS X.

00:01:29.580 --> 00:01:34.640
So Mac OS X is doing great
as a software platform.

00:01:34.670 --> 00:01:37.260
And this is really fantastic
because there are not too many

00:01:37.370 --> 00:01:39.420
software platforms out there.

00:01:39.450 --> 00:01:47.160
Now, maybe the ancestor of software
platforms was Unix in the '70s.

00:01:47.570 --> 00:01:52.210
Unix was very strong for doing
backend kind of applications,

00:01:52.210 --> 00:01:54.600
but a little weak in the UI, of course.

00:01:54.600 --> 00:01:59.950
And with the Mac in 1984,
we created a new software platform,

00:01:59.950 --> 00:02:03.900
one that enabled GUI applications,
the kind of applications

00:02:03.910 --> 00:02:06.180
that you like to write,
of course.

00:02:07.000 --> 00:02:12.420
Now then Windows of course came in
the 90s and that was kind of the

00:02:12.420 --> 00:02:15.380
establishment of the Win32 API.

00:02:15.380 --> 00:02:20.660
And quite frankly Apple was a little
bit in turmoil in those days but

00:02:20.730 --> 00:02:25.030
we finally got our act together
and at the turn of the century

00:02:25.170 --> 00:02:27.780
we designed Mac OS X of course.

00:02:27.880 --> 00:02:33.940
We evolved Mac OS X and over the years
it has totally replaced the original Mac.

00:02:33.940 --> 00:02:39.940
Now seeing the success of Mac OS X of
course the giant up north worked

00:02:39.940 --> 00:02:42.410
on something called Longhorn.

00:02:42.810 --> 00:02:47.540
That was very ambitious, actually,
quite frankly, but didn't quite pan out,

00:02:47.540 --> 00:02:51.300
so they shrank it down to
something called Vista.

00:02:51.330 --> 00:02:56.100
And now some people are making a
business out of removing Vista.

00:02:56.100 --> 00:03:00.170
Let me get that kind of bigger.

00:03:06.300 --> 00:03:09.680
This is a store in New Hampshire that
charges to remove Vista.

00:03:09.760 --> 00:03:16.920
So this Vista thing wins 32 forever,
I guess, for better or for worse.

00:03:17.980 --> 00:03:26.000
So here we are at the beginning of 2008
with three major software platforms.

00:03:26.080 --> 00:03:31.300
That is platforms with millions of users
and a great market for your application.

00:03:31.350 --> 00:03:34.370
And I think this is a year
to remember because of course

00:03:34.510 --> 00:03:37.540
we introduced a new platform.

00:03:37.600 --> 00:03:41.960
That's the iPhone with the iPhone OS.

00:03:42.410 --> 00:03:46.040
And there are not so many times in
history or in the short history of

00:03:46.040 --> 00:03:50.710
computer science when a new platform
kind of gets introduced like that.

00:03:50.800 --> 00:03:54.430
So, of course,
I'm going to focus on the Mac,

00:03:54.430 --> 00:03:58.720
but I also talk about the
iPhone OS because those two

00:03:58.740 --> 00:04:01.500
platforms share a lot in common.

00:04:01.500 --> 00:04:08.010
In fact, if you look at the technologies,
a lot of the technologies underlying

00:04:08.010 --> 00:04:11.300
Mac OS are also underlying iPhone OS.

00:04:12.200 --> 00:04:15.040
So this is going to be what
I'm talking about today.

00:04:15.040 --> 00:04:18.820
I'm going to cover a
number of technologies.

00:04:18.820 --> 00:04:23.520
Now, when I dive into a technology,
I will try to tell

00:04:23.520 --> 00:04:29.300
what is the principles,
the philosophy, kind of the methodologies

00:04:29.350 --> 00:04:33.170
that we've used,
the goal for a given technology.

00:04:33.390 --> 00:04:36.690
Then I'll give an overview of the
technology because I know that there's

00:04:36.750 --> 00:04:41.530
a lot of new attendees this year,
new to the Mac or new to

00:04:41.530 --> 00:04:43.420
the iPhone or new to both.

00:04:43.570 --> 00:04:48.320
So I'll give an overview to kind of
state where we stand very briefly.

00:04:48.330 --> 00:04:53.580
And then I'll talk about some of our
future direction in that technology area.

00:04:55.060 --> 00:05:02.200
So this is our world of technology,
and let me dive into the first technology

00:05:02.200 --> 00:05:03.920
area that's also a software platform.

00:05:03.920 --> 00:05:09.900
And of course, I want to talk about Unix,
because it is kind of a well-kept

00:05:09.900 --> 00:05:12.670
secret that the Mac is actually Unix.

00:05:12.740 --> 00:05:17.540
And when you think Unix,
you may have in mind a

00:05:17.540 --> 00:05:20.400
computer like this one.

00:05:20.400 --> 00:05:24.340
That was my first Unix computer, a VAX,
way back then.

00:05:24.340 --> 00:05:28.420
And you may wonder,
so why did we pick Unix as

00:05:28.420 --> 00:05:33.300
kind of the basis of Mac OS and
then of the iPhone OS?

00:05:33.400 --> 00:05:37.090
And of course,
we did that because Unix provides

00:05:37.090 --> 00:05:39.380
a number of key advantages.

00:05:39.380 --> 00:05:41.880
The first one is reliability.

00:05:41.880 --> 00:05:46.080
Unix, after all,
is what powers the Internet.

00:05:46.080 --> 00:05:50.170
The vast majority of servers on
the Internet are Unix servers,

00:05:50.180 --> 00:05:52.980
which also plays in
another strength of Unix,

00:05:53.080 --> 00:05:54.100
which is network.

00:05:54.340 --> 00:05:59.570
Networking was invented kind
of for Unix machines and Unix

00:05:59.570 --> 00:06:01.570
machines to do networking,
right?

00:06:01.590 --> 00:06:04.330
Those two things have been
hand-in-hand for many years.

00:06:05.930 --> 00:06:09.450
Now another strength of Unix is security.

00:06:09.620 --> 00:06:13.400
This is obviously becoming more
and more important each year.

00:06:13.550 --> 00:06:18.730
And this is a strength of Unix because
for the critical pieces of code that

00:06:18.930 --> 00:06:22.740
control the security of a system,
those pieces of code have been

00:06:22.770 --> 00:06:28.740
scrutinized by a lot of people and have
been iterated so they are really safe.

00:06:29.400 --> 00:06:32.460
Now, Unix also has these
interesting characteristics,

00:06:32.520 --> 00:06:37.780
notably because it's so weak in UI,
that it forces you to really

00:06:37.830 --> 00:06:41.060
separate the UI from the non-UI.

00:06:41.070 --> 00:06:46.260
So it forces you to have a proper
layering of your application.

00:06:46.260 --> 00:06:51.180
And this actually, I think,
is turning into a big advantage.

00:06:51.840 --> 00:06:56.100
Now, Unix also provides kind of
the meat and potatoes of APIs.

00:06:56.100 --> 00:07:01.300
So all the basic APIs that you
use when you program are in Unix.

00:07:01.300 --> 00:07:04.980
You know,
all the APIs to access the file system,

00:07:04.980 --> 00:07:12.300
to allocate memory, even basic sorts,
you know, all those things are Unix APIs.

00:07:13.340 --> 00:07:17.590
So despite its age,
Unix is still very active and dynamic.

00:07:17.600 --> 00:07:20.380
There's a lot going on in the Unix space.

00:07:20.770 --> 00:07:25.120
And this is because of open source.

00:07:25.170 --> 00:07:29.560
The open source movement had
totally added new vitality to Unix,

00:07:29.560 --> 00:07:33.350
and lots of innovation
is taking place there.

00:07:33.430 --> 00:07:38.330
And we like to take a lot
from the open source world.

00:07:38.580 --> 00:07:44.500
In fact, all of our base systems,
the non-UI, is open source.

00:07:44.570 --> 00:07:48.580
But we also like to contribute
back to the open source world.

00:07:48.690 --> 00:07:52.260
And in recent years,
we've added a number of key

00:07:52.260 --> 00:07:55.300
APIs back into the open source.

00:07:55.370 --> 00:07:59.410
The one that I think you
know about is Bonjour,

00:07:59.450 --> 00:08:02.820
which is a way to have
services discovery,

00:08:02.820 --> 00:08:07.480
easy, zero configuration,
a way to administer your

00:08:07.480 --> 00:08:10.600
services or not administer them.

00:08:10.760 --> 00:08:14.620
We've added something called NotifyD,
which is to solve the

00:08:14.620 --> 00:08:16.880
problems of notifications.

00:08:16.880 --> 00:08:20.290
It's fast notifications,
point-to-point notifications,

00:08:20.290 --> 00:08:24.580
or broadcast notifications to
invalidate all your caches.

00:08:24.820 --> 00:08:28.880
And recently we've added LaunchD,
which is the process that

00:08:28.950 --> 00:08:30.860
launches other processes.

00:08:30.860 --> 00:08:34.600
And it has a number of facilities
to provide reliability,

00:08:34.600 --> 00:08:37.960
to provide timing services,
to provide laziness.

00:08:37.960 --> 00:08:40.350
It is the mother of all processes.

00:08:40.360 --> 00:08:43.510
That's PID number one.

00:08:44.890 --> 00:08:47.040
So this is what we've been
doing in recent years,

00:08:47.040 --> 00:08:48.700
adding those APIs.

00:08:48.720 --> 00:08:50.040
What are we working on now?

00:08:50.040 --> 00:08:52.180
What are the upcoming APIs?

00:08:52.220 --> 00:08:57.270
Well, one that I want to mention
is about cache management.

00:08:57.390 --> 00:08:59.800
And caches are very important.

00:08:59.800 --> 00:09:07.220
Most of the RAMs that you have in your
application is as a form of cache.

00:09:07.270 --> 00:09:10.220
But the challenge with caches, of course,
is when to flush it.

00:09:10.220 --> 00:09:13.850
And we provide a mechanism to do that.

00:09:14.780 --> 00:09:18.610
Another thing that we've added
is a way to easily and quickly

00:09:18.820 --> 00:09:20.960
terminate your application.

00:09:20.960 --> 00:09:23.330
Because it's kind of a shame
when you have such a powerful

00:09:23.330 --> 00:09:25.980
computer at your disposition,
you press power off,

00:09:25.980 --> 00:09:30.520
and then you have to wait, okay,
for the computer just to shut down.

00:09:30.520 --> 00:09:32.360
There has to be a better way.

00:09:32.360 --> 00:09:33.360
And in fact, there is.

00:09:33.360 --> 00:09:35.940
And we've added some APIs to do that.

00:09:36.810 --> 00:09:42.660
And then the last thing that I want
to mention is an event loop facility.

00:09:42.660 --> 00:09:47.100
Because when you look at all the
user interface centric applications,

00:09:47.100 --> 00:09:48.100
they have an event loop.

00:09:48.110 --> 00:09:51.450
But in fact, the demons also typically
have an event loop.

00:09:51.500 --> 00:09:56.020
And this event loop is
not embodied by any API.

00:09:56.020 --> 00:09:57.160
There's no facility.

00:09:57.160 --> 00:09:58.930
There's no standard way to do that.

00:09:59.160 --> 00:10:01.510
Let me dig a little further.

00:10:01.600 --> 00:10:08.700
What you want to do with an event loop is
to multiplex different sources of events.

00:10:08.720 --> 00:10:11.390
You don't want to necessarily
create a thread for each source,

00:10:11.390 --> 00:10:15.420
but you'd like them to be serialized
and managed in a way that makes sense.

00:10:15.420 --> 00:10:20.680
And to do that,
we introduce a new API that is

00:10:20.680 --> 00:10:24.900
called Grant Central Dispatch.

00:10:27.000 --> 00:10:36.900
[Transcript missing]

00:10:37.290 --> 00:10:41.740
But it can also manage a pool of jobs,
that is, things to do,

00:10:41.740 --> 00:10:46.440
not just response to events, you know,
computational things that you need to do.

00:10:46.440 --> 00:10:51.760
And what it will do automatically is to
create new threads as needed to handle

00:10:51.760 --> 00:10:54.290
all the things that you have to do.

00:10:57.800 --> 00:11:03.760
The jobs that you have can be sequential,
or you can specify that they

00:11:03.760 --> 00:11:07.220
can be executed in parallel,
and that's when new

00:11:07.230 --> 00:11:09.540
threads will be created.

00:11:09.540 --> 00:11:12.940
In essence,
Grand Central Dispatch is a foundation

00:11:12.940 --> 00:11:16.950
for distributing all the events,
but also a foundation

00:11:16.950 --> 00:11:19.600
for multi-threading.

00:11:19.600 --> 00:11:22.880
It is the mother of all threads.

00:11:23.570 --> 00:11:30.140
So we've developed a little
application to visualize how GCD works.

00:11:30.430 --> 00:11:32.520
So let me show that to you.

00:11:42.600 --> 00:11:49.220
What I have here on the left is
a visualization of event sources,

00:11:49.270 --> 00:11:51.400
events as little color balls.

00:11:51.400 --> 00:11:53.710
The events come in one
by one or in trends,

00:11:53.710 --> 00:11:57.840
in which case they need
to be executed serially.

00:11:57.840 --> 00:12:00.600
And GCD is this thing kind
of in the middle on the right

00:12:00.700 --> 00:12:02.260
that serializes the event.

00:12:02.540 --> 00:12:05.130
Okay, this is not very fancy.

00:12:05.290 --> 00:12:09.150
Let's go parallel now and let's
say I have a four core machine

00:12:09.150 --> 00:12:14.610
and now you have four lanes,
four tubes, there are the threads that

00:12:14.610 --> 00:12:16.900
will get created by GCD.

00:12:17.580 --> 00:12:21.860
I can change the number of processors,
which of course changes

00:12:21.860 --> 00:12:23.380
the number of lanes.

00:12:23.380 --> 00:12:26.180
And you may say, okay,
so I can do all that

00:12:26.430 --> 00:12:30.540
with a P-threads library,
a library on top of P-threads.

00:12:30.540 --> 00:12:31.700
And that's absolutely right.

00:12:31.700 --> 00:12:33.660
You could do that.

00:12:33.660 --> 00:12:38.270
But what you cannot do when
you have P-threads is have GCD,

00:12:38.320 --> 00:12:42.540
your library,
look at the state of the whole system and

00:12:42.540 --> 00:12:48.040
back off when there's kind of pressure
on the CPU due to other processes.

00:12:48.040 --> 00:12:49.860
And this is what GCD does.

00:12:49.860 --> 00:12:54.150
It has its hands with the kernel
scheduler and it knows when to back

00:12:54.260 --> 00:12:59.540
off and when to actually lower the
number of threads it uses dynamically

00:12:59.540 --> 00:13:02.420
to obviously optimize efficiency.

00:13:02.420 --> 00:13:05.350
And when the pressure gets released,
of course,

00:13:05.360 --> 00:13:07.620
it uses the full number of threads.

00:13:07.620 --> 00:13:10.870
So this is GCD.

00:13:18.840 --> 00:13:22.420
So GCD is a fundamental
brick we're adding to Unix.

00:13:22.420 --> 00:13:26.350
And again, you know, when you think Unix,
you may have in mind

00:13:26.410 --> 00:13:28.400
a really old computer.

00:13:28.400 --> 00:13:32.460
But in fact,
the sexiest Unix boxes out there are

00:13:32.460 --> 00:13:37.160
of course a MacBook Air and an iPhone.

00:13:38.840 --> 00:13:44.050
So that was a brief overview of Unix.

00:13:44.140 --> 00:13:50.750
Let's dive into another technology area,
one that has to do with APIs,

00:13:50.950 --> 00:13:54.730
APIs that you use day in, day out.

00:13:59.500 --> 00:14:04.200
And I want to talk here about
our frameworks and about Cocoa.

00:14:04.370 --> 00:14:08.000
Now, Cocoa is the name for
our framework stack.

00:14:08.100 --> 00:14:12.160
And it's not just ordinary
frameworks that we have.

00:14:12.240 --> 00:14:16.300
They are object-oriented frameworks.

00:14:16.390 --> 00:14:19.970
Hence the name Cocoa.

00:14:21.070 --> 00:14:27.540
So it still is a surprise to me
how much code gets written in

00:14:27.540 --> 00:14:30.180
non-object-oriented frameworks,
you know,

00:14:30.180 --> 00:14:32.360
in things like C and all that stuff.

00:14:32.360 --> 00:14:35.400
It is well-known and it has been
well-known for many years that when

00:14:35.510 --> 00:14:40.600
you write in object-oriented style,
okay, with an object-oriented library,

00:14:40.600 --> 00:14:42.400
you get a major leg up.

00:14:42.400 --> 00:14:45.710
And you don't need to reinvent the wheel.

00:14:45.720 --> 00:14:49.820
You have a rich toolbox,
a higher-level toolbox that provides

00:14:49.920 --> 00:14:55.360
a lot of functionality with kind
of behaviors that are built in.

00:14:56.240 --> 00:15:02.580
You can also reuse code when you
have an object-oriented framework.

00:15:02.660 --> 00:15:06.260
The primary means, of course,
of reusing code is subclassing,

00:15:06.260 --> 00:15:08.440
but that's kind of meta-reusing.

00:15:08.440 --> 00:15:12.860
That's kind of the patterns
gets always reused.

00:15:12.860 --> 00:15:14.930
So this is definitely true in Cocoa.

00:15:14.930 --> 00:15:17.760
You always have the
same patterns coming up,

00:15:17.890 --> 00:15:22.780
the same way we structure our objects,
we put together our classes.

00:15:22.780 --> 00:15:25.060
And so everything is very predictable.

00:15:25.070 --> 00:15:27.320
The naming is very predictable.

00:15:27.320 --> 00:15:32.790
When you use a class for the first time,
you can guess the method names, okay,

00:15:32.900 --> 00:15:36.390
directly from your idea
of what the class does.

00:15:36.970 --> 00:15:41.340
We also have a very
evolved set of classes.

00:15:41.340 --> 00:15:44.940
If you count Next Step,
I think this is kind of third generation.

00:15:44.940 --> 00:15:47.260
There's a little bit of Next Step.

00:15:47.330 --> 00:15:50.590
There's a little bit of the original
Mac Toolbox and a little bit of

00:15:50.660 --> 00:15:52.900
knowledge that we gained over the years.

00:15:52.930 --> 00:15:55.970
And all that is in Cocoa.

00:15:56.130 --> 00:16:01.620
To sum it up, for me, and this is a very
personal view of Cocoa,

00:16:01.620 --> 00:16:04.760
but Cocoa is very elegant.

00:16:04.760 --> 00:16:05.980
It's very symmetrical.

00:16:06.060 --> 00:16:07.560
It's very orthogonal.

00:16:07.560 --> 00:16:12.980
You are not finding the same portion of
API in different places of the API set.

00:16:12.980 --> 00:16:17.020
And that is very pleasing
when you use those APIs.

00:16:17.680 --> 00:16:19.960
Now, what is Cocoa made of?

00:16:19.990 --> 00:16:25.320
Okay, so at the lowest level,
we have something called foundation,

00:16:25.610 --> 00:16:27.740
which is for non-UI code.

00:16:27.740 --> 00:16:31.090
Above that,
we have something called the app kit

00:16:31.250 --> 00:16:36.310
that provides all the widgetry that
you expect in a Mac OS application.

00:16:36.320 --> 00:16:40.570
And above that,
we put a number of specific frameworks

00:16:40.570 --> 00:16:43.290
with a specific functionality.

00:16:43.360 --> 00:16:47.660
And then, of course,
your application sits on top of this.

00:16:47.660 --> 00:16:55.080
So let me go layer by layer and talk a
little more about what these things are.

00:16:55.100 --> 00:16:57.890
So let's start with foundation.

00:16:57.900 --> 00:17:01.770
So foundation provides all
the basic data structures,

00:17:01.850 --> 00:17:06.800
you know, all the bag of bytes,
the string, which sounds very simple,

00:17:06.940 --> 00:17:11.330
although nowadays with Unicode
and collation and all that stuff,

00:17:11.500 --> 00:17:15.290
strings are no longer this
very simplistic thing.

00:17:15.300 --> 00:17:17.230
And all the backpacks.

00:17:17.680 --> 00:17:20.950
So you have all the basic
data structures you expect,

00:17:20.950 --> 00:17:23.650
you know, all the collections, arrays,
dictionary, and so forth.

00:17:24.620 --> 00:17:27.520
There's also in foundation access
to a lot of functionalities,

00:17:27.520 --> 00:17:32.460
that system functionality,
a way to localize your code,

00:17:32.650 --> 00:17:35.140
access to what computer
you're running on,

00:17:35.140 --> 00:17:39.280
okay, give me some information about
that computer and so forth.

00:17:39.880 --> 00:17:43.240
And that's the run loop,
which is kind of the ancestor, of course,

00:17:43.270 --> 00:17:46.680
of GCD, of Grand Central Dispatch.

00:17:46.790 --> 00:17:49.290
So that's a brief overview of Foundation.

00:17:49.360 --> 00:17:53.110
Now, above it, you have the app kit.

00:17:53.100 --> 00:18:52.600
[Transcript missing]

00:18:52.790 --> 00:18:57.340
The App Kit also proposes an
application infrastructure so that

00:18:57.360 --> 00:19:01.240
you don't need to reinvent the
wheel when you write an application.

00:19:01.240 --> 00:19:05.000
You can just focus on the piece
of code that is unique to your

00:19:05.230 --> 00:19:11.960
application and all the rest you get via
subclassing or via automatic behaviors.

00:19:12.130 --> 00:19:16.220
And many Mac OS applications are
document-centric applications.

00:19:16.220 --> 00:19:19.380
And so there's also a facility,
a document architecture,

00:19:19.510 --> 00:19:22.280
so that you can just subclass
the generic document,

00:19:22.300 --> 00:19:25.100
and suddenly there you have your
document-centric application

00:19:25.100 --> 00:19:27.860
with very little code.

00:19:28.000 --> 00:19:31.490
So that's the concept behind the AppKit.

00:19:31.850 --> 00:19:36.040
Now moving up,
we have specific frameworks,

00:19:36.080 --> 00:19:40.030
all kinds of specific frameworks,
specific frameworks to access

00:19:40.160 --> 00:19:43.270
the data that is accessed
by the system applications,

00:19:43.270 --> 00:19:47.850
you know, the calendar data and so forth,
the address data,

00:19:47.960 --> 00:19:54.720
frameworks to access the specific kind
of hardware functionality and so forth.

00:19:54.720 --> 00:19:58.200
And one question that I often
get from some of you is,

00:19:58.200 --> 00:20:01.610
okay, what about functionality XYZ?

00:20:01.610 --> 00:20:06.560
Okay, why isn't XYZ available
as an API on Mac OS?

00:20:06.560 --> 00:20:12.370
And so this brings a question of, okay,
which frameworks do we make available?

00:20:12.610 --> 00:20:18.160
And fundamentally, it is our mission to
enable your application.

00:20:18.310 --> 00:20:20.720
So we focus on enablement.

00:20:20.910 --> 00:20:22.430
I didn't say convenience here.

00:20:22.580 --> 00:20:23.350
I say enablement.

00:20:23.360 --> 00:20:25.770
That is,
if you are prevented from doing something

00:20:26.070 --> 00:20:31.420
because some functionality is not there
and there's no public way to get to it,

00:20:31.510 --> 00:20:34.740
we really want to solve that need.

00:20:35.120 --> 00:20:40.310
But at the same time,
we know that APIs have a very long life.

00:20:40.370 --> 00:20:44.120
APIs live forever,
and we like to preserve binary

00:20:44.120 --> 00:20:47.120
compatibility at all costs.

00:20:47.120 --> 00:20:49.920
And so we want to make sure
that all the APIs that we

00:20:49.920 --> 00:20:51.880
have are APIs we can maintain.

00:20:51.880 --> 00:20:55.300
And sometimes, we can't be sure of that.

00:20:55.380 --> 00:20:58.420
Maybe we know that there's some
hardware that's coming up that's not

00:20:58.420 --> 00:21:00.240
going to have that hardware feature.

00:21:00.290 --> 00:21:03.760
Or maybe there's a piece of
code we are not too proud of,

00:21:03.800 --> 00:21:07.940
that we haven't quite figured
out how to implement it right.

00:21:08.040 --> 00:21:10.320
In that case, we have Stain.

00:21:11.040 --> 00:21:14.260
Once we've decided to
provide a functionality,

00:21:14.420 --> 00:21:15.880
we want to use it ourselves.

00:21:15.940 --> 00:21:18.700
That's the dog food principle,
because we want to make

00:21:18.700 --> 00:21:19.880
sure it's just right.

00:21:20.060 --> 00:21:25.570
So we like to use that API,
this framework, in our own applications,

00:21:25.610 --> 00:21:29.610
system applications,
and we like to iterate with your help,

00:21:29.760 --> 00:21:34.380
with the feedback that you can
provide during seeds and so forth.

00:21:34.500 --> 00:21:40.600
[Transcript missing]

00:21:42.180 --> 00:21:48.830
So with that, we always add new
APIs and new frameworks.

00:21:48.890 --> 00:21:50.040
We'll be adding a few.

00:21:50.040 --> 00:21:55.150
One that I want to mention,
because the icon is so wonderful,

00:21:55.150 --> 00:21:58.230
is the Quick Look and the functionality,
too.

00:21:58.300 --> 00:22:00.490
It's a Quick Look framework.

00:22:00.560 --> 00:22:04.430
Quick Look is this easy way when you
are browsing for files in Finder,

00:22:04.430 --> 00:22:06.960
you press Paste,
and suddenly you can see a

00:22:07.020 --> 00:22:08.980
preview of your document.

00:22:09.040 --> 00:22:12.590
And this is such a nice functionality
that I think you should build that

00:22:12.670 --> 00:22:14.290
in a number of your applications.

00:22:14.320 --> 00:22:17.580
And we want to provide
you an API to do that.

00:22:22.000 --> 00:22:27.640
Now, we're adding entire frameworks,
but we also add lots of little

00:22:27.710 --> 00:22:29.500
APIs throughout the stack.

00:22:29.630 --> 00:22:30.980
Okay, we always do that.

00:22:31.120 --> 00:22:34.370
So, for example,
since we shipped Leopard,

00:22:34.380 --> 00:22:41.130
we've added already something like
750 new methods throughout the stack.

00:22:41.540 --> 00:22:46.040
This is to fill little gaps and to enable
you with one functionality or another.

00:22:46.040 --> 00:22:49.350
We also have another thrust here.

00:22:49.590 --> 00:22:54.040
We want to make sure that if
you develop a Cocoa application,

00:22:54.040 --> 00:23:01.230
you'd never need to go to the old API,
the old toolbox that is called Carbon.

00:23:01.230 --> 00:23:01.230
And

00:23:01.450 --> 00:23:07.700
As you know, we are putting Carbon on
a path for obsolescence.

00:23:07.870 --> 00:23:10.700
And we want to make sure
that your Cocoa application

00:23:10.700 --> 00:23:14.540
can be totally Carbon free.

00:23:22.520 --> 00:23:27.680
This is what we're doing with Cocoa,
a very, very high-level 10,000-foot

00:23:27.680 --> 00:23:30.640
overview of Cocoa,
and this is for the Mac.

00:23:30.640 --> 00:23:32.790
Now, what about the iPhone?

00:23:32.790 --> 00:23:38.940
Well, the stack is, of course, very,
very similar and shared in many cases.

00:23:38.940 --> 00:23:41.700
Instead of Cocoa,
it's called Cocoa Touch.

00:23:41.760 --> 00:23:44.560
At the bottom, you have Foundation.

00:23:44.560 --> 00:23:48.790
It's the same Foundation that
provide all the same facilities.

00:23:48.890 --> 00:23:53.200
And this is really important because
if you have an application that has,

00:23:53.200 --> 00:23:57.680
you know, like the Iceberg earlier,
that has a lot of non-UI code, okay,

00:23:57.680 --> 00:24:01.910
that non-UI code can be exactly the
same between your Mac application

00:24:02.230 --> 00:24:04.560
and your iPhone application.

00:24:05.660 --> 00:24:11.500
Above that,
the app kit turns into UI kit.

00:24:11.580 --> 00:24:16.440
Obviously, the widgetry is different
because the UI is different.

00:24:16.440 --> 00:24:21.520
But it's the same paradigm,
the MVC paradigm underneath it all.

00:24:21.520 --> 00:24:25.480
And so you have classes that parallel
the classes that you find on Mac OS.

00:24:25.480 --> 00:24:29.860
So if you are familiar with the Mac,
you'll have no trouble with

00:24:29.860 --> 00:24:32.360
the UI kit set of classes.

00:24:32.360 --> 00:24:35.450
And just like on the Mac,
there's an application architecture

00:24:35.450 --> 00:24:38.380
so that you don't need to reinvent
the wheel to do an application.

00:24:38.380 --> 00:24:42.340
In fact, you saw the demo that Scott did
this morning where an application

00:24:42.350 --> 00:24:46.680
was built from scratch from,
you know, new application in Xcode.

00:24:47.640 --> 00:24:51.820
Now, there's no document
architecture with UIKit,

00:24:51.820 --> 00:24:54.880
but of course we have
other things like touch,

00:24:54.880 --> 00:24:54.900
okay?

00:24:54.940 --> 00:24:58.540
Touch built in throughout the UIKit.

00:24:59.400 --> 00:25:01.760
So that's UIKit.

00:25:01.850 --> 00:25:05.790
And on top of UIKit,
you have a number of frameworks,

00:25:05.930 --> 00:25:09.910
just like for the Macs,
but that are specific to the iPhone.

00:25:09.910 --> 00:25:13.240
Two that I want to
mention is CoreLocation,

00:25:13.240 --> 00:25:16.940
that has been demonstrated
many times this morning,

00:25:16.940 --> 00:25:21.790
and the accelerometer, again,
that is -- that apparently

00:25:21.800 --> 00:25:24.480
you love using already.

00:25:25.060 --> 00:25:30.440
So this is our stack, Cocoa, Cocoa Touch,
to create Mac applications

00:25:31.030 --> 00:25:34.150
or iPhone applications.

00:25:34.740 --> 00:25:39.850
And of course, this is kind of the main
focus of this conference.

00:25:39.980 --> 00:25:46.610
There are over 40 sessions that
span Cocoa and Cocoa Touch.

00:25:46.720 --> 00:25:51.420
So this was frameworks.

00:25:51.520 --> 00:25:55.170
Now let's go into
another technology area.

00:26:02.020 --> 00:26:04.530
This is the teapot technology area.

00:26:04.630 --> 00:26:10.690
How to color a teapot,
how to apply textures to a teapot,

00:26:10.690 --> 00:26:16.640
how to transform a teapot,
how to modify the teapot, and so forth.

00:26:16.720 --> 00:26:19.480
Of course,
I want to talk here about graphics.

00:26:19.940 --> 00:26:26.130
Now, when we designed Micro S10 back
at the turn of the century,

00:26:26.180 --> 00:26:30.580
we knew we wanted to have a brand new UI,
Aqua.

00:26:30.580 --> 00:26:35.700
And we knew we couldn't do this
kind of UI that didn't exist

00:26:35.700 --> 00:26:41.460
in those days without really
solid graphics underpinnings.

00:26:41.500 --> 00:26:45.350
We wanted to do effects, you know,
like the genie effect,

00:26:45.480 --> 00:26:47.790
never done before as part of the US.

00:26:47.880 --> 00:26:49.920
We knew that we wanted to do graphics.

00:26:49.920 --> 00:26:53.610
We knew we wanted to have a high
level of compositing going on,

00:26:53.610 --> 00:26:55.280
you know, at all times.

00:26:55.280 --> 00:26:59.120
And so we built a number
of technologies like our

00:26:59.120 --> 00:27:05.280
Windows Server that manages all the
windows of all the apps on the screen.

00:27:05.280 --> 00:27:09.160
Like the ability to have multiple
client-side drawing libraries.

00:27:09.210 --> 00:27:12.260
And we had, in addition, some great ones.

00:27:12.260 --> 00:27:17.040
And compositing built in all this, okay,
definitely from the lowest

00:27:17.040 --> 00:27:19.180
level to the highest level.

00:27:19.350 --> 00:27:23.480
Now, we also made another bet way back
then when we designed Micro S10.

00:27:23.500 --> 00:27:29.470
It's to bet on hardware acceleration
because we could see coming

00:27:29.470 --> 00:27:32.340
a lot of power in those GPUs.

00:27:32.340 --> 00:27:36.600
And so, we decided to build
in right into the U.S.

00:27:36.600 --> 00:27:37.480
OpenGL.

00:27:37.480 --> 00:27:40.490
And, of course,
what we had in mind then was to do games,

00:27:40.490 --> 00:27:41.020
okay?

00:27:41.020 --> 00:27:46.060
And this is what you've been doing way
back then is a lot of OpenGL games.

00:27:46.060 --> 00:27:49.730
But we knew that we could
do a little more with that.

00:27:50.000 --> 00:27:55.110
And, in fact, by the release in 2002,
we had built OpenGL even

00:27:55.170 --> 00:27:56.800
deeper in the U.S.

00:27:56.800 --> 00:28:03.220
And we started to use the facilities
that it provided to do effects like

00:28:03.220 --> 00:28:06.500
expose or like fast user switching.

00:28:06.500 --> 00:28:09.870
This was all made possible
because we slight open -- we

00:28:09.900 --> 00:28:14.800
sliced OpenGL underneath the
Windows server to accelerate the --

00:28:14.800 --> 00:28:19.770
the fundamental window operations.

00:28:20.240 --> 00:28:24.280
And in some sense,
we were kind of lucky to have bet

00:28:24.280 --> 00:28:29.560
a lot of the technology on GPUs
because the graph for the number

00:28:29.560 --> 00:28:35.200
of gigaflops you get from a GPU has
kept going up and up and up and up.

00:28:35.200 --> 00:28:40.630
And as you know, Moore's law has kind of
stalled on a mono processor.

00:28:40.650 --> 00:28:45.060
They haven't increased in megahertz
every year as they used to.

00:28:45.060 --> 00:28:47.430
On the other hand,
the GPUs have continued to be

00:28:47.430 --> 00:28:50.080
exponential and probably are
going to do that for a while.

00:28:52.040 --> 00:28:58.090
So along with more power in
terms of raw kind of gigaflops,

00:28:58.090 --> 00:29:00.120
the GPUs turned programmable.

00:29:00.120 --> 00:29:05.140
That meant that you could download a
little piece of code onto the GPU that

00:29:05.150 --> 00:29:07.860
would do the program that you want.

00:29:07.860 --> 00:29:13.680
And so we used that for a new
technology that we called Core Image.

00:29:13.680 --> 00:29:15.000
And Core Image is about that.

00:29:15.000 --> 00:29:20.150
It's about specifying on the client
side what the effect that you want,

00:29:20.150 --> 00:29:23.680
the imaging effect that you want,
and then downloading

00:29:23.680 --> 00:29:28.680
that code to the GPU,
which gets executed really, really fast.

00:29:28.680 --> 00:29:33.760
And of course, all kinds of applications
have leverage of Core Image,

00:29:33.990 --> 00:29:36.740
including a number of your applications.

00:29:36.740 --> 00:29:42.620
This is, I think, Pixelmator that uses
Core Image to its advantage.

00:29:43.510 --> 00:29:48.390
So this was great,
applying effects to images.

00:29:48.460 --> 00:29:52.920
But we knew we wanted to
push that even further.

00:29:53.010 --> 00:29:55.220
How about using that in time?

00:29:55.240 --> 00:29:59.100
That is, at every frame,
we wanted to apply an effect.

00:29:59.180 --> 00:30:02.780
Essentially, that's kind of like making
a movie in real time.

00:30:02.840 --> 00:30:05.500
We wanted to use the time dimension.

00:30:05.680 --> 00:30:09.070
And what was great is
that the latest GPUs,

00:30:09.130 --> 00:30:11.550
the ones that arrived on the
market a couple years ago,

00:30:11.620 --> 00:30:14.870
enabled that, enabled real time effects.

00:30:14.950 --> 00:30:18.070
And we created a new
technology to leverage that.

00:30:18.080 --> 00:30:21.120
That is called core animation.

00:30:21.300 --> 00:30:24.860
Core animation is best on all
the knowledge that we've gained

00:30:25.130 --> 00:30:28.980
by doing lots of animation in
lots of the system application,

00:30:28.980 --> 00:30:32.340
in some system facilities,
and other apps.

00:30:32.450 --> 00:30:35.150
And we finally cracked the code here.

00:30:35.210 --> 00:30:39.280
And the code is to let
people not specify,

00:30:39.310 --> 00:30:44.270
or to, by default,
make the animation implicit.

00:30:44.520 --> 00:30:46.960
That is, you set your state.

00:30:46.960 --> 00:30:49.200
And automatically, the animation happens.

00:30:49.210 --> 00:30:52.900
Rather than trying to
put timers and cadence,

00:30:52.900 --> 00:30:55.070
everything that needs
to happen to your scene,

00:30:55.130 --> 00:30:56.520
you just specify the state.

00:30:56.520 --> 00:30:58.980
And the system does that for you.

00:30:59.280 --> 00:31:04.590
And we've started to use that to
our advantage throughout Leopard.

00:31:04.800 --> 00:31:09.310
Of course,
Time Machine uses Core Animation.

00:31:10.210 --> 00:31:14.600
And there's different facilities
in Leopard that use co-animation.

00:31:14.700 --> 00:31:18.600
Even other product lines
started to use co-animation.

00:31:18.690 --> 00:31:23.790
Apple TV, for example,
uses co-animation for its menu subsystem.

00:31:25.010 --> 00:31:29.220
And of course,
the iPhone uses Core Animation.

00:31:29.290 --> 00:31:34.120
In fact,
the iPhone created Core Animation.

00:31:34.130 --> 00:31:38.970
We first did Core Animation on the
iPhone because we knew that we wanted

00:31:39.010 --> 00:31:42.480
to have a very fluid user interface.

00:31:42.520 --> 00:31:45.170
And we also knew that we wanted
something super efficient

00:31:45.220 --> 00:31:49.140
because the GPU that you have,
the GPU cores that you have on the

00:31:49.220 --> 00:31:54.690
iPhone is nowhere near the kind
of GPU that you have on a Mac.

00:31:55.330 --> 00:32:01.860
And so, co-animation provided this ease
of specification of the animation

00:32:02.610 --> 00:32:06.200
with the efficiency that we needed.

00:32:07.340 --> 00:32:10.800
Okay, so this is all kind of the past.

00:32:10.870 --> 00:32:16.540
Now, where we stand today,
one teraflop is in sight.

00:32:16.590 --> 00:32:19.410
Now, this is amazing, right?

00:32:19.420 --> 00:32:21.970
I mean,
who would have guessed 10 years ago

00:32:22.030 --> 00:32:27.590
that we would talk of a teraflop
ability to compute data on a desktop,

00:32:27.590 --> 00:32:31.040
okay,
something that you can have on your desk?

00:32:31.580 --> 00:32:34.340
So what do we want to do with that power?

00:32:34.370 --> 00:32:39.870
Well, we want to unleash that
power for everyone,

00:32:39.890 --> 00:32:43.780
not just for graphics.

00:32:45.270 --> 00:32:50.010
And so today,
I'm pleased to introduce a new

00:32:50.010 --> 00:32:55.950
technology that is called OpenCL.

00:32:57.200 --> 00:33:14.800
[Transcript missing]

00:33:15.300 --> 00:33:37.300
[Transcript missing]

00:33:37.610 --> 00:33:40.980
For the language, we started with C.

00:33:41.100 --> 00:33:45.400
So OpenCL is mostly C, C99.

00:33:45.400 --> 00:33:49.440
We applied some restrictions
to pointers because GPUs cannot

00:33:49.440 --> 00:33:53.380
follow pointers very efficiently,
and you cannot parallelize

00:33:54.090 --> 00:33:56.520
some pointer-based code.

00:33:56.520 --> 00:34:00.150
On the other hand, we enhanced vectors.

00:34:00.150 --> 00:34:02.710
So a vector is essentially
an array of number,

00:34:02.740 --> 00:34:05.700
but we added some semantics to vectors.

00:34:05.920 --> 00:34:10.380
For example, that no one can go behind
the back of the GPU,

00:34:10.420 --> 00:34:15.890
say, and change a vector when the
main code is acting on it.

00:34:16.380 --> 00:34:18.760
We added some control flow primitives.

00:34:18.790 --> 00:34:23.040
In fact, we added one primitive,
which is barriers, to make sure you can

00:34:23.050 --> 00:34:24.680
synchronize your code.

00:34:24.940 --> 00:34:27.780
And we also acknowledge the
fact that in modern computers,

00:34:27.800 --> 00:34:29.780
you have different memory subsystems.

00:34:29.820 --> 00:34:33.480
You have typically one for the CPU,
one for the GPU.

00:34:33.850 --> 00:34:38.460
And so we added memory
address qualifiers.

00:34:40.130 --> 00:34:46.430
In terms of the runtime, we are compiling
OpenCL code down to native.

00:34:46.540 --> 00:34:52.350
And it's a just-in-time compilation,
so it's all totally dynamic.

00:34:52.730 --> 00:34:56.760
Because of that,
it works for CPUs as well as GPUs.

00:34:57.130 --> 00:35:03.350
So it works with one CPU,
with multiple CPUs,

00:35:03.800 --> 00:35:22.000
[Transcript missing]

00:35:22.690 --> 00:35:28.510
And also, it works with any
combinations of CPUs and GPUs,

00:35:28.580 --> 00:35:32.430
because underlying OpenCL,
you have the same infrastructure

00:35:33.390 --> 00:35:36.230
that is in Grand Central Dispatch.

00:35:37.730 --> 00:35:43.270
So what I'd like to do at this
point is to invite John Stauffer,

00:35:43.270 --> 00:35:46.550
who is the director for
graphics and imaging,

00:35:46.550 --> 00:35:51.200
to demonstrate OpenCL to us.

00:35:55.010 --> 00:35:56.240
So thank you Bertrand.

00:35:56.290 --> 00:36:01.730
What's on the screen here is basically
16,000 stars each feeling the

00:36:01.730 --> 00:36:04.360
gravitational effects of each other.

00:36:04.360 --> 00:36:07.520
And so this is an N squared
mathematical problem.

00:36:07.520 --> 00:36:10.320
Really, really computationally expensive.

00:36:10.480 --> 00:36:14.230
And the mode I'm running it in right
now is what you would get if you

00:36:14.310 --> 00:36:17.630
were to take that algorithm and see,
compile it and run it.

00:36:17.690 --> 00:36:18.010
Okay.

00:36:18.010 --> 00:36:21.450
And we're getting about two gigaflops
of compute power as you can see from

00:36:21.550 --> 00:36:23.610
the gauge in the right hand corner here.

00:36:23.740 --> 00:36:27.800
Gigaflops being billions of floating
point operations per second.

00:36:27.800 --> 00:36:30.330
So now what we're going to do is
we're going to take that piece of

00:36:30.330 --> 00:36:35.100
code and we're going to host it up
into OpenCL and we're going to use

00:36:35.100 --> 00:36:37.710
the language features of OpenCL

00:36:39.250 --> 00:36:42.490
So this is still running on
a single core on the CPU,

00:36:42.490 --> 00:36:46.080
but we've gone from 2
gigaflops to 11 gigaflops.

00:36:46.080 --> 00:36:49.980
Now, with OpenSeal, as Bertrand said,
it's on top of Grand Central Dispatch.

00:36:50.040 --> 00:36:53.660
So what I can simply do is just
tell OpenSeal to run this across

00:36:53.660 --> 00:36:55.560
all the cores in the system.

00:36:55.640 --> 00:37:00.920
So now we've gone from 2 gigaflops to 66.

00:37:01.130 --> 00:37:03.520
But OpenSeal runs across CPUs and GPUs.

00:37:03.560 --> 00:37:07.890
I take that same code
and run it on the GPU.

00:37:07.890 --> 00:37:09.900
So let's do that.

00:37:09.900 --> 00:37:13.880
So now we've gone from
2 gigaflops to 205.

00:37:21.840 --> 00:37:24.850
And you thought that was great.

00:37:25.080 --> 00:37:27.360
It can run across CPUs and GPUs.

00:37:27.360 --> 00:37:29.380
So I've got one more.

00:37:29.440 --> 00:37:34.400
I can run it across the CPUs and GPUs
at the same time going to 240 gigaflops.

00:37:34.530 --> 00:37:39.320
So I've gone 120 times faster
than the original code.

00:37:39.320 --> 00:37:41.720
So, you know,
we started asking ourselves,

00:37:41.760 --> 00:37:45.050
what kind of interesting things
can we do with this horsepower,

00:37:45.050 --> 00:37:48.530
this computational horsepower
that OpenSeal gives us?

00:37:48.700 --> 00:37:53.080
Well, one thing we did is we simulated
the collision of the Andromeda

00:37:53.080 --> 00:37:54.700
in the Milky Way galaxy.

00:37:54.700 --> 00:37:59.680
And the blue dot is Earth.

00:38:04.000 --> 00:38:06.520
So thank you.

00:38:06.900 --> 00:38:10.210
We think that OpenCL is going
to let you get access to all the

00:38:10.260 --> 00:38:12.860
great horsepower in the system.

00:38:12.860 --> 00:38:14.490
Thank you very much.

00:38:23.200 --> 00:38:26.200
Thanks, John, for showing us our future.

00:38:26.200 --> 00:38:34.780
So we have a wealth of
graphical technology.

00:38:35.300 --> 00:38:44.480
OpenGL, CoreImage, CoreAnimation,
and now we're introducing OpenCL.

00:38:44.480 --> 00:38:48.400
But again,
OpenCL is not just a graphics technology,

00:38:48.400 --> 00:38:54.390
something you can use for a wide
range of computational applications.

00:38:55.270 --> 00:39:01.900
So this was kind of a little history and
heads up on where we stand with graphics.

00:39:01.960 --> 00:39:07.190
There's, of course,
another technology area which is

00:39:07.300 --> 00:39:12.240
very closely related to graphics,
and that's how to display movies.

00:39:12.240 --> 00:39:17.400
And we usually in this
conference display Pixar movies.

00:39:19.720 --> 00:39:23.120
Of course,
I want to talk about QuickTime.

00:39:23.210 --> 00:39:26.170
Now, QuickTime is really great.

00:39:26.250 --> 00:39:31.680
It's QuickTime created kind of the
whole digital media kind of industry.

00:39:31.710 --> 00:39:35.270
It's the technology that
was foundational many,

00:39:35.270 --> 00:39:41.260
many years ago and that we still use,
that we've kept adding to over the years.

00:39:41.260 --> 00:39:44.260
So, one thing that's really great
about QuickTime is that it

00:39:44.260 --> 00:39:47.310
supports all kinds of formats,
you know,

00:39:47.310 --> 00:39:53.140
all the modern formats that matter,
a whole bunch of legacy formats,

00:39:53.140 --> 00:39:57.300
and even some experimental formats
that never really mattered.

00:39:57.300 --> 00:40:01.240
Now, QuickTime is really good
because it can do everything.

00:40:01.240 --> 00:40:06.960
It can do playback, of course,
but also it can do simple editing.

00:40:06.960 --> 00:40:10.260
And that really scales all
the way to high-end editing,

00:40:10.340 --> 00:40:15.240
high-end offerings that we do with
our applications like Final Cut Pro.

00:40:15.240 --> 00:40:18.150
And that you use in a
number of your applications.

00:40:18.180 --> 00:40:21.580
So, there's a lot of wealth here.

00:40:21.580 --> 00:40:24.670
There's a lot of richness in QuickTime.

00:40:24.680 --> 00:40:28.500
But as you can tell, it's a little hefty.

00:40:28.500 --> 00:40:33.120
And so, when we decided to have
media facility on the iPhone,

00:40:33.120 --> 00:40:37.480
we decided to start from scratch
with everything that we've

00:40:37.480 --> 00:40:42.310
learned over 20 years of doing
multimedia kind of systems.

00:40:42.350 --> 00:40:45.090
And we built that right into the iPhone.

00:40:45.230 --> 00:40:49.740
And the iPhone only
supports modern formats.

00:40:49.740 --> 00:40:53.080
And it only supports playback.

00:40:53.080 --> 00:40:56.880
And this stack is so efficient.

00:40:56.880 --> 00:41:01.180
It's fast and lightweight
and battery efficient.

00:41:01.180 --> 00:41:03.820
It applies all the knowledge
that we've gained on how to

00:41:03.820 --> 00:41:07.340
build a synchronous systems,
multi-threaded systems.

00:41:07.350 --> 00:41:08.330
It's really wonderful.

00:41:08.330 --> 00:41:14.060
So, we've decided to bring
that stack back to the Mac.

00:41:18.100 --> 00:41:23.340
So what we will provide is a single API.

00:41:23.340 --> 00:41:24.770
We are not changing the API.

00:41:24.920 --> 00:41:29.430
The API remains QtKit,
which is the object-oriented

00:41:29.430 --> 00:41:30.960
API to QuickTime.

00:41:30.960 --> 00:41:34.470
But there will be one more
thing that we add to that API,

00:41:34.470 --> 00:41:37.980
which is the ability
to specify your intent.

00:41:37.980 --> 00:41:41.680
And if your intent is playback
for just modern media,

00:41:41.680 --> 00:41:44.640
then you will go automatically
to the new stack,

00:41:44.730 --> 00:41:48.740
the lightweight stack,
and you will benefit the extended

00:41:48.740 --> 00:41:50.920
battery life and so forth.

00:41:50.920 --> 00:41:55.100
So this is a very simple thing,
at least simple for you,

00:41:55.100 --> 00:41:56.740
but it's very profound.

00:41:56.740 --> 00:42:00.960
So we decided to give it a name,
and that's QuickTime 10.

00:42:00.960 --> 00:42:03.640
And we also have a new icon for it.

00:42:03.640 --> 00:42:04.820
So that's the new QuickTime.

00:42:16.990 --> 00:42:20.700
Let's now go into
another technology area,

00:42:20.790 --> 00:42:26.020
one that spans the whole
set of layers of Mac OS X,

00:42:26.150 --> 00:42:30.940
one that affects all the binaries,
or I should say that should

00:42:30.940 --> 00:42:32.800
affect all the binaries.

00:42:32.820 --> 00:42:36.100
I want to talk here about 64-bit.

00:42:36.100 --> 00:42:39.300
Now, right off the bat,
I'm going to say this:

00:42:39.300 --> 00:42:41.140
this is just for the Mac.

00:42:41.140 --> 00:42:45.940
There are no plans to have an
iPhone that's 64-bit any time soon.

00:42:48.270 --> 00:42:52.580
Now, you may say, OK,
so why do I care about 64-bit?

00:42:52.710 --> 00:42:58.700
Why has Apple put 64-bit capable
processors for the last couple

00:42:58.700 --> 00:43:01.190
of years in every single machine?

00:43:02.360 --> 00:43:05.400
And the reason is twofold.

00:43:05.650 --> 00:43:11.060
The first reason is that 32-bit is
starting to be a little too tight.

00:43:11.130 --> 00:43:15.890
We want to stuff more and more
things into that address space.

00:43:16.010 --> 00:43:18.620
We have a lot of multimedia contents.

00:43:18.620 --> 00:43:23.300
And when you have a raw file
at several hundred megs a pop,

00:43:23.300 --> 00:43:27.960
very quickly your address space is
starting to be a little too tight here.

00:43:28.710 --> 00:43:34.100
Now, there are techniques to solve that,
like you slice your files and then you

00:43:34.100 --> 00:43:37.690
go through your files in little slices,
but it's very painful.

00:43:37.830 --> 00:43:42.440
So we want to simplify applications,
not make them more complex.

00:43:42.550 --> 00:43:45.690
So that's the first
reason to go to 64-bit.

00:43:45.790 --> 00:43:50.100
But the second reason is, of course,
performance.

00:43:50.320 --> 00:43:55.440
Now, that's a little trickier here
because unlike many other things,

00:43:55.440 --> 00:43:59.340
okay, like the increase in speed
of GPUs and all that stuff,

00:43:59.790 --> 00:44:04.590
64-bit is not necessarily win-win
because your pointers are growing by

00:44:04.590 --> 00:44:08.760
a factor of two when you go to 64-bit,
and some of the other data structures

00:44:08.760 --> 00:44:10.900
are also growing by a factor of two.

00:44:10.900 --> 00:44:15.020
So you consume a little
more memory with 64-bit.

00:44:15.020 --> 00:44:18.540
On the other hand,
the processor is really optimized

00:44:18.640 --> 00:44:23.760
for 64-bit instruction set,
a lot more registers, able to crunch the

00:44:23.760 --> 00:44:29.600
information in bigger chunks,
and so overall 64-bit goes faster.

00:44:29.600 --> 00:44:34.070
To kind of convince ourselves,
what we did is we measured a number of

00:44:34.660 --> 00:44:40.120
programs in both 32-bit and in 64-bit,
and we compared them.

00:44:40.120 --> 00:44:43.020
We took programs across
the whole spectrum,

00:44:43.020 --> 00:44:44.930
you know, things that are applications,
things that are hardware,

00:44:44.930 --> 00:44:46.520
things that are hardware,
things that are math centering,

00:44:46.530 --> 00:44:49.030
things that are system,
and they are color-coded.

00:44:49.050 --> 00:44:51.700
The categories are
color-coded on the graph.

00:44:51.700 --> 00:44:55.780
And on the Y axis is a
ratio of 64 over 32-bit.

00:44:55.780 --> 00:44:58.060
The green line is parity.

00:44:58.060 --> 00:45:01.460
And it turns out that the
vast majority of everything we

00:45:01.460 --> 00:45:05.180
tried goes faster in 64-bit.

00:45:05.180 --> 00:45:10.590
In fact, the average geometric mean of
the various data points that

00:45:10.660 --> 00:45:13.000
we have is around 15 percent.

00:45:13.000 --> 00:45:15.980
Now, I don't know about you,
but I think you're going to be surprised.

00:45:16.040 --> 00:45:21.290
I know of nothing that takes
very little effort and that

00:45:21.300 --> 00:45:25.760
buys you 15 percent system-wide.

00:45:25.760 --> 00:45:27.420
This is a huge improvement.

00:45:27.420 --> 00:45:31.130
You know, system-wide improvements
typically are 1 percent,

00:45:31.280 --> 00:45:33.900
2 percent, not 15 percent.

00:45:33.900 --> 00:45:41.180
And this is why we're heading to
64-bit at the greatest possible speed.

00:45:41.280 --> 00:45:44.960
So let me show that to
you on a small demo.

00:45:44.960 --> 00:45:46.740
demo here.

00:45:52.100 --> 00:47:39.300
[Transcript missing]

00:47:39.590 --> 00:47:44.400
I have another data set that
refines a little bit the portion.

00:47:44.400 --> 00:47:47.620
This is a portion of the
brain that has an aneurysm,

00:47:47.620 --> 00:47:51.890
which is kind of conditions that
you really don't want to have.

00:47:51.910 --> 00:47:54.420
This is fatal if not treated.

00:47:54.420 --> 00:47:59.060
And I can go into 3D volume rendering.

00:47:59.060 --> 00:48:02.670
And this is what doctors would have.

00:48:02.690 --> 00:48:09.120
And so now I can kind of see in 3D,
I can rotate this section of the brain

00:48:09.480 --> 00:48:12.490
and get a good look at the growth here.

00:48:14.140 --> 00:48:17.660
And there's about 75 views
that are getting generated in

00:48:17.660 --> 00:48:19.040
real time from the 3D model.

00:48:19.040 --> 00:48:24.320
And this is a 32-bit application,
and it takes about 17 seconds.

00:48:24.320 --> 00:48:29.100
So we recompiled that
application for 64-bit.

00:48:29.440 --> 00:48:36.900
Let me run that.

00:48:36.900 --> 00:48:36.910
Same data set, same algorithm,
same code recompiled.

00:48:38.020 --> 00:48:43.680
Same 75 views of the aneurysm,
and it's done.

00:48:43.850 --> 00:48:45.210
54% improvement.

00:48:45.420 --> 00:48:51.260
So this is a real life application
that shows a significant improvement,

00:48:51.280 --> 00:48:56.390
and that's the reason why
you want to go to 64-bit.

00:48:59.720 --> 00:49:05.220
So over the last releases,
we've moved as fast as

00:49:05.220 --> 00:49:06.900
we could to a 64-bit.

00:49:06.900 --> 00:49:11.260
If this is kind of a representation
of the layers of the system,

00:49:11.260 --> 00:49:16.300
we've made sure in Leopard
that all the APIs in the

00:49:16.340 --> 00:49:18.550
frameworks were 64-bit capable.

00:49:18.920 --> 00:49:22.860
Now, the way we do that is, of course,
we glue together the 32-bit

00:49:22.860 --> 00:49:26.460
and the 64-bit binaries so
that there's a single binary.

00:49:26.460 --> 00:49:31.150
So you don't need to have any
configuration or anything like that.

00:49:31.240 --> 00:49:31.860
It's all automatic.

00:49:31.960 --> 00:49:37.100
On a 32-bit machine,
you'll run a 32-bit version of the app,

00:49:37.100 --> 00:49:42.680
and it will use the 32-bit
frameworks and 64-bit equivalent.

00:49:42.680 --> 00:49:49.260
So we've done that,
and this has enabled you to... create

00:49:49.680 --> 00:49:52.780
applications that are both 32 and 64.

00:49:52.910 --> 00:49:54.190
So this is great.

00:49:54.260 --> 00:49:57.110
Okay, and I know that a number of
you have started doing that.

00:49:57.150 --> 00:50:00.140
But there are two things
that we haven't done.

00:50:00.160 --> 00:50:03.950
The first thing is to
take our own applications,

00:50:03.950 --> 00:50:07.600
the system apps, and make them 64-bit.

00:50:07.660 --> 00:50:12.010
So we'll be doing that, and there is an
application of doing that.

00:50:12.100 --> 00:50:16.650
The implication is that if you have
a plug-in to one of the system apps,

00:50:16.650 --> 00:50:20.820
you now need to be... 32 plus 64.

00:50:20.820 --> 00:50:24.920
So that affects the
screen saver plug-ins,

00:50:25.060 --> 00:50:31.000
all the prep bands, the Safari plug-ins,
the web plug-ins, QuickTime plug-ins,

00:50:31.000 --> 00:50:33.490
the printer plug-ins for the
portion of the printer plug-ins

00:50:33.490 --> 00:50:37.490
that runs in user space,
and so forth.

00:50:38.590 --> 00:50:44.230
The other thing we haven't done is
to run our own kernel in 64-bit.

00:50:44.620 --> 00:50:49.840
Now, we have to do that now because the
amount of RAM you can stuff onto a

00:50:49.910 --> 00:50:55.720
computer is hitting a wall because
every time you add physical RAM,

00:50:55.720 --> 00:51:00.940
you take a tiny fraction of that
RAM to store your map tables,

00:51:00.940 --> 00:51:06.000
all your tables that map for
the kernel to the wired memory.

00:51:06.000 --> 00:51:09.550
And so, all together,
we hit a wall around 32

00:51:09.670 --> 00:51:11.430
gigabytes of physical RAM.

00:51:11.460 --> 00:51:16.530
So, I know that you all want to have
32 gigabytes on your portable.

00:51:16.530 --> 00:51:20.620
I'm not sure when that will occur,
but at some point in the future,

00:51:20.620 --> 00:51:22.010
I'm sure this will occur.

00:51:22.010 --> 00:51:25.620
And definitely, on the high-end machine,
this will occur.

00:51:25.620 --> 00:51:27.760
So, we want to enable that.

00:51:27.760 --> 00:51:31.200
And so,
the consequence of doing that is that

00:51:31.340 --> 00:51:34.690
if you provide a kernel extension,
you now need to be

00:51:34.690 --> 00:51:37.000
running in 64-bit as well.

00:51:37.000 --> 00:51:41.720
So, that applies for everything that
touches the hardware that you provide,

00:51:41.800 --> 00:51:47.780
so a printer driver or some dongle driver
or any kind of extension to the kernel,

00:51:47.780 --> 00:51:51.480
say a file system extension for
those of you who have such things.

00:51:53.610 --> 00:51:58.870
So fundamentally,
this is a call to action.

00:51:58.960 --> 00:52:04.510
We want your application
to be both 32 and 64.

00:52:04.580 --> 00:52:06.870
And you can do that today.

00:52:07.260 --> 00:52:12.640
And soon,
we want all your plugins to be 32 and 64,

00:52:12.640 --> 00:52:15.890
whether it's your application
plugins running in user

00:52:16.050 --> 00:52:20.280
space or your system plugins,
your kernel plugins

00:52:20.280 --> 00:52:22.580
running in kernel space.

00:52:22.580 --> 00:52:23.570
So that's 64-bit.

00:52:26.030 --> 00:52:35.520
Now let me dive now into another area,
one that again applies to all the layers,

00:52:35.550 --> 00:52:41.290
one that I think has deep ramifications
in how you program in the future.

00:52:42.100 --> 00:52:47.400
[Transcript missing]

00:52:47.520 --> 00:52:51.470
Because multicores are a fact of life.

00:52:51.660 --> 00:52:55.440
It is very clear that
multicores are here to stay.

00:52:55.520 --> 00:52:58.030
From now on,
there will always be more cores because

00:52:58.030 --> 00:52:59.900
this is how Moore's Law is expressed.

00:52:59.900 --> 00:53:04.570
It's no longer expressed for
CPUs as megahertz that increases.

00:53:04.740 --> 00:53:07.920
It's expressed by more cores.

00:53:07.950 --> 00:53:09.280
Now, why is that?

00:53:09.280 --> 00:53:11.940
Well, the reason is really physics.

00:53:12.500 --> 00:54:33.300
[Transcript missing]

00:54:35.150 --> 00:54:39.980
So,
they say multicores are in our future.

00:54:40.020 --> 00:54:42.600
There's just a little problem here.

00:54:42.630 --> 00:54:46.560
And the problem is,
how do you program multicores?

00:54:46.560 --> 00:54:47.390
Right?

00:54:47.400 --> 00:54:49.460
It's a big head-scratcher.

00:54:49.480 --> 00:54:53.300
And the traditional answer
to that is multi-threading.

00:54:54.560 --> 00:54:56.160
Let's take a simple example.

00:54:56.160 --> 00:55:00.960
Let's take the simplest algorithm
I could find here is the sort,

00:55:01.130 --> 00:55:02.790
the classic sort.

00:55:02.820 --> 00:55:07.920
So I have an array with n kind of items,
and I want to sort it.

00:55:08.240 --> 00:55:11.040
So, well, okay,
I'm going to sort this half of the array,

00:55:11.090 --> 00:55:13.350
sort this half of the array, and merge.

00:55:13.470 --> 00:55:13.750
Okay?

00:55:14.170 --> 00:55:15.890
Simplest algorithm.

00:55:16.070 --> 00:55:21.190
So let's say I want to thread this
using pthreads or something like that.

00:55:21.200 --> 00:55:24.640
So the naive idea is, okay,
let's take this half of the

00:55:24.840 --> 00:55:26.890
array and do that in a thread.

00:55:26.890 --> 00:55:31.380
And let's take the other half of
the array and do that in a thread.

00:55:31.380 --> 00:55:32.940
Sort that in a thread.

00:55:32.950 --> 00:55:35.400
So, okay, so I need to do that.

00:55:35.400 --> 00:55:39.820
So to do that,
I'm going to use the pthreads library.

00:55:39.820 --> 00:55:45.070
I need to introduce kind of an auxiliary
function because with pthreads,

00:55:45.070 --> 00:55:49.240
you need to wrap up all your arguments
before you call the pthreads library.

00:55:49.360 --> 00:55:52.490
And you wrap up your arguments,
pass that to pthreads,

00:55:52.580 --> 00:55:55.490
fork those two threads,
and kind of gather,

00:55:55.490 --> 00:55:57.540
rejoin those two threads.

00:55:57.540 --> 00:55:58.880
So you can do it.

00:55:58.880 --> 00:56:01.750
There's just two problems with this.

00:56:01.750 --> 00:56:02.800
Okay?

00:56:02.800 --> 00:56:05.210
The first thing is that
this is cumbersome.

00:56:05.230 --> 00:56:05.690
Okay?

00:56:05.690 --> 00:56:11.300
That nice, simple algorithm that was kind
of sorting that anyone could

00:56:11.350 --> 00:56:14.140
read here is no longer simple.

00:56:14.570 --> 00:56:18.320
The second problem is that the way
I've done it is very inefficient.

00:56:18.320 --> 00:56:22.900
If there's anyone who is
algorithmically inclined,

00:56:22.900 --> 00:56:28.000
you will realize that I forked n
threads to sort my array with n items.

00:56:28.000 --> 00:56:32.370
That's not going to work great
when your array is large.

00:56:32.370 --> 00:56:36.400
In fact,
if you have an eight-core machine,

00:56:36.400 --> 00:56:39.930
you don't want to ever create
more than eight threads.

00:56:40.080 --> 00:56:41.550
It's just a big waste.

00:56:43.640 --> 00:56:45.900
So this is another way.

00:56:46.080 --> 00:56:48.320
Is there a better way?

00:56:50.260 --> 00:56:52.100
And we believe there is.

00:56:52.240 --> 00:56:56.240
And we call it: Grant Central.

00:56:56.540 --> 00:57:00.740
That's our codename for this strategy.

00:57:00.890 --> 00:57:04.740
And we believe that to address
the multi-core problem,

00:57:04.840 --> 00:57:08.320
we need to act at several places.

00:57:08.420 --> 00:57:11.500
We need to act at the
level of the language,

00:57:12.240 --> 00:57:16.240
We need to add a new
runtime to the system.

00:57:16.260 --> 00:57:19.040
And we need to add new APIs.

00:57:19.540 --> 00:57:21.760
So let's look at each of those.

00:57:21.800 --> 00:57:25.440
First, a new language feature.

00:57:25.490 --> 00:57:28.990
Let's go back to our classic sort.

00:57:29.340 --> 00:57:32.990
What you would like to do
is to take those two lines,

00:57:33.000 --> 00:57:38.320
you know,
the two sorts of the half of the array,

00:57:38.390 --> 00:57:43.640
and say, well, this block of code,
I want to do it on its own, okay?

00:57:43.640 --> 00:57:46.200
I want to fork of thread if necessary.

00:57:46.340 --> 00:57:50.840
So you want to get a handle
on those blocks of code,

00:57:50.920 --> 00:57:55.310
and you want to give those
blocks of code to the runtime.

00:57:55.490 --> 00:58:00.780
So we're adding a new feature to
the language that we called Blocks,

00:58:00.780 --> 00:58:03.460
which is exactly about that.

00:58:07.040 --> 00:58:13.110
What blocks enable you to do is
to take just two lines of code,

00:58:13.210 --> 00:58:16.880
put a caret in front
of the block of code,

00:58:16.900 --> 00:58:19.080
and suddenly you get a handle.

00:58:19.080 --> 00:58:23.010
You get a value that you can pass around.

00:58:23.050 --> 00:58:26.040
It's a very, very simple concept.

00:58:26.040 --> 00:58:30.160
It's how to get from a
block of code to a function.

00:58:31.260 --> 00:58:33.300
Now that you have your
two blocks of code,

00:58:33.300 --> 00:58:37.240
you can have runtime do all the work.

00:58:37.300 --> 00:58:42.050
That is, fork threads if necessary,
execute those two blocks and rejoin.

00:58:42.060 --> 00:58:47.390
This is clearly a very, very,

00:58:48.100 --> 00:59:32.200
[Transcript missing]

00:59:32.300 --> 00:59:34.440
And it hides all the thread creation.

00:59:34.510 --> 00:59:38.530
It will create threads
automatically if needed.

00:59:38.660 --> 00:59:43.990
Now, the beauty of GCD is that it will
scale up with the number of calls

00:59:44.040 --> 00:59:49.580
that you have on your machine,
but it will back off and scale

00:59:49.580 --> 00:59:53.200
down when all the calls are busy.

00:59:53.200 --> 00:59:59.100
As you saw in the visualization,
when you apply pressure, it backs off.

00:59:59.100 --> 01:00:03.630
And this is something that you
can only do if you have your hands

01:00:03.630 --> 01:00:07.200
into the OS scheduler itself.

01:00:08.970 --> 01:00:10.660
So that's the runtime.

01:00:10.660 --> 01:00:14.810
And of course,
the last piece is new APIs.

01:00:15.190 --> 01:00:19.680
So we've taken our entire layer,
and we're adding new APIs so that

01:00:19.840 --> 01:00:22.210
it's capable to do multicore.

01:00:22.220 --> 01:00:26.950
We're adding that at every layer,
APIs that can do blocks,

01:00:26.950 --> 01:00:29.180
APIs that can do GCD.

01:00:31.010 --> 01:00:36.760
So this is Grand Central,
a new language feature, a new runtime,

01:00:36.780 --> 01:00:38.520
and new APIs.

01:00:38.600 --> 01:00:41.820
Now,
to take an analogy with what's happening,

01:00:41.820 --> 01:00:43.040
I think it's very profound.

01:00:43.040 --> 01:00:48.380
It's very similar to what happened
with networking way back then.

01:00:48.450 --> 01:00:52.700
You know, networking a long time ago used
to be based on circuit switching.

01:00:52.880 --> 01:00:54.800
When you wanted to
communicate to someone,

01:00:54.800 --> 01:00:58.400
you would open this circuit,
And all the communication

01:00:58.840 --> 01:01:01.010
would go across that circuit.

01:01:01.740 --> 01:01:04.250
But of course,
that's a very inefficient way to

01:01:04.260 --> 01:01:06.340
deal with networking resources.

01:01:06.370 --> 01:01:09.700
And pretty quickly,
people realized that instead,

01:01:09.700 --> 01:01:11.640
you should use packet switching.

01:01:11.750 --> 01:01:15.550
Even for continuous communication,
like a stream of voice,

01:01:15.560 --> 01:01:18.180
you cut the voice into little packets.

01:01:18.240 --> 01:01:22.820
And the whole networking infrastructure
is responsible for routing the packets,

01:01:22.850 --> 01:01:26.860
not necessarily always the same
route to the end destination.

01:01:27.140 --> 01:01:31.670
Well, I believe the same thing is
happening with computing.

01:01:31.750 --> 01:01:35.390
Instead of having a dedicated
processor that you use for

01:01:35.530 --> 01:01:40.420
your program and just you,
or two processors or four processors,

01:01:40.420 --> 01:01:47.220
whatever you build in with traditional
kind of multi-threading approach,

01:01:47.310 --> 01:01:49.370
instead of that,

01:01:49.680 --> 01:01:53.100
You just think in terms
of packetized computing,

01:01:53.100 --> 01:01:55.990
little packets of computation.

01:01:56.380 --> 01:01:58.170
Those are blocks.

01:01:58.680 --> 01:02:01.760
So this is quite a different approach.

01:02:01.760 --> 01:02:06.710
Instead of parallelizing your code,
what you are doing is you are

01:02:06.710 --> 01:02:09.670
cutting your code into little blocks.

01:02:10.110 --> 01:02:14.600
This is a lot more convenient,
as you saw on a very simple example.

01:02:14.600 --> 01:02:18.580
And of course,
as the complexity of the code increases,

01:02:18.580 --> 01:02:20.750
it's even more convenient.

01:02:21.420 --> 01:02:24.790
It also means that you
always size things right.

01:02:24.920 --> 01:02:27.700
You don't have to know that
you're running on two processors,

01:02:27.730 --> 01:02:28.900
four processors, or whatever.

01:02:28.900 --> 01:02:33.000
It's always ideal for the number
of processors due to the runtime.

01:02:33.000 --> 01:02:37.200
And that enables us to
have a much finer grain.

01:02:37.620 --> 01:02:41.390
You know, when you use P threads,
you have a tradeoff of whether to use

01:02:41.400 --> 01:02:45.390
a new thread for something or not,
which is around 10,000 and

01:02:45.510 --> 01:02:48.520
100,000 function call equivalent.

01:02:48.520 --> 01:02:51.980
If you have less than that,
there's no point in forking a thread.

01:02:51.980 --> 01:02:55.780
And we believe we can bring
that down by three orders of

01:02:55.900 --> 01:02:58.380
magnitude with blocks and GCD.

01:02:58.380 --> 01:02:59.690
Thank you.

01:03:01.510 --> 01:03:06.680
Also, Grand Central unifies
the response to events,

01:03:06.760 --> 01:03:12.180
event-driven programming, and jobs,
you know, things to do.

01:03:12.180 --> 01:03:15.740
In fact, when you are sorting, you know,
this little sort example,

01:03:15.920 --> 01:03:20.280
you can conceivably think that you are
creating a little event loop that's going

01:03:20.280 --> 01:03:23.600
to do the two halves and then rejoin.

01:03:23.920 --> 01:03:30.960
And it unifies CPUs and GPUs
as we saw with the OpenCL demo.

01:03:32.240 --> 01:03:37.330
So this is Grand Central,
and it's a different

01:03:37.330 --> 01:03:40.190
approach to multicores.

01:03:48.880 --> 01:03:53.190
The last technology area
I want to touch upon is tools.

01:03:53.500 --> 01:03:56.170
It's something that you
interact with day in,

01:03:56.470 --> 01:04:01.340
day out, and that I know is
really important to you.

01:04:01.700 --> 01:04:06.040
So tools are, of course,
a missing link between the

01:04:06.040 --> 01:04:08.240
frameworks and your application.

01:04:08.240 --> 01:04:13.950
Well, no longer missing because we
have a great set of tools.

01:04:13.950 --> 01:04:15.800
Now, we had in mind that we

01:04:16.090 --> 01:04:20.550
A number of principles when
we designed our set of tools.

01:04:20.550 --> 01:04:25.600
One of the principles is to always make
sure that your code is center stage.

01:04:25.600 --> 01:04:31.210
So we try to reserve the maximum
real estate on the screen

01:04:31.210 --> 01:04:32.670
for your code in our tools.

01:04:32.670 --> 01:04:35.740
And that's a basic principle.

01:04:35.740 --> 01:04:40.820
Another one is that we capture whatever
you want to do at the highest level.

01:04:40.980 --> 01:04:44.540
We don't like, for example,
to generate code that you

01:04:44.540 --> 01:04:46.800
need to hand-edit afterwards.

01:04:46.950 --> 01:04:51.150
Instead, we prefer to keep the code at
the highest level or whatever

01:04:51.150 --> 01:04:55.800
specification you have at the
highest level and not degrade that.

01:04:56.660 --> 01:05:00.360
We also want to do direct
manipulation as much as possible.

01:05:00.480 --> 01:05:04.560
So rather than having codes that move
the window or that sizes a window,

01:05:04.560 --> 01:05:08.370
well, you just size a window, OK,
obviously.

01:05:09.240 --> 01:05:12.360
Now, we use our own tools for
developing the whole system.

01:05:12.490 --> 01:05:15.140
All of Mac OS is developed
with our own tools.

01:05:15.290 --> 01:05:18.560
All of the iPhone OS is
developed with our own tools.

01:05:18.710 --> 01:05:21.700
So we want to make sure
that our tools are really,

01:05:21.700 --> 01:05:23.600
really efficient.

01:05:23.700 --> 01:05:27.210
And of course, you benefit from that.

01:05:27.960 --> 01:05:31.800
Now, one thing is that we always strive
for simplicity in the tools.

01:05:31.800 --> 01:05:35.380
Now, that's a challenge because
there's a lot of you who use

01:05:35.550 --> 01:05:37.000
tools in a lot of different ways.

01:05:37.000 --> 01:05:41.960
But we always try to keep
them as simple as we can.

01:05:43.450 --> 01:05:47.350
And we believe in the
power of generic tools,

01:05:47.350 --> 01:05:50.040
but also in the power
of specialized tools.

01:05:50.040 --> 01:05:53.220
And so we will be talking about,
you know, the top tools,

01:05:53.220 --> 01:05:56.010
but we'll also be talking
during the conference of some

01:05:56.030 --> 01:05:57.880
of the second-order tools,
you know,

01:05:57.880 --> 01:06:04.190
the ones that have a very specific goal
in mind to do something very specific.

01:06:05.200 --> 01:06:10.090
So briefly,
what are the tools for the Mac?

01:06:10.390 --> 01:06:15.330
Talk first about that,
and then about the tools for the iPhone.

01:06:15.970 --> 01:06:25.270
The top three tools are Xcode,
which is our IDE that enables

01:06:25.270 --> 01:06:26.740
you to write the code.

01:06:26.740 --> 01:06:32.630
Interface Builder,
where you specify the user interface.

01:06:33.350 --> 01:06:37.940
And after you've built your app,
instruments to optimize your application,

01:06:37.940 --> 01:06:40.850
make sure it performs.

01:06:40.920 --> 01:06:45.290
These are the three
main tools for the Mac.

01:06:45.390 --> 01:06:49.550
What about tools for the iPhone?

01:06:51.800 --> 01:06:55.020
It's the same, right?

01:06:55.120 --> 01:06:56.650
This is fundamental.

01:06:56.760 --> 01:06:58.990
Our tool set

01:06:59.400 --> 01:07:18.000
[Transcript missing]

01:07:19.090 --> 01:07:21.540
So that was a key
message about the tools,

01:07:21.590 --> 01:07:23.080
the fact that they are the same.

01:07:23.080 --> 01:07:25.360
Okay,
all the knowledge that you have applies.

01:07:25.360 --> 01:07:27.830
And of course,
we cover that in a number of

01:07:27.830 --> 01:07:29.740
sessions at the conference.

01:07:33.980 --> 01:07:39.460
So that was the last technology
area I wanted to cover.

01:07:45.840 --> 01:07:51.200
There's a lot of technologies
in Mac OS and in iPhone OS.

01:07:51.260 --> 01:07:54.140
And I wish I could actually
talk about a lot more,

01:07:54.140 --> 01:07:56.650
but I'm going to run out of time.

01:07:56.720 --> 01:08:00.860
Because there's one more thing
that I want to talk about.

01:08:00.930 --> 01:08:06.660
And it's the Mac OS releases, of course.

01:08:07.700 --> 01:08:14.600
[Transcript missing]

01:08:14.860 --> 01:08:21.090
And it's been our most successful
OS release we ever had.

01:08:21.600 --> 01:08:26.040
In fact, it's amazing because here
we stand roughly six months,

01:08:26.060 --> 01:08:31.080
seven months,
eight months maybe now after its release,

01:08:31.080 --> 01:08:36.600
and we have already 37% of
our users who run Leopard.

01:08:36.880 --> 01:08:40.150
And when you add together
Leopard and Tiger,

01:08:40.280 --> 01:08:45.050
86% of our users run those two releases.

01:08:45.180 --> 01:08:49.740
That means that, you know, quite frankly,
you should not spend any time making

01:08:49.740 --> 01:08:54.870
sure your application works on anything
else besides those two releases because

01:08:54.870 --> 01:08:59.060
it's a very small portion of our
users who's not on the last two.

01:08:59.060 --> 01:09:00.050
And this is great.

01:09:00.060 --> 01:09:03.290
I think it's great for us and it's
great for you that our user base

01:09:03.320 --> 01:09:06.210
kind of moves along very quickly.

01:09:07.100 --> 01:09:12.490
So Leopard was the sixth
release in seven years.

01:09:12.600 --> 01:09:18.390
And we've added over the years
tons and tons of features.

01:09:19.060 --> 01:09:22.960
Each release had brought
its share of features.

01:09:22.980 --> 01:09:26.600
In fact, over the last six releases,
if you add them up,

01:09:26.680 --> 01:09:30.510
we've added 1,000 features.

01:09:32.120 --> 01:09:36.020
So, what do we do for an encore?

01:09:36.200 --> 01:09:38.340
What's the next big cat?

01:09:38.400 --> 01:09:45.530
Well, of course,
Steve and some websites have mentioned...

01:09:47.150 --> 01:09:52.380
That's the next big cat
is called Snow Leopard.

01:09:52.450 --> 01:09:55.170
And you may wonder, OK,
so how many features are

01:09:55.170 --> 01:09:57.130
there in Snow Leopard?

01:09:57.400 --> 01:10:00.410
Is it 200 features?

01:10:01.900 --> 01:10:07.500
[Transcript missing]

01:10:10.520 --> 01:10:15.000
We are going to do something
that is unprecedented,

01:10:15.000 --> 01:10:22.000
I think, in the industry of OSes,
OS releases.

01:10:22.170 --> 01:10:28.990
We are going to have a
release with no new features.

01:10:38.110 --> 01:10:43.360
Instead,
we are going to focus on technologies.

01:10:43.500 --> 01:10:47.760
Because our core asset is our stack,
our software stack.

01:10:47.760 --> 01:10:52.190
We want to make sure this is
as pristine as we can make it

01:10:52.190 --> 01:10:58.120
because we want to invest to go
to higher heights in the future.

01:10:58.120 --> 01:11:00.940
We want to reach new foundations.

01:11:00.940 --> 01:11:04.400
We want to have a higher
degree of quality,

01:11:04.510 --> 01:11:07.500
a higher degree of performance.

01:11:07.640 --> 01:11:11.160
We want to enable our
release for future hardware,

01:11:11.160 --> 01:11:17.080
whether it's new multicores or new GPUs.

01:11:17.190 --> 01:11:21.000
So, no new features.

01:11:22.580 --> 01:11:26.270
Well, actually, that's not quite true.

01:11:26.340 --> 01:11:29.150
We have one new feature.

01:11:29.900 --> 01:11:35.100
[Transcript missing]

01:11:35.520 --> 01:11:40.140
Because there's a very interesting
phenomena that's happening right now.

01:11:40.200 --> 01:11:42.950
People love the Mac that
they have at home,

01:11:43.010 --> 01:11:45.890
and they want to use it at work.

01:11:46.060 --> 01:11:51.050
And there's just one issue,
which is exchange support.

01:11:51.630 --> 01:11:56.620
And of course, the iPhone has provided
Exchange support by ActiveSync.

01:11:56.620 --> 01:12:00.810
And this has been
extremely well received.

01:12:00.810 --> 01:12:04.290
And so we'll be doing
that on the Mac as well.

01:12:04.560 --> 01:12:09.160
We will add direct exchange
connectivity in our free main

01:12:09.290 --> 01:12:14.700
communications application,
Mail, iCal, Address Book.

01:12:22.810 --> 01:12:27.660
This will require a
recent Exchange Server,

01:12:27.850 --> 01:12:29.710
Exchange Server 2007.

01:12:29.870 --> 01:12:33.320
So when you go home,
check out what is your Exchange Server.

01:12:33.320 --> 01:12:37.640
If it's not 2007,
tell your IS folks to upgrade.

01:12:37.710 --> 01:12:40.390
I'm sure Microsoft will be pleased.

01:12:42.700 --> 01:12:45.480
So this is the feature of Snow Leopard.

01:12:45.480 --> 01:12:53.150
Snow Leopard will ship
in about a year from now.

01:12:53.250 --> 01:12:59.620
But today, we will give you access
to a developer preview.

01:13:08.060 --> 01:13:12.770
It's a very early
version of Snow Leopard,

01:13:12.830 --> 01:13:16.520
but it has all of the technologies
I've been talking about.

01:13:16.520 --> 01:13:21.040
You know, things like OpenCL or GCD.

01:13:21.040 --> 01:13:26.880
And our main goal here is that you
give us feedback on the new APIs,

01:13:26.960 --> 01:13:31.800
on the new facilities,
so that we have time to iterate.

01:13:34.370 --> 01:13:40.520
So I've been taking you through two
of some of the technology areas that

01:13:40.850 --> 01:13:46.070
underlie Mac OS and the iPhone OS.

01:13:46.470 --> 01:13:49.470
I hope you will enjoy
all those technologies,

01:13:49.470 --> 01:13:54.710
and I hope you are going to create
great Mac applications and great

01:13:54.710 --> 01:14:00.020
iPhone applications on top of
these two software platforms.

01:14:00.100 --> 01:14:00.210
Thank you.
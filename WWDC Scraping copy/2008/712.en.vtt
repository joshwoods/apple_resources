WEBVTT

00:00:20.210 --> 00:00:20.650
Okay, great.

00:00:20.780 --> 00:00:23.910
Thanks, and welcome to session 712.

00:00:24.140 --> 00:00:26.260
This is
Advanced Media Application Development.

00:00:28.800 --> 00:00:31.720
And we're going to focus on some
more advanced uses of QTKit.

00:00:31.720 --> 00:00:35.780
I see there's a lot of people that
weren't here for the first session.

00:00:35.780 --> 00:00:39.050
So let me just remind
you that at noontime,

00:00:39.120 --> 00:00:43.510
there is a talk by one of the head
programmers at Pixar up in the Presidio

00:00:43.660 --> 00:00:46.370
that I think will be very entertaining.

00:00:46.370 --> 00:00:49.640
If you haven't heard him speak before,
you absolutely owe it to yourself to go.

00:00:50.200 --> 00:00:55.050
And then this afternoon, from 2 onward,
a lot of the QTKit engineers

00:00:55.320 --> 00:00:58.740
will be down in the lab,
so you can come by and ask

00:00:58.780 --> 00:01:01.520
questions that you want answered.

00:01:01.520 --> 00:01:04.690
My name is Tim Monroe,
and I will be joined shortly by

00:01:04.690 --> 00:01:06.990
David Underwood for this session.

00:01:08.720 --> 00:01:11.480
Actually, the first thing I want to do
is go to the demo machine.

00:01:11.480 --> 00:01:15.790
Every year, maybe you know this,
we have what we call a stupid

00:01:15.860 --> 00:01:19.400
movie that sort of encapsulates
one of the themes of WWDC.

00:01:19.400 --> 00:01:23.370
And I have gotten the honor of
showing that movie to you today.

00:01:23.370 --> 00:01:25.640
So could I have the demo machine?

00:01:30.470 --> 00:01:36.220
So here for your viewing pleasure
is the 2008 stupid movie.

00:01:42.300 --> 00:01:54.900
[Transcript missing]

00:02:03.900 --> 00:02:06.400
Some things are scalable.

00:02:06.400 --> 00:02:10.060
And some things are not.

00:02:23.300 --> 00:02:25.300
Some things scale naturally.

00:02:25.300 --> 00:02:32.550
And some things probably
shouldn't be compared at all.

00:02:32.550 --> 00:02:34.740
Like, not even a little bit.

00:02:34.740 --> 00:02:36.730
Know what I'm sayin'?

00:02:50.230 --> 00:02:57.720
Okay, back to slides please.

00:02:57.830 --> 00:02:59.870
This talk has nothing
to do with scalability,

00:03:00.060 --> 00:03:02.030
but, or maybe it does.

00:03:02.030 --> 00:03:07.600
So here I want to put on
my non-reading glasses.

00:03:09.750 --> 00:03:13.300
I want to start off by talking about
QTKit and the playback portion of it.

00:03:13.520 --> 00:03:17.340
And as you know, in Snow Leopard,
our charter was not to add a bunch of

00:03:17.340 --> 00:03:21.200
APIs to give you guys new capabilities,
but it was to go back and focus

00:03:21.200 --> 00:03:24.980
on stability and performance
of the existing APIs.

00:03:24.980 --> 00:03:31.240
And that was a great charter
because it allowed us to go back in,

00:03:31.240 --> 00:03:34.580
look at some of the code that
we maybe thought wasn't as

00:03:34.580 --> 00:03:37.690
good as it could have been,
rework it, and add capabilities,

00:03:37.770 --> 00:03:40.410
make things faster,
make them more stable for you.

00:03:40.420 --> 00:03:44.230
So we've gone in and completely
reworked two classes.

00:03:44.240 --> 00:03:47.250
Well, actually a number,
but the ones that you'll be

00:03:47.250 --> 00:03:49.040
interested in are QTMovie.

00:03:49.040 --> 00:03:53.780
We've rewritten it from scratch
in order to uncouple it from the

00:03:53.880 --> 00:03:58.200
QuickTime framework and allow it
to sit on top of other frameworks.

00:03:58.310 --> 00:04:00.240
And of course,
the one that you've heard about

00:04:00.340 --> 00:04:03.750
is this QuickTime 10 framework,
which gives us added capabilities

00:04:03.750 --> 00:04:05.530
that we'll talk about in a little bit.

00:04:06.040 --> 00:04:09.880
We've also gone in and done
significant work in making QTMovie

00:04:09.880 --> 00:04:15.820
View and QTMovie Layer faster,
more capable, and actually less buggy.

00:04:15.840 --> 00:04:18.240
So we'll talk about
some of that here today.

00:04:18.240 --> 00:04:22.860
I want to start off talking about
what I call QTMovie Best Practices.

00:04:22.880 --> 00:04:26.880
And these are essentially
trying to head off places

00:04:26.880 --> 00:04:29.540
where you may run into trouble.

00:04:29.540 --> 00:04:33.250
The tech support people or the
mailing list seem to get the same

00:04:33.250 --> 00:04:35.420
sorts of questions all the time.

00:04:35.420 --> 00:04:36.020
And I want to talk about that.

00:04:36.040 --> 00:04:39.850
I want to just touch on a few of them
here today to save you some trouble.

00:04:39.860 --> 00:04:43.940
Then I'll focus on these QTMovie
improvements that I just mentioned.

00:04:43.940 --> 00:04:47.120
I'll show you some of
the drawing improvements,

00:04:47.120 --> 00:04:50.360
that is to say the improvements in
the movie layer and the movie view.

00:04:50.360 --> 00:04:54.300
And then David will come up and do
roughly the same thing with what we have

00:04:54.300 --> 00:04:56.820
changed in the capture portion of QTKit.

00:04:56.820 --> 00:05:00.140
So let's talk about
QTMovie Best Practices.

00:05:02.000 --> 00:05:04.170
There are three of these
that I want to talk about.

00:05:04.430 --> 00:05:06.900
One having to do with movie loading.

00:05:07.010 --> 00:05:10.780
One having to do with accessing APIs in
the QuickTime framework directly.

00:05:10.780 --> 00:05:15.380
And then I want to talk about
how you can move QTKit processing

00:05:15.380 --> 00:05:17.620
onto a background thread.

00:05:19.270 --> 00:05:21.560
So if you were at the
introductory session this morning,

00:05:21.560 --> 00:05:27.230
you saw me use the API init with
file in order to open a file on disk

00:05:27.230 --> 00:05:29.860
and display it in a QT Movie view.

00:05:29.860 --> 00:05:32.950
What I want to suggest to you is
that if you're going to be doing

00:05:32.950 --> 00:05:36.860
more advanced work with QTKit,
you want to move to a different API,

00:05:36.860 --> 00:05:38.670
namely init with attributes.

00:05:39.120 --> 00:05:42.390
The idea is,
here is the declaration for it,

00:05:42.390 --> 00:05:46.690
you will pass in a dictionary
of attributes that you want the

00:05:46.690 --> 00:05:49.190
movie to have when it is opened.

00:05:49.260 --> 00:05:51.790
Now, of course,
one thing you have to do is

00:05:51.990 --> 00:05:53.650
specify where the movie is.

00:05:53.660 --> 00:06:00.500
So you will pass in either QT Movie file
name attribute or QT Movie URL attribute,

00:06:00.500 --> 00:06:04.620
and that will help QT Movie find
the data that it needs to use.

00:06:04.620 --> 00:06:09.060
I've listed a few others that are
likely candidates for inclusion.

00:06:09.120 --> 00:06:12.040
In the dictionary that you
pass to init with attributes.

00:06:12.100 --> 00:06:14.780
Again,
if you were at the earlier session,

00:06:14.860 --> 00:06:18.260
you saw that I made an API call
to make the movie editable,

00:06:18.310 --> 00:06:20.150
which by default it is not.

00:06:20.240 --> 00:06:23.990
You can save yourself the trouble
by putting the editability

00:06:23.990 --> 00:06:27.630
attribute into this dictionary,
and that will be set at the

00:06:27.630 --> 00:06:29.400
time you open the movie.

00:06:29.400 --> 00:06:34.400
You can also set a delegate on the movie,
and that's useful for areas where

00:06:34.550 --> 00:06:39.100
the delegate method needs to be
invoked early on in the open.

00:06:39.180 --> 00:06:41.120
So you can set the delegate to be
set at the time you open the movie.

00:06:41.310 --> 00:06:43.890
And finally,
pretty much any other attribute that

00:06:43.890 --> 00:06:47.930
can be set on the movie is fair game
for inclusion in the dictionary that

00:06:47.930 --> 00:06:49.120
you pass to init with attributes.

00:06:49.120 --> 00:06:51.120
And here I've listed just a couple.

00:06:51.120 --> 00:06:53.890
You might, for instance,
want to set the looping state

00:06:54.100 --> 00:06:57.120
of a movie so that it loops
continuously during playback.

00:06:57.120 --> 00:07:00.650
Or you may want to set the
volume of the movie in order

00:07:00.650 --> 00:07:03.100
to get some non-default volume.

00:07:03.120 --> 00:07:07.420
So here is a simple example
of a simple looping state.

00:07:09.440 --> 00:07:11.960
Use of initWithAttributes.

00:07:11.960 --> 00:07:15.310
As you can see,
I'm passing in a URL associated

00:07:15.310 --> 00:07:17.160
with the QTMovieURL attribute.

00:07:17.160 --> 00:07:20.390
And I'm also setting the movie
to be editable by passing in

00:07:20.480 --> 00:07:22.440
the movie editable attribute.

00:07:22.440 --> 00:07:25.980
And then I just call
initWithAttributes error,

00:07:25.980 --> 00:07:27.950
and I get back a QTMovie.

00:07:29.600 --> 00:10:00.900
[Transcript missing]

00:10:01.140 --> 00:10:03.350
Well,
this is not something you want to do

00:10:03.350 --> 00:10:06.490
in a UI app because your user will sit
there thinking your app has crashed.

00:10:06.490 --> 00:10:09.820
But it's perfectly reasonable
to do in a command line app.

00:10:09.930 --> 00:10:13.420
Maybe you have a command line
tool that opens movies and

00:10:13.540 --> 00:10:15.660
exports them to some other format.

00:10:15.660 --> 00:10:18.490
In that case,
it's perfectly okay to sit around

00:10:18.490 --> 00:10:21.870
waiting for all the movie data to arrive,
and so you can force

00:10:22.100 --> 00:10:24.420
synchronous loading in this way.

00:10:24.630 --> 00:10:28.060
For a GUI-based app,
the alternative method is to monitor

00:10:28.060 --> 00:10:30.240
what we call the movie load state.

00:10:30.710 --> 00:10:33.550
The movie load state is
an attribute of a movie,

00:10:33.550 --> 00:10:37.540
and these are the currently defined
values that can be returned when

00:10:37.540 --> 00:10:40.260
you ask for a movie load state.

00:10:40.310 --> 00:10:42.160
Two of these,
actually three of these to look at.

00:10:42.420 --> 00:10:44.150
The first one is the error state.

00:10:44.420 --> 00:10:47.690
If you get back an error state,
it means that something bad has happened

00:10:48.230 --> 00:10:51.330
during the opening of the movie,
and you should just toss the movie.

00:10:51.340 --> 00:10:53.740
There's nothing you can do with it.

00:10:54.020 --> 00:10:56.660
The state at the bottom is
the load state complete.

00:10:56.890 --> 00:11:00.270
It means we have every little
last bit in that movie available.

00:11:00.270 --> 00:11:03.750
We can play it, we can export it,
we can do whatever you

00:11:03.800 --> 00:11:05.480
want with that movie.

00:11:05.970 --> 00:11:09.020
Now, you don't actually need to wait
until you have all the data

00:11:09.090 --> 00:11:10.740
to do certain things with it.

00:11:10.780 --> 00:11:13.160
If all you want to do is
know how big the movie is,

00:11:13.230 --> 00:11:15.100
what's its dimensions,
what's its duration,

00:11:15.320 --> 00:11:18.320
how many tracks does it have,
then you want to look for

00:11:18.320 --> 00:11:19.680
the load state loaded.

00:11:19.710 --> 00:11:21.970
In technical terms,
that means that something called

00:11:21.970 --> 00:11:25.980
the movie atom is available to us,
and that's where a lot of the

00:11:26.080 --> 00:11:27.770
data about the movie is stored.

00:11:27.950 --> 00:11:30.600
So let's look at how this would work.

00:11:30.900 --> 00:11:34.660
So I can open my movie, again,
within it with attributes,

00:11:34.710 --> 00:11:38.200
and then I set some object
as an observer for the

00:11:38.200 --> 00:11:41.510
QTMovieLoadStateDidChange notification.

00:11:41.520 --> 00:11:46.430
That will get issued whenever QTMovie
determines that the load state has gone

00:11:46.430 --> 00:11:48.960
from one level to a different level.

00:11:48.960 --> 00:11:53.070
And then your observer could
look something like this.

00:11:53.120 --> 00:11:56.980
If you get the load state error,
toss the movie.

00:11:56.980 --> 00:11:58.230
There's nothing you can do with it.

00:11:58.990 --> 00:12:01.850
Once you've gotten to load state loaded,
at that point you can do

00:12:01.850 --> 00:12:03.300
the things you want to do.

00:12:03.300 --> 00:12:07.060
You can ask for the movie's natural size,
you can create your movie

00:12:07.060 --> 00:12:09.950
view to be just that size,
and you could even assign

00:12:09.950 --> 00:12:11.530
the movie to the movie view.

00:12:11.540 --> 00:12:17.490
Okay, let's talk about direct access
to the QuickTime framework.

00:12:20.330 --> 00:12:24.980
As you probably know,
QTKit sits on top of

00:12:25.140 --> 00:12:28.380
QuickTime to do all of its work.

00:12:28.930 --> 00:12:31.360
There is, QTKit, of course,
has a limited API,

00:12:31.360 --> 00:12:34.540
and there are certain things you
can do with the QuickTime framework,

00:12:34.630 --> 00:12:38.210
with its thousands and thousands
and thousands of function calls,

00:12:38.210 --> 00:12:40.130
that you cannot do with QTKit.

00:12:41.800 --> 00:12:45.420
Well, we give you a safety valve,
or a trapdoor,

00:12:45.420 --> 00:12:47.670
that lets you get down into
the QuickTime framework.

00:12:47.700 --> 00:12:53.210
And here are methods that return
to you the QuickTime identifiers,

00:12:53.210 --> 00:12:54.350
or objects.

00:12:54.460 --> 00:12:59.000
So, for instance, if you have a QT movie,
you could ask for the QuickTime movie

00:12:59.000 --> 00:13:01.690
that that QT movie is representing.

00:13:01.750 --> 00:13:04.180
You could also ask for
the movie controller,

00:13:04.180 --> 00:13:08.600
which is another component that helps
manage the playback of the movie,

00:13:08.600 --> 00:13:11.870
and also draws that little
controller bar underneath the movie.

00:13:11.880 --> 00:13:14.800
Or if you're working down at
the track or the media level,

00:13:14.800 --> 00:13:18.390
again, you can get the QuickTime track
or QuickTime media associated

00:13:18.480 --> 00:13:19.610
with those objects.

00:13:22.440 --> 00:13:27.100
So here's an example of when
it might be useful to dip

00:13:27.100 --> 00:13:29.260
down into the QuickTime API.

00:13:29.260 --> 00:13:36.240
There is currently no QTKit API that
lets you find out where a frame starts.

00:13:36.340 --> 00:13:39.400
So you're at some time in the movie,
and you'd like to back up to

00:13:39.400 --> 00:13:40.920
the beginning of that frame.

00:13:40.940 --> 00:13:46.650
There's no QTKit API that will tell
you the time that that frame starts at.

00:13:46.700 --> 00:13:49.740
Well,
we could write it ourselves in this way,

00:13:49.740 --> 00:13:53.870
by dipping down into the QuickTime API,
and the operative API here is

00:13:53.870 --> 00:13:56.310
called GetMovieNextInterestingTime.

00:13:56.320 --> 00:14:00.450
And you can see that the first
parameter to that function call is

00:14:00.950 --> 00:14:07.160
the QuickTimeMovie that is returned
by the QuickTimeMovie method there.

00:14:07.160 --> 00:14:09.260
So I'm not going to
look into this anymore,

00:14:09.260 --> 00:14:12.660
just to let you know that if
there's something QTKit doesn't do,

00:14:12.660 --> 00:14:17.600
and you need it for your application,
you can dip down into the QuickTime API.

00:14:20.110 --> 00:14:22.760
Now, there are some caveats here.

00:14:22.810 --> 00:14:27.650
If you dip down into the QuickTime API,
there's all sorts of fun calls that let

00:14:27.680 --> 00:14:29.720
you dispose tracks or dispose movies.

00:14:29.720 --> 00:14:30.980
Don't call those.

00:14:30.980 --> 00:14:33.120
You will just crash your application.

00:14:33.120 --> 00:14:33.590
Okay?

00:14:33.590 --> 00:14:36.860
Because QTKit assumes that
those things are still there,

00:14:36.860 --> 00:14:41.180
and if you dip down and behind its back
start deleting tracks from the movie,

00:14:41.180 --> 00:14:44.490
it'll get hopelessly confused
and eventually crash.

00:14:46.610 --> 00:14:51.810
QuickTime methods that return information
to you are virtually always safe to call.

00:14:52.100 --> 00:14:55.340
However,
when you go in and start changing

00:14:55.340 --> 00:14:58.990
attributes at that lower level,
again, there's a possibility that there

00:14:59.050 --> 00:15:03.980
could be inconsistencies between what
QTKit thinks and what QuickTime thinks.

00:15:04.030 --> 00:15:08.510
Now, you may not crash at this level,
but strange things may happen.

00:15:08.690 --> 00:15:11.170
And one thing to keep in mind
is that this ability to dip

00:15:11.320 --> 00:15:15.300
down into the QuickTime API is
not available to 64-bit apps.

00:15:15.300 --> 00:15:19.100
The very simple reason for that
is that the QuickTime framework

00:15:19.100 --> 00:15:21.300
is not available in 64-bit.

00:15:21.300 --> 00:15:25.550
We do a little bit of inter-process
communication from the 64-bit

00:15:25.630 --> 00:15:30.290
QTKit to be able to access the
32-bit QuickTime capabilities.

00:15:30.300 --> 00:15:33.170
Now,
one thing this should tell you is that if

00:15:33.170 --> 00:15:38.510
you need some of the functionality in the
QuickTime framework in your application,

00:15:38.520 --> 00:15:42.490
and you want to run 64-bit,
you should tell us about that so

00:15:42.550 --> 00:15:46.160
that we can give you equivalent
functionality in QTKit,

00:15:46.280 --> 00:15:49.210
which is guaranteed to work in 64-bits.

00:15:51.900 --> 00:18:04.500
[Transcript missing]

00:18:07.080 --> 00:18:11.230
Okay, so those are things you may
run into just to keep in mind.

00:18:11.350 --> 00:18:14.000
Let's talk about Qt Movie improvements.

00:18:14.000 --> 00:18:16.920
As I've said,
Qt Movie is a pretty thin wrapper

00:18:16.940 --> 00:18:21.970
on top of the QuickTime Movie and
Movie Controller concepts.

00:18:22.530 --> 00:18:26.560
So QuickTime has some
features and some limitations.

00:18:26.610 --> 00:18:29.200
One of the nice features of
QuickTime is that when you open a movie,

00:18:29.200 --> 00:18:31.940
you can not just play it back,
but you can also edit it.

00:18:31.940 --> 00:18:35.640
So it always sets things up
for editing and playback.

00:18:37.250 --> 00:18:39.580
It is not,
as I mentioned just a few minutes ago,

00:18:39.770 --> 00:18:41.560
64-bit capable.

00:18:41.600 --> 00:18:45.030
And, as we just saw,
there's some stuff you need

00:18:45.090 --> 00:18:48.070
to do to make it thread-safe.

00:18:48.180 --> 00:18:51.240
And QTKit, of course,
being built on top of QuickTime,

00:18:51.270 --> 00:18:52.960
inherits these features.

00:18:52.980 --> 00:18:57.300
Since there is no QuickTime in 64-bit,
as I said,

00:18:57.300 --> 00:19:00.260
we do IPC in order to get things
to actually work correctly.

00:19:01.890 --> 00:19:04.980
You must initialize a
QT movie on the main thread.

00:19:05.030 --> 00:19:07.900
And then if you want to operate
on it on another thread,

00:19:07.920 --> 00:19:10.820
you need to do the work
that we just showed.

00:19:12.620 --> 00:19:16.490
So here's sort of the way you might look
at how QTKit was originally structured.

00:19:16.490 --> 00:19:20.950
QTKit sits on top of QuickTime,
and the parts of QuickTime that

00:19:21.050 --> 00:19:24.690
it sits most heavily on are
called the Movie Toolbox and

00:19:24.690 --> 00:19:27.340
Movie Controller Components.

00:19:27.550 --> 00:19:31.560
Now, the movie toolbox itself will
talk to other components,

00:19:31.560 --> 00:19:34.710
and just a couple of
them are media handlers.

00:19:34.720 --> 00:19:37.160
So if you have a video
track in your file,

00:19:37.280 --> 00:19:39.430
you'll get a video media handler.

00:19:39.440 --> 00:19:42.280
If you have some sound in your file,
you'll have a sound media handler.

00:19:42.280 --> 00:19:45.280
And they will talk to yet
other software components,

00:19:45.280 --> 00:19:48.260
here the sound manager and
the image compression manager,

00:19:48.260 --> 00:19:52.280
in order to get the sound through your
speakers or the bits up on the screen.

00:19:52.840 --> 00:19:55.510
Now,
the nice thing about this architecture

00:19:55.820 --> 00:20:01.450
is that we can swap parts of it out
or add in new parts fairly easily.

00:20:01.480 --> 00:20:04.750
And one thing that happened quite
a while ago was that we lessened

00:20:04.790 --> 00:20:09.370
our dependence on the sound manager
and added support for core audio,

00:20:09.370 --> 00:20:13.360
a much more powerful
sound processing API.

00:20:13.360 --> 00:20:17.310
And we did a similar thing with
the image compression manager.

00:20:17.340 --> 00:20:22.280
We made a path where you could go through
core video to give you better performance

00:20:22.360 --> 00:20:25.350
and better fidelity for your video.

00:20:26.050 --> 00:20:31.290
We can do the same thing for the
Movie Toolbox and the Movie Controller,

00:20:31.290 --> 00:20:33.040
and that's what QuickTime 10 is.

00:20:33.040 --> 00:20:36.650
It's a new set of components
that doesn't rely on any existing

00:20:36.650 --> 00:20:42.060
QuickTime functionality that will play
your graphics and your sound through

00:20:42.060 --> 00:20:44.750
those other software components.

00:20:47.020 --> 00:20:51.230
So it's a new media pipeline
that you can opt into for

00:20:51.390 --> 00:20:54.380
playback of your media files.

00:20:54.620 --> 00:20:57.460
It's more efficient than
the original pipeline,

00:20:57.460 --> 00:20:58.520
as we'll see in just a minute.

00:20:58.580 --> 00:21:02.050
And, nicely, it is 64-bit capable.

00:21:02.170 --> 00:21:05.580
We don't need to do the IPC stuff
that ties our hands in certain ways.

00:21:05.580 --> 00:21:10.310
And finally, it is much,
much more thread-safe than QuickTime is.

00:21:11.750 --> 00:21:13.840
How do you opt into
the new media pipeline?

00:21:13.840 --> 00:21:16.400
How do you get that
QuickTime 10 goodness?

00:21:16.530 --> 00:21:17.680
It's very simple.

00:21:17.680 --> 00:21:21.520
In the initWithAttributes call,
you add in one more attribute,

00:21:21.520 --> 00:21:24.920
which is the
QTMovieOpenForPlayback attribute.

00:21:24.920 --> 00:21:29.470
When you pass that in with the value yes,
you're essentially telling QTKit,

00:21:29.470 --> 00:21:32.200
I'm only ever going to
play back this movie.

00:21:32.200 --> 00:21:34.850
I'm not going to edit it,
I'm not going to export it,

00:21:34.850 --> 00:21:36.490
I'm just going to play it back.

00:21:38.490 --> 00:21:39.670
So here's how the call would look.

00:21:39.840 --> 00:21:43.060
It's just the same code we had before,
but with the addition

00:21:43.450 --> 00:21:47.680
of a new key value pair,
namely the open for playback attribute,

00:21:47.690 --> 00:21:49.080
and in this case it's set to yes.

00:21:49.080 --> 00:21:54.660
So this tells QTKit that you're
willing to let it take a new code path.

00:21:54.800 --> 00:21:59.120
So let's take a demo of that,
if I could go to the demo machine.

00:22:16.910 --> 00:22:19.300
So here's an application
that I've got pre-built.

00:22:19.300 --> 00:22:25.880
And I'm going to open a movie.

00:22:28.120 --> 00:22:31.880
And now you can see down here that
I am listing the current media stack.

00:22:31.960 --> 00:22:34.980
In this case, if I start it playing,
it's going to use QuickTime 7.

00:22:34.980 --> 00:22:37.490
And I'll just use this
button to start it playing.

00:22:37.490 --> 00:22:42.380
And we have the movie playing back using
the code path that it's always used.

00:22:42.380 --> 00:22:43.520
Now here's a fun thing.

00:22:43.520 --> 00:22:46.080
I've got a button here that
says change media stack.

00:22:46.080 --> 00:22:48.890
I can change it on the fly.

00:22:50.420 --> 00:22:52.300
And now I'm using QuickTime 10.

00:22:52.370 --> 00:22:56.700
It looks the same, it sounds the same,
but what's the performance like?

00:22:56.740 --> 00:22:59.100
Well, let's go back to QuickTime 7.

00:22:59.100 --> 00:23:02.100
Can we mute the audio there?

00:23:02.230 --> 00:23:08.300
Let's launch... Oh,
somebody took it away.

00:23:08.400 --> 00:23:11.090
Good old Activity Viewer, I suppose.

00:23:14.190 --> 00:23:17.100
Activity Monitor, oh, there it is.

00:23:17.100 --> 00:23:21.600
All right, so this is gonna,
we're gonna look at the

00:23:21.600 --> 00:23:23.100
QTKit server and QTKit player.

00:23:23.110 --> 00:23:26.100
This is a 64-bit application.

00:23:26.210 --> 00:23:30.670
And to get the appropriate CPU load,
we need to add together the

00:23:30.820 --> 00:23:33.100
QTKit server and the QTKit player.

00:23:33.100 --> 00:23:34.940
And what are we looking about there?

00:23:35.140 --> 00:23:38.290
Adding them together is
about 25% of the CPU,

00:23:38.290 --> 00:23:39.100
roughly.

00:23:39.100 --> 00:23:43.090
Now let's go over here and
change it to QuickTime 10.

00:23:43.550 --> 00:23:48.400
All the CPU load for the QuickTime,
for the QTKit server, goes to zero.

00:23:48.440 --> 00:23:50.000
And what are we left with?

00:23:50.260 --> 00:23:51.740
Five percent.

00:23:51.790 --> 00:23:52.050
Whoa.

00:23:52.050 --> 00:23:53.280
So what was it before?

00:23:53.280 --> 00:23:54.380
25 percent?

00:23:54.420 --> 00:23:55.620
Five percent.

00:23:55.640 --> 00:23:57.380
Which path would you rather take?

00:23:57.380 --> 00:24:00.960
So by adding in one
attribute to our dictionary,

00:24:00.960 --> 00:24:02.860
can I go back to slides?

00:24:05.840 --> 00:24:11.110
We were able to significantly reduce
the CPU usage of our application.

00:24:11.430 --> 00:24:14.470
So, one of the things we have
added for Snow Leopard,

00:24:14.470 --> 00:24:17.420
the new media pipeline
that you get access to by

00:24:17.440 --> 00:24:20.310
specifying that new attribute.

00:24:20.460 --> 00:24:25.070
Now, when you go that path,
certain methods in

00:24:25.070 --> 00:24:26.940
QT Movie will not work.

00:24:27.070 --> 00:24:31.480
Anything that exports it,
so the right to file with attributes,

00:24:31.840 --> 00:24:32.530
will not work.

00:24:32.530 --> 00:24:35.660
Anything that attempts to
edit the file will not work,

00:24:35.700 --> 00:24:39.300
because you've told us that you
don't want to do those things.

00:24:41.070 --> 00:24:42.020
No editing, no export.

00:24:42.170 --> 00:24:44.940
And, more importantly,
because we're no longer

00:24:44.950 --> 00:24:47.400
built on QuickTime,
you cannot access those

00:24:47.510 --> 00:24:49.000
QuickTime primitives.

00:24:49.100 --> 00:24:52.130
You can't use those API calls
in the QuickTime framework,

00:24:52.130 --> 00:24:54.510
because there isn't any
QuickTime framework for

00:24:54.930 --> 00:24:56.090
that particular file.

00:24:58.420 --> 00:25:02.050
Now, one more thing to keep in mind
is that not all files that are

00:25:02.210 --> 00:25:06.610
playable by QuickTime are playable
by the new media pipeline.

00:25:08.030 --> 00:25:14.270
And when I say QuickTime there,
I mean QuickTime 7, of course.

00:25:14.950 --> 00:25:18.480
The ones that can be played
back are really those that can

00:25:18.480 --> 00:25:22.990
be played back on our devices,
such as iPods and iPhones.

00:25:23.600 --> 00:25:28.400
And if we decide that the movie
cannot be played by QuickTime 10,

00:25:28.400 --> 00:25:32.050
we will fall back to the
existing media pipeline.

00:25:32.050 --> 00:25:34.630
Without telling you, but it'll play back.

00:25:34.700 --> 00:25:37.540
We may need to add in an API that
lets you figure out which

00:25:37.850 --> 00:25:40.600
code path the movie is taking,
but we have not exposed that

00:25:40.700 --> 00:25:42.290
in the seed that you have.

00:25:44.380 --> 00:25:49.300
So let me talk a little bit about
improvements in the drawing subsystem.

00:25:49.310 --> 00:25:52.100
And for that,
I just want to go straight to demos.

00:25:52.220 --> 00:25:54.410
If I could have the demo machine.

00:25:59.040 --> 00:26:00.140
I want to show you two demos.

00:26:00.220 --> 00:26:01.910
In fact,
you've seen one of these already in the

00:26:02.000 --> 00:26:04.690
graphics and media State of the Union.

00:26:05.220 --> 00:26:06.260
And I'm going to launch it.

00:26:06.390 --> 00:26:08.200
House of Mirrors here.

00:26:08.350 --> 00:26:10.380
It's a very simple...

00:26:11.710 --> 00:26:13.500
But at the same time, very cool demo.

00:26:13.550 --> 00:26:15.440
Scalability, a review.

00:26:15.450 --> 00:26:17.840
Again, could I mute the audio on that?

00:26:17.910 --> 00:26:20.510
So here we have a QuickTime movie,
our stupid movie,

00:26:20.630 --> 00:26:24.910
played into a QT movie layer.

00:26:25.310 --> 00:26:27.470
And we've,
actually it's two layers because

00:26:27.610 --> 00:26:31.980
the one layer is on top and the
other layer is the reflection there.

00:26:32.160 --> 00:26:37.190
Now, this is the exact same
QT Movie instance being attached

00:26:37.530 --> 00:26:39.580
to two different movie layers.

00:26:39.640 --> 00:26:42.160
That was not possible
before Snow Leopard.

00:26:42.210 --> 00:26:44.000
You could try it, but it wouldn't work.

00:26:44.130 --> 00:26:46.480
You could not get this nice reflection.

00:26:46.550 --> 00:26:49.330
In Snow Leopard,
we've improved the movie layer stuff

00:26:49.770 --> 00:26:51.440
so that you can do this sort of thing.

00:26:51.490 --> 00:26:55.690
And of course, as you saw in the demo,
we could add lots of layers.

00:26:56.080 --> 00:26:58.890
One QT Movie, lots of layers.

00:26:58.960 --> 00:27:00.510
OK?

00:27:02.380 --> 00:27:03.640
And I want to show you one more demo.

00:27:03.700 --> 00:27:08.280
We have not only added that
capability with the movie layer,

00:27:08.280 --> 00:27:09.590
but...

00:27:10.800 --> 00:27:29.800
[Transcript missing]

00:27:30.600 --> 00:27:32.520
So again,
we didn't add any new API for that.

00:27:32.520 --> 00:27:37.420
We just added capability to QTKit.

00:27:37.460 --> 00:27:41.120
Yeah, I know there's bifocals.

00:27:43.800 --> 00:27:45.060
Okay, so what can we do?

00:27:45.100 --> 00:27:48.660
We can take the same QT movie and
attach it to two different movie layers.

00:27:48.660 --> 00:27:52.720
We can take the same QT movie and
attach it to two different movie views.

00:27:52.720 --> 00:27:56.680
We recommend doing the movie
view thing only if you're taking

00:27:56.680 --> 00:27:58.910
the QuickTime 10 code path.

00:27:59.650 --> 00:28:01.860
Otherwise,
the movie controllers attached to the

00:28:01.860 --> 00:28:05.810
two views start arguing with each other,
and it's not a pretty sight.

00:28:07.880 --> 00:28:10.010
So that's all I want to talk about,
and now I'd like to bring

00:28:10.010 --> 00:28:13.590
David Underwood up to talk about some
of these new and improved features

00:28:13.660 --> 00:28:16.040
we have in the capture part of QTKit.

00:28:22.910 --> 00:28:23.340
Thank you, Tim.

00:28:23.340 --> 00:28:28.570
So if you were here at the
previous session or if you're

00:28:28.680 --> 00:28:31.960
familiar with QTKit Capture,
you know that it's primarily

00:28:31.960 --> 00:28:36.380
focused on kind of what we perceived
as pretty common use cases.

00:28:36.380 --> 00:28:38.660
So for example,
a lot of applications are going

00:28:38.670 --> 00:28:42.040
to want to capture real-time media
and record it to a QuickTime movie,

00:28:42.040 --> 00:28:42.980
for example.

00:28:43.000 --> 00:28:45.800
But what we also did in the
API was we left some openings,

00:28:45.800 --> 00:28:49.780
some way of really controlling what
you're doing with your capture sessions,

00:28:49.890 --> 00:28:52.280
and also ways of getting at
the data that's being captured.

00:28:52.280 --> 00:28:54.740
So you can do custom things with
it that we didn't anticipate.

00:28:54.740 --> 00:28:58.550
So for the remainder of this session,
I'm going to go over a few of

00:28:58.550 --> 00:29:03.200
those things and some detailed ways
that you can control and get the

00:29:03.200 --> 00:29:04.480
most out of your capture sessions.

00:29:04.480 --> 00:29:07.760
I'm also going to show you some
new APIs that we've introduced

00:29:07.760 --> 00:29:09.300
to make that even better.

00:29:09.300 --> 00:29:11.500
So what we'll go over.

00:29:11.500 --> 00:29:15.980
First thing I'm going to do is show
you the small handful of new capture

00:29:15.980 --> 00:29:18.470
APIs we've added in Snow Leopard.

00:29:19.270 --> 00:29:22.760
Then I'm going to go into detail
about the QT Capture Connection class.

00:29:22.760 --> 00:29:25.810
And this class kind of plays
an interesting role in the API,

00:29:25.810 --> 00:29:28.260
because it's a class that
is behind everything,

00:29:28.260 --> 00:29:30.610
and you see it in a lot of the APIs,
but you rarely have to

00:29:30.710 --> 00:29:31.760
interact with it directly.

00:29:31.760 --> 00:29:35.130
But it's actually very powerful,
and I'll show you a few tricks and

00:29:35.140 --> 00:29:36.990
a few things you can get out of it.

00:29:37.650 --> 00:29:42.190
I'm also going to go a little bit
over the importance of observing

00:29:42.220 --> 00:29:46.300
real-time changes in your
capture session as it's running.

00:29:46.300 --> 00:29:50.210
One of the key complexities with capture
is that because it's a real-time system

00:29:50.290 --> 00:29:53.650
and things can change at any time,
an application ideally should anticipate

00:29:53.680 --> 00:29:55.400
those changes and deal with them.

00:29:55.400 --> 00:29:59.800
And that'll be a bit of a theme that
you'll see in a lot of these examples.

00:30:00.020 --> 00:30:03.990
So, first, for new APIs in Snow Leopard,
the biggest new API that we've added

00:30:03.990 --> 00:30:06.070
is the QTCapture Audio Data Output.

00:30:06.420 --> 00:30:11.510
And this class is a QTCapture
Output subclass that allows your

00:30:11.510 --> 00:30:14.760
application to get directly at
the raw audio samples that are

00:30:14.760 --> 00:30:16.040
going through the capture session.

00:30:16.040 --> 00:30:19.700
So, this is pretty much analogous,
if you're familiar with it,

00:30:19.700 --> 00:30:22.400
to the QTCapture
Decompressed Video Output,

00:30:22.440 --> 00:30:25.090
which is that it's basically a pipe,
an outlet,

00:30:25.160 --> 00:30:28.770
that lets you get at those samples,
do some custom processing on it,

00:30:28.820 --> 00:30:29.960
you know,
anything that we didn't think of

00:30:29.960 --> 00:30:33.810
that your application needs to do.

00:30:34.920 --> 00:30:37.440
Some of the key features of
QT Capture Audio Data Output.

00:30:37.460 --> 00:30:41.230
The format of the audio that
it gives you is the canonical

00:30:41.230 --> 00:30:43.480
Core Audio linear PCM format.

00:30:43.480 --> 00:30:46.200
So this is the format that's
compatible with almost all

00:30:46.200 --> 00:30:47.670
audio units in Core Audio.

00:30:47.680 --> 00:30:50.700
So it's designed to be specifically
compatible with audio units

00:30:50.710 --> 00:30:53.440
and make it easy to do your
extra processing in Core Audio,

00:30:53.440 --> 00:30:55.620
which is going to be
the most likely case.

00:30:57.300 --> 00:31:01.160
We package the audio data in
a QT sample buffer object,

00:31:01.210 --> 00:31:03.100
which is an object we already
had defined in the API.

00:31:03.100 --> 00:31:06.630
And what this object does for you is
it contains both the actual data itself

00:31:06.630 --> 00:31:08.520
and also metadata about that data.

00:31:08.520 --> 00:31:10.730
For example,
it tells you the format that it's in.

00:31:10.780 --> 00:31:11.940
That's very important.

00:31:11.940 --> 00:31:14.040
And it also gives you timing information.

00:31:14.040 --> 00:31:16.690
So everything in a live
capture session is time-stamped

00:31:16.690 --> 00:31:18.340
relative to a certain time base.

00:31:18.340 --> 00:31:21.580
So you can use that for synchronization
and other services to figure

00:31:21.580 --> 00:31:23.160
out the timing of the data.

00:31:26.120 --> 00:31:29.350
So if you're familiar with this API and
you've been to these sessions before,

00:31:29.350 --> 00:31:32.810
you've probably seen a diagram like this,
where we have our QTCapture

00:31:32.810 --> 00:31:35.200
session in the middle,
and then we have our QTCapture

00:31:35.220 --> 00:31:36.740
inputs and our QTCapture outputs.

00:31:36.740 --> 00:31:39.960
And in the past,
I've plugged QTCapture decompressed

00:31:39.960 --> 00:31:43.340
video output as the way to
serve open-ended use cases.

00:31:43.340 --> 00:31:46.990
So all this class does is it gives you
CV image buffers of your video frames

00:31:47.040 --> 00:31:51.050
as it gets them as quickly as possible,
and then you do what you want with them.

00:31:52.090 --> 00:31:55.290
QTCapture audio data output
is basically the same thing,

00:31:55.310 --> 00:31:56.040
but for audio.

00:31:56.040 --> 00:32:00.320
And the big difference is your input
will be from some kind of audio source,

00:32:00.320 --> 00:32:04.040
and your output format will be
these QT sample buffer objects

00:32:04.060 --> 00:32:06.080
instead of CV image buffers.

00:32:09.290 --> 00:32:11.960
So just to quickly go over
how you would use this class,

00:32:11.960 --> 00:32:15.280
it's very similar to the other
QTKit capture output classes.

00:32:15.280 --> 00:32:19.200
First, you will create your
QTCapture audio data output,

00:32:19.200 --> 00:32:22.210
just using the standard initializers,
and you'll set a delegate on it.

00:32:22.280 --> 00:32:24.590
And common to the
pattern in other classes,

00:32:24.590 --> 00:32:27.390
this delegate's going to get
called every time a sample

00:32:27.590 --> 00:32:29.450
buffer full of audio is received.

00:32:29.480 --> 00:32:33.850
And just a note on that,
a single sample buffer can contain many,

00:32:33.880 --> 00:32:37.360
many samples of audio,
as is natural for audio.

00:32:37.480 --> 00:32:40.290
So it can contain, you know,
maybe 512 samples of audio

00:32:40.290 --> 00:32:41.680
that you can use to queue up.

00:32:41.880 --> 00:32:43.960
And then finally,
once you've created that,

00:32:43.960 --> 00:32:47.300
you'll take that output and you'll
add it to your capture session,

00:32:47.300 --> 00:32:48.610
just like you would
with any other output.

00:32:48.720 --> 00:32:49.320
So, simple.

00:32:49.320 --> 00:32:53.480
The delegate will implement one method.

00:32:53.480 --> 00:32:55.930
There's one method defined,
which is this capture output

00:32:55.930 --> 00:32:58.440
did output audio sample
buffer from connection method.

00:32:58.440 --> 00:33:02.230
And most likely what you're going
to do with this sample buffer

00:33:02.230 --> 00:33:06.260
that you're given is do some
processing on it with core audio.

00:33:06.880 --> 00:33:09.090
And so QT sample buffer
provides a few conveniences

00:33:09.090 --> 00:33:10.680
that make that relatively easy.

00:33:10.680 --> 00:33:15.220
One is that you can get a handle
on an audio buffer list object,

00:33:15.220 --> 00:33:17.810
which is the common object
that's used with core audio

00:33:17.810 --> 00:33:19.260
audio units and AU graphs.

00:33:19.260 --> 00:33:22.720
And you also need to find
out how many frames of audio

00:33:22.720 --> 00:33:24.760
are in that single sample.

00:33:24.760 --> 00:33:28.280
And you do that by calling the
QT sample buffer number samples method.

00:33:30.190 --> 00:33:33.190
And then once you have that information,
you do whatever you need to do with it.

00:33:33.260 --> 00:33:36.380
So just to show you a
concrete example of this,

00:33:36.380 --> 00:33:38.470
I'm going to show you a
quick demo application.

00:33:38.480 --> 00:33:40.540
So if we could go to the demo machine,
please.

00:33:47.400 --> 00:33:51.240
And this application is called
Audio Data Output to Audio Unit.

00:33:51.240 --> 00:33:55.740
And if you go to the WWDC attendee
page for this session,

00:33:55.740 --> 00:33:59.040
you can download this application
and play with it yourself.

00:34:01.700 --> 00:34:03.540
I'm just going to close this off.

00:34:03.540 --> 00:34:07.640
And what this application does for
you is it's a simple example of

00:34:07.640 --> 00:34:11.300
how to take the audio buffers that
you're getting from QTKit Capture

00:34:11.300 --> 00:34:14.360
and use them with the core audio API,
which is going to be probably the

00:34:14.360 --> 00:34:17.020
most common case of using this class.

00:34:17.020 --> 00:34:20.590
And it deals with a few of kind
of the impedance-- a little bit

00:34:20.590 --> 00:34:23.080
of the impedance matching that
you need to do between those APIs.

00:34:23.080 --> 00:34:25.230
So I'll just show that
to you pretty quickly.

00:34:25.250 --> 00:34:28.140
And all this application is going
to do is it's going to get those

00:34:28.180 --> 00:34:30.080
audio buffers from a capture session.

00:34:30.080 --> 00:34:33.480
Then it's going to use an audio unit
to apply an effect to those buffers.

00:34:33.480 --> 00:34:36.780
And then it's going to use
the core audio x-ed audio file

00:34:36.780 --> 00:34:38.320
API to write that to disk.

00:34:38.320 --> 00:34:43.420
So we're going to record an audio
capture session with an effect.

00:34:43.690 --> 00:34:46.250
So this is a very simple application.

00:34:46.300 --> 00:34:49.460
It's a single-windowed application,
so we just have one controller.

00:34:49.470 --> 00:34:51.470
I'm just gonna open that up.

00:34:53.390 --> 00:34:55.290
And I'll jump through this a little bit.

00:34:55.420 --> 00:34:57.020
Don't need to build it
from scratch because,

00:34:57.020 --> 00:34:59.040
again, this is kind of the common theme.

00:34:59.040 --> 00:35:02.140
A lot of the things you need to do here
are similar to what you've done before.

00:35:02.140 --> 00:35:04.890
So, for example,
we need to find an audio device.

00:35:04.890 --> 00:35:09.260
So we use the default input device with
media type and pass an audio media type.

00:35:09.320 --> 00:35:11.780
And we have to open it,
make sure it opens successfully.

00:35:11.780 --> 00:35:15.210
Then we create our capture session
and create our device input

00:35:15.230 --> 00:35:16.870
and add that to the session.

00:35:16.870 --> 00:35:17.960
Pretty simple.

00:35:18.900 --> 00:35:22.720
And then the new thing here is we
create our audio data output and set a

00:35:22.720 --> 00:35:27.030
delegate on it to get those callbacks
whenever a new audio buffer comes in and

00:35:27.030 --> 00:35:29.390
add that as an output to the session.

00:35:29.400 --> 00:35:32.690
And really,
I don't know if you can see it here,

00:35:32.690 --> 00:35:37.700
this is basically all of the
QTKit capture code in this application.

00:35:37.700 --> 00:35:40.690
Really, in this case,
we're supporting these

00:35:40.720 --> 00:35:42.360
open-ended use cases.

00:35:42.580 --> 00:35:45.180
Really, the meat of the work is going
to be done by everything else.

00:35:45.180 --> 00:35:47.370
So by core audio and the other
things your application does.

00:35:47.410 --> 00:35:48.880
And really, in this case,
we're just going to do that.

00:35:48.880 --> 00:35:52.020
We're just using QTKit capture as
a source for data and nothing else.

00:35:52.020 --> 00:35:54.810
So the amount that you do with
QTKit capture is pretty small,

00:35:54.810 --> 00:35:55.520
actually.

00:35:57.640 --> 00:36:00.110
And also in the setup area,
we're going to create

00:36:00.110 --> 00:36:02.340
our effects audio unit.

00:36:02.340 --> 00:36:03.810
In this case, we'll do a delay effect.

00:36:03.860 --> 00:36:04.940
It's pretty easy to hear.

00:36:04.940 --> 00:36:07.300
And we'll go and open that up.

00:36:07.460 --> 00:36:09.960
And here's where it gets
a little bit interesting.

00:36:09.960 --> 00:36:12.750
So if you're familiar with Core Audio,
and if you're not,

00:36:12.750 --> 00:36:15.900
there are some sessions at this
conference that you should go to,

00:36:15.970 --> 00:36:17.140
or at least review.

00:36:18.120 --> 00:36:21.230
Core Audio, both the Audio Unit API and
the AU Graph API,

00:36:21.260 --> 00:36:24.230
employ what's called a
pull model for getting data

00:36:24.230 --> 00:36:26.440
through these different units.

00:36:26.440 --> 00:36:29.910
And what that means is when you
have a chain of audio units,

00:36:29.910 --> 00:36:33.710
or even just one audio unit,
it's told to render periodically,

00:36:33.780 --> 00:36:35.040
or it's pulled on.

00:36:35.100 --> 00:36:37.620
And when it's told to render,
the thing that's telling it to render

00:36:37.620 --> 00:36:38.990
is getting the output from that.

00:36:39.020 --> 00:36:43.110
And what that means is that whenever
the audio unit needs new data,

00:36:43.110 --> 00:36:44.260
it asks for it.

00:36:44.260 --> 00:36:46.200
It issues a callback that was set on it.

00:36:46.300 --> 00:36:47.670
And this is called a render callback.

00:36:47.900 --> 00:36:50.900
So in other words,
instead of data being pushed into it,

00:36:50.900 --> 00:36:53.810
it issues this callback
whenever it needs more data.

00:36:53.920 --> 00:36:58.060
But Qt Get Capture kind of has
a very different set of goals.

00:36:58.060 --> 00:37:00.610
The audio data output is trying
to give you these audio sample

00:37:00.610 --> 00:37:01.940
buffers as quickly as it can.

00:37:01.980 --> 00:37:03.760
So it's pushing them on you effectively.

00:37:03.820 --> 00:37:05.570
So we have a push model and a pull model.

00:37:05.580 --> 00:37:07.300
And you need to reconcile those.

00:37:07.300 --> 00:37:10.340
And that actually turns out
to be relatively simple.

00:37:10.340 --> 00:37:13.530
And the way we're going to do
that is by setting this render

00:37:13.540 --> 00:37:15.280
callback on the audio unit.

00:37:15.280 --> 00:37:16.950
And this is the callback that's
going to be called when the

00:37:16.950 --> 00:37:17.860
audio unit needs new data.

00:37:17.900 --> 00:37:19.350
data.

00:37:21.020 --> 00:37:22.920
So that's what we do here.

00:37:22.970 --> 00:37:26.000
So I'm just gonna skip
down here a little bit.

00:37:26.080 --> 00:37:29.430
Here is the delegate method
that gets called by QT Capture

00:37:29.540 --> 00:37:32.360
Audio Data Output for every sample.

00:37:32.390 --> 00:37:34.700
And I'll skip over all
of this for a minute.

00:37:34.700 --> 00:37:36.670
I'll come back to it.

00:37:39.200 --> 00:37:42.610
And the main thing we try to do here
is we need two pieces of information,

00:37:42.610 --> 00:37:44.100
which I showed you in the slide.

00:37:44.110 --> 00:37:48.090
We need to find out how many frames of
audio are in the specific sample buffer,

00:37:48.220 --> 00:37:49.520
so we get that here.

00:37:49.550 --> 00:37:51.440
And then we also need
an audio buffer list,

00:37:51.440 --> 00:37:52.450
which we get here.

00:37:52.620 --> 00:37:57.250
What we're gonna do with that audio
buffer list is we're gonna assign it to,

00:37:57.250 --> 00:37:58.200
whoops,

00:37:58.690 --> 00:38:01.780
We're going to assign it to an
instance variable in our class.

00:38:01.780 --> 00:38:03.170
So we're just going to store it away.

00:38:03.170 --> 00:38:06.330
And what we'll do immediately is
we'll tell our audio unit to render.

00:38:06.330 --> 00:38:08.900
And this is the call that
pulls on the audio unit.

00:38:08.900 --> 00:38:09.900
It pulls on the output.

00:38:09.900 --> 00:38:15.120
And what this will cause it to do is
cause it to call its render callback,

00:38:15.120 --> 00:38:17.140
which we have down here.

00:38:19.220 --> 00:38:22.820
And all that the render callback does
is it takes this sample buffer that we

00:38:22.860 --> 00:38:27.000
just stored in our instance variable
right here and just fills it in.

00:38:27.000 --> 00:38:28.020
It just fills in the pointers.

00:38:28.020 --> 00:38:29.330
It doesn't even need to copy any data.

00:38:29.340 --> 00:38:31.450
And this all happens synchronously.

00:38:31.460 --> 00:38:33.900
So when Audio Unit Render is called,
the render callback is

00:38:34.030 --> 00:38:35.090
called synchronously.

00:38:35.100 --> 00:38:36.860
So we don't have to worry
about the data going away.

00:38:36.860 --> 00:38:40.130
We don't have to retain it or hold
on to it or anything because...

00:38:43.640 --> 00:38:47.410
Once this audio unit render call returns,
we'll be sure to have copied

00:38:47.410 --> 00:38:48.700
all that data in there.

00:38:48.750 --> 00:38:52.250
So that's how you reconcile those push
and pull models in a very simple way.

00:38:52.380 --> 00:38:55.230
Just you need to do a little
extra storage and then move

00:38:55.230 --> 00:38:57.480
over with that render callback.

00:38:57.720 --> 00:39:00.800
So once we have the output
audio from our audio unit,

00:39:00.800 --> 00:39:03.730
we use the X audio file API,
which is the high-level file

00:39:03.730 --> 00:39:06.190
writing API in Core Audio,
and write that out to disk.

00:39:06.240 --> 00:39:09.560
And we do that asynchronously
because we can.

00:39:09.560 --> 00:39:11.580
And it's that simple.

00:39:11.580 --> 00:39:13.170
So that doesn't sound so bad.

00:39:13.180 --> 00:39:16.780
You notice I skipped
over a ton of code here,

00:39:16.780 --> 00:39:17.750
though.

00:39:17.780 --> 00:39:20.310
And this code is very critical, actually.

00:39:20.480 --> 00:39:26.590
So as I alluded to earlier, the format,
or many things about a capture session,

00:39:26.590 --> 00:39:28.480
can change over time.

00:39:28.580 --> 00:39:33.960
So for example,
just in the internal line in on the Mac,

00:39:34.120 --> 00:39:37.900
the user can go and open Audio MIDI Setup
and at any time change the sample

00:39:37.900 --> 00:39:39.200
rate of the audio that it's giving.

00:39:39.200 --> 00:39:41.600
So if you're recording
from that device live,

00:39:41.660 --> 00:39:43.600
the user can change
that format at any time,

00:39:43.600 --> 00:39:46.880
and your application needs
to be able to deal with that.

00:39:47.490 --> 00:39:50.870
And the way that we deal with that is
for every single QT sample buffer that

00:39:50.870 --> 00:39:53.090
comes in from the audio data output,
we're going to get its

00:39:53.200 --> 00:39:53.960
format description.

00:39:53.960 --> 00:39:57.640
And this is an object of
type QT format description.

00:39:57.640 --> 00:40:01.100
And what we're going to get
out of it is some information.

00:40:01.100 --> 00:40:04.020
So we're going to get the
Core Audio AudioStream basic description.

00:40:04.020 --> 00:40:07.080
And we have a copy of the old
AudioStream basic description

00:40:07.080 --> 00:40:08.930
that we were using previously.

00:40:08.940 --> 00:40:11.680
And basically we're just going to check,
did something about the AudioStream

00:40:11.680 --> 00:40:12.820
basic description change?

00:40:12.820 --> 00:40:14.360
That means the format
of the audio changed,

00:40:14.360 --> 00:40:16.580
so we're going to have to
reconfigure all of our audio units.

00:40:16.720 --> 00:40:18.540
And we're going to have to
reconfigure the X audio file.

00:40:18.540 --> 00:40:22.620
And the things that are liable to change
are the number of channels in the audio.

00:40:22.620 --> 00:40:24.620
So it can go from stereo to mono,
for example.

00:40:24.640 --> 00:40:25.620
And the sample rate.

00:40:28.490 --> 00:40:30.960
So if that's the case,
we need to do some teardown.

00:40:30.960 --> 00:40:34.160
So we uninitialize our audio unit,
and then we reset it up again.

00:40:34.160 --> 00:40:37.000
So we need to set up our stream format.

00:40:37.000 --> 00:40:39.100
So we set that audio stream
basic description on it.

00:40:39.180 --> 00:40:41.940
And we also set up the
X audio file down here.

00:40:41.940 --> 00:40:45.800
So we update its output format to
match the number of channels in

00:40:45.800 --> 00:40:48.380
the sample rate that we're writing.

00:40:48.380 --> 00:40:51.010
It's very important that
your application does this.

00:40:51.010 --> 00:40:54.780
It always needs to be able to anticipate
these changes and reconfigure whatever

00:40:54.780 --> 00:40:56.940
processing is being done as necessary.

00:40:58.400 --> 00:41:00.160
And that pretty much wraps it up.

00:41:00.160 --> 00:41:02.700
So if we build and run this thing.

00:41:06.030 --> 00:41:08.430
And you see we have a pretty
minimalist user interface here,

00:41:08.430 --> 00:41:09.750
and I'm just going to
do a quick recording.

00:41:09.760 --> 00:41:12.160
Hello.

00:41:12.160 --> 00:41:14.040
Okay.

00:41:14.040 --> 00:41:15.360
I think that's enough.

00:41:15.360 --> 00:41:19.270
And let's just open that up.

00:41:24.580 --> 00:41:25.290
Hello.

00:41:25.570 --> 00:41:26.160
Hello.

00:41:26.230 --> 00:41:26.610
Okay.

00:41:26.610 --> 00:41:27.580
Okay.

00:41:27.580 --> 00:41:28.620
Okay.

00:41:28.810 --> 00:41:29.740
That's going to get out of hand.

00:41:29.760 --> 00:41:32.680
And so that's a simple application.

00:41:32.680 --> 00:41:35.220
Again, using QTKit Capture just
as a source for data,

00:41:35.220 --> 00:41:38.010
but really doing all the hard work
in a different API or something

00:41:38.150 --> 00:41:39.540
that's specific to your application.

00:41:39.540 --> 00:41:42.560
So can we go back to the slides, please?

00:41:49.280 --> 00:41:52.880
So in Snow Leopard, we've also added a
handful of other new APIs.

00:41:52.880 --> 00:41:56.200
And keeping with the general
goals of Snow Leopard,

00:41:56.270 --> 00:41:59.200
they're all, for the most part,
performance related.

00:41:59.230 --> 00:42:03.360
So for example, QTKit capture the
decompressed video output,

00:42:03.380 --> 00:42:04.810
we've added a few APIs.

00:42:04.960 --> 00:42:08.300
First, we've added an API that enables
automatic frame dropping.

00:42:08.300 --> 00:42:12.310
A common problem that a lot of developers
had with decompressed video output

00:42:12.310 --> 00:42:16.870
was if they were doing some kind of
processing on their video frames and

00:42:16.870 --> 00:42:19.840
it was taking longer than the rate
at which the frames were coming in,

00:42:19.850 --> 00:42:22.380
then they didn't do anything
to drop those frames.

00:42:22.450 --> 00:42:24.630
The memory usage of the application
would just get out of hand 'cause

00:42:24.700 --> 00:42:27.460
the frames would just kind of pile
up further and further on a queue,

00:42:27.460 --> 00:42:31.260
and your memory usage would grow and
grow until your application crashes.

00:42:31.410 --> 00:42:36.050
So what we've told developers to do
in the past is shuttle all of that

00:42:36.100 --> 00:42:39.300
work off onto another thread and
handle dropping frames yourself,

00:42:39.310 --> 00:42:39.960
basically.

00:42:39.960 --> 00:42:42.340
So if you see that you're getting behind,
just throw out the

00:42:42.340 --> 00:42:43.820
frames as they come in.

00:42:43.850 --> 00:42:46.100
But we realized there are some
applications where they don't

00:42:46.100 --> 00:42:48.850
really need that much control over
their frame dropping behavior.

00:42:48.870 --> 00:42:51.910
They just wanna kind of salvage their
performance if they're running behind.

00:42:52.010 --> 00:42:55.560
So we've added a new API that
lets Qt Capture decompress video

00:42:55.560 --> 00:42:57.990
output do that work for you,
so you don't have to worry

00:42:58.000 --> 00:43:00.680
about shuttling your work
to a different thread.

00:43:00.870 --> 00:43:05.160
In a similar vein to that,
we've also added an API that

00:43:05.160 --> 00:43:07.710
lets you specify the rate of
the video frames that you get,

00:43:07.930 --> 00:43:10.820
with a set minimum video
frame interval API.

00:43:10.820 --> 00:43:12.870
And this is an opportunity,
if your application doesn't

00:43:12.870 --> 00:43:15.310
need frames that often,
this is an opportunity for the

00:43:15.310 --> 00:43:18.740
entire pipeline to be optimized,
so you don't use as much bus bandwidth,

00:43:18.740 --> 00:43:21.360
you don't use as much memory,
and it's just a performance

00:43:21.360 --> 00:43:22.960
hint for the API,
basically.

00:43:22.960 --> 00:43:27.080
QT Capture File Output has
gained similar types of APIs.

00:43:27.080 --> 00:43:29.700
It also has a way of
specifying the frame rate.

00:43:30.460 --> 00:43:33.830
We've also added an API for
specifying the maximum size of the

00:43:33.830 --> 00:43:34.990
video that you're writing to disk.

00:43:35.000 --> 00:43:38.130
So, as you might know,
a lot of the computers that we've

00:43:38.130 --> 00:43:42.740
shipped relatively recently have
these giant HD iSights on them,

00:43:42.740 --> 00:43:46.690
built in, that produce these huge frames,
and they're around 1280 by 1024.

00:43:46.770 --> 00:43:49.370
And some applications might
actually want that resolution,

00:43:49.370 --> 00:43:52.470
but often they don't want to, you know,
hitting the disk with frames

00:43:52.470 --> 00:43:55.410
that big repeatedly is actually
too much for most hard disks.

00:43:55.420 --> 00:43:57.220
So now you can control what's happening.

00:43:57.220 --> 00:44:02.040
QT Capture File Output has also gained
a... A pause and resume recording API,

00:44:02.040 --> 00:44:04.950
so you can pause in the middle
of a file and record it.

00:44:04.960 --> 00:44:07.270
You don't... Yeah,
you no longer have to do weird

00:44:07.270 --> 00:44:09.640
things like change files and
then stitch them together.

00:44:09.640 --> 00:44:10.650
We do that for you.

00:44:10.770 --> 00:44:14.740
One note is that the minimum
frame interval API in both classes

00:44:14.740 --> 00:44:17.680
is not currently implemented
in the seed you have today,

00:44:17.680 --> 00:44:19.400
but you will see that in the future.

00:44:22.000 --> 00:44:25.380
So now I'm going to move away from
new APIs a bit and talk about some

00:44:25.570 --> 00:44:28.980
of the general things that you can
do with QTKit Capture that really

00:44:29.130 --> 00:44:33.180
enable you to fine-tune what's going
on in your capture session and also

00:44:33.180 --> 00:44:34.640
kind of understand what's going on.

00:44:34.770 --> 00:44:38.080
And one of the classes that's central
to this is QTCaptureConnection.

00:44:38.080 --> 00:44:42.100
So I'm sure by now you've seen
a lot of diagrams like this.

00:44:42.100 --> 00:44:44.120
We have, again,
our capture session in the middle,

00:44:44.120 --> 00:44:47.080
and we have our inputs going
into the capture session and our

00:44:47.080 --> 00:44:49.330
outputs taking the data coming
out of the capture session.

00:44:49.600 --> 00:44:52.500
What you haven't seen in most of
these diagrams is there are actually

00:44:52.860 --> 00:44:56.280
these streams of data coming from the
inputs into the session and coming

00:44:56.280 --> 00:44:59.120
from the session into the outputs,
represented by these

00:44:59.120 --> 00:45:00.280
lines and arrows here.

00:45:00.280 --> 00:45:03.470
And in QTKit Capture,
these are actually represented by

00:45:03.470 --> 00:45:05.830
a class called QTCaptureConnection.

00:45:07.060 --> 00:45:10.320
QT Capture Connection serves
three fundamental purposes.

00:45:10.320 --> 00:45:15.160
First,
it allows your application to identify

00:45:15.160 --> 00:45:17.700
one of these specific streams,
one of those lines or

00:45:17.700 --> 00:45:21.020
arrows in the diagram,
and this can either be an identifier

00:45:21.020 --> 00:45:24.010
that's given to you or something
that you give to part of the API.

00:45:24.020 --> 00:45:28.540
It also allows the application to
actually control which of these streams

00:45:28.540 --> 00:45:30.730
of media are enabled at any given time.

00:45:30.740 --> 00:45:34.320
So if an application doesn't
need to take all of the data

00:45:34.320 --> 00:45:36.420
coming from a certain thing,
you can disable it using

00:45:36.420 --> 00:45:37.520
QT Capture Connection.

00:45:37.520 --> 00:45:41.440
Finally, because QT Capture Connection is
sitting on top of the stream of data,

00:45:41.440 --> 00:45:44.940
it can give applications lots of
up-to-date information about what's going

00:45:44.940 --> 00:45:49.020
on with that stream at a given time,
such as its format or other useful

00:45:49.020 --> 00:45:50.620
information about the data stream.

00:45:52.790 --> 00:45:55.820
So I'm going to go into some additional
detail about how you can use QT Capture

00:45:55.820 --> 00:45:59.410
Connection to identify a specific stream.

00:46:02.450 --> 00:46:04.820
So if you've gone through the headers,
you're familiar with the API,

00:46:04.820 --> 00:46:07.970
you've probably seen a lot of
QTKit capture APIs that either

00:46:07.970 --> 00:46:11.320
give you a QT capture connection
or take one as a parameter.

00:46:11.340 --> 00:46:13.940
And when they're doing this,
they are effectively using

00:46:13.940 --> 00:46:16.830
this connection to identify
one of these specific streams.

00:46:16.840 --> 00:46:19.740
So we just have a good example down here.

00:46:19.740 --> 00:46:22.940
We have a QT capture connection
outputting to a movie file output.

00:46:22.940 --> 00:46:26.100
And if your application does this,
you can implement a delegate method

00:46:26.100 --> 00:46:29.210
called capture output did output
sample buffer from connection.

00:46:29.690 --> 00:46:32.380
And this method is called
every time a new sample buffer

00:46:32.380 --> 00:46:34.100
enters the movie file output.

00:46:34.100 --> 00:46:36.060
So you can use it to precisely
control what's going on.

00:46:36.250 --> 00:46:39.920
And say you're implementing this,
and you really want to know, you know,

00:46:39.920 --> 00:46:42.400
I have audio and video going
into this movie file output.

00:46:42.400 --> 00:46:44.060
Where did the sample buffer come from?

00:46:44.060 --> 00:46:46.120
Did it come from the audio
connection or the video connection?

00:46:46.120 --> 00:46:49.200
And the way you do that is you
look at the QT capture connection

00:46:49.260 --> 00:46:50.860
parameter in that method.

00:46:50.860 --> 00:46:53.950
That's why it exists as a parameter
so you can identify the stream.

00:46:55.820 --> 00:46:58.940
Another really common example is,
and if you were at the last session,

00:46:58.940 --> 00:47:02.110
you saw a little preview of this,
is if you want to set compression

00:47:02.110 --> 00:47:05.270
options on the movie file output,
you need to specify which stream of

00:47:05.270 --> 00:47:08.460
media is going to get compressed,
because the movie file output might

00:47:08.470 --> 00:47:10.000
be writing out multiple streams.

00:47:10.000 --> 00:47:12.310
And you use
QTCaptureConnection to do that.

00:47:12.360 --> 00:47:14.600
So in this case,
say we want to compress the video

00:47:14.670 --> 00:47:17.630
coming out of our capture session,
we find a QTCaptureConnection

00:47:17.670 --> 00:47:20.040
object and say,
use these compression options

00:47:20.140 --> 00:47:21.330
for this video stream.

00:47:25.150 --> 00:47:28.380
So when you do that,
when you need to pass a QTCapture

00:47:28.380 --> 00:47:31.230
connection to a specific API,
you need to get that QTCapture

00:47:31.250 --> 00:47:32.800
connection from somewhere.

00:47:32.800 --> 00:47:37.000
And the way that you do that is both
QTCaptureInput and QTCaptureOutput

00:47:37.000 --> 00:47:39.290
define an API called connections.

00:47:39.300 --> 00:47:43.910
And this method just returns an
NSArray of the QTCapture connections

00:47:44.150 --> 00:47:49.160
that are currently associated
with that input or that output.

00:48:03.380 --> 00:48:05.300
So we have a few examples of this here.

00:48:05.300 --> 00:48:09.680
So for example,
if you wanted to get all the

00:48:09.680 --> 00:48:13.700
connections coming from a device input
going into the QT Capture session,

00:48:13.700 --> 00:48:15.220
you'd just call the connections method.

00:48:16.940 --> 00:48:19.120
And similarly,
if you wanted to get all the connections

00:48:19.260 --> 00:48:21.940
coming from the session into,
say, your movie file output, again,

00:48:21.940 --> 00:48:23.570
you just call the connections method.

00:48:23.570 --> 00:48:25.910
And the time to call these
methods is generally after you've

00:48:25.980 --> 00:48:27.290
built your capture session up.

00:48:27.290 --> 00:48:29.040
So you have your session,
you've added all of

00:48:29.100 --> 00:48:31.380
your inputs and outputs,
because that's the time at which

00:48:31.420 --> 00:48:33.950
these connections will have been
created and will be defined,

00:48:33.950 --> 00:48:35.970
and they're created implicitly.

00:48:36.540 --> 00:48:38.740
So once you've gotten
your array of connections,

00:48:38.790 --> 00:48:41.300
generally you want to find a
specific connection in that array,

00:48:41.300 --> 00:48:42.490
so you want to narrow it down further.

00:48:42.500 --> 00:48:44.180
And the way that you do
that is straightforward.

00:48:44.180 --> 00:48:47.370
You just iterate through the array
and use some criteria to decide,

00:48:47.370 --> 00:48:49.720
is this the connection
that I'm interested in?

00:48:49.870 --> 00:48:53.270
So here's an example, again,
of setting compression options

00:48:53.270 --> 00:48:54.730
on a movie file output.

00:48:54.740 --> 00:48:58.380
And this is an example of what
was being done in the last session

00:48:58.380 --> 00:49:02.140
and in many recording applications
when you want to record to a movie

00:49:02.550 --> 00:49:04.360
file and compress it somehow.

00:49:04.780 --> 00:49:06.910
So in this case,
we have some video compression

00:49:06.920 --> 00:49:08.400
options that we've created.

00:49:08.400 --> 00:49:11.840
And what we're going to do is we're
just going to iterate through the

00:49:11.880 --> 00:49:15.440
array of QT Capture connections
owned by the movie file output.

00:49:15.440 --> 00:49:17.380
And whenever the connection
is of the type video,

00:49:17.380 --> 00:49:19.160
we say, oh, okay,
it's a video connection,

00:49:19.160 --> 00:49:21.480
so we want to compress the video,
so we're going to apply those

00:49:21.580 --> 00:49:23.520
compression options for that connection.

00:49:27.690 --> 00:49:30.560
In addition to acting as an identifier,
QT Capture Connection also,

00:49:30.730 --> 00:49:32.680
as a representative of
this stream of media,

00:49:32.680 --> 00:49:36.550
has a way of controlling whether or
not any media is going through it,

00:49:36.560 --> 00:49:40.140
and also specifics about
the media going through it.

00:49:42.120 --> 00:49:45.680
So one of the most common cases about it,
and it's a question that's come

00:49:45.680 --> 00:49:47.450
up a lot on the mailing list,
and we actually have a

00:49:47.460 --> 00:49:50.240
tech note about it now,
is say you're recording

00:49:50.250 --> 00:49:52.600
from a DV or an HDV camera.

00:49:52.600 --> 00:49:56.370
The interesting thing about these
cameras is these give you a muxed media

00:49:56.370 --> 00:49:59.790
stream or a multiplexed media stream,
which can contain both

00:49:59.790 --> 00:50:01.160
audio and video data.

00:50:01.160 --> 00:50:05.080
So when you create a QT Capture device
input around one of these devices,

00:50:05.080 --> 00:50:07.900
it's going to expose two
QT Capture connections,

00:50:07.900 --> 00:50:10.260
both a video connection
and an audio connection.

00:50:10.680 --> 00:50:13.330
So say you have a simple scenario
like this where you just want to

00:50:13.330 --> 00:50:15.740
preview it and record it to a file,
but you're not actually

00:50:15.740 --> 00:50:17.320
interested in recording the audio.

00:50:17.320 --> 00:50:21.240
Maybe it's a security camera
application and there's no interesting

00:50:21.240 --> 00:50:23.380
things to record about the audio.

00:50:23.380 --> 00:50:24.400
It just wastes disk space.

00:50:24.400 --> 00:50:26.000
You just want to use
this as a video source.

00:50:26.000 --> 00:50:29.850
So what you do there is you would
disable the audio connection coming

00:50:29.890 --> 00:50:32.070
out of the QT Capture device input.

00:50:32.080 --> 00:50:33.990
That's why we have
that big red X over it.

00:50:34.160 --> 00:50:36.520
And what will happen is when
you disable a connection,

00:50:36.520 --> 00:50:40.660
any connections that are downstream of
that just simply won't get any data.

00:50:40.660 --> 00:50:45.210
So you've effectively prevented
the audio data from making it to

00:50:45.210 --> 00:50:47.790
the movie file output right here.

00:50:47.960 --> 00:50:51.200
And so this is a way of kind of
narrowing down and specifying

00:50:51.200 --> 00:50:52.120
exactly what you want.

00:50:54.790 --> 00:50:58.260
And the way that you do this is
QT Capture Connection defines

00:50:58.260 --> 00:51:00.340
an API called SetEnabled.

00:51:00.360 --> 00:51:03.620
And so in this particular example,
we're showing in code what

00:51:03.620 --> 00:51:05.570
I did on that slide before,
which is we're going through

00:51:05.640 --> 00:51:08.410
all the QT Capture Connections
owned by the device input.

00:51:08.690 --> 00:51:11.990
And since we don't care about audio,
if the connection happens to

00:51:11.990 --> 00:51:14.640
be of the sound media type,
we just say disable it.

00:51:14.730 --> 00:51:16.580
SetEnabled now.

00:51:20.920 --> 00:51:25.370
Finally,
QT Capture Connection also is a provider

00:51:25.370 --> 00:51:27.010
of information to your application.

00:51:27.020 --> 00:51:32.670
So it will allow you to get a snapshot
of what's going on with that specific

00:51:32.670 --> 00:51:34.500
stream of media at that given time.

00:51:34.520 --> 00:51:38.340
And the easiest way to show you
in what ways it does this is just

00:51:38.340 --> 00:51:39.540
through a handful of examples.

00:51:39.540 --> 00:51:44.190
So, for example,
if you want to display in your

00:51:44.200 --> 00:51:48.200
user interface what the format
of the captured media is,

00:51:48.200 --> 00:51:52.300
so you have a device input set
up and you want to show the user,

00:51:52.300 --> 00:51:54.700
you know, here's the format that's
coming off this device.

00:51:54.700 --> 00:51:57.170
Well,
one way of doing that is you can get

00:51:57.350 --> 00:52:01.730
the QT Capture Connection's format
description from that device input,

00:52:01.910 --> 00:52:04.780
and then QT format description
has a convenience method called

00:52:04.840 --> 00:52:07.090
localized format summary,
which will give you a nice

00:52:07.090 --> 00:52:08.000
human-readable string.

00:52:08.000 --> 00:52:10.400
And in this example,
we just stick it into a text file,

00:52:10.400 --> 00:52:11.800
or to a text field, sorry.

00:52:11.800 --> 00:52:12.680
So that's one example.

00:52:14.880 --> 00:52:17.750
Another pretty common example for
applications is any application

00:52:17.790 --> 00:52:22.070
that records audio most likely
wants to display a little level

00:52:22.070 --> 00:52:25.200
meter so that the user knows if
they're clipping out the audio,

00:52:25.200 --> 00:52:27.140
if they're speaking too
loudly or too quietly,

00:52:27.140 --> 00:52:28.960
or whatever they're recording,
they'll have an idea

00:52:28.960 --> 00:52:29.850
of its decibel level.

00:52:29.860 --> 00:52:32.340
And QTCaptureConnection, again,
exposes this,

00:52:32.340 --> 00:52:36.240
exposes as an attribute because it's
an optional property of the connection,

00:52:36.240 --> 00:52:39.090
and it's called the
QTCaptureConnectionAudioAveragePowerLevel

00:52:39.090 --> 00:52:39.840
s attribute.

00:52:41.800 --> 00:52:47.920
And what this lets you do is it lets
you obtain the power level in decibels

00:52:47.920 --> 00:52:49.680
of the audio that you're looking at.

00:52:49.710 --> 00:52:51.930
So in this case,
we'll maybe have an NS level

00:52:51.930 --> 00:52:53.680
indicator that shows the audio level.

00:52:53.680 --> 00:52:55.940
And because it's in decibels,
we wanna convert that to

00:52:55.940 --> 00:52:57.200
some kind of linear scale.

00:52:57.200 --> 00:53:00.680
So we take it as a power of 10,
and that'll give you a nice,

00:53:00.680 --> 00:53:04.960
smooth audio level meter that
you can query and update.

00:53:07.360 --> 00:53:09.840
So in light of this,
I've told you that QT Capture

00:53:09.840 --> 00:53:13.300
Connection is a way of inspecting
the current state of a stream.

00:53:13.300 --> 00:53:18.730
But I've already kind of repeatedly
said that these are things that

00:53:18.730 --> 00:53:21.730
can change often over time,
and your application

00:53:21.730 --> 00:53:22.750
should deal with that.

00:53:22.940 --> 00:53:26.390
So even in the very simplest case,
even if you trust your user

00:53:26.390 --> 00:53:28.830
implicitly and they know they're
not going to try and undermine

00:53:28.830 --> 00:53:31.740
everything your application is doing,
they're not going to go and unplug and

00:53:31.830 --> 00:53:34.720
plug in the device over and over again,
they're not going to go and screw

00:53:34.720 --> 00:53:35.940
around with audio MIDI setup.

00:53:36.640 --> 00:53:38.560
Even if you know that they're not
going to do that kind of thing.

00:53:38.560 --> 00:53:41.910
Even then, when you've initially set
up your capture session,

00:53:41.910 --> 00:53:44.660
and you've added your inputs
and your outputs to it,

00:53:44.800 --> 00:53:48.020
the QT Capture Connection,
no data has gone through it yet.

00:53:48.040 --> 00:53:49.080
You haven't started the session.

00:53:49.100 --> 00:53:52.340
So it has no idea what the format of
that data is or any properties of it,

00:53:52.340 --> 00:53:53.700
such as the audio levels.

00:53:53.700 --> 00:53:56.320
And so when you start your session,
a little bit later,

00:53:56.350 --> 00:53:58.930
once that data starts coming through,
it'll know.

00:53:58.940 --> 00:54:01.290
And so if your application
is relying on that data,

00:54:01.290 --> 00:54:03.600
it needs to know when
that information came in.

00:54:03.600 --> 00:54:06.260
And then, of course,
once you've done that work, well,

00:54:06.260 --> 00:54:08.870
now you're also accounting for the
case where the user is trying to

00:54:08.870 --> 00:54:12.000
destroy everything and is unplugging
and plugging in devices all the

00:54:12.010 --> 00:54:13.680
time and doing other such things.

00:54:20.040 --> 00:54:21.600
There are two ways of doing this,
basically,

00:54:21.600 --> 00:54:24.020
and they're both common Cocoa patterns.

00:54:24.020 --> 00:54:26.540
One way of doing it is
to use notifications,

00:54:26.540 --> 00:54:30.280
and QT Capture Connection defines
a number of notifications.

00:54:30.280 --> 00:54:33.790
But one of them is the format
description did change notification,

00:54:33.790 --> 00:54:36.700
and that will tell you whenever
the format going through

00:54:36.700 --> 00:54:38.480
the connection was altered.

00:54:38.480 --> 00:54:42.840
And so one example of this that
you can think of is DV cameras.

00:54:42.840 --> 00:54:46.740
Many consumer DV cameras have a
toggle mode on them that switches

00:54:46.740 --> 00:54:49.050
between widescreen and standard.

00:54:49.520 --> 00:54:52.020
And this is something the user can
fiddle around with at any time,

00:54:52.020 --> 00:54:54.320
you know, so to switch the aspect
ratio of the video.

00:54:54.320 --> 00:54:55.640
And that's a format change.

00:54:55.640 --> 00:54:57.500
It's a different video format, then.

00:54:57.500 --> 00:55:00.240
In addition,
if a DV camera is a tape camera,

00:55:00.240 --> 00:55:03.840
the format of what's recorded
on that tape can change.

00:55:03.850 --> 00:55:06.170
So even if the user is not, you know,
fiddling with the switch,

00:55:06.240 --> 00:55:08.940
if you're recording off of tape,
that format can change at any time.

00:55:08.940 --> 00:55:11.740
And so responding to this,
this notification will be posted

00:55:11.860 --> 00:55:15.520
whenever the format of the data going
through that connection is altered.

00:55:15.520 --> 00:55:17.620
As an alternative,
if this is what you want to

00:55:17.740 --> 00:55:20.570
do with your application,
you can use key value observing.

00:55:20.630 --> 00:55:22.680
And again,
it's just a standard Cocoa pattern.

00:55:22.680 --> 00:55:25.720
You add an observer directly to
the QT capture connection for

00:55:25.720 --> 00:55:27.330
the format description key path.

00:55:27.440 --> 00:55:28.700
So it's roughly equivalent.

00:55:31.000 --> 00:55:33.100
So this is useful for
QT capture connection,

00:55:33.100 --> 00:55:37.450
but in fact, this paradigm applies to any
QTKit capture object that is

00:55:37.450 --> 00:55:41.390
liable to change at any given time.

00:55:41.880 --> 00:55:45.100
And the reason for that is, again,
QTKit Capture is dealing with a

00:55:45.100 --> 00:55:48.190
lot of live things like devices.

00:55:48.320 --> 00:55:50.570
So one thing that you
might not have known,

00:55:50.570 --> 00:55:55.220
it's not called out very explicitly,
is that anywhere where you

00:55:55.620 --> 00:55:59.360
see an API that uses attribute
for key in QTKit Capture,

00:55:59.360 --> 00:56:02.750
the keys that you pass to that,
they can be used with both key value

00:56:02.750 --> 00:56:06.820
coding and key value observing as
a way of observing those changes.

00:56:06.820 --> 00:56:08.560
And I'll show you some
examples of that in a second.

00:56:08.560 --> 00:56:12.900
So a very common example of
that is QTCapture device.

00:56:14.740 --> 00:56:20.760
So the FireWire EyeSight that
we've shipped in the past,

00:56:20.760 --> 00:56:24.740
probably can't see it too well,
has this little privacy iris on it.

00:56:24.830 --> 00:56:28.460
So you rotate this little thing,
and it covers up the video camera.

00:56:28.460 --> 00:56:31.240
And this actually goes and talks
back to the computer through

00:56:31.310 --> 00:56:33.770
hardware and says this is closed,
so that applications can

00:56:33.780 --> 00:56:35.140
display in their user interface.

00:56:35.140 --> 00:56:36.960
They can say, you've closed the iris.

00:56:36.960 --> 00:56:39.200
That's why you're not
capturing any video.

00:56:41.230 --> 00:56:45.020
And the way we expose this in
QTKit Capture is through an attribute

00:56:45.020 --> 00:56:48.210
on QTCaptureDevice called the
QTCaptureDeviceSuspendedAttribute.

00:56:48.220 --> 00:56:50.840
And this is something that
can change live at any time,

00:56:50.840 --> 00:56:53.380
regardless of whether the device is
associated with a capture session.

00:56:53.380 --> 00:56:56.130
And this is something that you
want to observe changes on.

00:56:56.140 --> 00:56:57.480
You don't want to pull,
and you don't want to do

00:56:57.480 --> 00:56:58.330
anything silly like that.

00:56:58.490 --> 00:57:01.870
So one way of doing that is to, again,
use notifications.

00:57:01.880 --> 00:57:05.560
And QTCaptureDevice exposes a
QTCaptureDeviceAttributeDidChange

00:57:05.560 --> 00:57:07.030
notification to do that.

00:57:07.450 --> 00:57:09.660
And then you can query the user
info of the notification to

00:57:09.660 --> 00:57:11.120
find out exactly what changed.

00:57:12.580 --> 00:57:16.050
As an alternative,
you can use key value observing and

00:57:16.050 --> 00:57:18.040
observe the capture device directly.

00:57:18.040 --> 00:57:21.060
And in this case,
what you do is you can use the attribute

00:57:21.060 --> 00:57:25.700
key directly as the key path on that
object for that key value observing.

00:57:25.700 --> 00:57:29.250
So for any attribute that you
see in a QTKit capture API,

00:57:29.260 --> 00:57:32.840
again, that attribute key is key
value observing compliant.

00:57:37.690 --> 00:57:42.010
So just to sum things up a little bit,
even though out of the box QT Capture

00:57:42.100 --> 00:57:47.290
sessions and the inputs and outputs that
you add to them often give you kind of

00:57:47.290 --> 00:57:51.320
the useful behavior that you wanted,
they can be tweaked to do custom things.

00:57:51.320 --> 00:57:53.820
And in addition,
we provide certain QT Capture inputs

00:57:53.820 --> 00:57:56.920
or certain QT Capture outputs that
let you do custom processing that

00:57:56.920 --> 00:57:58.600
wasn't anticipated by the API.

00:57:58.600 --> 00:58:01.740
And these outputs in particular
are the audio data output and

00:58:01.740 --> 00:58:03.640
the decompressed video output.

00:58:03.640 --> 00:58:06.270
That's where you get your raw
data to do some custom processing.

00:58:07.140 --> 00:58:10.970
You can also have fine-grained
control in a QT Capture session

00:58:11.020 --> 00:58:13.240
by using QT Capture Connection.

00:58:13.240 --> 00:58:16.200
And you can either use that
to inspect and identify media

00:58:16.200 --> 00:58:19.720
streams or use it to actually
turn certain streams of media off.

00:58:23.240 --> 00:58:25.910
So, if you have any additional
questions or problems,

00:58:25.940 --> 00:58:28.040
come see us in the lab.

00:58:28.040 --> 00:58:29.820
That's going to be, I believe, at 2.

00:58:29.820 --> 00:58:31.840
Yeah,
it's going to be at 2 this afternoon.

00:58:31.840 --> 00:58:32.940
So, come in with your questions.

00:58:32.940 --> 00:58:34.310
We'll help you out
with anything you have.

00:58:34.310 --> 00:58:36.420
And, you know, if you just want to chat,
we'll be there, too.

00:58:38.500 --> 00:58:41.620
And again, for more information,
ping Alan Schaefer.

00:58:41.620 --> 00:58:44.260
He will direct you to someone
who can answer your question,

00:58:44.260 --> 00:58:46.080
and probably will answer a
lot of your questions anyway.

00:58:46.080 --> 00:58:49.580
And check out all of our
documentation and sample code,

00:58:49.580 --> 00:58:54.290
both at our developer page and also at
the attendee pages for this session,

00:58:54.290 --> 00:58:55.260
actually.

00:58:55.260 --> 00:58:57.070
They're not up there,
but you should be able to find it

00:58:57.080 --> 00:58:58.380
through the WWDC attendee site.
WEBVTT

00:00:20.090 --> 00:00:22.840
Okay, we're here for Maximizing
Platform Compatibility

00:00:22.840 --> 00:00:23.770
of I/O Kit Drivers.

00:00:23.810 --> 00:00:25.440
That's a mouthful.

00:00:25.480 --> 00:00:26.540
My name's Jay Towslee.

00:00:26.540 --> 00:00:28.950
I'll be your host for this morning.

00:00:29.030 --> 00:00:32.430
And what we're really talking about
is how do you get your drivers to

00:00:32.540 --> 00:00:35.000
work everywhere you want them to work.

00:00:35.000 --> 00:00:36.000
Kind of simple.

00:00:36.160 --> 00:00:37.240
Yeah, right.

00:00:37.370 --> 00:00:41.550
We're also here to talk about K64 because
that's probably the biggest change that

00:00:41.550 --> 00:00:45.000
you're going to undergo next few weeks.

00:00:45.090 --> 00:00:46.440
It's really that simple.

00:00:46.500 --> 00:00:49.910
I should say this does have
nothing to do with the iPhone.

00:00:50.000 --> 00:00:53.000
So, if there are iPhone sessions
that you wanted to go see,

00:00:53.000 --> 00:00:55.770
now would be a good time to go see them.

00:00:56.630 --> 00:00:58.260
So what you're going to learn.

00:00:58.290 --> 00:01:01.630
We're going to talk about extending
your I/O Kit code base lifespan.

00:01:01.750 --> 00:01:05.950
How many people have got code
that's been around since 10 mumble,

00:01:05.950 --> 00:01:07.280
mumble, mumble?

00:01:07.320 --> 00:01:07.990
A few of you.

00:01:08.050 --> 00:01:09.300
Yeah.

00:01:09.500 --> 00:01:16.780
So ideally, it's not something you
want to throw on the floor.

00:01:16.780 --> 00:01:16.780
In order to give you that kind of

00:01:17.310 --> 00:01:36.200
Education or hints, whatever.

00:01:36.200 --> 00:01:36.200
We're going to go through a decision
matrix which will help you understand

00:01:36.200 --> 00:01:36.200
where to kind of make the cutoffs,
cutovers, which APIs to move to,

00:01:36.200 --> 00:01:36.200
that sort of deal.

00:01:36.200 --> 00:01:36.200
And we're going to spend some
time looking at Xcode because the

00:01:36.200 --> 00:01:36.200
new Xcode actually has done some
nice things for KEXT development.

00:01:36.460 --> 00:01:38.200
We're going to start with a
very short history lesson.

00:01:38.200 --> 00:01:40.520
I promise, very short.

00:01:40.520 --> 00:01:43.940
In the beginning, after the Earth cooled
and the dinosaurs came,

00:01:43.940 --> 00:01:46.160
there was 10 and 10.3.9.

00:01:46.390 --> 00:01:47.430
That was pretty straightforward.

00:01:47.440 --> 00:01:54.140
We had one architecture, PowerPC, 32-bit,
user space, 32-bit, kernel space.

00:01:54.220 --> 00:01:56.300
Everything was relatively
straightforward.

00:01:56.510 --> 00:01:58.560
Binary compatibility was good.

00:01:58.860 --> 00:02:01.750
In a KEXT developer's life, yeah,
we made some changes,

00:02:01.760 --> 00:02:04.160
but that was relatively straightforward.

00:02:04.280 --> 00:02:06.320
Then we gave ourselves Tiger.

00:02:06.390 --> 00:02:09.580
Now,
there were tiny bits of 64-bit support,

00:02:09.580 --> 00:02:12.770
and that was sort of the beginning
of you starting to have to think

00:02:12.770 --> 00:02:14.580
about those kind of problems.

00:02:14.650 --> 00:02:17.590
But in general,
we're still pretty good on

00:02:17.590 --> 00:02:19.690
the binary compatibility.

00:02:19.690 --> 00:02:21.540
Life is pretty simple.

00:02:21.600 --> 00:02:23.250
And then we did this to you.

00:02:23.470 --> 00:02:24.960
We gave you Intel.

00:02:25.010 --> 00:02:26.160
Sorry about that.

00:02:26.220 --> 00:02:29.070
Well, not really.

00:02:29.330 --> 00:02:34.240
The good news was that we kept
the PowerPC support around.

00:02:34.360 --> 00:02:38.350
How many people have implemented
Rosetta support in their texts?

00:02:38.600 --> 00:02:41.240
The same guys that have been
writing the KEXT since 10-- OK,

00:02:41.240 --> 00:02:42.740
interesting problem.

00:02:42.930 --> 00:02:46.300
So we'll talk a little bit about
getting Rosetic support into your KEXTs,

00:02:46.340 --> 00:02:52.510
as well as how you're going to
deal with PowerPC-only issues,

00:02:52.510 --> 00:02:52.510
Intel-only issues, and so forth.

00:02:52.790 --> 00:02:53.700
Then we gave you Leopard.

00:02:53.700 --> 00:02:57.240
Now the good news with Leopard was
the matrix doesn't change a whole lot,

00:02:57.380 --> 00:03:02.170
so that kind of gave you time
to get your stuff in order.

00:03:02.580 --> 00:03:05.940
The bad news was that that's kind of
when we really modernized everything.

00:03:05.940 --> 00:03:09.740
We got 64-bit user space, and really,
you needed to have your

00:03:09.740 --> 00:03:16.770
text be 64-bit internally,
or at least understand how to deal with

00:03:16.770 --> 00:03:16.770
it when somebody contacted you that way.

00:03:17.160 --> 00:03:19.450
And then finally,
we are where we are today,

00:03:19.650 --> 00:03:21.180
with the Snow Leopard preview.

00:03:21.230 --> 00:03:23.730
Now, if you haven't read yet,
the Snow Leopard preview

00:03:23.730 --> 00:03:25.100
doesn't boot on PowerPC.

00:03:25.170 --> 00:03:29.990
So at least you don't have to test that
right now until we do something later.

00:03:30.440 --> 00:03:32.600
But you do have K64.

00:03:32.710 --> 00:03:36.290
How many people have
K64-capable machines at home?

00:03:37.080 --> 00:03:38.760
Okay, it's the same group of people.

00:03:38.760 --> 00:03:41.000
I think you should exchange
business cards afterwards.

00:03:43.680 --> 00:03:46.490
Yeah, they have their own support group.

00:03:46.640 --> 00:03:49.470
The other change that's
kind of significant is that

00:03:49.530 --> 00:03:53.350
in 64-bit kernel space,
you can have a 32-bit user process

00:03:53.350 --> 00:03:55.840
contacting your 64-bit driver.

00:03:56.100 --> 00:03:59.400
So you need to understand what's
going to bite you in the butt there.

00:04:00.310 --> 00:04:04.720
So that's kind of the history lesson
in how we got to where we are today.

00:04:04.740 --> 00:04:06.830
A little review for what
we're really talking about.

00:04:07.080 --> 00:04:08.690
Kernel land is different.

00:04:08.830 --> 00:04:10.880
Our driver executes in the kernel.

00:04:10.920 --> 00:04:18.560
You need to protect the rest of the--you
need--your code needs to not crash.

00:04:18.560 --> 00:04:18.560
Ugh, let's--

00:04:18.980 --> 00:04:19.740
Why is that important?

00:04:19.740 --> 00:04:22.880
Because if you crash in the kernel,
the whole system goes in the dumper.

00:04:24.600 --> 00:04:25.510
That would be bad.

00:04:25.780 --> 00:04:27.000
Don't do that.

00:04:27.130 --> 00:04:29.190
Applications execute in user space.

00:04:29.490 --> 00:04:31.130
How do we cross the divide?

00:04:31.310 --> 00:04:33.500
Well, we're doing that in I/O Kit land.

00:04:33.590 --> 00:04:37.900
And common services are vended
applications by system services,

00:04:38.030 --> 00:04:39.530
which are the things we're
all taking advantage of,

00:04:39.660 --> 00:04:44.960
BSD land-type things,
and the more user-accessible

00:04:44.980 --> 00:04:47.900
devices that we're all plugging
into our machines all the time,

00:04:47.900 --> 00:04:50.600
USB, FireWire, et cetera.

00:04:50.990 --> 00:04:54.580
If your device doesn't require custom
access beyond what the families give,

00:04:54.700 --> 00:04:57.180
though, that's good news.

00:04:57.220 --> 00:05:01.900
I/O Kit families pretty much handle
the low-hanging fruit for you.

00:05:02.170 --> 00:05:04.020
There are even things
called codeless KEXTs,

00:05:04.100 --> 00:05:05.840
which are literally that simple.

00:05:06.020 --> 00:05:08.890
If you don't need custom access,
you're done.

00:05:08.890 --> 00:05:11.900
Anybody here doesn't need custom access?

00:05:12.020 --> 00:05:14.100
Because if you don't, you can--no, okay.

00:05:14.280 --> 00:05:20.500
Otherwise, I/O Kit provides two bridges,
I/Octal type controls or mechanisms.

00:05:20.750 --> 00:05:21.970
That's through the I/O registry.

00:05:21.980 --> 00:05:22.980
That's pretty straightforward.

00:05:23.000 --> 00:05:23.850
We're going to look at that.

00:05:24.060 --> 00:05:27.300
For a lot of people, that's all you need.

00:05:27.580 --> 00:05:30.100
That's all you're going
to need in your KEXT.

00:05:30.100 --> 00:05:32.570
If you need--depends
on your point of view,

00:05:32.570 --> 00:05:36.480
I suppose, higher level,
lower level access, then you're going to

00:05:36.480 --> 00:05:38.100
be in I/O user clients.

00:05:38.100 --> 00:05:40.100
It's pretty straightforward.

00:05:40.100 --> 00:05:42.100
Basic process, define a set of entry
points in a common header.

00:05:42.100 --> 00:05:44.100
We'll look at that.

00:05:44.100 --> 00:05:47.920
Your app--now, we don't usually recommend
putting it into an app.

00:05:47.920 --> 00:05:51.480
We're typically going to put you
into a driver or a framework or,

00:05:51.480 --> 00:05:55.060
excuse me, a library or a framework
that then apps can call.

00:05:55.190 --> 00:05:57.100
But some people are building
it directly into their app.

00:05:57.340 --> 00:06:00.100
That's kind of a stub
function for each entry point.

00:06:00.100 --> 00:06:04.720
And then the I/O user client subclass
in your KEXT is what actually is

00:06:04.820 --> 00:06:07.310
going to implement those tasks.

00:06:08.130 --> 00:06:10.670
So the I/O registry,
for those of you that weren't

00:06:10.810 --> 00:06:13.650
in Dean's talk earlier,
very quick review,

00:06:13.680 --> 00:06:17.520
it's what we're using through
the I/O Kit framework to locate

00:06:17.520 --> 00:06:19.240
and communicate with drivers.

00:06:19.260 --> 00:06:22.640
We can locate drivers in
the registry by properties,

00:06:22.830 --> 00:06:29.630
so that's how you differentiate
between a driver for card A and card B.

00:06:29.810 --> 00:06:32.730
Apps can read and optionally,
and I do say optionally,

00:06:32.730 --> 00:06:35.640
the default behavior is
I/O Registry is read only.

00:06:35.650 --> 00:06:38.780
We're going to look at an example of
how to make I/O Registry read and write.

00:06:38.780 --> 00:06:42.720
Again, for that situation where your
need to cross the kernel boundary

00:06:42.880 --> 00:06:46.080
to actually move data back
and forth is pretty minimal.

00:06:46.080 --> 00:06:50.210
And then if you want to extend
or need to extend because of the

00:06:50.210 --> 00:06:52.220
functionality of your device,
you've got the I/O user

00:06:52.220 --> 00:06:54.560
client and plugin,
again, plugin, library,

00:06:54.560 --> 00:07:01.250
etc., etc., which will let your app have
a direct connection into the kernel.

00:07:02.060 --> 00:07:06.090
Now, with I/O User Client, big gotcha.

00:07:06.580 --> 00:07:09.260
You are now--we are holding you,
at some level,

00:07:09.390 --> 00:07:13.020
responsible to make sure that
you're not going to let bad

00:07:13.020 --> 00:07:15.110
things happen in the kernel.

00:07:15.380 --> 00:07:20.690
So remember, you're exposing a library
or a stub or something,

00:07:20.690 --> 00:07:24.460
which may be an argument for putting
it into the application itself.

00:07:24.530 --> 00:07:28.430
You're exposing that to other
applications to do with what they will.

00:07:28.580 --> 00:07:32.820
So you want to make sure your
API is as small as humanly possible.

00:07:32.890 --> 00:07:34.270
You want to validate the access.

00:07:34.380 --> 00:07:36.720
Make sure that you're talking to
who you think you're talking to.

00:07:36.720 --> 00:07:41.490
And related to that, if you check out
Apple Smart Battery in Darwin,

00:07:41.490 --> 00:07:43.940
you'll see an example of
using the I/O user client,

00:07:43.940 --> 00:07:48.680
Client has privilege subclass,
which you may find useful.

00:07:48.730 --> 00:07:51.120
But again, be careful out there.

00:07:51.170 --> 00:07:53.870
Because as we all know,
that's the last thing we need,

00:07:53.870 --> 00:07:57.960
is to have the Mac become the same
home for problems that some other

00:07:57.960 --> 00:08:00.250
operating systems have become.

00:08:01.350 --> 00:08:06.580
Before we go further, again,
I wanted to talk about kind of the easy,

00:08:06.580 --> 00:08:11.400
the minimal thing that you can do if
you need custom access from user space.

00:08:11.440 --> 00:08:12.870
And it's a single API.

00:08:13.020 --> 00:08:14.530
It's got great compatibility.

00:08:14.540 --> 00:08:16.940
In fact,
we've got code that will run easily

00:08:17.050 --> 00:08:23.100
from 10.3.9 all the way forward to
10.6 with basically an ifdef to say,

00:08:23.130 --> 00:08:27.020
oh, yeah,
this time I built it for a 10.3.9 text.

00:08:27.060 --> 00:08:29.220
And it's really pretty straightforward.

00:08:29.270 --> 00:08:31.570
and that's the I/O registry.

00:08:32.890 --> 00:08:34.600
We're going to look at
I/O Registry in detail,

00:08:34.650 --> 00:08:37.950
but now I want to go through the
operating systems that we have

00:08:37.950 --> 00:08:40.260
historically needed to support.

00:08:40.410 --> 00:08:43.870
So Panther is PowerPC only.

00:08:44.340 --> 00:08:47.490
No I/O DMA command,
which is sort of the modern

00:08:47.490 --> 00:08:49.500
way of dealing with memory.

00:08:49.740 --> 00:08:52.690
32 applications only.

00:08:52.800 --> 00:09:00.290
For I/O user client access,
you had get target and method for index,

00:09:00.290 --> 00:09:00.290
and that was the only
way you could do it.

00:09:00.810 --> 00:09:03.380
Now, realistically,
and I think if people were in

00:09:03.430 --> 00:09:07.840
Bertrand's State of the Union,
he's suggesting that probably 10.3.9

00:09:07.930 --> 00:09:09.770
is not the way to go at this stage.

00:09:09.780 --> 00:09:13.130
If you have existing code, though,
there's no particular

00:09:13.150 --> 00:09:16.300
reason to throw it away,
particularly if it works.

00:09:16.440 --> 00:09:18.100
If it doesn't work,
maybe you should consider

00:09:18.200 --> 00:09:19.020
throwing it away.

00:09:19.020 --> 00:09:22.480
The SDK, however,
is not supplied with Snow Leopard,

00:09:22.480 --> 00:09:25.780
so you'll need to get that
from some previous build of the

00:09:25.780 --> 00:09:27.860
OS that you have laying around.

00:09:28.780 --> 00:09:30.280
It does install on Snow Leopard.

00:09:30.280 --> 00:09:31.600
It does work on Snow Leopard.

00:09:34.490 --> 00:09:36.970
With Tiger, in particular,
once we got to Universal,

00:09:36.970 --> 00:09:40.840
you've got Intel and PowerPC, Rosetta,
which I think is probably the most

00:09:40.970 --> 00:09:46.770
important thing that you can do kind
of minimally to make your life easier.

00:09:46.780 --> 00:09:51.110
32- and 64-bit application support,
barely.

00:09:51.120 --> 00:09:54.300
LibSystem gave us 64-bit support.

00:09:54.300 --> 00:09:57.350
The I/O user client functionality,
we're still a get-targeted

00:09:57.470 --> 00:09:58.500
method for index.

00:09:58.570 --> 00:10:01.800
Structures for parameter passing
is something that we've started

00:10:01.910 --> 00:10:05.400
to recommend at this point,
and that's primarily because

00:10:05.400 --> 00:10:08.820
it simplifies the design.

00:10:08.820 --> 00:10:11.880
And I think you'll see in the
example where using a structure

00:10:12.000 --> 00:10:15.680
to shuffle data around in and out,
as opposed to a whole bunch of scalers,

00:10:15.730 --> 00:10:17.040
will make your life easier.

00:10:17.040 --> 00:10:21.000
And finally,
you had the problem if you were dealing

00:10:21.000 --> 00:10:24.880
with an older PowerPC code base,
you still had I-O memory

00:10:24.880 --> 00:10:28.200
cursor laying around,
and you really wanted to start moving

00:10:28.200 --> 00:10:30.200
the I-O DMA command at this point.

00:10:32.150 --> 00:10:33.810
Leopard, more decisions.

00:10:33.920 --> 00:10:38.830
To me,
the decision point comes down to kind of

00:10:39.010 --> 00:10:45.230
your code is sitting at 10.4 and earlier,
and then if you're going 10.5 and later,

00:10:45.230 --> 00:10:50.570
and we'll show you some tricks on how
to ship sort of one kex to do that,

00:10:50.600 --> 00:10:52.770
but that's kind of the
great dividing line.

00:10:52.780 --> 00:10:57.780
Leopard is sort of the modern world,
and 10.4 and earlier is sort of the,

00:10:57.780 --> 00:11:00.830
I don't want to use,
really use the word prehistoric,

00:11:00.980 --> 00:11:03.820
but kind of the earlier way to do things.

00:11:03.940 --> 00:11:08.440
We got a new way of dispatching
methods called the external method.

00:11:08.580 --> 00:11:11.520
Everything from Tiger still
applies and becomes more important.

00:11:11.710 --> 00:11:15.900
I/O DMA command is the way
to deal with memory in KEXTs.

00:11:15.980 --> 00:11:21.400
I/O Memory Descriptor goes to
64-bit support for user land.

00:11:21.740 --> 00:11:25.840
And if you, the good news is,
is if you have gone through

00:11:25.840 --> 00:11:30.420
and modernized for Leopard,
then for the most part,

00:11:30.480 --> 00:11:36.060
within a couple of hours,
and clicking the 64-bit checkbox,

00:11:36.230 --> 00:11:38.870
and the hours are like testing
and resolving warnings,

00:11:38.870 --> 00:11:43.590
you're probably going to be
Snow Leopard K64 text aware.

00:11:43.590 --> 00:11:45.080
Life will be good.

00:11:45.080 --> 00:11:48.400
So, you know,
if you do the work for Leopard now,

00:11:48.400 --> 00:11:50.900
you won't have to do the work
for Snow Leopard in the future.

00:11:53.300 --> 00:11:55.460
If, however,
you're going to start at Snow Leopard,

00:11:55.460 --> 00:11:59.030
and that's kind of your jump-off point,
a couple things to know about.

00:11:59.050 --> 00:12:01.780
Obviously, you've heard earlier in
the week the 64-bit kernel.

00:12:01.780 --> 00:12:04.850
There are two Intel KEXT architectures.

00:12:04.860 --> 00:12:07.650
You have to have a
32-bit and a 64-bit KEXT.

00:12:07.800 --> 00:12:10.660
The 32-bit KEXT will not load.

00:12:10.660 --> 00:12:15.840
In fact, I think when I talked to some
of the folks after the K64 lab,

00:12:15.840 --> 00:12:20.540
that was one of the sample solutions to
how to tell you're on a 64-bit kernel.

00:12:20.540 --> 00:12:24.200
If the 32-bit KEXT only doesn't load,
you're on a 64-bit kernel.

00:12:24.200 --> 00:12:29.560
Support for 64-bit addressing everywhere,
in and out, both sides.

00:12:29.600 --> 00:12:33.000
IO memory descriptor is what
you want to use for that,

00:12:33.020 --> 00:12:36.980
and there's a couple of pieces that
were available in Leopard and later.

00:12:36.980 --> 00:12:41.850
Availability.h, which is going to let
you ifdef your code.

00:12:41.900 --> 00:12:45.330
We'll look at a sample of how that
works when we look at the sample code.

00:12:45.370 --> 00:12:48.730
And the C preprocessor,
you're going to learn to know and love.

00:12:48.930 --> 00:12:52.600
Again, this is the issue where you're
taking an existing code base,

00:12:52.920 --> 00:12:55.300
you want to keep a single
existing code base,

00:12:55.300 --> 00:12:56.560
and bring it forward.

00:12:56.700 --> 00:12:59.420
If what you're trying to do,
it depends on your

00:12:59.420 --> 00:13:02.830
development methodology,
but what we're going to concentrate

00:13:02.830 --> 00:13:05.570
on is the case where you'd really
like to keep things and just

00:13:05.570 --> 00:13:10.340
sort of migrate as opposed to,
here's a clean sheet, or here's the copy,

00:13:10.340 --> 00:13:11.690
and here's the build for that.

00:13:11.840 --> 00:13:18.070
The obligatory I chart in
every presentation at WWDC.

00:13:18.540 --> 00:13:22.780
These are the big changes
between K64 and previous,

00:13:22.780 --> 00:13:24.480
with the I/O memory descriptor.

00:13:24.490 --> 00:13:31.690
The good news is all this stuff is A,
in the documentation that's on your DVD.

00:13:32.480 --> 00:13:34.400
Release notes, thank you.

00:13:34.520 --> 00:13:35.640
It's early.

00:13:35.690 --> 00:13:39.690
Maybe I did go to the party
and I just didn't remember it.

00:13:40.270 --> 00:13:42.930
So I'll get the eye chart off,
but most of these are a drop-in,

00:13:42.930 --> 00:13:45.530
one-for-one replacement,
and it's actually pretty

00:13:45.540 --> 00:13:46.920
easy to do this update.

00:13:46.950 --> 00:13:51.120
The other issue-- how many people were
at the K64 talk earlier in the week?

00:13:51.140 --> 00:13:51.510
A lot of you.

00:13:51.650 --> 00:13:52.280
Good.

00:13:52.370 --> 00:13:54.860
So this slide should look familiar.

00:13:54.890 --> 00:13:59.080
This is one of those deals where
you didn't realize you had the

00:13:59.200 --> 00:14:01.720
problem until you had the problem.

00:14:01.750 --> 00:14:03.010
And it's all about alignment.

00:14:03.130 --> 00:14:06.190
Now, we have to remember that different
compilers for different architectures

00:14:06.320 --> 00:14:09.570
have different rules about how
they're going to lay things out.

00:14:10.190 --> 00:14:15.260
And if we compare the 32-bit and
64-bit versions of this same structure,

00:14:15.260 --> 00:14:17.510
you'll see we've got some padding issues.

00:14:17.710 --> 00:14:22.320
So the A tag comes out beautifully,
but then we go to-- because we've

00:14:22.320 --> 00:14:26.960
defined the B pointer as just a
void star on a 64-bit machine,

00:14:26.960 --> 00:14:31.200
that's now an 8-byte-wide
structure-- or excuse me,

00:14:31.230 --> 00:14:32.280
entity.

00:14:32.530 --> 00:14:33.710
That causes us a problem.

00:14:33.890 --> 00:14:35.900
We have to deal with
that inside the kecks,

00:14:35.960 --> 00:14:39.790
because this pad that we
weren't expecting showed up.

00:14:40.720 --> 00:14:43.900
We're okay on most of the rest of this,
but we also have this ending

00:14:43.900 --> 00:14:45.800
pad that could bite us.

00:14:45.940 --> 00:14:48.620
So on your text,
if you haven't thought through

00:14:48.620 --> 00:14:52.300
the alignment issues in the
data you're passing in and out,

00:14:52.430 --> 00:14:55.480
you're going to have
up to four code paths,

00:14:55.630 --> 00:14:59.800
32 to 64, both directions,
to deal with pulling these

00:14:59.800 --> 00:15:02.100
structures apart and updating them.

00:15:02.140 --> 00:15:05.030
So what we're recommending
is now is an opportunity,

00:15:05.100 --> 00:15:07.450
even though you may lose
a few bytes or bits,

00:15:07.450 --> 00:15:10.520
depending on how much shifting
around you have to do,

00:15:10.520 --> 00:15:15.340
now is the opportunity to sort of rethink
the structures you're passing through.

00:15:15.340 --> 00:15:18.300
It does mean that you're going to
have to learn a little bit more,

00:15:18.300 --> 00:15:20.430
maybe than you had to before,
about the way the

00:15:20.430 --> 00:15:24.430
compiler lays things out,
but it's kind of a small price to pay.

00:15:24.440 --> 00:15:27.740
And the reality is that's something
that we're going to be stuck with

00:15:27.850 --> 00:15:31.270
for the foreseeable future because
compilers change all the time.

00:15:33.420 --> 00:15:36.460
We're going to move on to some demo now.

00:15:36.570 --> 00:15:40.740
We're going to look at Xcode,
the modern Xcode 3.2.

00:15:40.870 --> 00:15:43.530
If you can switch me to demo A, please.

00:15:48.760 --> 00:15:56.100
So this is a piece of sample code that
will be available almost immediately.

00:15:56.100 --> 00:16:00.700
We hope that it's going to be up a
little later today for you to take home.

00:16:00.700 --> 00:16:03.200
And it's a pretty simple project.

00:16:03.200 --> 00:16:08.410
It's a PCI driver that matches on
every display card in your system.

00:16:08.650 --> 00:16:10.930
We'll start by looking at
the targets themselves,

00:16:10.930 --> 00:16:15.890
because this is where we were talking
about making it more compatible.

00:16:16.820 --> 00:16:20.300
And I apologize that I can't
get this text larger.

00:16:20.330 --> 00:16:24.740
One of the things to note from Xcode
in the new version is they got a lot

00:16:24.740 --> 00:16:28.300
more context sensitive about where
they offered you certain options,

00:16:28.300 --> 00:16:29.300
and it got easier.

00:16:29.300 --> 00:16:33.700
You no longer have to guess where
you're going to add something.

00:16:33.700 --> 00:16:38.150
You basically can choose
any field and add a build

00:16:38.150 --> 00:16:43.800
setting based on architecture,
SDK, etc.

00:16:43.800 --> 00:16:44.600
So that's kind of handy.

00:16:44.600 --> 00:16:47.720
What we do have to define
for this particular project

00:16:47.950 --> 00:16:50.600
is 32- and 64-bit universal.

00:16:50.730 --> 00:16:54.440
You'll note this is the
Leopard version of this kex,

00:16:54.440 --> 00:16:57.120
Leopard and Snow Leopard version.

00:16:57.590 --> 00:17:08.210
We've defined SDKs for
the PowerPC and Intel.

00:17:08.210 --> 00:17:08.210
Those are the 32-bit versions of the OS,
and we've defined the

00:17:08.210 --> 00:17:08.210
Intel 64-bit as 10.6.

00:17:08.760 --> 00:17:12.110
The part that really will
get you is in two places.

00:17:12.220 --> 00:17:14.520
One, picking the correct compiler
for the architecture.

00:17:14.820 --> 00:17:17.000
So as you may remember,
if you're running Leopard,

00:17:17.000 --> 00:17:24.000
the default compiler on that was 4.0 GCC,
and the default compiler on 10.6 is 4.2.

00:17:24.000 --> 00:17:28.490
The part that is actually handy for us
that we're going to be able to use for

00:17:28.490 --> 00:17:30.440
the code is the deployment targets.

00:17:30.440 --> 00:17:37.840
Those basically will set up
symbols in the compile time,

00:17:37.840 --> 00:17:41.430
which will allow you to make
decisions as to what part of the

00:17:41.580 --> 00:17:44.700
code you're going to compile and
load for that particular driver.

00:17:48.750 --> 00:17:54.830
If we look at the target for
the 10.4 version of the code,

00:17:55.100 --> 00:17:57.660
we don't ask for Google, we unclick.

00:17:57.870 --> 00:17:58.240
Yipe.

00:17:58.340 --> 00:18:01.590
Let's try this trick again.

00:18:02.800 --> 00:18:04.020
You're not going to see
a whole lot of changes.

00:18:04.130 --> 00:18:05.650
We are 32-bit only.

00:18:05.810 --> 00:18:08.240
We've gone to the 10.4 SDK everywhere.

00:18:08.310 --> 00:18:12.740
You will note we've
reduced the complexity of

00:18:13.260 --> 00:18:16.700
The architecture argument,
and everything's GCC 4.0.

00:18:16.730 --> 00:18:26.520
What we did add is a dependency
on the other text and a copy where

00:18:26.520 --> 00:18:28.170
what we're doing is we're going
to add a copy of the other text,

00:18:29.700 --> 00:18:34.940
is copying that file into...is it here?

00:18:35.050 --> 00:18:37.020
I apologize.

00:18:42.520 --> 00:18:45.500
The KEXT that we built for 10.4
gets copied into the plugin

00:18:45.610 --> 00:18:48.910
directory of the 10.5 and 10.6 KEXT.

00:18:49.130 --> 00:18:52.900
That will cause it to
load only on 10.4 systems.

00:18:52.900 --> 00:18:55.900
It's kind of a hack, but it works.

00:18:56.460 --> 00:18:59.170
This is more targeted
at the situation where,

00:18:59.270 --> 00:19:02.580
from a support perspective,
you absolutely want to

00:19:02.580 --> 00:19:05.100
ship exactly one text.

00:19:08.500 --> 00:19:12.050
So, one of the things we talked about
earlier was the I/O registry.

00:19:12.080 --> 00:19:16.270
And I wanted to take a quick peek at what
we actually stuffed into the I/O registry

00:19:16.890 --> 00:19:21.890
for purposes of changing settings,
managing different values in your driver

00:19:21.900 --> 00:19:23.400
that then your driver can react to.

00:19:23.400 --> 00:19:25.400
So we've added a little dictionary.

00:19:25.400 --> 00:19:29.400
You could certainly construct
this on the fly in your driver.

00:19:29.400 --> 00:19:33.230
It's just a lot more code to demo,
and so I chose to actually add this

00:19:33.380 --> 00:19:36.230
dictionary to the plist itself.

00:19:36.400 --> 00:19:39.400
And we're going to be looking at
the display parameters section,

00:19:39.400 --> 00:19:42.400
and we're actually going to be
changing the value of the brightness.

00:19:42.400 --> 00:19:44.400
It's pretty straightforward.

00:19:44.400 --> 00:19:48.400
Again, this is something you could
do all internally in the code.

00:19:48.440 --> 00:19:52.400
So what we need to look
at is in the code itself,

00:19:52.400 --> 00:19:54.430
we're going to define
that in a shared file,

00:19:54.490 --> 00:19:57.310
and we're going to just
put some arbitrary values

00:19:57.390 --> 00:20:00.500
because it's a lot easier than
remembering to write brightness,

00:20:00.520 --> 00:20:04.400
and that way I change this in one place,
normal programming technique.

00:20:04.400 --> 00:20:07.250
And those are the,
these keys are what we're

00:20:07.250 --> 00:20:09.080
going to be using in our code.

00:20:10.700 --> 00:20:17.360
All right, so let's say we wanna
look at the actual client.

00:20:17.380 --> 00:20:19.090
This is your user space code.

00:20:19.100 --> 00:20:20.660
This would, again,
normally be a library that

00:20:20.660 --> 00:20:22.380
you're gonna implement.

00:20:22.390 --> 00:20:25.800
But in this case, we've rolled the whole
thing into an application.

00:20:26.260 --> 00:20:29.900
So the first thing you're going to
do is you're going to actually match.

00:20:29.900 --> 00:20:33.420
If you stayed with Dean's talk,
you understand what you're doing here.

00:20:33.420 --> 00:20:38.150
Basically,
this command is going to match on every

00:20:38.150 --> 00:20:40.300
device that's relevant for your key.

00:20:40.300 --> 00:20:42.980
Then we're going to
iterate through those,

00:20:43.140 --> 00:20:46.200
each device in kind,
and we're going to do a couple of things.

00:20:46.240 --> 00:20:48.710
If we found it,
which we're going to today,

00:20:48.710 --> 00:20:51.360
we're going to run a
test on the properties,

00:20:51.360 --> 00:20:53.000
which is where we talked
about doing the I.O.

00:20:53.000 --> 00:20:55.250
registry settings,
and we're going to do a test

00:20:55.250 --> 00:20:58.310
on the user-client piece,
which is the more advanced section.

00:20:58.320 --> 00:21:07.410
So if we look at the properties,
we're going to jump over here.

00:21:08.560 --> 00:21:14.680
And properties that we're doing with
I/O registry are all going to be

00:21:15.070 --> 00:21:17.300
sent back and forth via dictionaries.

00:21:17.370 --> 00:21:21.460
That's a little more complex,
as you can see, to do the setup,

00:21:21.540 --> 00:21:24.540
because I have to do some
core foundation magic.

00:21:24.620 --> 00:21:27.340
But then the call's relatively
simple once I've put it in.

00:21:27.340 --> 00:21:32.200
I'm making one call to this
I/O registry entry set CF properties.

00:21:32.260 --> 00:21:34.480
This is something that, again,
by default,

00:21:34.620 --> 00:21:35.920
you are going to have to override.

00:21:36.020 --> 00:21:38.620
By default, this is going to return,
nope, sorry, nothing was set,

00:21:38.680 --> 00:21:39.200
you're not allowed.

00:21:41.920 --> 00:21:45.740
So let's go over onto the kernel side
and look at what's actually happening.

00:21:45.750 --> 00:21:50.500
Now what I chose to do on this was not

00:21:51.510 --> 00:21:56.800
Not actually pull this
into the user client code.

00:21:56.970 --> 00:21:58.700
That's purely a stylistic thing.

00:21:58.850 --> 00:22:00.500
You can put this in the user client.

00:22:00.500 --> 00:22:01.740
You can put this in your main driver.

00:22:01.740 --> 00:22:03.740
It really doesn't matter.

00:22:03.750 --> 00:22:09.290
This is the only if-def that
you'll have to deal with for 10.4

00:22:09.290 --> 00:22:13.320
to later with this technique,
and it's pretty straightforward.

00:22:13.340 --> 00:22:16.650
You're matching on the correct KEXT name.

00:22:17.220 --> 00:22:20.180
So the set properties
itself is a simple override.

00:22:20.200 --> 00:22:24.540
Again,
you do have some core foundation-like.

00:22:24.540 --> 00:22:26.420
We did not implement core
foundation in the kernel,

00:22:26.420 --> 00:22:28.640
but we cherry-picked the
pieces that we needed,

00:22:29.050 --> 00:22:33.260
where we now need to deserialize
effectively that dictionary.

00:22:33.290 --> 00:22:35.030
Now,
there is one immediate advantage to this.

00:22:35.230 --> 00:22:38.380
You'll notice that I'm not doing
anything worried about Rosetta because

00:22:38.380 --> 00:22:42.740
the serialization of getting it in
and out of the dictionary took care

00:22:42.740 --> 00:22:45.660
of any Indian-ness issues that I had.

00:22:45.660 --> 00:22:48.840
So once I've set the value after
pulling it out of the dictionary,

00:22:48.920 --> 00:22:50.470
or pulled the value
out of the dictionary,

00:22:50.550 --> 00:22:52.800
then I'm going to do the update registry.

00:22:52.800 --> 00:22:55.490
Now, the update registry call
is a little trickier,

00:22:55.860 --> 00:22:59.020
partially because we
do not have protection,

00:22:59.020 --> 00:23:03.220
if you will,
for the I/O registry collections.

00:23:03.270 --> 00:23:04.920
It's not protected
against multiple writers.

00:23:05.090 --> 00:23:10.180
So the first thing you're going to do is
grab a copy of the properties that are

00:23:10.180 --> 00:23:12.190
relevant to this particular dictionary.

00:23:13.080 --> 00:23:18.520
Then you're going to copy that collection
and throw it into another dictionary.

00:23:18.590 --> 00:23:22.050
If you don't, your code will panic,
I promise.

00:23:22.750 --> 00:23:24.120
That makes it really easy to debug.

00:23:24.160 --> 00:23:26.680
When it panics and it says,
"I think you did that wrong,"

00:23:26.760 --> 00:23:29.370
and it literally will call out,
"I think you've just touched the

00:23:29.370 --> 00:23:33.960
I/O registry in an unsafe way," you'll
know this is likely your problem.

00:23:34.290 --> 00:23:38.200
You also know things about the
actual structure of that dictionary.

00:23:38.200 --> 00:23:42.380
So in this section of code,
I'm actually iterating down effectively

00:23:42.580 --> 00:23:45.990
through the dictionary until I get
to the point where I've got the

00:23:45.990 --> 00:23:47.530
value that I wanted to change.

00:23:47.630 --> 00:23:51.130
At that point,
I can make one call to set property.

00:23:51.370 --> 00:23:55.890
That's serialized and a safe
way to get the data back in.

00:23:57.110 --> 00:24:00.760
So it's really pretty straightforward
if all you need is to do simple kind

00:24:00.760 --> 00:24:04.280
of command and control sorts of things,
enable features,

00:24:04.280 --> 00:24:06.660
etc., etc., on your driver.

00:24:07.470 --> 00:24:09.790
At that point,
your other code in your driver is

00:24:09.830 --> 00:24:11.120
going to be going around going,
"Hey,

00:24:11.120 --> 00:24:13.400
I just noticed a change in the registry.

00:24:13.450 --> 00:24:15.260
Now I can go do things
based on that change."

00:24:17.000 --> 00:24:18.040
All right.

00:24:18.210 --> 00:24:23.040
So again,
that was pretty straightforward, I think.

00:24:23.040 --> 00:24:23.780
I hope you agree.

00:24:23.780 --> 00:24:27.850
And then setting is, or getting is free.

00:24:27.850 --> 00:24:31.160
Getting doesn't require
any code on your part.

00:24:31.320 --> 00:24:32.960
You're basically querying the registry.

00:24:32.960 --> 00:24:36.590
You're querying it with the
I/O registry entry create CF properties,

00:24:36.590 --> 00:24:39.980
which is basically taking a
snapshot of your existing match.

00:24:39.980 --> 00:24:42.380
You're going to look up the
value you're looking for.

00:24:42.380 --> 00:24:44.160
So in this case,
I'm matching on the name that

00:24:44.160 --> 00:24:45.710
I actually matched for the device.

00:24:45.800 --> 00:24:51.210
And then I'm going to do on the user
space side some core foundation work,

00:24:51.210 --> 00:24:54.670
in particular because this is a string,
to pull that string out of the

00:24:54.670 --> 00:24:57.640
dictionary and use it however
I want to use it in my program.

00:24:57.800 --> 00:25:01.840
Again, so setting and getting
properties out of the registry,

00:25:02.070 --> 00:25:03.800
simple, very compatible.

00:25:03.800 --> 00:25:07.190
There's a little bit of
overhead more than direct,

00:25:07.190 --> 00:25:09.800
but that's about the only downside.

00:25:09.800 --> 00:25:11.770
All right.

00:25:11.810 --> 00:25:14.700
So you may remember.

00:25:15.500 --> 00:25:17.440
back here.

00:25:20.900 --> 00:25:21.740
Whoops.

00:25:21.740 --> 00:25:25.200
I may remember where I am.

00:25:25.200 --> 00:25:27.520
Oh, yeah.

00:25:27.630 --> 00:25:29.790
Sorry, lost.

00:25:30.790 --> 00:25:32.700
No,
I don't think it's a pop-up to the left.

00:25:32.740 --> 00:25:35.170
You're right, it's a pop-up to the left.

00:25:35.350 --> 00:25:36.940
Thank you, Nick.

00:25:40.160 --> 00:25:42.920
All of this to say,
first we're testing the properties,

00:25:42.920 --> 00:25:44.100
and then we're testing the user client.

00:25:44.100 --> 00:25:50.640
So the user client, again, like I said,
is more work, and it's more useful.

00:25:50.640 --> 00:25:51.820
A couple of quick things.

00:25:52.050 --> 00:25:54.800
You have to connect to the
driver if you're going to

00:25:54.800 --> 00:25:56.210
access the user client at all.

00:25:56.480 --> 00:26:00.790
And this is kind of the first place where
we're going to start seeing if-defs.

00:26:00.880 --> 00:26:04.830
If you're running 10.4 or earlier,
you're going to be using structure I,

00:26:04.830 --> 00:26:05.680
structure O.

00:26:05.680 --> 00:26:09.310
If you're running 10.5 and later,
you should be using

00:26:09.350 --> 00:26:11.770
I/O call struct method.

00:26:12.540 --> 00:26:15.970
And we're actually not doing
any setup for method one.

00:26:16.120 --> 00:26:18.400
We're just going to go in and use it.

00:26:18.600 --> 00:26:22.320
So we do need to look at one small thing.

00:26:22.450 --> 00:26:24.110
Pardon me.

00:26:24.570 --> 00:26:26.870
That is there.

00:26:27.070 --> 00:26:30.750
And at the top of the shared header,
you're going to actually

00:26:30.750 --> 00:26:33.000
declare an index of the methods.

00:26:33.070 --> 00:26:35.770
And that's actually how we're
going to cross the kernel boundary.

00:26:35.960 --> 00:26:37.370
We're using Mach messaging to do this.

00:26:37.640 --> 00:26:38.960
All of it is hidden from you.

00:26:39.010 --> 00:26:43.310
And believe me, you don't want to use
MIG if you don't have to.

00:26:43.660 --> 00:26:46.940
For those of us in the front
row that have to use MIG,

00:26:46.970 --> 00:26:48.270
it makes us very happy.

00:26:48.280 --> 00:26:49.540
All right.

00:26:52.090 --> 00:26:56.390
So we go back to the user client,
and it has made the call,

00:26:56.560 --> 00:26:58.780
and on the way in,

00:26:59.440 --> 00:27:03.110
It has to actually distribute the call.

00:27:03.350 --> 00:27:06.420
Now in 10.4 land,
you're going to distribute via

00:27:06.420 --> 00:27:09.060
get target and method for index.

00:27:09.630 --> 00:27:12.350
And it's a little bit
more complex to set up.

00:27:12.500 --> 00:27:14.940
It isn't--well, it's a relative term.

00:27:14.940 --> 00:27:18.230
I just should say
I prefer the other method.

00:27:18.370 --> 00:27:22.420
The one limitation that you have with
getTargeted method for index that would

00:27:22.420 --> 00:27:28.140
prevent you from using it going forward
is it doesn't support 64-bit scalers.

00:27:28.310 --> 00:27:31.500
If you're passing structures around
and you're used to using this,

00:27:31.560 --> 00:27:36.310
you can stick with this for
64-bit KEXT development.

00:27:38.170 --> 00:27:40.690
The method that you're
using if you're running,

00:27:40.780 --> 00:27:43.640
say, Leopard and later,
and what I would recommend if

00:27:43.800 --> 00:27:47.550
you're starting new development
is to basically take the selector,

00:27:47.730 --> 00:27:50.110
that same index
denumeration we saw earlier,

00:27:50.110 --> 00:27:52.930
and we're going to call down
here and based on a switch,

00:27:52.930 --> 00:27:54.700
call the different methods.

00:27:54.700 --> 00:27:59.620
Again, it's more a conventional
programming approach,

00:27:59.900 --> 00:28:04.780
which is going to make it easier if
you have to share your code or have

00:28:04.780 --> 00:28:04.780
other people work on it for you.

00:28:06.340 --> 00:28:08.480
So we're going to call method one.

00:28:08.540 --> 00:28:10.400
And method one, again,
is very straightforward.

00:28:10.580 --> 00:28:13.060
It's a very simple example.

00:28:13.290 --> 00:28:16.160
Right up, we're coming in,
we're checking the input size,

00:28:16.160 --> 00:28:17.320
we're going to do some calculations.

00:28:17.390 --> 00:28:21.290
And then we have this magic,
cross-Indian.

00:28:21.300 --> 00:28:24.000
This is how we're going to
implement Rosetta support.

00:28:24.000 --> 00:28:27.310
Again, Rosetta support is pretty
darn straightforward if

00:28:27.310 --> 00:28:28.910
you know what to look for.

00:28:31.610 --> 00:28:43.310
So, when we initialize this driver,
we're actually going to,

00:28:43.310 --> 00:28:43.310
on its call in from the outside world,
we're actually going to check and see

00:28:44.390 --> 00:28:50.060
Whether or not this object KIO user
client cross-Indian key exists.

00:28:50.130 --> 00:28:53.800
If it exists,
that means you're on an Intel machine.

00:28:53.850 --> 00:28:56.440
If it doesn't exist,
you're on a PowerPC machine,

00:28:56.440 --> 00:28:58.430
and the rest of this is irrelevant.

00:28:58.590 --> 00:29:02.160
So assuming that you're checking because
you actually want to support this,

00:29:02.400 --> 00:29:04.920
once you've found out that
you're on an Intel machine,

00:29:04.980 --> 00:29:07.570
you're actually going to
set the key KIO user client

00:29:07.580 --> 00:29:10.090
cross-Indian compatible key.

00:29:10.380 --> 00:29:12.840
So that now you've told
whoever's talking to you,

00:29:13.030 --> 00:29:16.340
yeah, I can deal with Rosetta issues.

00:29:16.360 --> 00:29:19.770
And you're going to set this
cross-Indian flag to true.

00:29:20.000 --> 00:29:44.100
[Transcript missing]

00:29:44.960 --> 00:29:47.240
Pretty straightforward.

00:29:47.240 --> 00:29:47.840
All right.

00:29:47.840 --> 00:29:52.450
Now we're going to look at one more
example that's a little bit more complex.

00:29:54.530 --> 00:29:59.250
And what we're doing is actually
allocating some memory and then

00:29:59.370 --> 00:30:02.970
passing in some parameters,
in particular, handled to the memory.

00:30:03.560 --> 00:30:06.860
What's important here is
looking at this fabulous number.

00:30:06.900 --> 00:30:09.650
1, 2, 3, 4, 5, 6, 7,
8 is pretty much guaranteed

00:30:09.740 --> 00:30:12.220
to look really funny if you
get the end in this wrong.

00:30:12.220 --> 00:30:16.100
So it's actually a really handy number to
have around if you're testing your code.

00:30:16.820 --> 00:30:19.800
Pretty much the same way of calling in.

00:30:20.000 --> 00:30:23.090
So we're gonna go back
to the user client.

00:30:23.260 --> 00:30:24.680
We're going to look at the second method.

00:30:24.750 --> 00:30:26.160
Again, we're getting here the same way.

00:30:26.160 --> 00:30:30.110
We're either going through the selector
or the get target method for index.

00:30:31.530 --> 00:30:35.060
And in here, again,
we've got some Rosetta testing.

00:30:35.100 --> 00:30:38.160
We're checking and swapping
the bytes if we need to check.

00:30:38.250 --> 00:30:43.280
And now we get into the whole
I/O memory descriptor issue.

00:30:43.490 --> 00:30:46.750
And again, I think you'll notice as we go
through this that you're looking at

00:30:46.750 --> 00:30:50.000
samples that are pretty close to,
"Yeah, I had A before.

00:30:50.000 --> 00:30:54.590
Now I use B." This is also one of
the few places that you're going

00:30:54.590 --> 00:30:59.190
to be occasionally if-deffing with
PowerPC code as well as the version.

00:30:59.400 --> 00:31:01.770
So, for example,
here we have the I/O memory

00:31:01.770 --> 00:31:03.400
descriptor with address.

00:31:03.650 --> 00:31:07.360
Note that we have a VM_address_T.

00:31:07.470 --> 00:31:11.400
That's a real strong hint that, yeah,
this is really 32-bit only.

00:31:11.670 --> 00:31:16.710
64-bit code's going to
have mock_vm_address_T.

00:31:16.960 --> 00:31:20.060
And the good news is,
is this will actually fail in a nice way

00:31:20.060 --> 00:31:22.620
and give you a backtrace in the logs.

00:31:22.630 --> 00:31:24.960
Also,
I believe I heard somebody in Dean's

00:31:24.960 --> 00:31:29.590
session earlier asking whether there was
a way to do single machine debugging.

00:31:29.780 --> 00:31:32.890
Here's an example of an I/O log
that we're going to see when

00:31:32.890 --> 00:31:34.880
we run this a little bit later.

00:31:35.950 --> 00:31:39.210
And we did ifdef, and so this is the case
where if you're on Tiger,

00:31:39.330 --> 00:31:41.000
or excuse me,
if you're on Leopard or Later,

00:31:41.000 --> 00:31:45.490
we basically have taken with
address range and dropped it

00:31:45.790 --> 00:31:50.800
in as a wholesale replacement,
not any changes on your part beyond not

00:31:50.800 --> 00:31:55.890
doing the wrong thing with the size of
the variables you're passing around.

00:31:56.270 --> 00:32:00.410
We have a similar kind of deal
down here with memory mapping.

00:32:00.730 --> 00:32:04.290
You're going to swap out map
for create mapping in task.

00:32:04.520 --> 00:32:06.000
Again, really easy to do.

00:32:06.000 --> 00:32:08.520
And like I said,
that's in the release notes and

00:32:08.520 --> 00:32:10.980
that's on the I chart slide,
but this stuff is pretty

00:32:11.090 --> 00:32:12.120
darn straightforward.

00:32:12.460 --> 00:32:16.610
And the last example would be
dealing with get virtual address

00:32:16.610 --> 00:32:18.980
and using get address instead.

00:32:19.370 --> 00:32:20.590
So that's all in the sample code.

00:32:20.600 --> 00:32:23.510
I should show you how it works just
to prove that we didn't come up here

00:32:23.510 --> 00:32:29.410
to blow sunshine in various locations.

00:32:30.120 --> 00:32:33.600
Boy, that probably doesn't
translate very well.

00:32:33.780 --> 00:32:36.520
So here's our keks that we have loaded.

00:32:40.210 --> 00:32:45.760
And here is the console,
so we'll see the debug output.

00:32:47.240 --> 00:32:50.630
So right now, if we look,
we have all the different

00:32:50.640 --> 00:32:51.620
various configurations.

00:32:51.740 --> 00:32:54.650
So let's run the PowerPC version.

00:32:55.180 --> 00:32:56.100
of the client.

00:32:56.410 --> 00:32:58.070
Certainly,
you could have a--you're going to

00:32:58.160 --> 00:33:00.860
expect to see universal clients,
but for ease of testing,

00:33:00.870 --> 00:33:03.540
I've broken these out to
each individual architecture.

00:33:03.540 --> 00:33:08.020
And next time, I won't type it.

00:33:10.610 --> 00:33:13.970
So it's run,
and those answers are correct.

00:33:14.100 --> 00:33:14.940
You'll have to trust me on that.

00:33:14.940 --> 00:33:16.740
When you look at your code, you see that.

00:33:16.770 --> 00:33:20.190
And here it is with those
I/O logs on the other side.

00:33:20.350 --> 00:33:26.560
I should point out real quickly
that despite something we may

00:33:26.560 --> 00:33:29.370
have all wished for at some level,
the--

00:33:31.230 --> 00:33:33.980
The PowerPC 64 code doesn't
work on Snow Leopard any

00:33:33.980 --> 00:33:36.140
better than it did on Leopard.

00:33:36.160 --> 00:33:37.820
This is an Intel machine.

00:33:37.840 --> 00:33:41.320
Okay, that's kind of what I wanted
to show you for the demo.

00:33:41.330 --> 00:33:43.960
And let's go back over
and see what we've got.

00:33:48.100 --> 00:33:52.350
So kind of to summarize,
K64 development helpers, again,

00:33:52.350 --> 00:33:55.520
this was cribbed kind of
directly from the K64 session.

00:33:55.560 --> 00:33:57.720
So if you saw that, I apologize.

00:33:57.740 --> 00:34:00.760
You want to be moving to the
GCC 4.2 as a system compiler.

00:34:00.760 --> 00:34:02.720
Again,
if you're doing the compatibility thing,

00:34:02.720 --> 00:34:06.900
you're going to play with the options
in Xcode to do the right thing for

00:34:06.900 --> 00:34:08.640
the keks that you want to ship.

00:34:08.670 --> 00:34:11.260
You're going to replace
calls to deprecated APIs.

00:34:11.290 --> 00:34:15.080
That's really critical for K64
because they're not just deprecated,

00:34:15.080 --> 00:34:17.180
they're removed in K64.

00:34:17.370 --> 00:34:19.940
There's a couple of really
key warnings you're going to

00:34:19.940 --> 00:34:21.480
want to enable and resolve.

00:34:21.480 --> 00:34:25.700
WALL and shorten 64 to 32,
which will keep yourself from

00:34:25.700 --> 00:34:29.930
shooting yourself in the foot,
as I've been known to do on occasion.

00:34:30.050 --> 00:34:33.730
You're going to add support for
32-bit and 64-bit user space.

00:34:33.880 --> 00:34:36.200
And if you're not using Xcode,
there's a couple of flags

00:34:36.200 --> 00:34:37.580
you're going to want to set.

00:34:37.910 --> 00:34:43.710
Now, if you weren't in the K64 session,
the actual session number

00:34:43.740 --> 00:34:46.900
from Tuesday was 338,
so when you're looking it up on iTunes,

00:34:46.900 --> 00:34:48.640
that's what you're going
to want to look for.

00:34:48.640 --> 00:34:52.390
And right after this,
we're going to talk about text management

00:34:52.440 --> 00:34:56.420
changes that we've made in Snow Leopard,
so you may want to stay tuned for that.

00:34:56.630 --> 00:35:00.260
In summary, you want to add 64-bit
support for your driver.

00:35:00.260 --> 00:35:04.100
If you do it in your Leopard driver,
your K64 work for Snow Leopard

00:35:04.220 --> 00:35:05.490
is pretty much done.

00:35:05.770 --> 00:35:08.580
So the good news is you can
actually add it as a feature to

00:35:08.580 --> 00:35:11.920
something you can ship today,
as opposed to doing the work and going,

00:35:11.930 --> 00:35:14.580
yeah, well, whenever Apple gets
around to shipping that,

00:35:14.580 --> 00:35:15.630
we'll be all set.

00:35:16.000 --> 00:35:18.110
You want to consider
your portability options,

00:35:18.110 --> 00:35:20.830
and really that's about what
choices you're going to make,

00:35:20.830 --> 00:35:23.770
where you're going to make your cutoffs,
how are you from a

00:35:23.770 --> 00:35:26.190
supportability perspective
going to deal with this stuff.

00:35:26.290 --> 00:35:29.500
Are you going to ship the single KEXT,
or are you going to ship

00:35:29.500 --> 00:35:32.090
multiple KEXTs and deal with
the support calls there?

00:35:32.100 --> 00:35:34.580
Having been on the other end
of tech support phone calls,

00:35:34.580 --> 00:35:36.710
it's kind of six and one
half dozen the other.

00:35:36.720 --> 00:35:41.360
You want to clean your code in
32-bit mode before moving forward.

00:35:41.360 --> 00:35:45.940
Another really great advantage of the
K64 stuff is that if you are on a K64

00:35:45.940 --> 00:35:50.250
machine and you're having a problem,
you can certainly quickly regress

00:35:50.370 --> 00:35:54.070
and see if you introduced the problem
only on K64 or not by running,

00:35:54.070 --> 00:35:56.510
rebooting the machine in 32-bit mode.

00:35:56.700 --> 00:35:59.700
If you already have,
if you've already done all

00:35:59.740 --> 00:36:03.490
the Leopard modernization,
you're pretty much done.

00:36:03.780 --> 00:36:05.390
Congratulations, you can go home now.

00:36:05.540 --> 00:36:06.540
If not, you do have a little
bit of time to do that.

00:36:06.540 --> 00:36:07.540
You do have some work to do.

00:36:07.540 --> 00:36:08.530
It's not onerous.

00:36:08.530 --> 00:36:12.510
I think the longest
Apple driver to come over,

00:36:12.520 --> 00:36:17.030
modulo that we haven't
done the audio stuff yet,

00:36:17.030 --> 00:36:19.360
was three, four days.

00:36:19.440 --> 00:36:22.670
This is not,
this has not been a huge effort for us.

00:36:22.670 --> 00:36:24.780
I hope it's not a huge effort for you.

00:36:26.970 --> 00:36:30.060
For more information,
your contacts are Craig Keithley.

00:36:30.080 --> 00:36:33.690
There's some terrific documentation
about getting through this stuff in the

00:36:33.690 --> 00:36:37.900
64-bit transition guide in terms of how
you want to deal with 64-bit things.

00:36:38.130 --> 00:36:41.370
Also, you want to check the release
notes because they're going to show

00:36:41.370 --> 00:36:44.900
you the one-for-one swaps on all
the I/O memory descriptor stuff.

00:36:44.900 --> 00:36:48.840
So, we have time for some questions.
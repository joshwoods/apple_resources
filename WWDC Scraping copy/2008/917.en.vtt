WEBVTT

00:00:20.560 --> 00:00:21.400
Good afternoon.

00:00:21.450 --> 00:00:24.310
Welcome to session 917,
What's New in Core Data?

00:00:24.320 --> 00:00:27.990
My name is Adam Swift,
and I'm an engineer

00:00:27.990 --> 00:00:30.160
on the Core Data team.

00:00:31.890 --> 00:00:34.090
In this session,
we're going to talk about some of

00:00:34.090 --> 00:00:37.260
the new functionality and APIs that
we've introduced in Snow Leopard.

00:00:37.330 --> 00:00:41.940
The content that is in the session will
be covering just the things that are

00:00:41.940 --> 00:00:44.440
available on the Snow Leopard seed.

00:00:44.630 --> 00:00:48.430
None of this really applies to Leopard.

00:00:49.800 --> 00:00:54.240
You can try it out with the CD you
picked up hopefully earlier in the week.

00:00:54.240 --> 00:00:56.300
DVD.

00:00:56.300 --> 00:00:59.500
We're going to talk about the
new Spotlight integration work.

00:00:59.510 --> 00:01:04.720
We've done some work to make it easier
for you to develop your Core Data models

00:01:04.780 --> 00:01:06.800
and evolve them over time.

00:01:06.800 --> 00:01:11.750
And we've also introduced some
new APIs you can use to boost

00:01:11.750 --> 00:01:11.750
your application performance.

00:01:12.410 --> 00:01:14.540
We're breaking this
up into four sections.

00:01:14.700 --> 00:01:17.660
First, we're going to cover the
Spotlight integration.

00:01:17.660 --> 00:01:21.190
Then we'll go into SQL generation,
read-only property data,

00:01:21.200 --> 00:01:24.550
and then we'll go to lightweight
migration to wrap it up.

00:01:29.330 --> 00:01:33.280
So let's start with
Spotlight search integration.

00:01:33.350 --> 00:01:36.750
Spotlight is an amazing
search technology,

00:01:36.750 --> 00:01:40.700
and it just works
wonderfully on Mac OS X.

00:01:40.740 --> 00:01:46.920
Your users want to use Spotlight
to search your application data

00:01:46.920 --> 00:01:46.920
in a Core Data application.

00:01:47.370 --> 00:01:52.480
But sometimes this is a problem because
Spotlight Search returns matching files.

00:01:53.350 --> 00:01:55.350
And particularly,
when you've got a non-document

00:01:55.410 --> 00:02:01.170
based Core Data application,
all your record data lives in one file.

00:02:01.760 --> 00:02:13.750
And your search results,
you want to open individual records,

00:02:13.750 --> 00:02:13.750
not the whole file.

00:02:13.750 --> 00:02:13.750
So, for example,
when you search for guacamole,

00:02:13.750 --> 00:02:13.750
you want the recipe, not the cookbook.

00:02:15.260 --> 00:02:18.720
So what we've done is we've come up
with a way to create files to represent

00:02:18.720 --> 00:02:21.020
the records you want to search.

00:02:21.080 --> 00:02:24.920
And what this really translates
into is each file corresponds

00:02:24.930 --> 00:02:27.210
to an individual managed object.

00:02:27.310 --> 00:02:32.280
The path for the file encodes the managed
object ID and the store identifier.

00:02:33.850 --> 00:02:37.260
This plays well with Spotlight
because Spotlight can search for,

00:02:37.260 --> 00:02:40.780
index, and return individual files
representing the results that

00:02:40.780 --> 00:02:42.410
your users want to search for.

00:02:42.690 --> 00:02:48.770
And when they open up the file,
your application is registered to

00:02:48.770 --> 00:02:48.770
open it by the file extension or UTI.

00:02:50.410 --> 00:02:52.540
So how does this all work together?

00:02:52.680 --> 00:02:55.050
We keep the files in sync with the store.

00:02:55.130 --> 00:02:56.860
We take care of the hard part.

00:02:57.000 --> 00:02:59.820
We create, delete,
touch these marker files,

00:02:59.820 --> 00:03:04.820
and every you save changes to
your manage objects context.

00:03:04.950 --> 00:03:11.220
And the file activity triggers
the indexer and uses your

00:03:11.220 --> 00:03:11.220
importer to populate the index.

00:03:13.110 --> 00:03:16.040
When you make changes
to one of your objects,

00:03:16.040 --> 00:03:17.920
we update the marker file.

00:03:18.080 --> 00:03:22.400
If you delete one of your objects,
we delete the marker file.

00:03:24.370 --> 00:03:28.370
This new Spotlight importer is
available on the Snow Leopard seed

00:03:28.530 --> 00:03:32.500
and it has a new project template
called the Core Data Application with

00:03:32.540 --> 00:03:34.280
Spotlight Importer.

00:03:45.400 --> 00:03:48.460
So the new template provides
the basic implementation,

00:03:48.460 --> 00:03:52.410
the basic source code you need
to integrate the new Spotlight

00:03:53.000 --> 00:03:55.080
infrastructure into your application.

00:03:55.180 --> 00:03:58.430
It provides the code to fetch a
managed object for a marker file,

00:03:58.500 --> 00:04:01.960
and it also provides the code
to import the properties you've

00:04:01.960 --> 00:04:04.560
configured to be indexed in Spotlight.

00:04:06.270 --> 00:04:09.540
How do you mark your properties
to be indexed in Spotlight?

00:04:09.580 --> 00:04:13.400
Well, we've added some new API and new
interface to the data model design

00:04:14.200 --> 00:04:18.610
tool that lets you mark individual
properties to be indexed in Spotlight.

00:04:20.290 --> 00:04:21.830
So let's talk about the big picture here.

00:04:21.990 --> 00:04:23.920
How do all these pieces work together?

00:04:24.230 --> 00:04:26.660
You've got your Core Data Application.

00:04:26.720 --> 00:04:27.530
There's the store.

00:04:27.690 --> 00:04:28.820
There's Spotlight.

00:04:28.970 --> 00:04:33.000
Well, when your user is editing data in
your Core Data application and they

00:04:33.000 --> 00:04:36.950
save their changes to the store,
Core Data propagates the

00:04:36.950 --> 00:04:41.460
changes that were applied there
to update the marker files.

00:04:41.510 --> 00:04:47.320
The changes to the marker files trigger
file system events which the Spotlight

00:04:47.320 --> 00:04:51.150
importer notices and then uses the
file path information to look up

00:04:51.250 --> 00:04:55.440
your managed objects from the store,
fetches the property data

00:04:55.570 --> 00:04:59.160
from those managed objects,
and then populates the Spotlight

00:04:59.160 --> 00:05:02.310
index with that information.

00:05:02.790 --> 00:05:06.910
Then at a later time when your
user performs a spotlight search,

00:05:06.910 --> 00:05:10.880
they've searched the spotlight index,
which returns the marker

00:05:11.000 --> 00:05:12.970
files matching their query.

00:05:13.170 --> 00:05:16.390
And when they open those files,
they're registered to open

00:05:16.390 --> 00:05:17.930
up in your application.

00:05:20.650 --> 00:05:24.420
So how does this actually
work on the file system?

00:05:24.570 --> 00:05:29.620
We actually provide a support folder
where all of the marker files are

00:05:29.620 --> 00:05:34.190
saved as well as some other resources
that we use to support this feature.

00:05:34.700 --> 00:05:37.710
By default,
the marker files are stored in a support

00:05:37.710 --> 00:05:42.480
folder next to the persistent store,
but you can override that as the

00:05:42.480 --> 00:05:46.940
Spotlight template does with this
option you can provide at store load,

00:05:46.940 --> 00:05:49.760
the external records directory option.

00:05:51.340 --> 00:05:53.370
In order to actually
create the marker files,

00:05:53.370 --> 00:05:57.540
you need to specify an option
at store load time to provide

00:05:57.540 --> 00:06:00.450
the spotlight file extension.

00:06:01.370 --> 00:06:07.190
The file extension is the hook that lets
Core Data know that you want marker files

00:06:07.210 --> 00:06:10.030
to be synchronized to your data store.

00:06:12.370 --> 00:06:15.060
Now,
the template provides code to get access

00:06:15.060 --> 00:06:19.800
to the managed objects from the store,
but you really want to customize it.

00:06:19.800 --> 00:06:25.160
You have access to everything that
is available in your data store.

00:06:25.160 --> 00:06:31.690
And there's some new API to allow you to
extract the details of what's available

00:06:32.320 --> 00:06:34.600
from the path to the marker file.

00:06:34.600 --> 00:06:38.010
So you can get access to
the managed object ID,

00:06:38.130 --> 00:06:40.740
the entity name,
the managed object model path,

00:06:40.740 --> 00:06:42.280
the store path, and the store path.

00:06:42.300 --> 00:06:42.570
You can get access to
the managed object ID,

00:06:42.570 --> 00:06:42.890
the entity name,
the managed object model path,

00:06:42.890 --> 00:06:43.730
the store path,
and the store identifier purely

00:06:43.730 --> 00:06:47.550
by looking at the path for the
support file or the marker file.

00:06:47.550 --> 00:06:51.280
These are all available as
keys returned in a dictionary.

00:06:57.310 --> 00:07:03.530
By registering the UTI and the
file extension for the marker

00:07:03.530 --> 00:07:03.530
files with your application,

00:07:03.960 --> 00:07:06.630
The launch services system
will make sure that those

00:07:06.630 --> 00:07:10.150
files open in your application,
but it's up to you to provide the

00:07:10.150 --> 00:07:13.860
application-specific behavior to
actually show the records that

00:07:13.860 --> 00:07:16.300
correlate to the matching marker file.

00:07:16.300 --> 00:07:25.010
So in general, that means highlighting or
opening up the managed object that

00:07:25.010 --> 00:07:25.010
corresponds to that marker file.

00:07:25.600 --> 00:07:30.970
So I'd like to give a quick
demo showing how you can set up,

00:07:31.020 --> 00:07:35.030
you can take advantage of the
Spotlight integration work.

00:07:37.200 --> 00:07:40.440
I'm running this on the new
Xcode 3.2 on Snow Leopard.

00:07:40.440 --> 00:07:47.480
And we'll use the new
project assistant and find...

00:07:50.700 --> 00:07:51.770
There we go.

00:07:51.770 --> 00:07:53.760
Application projects.

00:07:53.760 --> 00:07:57.410
The new Core Data application
with Spotlight importer.

00:08:00.270 --> 00:08:04.380
And we'll create a real quick,
easy cookbook application.

00:08:07.900 --> 00:08:11.330
I'm going to set up a very simple
model just to demonstrate how this

00:08:11.330 --> 00:08:14.870
all works with a recipe entity.

00:08:18.060 --> 00:08:22.200
We have two attributes.

00:08:22.200 --> 00:08:24.270
We want a recipe name.

00:08:25.260 --> 00:08:27.960
That'll be a string.

00:08:28.020 --> 00:08:31.210
And we want to have directions.

00:08:31.380 --> 00:08:35.420
for the recipe,
which will also make a string.

00:08:35.430 --> 00:08:38.970
Obviously,
this is a fairly simplified model.

00:08:39.770 --> 00:08:49.220
And here you can see a new part of
the property inspector allows us to

00:08:49.720 --> 00:08:52.950
select that we want these properties
to both be indexed in Spotlight.

00:08:52.950 --> 00:08:59.310
So we want the name and directions to
be searchable for Spotlight searches.

00:08:59.980 --> 00:09:02.130
So we're done with our model.

00:09:02.400 --> 00:09:06.440
And the next step,
we'll set up a simple user

00:09:06.440 --> 00:09:08.530
interface for the app.

00:09:10.600 --> 00:09:16.160
And this gives me a chance to show
you a great feature in Interface

00:09:16.160 --> 00:09:23.780
Builder if you haven't seen it,
which is the Core Data Entity Assistant.

00:09:25.990 --> 00:09:30.840
So that allows me to select my entity,
the recipe,

00:09:31.020 --> 00:09:33.110
choose the type of view I want for it.

00:09:33.250 --> 00:09:39.040
So I'll set that up
with a basic interface.

00:09:39.090 --> 00:09:40.740
And there we go.

00:10:03.830 --> 00:10:03.830
The IB guys get credit for that one.

00:10:03.830 --> 00:10:03.830
And I think that's all we
need to do for our interface.

00:10:03.830 --> 00:10:03.830
That's all we need in order
to create some simple recipes.

00:10:03.830 --> 00:10:03.830
But the other work that I need to
do to enable the Spotlight searching

00:10:03.830 --> 00:10:03.830
is I need to customize my importer.

00:10:08.630 --> 00:10:11.860
Hello, everyone.

00:10:11.860 --> 00:10:11.860
I'm Adam Swift.

00:10:11.860 --> 00:10:11.860
I'm the CEO of Core Data.

00:10:11.860 --> 00:10:11.860
I'm the CEO of

00:10:12.290 --> 00:10:15.690
So I know that there's a number of
parameters in here I need to set.

00:10:15.820 --> 00:10:18.160
And one is the display string.

00:10:18.160 --> 00:10:20.620
And this will be the string
that gets displayed in the

00:10:20.620 --> 00:10:22.370
actual Spotlight search results.

00:10:22.440 --> 00:10:25.500
So we want to pretty
print this a little bit.

00:10:25.500 --> 00:10:30.370
We'll say cookbook recipe.

00:10:32.230 --> 00:10:37.570
And then we'll fill in--
turn on line wrapping.

00:11:02.640 --> 00:11:02.640
And we'll just put the name
of the recipe in there.

00:11:02.640 --> 00:11:02.640
Okay.

00:11:02.640 --> 00:11:02.640
And the other thing we want
to do is if we look at this,

00:11:02.640 --> 00:11:02.640
I should have mentioned that
this is a custom class that's

00:11:02.640 --> 00:11:02.640
provided by the Spotlight template.

00:11:03.160 --> 00:11:07.250
And what it does is this is the
My Spotlight Importer template class,

00:11:07.250 --> 00:11:13.450
and it gives you one method to import
a marker file with a certain path.

00:11:13.660 --> 00:11:17.580
So it's one place to put in
all your code for actually

00:11:17.970 --> 00:11:21.140
populating the Spotlight index.

00:11:21.360 --> 00:11:25.110
And it contains some code to
put together the display string,

00:11:25.110 --> 00:11:26.640
which I just customized.

00:11:26.720 --> 00:11:29.970
And then the other part is iterating
through all of the attributes of

00:11:29.980 --> 00:11:35.780
the entity that's being indexed
corresponding to the marker file and

00:11:35.840 --> 00:11:41.240
checking for each attribute if it's
configured to be indexed by Spotlight,

00:11:41.280 --> 00:11:46.200
I want to go ahead and add that
attribute to the Spotlight index.

00:11:46.220 --> 00:11:49.970
In this case, we're just going to use
the raw field value.

00:11:50.370 --> 00:11:51.800
for that attribute.

00:11:51.800 --> 00:11:54.660
And we'll put it in the
index as text container,

00:11:54.690 --> 00:11:57.730
as MD item text container, or content.

00:11:57.780 --> 00:12:00.790
Excuse me.

00:12:06.680 --> 00:12:09.840
Now, if I had some relationships and
I wanted to put in some related data,

00:12:09.840 --> 00:12:14.480
there's some code in here that I could
use to fill in those details as well.

00:12:14.480 --> 00:12:17.540
But since I've got such a simple model,
I don't really need to worry

00:12:17.540 --> 00:12:18.850
about that for this one.

00:12:20.570 --> 00:12:26.000
So that's all we need to do
to actually get populating the

00:12:26.000 --> 00:12:28.260
property values into the index.

00:12:28.260 --> 00:12:32.970
The rest of the work we need to do is
simply providing the file extension

00:12:32.980 --> 00:12:38.300
information and the UTIs so that all of
the pieces know how to work together.

00:12:39.930 --> 00:12:42.500
And I'm going to use a little
shortcut here to help me find

00:12:42.500 --> 00:12:45.080
all the places I need to do that.

00:12:45.170 --> 00:12:47.990
So I'm going to search for--

00:12:49.630 --> 00:12:53.450
: I'm going to search
through the whole project.

00:12:53.520 --> 00:13:00.020
And that will show me everywhere where
I need to customize the UTI information.

00:13:01.030 --> 00:13:08.630
And we'll just call it mycookbook.recipe.

00:13:08.760 --> 00:13:15.060
So this is identifying and
providing a unified type

00:13:15.060 --> 00:13:18.980
identifier for the marker files.

00:13:23.970 --> 00:13:26.370
And then we need to also provide
a file extension for them.

00:13:26.500 --> 00:13:29.530
So I'll call that recipe.

00:13:34.200 --> 00:13:38.150
Now we also need to configure our
application to know that these

00:13:38.150 --> 00:13:41.800
marker files should be opened
in our cookbook application.

00:13:41.800 --> 00:13:45.500
So I'll put the file
extension in here too,

00:13:45.540 --> 00:13:46.570
recipe.

00:13:50.430 --> 00:13:57.840
And then we also need to put it
in the UTI for our marker files.

00:13:58.370 --> 00:14:06.290
So that was my company -- no,
mycookbook.recipe.

00:14:06.290 --> 00:14:06.290
There we go.

00:14:08.700 --> 00:14:10.460
All right, that's done.

00:14:10.460 --> 00:14:15.050
And the last remaining piece is
to put in the file extension and

00:14:15.050 --> 00:14:19.610
UTIs in the Spotlight importer,
which we will also be

00:14:19.610 --> 00:14:22.130
building for the project.

00:14:53.970 --> 00:14:53.970
Hello, everyone.

00:14:53.970 --> 00:14:53.970
I'm Adam Swift.

00:14:53.970 --> 00:14:53.970
I'm the founder of Core Data.

00:15:11.590 --> 00:15:11.590
So at this point in time,
we should have a functional application.

00:15:11.590 --> 00:15:11.590
And I'm going to go ahead
and try and give it a run.

00:15:12.900 --> 00:15:13.660
And there we are.

00:15:13.660 --> 00:15:16.020
OK.

00:15:16.090 --> 00:15:21.150
So I'm going to add a
recipe for guacamole.

00:15:21.400 --> 00:15:33.400
[Transcript missing]

00:15:36.430 --> 00:15:39.720
We'll put in a recipe for
another fine condiment,

00:15:39.720 --> 00:15:46.020
salsa, mix, chopped tomato, onion.

00:15:47.100 --> 00:15:51.100
Cilantro with some lime.

00:15:51.100 --> 00:15:52.130
Okay.

00:15:52.220 --> 00:15:54.350
So those are our simple recipes,
and we are done with

00:15:54.440 --> 00:15:57.010
this part of the job.

00:15:57.210 --> 00:15:58.560
So I'm going to quit that.

00:15:58.590 --> 00:16:01.940
Now, I won't actually be able to perform
my Spotlight search yet because

00:16:01.940 --> 00:16:06.120
I haven't built the Spotlight importer
and I haven't installed it in one

00:16:06.120 --> 00:16:08.000
of the known Spotlight locations.

00:16:08.000 --> 00:16:10.640
So let me quickly build
the Spotlight importer.

00:16:10.640 --> 00:16:19.680
And then I will need to copy it into the
standard library Spotlight directory.

00:16:19.680 --> 00:16:23.590
So let's...

00:16:24.710 --> 00:16:29.600
Where did I put my cookbook application?

00:16:29.640 --> 00:16:31.800
Grab the importer.

00:16:33.170 --> 00:16:34.540
Put it in there.

00:16:34.560 --> 00:16:39.940
And then with a little luck,
let's see what matches tomato.

00:16:39.940 --> 00:16:41.670
Oh, look at that.

00:16:42.860 --> 00:16:44.700
And it launches our application.

00:16:44.710 --> 00:16:48.650
And if I had done the work to add
the logic to select the recipe

00:16:48.650 --> 00:16:53.440
that I'd specified by marker file,
then it would have selected

00:16:53.460 --> 00:16:55.210
the proper recipe as well.

00:16:57.600 --> 00:16:58.600
And that's that.

00:16:58.740 --> 00:17:01.310
Can we go back to slides?

00:17:05.790 --> 00:17:10.020
So we think this is a really major
improvement in making your lives easier

00:17:10.020 --> 00:17:14.000
for integrating Spotlight because the
really hard part of that is making sure

00:17:14.070 --> 00:17:19.080
that you've got the data synced up in
the marker files and in your data store.

00:17:19.080 --> 00:17:23.730
And what we've actually done is we aren't
putting the data in the marker file.

00:17:23.730 --> 00:17:28.410
You can access it just using the
encoded managed object ID and

00:17:28.750 --> 00:17:30.890
the reference to the store.

00:17:41.800 --> 00:17:43.010
So one of the things
I mentioned earlier on,

00:17:43.010 --> 00:17:43.010
but it went past pretty quickly,
is that I was talking about

00:17:43.010 --> 00:17:43.010
non-document-based applications.

00:17:43.010 --> 00:17:43.010
So as far as document-based applications,

00:17:44.640 --> 00:17:48.360
Let's talk about what
we're doing with those.

00:17:48.400 --> 00:17:53.710
The marker file synchronization
pairs the persistent store file with

00:17:54.220 --> 00:17:56.600
the Spotlight support directory.

00:17:56.640 --> 00:17:58.130
These two work together.

00:17:58.210 --> 00:18:01.550
We use file paths a
lot to make this work.

00:18:01.750 --> 00:18:07.870
Unfortunately,
we can't put the Spotlight search

00:18:08.000 --> 00:18:15.250
directory in a document wrapper because
the Spotlight indexer won't actually go

00:18:15.250 --> 00:18:17.520
into a wrapper file to do its indexing.

00:18:17.520 --> 00:18:20.770
It won't see the files,
and so the marker files

00:18:20.770 --> 00:18:22.330
won't get indexed.

00:18:22.930 --> 00:18:25.140
Now,
putting the support folder into another

00:18:25.140 --> 00:18:28.500
location outside of the document
wrapper doesn't work very well,

00:18:28.600 --> 00:18:31.770
doesn't scale very well,
because documents tend to move around.

00:18:32.100 --> 00:18:35.760
They get copied off of your computer
and onto some other computer.

00:18:35.760 --> 00:18:39.350
So for document-based
Core Data applications,

00:18:39.350 --> 00:18:43.730
we recommend that you continue
to use the Tiger template for

00:18:44.110 --> 00:18:48.310
building Spotlight importers,
which is the Core Data document-based

00:18:48.320 --> 00:18:51.060
application with Spotlight
importer template.

00:18:53.870 --> 00:18:56.600
So quickly recapping,
try out the new template

00:18:56.600 --> 00:18:58.340
on your Snow Leopard seed.

00:18:58.340 --> 00:19:01.220
There's a lot of helpful details
about what you're seeing in

00:19:01.220 --> 00:19:02.580
the importer readme file.

00:19:02.580 --> 00:19:05.100
And then if you have questions
and you want to learn more,

00:19:05.100 --> 00:19:06.700
please come to the lab tomorrow.

00:19:08.760 --> 00:19:12.080
So let's move along to SQL generation.

00:19:12.120 --> 00:19:16.250
And what we focused on for
SQL generation is giving you

00:19:16.250 --> 00:19:21.690
more opportunities to improve the
performance of your application.

00:19:22.450 --> 00:19:25.670
And for those of you not coming
from a database background,

00:19:25.890 --> 00:19:27.660
SQL may not be a familiar term.

00:19:27.660 --> 00:19:32.250
It stands for structured query language,
and it's the language that we use every

00:19:32.250 --> 00:19:34.700
time we talk to SQLite in Core Data.

00:19:34.770 --> 00:19:37.800
Any time we fetch objects,
we insert objects,

00:19:37.940 --> 00:19:41.900
update and insert or delete,
it's all done through SQL.

00:19:42.130 --> 00:19:46.310
And in SQL's view of the world,
data lives in tables filled

00:19:46.310 --> 00:19:48.210
with columns and rows.

00:19:48.310 --> 00:19:51.950
There's a pretty direct correlation
between SQL and Core Data.

00:19:52.070 --> 00:19:56.460
A table corresponds to an entity,
a row corresponds to a managed object,

00:19:56.460 --> 00:20:01.610
a column corresponds to an attribute,
and in Core Data's parlance,

00:20:01.610 --> 00:20:06.280
a predicate translates
to a where clause in SQL.

00:20:07.260 --> 00:20:11.810
So we use SQL to try,
so a predicate fills the

00:20:11.810 --> 00:20:17.880
role of filtering objects
when you perform a fetch.

00:20:42.430 --> 00:20:42.560
And when we're dealing
with an SQLite database,

00:20:42.560 --> 00:20:42.560
the whole advantage of performance
is based on only retrieving the

00:20:42.560 --> 00:20:42.560
objects that you really need to use.

00:20:42.560 --> 00:20:42.560
So in order to achieve that and
only have to interact with those

00:20:42.560 --> 00:20:42.560
objects that you want as the result,
we need to generate SQL that's

00:20:42.560 --> 00:20:42.560
logically equivalent to the predicate.

00:20:42.560 --> 00:20:42.560
And then we let SQL do the filtering,
and we get better performance.

00:20:43.560 --> 00:20:46.400
So you only might fetch the
managed objects you want,

00:20:46.400 --> 00:20:49.200
you get to do the
filtering in the database,

00:20:49.200 --> 00:20:52.610
and you avoid doing unnecessary
work when you're able to use

00:20:52.610 --> 00:20:54.840
SQL to filter your fetch results.

00:20:54.880 --> 00:20:59.010
And that means the unnecessary work
of allocating space for objects

00:20:59.010 --> 00:21:03.720
that you aren't going to use and
populating the values from the database.

00:21:04.620 --> 00:21:08.110
And what we've done in Snow Leopard
is we've expanded our coverage of what

00:21:08.260 --> 00:21:10.140
predicates can be translated into SQL.

00:21:10.140 --> 00:21:14.880
And beyond the performance aspects
of the performance benefits of that,

00:21:14.970 --> 00:21:18.740
we also,
this also means less work for you.

00:21:18.740 --> 00:21:23.250
The alternative is you have to write
special case for unsupported predicates.

00:21:23.250 --> 00:21:26.990
And that means fetching in all of
the objects into memory and then

00:21:27.610 --> 00:21:29.480
evaluating the predicate in memory.

00:21:29.680 --> 00:21:32.760
And let's take a look at how that
actually gets realized as code.

00:21:32.760 --> 00:21:37.230
For a supported predicate,
you simply set the predicate

00:21:37.290 --> 00:21:38.800
on your fetch request.

00:21:39.340 --> 00:21:43.360
For an unsupported predicate,
you have to fetch all the objects back,

00:21:43.390 --> 00:21:48.570
and then you filter the results
with an in-memory filtered

00:21:48.730 --> 00:21:51.990
array using predicate method.

00:21:54.250 --> 00:21:56.960
So what specifically have we added?

00:21:57.000 --> 00:22:01.120
We've added a bunch
more functions in SQL,

00:22:01.180 --> 00:22:07.000
support for the arithmetic functions,
bitwise operators like ands, ors,

00:22:07.000 --> 00:22:08.080
left shifts,

00:22:08.200 --> 00:22:13.970
String functions, regular expressions,
and a whole new category of functions

00:22:13.980 --> 00:22:20.320
called aggregate functions that
will provide results like average,

00:22:20.590 --> 00:22:23.200
max, min, sum, and count.

00:22:24.990 --> 00:22:28.480
Now let's take another look
at regular expressions.

00:22:28.480 --> 00:22:31.810
This is a great addition
because it means you've got

00:22:31.810 --> 00:22:35.770
the full support for predicate,
for the predicate behavior

00:22:35.770 --> 00:22:39.720
of regular expressions,
but now it can be expressed in SQLite

00:22:39.800 --> 00:22:44.550
so you're no longer having to evaluate
the regular expression in memory.

00:22:44.910 --> 00:22:46.700
You can do it in SQLite.

00:22:46.760 --> 00:22:50.490
And this has full support
for Unicode strings,

00:22:50.490 --> 00:22:54.440
including case and
diacritic insensitivity.

00:22:54.900 --> 00:22:59.600
But you need to be mindful of performance
if you are going to do case or diacritic

00:22:59.600 --> 00:23:01.420
insensitive regular expressions.

00:23:01.420 --> 00:23:04.880
They are expensive,
and you might want to consider

00:23:04.910 --> 00:23:09.800
creating a flattened derived attribute
that represents your property

00:23:09.800 --> 00:23:15.020
value without any flattened case
normalized or diacritic normalized.

00:23:15.020 --> 00:23:17.470
And if that just confused
the heck out of you,

00:23:17.470 --> 00:23:20.860
I'd please encourage you to go
to Creating Efficient Data Models

00:23:21.020 --> 00:23:22.810
with Core Data at 5 o'clock.

00:23:22.940 --> 00:23:24.460
Melissa will be presenting that.

00:23:25.880 --> 00:23:27.970
And a lot of other information
about how to design your data

00:23:28.350 --> 00:23:30.560
models for better performance.

00:23:31.910 --> 00:23:37.400
So another category of feature we've
added is something called fetch offsets.

00:23:37.530 --> 00:23:40.590
And where this comes in handy is
when you're trying to work with

00:23:40.590 --> 00:23:43.390
an extremely large set of data,
you've got millions

00:23:43.390 --> 00:23:44.560
upon millions of rows.

00:23:44.560 --> 00:23:48.750
And you want to process those rows,
but you don't want to have the overhead

00:23:48.750 --> 00:23:51.330
of reading them all into memory at once.

00:23:51.330 --> 00:23:57.520
So what fetch offsets allows
you to do when you combine

00:23:57.520 --> 00:23:57.590
them with fetch limits is...

00:23:57.680 --> 00:24:00.950
You can work with your data in batches.

00:24:01.240 --> 00:24:04.910
A fetch offset lets you specify
the index at which you want your

00:24:05.030 --> 00:24:07.590
fetch results to be returned from.

00:24:07.740 --> 00:24:11.370
So let's take a quick look
at a code sample to try and

00:24:11.500 --> 00:24:13.790
make this a little clearer.

00:24:13.980 --> 00:24:17.200
What you can do in this
code sample you can see,

00:24:17.250 --> 00:24:19.810
I've set a batch size of a
thousand objects and then

00:24:19.810 --> 00:24:23.820
a loop that walks through,
sets the limit to the batch size,

00:24:23.900 --> 00:24:27.070
and then sets the fetch
offset to the current index

00:24:27.530 --> 00:24:29.630
multiplied by the batch size.

00:24:29.800 --> 00:24:35.790
And then for each batch of a
thousand objects that comes back,

00:24:35.820 --> 00:24:39.750
I can do something useful
and never do I have to fetch

00:24:39.750 --> 00:24:39.750
in all the objects at once.

00:24:43.630 --> 00:24:48.690
So there are a lot of functions
I listed in that table.

00:24:48.980 --> 00:24:53.020
The function syntax and usage is
documented on your Snow Leopard seed.

00:24:53.020 --> 00:25:00.780
It's in the foundation framework,
nsexpression.h.

00:25:00.780 --> 00:25:04.580
And if you do try and call a
function that isn't supported,

00:25:04.580 --> 00:25:06.280
we'll throw an exception for you.

00:25:07.900 --> 00:25:10.350
So...

00:25:13.670 --> 00:25:17.680
Along with the extensions
to SQL generation,

00:25:17.680 --> 00:25:23.000
we've added another way of
accessing your data in SQLite.

00:25:32.160 --> 00:25:32.160
And for now, when you're fetching data,
you're fetching managed objects or

00:25:32.160 --> 00:25:32.160
you're fetching managed object IDs.

00:25:33.090 --> 00:25:35.440
When you want to access property data,
you access the property

00:25:35.440 --> 00:25:36.640
data through the objects.

00:25:36.640 --> 00:25:40.710
And that gives us a way to track the
changes to property data and associate

00:25:40.710 --> 00:25:43.680
it with the objects that it belongs in.

00:25:44.510 --> 00:25:46.380
But there are times,
and there are certain problems,

00:25:46.420 --> 00:25:51.880
where you want to view your data
across the lines of properties,

00:25:51.880 --> 00:25:54.200
and you're not as
interested in the objects.

00:25:54.200 --> 00:25:57.500
You want to look across all
objects at property values.

00:25:57.500 --> 00:26:00.550
Some examples of that is when
you want to see distinct values

00:26:00.600 --> 00:26:04.220
across the set of objects,
like unique dates and a list of events.

00:26:04.680 --> 00:26:07.720
Or if you want to perform
some statistical analysis,

00:26:07.720 --> 00:26:11.150
for example, financial data,
you want to see some totals or

00:26:11.150 --> 00:26:14.740
you want to see an average value,
you're really not interested

00:26:14.740 --> 00:26:16.530
in individual objects.

00:26:16.600 --> 00:26:20.710
You're interested in the properties,
irrespective of the objects.

00:26:22.770 --> 00:26:27.260
So if you want to do this now,
it means fetching in all the objects,

00:26:27.380 --> 00:26:30.120
analyzing the property data
across all the objects,

00:26:30.210 --> 00:26:34.080
and you definitely incur some
performance costs by doing that.

00:26:34.110 --> 00:26:37.480
You're reading in a lot of extra
data that you won't be using.

00:26:37.700 --> 00:26:42.280
So we've introduced some more API that
will let you individually select

00:26:42.410 --> 00:26:44.980
the properties you want to fetch.

00:26:45.010 --> 00:26:47.070
And beyond that,

00:26:47.290 --> 00:26:51.710
We've introduced a new subclass
of property description,

00:26:51.710 --> 00:26:53.640
which is the expression description.

00:26:53.670 --> 00:26:57.760
And an expression description
is a way of encapsulating an

00:26:57.800 --> 00:27:02.490
expression into something that
we can treat as a property.

00:27:03.310 --> 00:27:06.920
So when you're specifying an
array of properties that you

00:27:07.170 --> 00:27:11.030
want to fetch from an entity,
your expressions can represent

00:27:11.030 --> 00:27:14.980
functions or key paths or constants
or any other kind of expression

00:27:14.980 --> 00:27:17.240
that makes sense in that context.

00:27:17.240 --> 00:27:24.340
The properties you can specify
are attributes or relationships,

00:27:24.340 --> 00:27:28.920
and you can even specify your
properties as simple key paths,

00:27:28.920 --> 00:27:28.920
string key paths.

00:27:47.090 --> 00:27:47.090
So to really get the
most power from this,

00:27:47.090 --> 00:27:47.090
though,
in order to get that unique set of event

00:27:47.090 --> 00:27:47.090
dates like I was talking about before,
you want to be able to only retrieve

00:27:47.090 --> 00:27:47.090
the rows that are different.

00:27:47.090 --> 00:27:47.090
So if you're fetching
just for the event date,

00:28:15.450 --> 00:28:15.490
So, let's -- there's a couple
of new things in here.

00:28:15.490 --> 00:28:15.490
Let's walk through them one at a time.

00:28:15.490 --> 00:28:15.490
First is this API to set that
you want to return only the

00:28:15.490 --> 00:28:15.490
distinct results of your fetch.

00:28:16.060 --> 00:28:20.080
: Second is identifying the properties
that you want to fetch back.

00:28:20.080 --> 00:28:22.320
So in this case,
as I've been talking about,

00:28:22.420 --> 00:28:24.440
we're specifying the event date.

00:28:39.320 --> 00:28:39.320
And then the last thing is, well,
you're not fetching objects.

00:28:39.320 --> 00:28:39.320
You're not fetching managed
object IDs right now.

00:28:39.320 --> 00:28:39.320
What are you fetching?

00:28:39.320 --> 00:28:39.320
How are we getting these
results back to you?

00:28:39.320 --> 00:28:39.320
Well,
we've introduced another return type,

00:28:39.320 --> 00:28:39.320
which is the dictionary result type.

00:28:42.490 --> 00:28:48.700
So you'll get back your distinct result
as a set of immutable dictionaries.

00:28:48.700 --> 00:28:49.690
And why are they read-only?

00:28:49.920 --> 00:28:54.320
Because they may be calculated values,
they may be derived from --

00:28:54.320 --> 00:28:56.490
taken from different entities.

00:28:56.650 --> 00:29:03.810
They're really not something that you
can work with in a meaningful way and

00:29:03.910 --> 00:29:06.520
expect that we can make any changes,
populate those changes

00:29:06.520 --> 00:29:06.520
back to the database.

00:29:06.980 --> 00:29:10.240
So your results will be returned
as immutable dictionaries,

00:29:10.240 --> 00:29:14.350
and the keys in those dictionaries
will be based on the set of property

00:29:14.350 --> 00:29:16.900
descriptions that you provided to us.

00:29:16.910 --> 00:29:19.940
In the case where you've
provided a property description,

00:29:19.940 --> 00:29:21.140
we'll use the name.

00:29:21.170 --> 00:29:26.360
Or if you've used a string key path,
then we just send back the

00:29:26.360 --> 00:29:31.410
string value as the key path
as the raw string as the key.

00:29:32.970 --> 00:29:36.590
You can combine this feature with
working with managed objects in

00:29:36.590 --> 00:29:38.900
very powerful and useful ways.

00:29:38.900 --> 00:29:42.530
One of the ways is by specifying
that you want some object

00:29:42.530 --> 00:29:44.380
IDs back in your results.

00:29:44.380 --> 00:29:51.920
You can specify that you want self to
get the receiving entity's object IDs.

00:29:51.920 --> 00:29:56.280
Or if you specify a relationship
description or a key path that

00:29:56.280 --> 00:30:00.690
terminates in a relationship,
then we'll send back the object

00:30:00.690 --> 00:30:02.780
ID for the related object.

00:30:02.900 --> 00:30:04.120
Thank you.

00:30:05.050 --> 00:30:08.140
A key path that traverses
a too many relationship,

00:30:08.180 --> 00:30:10.500
however, will generate an error.

00:30:11.480 --> 00:30:18.840
So I'm going to demonstrate the read-only
data sample code that is included or

00:30:19.040 --> 00:30:23.040
is available for download from ADC.

00:30:32.590 --> 00:30:37.270
Tell you a little bit about it and
then we'll give it a run through

00:30:37.500 --> 00:30:38.890
and talk about how it works.

00:30:39.110 --> 00:30:42.790
The project, this read-only data project,
demonstrates the read-only

00:30:42.930 --> 00:30:47.600
property fetching feature,
and it uses a pretty simple model.

00:30:47.600 --> 00:30:50.680
You've got books, and you've got friends.

00:30:50.680 --> 00:30:54.060
Books have a replacement
cost and a title,

00:30:54.250 --> 00:30:57.300
and you can loan your books to friends.

00:30:58.310 --> 00:31:01.560
The project also includes
some pre-canned data,

00:31:01.570 --> 00:31:02.360
so it's easy to run.

00:31:02.360 --> 00:31:03.530
And we'll take a quick look here.

00:31:03.590 --> 00:31:05.640
I don't know if -- can
you guys see that at all?

00:31:05.740 --> 00:31:06.760
Maybe not.

00:31:06.760 --> 00:31:09.880
We've got four books,
The Fellowship of the Ring,

00:31:09.880 --> 00:31:14.760
$10 replacement value, Two Towers,
Return of the King, The Hobbit.

00:31:14.810 --> 00:31:19.950
And then you've got two friends,
and two of your books have

00:31:19.950 --> 00:31:19.950
been loaned to friends.

00:31:22.600 --> 00:31:29.700
So I'm going to go ahead
and build the project.

00:31:54.800 --> 00:31:54.800
And then we'll look at
the work that it does.

00:31:54.800 --> 00:31:54.800
So there are three individual fetches
using read-only property data fetches

00:31:54.800 --> 00:31:54.800
that occur running this application.

00:31:54.800 --> 00:31:54.800
And

00:31:56.000 --> 00:32:01.500
Let's see,
I'll start with the first one here.

00:32:01.500 --> 00:32:01.500
The first one.

00:32:02.120 --> 00:32:08.460
We'll make use of one of the new
expression description objects.

00:32:08.460 --> 00:32:12.150
And what this expression description
will represent is the total

00:32:12.150 --> 00:32:14.500
replacement cost of all of your books.

00:32:14.620 --> 00:32:23.050
And the way we calculate that
is by specifying a function

00:32:23.050 --> 00:32:23.050
expression to calculate the sum.

00:32:23.460 --> 00:32:32.670
And then the key path to the
replacement cost on the books entity.

00:32:35.830 --> 00:32:38.960
Let's see if I can have a
pre-canned script to run this

00:32:39.040 --> 00:32:42.800
with some additional SQL logging.

00:32:42.800 --> 00:32:51.800
Well, maybe I don't.

00:32:51.800 --> 00:33:00.690
What is this called?

00:33:00.690 --> 00:33:00.690
Run read only.

00:33:00.690 --> 00:33:00.690
Oh, okay.

00:33:08.300 --> 00:33:19.600
[Transcript missing]

00:33:20.810 --> 00:33:23.530
Which is a... Well, let's see.

00:33:23.530 --> 00:33:26.200
This is getting way too busy here.

00:33:31.910 --> 00:33:36.570
So what I did is I turned on the
SQL logging so we can see the actual

00:33:36.570 --> 00:33:39.070
SQL command being issued to SQLite.

00:33:39.070 --> 00:33:46.190
And then in the project itself,
we log the results of the fetch.

00:33:46.480 --> 00:33:49.870
So the fetch was, as I said,
specified with an

00:33:49.920 --> 00:33:53.120
expression that calculates,
that applies the sum function

00:33:53.460 --> 00:33:59.160
to the replacement cost key path
and then takes the dictionaries

00:33:59.440 --> 00:34:02.590
that are returned by the fetch,

00:34:02.900 --> 00:34:23.700
[Transcript missing]

00:34:24.600 --> 00:34:26.790
I don't know if you can,
I guess maybe you can see that.

00:34:26.980 --> 00:34:31.810
It basically just shows that the work
to calculate that result was done in

00:34:31.810 --> 00:34:34.620
the database using a select command.

00:34:34.620 --> 00:34:40.490
So, I think...

00:34:45.620 --> 00:34:49.600
So for the second fetch,
what we're actually

00:34:49.600 --> 00:34:52.600
seeing is two properties.

00:35:04.390 --> 00:35:04.390
Hello, everyone.

00:35:04.390 --> 00:35:04.390
I'm Adam Swift.

00:35:04.390 --> 00:35:04.390
I'm the founder of Snow Leopard.

00:35:05.540 --> 00:35:08.900
And then perform the search.

00:35:08.900 --> 00:35:13.150
And then we log the result
as read only data fetch 2.

00:35:13.170 --> 00:35:16.910
So let's see what that result looks like.

00:35:18.320 --> 00:35:22.030
And you can see here,
the result we got back was a series

00:35:22.120 --> 00:35:26.690
of dictionaries containing "loan
to" with managed object IDs pointing

00:35:26.690 --> 00:35:30.930
to the friend that the book was
loaned to and the title of the book.

00:35:36.640 --> 00:35:40.770
And in our last fetch,
we're going to add one more

00:35:40.770 --> 00:35:45.680
parameter to -- or one more
property description to the set of

00:35:45.680 --> 00:35:51.740
properties that we're going to fetch,
and that is a property description,

00:35:51.740 --> 00:36:00.940
an expression description
representing the manage object

00:36:00.940 --> 00:36:00.940
ID of the book that we are printing

00:36:01.560 --> 00:36:04.320
And we'll give it a name, book ID.

00:36:04.320 --> 00:36:08.430
Expression result type is
object ID attribute type.

00:36:09.330 --> 00:36:16.850
To represent the managed object ID,
we use the NS expression

00:36:17.150 --> 00:36:22.700
for evaluated object.

00:36:22.700 --> 00:36:22.700
And when we look at the
results of that fetch,

00:36:24.210 --> 00:36:30.180
We can see in addition to the title and
the friend that the book was loaned to,

00:36:30.320 --> 00:36:34.950
we now also get a reference
to the book's manage object

00:36:34.990 --> 00:36:39.200
ID returned under the key book ID.

00:36:39.750 --> 00:36:43.290
So this is a very flexible,
powerful feature.

00:36:43.440 --> 00:36:46.860
You can get a lot of use out of it.

00:36:48.220 --> 00:36:52.990
There are a lot of other uses
which I hope you'll get to explore

00:36:53.510 --> 00:36:57.320
when you try it out yourself.

00:36:57.320 --> 00:36:59.390
Can we switch back to slides?

00:37:03.760 --> 00:37:04.350
All right.

00:37:04.430 --> 00:37:11.310
So the last subject we're going to
cover here is lightweight migration.

00:37:11.310 --> 00:37:11.310
And

00:37:11.670 --> 00:37:15.240
When we talk about models
and stores in Core Data,

00:37:15.310 --> 00:37:19.590
we all know that a store must be
open with the model that created it.

00:37:22.030 --> 00:37:26.060
In Leopard,
we added a new feature we called

00:37:26.060 --> 00:37:28.130
model versioning and store migration.

00:37:28.140 --> 00:37:34.840
And it is a really powerful feature
that lets you describe a mapping model,

00:37:34.840 --> 00:37:38.890
to create a mapping model to
describe changes that can be

00:37:38.890 --> 00:37:42.870
very complicated and flexible,
and then a migration manager to

00:37:42.890 --> 00:37:47.400
perform those changes to migrate
data from one store to another.

00:37:47.400 --> 00:37:54.950
And this feature is designed to
handle any kind of migration.

00:37:54.950 --> 00:37:54.950
Very flexible, very powerful.

00:37:55.790 --> 00:37:59.270
and you can learn a lot about
this and other tips and tricks for

00:37:59.270 --> 00:38:03.550
working with Core Data on Leopard
at Miguel's session coming up at

00:38:03.550 --> 00:38:06.700
3:30 after this one in Russian Hill.

00:38:07.930 --> 00:38:12.900
One of the things we found is that when
you're talking about developing your

00:38:12.900 --> 00:38:17.010
data model and the changes that happen,
the workflow of developing

00:38:17.010 --> 00:38:23.570
a data model over time,
is that there's sort of two categories

00:38:23.570 --> 00:38:23.570
of the types of changes you see.

00:38:24.150 --> 00:38:28.240
For major version releases
and major new features,

00:38:28.380 --> 00:38:31.960
you have to introduce major
changes to your data model.

00:38:32.050 --> 00:38:34.020
But during the bulk of
the development time,

00:38:34.030 --> 00:38:37.340
when you're really working
with the code and you're eking

00:38:37.340 --> 00:38:41.580
out performance improvements
and you're tweaking features,

00:38:41.580 --> 00:38:45.000
your changes tend to be
pretty limited in scope.

00:38:45.000 --> 00:38:47.800
And in many cases, they're trivial.

00:38:48.930 --> 00:38:49.490
This happens a lot.

00:38:49.600 --> 00:38:54.180
You tend to get a lot of model churn
during this development process,

00:38:54.200 --> 00:38:58.060
especially when you're trying
to focus on performance.

00:38:58.120 --> 00:39:03.910
And what we found in our experience and
others have given us the same feedback

00:39:04.360 --> 00:39:09.160
that it can be very -- it can be hard
to keep up with mapping models over

00:39:09.160 --> 00:39:13.640
time as you're trying to deal with
these many small incremental changes.

00:39:13.730 --> 00:39:17.190
So you create version
one of your data model,

00:39:17.190 --> 00:39:22.360
and then you realize you've made
a typo or forgotten some small

00:39:22.360 --> 00:39:25.660
feature or detail in your objects.

00:39:25.790 --> 00:39:28.400
And so you add 1.1.

00:39:28.660 --> 00:39:30.800
Well, at that point in time,
the people who have been testing

00:39:30.800 --> 00:39:35.100
your application and giving you
the feedback on your application,

00:39:35.100 --> 00:39:39.080
they want to be able to preserve the
data that they've built up so far.

00:39:39.130 --> 00:39:42.440
So you need to build a mapping
model to make that possible,

00:39:42.550 --> 00:39:45.610
to translate the data from
one store to the next.

00:39:47.330 --> 00:39:49.200
Well,
then you've gone and realized that there

00:39:49.200 --> 00:39:50.420
was another change you needed to make.

00:39:50.530 --> 00:39:52.700
Somebody came in with
a last minute request.

00:39:52.780 --> 00:39:54.990
So you come up with 1.2.

00:39:55.080 --> 00:40:04.600
And then again, to preserve the data that
people have been working with,

00:40:04.600 --> 00:40:04.600
you add another mapping model to
carry the data from 1.1 to 1.2.

00:40:05.040 --> 00:40:08.450
But then there's the people
who never tried or installed

00:40:08.450 --> 00:40:12.480
the version that used 1.1,
so you need yet another mapping

00:40:12.480 --> 00:40:15.360
model to get from 1.0 to 1.2.

00:40:16.420 --> 00:40:22.690
So, over time, obviously,
this becomes very time consuming and

00:40:47.800 --> 00:40:47.800
There has to be a better way.

00:40:47.800 --> 00:40:47.800
And what we've discovered is that
during this real heavy model evolution,

00:40:47.800 --> 00:40:47.800
the time where you're
making all these changes,

00:40:47.800 --> 00:40:47.800
most of those changes are pretty small.

00:40:47.800 --> 00:40:47.800
So we figured out how to create a
mapping model based on analyzing

00:40:47.800 --> 00:40:47.800
two data models with small changes
between them and inferring a

00:40:47.800 --> 00:40:47.800
mapping model directly from them.

00:40:48.670 --> 00:40:51.010
And so we've introduced some
new API to let you call this

00:40:51.070 --> 00:40:54.800
directly on NS Mapping Model.

00:40:57.480 --> 00:41:01.490
And we've taken it a step further
to allow you to specify another key

00:41:01.560 --> 00:41:05.580
at the time that you load your store
to automatically infer a mapping

00:41:05.580 --> 00:41:08.340
model and then perform the migration.

00:41:09.380 --> 00:41:11.720
Just as with the original
migration support,

00:41:11.720 --> 00:41:15.260
we use the store version hashes
to look up the source data model,

00:41:15.390 --> 00:41:19.640
which you need to have available for
us to be able to create a mapping model

00:41:19.640 --> 00:41:22.030
between the old version and the new.

00:41:22.990 --> 00:41:29.300
So what kind of changes can we actually
handle for inferring a mapping model?

00:41:29.310 --> 00:41:30.980
What's inferrable?

00:41:31.040 --> 00:41:34.490
Well, it basically comes down to can we
do the right thing with your data?

00:41:34.490 --> 00:41:39.510
Is it unambiguous what we should do with
the data that you've created in the old

00:41:39.850 --> 00:41:44.970
version of the store when we copy it
over and migrate it to the new version?

00:41:45.770 --> 00:41:47.340
So what are the kinds of
things that we can do?

00:41:47.380 --> 00:41:50.130
Well, if you delete an attribute,
that's obvious.

00:41:50.270 --> 00:41:51.710
We just get rid of the data for that.

00:41:51.710 --> 00:41:55.710
If you rename an attribute, well,
we can just save the

00:41:55.800 --> 00:41:57.690
data under the new name.

00:41:57.690 --> 00:42:00.720
But if you're adding an
attribute or a relationship,

00:42:00.800 --> 00:42:04.430
then it either needs to be optional
or provide a default value.

00:42:04.430 --> 00:42:08.210
Otherwise, we don't know what data
to put into the new store.

00:42:13.490 --> 00:42:19.470
Let's talk about renaming.

00:42:19.470 --> 00:42:19.470
When you're looking at two data models,

00:42:19.620 --> 00:42:24.700
You can't really tell whether you've
got one attribute being deleted

00:42:24.700 --> 00:42:28.330
and one being added or if it's
just one attribute being renamed.

00:42:28.360 --> 00:42:32.620
So you need to use the renaming
identifier and you set the

00:42:32.900 --> 00:42:36.440
naming identifier to the name
used in the original model.

00:42:36.520 --> 00:42:40.110
So that way we know to take
the value from the old model,

00:42:40.110 --> 00:42:42.680
from the old data,
and put it in under the

00:42:42.680 --> 00:42:44.360
new name in your new model.

00:42:46.530 --> 00:42:50.720
Now, there's new API to support this,
and there's also support in the

00:42:50.720 --> 00:42:54.700
new modeling tool in the seed of
Snow Leopard where you can specify

00:42:55.420 --> 00:42:59.910
directly in the interface the
renaming identifier in your model.

00:42:59.920 --> 00:43:05.910
So I'd like to take a minute
to demonstrate this feature.

00:43:09.450 --> 00:43:11.970
And we'll use the old
cookbook application we

00:43:11.970 --> 00:43:16.400
built just a few minutes ago.

00:43:21.920 --> 00:43:27.320
So we've realized that with our cookbook,
we forgot to include the

00:43:27.650 --> 00:43:29.020
author of our recipes.

00:43:29.020 --> 00:43:33.040
Now, before I go and change the
model to add this attribute,

00:43:33.040 --> 00:43:36.360
I want to be able to preserve
the data I already created.

00:43:36.360 --> 00:43:39.700
I already put together some recipes,
and I don't want to lose it.

00:43:39.780 --> 00:43:43.130
If I change my model,
I won't be able to read it in unless

00:43:43.540 --> 00:43:46.980
I keep a copy of the old model
so that we can infer the mapping

00:43:46.980 --> 00:43:48.620
and then perform the migration.

00:43:49.780 --> 00:43:56.770
So I'm going to use the data
model menu to add a model version.

00:43:57.460 --> 00:44:01.980
And that way I'll preserve the
existing version of my model,

00:44:02.010 --> 00:44:14.390
but be able to make a change to a new
version so I can introduce the author.

00:44:14.460 --> 00:44:17.110
And we'll make that a string.

00:44:22.270 --> 00:44:27.760
So I also need to make a change
to the template code because it's

00:44:27.760 --> 00:44:31.230
going to look for the old version
-- the old name of the model,

00:44:31.240 --> 00:44:33.220
a nonversion model.

00:44:33.320 --> 00:44:37.920
And I've just created a bundle
-- a model version bundle that

00:44:37.960 --> 00:44:40.910
contains two versions of my model.

00:44:41.030 --> 00:44:44.150
So in order to make sure I get the right

00:44:45.000 --> 00:45:02.800
[Transcript missing]

00:45:10.740 --> 00:45:16.780
What I also need to do is add
the keys to my options dictionary

00:45:17.470 --> 00:45:27.010
so that when I load the store,
it will automatically migrate the...

00:45:28.340 --> 00:45:34.630
is the founder of Core Data.

00:45:34.630 --> 00:45:34.630
He's the founder of the new API,
which is the new API.

00:45:34.630 --> 00:45:34.630
He's

00:45:49.200 --> 00:45:51.000
So it worked.

00:45:51.000 --> 00:45:52.050
All right.

00:45:52.140 --> 00:45:54.380
Can we switch back to slides, please?

00:45:58.650 --> 00:46:01.730
Okay,
so one of the things that we've done on

00:46:01.730 --> 00:46:06.620
top of the lightweight migration work
and inferring a mapping model is to try

00:46:06.620 --> 00:46:10.840
and do migrations in place within SQLite.

00:46:10.980 --> 00:46:17.940
And this has been driven by a desire to
deal with large data files and be able

00:46:17.940 --> 00:46:22.330
to perform all of the work to migrate
data from one version of your data model

00:46:22.720 --> 00:46:26.710
to another version of your data model
without having to read in any objects and

00:46:26.720 --> 00:46:33.350
to make the changes directly in SQLite
using SQL to perform the table changes.

00:46:49.710 --> 00:46:49.710
And we can migrate some of the
inferred mapping models with the

00:46:49.710 --> 00:46:49.710
in-place migration in SQLite.

00:46:49.710 --> 00:46:49.710
And what we support is all the
inferable changes to attributes

00:46:49.710 --> 00:46:49.710
that were listed before.

00:46:49.860 --> 00:46:53.470
So deletes, renames,
adding an optional or

00:46:53.790 --> 00:46:59.050
attribute with a default value,
and changing types, optionality,

00:46:59.050 --> 00:47:00.550
or transients.

00:47:01.660 --> 00:47:06.430
The in-place migration support
is part of a bigger feature

00:47:06.810 --> 00:47:09.580
for store-specific migration.

00:47:09.580 --> 00:47:12.880
So if you have developed
your own custom store,

00:47:13.060 --> 00:47:16.840
you can specify your own custom
migration manager class to perform

00:47:16.840 --> 00:47:18.980
a custom migration for yourself.

00:47:19.030 --> 00:47:24.790
And that's available through some
new API on NS Persistence Store.

00:47:26.120 --> 00:47:29.500
In terms of debugging
lightweight migration,

00:47:29.650 --> 00:47:35.310
you can use the existing migration
logging feature using the user default

00:47:35.310 --> 00:47:39.310
com apple core data migration debug.

00:47:39.710 --> 00:47:43.150
And a note on the SQLite
in-place migration.

00:47:43.150 --> 00:47:50.260
The in-place migration manager will
only attempt a migration if the

00:47:50.260 --> 00:47:53.670
mapping model has been inferred.

00:47:54.440 --> 00:47:59.610
But if you want to try it out and see
what's actually happening under the hood,

00:47:59.610 --> 00:48:03.220
you can turn on the SQL logging
and see the changes that

00:48:03.220 --> 00:48:05.300
are happening to your data.

00:48:08.860 --> 00:48:10.550
We've got a couple
more Core Data sessions

00:48:10.550 --> 00:48:12.330
coming up after this one.

00:48:12.440 --> 00:48:16.790
There's Core Data tips and
tricks at 3:30 in Russian Hill.

00:48:16.950 --> 00:48:19.770
Creating efficient data models
with Core Data at 5 o'clock.

00:48:19.830 --> 00:48:23.550
And then tomorrow we're available
at 2 o'clock for the Core Data Lab.

00:48:26.260 --> 00:48:30.180
For more information,
contact Mike Jurowicz,

00:48:30.450 --> 00:48:35.100
Developer Tools Evangelist,
jurowicz@apple.com.

00:48:35.130 --> 00:48:39.810
Or send messages to ask your
questions on the Cocoa Dev mailing

00:48:39.810 --> 00:48:43.560
list at cocodev@lists.apple.com.

00:48:43.570 --> 00:48:48.570
And please, send us all the feedback you
can on what we've introduced and

00:48:48.570 --> 00:48:50.910
what you might want in addition.

00:48:51.210 --> 00:48:55.440
Use the bug reporter website,
bugreport.apple.com.
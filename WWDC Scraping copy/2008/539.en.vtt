WEBVTT

00:00:22.940 --> 00:00:23.710
Good afternoon.

00:00:23.870 --> 00:00:24.840
My name is John Comiskey.

00:00:24.840 --> 00:00:28.680
I'm an engineer in the AppleScript group,
and I'm here to talk to you today about

00:00:28.680 --> 00:00:31.310
making your application scriptable.

00:00:32.670 --> 00:00:36.580
Scriptability lets your end users
solve their problems on their own.

00:00:36.610 --> 00:00:39.440
You spend a lot of time
polishing your application,

00:00:39.660 --> 00:00:41.550
but you can't always
anticipate every need,

00:00:41.550 --> 00:00:45.750
and you also can't always justify the
time it takes to fill the needs of

00:00:45.830 --> 00:00:48.650
people that have very unique needs.

00:00:49.220 --> 00:00:51.930
The benefits of Scriptability
to you are very high.

00:00:51.980 --> 00:00:54.690
You get automation,
which is going to help you do your

00:00:54.690 --> 00:00:58.070
testing and ship your product better,
and it's going to help your end

00:00:58.070 --> 00:00:59.880
users solve their problems better.

00:00:59.880 --> 00:01:01.170
You get integration.

00:01:01.170 --> 00:01:04.470
You work better with other
applications on the Macintosh and

00:01:04.470 --> 00:01:08.670
with the Macintosh system itself,
and you get loyalty from your customers,

00:01:08.670 --> 00:01:09.880
which is great.

00:01:09.910 --> 00:01:12.760
You want your customers to come
back release after release.

00:01:12.770 --> 00:01:14.030
You want them to upgrade.

00:01:14.030 --> 00:01:17.980
You want them to keep using your product,
and Scriptability can help you do that.

00:01:19.100 --> 00:02:06.500
[Transcript missing]

00:02:07.960 --> 00:02:09.310
We're going to cover
several different topics.

00:02:09.500 --> 00:02:11.180
First, why you want to be scriptable.

00:02:11.180 --> 00:02:12.660
We already talked a
little bit about that,

00:02:12.660 --> 00:02:13.840
but we'll go into more detail.

00:02:13.840 --> 00:02:16.300
Then the first step,
and we really do mean the first

00:02:16.300 --> 00:02:19.360
step in good scriptability,
is designing a dictionary.

00:02:19.360 --> 00:02:21.160
And we're not just going
to talk about that today,

00:02:21.160 --> 00:02:22.080
we're going to show you.

00:02:22.180 --> 00:02:23.780
Then you have got to write some code.

00:02:23.870 --> 00:02:26.700
You should be able to leverage a
lot of code that you've already got,

00:02:26.780 --> 00:02:29.520
but you will have to write
some that's just for scripting.

00:02:30.620 --> 00:02:35.860
Then you have got to write some
code that you've already got,

00:02:35.860 --> 00:02:41.560
but you will have to write some
code that's just for scripting.

00:02:42.030 --> 00:02:45.290
Your end users can solve their
problems and that you haven't regressed

00:02:45.300 --> 00:02:49.570
anything that they're depending
upon in their daily workflows.

00:02:50.500 --> 00:02:55.430
And scriptability will help
you do a better job of testing.

00:02:55.610 --> 00:02:57.000
So why be scriptable?

00:02:57.070 --> 00:02:58.150
What's in it for me?

00:02:58.360 --> 00:03:00.400
As a developer, how do you benefit?

00:03:00.470 --> 00:03:02.580
Well, first we need to define our terms.

00:03:02.640 --> 00:03:04.180
What does scriptable mean?

00:03:04.300 --> 00:03:07.120
It means giving your end users
a way of controlling your

00:03:07.120 --> 00:03:10.820
application with something other
than the keyboard and the mouse.

00:03:10.880 --> 00:03:15.860
You want to give them a programmatic
way of controlling your application

00:03:15.860 --> 00:03:19.570
so that they can automate tasks
that they do repetitively.

00:03:20.270 --> 00:03:22.990
Strictly speaking,
you need to be OSA compliant.

00:03:22.990 --> 00:03:26.970
OSA compliant, OSA stands for
Open Scripting Architecture,

00:03:27.040 --> 00:03:31.150
and it's a set of protocols and
agreements that we all stick to so that

00:03:31.150 --> 00:03:35.760
our applications work better together
and work better with the system.

00:03:36.660 --> 00:03:39.300
And to find out the particulars
and the details of that,

00:03:39.300 --> 00:03:41.890
you want to read the scripting
interface guidelines,

00:03:41.890 --> 00:03:43.580
which is Techno 2106.

00:03:43.580 --> 00:03:47.500
Just as we have human interface
guidelines to make sure that programs

00:03:47.500 --> 00:03:51.040
are uniform across applications,
uniform across vendors,

00:03:51.040 --> 00:03:54.950
and every experienced Macintosh
user can approach a new application

00:03:55.010 --> 00:03:58.260
and know instinctively what
it is they're supposed to do,

00:03:58.260 --> 00:04:01.360
how to explore the menus,
how to explore the toolbar,

00:04:01.360 --> 00:04:06.000
how to move things around on the screen
and get it to do what they want to do.

00:04:06.320 --> 00:04:10.490
We also have a set of scripting interface
guidelines so that we have consistency

00:04:10.530 --> 00:04:14.970
across applications and across vendors,
and people who are experienced scripters

00:04:15.050 --> 00:04:19.020
get that same end user experience of
continuity across the entire system.

00:04:19.060 --> 00:04:22.830
And the key component of that is that
we want you to do model scripting,

00:04:22.930 --> 00:04:24.210
not view scripting.

00:04:24.260 --> 00:04:28.810
We want you to expose the objects
that your application manipulates

00:04:28.810 --> 00:04:33.020
rather than just all the buttons
and sliders on the screen.

00:04:34.670 --> 00:04:38.660
View scripting is free and
it's worth every penny.

00:04:38.660 --> 00:04:42.010
You can do things with view scripting,
but anytime the view changes,

00:04:42.010 --> 00:04:44.720
anytime you move a button,
anytime you put something

00:04:44.720 --> 00:04:47.210
inside of a box,
all of a sudden your view scripts break

00:04:47.210 --> 00:04:48.800
and they all have to be rewritten.

00:04:48.900 --> 00:04:51.460
Model scripting doesn't act like that.

00:04:51.560 --> 00:04:54.880
Model scripting works
release after release.

00:04:57.110 --> 00:05:00.040
The biggest benefit and the most
immediate benefit to you as a

00:05:00.040 --> 00:05:03.520
developer is in automated testing.

00:05:03.740 --> 00:05:07.750
You've got a lot of code that backs
up your beautiful user interface.

00:05:07.750 --> 00:05:10.420
You've got a powerful back end.

00:05:10.420 --> 00:05:11.660
Maybe it's hooked up to a database.

00:05:11.660 --> 00:05:12.960
Maybe it's hooked up to the network.

00:05:13.170 --> 00:05:14.710
And you need ways to test that.

00:05:14.740 --> 00:05:17.400
And you've probably got very dedicated
people that sit down in front of a

00:05:17.400 --> 00:05:20.540
computer and try one thing after another
to see if they can make something break.

00:05:20.600 --> 00:05:21.900
But try as they might.

00:05:21.990 --> 00:05:24.960
They really can't touch
everything every time.

00:05:24.990 --> 00:05:27.290
If you've got a way of
automating your testing,

00:05:27.290 --> 00:05:28.300
they can do that.

00:05:28.840 --> 00:05:31.020
And what you want to do is you
want to do regression testing.

00:05:31.020 --> 00:05:33.620
You want to keep your results from
the time before and compare them.

00:05:33.620 --> 00:05:36.580
Make sure that if you make a change,
you get the intended change,

00:05:36.580 --> 00:05:39.180
but you don't get any unintended
changes along with it.

00:05:39.260 --> 00:05:42.880
Stress testing is hard to do by hand,
but with automated testing,

00:05:42.880 --> 00:05:46.210
you can set up a script and let
it run overnight and do thousands

00:05:46.210 --> 00:05:50.080
or tens of thousands of iterations
while you're at home sleeping.

00:05:50.080 --> 00:05:52.320
And you can also have validated releases.

00:05:52.330 --> 00:05:54.640
When you get ready to
release your software,

00:05:54.820 --> 00:05:57.140
you can know for a fact,
not only does the new stuff

00:05:57.170 --> 00:05:58.770
that we put in there work.

00:05:59.010 --> 00:06:03.030
Not only do our whiz-bang features
really get that wow and that pop,

00:06:03.030 --> 00:06:07.440
but all the things that people have
come to depend upon also still work.

00:06:07.680 --> 00:06:10.490
It's a sad surprise to
open a new application,

00:06:10.550 --> 00:06:14.160
see all the cool new things it can do,
but the one thing that you

00:06:14.350 --> 00:06:15.980
do every day is broken.

00:06:19.000 --> 00:06:22.520
Another thing that you and your end users
get from scriptability is integration.

00:06:22.520 --> 00:06:26.610
It makes your application work
better with the rest of the system.

00:06:26.610 --> 00:06:28.890
And you can leverage
existing technologies inside

00:06:28.980 --> 00:06:30.180
of the operating system.

00:06:30.180 --> 00:06:32.320
AppleScript is 15 years old now.

00:06:32.320 --> 00:06:35.450
AppleScript's been bugging
me about getting a learner's

00:06:35.450 --> 00:06:38.940
permit and borrowing my car,
but that's not going to happen.

00:06:39.060 --> 00:06:41.710
More recently,
we've come up with Automator.

00:06:41.710 --> 00:06:45.220
Automator is big chunk automation
for end users to make automation

00:06:45.340 --> 00:06:46.910
even more approachable.

00:06:47.450 --> 00:06:49.590
We've come up with some
common things that people do.

00:06:49.600 --> 00:06:50.840
Those are called actions.

00:06:50.920 --> 00:06:54.930
They can be put together in a big block
fashion into a workflow and solve common

00:06:54.990 --> 00:06:57.060
problems that everyday people have.

00:06:57.230 --> 00:06:59.090
And it's much more
approachable than AppleScript.

00:06:59.160 --> 00:07:01.400
You don't have to think of
yourself as a programmer to do it.

00:07:01.500 --> 00:07:05.370
And we've now got,
that says scripting bridge,

00:07:05.370 --> 00:07:08.900
but it's pronounced Apple event bridge.

00:07:08.900 --> 00:07:11.710
And it is a programmatic way
for one application to talk

00:07:11.710 --> 00:07:14.780
to another using Apple events,
using the scriptability of

00:07:14.780 --> 00:07:16.470
the external application.

00:07:17.200 --> 00:07:20.640
And what happens is the object
model of an external application

00:07:21.090 --> 00:07:25.570
becomes available to you,
the developer, as full-fledged objects

00:07:25.670 --> 00:07:26.760
inside your application.

00:07:26.760 --> 00:07:29.480
So you can simply tell other
applications to do things for you,

00:07:29.480 --> 00:07:32.020
and then you don't have to
write all that code yourself.

00:07:32.160 --> 00:07:37.030
That's your bridge to
leveraging other applications.

00:07:37.080 --> 00:07:41.710
Anthracite is a web mining tool.

00:07:41.780 --> 00:07:43.560
And Joe Pizzillo wrote it.

00:07:43.560 --> 00:07:44.980
He's a great friend of scriptability.

00:07:44.980 --> 00:07:46.680
If you see a guy in a plaid hat,
that's Joe Pizzillo.

00:07:46.680 --> 00:07:47.580
Say hi.

00:07:47.580 --> 00:07:51.660
And he did a great job of
making Anthracite scriptable.

00:07:51.660 --> 00:07:55.780
And Anthracite can pull down huge
amounts of data off of the web.

00:07:55.820 --> 00:07:58.920
And he didn't want to write all
the code to process all of that.

00:07:58.980 --> 00:08:01.500
But he didn't have to,
because Microsoft Excel is

00:08:01.500 --> 00:08:02.980
extensively scriptable.

00:08:03.000 --> 00:08:07.360
He can export data directly into
Microsoft Excel spreadsheets,

00:08:07.360 --> 00:08:10.950
and you can use Excel to do a lot
of your data grinding for you.

00:08:11.040 --> 00:08:15.730
But thousands and thousands of numbers
are sometimes hard to understand.

00:08:16.460 --> 00:08:18.910
The Omni group is another
great friend of scriptability.

00:08:18.920 --> 00:08:21.260
They have a tremendous suite
of scriptable applications.

00:08:23.000 --> 00:08:26.920
and OmniGraffle is one that can take
huge amounts of numeric data and

00:08:27.360 --> 00:08:30.090
express it in a graphical form and
make it much more understandable.

00:08:30.100 --> 00:08:34.590
Adobe is also another company that
has embraced scriptability and put

00:08:34.770 --> 00:08:36.160
it into all of their applications.

00:08:36.160 --> 00:08:38.740
And Adobe Illustrator can
fulfill the same role,

00:08:38.740 --> 00:08:41.210
turning thousands and
thousands of numbers into one

00:08:41.210 --> 00:08:42.680
nice comprehensible picture.

00:08:42.680 --> 00:08:45.320
And then when you're all done,
you want to email this off

00:08:45.460 --> 00:08:47.680
to your boss so he knows that
you've been working really,

00:08:47.680 --> 00:08:49.560
really hard in getting
all of this stuff done.

00:08:50.100 --> 00:08:52.540
And once you've put this
whole workflow together,

00:08:52.540 --> 00:08:55.920
it can run unattended while
you're not even there,

00:08:55.920 --> 00:08:59.230
fire off this email at the end and
everybody thinks you're working really

00:08:59.230 --> 00:09:00.790
hard and you're actually at the ballgame.

00:09:04.410 --> 00:09:07.600
Automation is a benefit that
accrues to your end users.

00:09:07.600 --> 00:09:10.780
They have problems that
you didn't anticipate.

00:09:10.780 --> 00:09:14.620
They want to do things that you
didn't think of and you didn't

00:09:14.620 --> 00:09:17.180
make a feature in your application.

00:09:17.180 --> 00:09:19.930
But if you give them a rich
object model to work with,

00:09:19.930 --> 00:09:24.110
they can solve these problems on their
own and they get immediate results.

00:09:24.290 --> 00:09:26.030
They don't have to wait
for your release cycle.

00:09:26.040 --> 00:09:28.730
They don't have to wait six months
or a year for you to come out with

00:09:28.740 --> 00:09:31.200
a new version or bug you to be on
a beta list even though you know

00:09:31.280 --> 00:09:34.380
they're actually going to deploy
it throughout their entire company.

00:09:34.400 --> 00:09:35.280
You don't want to do that.

00:09:35.300 --> 00:09:39.580
And when people do write these scripts
and solve their problems on their own,

00:09:39.580 --> 00:09:41.300
you want to get that feedback.

00:09:41.470 --> 00:09:44.160
You want to have a vibrant
online community feeding

00:09:44.160 --> 00:09:47.670
information back to you saying,
hey, I wrote this script.

00:09:47.750 --> 00:09:49.530
And you want that for
a couple of reasons.

00:09:49.540 --> 00:09:50.660
You want to capture that script.

00:09:50.790 --> 00:09:52.130
You want to make it part of your testing.

00:09:52.130 --> 00:09:54.480
You want to make sure you don't break
that script ever because there's

00:09:54.490 --> 00:09:55.980
somebody out there really using it.

00:09:56.080 --> 00:09:59.410
And also, you want to kind of pull these
little features that people

00:09:59.460 --> 00:10:01.220
are adding to your application.

00:10:01.260 --> 00:10:04.380
If you find that 50 different people have
written a script to do the same thing,

00:10:04.380 --> 00:10:04.380
you want to make sure you
don't break that script ever.

00:10:04.400 --> 00:10:06.210
If you find that 50 different people have
written a script to do the same thing,

00:10:06.270 --> 00:10:07.610
you might want to consider making
that a feature of your app.

00:10:07.690 --> 00:10:10.380
Customers also get
their work done faster.

00:10:10.380 --> 00:10:13.130
They do the same things
over and over again.

00:10:13.150 --> 00:10:16.290
And after you've worked with an
application for a while and you've done

00:10:16.290 --> 00:10:18.780
the same thing over and over again,
you get tired.

00:10:18.780 --> 00:10:20.480
You begin to hate the application.

00:10:20.480 --> 00:10:23.390
The last thing you want is for people
to learn to hate your application.

00:10:23.390 --> 00:10:25.300
You want them to love your application.

00:10:25.300 --> 00:10:28.310
If you give them an automated way
of doing their repetitive tasks,

00:10:28.410 --> 00:10:29.540
they can write scripts.

00:10:29.650 --> 00:10:30.750
They can set that all up.

00:10:30.750 --> 00:10:32.170
It runs while they're at lunch.

00:10:32.230 --> 00:10:33.440
It runs overnight.

00:10:33.440 --> 00:10:36.150
And then the next time
they come to your app,

00:10:36.220 --> 00:10:37.270
it's to solve a new problem.

00:10:37.270 --> 00:10:38.440
And they're really excited about it.

00:10:38.440 --> 00:10:39.390
And then they learn to love your app.

00:10:39.460 --> 00:10:42.000
And you want them to love
your app because then they'll

00:10:42.000 --> 00:10:43.490
buy all your upgrades.

00:10:43.600 --> 00:10:47.560
And automation is going to give
them consistent results as well.

00:10:47.560 --> 00:10:49.400
They're going to get the
same result every time.

00:10:49.400 --> 00:10:52.330
They're never going to wonder, gee,
did I click this first and then that?

00:10:52.360 --> 00:10:54.780
They don't have to worry about
what was clicked because it was

00:10:54.780 --> 00:10:56.460
all done programmatically for them.

00:10:58.500 --> 00:11:00.400
And this leads to loyalty.

00:11:00.440 --> 00:11:02.720
Once somebody's made you part
of their automated workflow,

00:11:02.720 --> 00:11:05.090
they are never going to get
rid of your application.

00:11:05.210 --> 00:11:07.670
Even if your competitor comes
out with a great new feature

00:11:07.680 --> 00:11:11.200
that everybody's got to have,
if you're scriptable and they're not,

00:11:11.300 --> 00:11:13.050
your customers may go buy
that other application,

00:11:13.060 --> 00:11:14.790
but they're never going
to get rid of yours.

00:11:14.920 --> 00:11:19.200
You're going to be part of their workflow
forever unless you break their scripts,

00:11:19.280 --> 00:11:22.580
which is why you need to do
automated regression testing.

00:11:25.730 --> 00:11:28.000
And this is all going to save you money.

00:11:28.030 --> 00:11:29.840
You're going to let your
customers do the customization

00:11:30.120 --> 00:11:32.020
because they're the customers.

00:11:32.090 --> 00:11:34.080
They're going to think
of what you've forgotten.

00:11:34.140 --> 00:11:36.460
They're going to think of
what you didn't think of.

00:11:36.510 --> 00:11:37.870
And they're going to
write scripts to do it.

00:11:37.870 --> 00:11:41.200
And if you've got this online
community feeding that back to you,

00:11:41.230 --> 00:11:42.700
you're going to find out about it.

00:11:42.760 --> 00:11:44.680
And then you're going to be able to
spend your time on the things that

00:11:44.700 --> 00:11:46.440
people are really interested in.

00:11:46.460 --> 00:11:49.880
You're not going to spend a year creating
a fabulous feature that you're really,

00:11:49.880 --> 00:11:53.340
really proud of, but nobody ever uses.

00:11:56.000 --> 00:11:58.180
The first step,
and I said we mean the first step,

00:11:58.260 --> 00:11:59.380
is designing a dictionary.

00:11:59.380 --> 00:12:01.300
You want to empower your end user.

00:12:01.340 --> 00:12:04.140
You want to give them the ability
to solve their own problems.

00:12:04.160 --> 00:12:07.230
And you start by reading the
scripting interface guidelines.

00:12:07.230 --> 00:12:10.400
Tech Note 2106,
one of the great tech notes of our time.

00:12:10.410 --> 00:12:12.080
You should definitely read it.

00:12:12.160 --> 00:12:14.990
And you want to deliver an
object-oriented solution.

00:12:14.990 --> 00:12:18.550
Give your users tools that they
can build their own solutions with.

00:12:19.040 --> 00:12:22.210
Don't try to anticipate their needs and
give them a silver bullet that does that

00:12:22.270 --> 00:12:23.920
one magic thing that they need done.

00:12:23.920 --> 00:12:26.790
Because sure as shooting
that silver bullet,

00:12:26.810 --> 00:12:29.300
they'll be back saying,
"I need one more silver bullet.

00:12:29.420 --> 00:12:32.800
I'm not done yet." And if you
give them a rich object model,

00:12:32.800 --> 00:12:36.420
you also achieve interoperability
with other applications.

00:12:36.420 --> 00:12:38.920
And you don't have people
coming to you and saying,

00:12:38.920 --> 00:12:42.440
"Gee, it would be really great if your
application had a nice spreadsheet like

00:12:42.440 --> 00:12:45.970
Excel embedded in it." You can say,
"Well, we have scriptability,

00:12:45.970 --> 00:12:47.420
so we don't need that."

00:12:50.800 --> 00:12:52.810
When you're designing things,
there's some pitfalls

00:12:52.870 --> 00:12:55.320
that you can fall into,
and if you read Techno 2106,

00:12:55.320 --> 00:12:56.510
we'll talk about those.

00:12:56.510 --> 00:12:58.190
You'll see those in there.

00:12:58.200 --> 00:13:02.000
And mostly it's oriented
around giving a good,

00:13:02.000 --> 00:13:03.960
strong object model.

00:13:03.980 --> 00:13:06.770
Those of you who are familiar with
AppleScript or have maybe made

00:13:06.770 --> 00:13:09.400
an application scriptable before
will look at this first line,

00:13:09.400 --> 00:13:12.000
close front window, and you'll say, John,
it's a perfectly good

00:13:12.000 --> 00:13:13.170
line of AppleScript.

00:13:13.250 --> 00:13:14.430
What's wrong with that?

00:13:14.550 --> 00:13:16.150
Why is there a big red X there?

00:13:16.790 --> 00:13:20.180
Well, because in our example here,
somebody has put close front window

00:13:20.270 --> 00:13:22.120
in their dictionary as a command.

00:13:22.180 --> 00:13:24.560
It's three words,
it's close front window,

00:13:24.560 --> 00:13:26.380
and it closes the front window.

00:13:26.380 --> 00:13:28.330
That's not the way we want you to do it.

00:13:28.420 --> 00:13:32.150
What we want you to do is use close,
which is a verb in the standard suite.

00:13:32.150 --> 00:13:33.590
You don't have to add that.

00:13:33.590 --> 00:13:34.950
That's already there.

00:13:35.000 --> 00:13:39.320
Front is a reserved word in
the AppleScript language that's

00:13:39.330 --> 00:13:41.570
a synonym for the index one.

00:13:41.580 --> 00:13:46.530
And window is an object that's
also defined in the standard suite.

00:13:46.630 --> 00:13:47.990
So you don't have to do that either.

00:13:47.990 --> 00:13:50.420
You need to support it,
but you don't have to define it.

00:13:50.460 --> 00:13:55.070
And so together,
those things become close, the command,

00:13:55.160 --> 00:13:58.590
and front window, the object specifier.

00:13:58.620 --> 00:14:00.610
And now that's the right way of doing it.

00:14:00.610 --> 00:14:03.320
The same line of AppleScript,
but the implementation is

00:14:03.360 --> 00:14:04.970
object-oriented instead.

00:14:05.020 --> 00:14:07.950
Another thing that you want to avoid,
you want to be friendly

00:14:07.950 --> 00:14:09.200
to the language itself.

00:14:09.360 --> 00:14:12.300
You don't want to stick verbs inside of
things that are supposed to be nouns,

00:14:12.300 --> 00:14:14.130
because then when people
write AppleScript,

00:14:15.000 --> 00:14:17.990
AppleScript is has a
nice easy flow to it.

00:14:18.000 --> 00:14:18.820
It's easy to read.

00:14:18.870 --> 00:14:20.920
But if you throw verbs
into the middle of nouns,

00:14:21.020 --> 00:14:22.300
funny things are going to happen.

00:14:22.300 --> 00:14:26.610
You're going to have something that says,
"if isFrontWindow is true." And that's

00:14:26.780 --> 00:14:28.680
going to make it hard to read,
hard to figure out

00:14:28.800 --> 00:14:31.240
what's a language term,
what's an application term.

00:14:31.260 --> 00:14:34.460
So what we want you to do
is leave that word "is" out,

00:14:34.460 --> 00:14:38.100
and just call this "frontWindow." Again,
it's an object specifier.

00:14:38.100 --> 00:14:40.880
If you support windows,
"front" is defined for you.

00:14:40.950 --> 00:14:42.120
It all just works.

00:14:43.460 --> 00:14:46.180
You also don't want to just
take the internals of your

00:14:46.180 --> 00:14:46.180
code and just leave it out.

00:14:46.180 --> 00:14:48.600
You want to take the internals
of your application and dump it

00:14:48.600 --> 00:14:51.360
on the end user and expect him to
figure out what it was you wrote.

00:14:51.530 --> 00:14:53.180
You want to simplify it for him.

00:14:53.180 --> 00:14:55.260
You want to candy-coat
it a little bit for him.

00:14:55.260 --> 00:14:58.500
And one of the things that will tell
you faster than anything else that

00:14:58.670 --> 00:15:02.210
you've just dumped your internal
implementation on the user is if

00:15:02.360 --> 00:15:04.050
there's intercaps in your dictionary.

00:15:04.410 --> 00:15:06.200
Anybody who sees intercaps
in your dictionary,

00:15:06.200 --> 00:15:08.190
they're going to know immediately
you haven't done your homework.

00:15:08.280 --> 00:15:09.640
You haven't done it right.

00:15:09.640 --> 00:15:13.640
And again, this is an example of a
really egregious violation.

00:15:14.230 --> 00:15:18.090
This is a command called "closeWindow"
with intercaps and no spaces in it.

00:15:18.170 --> 00:15:20.370
And as its object, it takes an index.

00:15:20.780 --> 00:15:22.780
That's not object-oriented.

00:15:22.820 --> 00:15:24.920
We don't close integers.

00:15:24.920 --> 00:15:26.460
We close windows.

00:15:26.540 --> 00:15:33.660
So again, we don't want to pass an index
as the input to an operation.

00:15:33.840 --> 00:15:37.910
What we want to do is we want to pass
an object specifier as the input to

00:15:37.910 --> 00:15:40.200
the close command and do it that way.

00:15:40.500 --> 00:15:41.670
That's object-oriented.

00:15:41.680 --> 00:15:46.660
Another thing you don't want to do
is put underbars in your dictionary.

00:15:46.730 --> 00:15:49.900
AppleScript will allow you
to have multi-word terms.

00:15:49.940 --> 00:15:52.900
You don't have to connect things
together for them to work in AppleScript.

00:15:52.970 --> 00:15:56.380
So again, you want to get rid of
these underbars here,

00:15:56.880 --> 00:15:58.660
and you just want to change
this to front window,

00:15:58.660 --> 00:16:00.730
which is an object specifier
just like any other.

00:16:02.940 --> 00:16:05.530
What do I do?

00:16:05.940 --> 00:16:06.550
Where do I start?

00:16:06.610 --> 00:16:07.150
Where do I finish?

00:16:07.260 --> 00:16:09.500
How do I know I'm ready
to ship release one?

00:16:09.640 --> 00:16:13.300
Well, what we want you to do is
think big at the beginning.

00:16:13.320 --> 00:16:15.540
Go through the process
in an iterative fashion.

00:16:15.540 --> 00:16:19.390
Keep designing until you've
designed terminology for

00:16:19.390 --> 00:16:22.120
everything your application can do.

00:16:22.290 --> 00:16:26.360
Then step back and look at it and say,
my gosh, I can't do that in one release.

00:16:26.360 --> 00:16:27.980
What am I going to do with this?

00:16:27.980 --> 00:16:31.010
Scale it back for the first release.

00:16:31.010 --> 00:16:36.160
And what we tell people is solve one
compelling problem that a real user has.

00:16:36.160 --> 00:16:38.160
Talk to your online community.

00:16:38.170 --> 00:16:40.600
Find out what people's problems are.

00:16:40.600 --> 00:16:43.940
Find out something interesting that
would be good to do with scriptability.

00:16:44.580 --> 00:16:48.700
And provide enough scriptability in your
dictionary to solve that one problem.

00:16:48.700 --> 00:16:51.490
Send out a sample script
that solves that problem,

00:16:51.490 --> 00:16:52.950
and that's release one.

00:16:52.980 --> 00:16:55.860
Now you've got scriptability
into your end user's hands.

00:16:55.860 --> 00:16:59.130
You've got an interesting problem
that at least one person was really

00:16:59.150 --> 00:17:01.200
interested in getting a solution for.

00:17:01.200 --> 00:17:04.070
And now there's going to be
a buzz that's going to start.

00:17:04.080 --> 00:17:07.070
People are going to start
scripting your application.

00:17:07.110 --> 00:17:09.390
They're going to find out that they
can do some really cool things.

00:17:09.420 --> 00:17:11.790
They're going to find out that
there's some things they can't get at.

00:17:11.850 --> 00:17:14.140
They're going to feed that
information back to you.

00:17:14.520 --> 00:17:16.080
And again,
you're going to spend your time where

00:17:16.080 --> 00:17:17.440
you know it's going to do a lot of good.

00:17:17.490 --> 00:17:21.850
It's okay to have features that are in
the GUI but are not in your scripting.

00:17:21.960 --> 00:17:27.200
Some applications have very powerful
dialogues that allow you to create

00:17:27.710 --> 00:17:30.460
Boolean descriptions of searches.

00:17:30.480 --> 00:17:33.520
That you can take values
of various fields,

00:17:33.590 --> 00:17:37.100
do comparative operations,
and and or the various

00:17:37.100 --> 00:17:41.020
operations together,
and come up with a subset of data that

00:17:41.020 --> 00:17:43.510
the user's interested in looking at.

00:17:44.460 --> 00:17:45.460
And that's a great feature.

00:17:45.460 --> 00:17:47.370
But you really don't want
to try to duplicate that in

00:17:47.370 --> 00:17:48.460
your scripting dictionary.

00:17:48.460 --> 00:17:52.460
The reason being,
Apple script has whose clauses,

00:17:52.460 --> 00:17:56.950
Objective C has predicates,
every scripting language has some way

00:17:56.950 --> 00:17:59.460
of expressing a query of some sort.

00:17:59.460 --> 00:18:01.460
You want to leave that in the language.

00:18:01.460 --> 00:18:04.460
If you implement the basics
of object model access,

00:18:04.460 --> 00:18:08.460
you'll get that query feature as
part of the scripting language.

00:18:08.460 --> 00:18:10.460
You won't have to build
it into your application.

00:18:10.460 --> 00:18:12.950
It's also okay to have features that
are in the scripting and don't have

00:18:12.960 --> 00:18:14.380
to build it into your application.

00:18:14.430 --> 00:18:17.390
You can also have features that don't
show up in the application's UI.

00:18:17.440 --> 00:18:20.400
Not right away, maybe later, maybe never.

00:18:20.400 --> 00:18:27.400
In mail, there's a lot of fields that you
can add to an address book card.

00:18:27.400 --> 00:18:32.400
Like job title, anniversary date,
maiden name, things like that.

00:18:32.400 --> 00:18:34.810
Those were all available in
scripting first and didn't

00:18:34.900 --> 00:18:36.400
show up in the UI until later.

00:18:36.400 --> 00:18:40.400
That meant that the address
book team was able to test them.

00:18:40.400 --> 00:18:44.340
Power users of address book were able to
get at them and start putting data in.

00:18:44.340 --> 00:18:48.340
People that were importing data into
address book could make use of them.

00:18:48.340 --> 00:18:51.320
It wasn't until later when they
designed a nice UI for them

00:18:51.340 --> 00:18:52.340
that it showed up in the UI.

00:18:52.340 --> 00:18:53.210
That's okay.

00:18:53.340 --> 00:18:56.230
Your scripting implementation
and your UI implementation

00:18:56.300 --> 00:18:58.340
do not need to match exactly.

00:18:58.340 --> 00:19:00.340
But they shouldn't stray too far afield.

00:19:01.930 --> 00:19:04.520
A long, long time ago,
networks were slower,

00:19:04.520 --> 00:19:06.120
computers were smaller.

00:19:06.120 --> 00:19:09.650
This is a gigabyte of memory
and it's considered small.

00:19:09.650 --> 00:19:11.880
That would be enough for a
thousand computers back when

00:19:11.990 --> 00:19:13.880
AppleScript first came into existence.

00:19:13.880 --> 00:19:16.770
We had to shrink things
down and as a result,

00:19:16.770 --> 00:19:20.020
a lot of the terminology
in Apple Events has shrunk

00:19:20.090 --> 00:19:21.810
down to four byte codes.

00:19:22.670 --> 00:19:26.530
One of the jobs you have to do as a
developer is to take human terminology

00:19:26.830 --> 00:19:29.630
that's going to mean something to your
end users that they're going to use

00:19:29.630 --> 00:19:32.760
in their scripts and you're going to
have to map that to a four byte code.

00:19:32.800 --> 00:19:36.440
Four byte codes absolutely must
be unique inside your application.

00:19:38.070 --> 00:19:42.140
Applications are isolated from each
other by tel blocks in AppleScript and by

00:19:42.210 --> 00:19:46.450
similar mechanisms in other languages so
that your terminology and the terminology

00:19:46.550 --> 00:19:48.520
of another application don't collide.

00:19:48.520 --> 00:19:51.960
But it's good for you to agree
with as much existing terminology

00:19:51.960 --> 00:19:53.760
as you can for several reasons.

00:19:53.880 --> 00:19:56.860
The AppleScript language itself
defines a lot of terminology,

00:19:56.860 --> 00:19:59.060
and you definitely want
to agree with that.

00:19:59.060 --> 00:20:01.660
If you have any conflicts,
AppleScript wins and you lose.

00:20:02.610 --> 00:20:04.710
Scripting editions,
including the standard editions

00:20:04.710 --> 00:20:08.630
that ship with the system,
also define global terminology,

00:20:08.630 --> 00:20:11.790
and if you conflict with that,
they win and you lose.

00:20:11.800 --> 00:20:17.240
If you want your application to be
used by AppleScript Studio developers,

00:20:17.240 --> 00:20:19.210
AppleScript Studio defines
a lot of terminology,

00:20:19.290 --> 00:20:21.370
and you don't want to
conflict with that either.

00:20:21.400 --> 00:20:24.360
And even if you just want to get
along with some other application,

00:20:24.360 --> 00:20:27.830
if you want to be able to send things
like files and pictures back and forth,

00:20:27.890 --> 00:20:30.840
you want to agree on terminology
with that application.

00:20:31.550 --> 00:20:33.640
So if you go to your favorite
search engine and you search

00:20:33.720 --> 00:20:36.500
for Apple event codes,
one of the first couple of hits will

00:20:36.500 --> 00:20:41.610
be a big page that we have posted
from Apple servers with a list of

00:20:41.610 --> 00:20:46.340
about 2,000 4-byte codes and the human
readable terms that they correspond to.

00:20:46.340 --> 00:20:50.040
We strongly encourage you,
when you're reviewing your dictionary and

00:20:50.040 --> 00:20:53.250
making sure that everything's just right,
go to that page and

00:20:53.250 --> 00:20:54.910
check your 4-byte codes.

00:20:54.960 --> 00:20:57.350
If you see something that's
already been defined,

00:20:57.350 --> 00:21:00.120
by all means, reuse it,
reuse the same 4-byte code.

00:21:00.570 --> 00:21:02.580
You're not stealing, you're being nice.

00:21:06.730 --> 00:21:08.060
Where do you get this design from?

00:21:08.090 --> 00:21:13.220
You don't get it from a typical
programming specification.

00:21:13.350 --> 00:21:16.100
What you want to do is you want
to get it from the end user

00:21:16.100 --> 00:21:17.430
perception of your application.

00:21:17.430 --> 00:21:21.470
You want to design a terminology
that's going to be familiar to your

00:21:21.470 --> 00:21:25.930
end users because it uses the same
words to describe things that they do.

00:21:26.760 --> 00:21:28.540
Last year,
I talked about something called

00:21:28.610 --> 00:21:31.200
a blind interview and I showed
this real scary picture.

00:21:31.200 --> 00:21:34.100
And then I never did tell you
what a blind interview was.

00:21:34.100 --> 00:21:35.520
So we're going to correct that.

00:21:35.670 --> 00:21:38.590
Today we're actually going to do
a blind interview so you'll get an

00:21:38.590 --> 00:21:40.350
idea of how we go about doing this.

00:21:40.360 --> 00:21:44.360
Your scripting dictionary is going
to have to reflect your internal

00:21:44.360 --> 00:21:46.330
structure to a certain extent.

00:21:46.330 --> 00:21:50.180
In fact, the way Cocoa scripting works,
there really do need to be

00:21:50.180 --> 00:21:54.170
Cocoa objects for everything
that appears in your dictionary.

00:21:54.180 --> 00:21:56.150
But you want to do that within reason.

00:21:56.160 --> 00:21:58.830
There's a lot of private
stuff inside your application,

00:21:58.870 --> 00:22:03.040
implementation details, helper objects,
things that you really don't want

00:22:03.040 --> 00:22:04.390
to hand over to the end user.

00:22:04.390 --> 00:22:06.070
Hide all of that stuff.

00:22:06.070 --> 00:22:08.140
Simplify all of that stuff.

00:22:08.240 --> 00:22:11.520
Use the classic data hiding
capabilities of object-oriented

00:22:11.520 --> 00:22:15.080
languages to protect the customer
from having to mess around with

00:22:15.080 --> 00:22:17.260
crazy bit flags and things like that.

00:22:19.380 --> 00:22:21.670
And I promised you a blind interview
and now we're going to do that.

00:22:21.780 --> 00:22:25.360
We're going to bring up
Chris Page for our demo.

00:22:25.470 --> 00:22:30.880
And we're going to show you
what a blind interview is.

00:22:33.540 --> 00:22:37.460
So, we're going to look at a program that
should be familiar to all of you.

00:22:37.460 --> 00:22:38.140
It's Preview.

00:22:38.140 --> 00:22:41.900
It comes with Mac OS X,
and you all have it on your machine,

00:22:41.900 --> 00:22:44.650
and if you double-click a picture file,
Preview is what comes up

00:22:44.710 --> 00:22:46.110
and shows you that picture.

00:22:46.120 --> 00:22:49.440
So, Chris, if you could, wait,
the blind part.

00:22:49.440 --> 00:22:53.110
What I'm going to do is I'm
going to situate myself somewhere

00:22:53.110 --> 00:22:55.960
where I can talk to Chris,
and he can manipulate

00:22:55.960 --> 00:22:59.940
the Preview application,
and he can tell me what it is he's doing,

00:22:59.940 --> 00:23:02.700
but I can't actually see what he's doing.

00:23:02.900 --> 00:23:05.610
If you come to the lab downstairs,
typically I would sit

00:23:05.610 --> 00:23:07.140
across the table from you.

00:23:07.140 --> 00:23:09.880
You would have your application
on your portable in front of you.

00:23:09.900 --> 00:23:11.440
I'd be across the table.

00:23:11.440 --> 00:23:13.000
I couldn't see what you were doing.

00:23:13.040 --> 00:23:16.580
This forces you to tell me in
words what it is that you're doing,

00:23:16.580 --> 00:23:19.010
and then I'm going to
write those words down,

00:23:19.140 --> 00:23:23.840
and those words are going to become the
terms in your AppleScript dictionary.

00:23:23.840 --> 00:23:26.790
So, Chris, double-click a file.

00:23:26.880 --> 00:23:27.980
A file?

00:23:27.980 --> 00:23:28.750
A file.

00:23:30.290 --> 00:23:30.580
All right.

00:23:30.600 --> 00:23:33.010
And tell me what you see.

00:23:33.060 --> 00:23:34.500
I see a window.

00:23:34.500 --> 00:23:35.990
Honestly,
I can't see anything down here at all.

00:23:36.040 --> 00:23:38.710
I see a window with an image
of the Golden Gate Bridge.

00:23:38.720 --> 00:23:40.120
Okay.

00:23:40.120 --> 00:23:42.620
Do you see anything around
the edges of that window?

00:23:42.620 --> 00:23:45.250
Is there anything else
besides just the image?

00:23:45.360 --> 00:23:47.630
Yeah, the window has a toolbar
with some buttons in it.

00:23:47.700 --> 00:23:48.090
Okay.

00:23:48.090 --> 00:23:50.340
And what are some of the
tools in the toolbar?

00:23:50.340 --> 00:23:52.920
There's a previous and next button.

00:23:52.920 --> 00:23:54.790
There's some zooming buttons.

00:23:54.880 --> 00:23:57.280
Moving and selecting.

00:23:57.280 --> 00:24:00.020
A slideshow button to play a slideshow.

00:24:00.200 --> 00:24:02.340
And there's a button to
show and hide the sidebar.

00:24:02.360 --> 00:24:03.340
Okay.

00:24:03.340 --> 00:24:05.450
Sidebar, huh?

00:24:05.450 --> 00:24:06.670
I wonder what that is.

00:24:06.680 --> 00:24:08.650
Are there any other tools?

00:24:08.690 --> 00:24:11.090
Are there any other places that
we could look and find some tools?

00:24:11.120 --> 00:24:17.080
Well, we've got some menus with commands
like rotation and flipping,

00:24:17.080 --> 00:24:19.330
markup, annotation.

00:24:19.340 --> 00:24:20.370
Okay.

00:24:20.740 --> 00:24:22.300
Okay, good.

00:24:22.300 --> 00:24:25.300
Okay, go ahead and close that.

00:24:25.360 --> 00:24:28.460
And open another file.

00:24:33.540 --> 00:24:34.850
Here's another file.

00:24:34.970 --> 00:24:36.920
Okay, now what do you see?

00:24:37.190 --> 00:24:40.040
I see another window
with another toolbar.

00:24:40.090 --> 00:24:43.100
But this time I see a text document,
and I see a sidebar

00:24:43.100 --> 00:24:44.940
with four pages in it.

00:24:44.990 --> 00:24:49.620
Okay, so before we had a window with
just a single image in it.

00:24:49.790 --> 00:24:51.440
Now we've got pretty
much that same window,

00:24:51.470 --> 00:24:54.140
but it's got a document in it,
and that document's got

00:24:54.200 --> 00:24:55.370
several different pages.

00:24:55.500 --> 00:24:57.390
Is that, it's probably a PDF, right?

00:24:57.650 --> 00:24:58.350
It is a PDF.

00:24:58.500 --> 00:24:59.820
Okay, okay.

00:24:59.980 --> 00:25:03.690
So now, we're starting to develop a
containment hierarchy here.

00:25:03.790 --> 00:25:04.900
We've got an application.

00:25:05.040 --> 00:25:08.040
This application has windows,
and closely associated with the

00:25:08.040 --> 00:25:10.260
window is one or more documents.

00:25:10.290 --> 00:25:12.600
In the first case,
it was just a single image.

00:25:12.620 --> 00:25:17.270
In this case, it's a single PDF file
with multiple pages.

00:25:17.420 --> 00:25:21.420
So we're starting to develop
a list of things that our

00:25:21.670 --> 00:25:25.470
application can manipulate,
and we're also starting to develop

00:25:25.800 --> 00:25:29.130
a containment hierarchy of how these
things are nested one inside another.

00:25:29.140 --> 00:25:32.130
Okay, go ahead and close that,
and see if you can find

00:25:32.130 --> 00:25:33.620
a whole bunch of files.

00:25:33.620 --> 00:25:35.120
A bunch of files.

00:25:35.160 --> 00:25:35.810
Let me see.

00:25:35.840 --> 00:25:37.040
Oh, here's some.

00:25:37.040 --> 00:25:37.450
Okay.

00:25:37.450 --> 00:25:38.910
Go ahead and open all of them.

00:25:39.020 --> 00:25:39.760
Okay.

00:25:39.760 --> 00:25:40.740
Okay.

00:25:40.740 --> 00:25:42.470
Now what do you see?

00:25:43.620 --> 00:25:46.770
Now I see a window with an
image and a sidebar with the

00:25:46.890 --> 00:25:48.820
other images that I opened.

00:25:48.820 --> 00:25:50.120
Okay.

00:25:50.120 --> 00:25:54.020
And can you change which image
it is that you're looking at?

00:25:54.060 --> 00:25:58.960
Yes, I can click on the images in the
sidebar and view them separately.

00:25:58.960 --> 00:25:59.920
Okay.

00:25:59.920 --> 00:26:03.620
Okay, so now we can see in
our first experiment,

00:26:03.620 --> 00:26:07.420
we clicked on a single image,
and it just came up in

00:26:07.420 --> 00:26:09.430
a window all by itself.

00:26:09.480 --> 00:26:15.210
But now, if we open up multiple images,
they're all available in a sidebar.

00:26:15.230 --> 00:26:19.150
So a window can actually have more
than one image associated with it.

00:26:19.220 --> 00:26:23.120
So by going through our interview
process in an iterative fashion,

00:26:23.120 --> 00:26:25.520
we've learned something more
about the containment hierarchy.

00:26:25.520 --> 00:26:27.310
A window can have an image in it.

00:26:27.370 --> 00:26:29.650
A window can also have
multiple images in it.

00:26:29.700 --> 00:26:32.420
And that's going to be important when
we start designing our scripting,

00:26:32.420 --> 00:26:34.380
our scripting dictionary.

00:26:34.380 --> 00:26:35.470
Okay.

00:26:35.680 --> 00:26:36.930
Thanks very much, Chris.

00:26:36.940 --> 00:26:39.020
You're welcome.

00:26:44.310 --> 00:26:47.680
Chris Page, he's here all week.

00:26:47.730 --> 00:26:49.400
Bring him back up for Q&A later.

00:26:49.420 --> 00:26:52.320
And if we can go back to the slides.

00:26:57.600 --> 00:26:59.300
Okay.

00:26:59.350 --> 00:27:01.210
So,
we did a couple of different things here.

00:27:01.470 --> 00:27:03.600
First thing we developed in inventory.

00:27:03.640 --> 00:27:05.940
What classes did we find
when we opened this thing up?

00:27:06.010 --> 00:27:11.030
We found that there was a window
and it was closely associated

00:27:11.030 --> 00:27:12.520
with one or more documents.

00:27:12.520 --> 00:27:16.660
Those documents could be
either images or PDFs.

00:27:16.660 --> 00:27:18.680
We haven't really finished exploring.

00:27:18.680 --> 00:27:20.710
Maybe there's other things
that Preview can open up.

00:27:20.820 --> 00:27:24.290
But we know already that there's
at least images and PDFs and

00:27:24.290 --> 00:27:26.580
that they inherit from documents.

00:27:26.690 --> 00:27:29.180
Your scripting dictionary is
going to be able to represent

00:27:29.180 --> 00:27:30.940
both inheritance and containment.

00:27:30.940 --> 00:27:33.430
And inheritance and containment
are two different things.

00:27:33.430 --> 00:27:38.000
Images and PDFs inherit from documents,
but they're contained inside of Windows.

00:27:38.100 --> 00:27:39.060
Okay.

00:27:39.060 --> 00:27:42.680
We've also deepened our
containment hierarchy.

00:27:42.730 --> 00:27:44.070
PDFs can have pages.

00:27:44.070 --> 00:27:46.700
So, we have to add that to our inventory.

00:27:46.700 --> 00:27:48.800
And there's this thing
called a slideshow.

00:27:48.800 --> 00:27:51.500
And we're thinking we're probably not
going to get to it in release one,

00:27:51.500 --> 00:27:54.480
but we better put it on our list because
we're designing the whole universe.

00:27:54.600 --> 00:27:55.680
And we want to make sure that
we're designing the whole universe.

00:27:55.680 --> 00:27:58.620
And we want to make sure that we
reserve those terms now so that

00:27:58.620 --> 00:28:01.910
we don't come back later and say,
you know, we really should have called

00:28:01.990 --> 00:28:03.720
this other thing a slideshow.

00:28:03.720 --> 00:28:04.920
Boy, we messed up.

00:28:05.050 --> 00:28:06.310
Now we're going to
have to work around it.

00:28:08.140 --> 00:28:11.610
We also looked at the toolbar
and the menus and we found some

00:28:11.610 --> 00:28:12.940
possibilities for commands.

00:28:12.990 --> 00:28:15.800
We want you to deliver an
object-oriented solution.

00:28:15.840 --> 00:28:17.480
We want you to think objects first.

00:28:17.480 --> 00:28:21.030
But every application has a few
things that it does that are unique

00:28:21.150 --> 00:28:24.650
to that application and you want to
make sure that you cover those so

00:28:24.650 --> 00:28:26.620
that your end users can use them.

00:28:26.940 --> 00:28:29.620
In preview,
some of the things we saw were rotate,

00:28:29.620 --> 00:28:30.640
flip, and zoom.

00:28:30.820 --> 00:28:34.540
We have this thing called a slideshow we
want to do and we know at the very least

00:28:34.540 --> 00:28:36.630
we're going to have to start and stop it.

00:28:36.720 --> 00:28:40.520
And then just in general,
almost any application will

00:28:40.520 --> 00:28:42.640
have these kinds of things.

00:28:42.640 --> 00:28:46.460
We were able to select an individual
page or an individual image

00:28:46.460 --> 00:28:48.340
and focus the window on that.

00:28:48.420 --> 00:28:51.250
So we're going to want to have
a way of selecting things.

00:28:51.320 --> 00:28:53.920
And the whole purpose of
preview is to show us stuff.

00:28:53.920 --> 00:28:56.920
So we want to be able to tell preview,
hey, show me this.

00:28:56.940 --> 00:28:59.380
and reveal is the word
that we use for that.

00:29:01.730 --> 00:29:05.140
I talked earlier about the difference
between inheritance and containment.

00:29:05.170 --> 00:29:07.310
Here's the containment hierarchy.

00:29:07.420 --> 00:29:10.600
The outermost container is
always the application itself.

00:29:10.610 --> 00:29:12.700
When you tell an
application to do something,

00:29:12.740 --> 00:29:15.720
it acts as the outermost container
for all these other objects.

00:29:16.020 --> 00:29:18.310
The application has a
window inside of it.

00:29:18.450 --> 00:29:23.440
The window has one or more documents
that can be either images or PDFs,

00:29:23.440 --> 00:29:25.900
and PDFs have one or more pages.

00:29:25.900 --> 00:29:29.570
And slideshows, we're figuring,
will probably also have images in them.

00:29:29.570 --> 00:29:33.930
And as we develop this some more
and we iterate our interview,

00:29:34.020 --> 00:29:38.050
we'll find out more about
what goes inside a slideshow.

00:29:38.500 --> 00:29:40.400
What makes one object
different from another?

00:29:40.400 --> 00:29:43.200
What makes one object interesting
when another isn't is the

00:29:43.200 --> 00:29:44.410
value of its properties.

00:29:44.610 --> 00:29:48.420
You're going to want to give your end
users access to these properties to

00:29:48.630 --> 00:29:52.710
allow them to get them and set them and
also to sift through their inventory

00:29:52.710 --> 00:29:56.780
of objects that they have and pick
the ones that they're interested in.

00:29:56.960 --> 00:30:01.560
We noticed while we were manipulating
preview that there was some notion

00:30:01.840 --> 00:30:04.480
of a current document in the window.

00:30:04.620 --> 00:30:08.120
We want to make sure that the
scripter can get at that so he knows

00:30:08.120 --> 00:30:12.100
which picture it is that is being
displayed in the window right now or

00:30:12.220 --> 00:30:16.470
which page of the PDF and that the
scripter will be able to change those.

00:30:17.360 --> 00:30:22.390
Again, the PDF document is going to have
a notion of a current page that's

00:30:22.450 --> 00:30:24.340
the one being shown in the window.

00:30:24.340 --> 00:30:25.760
We would want to support that as well.

00:30:25.780 --> 00:30:29.540
And another thing you can do with PDFs,
when I was experimenting with it,

00:30:29.720 --> 00:30:32.570
you can blow them up and make them
easier to read from the back of the room.

00:30:32.580 --> 00:30:34.600
So you're going to want to
be able to control the scale

00:30:34.670 --> 00:30:36.540
of the document as well,
and that's measured as

00:30:36.540 --> 00:30:38.000
a percentage of 100.

00:30:38.000 --> 00:30:41.370
And images,
they're going to have height and width,

00:30:41.370 --> 00:30:43.930
and they're going to have a file type.

00:30:44.660 --> 00:30:46.870
One of the things that Preview
does that's really powerful

00:30:46.870 --> 00:30:48.190
is convert between file types.

00:30:48.300 --> 00:30:50.580
You're definitely going to
want to make that scriptable.

00:30:50.580 --> 00:30:54.340
That's exactly the kind of tedious,
repetitive task that people hate,

00:30:54.340 --> 00:30:56.830
and we'll teach them to
hate your application unless

00:30:56.830 --> 00:30:58.180
you make it automatable.

00:30:58.180 --> 00:31:03.740
Slideshows are going to have intervals
for how long a slide stays on the screen,

00:31:03.740 --> 00:31:08.100
transitions for how one slide goes off
the screen and the next takes its place.

00:31:08.160 --> 00:31:11.420
And there's probably going to be settings
for those for the entire slideshow.

00:31:11.970 --> 00:31:14.730
There may very well be settings
for interval and transition for

00:31:14.730 --> 00:31:16.130
each individual slide as well.

00:31:16.260 --> 00:31:18.560
I know that Keynote supports that.

00:31:20.800 --> 00:31:22.210
Then,
after you've done this interview and

00:31:22.210 --> 00:31:24.400
you've gathered all this information,
all you've got to do is sit

00:31:24.460 --> 00:31:25.650
down and write a little XML.

00:31:25.660 --> 00:31:30.240
There are two really good
third-party solutions.

00:31:30.240 --> 00:31:32.830
Suite Modeler from Don Briggs.

00:31:32.920 --> 00:31:34.880
If Don's here, say hi.

00:31:34.880 --> 00:31:37.130
It's a good one.

00:31:37.140 --> 00:31:39.480
And then there's also SDef Editor.

00:31:39.480 --> 00:31:42.240
They're third-party shareware solutions.

00:31:42.240 --> 00:31:45.090
By all means, search for them on the web,
download them, see if you like them.

00:31:45.720 --> 00:31:50.900
I personally write my XML in BBEdit
and use their formatting features

00:31:50.900 --> 00:31:52.040
to make it look really pretty.

00:31:52.040 --> 00:31:54.530
I make fire with Flint and Stone.

00:31:54.540 --> 00:31:56.940
So you do it the way
that's right for you.

00:31:58.600 --> 00:32:00.830
You're going to want to take the
information that you got from that

00:32:00.830 --> 00:32:02.220
interview and put it in your dictionary.

00:32:02.220 --> 00:32:07.090
These are the terms that we came up
with when we were doing our interview.

00:32:07.100 --> 00:32:12.170
We saw that there was an image that
we were going to be able to look at.

00:32:12.220 --> 00:32:15.210
Images have height and width,
and images have file type.

00:32:15.520 --> 00:32:17.860
Those file types are enumerated.

00:32:17.860 --> 00:32:22.010
The way I found out which file
types preview supported is I did a

00:32:22.170 --> 00:32:24.430
save as and looked at the pop-up.

00:32:24.500 --> 00:32:26.560
That's where I found those.

00:32:27.860 --> 00:32:30.390
Then you're going to want to
assign 4-byte codes to those.

00:32:30.440 --> 00:32:32.650
I looked these up on
our 4-byte code page,

00:32:32.700 --> 00:32:35.140
and I found some and used the
ones that were already there.

00:32:35.140 --> 00:32:37.680
The ones that I didn't find,
I made up some,

00:32:37.680 --> 00:32:41.250
and then I looked for the ones I made up
and made sure that they weren't there.

00:32:41.260 --> 00:32:43.430
You've got to do it both ways.

00:32:43.460 --> 00:32:45.290
If you make up something new,
you've got to make sure it's not

00:32:45.360 --> 00:32:46.560
being used for something else.

00:32:46.560 --> 00:32:49.640
If you find what it is
you're trying to define,

00:32:49.640 --> 00:32:52.250
you definitely want to keep
the human readable term and the

00:32:52.250 --> 00:32:53.840
4-byte code paired together.

00:32:53.880 --> 00:32:57.060
You're the programmers.

00:32:57.060 --> 00:33:00.000
you get paid to do that kind of stuff.

00:33:01.050 --> 00:33:03.820
Then you're going to have to hook
this back up to your Cocoa objects

00:33:03.930 --> 00:33:05.380
inside your application.

00:33:05.400 --> 00:33:09.460
So the image object is represented
inside my application by a

00:33:09.540 --> 00:33:11.840
Cocoa object I call my image.

00:33:11.980 --> 00:33:14.500
We've also got this
nice property file type.

00:33:14.500 --> 00:33:17.590
And since AppleScript's a
nice English-like language,

00:33:17.590 --> 00:33:19.170
there's a space in there.

00:33:19.170 --> 00:33:22.820
Objective-C doesn't like spaces
in the middle of its method name.

00:33:22.850 --> 00:33:24.940
So somehow or another,
we're going to have to arbitrate that.

00:33:25.180 --> 00:33:28.930
So in our property element here,
we've got a non-empty element and

00:33:28.930 --> 00:33:31.350
inside of it we've got a Cocoa element.

00:33:31.390 --> 00:33:35.360
And we say that the key for this property
is file type with the space squeezed

00:33:35.440 --> 00:33:36.840
out and an intercap put in there.

00:33:36.860 --> 00:33:40.630
So this allows us to map really
nice-looking human-readable terms

00:33:40.630 --> 00:33:45.120
to the yuck that's inside of our
applications and hide that from the user.

00:33:45.160 --> 00:33:49.730
Then,
when you're done with all of this...

00:33:49.900 --> 00:33:52.500
You put it in the resources
folder in your application,

00:33:52.570 --> 00:33:54.870
you set a key in your P list,
point to it,

00:33:54.950 --> 00:33:56.800
and it becomes your scripting dictionary.

00:33:56.800 --> 00:33:59.760
And then anybody that wants to can
look at it with the dictionary viewer.

00:33:59.760 --> 00:34:02.320
If they drag and drop your
application on the script editor,

00:34:02.320 --> 00:34:03.790
the dictionary viewer opens up.

00:34:03.860 --> 00:34:06.930
If they're an
AppleScript Studio programmer

00:34:06.930 --> 00:34:11.100
and they're inside of Xcode and
they ask about your application,

00:34:11.100 --> 00:34:12.750
the dictionary viewer comes up.

00:34:12.800 --> 00:34:15.610
And they see this nice
representation of it.

00:34:16.090 --> 00:34:18.760
And you can see that inheritance
is being expressed here,

00:34:18.760 --> 00:34:23.220
containment is being expressed here,
references back to objects that

00:34:23.220 --> 00:34:27.640
are defined in the standard
suite are being expressed here.

00:34:27.640 --> 00:34:31.900
The end user can see everything
you've done to make this image object

00:34:32.030 --> 00:34:34.710
scriptable inside your application.

00:34:34.720 --> 00:34:37.040
This is just a little baby step here.

00:34:37.040 --> 00:34:39.100
You're going to want
to add more properties.

00:34:39.100 --> 00:34:40.460
You're going to want to add more objects.

00:34:40.580 --> 00:34:43.480
You're going to want to fill
this out to define everything

00:34:43.570 --> 00:34:45.670
that's inside of your application.

00:34:49.800 --> 00:34:52.960
After you're done with that,
then you need to write some

00:34:52.980 --> 00:34:54.610
code to make it all work.

00:34:54.710 --> 00:34:57.500
And I promised you that there
wasn't going to be a lot.

00:34:59.350 --> 00:35:01.920
There's four things that you
basically need to take care of.

00:35:01.970 --> 00:35:04.500
You have to have element accessors.

00:35:04.520 --> 00:35:08.580
The containment hierarchy is all about
nesting things inside of other things.

00:35:08.580 --> 00:35:12.500
You need to be able to traverse
that containment hierarchy

00:35:12.500 --> 00:35:14.230
and get at these things.

00:35:14.310 --> 00:35:18.050
So that means that the container objects
are going to have to have accessors

00:35:18.140 --> 00:35:19.980
to get at the contained objects.

00:35:20.800 --> 00:35:24.800
Chances are your application already
has something along these lines.

00:35:24.800 --> 00:35:28.280
If you're using an
NS Document-based application,

00:35:28.430 --> 00:35:32.410
then the NS Application object
already has ordered windows

00:35:32.410 --> 00:35:34.850
and ordered documents defined.

00:35:34.870 --> 00:35:41.230
Your window accessor and your document
accessor are already there for you.

00:35:41.270 --> 00:35:43.590
You just have to make sure
that you use the right method

00:35:43.590 --> 00:35:46.440
names in your dictionary,
hook that up, and it just works.

00:35:46.440 --> 00:35:49.660
The objects that you define
have to behave similarly.

00:35:49.660 --> 00:35:52.290
You have to have ordered
collections of things,

00:35:52.680 --> 00:35:55.300
make them available to the scripter
so that they can manipulate them.

00:35:55.300 --> 00:35:57.550
You're going to need to do
some element management,

00:35:57.650 --> 00:35:57.740
too.

00:35:57.740 --> 00:35:59.130
You want to create and delete things.

00:35:59.140 --> 00:36:03.230
Your collection of data is not static,
and you definitely want to give the

00:36:03.250 --> 00:36:05.120
scripting user the chance to do that.

00:36:05.190 --> 00:36:08.390
One of the first things a tester is
going to do when they get their hands

00:36:08.390 --> 00:36:11.630
on your scriptability is write a script
that's going to fill the database up

00:36:11.630 --> 00:36:14.580
with a thousand objects real fast so
that they don't have to do that by

00:36:14.580 --> 00:36:16.480
hand every time they get a new release.

00:36:16.480 --> 00:36:19.290
You're going to have to
have property accessors.

00:36:19.390 --> 00:36:20.680
What makes one object
different from the other?

00:36:20.680 --> 00:36:23.510
What makes one object more
interesting than another is

00:36:23.520 --> 00:36:25.100
the value of its properties.

00:36:25.140 --> 00:36:26.840
This is something you might
actually already have.

00:36:26.890 --> 00:36:29.220
You might get that for free,
and we'll see that later.

00:36:29.220 --> 00:36:33.780
And then lastly, and we do mean lastly,
you want to do your commands.

00:36:33.820 --> 00:36:38.170
You want to do everything you possibly
can in an object-oriented fashion.

00:36:38.550 --> 00:36:42.940
If you have some property
that's just a Boolean value,

00:36:43.000 --> 00:36:45.780
you don't want to create two
different verbs to turn it on and off.

00:36:45.780 --> 00:36:49.770
You don't want to have a show
command and a hide command.

00:36:49.770 --> 00:36:52.060
What you want to have
is a visible property.

00:36:52.060 --> 00:36:54.380
And if you set that
visible property to true,

00:36:54.380 --> 00:36:55.890
then you can see the object.

00:36:55.890 --> 00:36:57.580
You set it to false, you can't.

00:36:57.720 --> 00:36:59.370
Saves you two commands.

00:36:59.370 --> 00:37:02.540
You're going to have to create that
Boolean property anyway because you're

00:37:02.540 --> 00:37:05.730
going to need to be able to query it
to see if something's visible or not.

00:37:06.480 --> 00:37:08.330
Once you've got that and
you make it read-write,

00:37:08.330 --> 00:37:10.580
you don't need the show
and hide commands anymore.

00:37:10.580 --> 00:37:13.990
So try to do things in an
object-oriented fashion first,

00:37:13.990 --> 00:37:17.540
then make commands when it's
really a unique situation.

00:37:19.580 --> 00:37:21.030
Element accessors look like this.

00:37:21.040 --> 00:37:25.310
And again, I said you might already
have something like this.

00:37:27.330 --> 00:37:33.040
The name images comes from the
object name in your dictionary,

00:37:33.040 --> 00:37:36.900
and it gets repeated in a naming
pattern throughout these accessors.

00:37:37.000 --> 00:37:39.110
If you've got small
collections of things,

00:37:39.110 --> 00:37:42.830
if you've got a little graphics program
and put maybe a couple of dozen,

00:37:42.830 --> 00:37:45.840
a couple of hundred graphics on the
screen at one particular point in time,

00:37:45.840 --> 00:37:48.260
you can just return the
entire collection all at once.

00:37:48.660 --> 00:37:51.040
If you have a more
voluminous application,

00:37:51.040 --> 00:37:54.780
if the back end of your application
is a database or the back end of your

00:37:54.780 --> 00:37:58.640
application is the entire Internet,
it's not reasonable for you to

00:37:58.640 --> 00:38:01.970
return the entire collection every
time somebody wants to look at

00:38:02.040 --> 00:38:03.620
one element in that collection.

00:38:03.620 --> 00:38:05.670
So you've got an alternative here.

00:38:05.670 --> 00:38:09.150
You can have two variants of this,
one of which returns

00:38:09.150 --> 00:38:12.600
the count of the images,
the other of which returns a

00:38:12.600 --> 00:38:15.460
particular image at a particular index.

00:38:15.540 --> 00:38:18.300
Cocoa Scripting will figure out
which of these you've supported.

00:38:18.820 --> 00:38:24.060
And use them appropriately to make
your application perform better.

00:38:24.060 --> 00:38:27.240
And in the interest of performance,
there's a couple more

00:38:27.340 --> 00:38:29.010
accessors that are defined.

00:38:29.020 --> 00:38:32.540
You may have a back end that allows you
to find things by name really quickly.

00:38:32.540 --> 00:38:35.120
You may have a hash table where
you can look things up by name

00:38:35.130 --> 00:38:36.690
and find them really quickly.

00:38:36.700 --> 00:38:41.530
And if you do, you want to provide that
performance to your scripting users.

00:38:41.580 --> 00:38:46.090
And you do that by providing a method
called value in images with name.

00:38:46.100 --> 00:38:47.950
And again, images would change.

00:38:47.980 --> 00:38:48.600
Images would change.

00:38:48.620 --> 00:38:48.660
Images would change.

00:38:48.660 --> 00:38:51.960
Images, documents, windows,
whatever objects you support,

00:38:51.960 --> 00:38:54.680
that word that's in there
in yellow keeps changing.

00:38:54.700 --> 00:38:57.440
And if you've got your
back end as a database,

00:38:57.540 --> 00:39:01.560
your database probably supports
some notion of a database key.

00:39:01.560 --> 00:39:05.940
And it can get things by, it can search,
it can retrieve things from the

00:39:05.990 --> 00:39:09.910
database using that key very
quickly and very efficiently.

00:39:09.960 --> 00:39:12.590
You want to pass that
performance capability on to

00:39:12.670 --> 00:39:16.180
your scripters by implementing
value in images with unique ID.

00:39:18.670 --> 00:39:23.580
defining unique ID property
on the image object,

00:39:23.860 --> 00:39:27.860
Use the database key to
represent that unique ID,

00:39:27.860 --> 00:39:30.120
and then you'll be able to fetch things
from your database in the quickest

00:39:30.460 --> 00:39:32.230
and most efficient manner possible.

00:39:34.230 --> 00:39:36.980
You're going to want to
manage your objects as well.

00:39:36.980 --> 00:39:40.880
You want to create new ones,
get rid of old ones, move things from one

00:39:40.880 --> 00:39:44.180
collection to another,
move an image from one album to another,

00:39:44.180 --> 00:39:45.540
from one folder to another.

00:39:45.540 --> 00:39:50.760
And you do that with these two routines,
insert object in images at index,

00:39:50.760 --> 00:39:53.840
and remove object from images at index.

00:39:53.840 --> 00:39:56.100
And again, images changes with
the name of the object.

00:39:57.260 --> 00:39:59.540
And if you provide these two,
Cocoa Scripting will use

00:39:59.540 --> 00:40:01.980
them at the appropriate point
in time to make new things,

00:40:01.980 --> 00:40:04.060
get rid of old things,
and to move things around from

00:40:04.060 --> 00:40:05.340
one collection to another.

00:40:05.340 --> 00:40:09.640
And every good scriptable object
needs to be able to identify itself.

00:40:09.670 --> 00:40:12.010
It needs to return an object specifier.

00:40:12.020 --> 00:40:15.300
And an object specifier is
essentially a return address.

00:40:15.300 --> 00:40:20.010
It tells the scripter or the script
itself while it's running how to get back

00:40:20.160 --> 00:40:24.150
to something that it's touched before,
how to get back to an object

00:40:24.150 --> 00:40:26.120
that it was looking for before.

00:40:26.540 --> 00:40:30.010
And you want to return the best
object specifier that you can.

00:40:30.030 --> 00:40:33.430
If your back end is a database,
and you have a key that uniquely

00:40:33.870 --> 00:40:37.560
identifies every record in the database,
you want to use that in

00:40:37.560 --> 00:40:39.280
your object specifier.

00:40:39.280 --> 00:40:41.610
Because then those object
specifiers are good for as

00:40:41.640 --> 00:40:43.170
long as the program is running.

00:40:43.170 --> 00:40:45.800
You'll always be able to
get back to the same record.

00:40:45.800 --> 00:40:46.660
You'll never miss.

00:40:46.660 --> 00:40:50.600
Nothing bad will happen because
you added or deleted objects.

00:40:50.700 --> 00:40:54.590
If you don't have something like that,
you may want to use a

00:40:54.740 --> 00:40:56.370
name object specifier.

00:40:56.610 --> 00:40:59.600
Particularly if you're referencing
things in the file system,

00:40:59.600 --> 00:41:02.470
name object specifiers are
usually very good for that.

00:41:02.560 --> 00:41:07.160
In AppleScript and
scriptability in general,

00:41:07.160 --> 00:41:10.940
it's not necessary that names be unique.

00:41:11.060 --> 00:41:16.640
So the name object specifier is not as
good as the unique ID object specifier,

00:41:16.640 --> 00:41:20.010
but it can be good
enough for your purposes.

00:41:20.040 --> 00:41:22.120
You just want to make sure
that you're consistent.

00:41:22.140 --> 00:41:24.220
If someone references something by name,
and there's two copies

00:41:24.220 --> 00:41:25.480
with the same name,
you want to make sure

00:41:25.480 --> 00:41:26.520
that you're consistent.

00:41:26.540 --> 00:41:30.400
name, you want to make sure that you
always return the first one,

00:41:30.560 --> 00:41:32.720
whatever first means to you.

00:41:32.880 --> 00:41:37.520
Because then if someone finds that
object and then later decides,

00:41:37.600 --> 00:41:41.090
okay I want to delete that object,
he won't accidentally delete the other

00:41:41.090 --> 00:41:42.940
one that happens to have the same name.

00:41:42.940 --> 00:41:46.810
As long as you consistently return
the same object for the same name,

00:41:47.030 --> 00:41:48.120
that'll work too.

00:41:48.120 --> 00:41:50.880
The third kind of object
specifiers is by index.

00:41:50.880 --> 00:41:52.240
This is the weakest kind.

00:41:52.240 --> 00:41:53.180
This can change.

00:41:53.300 --> 00:41:57.860
If you return an object specifier
that's defined by index and you add

00:41:57.860 --> 00:42:00.710
or delete anything to the collection,
it's possible that that

00:42:00.710 --> 00:42:02.440
index isn't good anymore.

00:42:02.440 --> 00:42:04.490
The things have shifted back
and forth and now the index

00:42:04.490 --> 00:42:05.950
actually points somewhere else.

00:42:06.310 --> 00:42:07.230
That's problematic.

00:42:07.360 --> 00:42:08.640
It can lead to data loss.

00:42:08.640 --> 00:42:09.760
You want to try to avoid it.

00:42:09.760 --> 00:42:12.470
But there's situations where
it's perfectly appropriate.

00:42:12.470 --> 00:42:16.880
For instance, if you're talking about a
character inside of a word,

00:42:17.200 --> 00:42:19.880
inside of a paragraph,
it's perfectly appropriate

00:42:19.880 --> 00:42:21.160
to do that by index.

00:42:21.160 --> 00:42:27.050
It's not practical to create a unique
ID for every character in a document.

00:42:27.160 --> 00:42:30.600
It's not practical to create a name
for every character in a document.

00:42:30.600 --> 00:42:31.820
You just do it by index.

00:42:31.920 --> 00:42:35.310
And your scripters will need to know,
gee when I'm manipulating

00:42:35.310 --> 00:42:38.240
text on the character level,
I have to be careful about

00:42:38.240 --> 00:42:39.740
indices sliding back and forth.

00:42:39.860 --> 00:42:41.830
If I delete something,
I have to throw away all my old

00:42:41.830 --> 00:42:45.450
object specifiers and get new ones.

00:42:47.580 --> 00:42:51.620
If you've made an application
scriptable before,

00:42:51.640 --> 00:42:54.860
then you know one of the most
difficult parts is handling

00:42:54.860 --> 00:42:56.130
the making of new objects.

00:42:56.220 --> 00:42:59.960
The way that Cocoa Scripting worked
is it would allocate an object of

00:42:59.980 --> 00:43:02.190
the class that it was interested in.

00:43:02.200 --> 00:43:05.130
It would call init on that
object with no parameters.

00:43:05.140 --> 00:43:09.340
Then it would call set on that object
to set the various properties that

00:43:09.340 --> 00:43:11.960
were specified in the make new command.

00:43:11.960 --> 00:43:14.940
And then it would call the insertion
routine that we saw earlier

00:43:14.940 --> 00:43:16.300
to add it to the collection.

00:43:17.590 --> 00:43:21.000
This was great for a lot of applications,
but it wasn't so great

00:43:21.000 --> 00:43:22.090
for other applications.

00:43:22.100 --> 00:43:25.750
First of all, your designated initializer
might not be init.

00:43:25.840 --> 00:43:29.240
You might have another initializer
that needs to be called for

00:43:29.540 --> 00:43:30.890
your object to work correctly.

00:43:30.960 --> 00:43:32.820
An excellent case of this is Core Data.

00:43:32.900 --> 00:43:35.930
Core Data really brought
this problem home to us.

00:43:35.940 --> 00:43:40.260
Making Core Data applications scriptable
was difficult just for that reason alone.

00:43:40.340 --> 00:43:43.660
Core Data has an initializer
that takes several parameters,

00:43:43.910 --> 00:43:46.500
and somebody needs to call that.

00:43:47.130 --> 00:43:52.880
What we've done is we've added
a new object creation interface.

00:43:53.210 --> 00:43:57.940
It's a method that you can define on
a container object that will receive

00:43:58.200 --> 00:44:03.360
all of the information needed to create
an object all at once and allow you to

00:44:03.360 --> 00:44:05.350
determine the order of the operations.

00:44:05.420 --> 00:44:07.000
This works great for core data.

00:44:07.040 --> 00:44:09.960
It works great for approaching
existing applications that

00:44:09.960 --> 00:44:11.640
have complex initializers.

00:44:11.640 --> 00:44:14.970
It works great for a lot of people
that were finding scriptability

00:44:15.050 --> 00:44:16.900
very difficult for this reason.

00:44:17.000 --> 00:44:23.110
The first thing that happens is
the class of the object that's

00:44:23.120 --> 00:44:25.200
being defined in the make new

00:44:25.600 --> 00:44:42.300
[Transcript missing]

00:44:42.650 --> 00:44:47.370
In the case of the preview dictionary
that we were showing you before,

00:44:47.500 --> 00:44:50.540
the class would just be NSWindow
because that's what's defined

00:44:50.540 --> 00:44:52.360
in the standard dictionary.

00:44:52.430 --> 00:44:55.990
And the key would be orderedWindows
because that's the collection it's

00:44:55.990 --> 00:44:57.820
going to be inserted into later.

00:44:58.410 --> 00:45:01.380
You also have the option when you
make a new object to pass in some

00:45:01.380 --> 00:45:03.940
data using a with data clause.

00:45:04.030 --> 00:45:07.900
And what might be appropriate in the case
of preview would be a list of images to

00:45:07.900 --> 00:45:11.530
open up when this new window is created.

00:45:11.810 --> 00:45:15.790
Those are going to arrive into your
application in the contents value.

00:45:16.010 --> 00:45:19.000
In this case, the contents value is
going to be an NSArray,

00:45:19.010 --> 00:45:24.340
and that NSArray is probably going to
have NSURLs in it to define these files.

00:45:24.790 --> 00:45:26.730
Then you're also going to want
to be able to set properties on

00:45:26.730 --> 00:45:29.770
that object when you create it,
and those are going to show up

00:45:29.770 --> 00:45:34.500
in your method that you code
in the properties operand here.

00:45:34.500 --> 00:45:38.280
And that's going to be an
NSDictionary that's going to have

00:45:38.810 --> 00:45:44.500
entries for height and width and values
of 300 and 400 associated with them.

00:45:44.580 --> 00:45:48.600
So you've got all the data that you need
to make this new object all at once.

00:45:48.600 --> 00:45:50.850
And so you make this
new object all at once,

00:45:50.960 --> 00:45:54.260
and then you return it as the
return value of this routine.

00:45:54.700 --> 00:45:57.890
And then more or less immediately,
Cocoa Scripting will call you back and

00:45:57.920 --> 00:45:59.850
tell you to insert it in the collection.

00:45:59.880 --> 00:46:04.290
This solves a lot of problems,
particularly if you're trying to make

00:46:04.290 --> 00:46:08.420
a core data application scriptable,
or again, like I said,

00:46:08.420 --> 00:46:11.540
if you've got a large existing
application that has complex

00:46:11.640 --> 00:46:13.560
initializers for your objects.

00:46:13.560 --> 00:46:15.260
And that's a very common case.

00:46:17.770 --> 00:46:20.360
Property accessors are important
because it's how you differentiate

00:46:20.360 --> 00:46:22.240
one object from another.

00:46:22.360 --> 00:46:24.400
Chances are, like I said,
if you're using things

00:46:24.400 --> 00:46:27.680
like key value coding,
key value observing, and bindings,

00:46:27.680 --> 00:46:30.160
you've already got a lot
of these things defined.

00:46:30.340 --> 00:46:33.790
And the old way to do it was to just
have a pair of accessors that would

00:46:33.790 --> 00:46:37.140
have the name of the property and
then set the name of the property,

00:46:37.150 --> 00:46:38.640
and you'd define both of these.

00:46:38.790 --> 00:46:43.210
If we wanted to have a name for an image,
this would be the pair of accessors

00:46:43.250 --> 00:46:47.030
that would get us at the name
property and allow us to set it.

00:46:48.020 --> 00:46:52.080
Key-value coding also can do some
introspection on your object and

00:46:52.080 --> 00:46:56.880
actually find your instance variables
with the correct name and hook them up.

00:46:57.020 --> 00:47:02.140
If you're really bindings-centric,
you may be depending upon this already

00:47:02.140 --> 00:47:04.580
and you don't have any accessors.

00:47:04.580 --> 00:47:09.000
You just let bindings access
the instance variables directly.

00:47:09.000 --> 00:47:10.770
Well, scripting can do the same thing.

00:47:10.770 --> 00:47:13.670
You don't have to write any extra
code that's just for scripting.

00:47:14.430 --> 00:47:17.620
And if you've graduated
to Objective-C 2.0 with

00:47:17.620 --> 00:47:21.580
the @Property directive,
again, Cocoa Scripting knows about this.

00:47:21.580 --> 00:47:22.620
It finds it for you.

00:47:22.620 --> 00:47:23.960
You don't have to write any code.

00:47:23.960 --> 00:47:25.040
It all just works.

00:47:27.680 --> 00:47:32.770
When you're implementing commands,
when you're done right at the very end,

00:47:32.770 --> 00:47:35.630
you can't think of anything else to do,
and you've finally gotten

00:47:35.630 --> 00:47:37.900
down to the commands,
you're going to have to make some

00:47:37.900 --> 00:47:40.240
decisions about how to implement them.

00:47:40.240 --> 00:47:42.520
And there's basically two different ways.

00:47:42.580 --> 00:47:46.600
You can do them object
first or command first.

00:47:47.310 --> 00:47:50.310
Okay, how do you decide which to do?

00:47:50.440 --> 00:47:52.410
Always consider object first first.

00:47:52.620 --> 00:47:57.160
This is, we're asking you to do an
object-oriented solution.

00:47:57.190 --> 00:48:01.490
So obviously we want you to do the
object first method if you can.

00:48:01.490 --> 00:48:04.480
Any command that acts on
objects independently is

00:48:04.480 --> 00:48:06.190
suitable for this method.

00:48:06.370 --> 00:48:07.480
Rotate's a good example.

00:48:07.480 --> 00:48:09.660
No matter how many
pictures I tell to rotate,

00:48:09.660 --> 00:48:12.630
each picture just rotates
individually on its own and doesn't

00:48:12.730 --> 00:48:16.060
need to know about all the rest
of the pictures that are out there.

00:48:16.920 --> 00:48:21.310
Here I'm saying pictures
instead of images.

00:48:21.520 --> 00:48:24.560
That's not the case with some commands.

00:48:24.620 --> 00:48:26.600
If you have an align command,
if you've got a bunch of

00:48:26.600 --> 00:48:30.040
graphics in a document and you
want to align their left edges,

00:48:30.170 --> 00:48:33.240
you're going to have to act on all
of those objects at the same time.

00:48:33.310 --> 00:48:35.520
Those objects do need to
know about each other.

00:48:35.590 --> 00:48:38.750
One of them has to be chosen
as the left edge that everybody

00:48:38.750 --> 00:48:40.690
else is going to be lined up to.

00:48:40.810 --> 00:48:44.760
You may decide for purposes of your
application to just pick the first one.

00:48:44.820 --> 00:48:48.670
You may decide for purposes of your
application to pick whichever one

00:48:48.670 --> 00:48:50.510
is farthest to the left already.

00:48:50.710 --> 00:48:54.520
So you want to be able to look at
all of those objects all at once.

00:48:54.570 --> 00:48:56.800
To do that,
you want to do command-first dispatching.

00:48:56.800 --> 00:49:00.820
And to do that, you define a Cocoa object
that represents the command,

00:49:00.820 --> 00:49:02.540
the align command.

00:49:02.540 --> 00:49:06.340
You inherit from the NS script command,
and you implement a method called

00:49:06.340 --> 00:49:08.380
perform default implementation.

00:49:08.760 --> 00:49:11.960
And what's going to happen is when
a scripter issues this command,

00:49:11.960 --> 00:49:15.000
an instance of this align command
object is going to be created,

00:49:15.100 --> 00:49:18.800
and the perform default implementation
method is going to be called.

00:49:18.800 --> 00:49:23.380
And then you get your opportunity to act
on the entire collection all at once.

00:49:26.360 --> 00:49:31.610
Cocoa Scripting uses your
application as a set of callbacks.

00:49:32.110 --> 00:49:34.850
And once you're familiar with it,
it is very logical,

00:49:34.850 --> 00:49:37.790
it's very predictable,
and it's going to make a whole lot

00:49:37.830 --> 00:49:39.710
of sense to you what's going on.

00:49:39.840 --> 00:49:43.010
But there's a learning curve,
and you're going to have to find out,

00:49:43.100 --> 00:49:45.640
how does Cocoa Scripting
use my application?

00:49:45.640 --> 00:49:47.620
What callbacks do I get?

00:49:47.930 --> 00:49:51.870
The toughest part of debugging
scripting implementations

00:49:51.870 --> 00:49:55.750
when you first get started is,
where the heck do I put the breakpoint?

00:49:55.770 --> 00:49:56.900
What's going to happen next?

00:49:56.900 --> 00:49:58.460
I can't get my program to stop.

00:49:59.280 --> 00:50:03.250
Well, one way that you can find out is to
use some kind of logging mechanism.

00:50:03.260 --> 00:50:07.220
Just put a little macro,
sprinkle it around in your application.

00:50:07.240 --> 00:50:10.820
I put it at the very beginning of
every single routine that I write that

00:50:10.820 --> 00:50:13.970
has anything to do with scripting,
and a lot that don't.

00:50:13.980 --> 00:50:15.740
I put it absolutely everywhere.

00:50:15.760 --> 00:50:18.580
And you can have something really simple.

00:50:18.580 --> 00:50:20.610
This is what I started out
with several years ago.

00:50:20.620 --> 00:50:23.550
But then Brooke Callahan
from the Automator team,

00:50:23.650 --> 00:50:27.780
he put me wise and told me that I could
have a lot of stuff done for me.

00:50:27.780 --> 00:50:29.480
I used to have to type
in the method name.

00:50:29.480 --> 00:50:31.000
I used to have to type in the file name.

00:50:31.020 --> 00:50:33.170
Now I don't anymore,
because I've got a little

00:50:33.170 --> 00:50:34.280
bit more complicated macro.

00:50:34.320 --> 00:50:36.880
And again,
I put this absolutely everywhere.

00:50:36.900 --> 00:50:40.370
And just by changing that zero to a one,
I can turn this on.

00:50:40.400 --> 00:50:42.880
Just make sure you don't check
it into the source repository

00:50:42.980 --> 00:50:45.370
with the switch turned on,
or everybody else that works on the

00:50:45.470 --> 00:50:46.910
project is going to get real mad at you.

00:50:50.480 --> 00:50:53.940
I maintain an application
called System Events.

00:50:53.940 --> 00:50:56.770
If you're an experienced scripter,
you may be familiar with it.

00:50:56.890 --> 00:50:59.250
One of the things that
System Events can do is it can tell

00:50:59.380 --> 00:51:00.880
you if the script menu is enabled.

00:51:00.890 --> 00:51:04.490
It can tell you if that little
script icon is up in the upper

00:51:04.490 --> 00:51:06.780
right-hand end of your menu bar.

00:51:06.780 --> 00:51:13.720
And you might want to know that if
you're doing some kind of installation

00:51:13.720 --> 00:51:14.910
because you might have scripts
that you want to install in there.

00:51:15.410 --> 00:51:20.330
And if you turn on the logging in
System Events and you issue the

00:51:20.340 --> 00:51:23.480
Get Script Menu Enabled command,
then you'll get these messages

00:51:23.560 --> 00:51:24.810
down here at the bottom.

00:51:24.820 --> 00:51:28.420
And my macro automatically
sticks my initials in there.

00:51:28.420 --> 00:51:31.120
That way, if I'm working on a big
project with a lot of people,

00:51:31.120 --> 00:51:35.920
I can tell which messages are coming
from my macros and which messages aren't.

00:51:36.060 --> 00:51:38.550
And my initials are not a
string that's likely to show up

00:51:38.550 --> 00:51:40.300
accidentally in some other word.

00:51:41.260 --> 00:51:44.560
I also have the name of the file,
so I can go back to the source

00:51:44.670 --> 00:51:47.050
file where the problem is,
or at least where I want

00:51:47.050 --> 00:51:48.110
to put the breakpoint.

00:51:48.180 --> 00:51:51.460
Because that's what I'm trying to learn
here is what is Cocoa Scripting doing?

00:51:51.460 --> 00:51:52.580
Where do I put my breakpoints?

00:51:52.580 --> 00:51:55.100
How do I follow through?

00:51:55.900 --> 00:51:58.670
It'll also give me the line number,
so it's really absurdly simple to know

00:51:58.670 --> 00:52:00.040
where I need to put my breakpoint.

00:52:00.040 --> 00:52:03.370
It'll give me the name of the
routine that's being called,

00:52:04.160 --> 00:52:07.030
and sometimes that's all I need.

00:52:07.040 --> 00:52:09.110
Sometimes I don't even need to
go and look at the source file.

00:52:09.120 --> 00:52:10.850
I say, oh, I'm getting called there.

00:52:10.890 --> 00:52:11.820
Yeah, that's wrong.

00:52:11.820 --> 00:52:14.300
And also,
if there's any key inputs to this

00:52:14.380 --> 00:52:18.840
routine that are going to tell you
something about what's going to happen,

00:52:18.860 --> 00:52:21.240
you can put those in the
logging macro as well,

00:52:21.240 --> 00:52:23.970
and you'll be able to see
those in the console log.

00:52:24.640 --> 00:52:29.110
You turn this on, recompile your app,
run your test script,

00:52:29.360 --> 00:52:33.240
and you'll get a log of everything that
your application did in order to satisfy

00:52:33.240 --> 00:52:35.400
the requirements of that test script.

00:52:35.460 --> 00:52:37.800
Turn it back off,
the macros compile again,

00:52:38.100 --> 00:52:41.350
everything goes away,
and you're ready to ship your code.

00:52:44.570 --> 00:52:47.910
Testing is really important, again,
for two reasons.

00:52:48.170 --> 00:52:52.040
First, it's one of the great benefits
that you get out of making

00:52:52.040 --> 00:52:55.120
your application scriptable.

00:52:55.160 --> 00:52:57.590
You can test not just the
scripting part of your application,

00:52:57.640 --> 00:53:00.110
but the whole back end,
the whole engine that makes your

00:53:00.110 --> 00:53:01.600
application as great as it is.

00:53:01.740 --> 00:53:06.000
You can test that and make sure
that you're not breaking anything.

00:53:06.510 --> 00:53:08.900
So you want to do repeatable
regression testing.

00:53:08.970 --> 00:53:10.580
You want to access every element.

00:53:10.580 --> 00:53:13.020
You want to create and
delete every kind of element.

00:53:13.020 --> 00:53:15.180
You want to move things back
and forth between collections.

00:53:15.180 --> 00:53:18.300
You want to access all the
properties of all the elements.

00:53:18.340 --> 00:53:21.440
And you want to exercise all of
your commands that you created.

00:53:21.440 --> 00:53:24.150
And you want to exercise all of
the commands from the standard

00:53:24.150 --> 00:53:25.660
suite that you support as well.

00:53:26.400 --> 00:53:28.940
These examples here are in
the form of AppleScript.

00:53:28.990 --> 00:53:30.750
That's what I'm most familiar with.

00:53:30.790 --> 00:53:35.840
But if you attended the talk yesterday
talking about Apple Event Bridge and

00:53:36.030 --> 00:53:40.340
the various language bridges,
you'll know that AppleScript is not

00:53:40.340 --> 00:53:43.150
the only language you can use anymore.

00:53:43.150 --> 00:53:44.010
You can use Ruby.

00:53:44.010 --> 00:53:44.970
You can use Python.

00:53:44.970 --> 00:53:46.240
You can use Objective-C.

00:53:46.240 --> 00:53:49.520
You can use any language that
has a bridge to Objective-C.

00:53:49.520 --> 00:53:53.420
So you can write your tests in
whatever scripting language you like.

00:53:53.420 --> 00:53:55.520
You don't have to use AppleScript.

00:53:56.180 --> 00:54:00.540
And Ruby and Python have some
testing infrastructure built into

00:54:00.540 --> 00:54:03.080
them to drive suites of unit tests.

00:54:03.170 --> 00:54:06.750
You might want to make use of that to
even further automate your testing.

00:54:06.780 --> 00:54:10.010
But these examples are all in
the form of AppleScript because

00:54:10.010 --> 00:54:12.070
that's what I'm most familiar with.

00:54:12.120 --> 00:54:14.860
Again,
you want to get at everything in your

00:54:15.020 --> 00:54:17.360
application every way that you can.

00:54:17.360 --> 00:54:19.500
You want to test all of
your element accessors.

00:54:19.500 --> 00:54:22.700
And you want to use all the various
different ways of specifying which

00:54:22.790 --> 00:54:24.390
element you want to talk about.

00:54:26.960 --> 00:54:32.830
You want to do some of these special
named indices and negative indices.

00:54:32.830 --> 00:54:34.130
And if you're not
familiar with AppleScript,

00:54:34.170 --> 00:54:36.760
negative indices count backwards
from the end of the collection.

00:54:36.760 --> 00:54:39.320
So if you want the last
thing in a collection,

00:54:39.340 --> 00:54:41.570
that's index minus one and so forth.

00:54:41.710 --> 00:54:45.180
And you definitely want to test whose
clauses or whatever the equivalent is

00:54:45.180 --> 00:54:47.120
in the language that you're writing.

00:54:47.120 --> 00:54:49.680
You want to create some
kind of complex predicate.

00:54:49.680 --> 00:54:52.740
You want to ask for a
collection of objects based on

00:54:52.740 --> 00:54:54.790
the values of the properties.

00:54:54.800 --> 00:54:57.270
And the reason why you want to
do that is because that's what

00:54:57.270 --> 00:54:58.800
your customers are going to do.

00:54:58.820 --> 00:54:59.800
This is the power of the language.

00:54:59.800 --> 00:55:03.640
Going after things one at a time,
iterating through the entire collection,

00:55:04.110 --> 00:55:06.780
pounding on things with a little hammer,
that's not the interesting part.

00:55:06.780 --> 00:55:10.550
The interesting part is mining the data,
going fishing,

00:55:10.730 --> 00:55:15.230
finding out what's in there,
getting at things by means of a query,

00:55:15.230 --> 00:55:17.700
and then acting on those results.

00:55:20.580 --> 00:55:22.100
You're going to want to test
your element management.

00:55:22.100 --> 00:55:27.460
That's one of the potentially most
difficult parts of your program.

00:55:27.460 --> 00:55:29.650
That's where if things go wrong,
you can have data loss.

00:55:29.650 --> 00:55:32.160
So you want to make sure
that this works very well.

00:55:32.160 --> 00:55:33.190
You want to create new objects.

00:55:33.190 --> 00:55:34.230
You want to delete new objects.

00:55:34.270 --> 00:55:36.750
And this is great for
stress testing as well.

00:55:37.270 --> 00:55:41.770
Creating and deleting objects thousands
at a time is great for stress testing.

00:55:41.780 --> 00:55:44.990
You want to get at all your properties
and make sure that that works.

00:55:45.030 --> 00:55:46.970
You can get at the properties as a group.

00:55:46.970 --> 00:55:49.610
You can get at the properties
individually by name.

00:55:51.260 --> 00:55:53.750
You want to create repeatable
regression tests where you

00:55:53.750 --> 00:55:56.510
change the values of a property,
but then you change them back

00:55:56.510 --> 00:55:57.400
to what they were before.

00:55:57.740 --> 00:56:00.270
So if you run this test again tomorrow,
you can expect to get

00:56:00.270 --> 00:56:01.600
exactly the same results.

00:56:01.780 --> 00:56:05.640
You can even automate the comparison
of results if you're creating

00:56:05.640 --> 00:56:08.750
suites of automated tests in
your favorite scripting language.

00:56:09.040 --> 00:56:11.030
You want to test edge cases.

00:56:11.200 --> 00:56:13.420
Push your program right up to the
limit of what it can do and make

00:56:13.420 --> 00:56:14.880
sure that that works correctly.

00:56:14.880 --> 00:56:16.510
And you also want to test error cases.

00:56:16.610 --> 00:56:19.960
Make sure that the scripter gets back
some kind of reasonable response that's

00:56:19.980 --> 00:56:23.730
going to help them debug their script and
figure out what it is they've done wrong.

00:56:23.750 --> 00:56:27.850
If you need more specific information
about how to return particular errors,

00:56:27.850 --> 00:56:31.050
come and see us in the lab and
we can tell you all about that.

00:56:32.930 --> 00:56:34.340
And with your commands,
you're going to want

00:56:34.340 --> 00:56:35.230
to do the same thing.

00:56:35.240 --> 00:56:38.390
You're going to want to test your
commands with just default parameters.

00:56:38.480 --> 00:56:39.930
Just issue the command
and see what happens.

00:56:40.020 --> 00:56:41.720
Make sure it doesn't do anything bad.

00:56:41.730 --> 00:56:44.420
Make sure that it presumes
some reasonable defaults

00:56:44.420 --> 00:56:46.060
and does something useful.

00:56:46.080 --> 00:56:51.070
And you want to do it with all
the parameters specified as well.

00:56:51.700 --> 00:57:06.000
[Transcript missing]

00:57:06.710 --> 00:57:11.700
And last and probably most important,
you want to include some real-world

00:57:11.700 --> 00:57:13.460
test cases in your test suites.

00:57:13.510 --> 00:57:17.080
We talked about getting feedback
from your online community.

00:57:17.080 --> 00:57:20.490
We talked about your end users
becoming very loyal to you because

00:57:20.820 --> 00:57:24.430
they've put you in their automated
workflows and now they're dependent

00:57:24.440 --> 00:57:26.610
upon you as part of their daily lives.

00:57:27.120 --> 00:57:29.890
You want to make sure that you
don't break those workflows.

00:57:29.890 --> 00:57:32.960
You want to make sure that you don't
hurt those people that love your

00:57:32.980 --> 00:57:35.190
application because of its scriptability.

00:57:35.240 --> 00:57:37.760
And you also want to make
sure that your big customers,

00:57:37.760 --> 00:57:41.290
if you've got one big customer that
accounts for two-thirds of your revenue,

00:57:41.290 --> 00:57:44.140
you definitely want to make
sure you never hurt that guy.

00:57:44.140 --> 00:57:46.420
So what you want to do
is communicate with him.

00:57:46.420 --> 00:57:49.380
Get his scripts that he actually
uses on a day-to-day basis.

00:57:49.380 --> 00:57:50.810
Put them in your test suite.

00:57:50.810 --> 00:57:52.630
Make sure that they never break.

00:57:52.760 --> 00:57:53.920
Retain the results.

00:57:53.920 --> 00:57:56.400
Compare the results
from release to release.

00:57:56.960 --> 00:57:58.950
And validate your release
before you send it out.

00:57:59.000 --> 00:58:02.860
You don't want your best and most
loyal customers to be disappointed

00:58:02.970 --> 00:58:07.220
with your newest release because
you broke their weekly workflow.

00:58:09.490 --> 00:58:12.490
If you want more information,
you've got lots of sources.

00:58:12.710 --> 00:58:17.180
Sal Sigourian is our Product Manager of
Automation Technologies.

00:58:17.180 --> 00:58:19.120
His name gets longer and longer.

00:58:19.120 --> 00:58:24.040
And he's the Product Manager for
both AppleScript and Automator

00:58:24.190 --> 00:58:26.620
and all the language bridges.

00:58:26.620 --> 00:58:30.560
John Montbriand is your
Developer Technical Support contact.

00:58:30.560 --> 00:58:33.140
If you get a message to him,
he'll make sure it gets to the right

00:58:33.140 --> 00:58:36.410
engineer in the right group and that
you get some kind of answer back.

00:58:36.780 --> 00:58:38.770
Lots of documentation online.

00:58:38.770 --> 00:58:42.020
Techno 2106,
the scripting interface guidelines,

00:58:42.020 --> 00:58:45.610
the table of Apple event terms
and codes so that you can pick

00:58:45.610 --> 00:58:47.600
your 4-byte codes correctly.

00:58:47.600 --> 00:58:50.690
Lots more documentation.

00:58:50.780 --> 00:58:54.270
And the last one up there is just
the site for the show itself.

00:58:54.580 --> 00:58:56.540
Each session will have its own page.

00:58:56.580 --> 00:58:59.410
You can go to the page for this
session and there'll be some wonderful

00:58:59.410 --> 00:59:00.840
links there for you to follow.

00:59:00.840 --> 00:59:04.140
Tomorrow at 10.30 a.m.

00:59:04.140 --> 00:59:05.820
downstairs in Mac Lab A.

00:59:06.280 --> 00:59:08.440
We'll be there to help make
your application scriptable.

00:59:08.440 --> 00:59:11.440
We can go through a blind interview
and help you design your dictionary.

00:59:11.440 --> 00:59:12.910
We can help you write code.

00:59:12.910 --> 00:59:14.520
We can help you write tests.

00:59:14.520 --> 00:59:17.830
We can just give you general
encouragement to make your application

00:59:17.830 --> 00:59:21.520
scriptable and show you how it'll
interact with other people if you do,

00:59:21.520 --> 00:59:23.390
with other applications if you do.

00:59:25.110 --> 00:59:28.830
And so, to sum it all up,
customers get a chance to

00:59:28.830 --> 00:59:31.120
solve their own problems,
which is great for them,

00:59:31.370 --> 00:59:32.370
and it's great for you.

00:59:32.380 --> 00:59:35.000
You spend less time hunting
for regressions because

00:59:35.080 --> 00:59:36.780
they're caught automatically.

00:59:36.880 --> 00:59:40.310
You spend more time on beneficial
features that you know lots of

00:59:40.310 --> 00:59:42.320
people are already interested in.

00:59:42.390 --> 00:59:45.940
The customers spend less time
doing the same thing over and over,

00:59:45.940 --> 00:59:47.860
learning to hate your program.

00:59:47.860 --> 00:59:53.060
And they spend more money ordering
upgrades and new desks for your program.

00:59:53.770 --> 00:59:54.780
Everybody wins.

00:59:55.000 --> 00:59:56.100
Thank you.
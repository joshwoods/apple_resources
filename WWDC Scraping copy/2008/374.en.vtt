WEBVTT

00:00:20.710 --> 00:00:22.830
Well, good afternoon, everybody.

00:00:22.940 --> 00:00:26.770
Bonjour, konichiwa, nimakauma.

00:00:27.040 --> 00:00:29.340
Welcome, bienvenue, daigafu, nyingra.

00:00:29.340 --> 00:00:35.840
This is session 374,
internationalizing your software.

00:00:35.840 --> 00:00:37.260
And I am John Jenkins.

00:00:37.330 --> 00:00:39.760
I'm a senior software engineer at Apple.

00:00:39.940 --> 00:00:43.760
I will be your guide to this
wonderful world of localization

00:00:43.780 --> 00:00:45.000
and internationalization.

00:00:45.000 --> 00:00:48.810
In the spirit of the session,
I am also Zheng Zhaohang,

00:00:48.990 --> 00:00:53.520
or in the barbarian northern dialect,
Zheng Zhaohang, or if you prefer,

00:00:53.550 --> 00:00:55.410
Shona Prichardt.

00:00:56.870 --> 00:00:58.910
or even Juani Tinikini.

00:00:59.090 --> 00:01:02.010
I will answer to any of those
and I may give a prize to the

00:01:02.010 --> 00:01:05.840
first person who can identify all
four localizations of my name.

00:01:06.010 --> 00:01:08.120
So, what are we talking about?

00:01:08.510 --> 00:01:11.880
Internationalization,
which is often referred to

00:01:12.000 --> 00:01:15.790
with the abbreviation I18N,
an I followed by 18

00:01:15.860 --> 00:01:17.600
letters followed by an N.

00:01:17.600 --> 00:01:21.040
This is the process of preparing
your software to be used in different

00:01:21.040 --> 00:01:23.080
places and with different languages.

00:01:23.120 --> 00:01:28.800
Localization,
which has a similar abbreviation, L10N.

00:01:28.800 --> 00:01:34.280
This is the process of actually adding
data for specific languages and locales.

00:01:34.900 --> 00:01:38.630
You need to do both of them if you're
going to be properly internationalized.

00:01:38.680 --> 00:01:40.250
Both processes must be done.

00:01:40.540 --> 00:01:42.990
However, of the two,
the most important is

00:01:43.110 --> 00:01:47.210
the internationalization,
the process of getting things ready,

00:01:47.210 --> 00:01:48.810
getting things set up.

00:01:48.900 --> 00:01:51.090
This has to be done by the programmers.

00:01:51.090 --> 00:01:52.820
This has to be done in-house.

00:01:52.820 --> 00:01:53.970
This has to be done first.

00:01:54.060 --> 00:01:57.680
Once it is done, the localization,
particularly on Mac OS,

00:01:57.780 --> 00:02:01.600
the localization is an almost
entirely separate process.

00:02:01.600 --> 00:02:03.940
It comes later.

00:02:04.380 --> 00:02:06.330
It can be done,
actually can be outsourced and

00:02:06.380 --> 00:02:07.700
off to third parties to do.

00:02:07.700 --> 00:02:11.920
The structure that we have and which
we'll be explaining makes it easy to add

00:02:11.970 --> 00:02:14.520
localizations once the work is finished.

00:02:14.540 --> 00:02:19.040
So we will be focusing
on internationalization.

00:02:19.040 --> 00:02:22.580
We will also be focusing on Mac OS X.

00:02:24.220 --> 00:02:27.800
Pretty much everything here does,
in fact, apply to the iPhone as well.

00:02:27.800 --> 00:02:30.240
So if you learn how to
internationalize on the Mac,

00:02:30.360 --> 00:02:32.330
you know how to
internationalize on the iPhone.

00:02:32.330 --> 00:02:36.800
So learn it once,
and you can do it on both ways.

00:02:36.800 --> 00:02:41.560
Some key ideas that we want everyone to
come away from this session understanding

00:02:41.560 --> 00:02:45.130
is that internationalization
is enormously difficult.

00:02:45.130 --> 00:02:48.200
It is a very, very hard thing to do.

00:02:48.200 --> 00:02:51.280
Fortunately, we have done it for you.

00:02:51.320 --> 00:02:56.010
If you use the APIs built into Mac OS,
virtually all of the work

00:02:56.010 --> 00:02:57.790
will be done for you.

00:02:57.800 --> 00:03:00.890
In fact, for most people,
all of the work will be done for you.

00:03:00.900 --> 00:03:03.470
There will be a few people,
a few situations where you

00:03:03.470 --> 00:03:06.430
need something special that
you'll have to do on your own,

00:03:06.430 --> 00:03:08.930
but almost nobody will
have to deal with them.

00:03:08.960 --> 00:03:13.540
So write your application properly,
use the APIs that we provide,

00:03:13.540 --> 00:03:16.260
and everything comes automatically.

00:03:18.130 --> 00:03:20.970
Which means we're through, basically.

00:03:21.150 --> 00:03:23.610
There are three main steps
to internationalization.

00:03:23.680 --> 00:03:25.500
The first is to use Unicode.

00:03:25.630 --> 00:03:27.990
The second is to take
advantage of bundles.

00:03:28.000 --> 00:03:29.460
And then the third is to use locales.

00:03:29.520 --> 00:03:31.080
We will be discussing all three of these.

00:03:31.080 --> 00:03:34.510
And they all need to be done.

00:03:34.520 --> 00:03:36.350
Now, as I say,
we do most of the work for you,

00:03:36.460 --> 00:03:38.620
so you may not actually
have to use these directly,

00:03:38.650 --> 00:03:41.850
but you should at least understand
what's going on under the hood.

00:03:42.860 --> 00:03:45.840
So, let's start with Unicode.

00:03:45.840 --> 00:03:49.020
Now, Unicode, you know,
I'm old enough that I remember

00:03:49.020 --> 00:03:52.160
introducing Unicode as
a new character set.

00:03:52.160 --> 00:03:54.680
Unicode is, in fact,
not a new character set.

00:03:54.680 --> 00:03:55.900
It's almost 20 years old.

00:03:55.900 --> 00:04:00.970
And yet, there's a surprising amount
of misunderstandings that

00:04:01.060 --> 00:04:05.990
you'll run into regarding it.

00:04:05.990 --> 00:04:05.990
So, we're going to take a few minutes
and discuss it in some detail.

00:04:06.320 --> 00:04:09.110
Unicode, if you do not know,
is a character set,

00:04:09.150 --> 00:04:13.020
and its goal is to make it
possible to represent on computers

00:04:13.150 --> 00:04:17.950
simultaneously all written languages,
living or dead.

00:04:17.980 --> 00:04:20.150
It's not quite there yet.

00:04:20.230 --> 00:04:23.020
There are some dead
languages it doesn't cover.

00:04:23.020 --> 00:04:25.060
There are some minority
scripts it doesn't cover.

00:04:25.060 --> 00:04:30.210
But virtually anything that your
users will run into is in Unicode now,

00:04:30.210 --> 00:04:31.840
or will be shortly.

00:04:31.840 --> 00:04:35.310
And by simultaneous, I mean exactly that.

00:04:35.350 --> 00:04:38.940
A properly written Unicode
application can handle any text in

00:04:38.940 --> 00:04:42.290
any writing system with equal ease.

00:04:42.720 --> 00:04:45.480
You could even theoretically
have a document which contains in

00:04:45.480 --> 00:04:48.950
one document samples from every
language and every writing system,

00:04:48.960 --> 00:04:49.570
and it will work.

00:04:49.630 --> 00:04:52.600
That's what Unicode is all about.

00:04:52.740 --> 00:04:55.100
The current version of
the standard is 5.1.0.

00:04:55.100 --> 00:04:57.590
That came out just a couple months ago.

00:04:57.590 --> 00:05:01.590
And there are currently over
100,000 characters in Unicode.

00:05:01.600 --> 00:05:04.590
Now, the exact number depends
on how you count them.

00:05:04.590 --> 00:05:07.590
There are a number of control characters,
things like that.

00:05:07.640 --> 00:05:12.190
But there are over 100,000
graphical characters that cover

00:05:12.190 --> 00:05:14.600
77 different writing systems.

00:05:14.600 --> 00:05:18.600
So, as I say, pretty much everything you
will need is already there.

00:05:19.210 --> 00:05:23.680
Moreover, Unicode is the way to represent
internationalized text in

00:05:23.860 --> 00:05:27.520
almost every setting now,
but in particular on the Internet.

00:05:27.690 --> 00:05:31.460
Just to give an example,
if you do HTML and you use

00:05:31.460 --> 00:05:36.610
numeric entities at all,
those are Unicode code points.

00:05:37.130 --> 00:05:41.300
So it is everywhere
that you're doing text.

00:05:41.300 --> 00:05:44.880
And just so that you're
familiar with the convention,

00:05:44.880 --> 00:05:48.160
the way to represent Unicode
code points is with a capital U,

00:05:48.160 --> 00:05:50.400
a plus sign,
and then four to six hexadecimal

00:05:50.400 --> 00:05:51.580
digits following that.

00:05:51.640 --> 00:05:53.840
And this is the convention
we'll be following here.

00:05:54.900 --> 00:05:58.380
Main thing to remember and to
understand about Unicode is

00:05:58.380 --> 00:06:00.600
that it is not 16-bit ASCII.

00:06:00.600 --> 00:06:04.480
ASCII is obscenely easy to program for.

00:06:04.480 --> 00:06:07.160
There's almost nothing you need to do.

00:06:07.170 --> 00:06:12.240
Unicode is almost obscenely
difficult to program for.

00:06:12.260 --> 00:06:14.240
It is very hard to do.

00:06:14.240 --> 00:06:17.450
And as I say,
we've done the work for you,

00:06:17.450 --> 00:06:20.140
and you should be glad of that.

00:06:20.200 --> 00:06:24.770
There are some things that you may run
into or that you may need to be aware of.

00:06:24.780 --> 00:06:26.310
And we'll mention those briefly.

00:06:26.440 --> 00:06:28.350
We're not going to go
into all of Unicode.

00:06:28.350 --> 00:06:30.210
We could devote an entire conference.

00:06:30.210 --> 00:06:33.220
In fact, there are entire conferences
devoted to Unicode.

00:06:33.220 --> 00:06:36.780
But we'll be mentioning here
some really important points.

00:06:36.890 --> 00:06:41.130
The first is the existence of the
different encoding forms of Unicode.

00:06:41.130 --> 00:06:42.990
Second is the byte order mark.

00:06:43.100 --> 00:06:48.090
The four or five normalization forms and,
most importantly, grapheme clusters.

00:06:48.100 --> 00:06:51.140
And again,
don't try to do this on your own.

00:06:51.140 --> 00:06:53.660
You may need to know what's going on.

00:06:53.740 --> 00:06:54.770
But if so long as you're doing it,
you're going to be able to do it.

00:06:54.840 --> 00:06:56.860
And if so long as you use
the APIs that we've provided,

00:06:56.860 --> 00:06:58.240
you should be just fine.

00:06:58.240 --> 00:07:00.120
So encoding forms.

00:07:00.160 --> 00:07:03.800
There are three basic ways
that Unicode is actually

00:07:03.800 --> 00:07:06.120
represented in terms of bytes.

00:07:06.220 --> 00:07:09.440
The first of these is UTF-8.

00:07:09.480 --> 00:07:11.980
This is a byte-oriented protocol.

00:07:11.980 --> 00:07:14.240
You read data one byte at a time.

00:07:14.260 --> 00:07:17.400
This means a couple of
really useful things.

00:07:17.400 --> 00:07:20.240
In particular,
it is upwardly compatible with ASCII.

00:07:20.240 --> 00:07:23.240
A valid ASCII file is a valid UTF-8 file.

00:07:23.240 --> 00:07:24.630
It also means that you can use
it in a lot of different ways.

00:07:24.680 --> 00:07:24.690
You can use it in a
lot of different ways.

00:07:24.690 --> 00:07:24.760
You can use it in a
lot of different ways.

00:07:24.760 --> 00:07:30.120
The second is that UTF-8 works seamlessly
with older protocols and older libraries

00:07:30.560 --> 00:07:33.390
which expect ASCII-like character sets.

00:07:33.480 --> 00:07:38.290
UTF-8 is now the most common text
encoding used on the Internet.

00:07:38.290 --> 00:07:43.600
Google announced just a few weeks ago
that of all the pages on the Internet,

00:07:43.600 --> 00:07:47.970
more are encoded in UTF-8
than any other text encoding.

00:07:48.640 --> 00:07:52.220
Now, there's also UTF-16.

00:07:52.220 --> 00:07:55.690
UTF-16 is the oldest way of
representing Unicode on computers,

00:07:55.690 --> 00:07:58.500
and it's the way that you will
typically see in libraries.

00:07:58.650 --> 00:08:02.570
In particular, it's the form which we
use inside NSString.

00:08:03.260 --> 00:08:07.230
UTF-16, as the name implies,
you're reading data 16 bits at a time,

00:08:07.290 --> 00:08:07.980
two bytes.

00:08:08.040 --> 00:08:11.120
And if you're dealing with
units of more than one byte,

00:08:11.120 --> 00:08:13.430
you have to care about byte swapping.

00:08:13.430 --> 00:08:16.190
Now, there's a built-in mechanism
that I'll mention in a minute

00:08:16.190 --> 00:08:17.550
to deal with byte swapping.

00:08:17.560 --> 00:08:23.010
There are also two variations of UTF-16,
UTF-16BE and UTF-16LE,

00:08:23.050 --> 00:08:26.290
which specify in advance
what the byte order is,

00:08:26.290 --> 00:08:28.590
so that you can deal with that.

00:08:28.620 --> 00:08:32.640
And finally, there's UTF-32, and as,
again, the name implies,

00:08:32.650 --> 00:08:35.320
you're dealing with
data 32 bits at a time,

00:08:35.320 --> 00:08:38.120
four bytes,
so there are also two variations that

00:08:38.120 --> 00:08:40.380
specify the byte order in advance.

00:08:40.380 --> 00:08:44.250
UTF-32 is not terribly common,
and it is not likely

00:08:44.250 --> 00:08:47.260
to be terribly common,
and this is why.

00:08:47.260 --> 00:08:49.540
Here we have four
characters from Unicode.

00:08:49.630 --> 00:08:53.480
A common Latin letter,
a not-quite-so-common Latin letter,

00:08:53.480 --> 00:08:58.600
a relatively common Chinese character,
and a decidedly rare Chinese character.

00:08:58.620 --> 00:09:01.580
And how you represent them in each
of these three encoding forms.

00:09:01.580 --> 00:09:07.240
UTF-8, capital letter A is one byte, 4-1,
just as you would expect.

00:09:07.360 --> 00:09:10.180
The others require two, three,
and four bytes, respectively.

00:09:10.220 --> 00:09:15.940
UTF-16 are common characters,
each require two bytes.

00:09:15.990 --> 00:09:18.010
The rare character requires four.

00:09:18.030 --> 00:09:21.550
UTF-32, they each require four bytes,
and that tells you instantly

00:09:21.550 --> 00:09:23.240
what's wrong with UTF-32.

00:09:23.240 --> 00:09:26.380
Most of those bits are zero.

00:09:26.380 --> 00:09:28.600
Most of the bytes are zero.

00:09:28.620 --> 00:09:33.380
So it's not a terribly efficient way
of storing text in terms of memory.

00:09:33.380 --> 00:09:38.460
Hence, UTF-16 is probably going to be the
most common for the indefinite future.

00:09:38.460 --> 00:09:41.170
Now,
I mentioned that Unicode has a built-in

00:09:41.220 --> 00:09:43.440
mechanism to deal with byte order.

00:09:43.600 --> 00:09:47.640
This is called the byte order mark,
Unicode F-E-F-F.

00:09:47.830 --> 00:09:54.690
It is used to distinguish UTF-16
and UTF-32 byte order variations.

00:09:54.690 --> 00:09:58.860
You don't need it if you already know
what the byte order is going to be,

00:09:58.860 --> 00:10:00.860
if that's specified some other way.

00:10:00.860 --> 00:10:02.980
In particular,
you don't need it for UTF-8.

00:10:02.980 --> 00:10:04.700
UTF-8 reads data byte by byte.

00:10:04.700 --> 00:10:05.540
There's no byte order.

00:10:05.540 --> 00:10:09.820
However, you will sometimes see it at the
beginning of UTF-8 text files.

00:10:09.820 --> 00:10:13.880
People use this as a flag so that
they know that the text file is UTF-8.

00:10:14.260 --> 00:10:17.620
This can create problems,
but you do see it.

00:10:17.700 --> 00:10:22.300
It's generated by several
different programs.

00:10:22.490 --> 00:10:24.430
This is how it works.

00:10:25.310 --> 00:10:28.320
You put the buy order mark at
the beginning of your text,

00:10:28.360 --> 00:10:30.190
F-E-F-F.

00:10:30.350 --> 00:10:35.330
You account on the fact that
its byte-swapped counterpart,

00:10:35.430 --> 00:10:38.610
FFFE, is defined to be undefined.

00:10:39.050 --> 00:10:42.680
So when the data is read in,
you read in the first two bytes,

00:10:42.680 --> 00:10:45.700
you will either see F-E-F-F or F-F-F-E.

00:10:45.700 --> 00:10:49.090
If you see F-E-F-F,
that's the byte order mark.

00:10:49.160 --> 00:10:52.590
That tells you that you are interpreting
byte order the same way the text file is,

00:10:52.590 --> 00:10:54.230
and you don't need to do anything.

00:10:54.230 --> 00:10:59.500
If you see F-F-F-E,
you know that you do need to byte swap.

00:10:59.630 --> 00:11:02.290
You are interpreting byte order,
or you have a different byte

00:11:02.300 --> 00:11:04.960
order from the text file,
and you know how to proceed.

00:11:05.640 --> 00:11:06.890
So here we have an example.

00:11:06.890 --> 00:11:09.100
The first word in our document is 6F22.

00:11:09.100 --> 00:11:12.260
There are two different
Unicode characters that this

00:11:12.330 --> 00:11:15.180
could possibly represent,
although admittedly,

00:11:15.230 --> 00:11:18.430
one of them is not likely to be
the first character in a text file,

00:11:18.430 --> 00:11:20.560
but they're still both valid Unicode.

00:11:22.430 --> 00:11:25.300
Without the byte order mark,
you don't know which one to use.

00:11:25.300 --> 00:11:27.940
With the byte order mark, you do.

00:11:28.100 --> 00:11:32.530
So you will see this at the beginning
of a lot of Unicode text files.

00:11:33.800 --> 00:11:35.460
Next are the normalization forms.

00:11:35.460 --> 00:11:39.310
One of the things that makes Unicode
really difficult to deal with is the fact

00:11:39.380 --> 00:11:43.460
that characters or units on the screen,
what we call graphemes,

00:11:43.660 --> 00:11:47.390
can be represented with more than
one byte and sometimes characters can

00:11:47.390 --> 00:11:49.700
be represented in more than one way.

00:11:49.890 --> 00:11:52.690
Example here is an accented E.

00:11:52.810 --> 00:11:59.490
You can either do it as a single
character or as a pair of characters,

00:11:59.490 --> 00:11:59.490
the lowercase e and the acute accent.

00:12:00.450 --> 00:12:04.620
To simplify Unicode processing,
the Unicode Consortium has defined

00:12:04.620 --> 00:12:06.580
four different normalization forms.

00:12:06.580 --> 00:12:09.380
The idea is that you will take text,
you will normalize it to

00:12:09.380 --> 00:12:12.010
one of these four forms,
you will then know an awful lot

00:12:12.010 --> 00:12:14.460
about the characteristics it has,
and that will make it

00:12:14.460 --> 00:12:15.370
easier for you to process.

00:12:15.380 --> 00:12:18.500
The first form is normalization form C.

00:12:18.500 --> 00:12:21.640
You use combined forms wherever possible.

00:12:21.640 --> 00:12:24.660
Normalization form D is the opposite.

00:12:24.690 --> 00:12:27.400
You use decomposed
forms wherever possible.

00:12:28.390 --> 00:12:31.290
And then there are two
variations of these,

00:12:31.390 --> 00:12:32.300
NFKC and NFKD.

00:12:32.520 --> 00:12:35.170
The K stands for compatibility.

00:12:35.230 --> 00:12:40.040
And the idea here is that Unicode has
what are called compatibility characters.

00:12:40.060 --> 00:12:45.320
These two normalization forms will
get rid of the compatibility variance.

00:12:45.340 --> 00:12:48.000
Before I show examples,
I just need to mention there is, in fact,

00:12:48.000 --> 00:12:52.810
a fifth form that you may
theoretically run into on the Mac OS,

00:12:52.920 --> 00:12:58.860
and that is the form used by HFS+.
HFS+ is a file system which is

00:12:58.880 --> 00:13:01.810
used by most Macintoshes out there.

00:13:02.130 --> 00:13:04.170
And it uses a form of names.

00:13:04.200 --> 00:13:06.080
It uses UTF-16.

00:13:06.230 --> 00:13:10.520
It uses a decomposed form of Unicode,
which is almost exactly the same as NFD,

00:13:10.520 --> 00:13:12.340
but not quite.

00:13:12.380 --> 00:13:14.650
There are some differences.

00:13:14.770 --> 00:13:17.770
Again, this is not something you'll
probably have to deal with,

00:13:17.770 --> 00:13:19.720
but you should be aware that it exists.

00:13:19.780 --> 00:13:21.180
So here are some examples.

00:13:21.210 --> 00:13:24.540
I want to compare NFC and NFD.

00:13:24.540 --> 00:13:26.520
I've already showed one instance of this.

00:13:26.550 --> 00:13:28.160
E with an acute accent.

00:13:28.160 --> 00:13:31.660
Okay, you can either do it as a
single character or as two.

00:13:31.660 --> 00:13:36.300
The common Korean surname Kim,
as in Kim Jong Il,

00:13:36.300 --> 00:13:38.920
you can either do as a single
character or you can do it,

00:13:38.920 --> 00:13:41.910
given the nature of Korean, as three,
the "keu," the "i,"

00:13:41.920 --> 00:13:44.680
and the "m" separately.

00:13:45.520 --> 00:13:51.200
To compare NFC and NFKC,
one of Unicode's goals was to be

00:13:51.200 --> 00:13:57.620
compatible with character sets
which existed when it was created.

00:13:57.800 --> 00:14:02.230
This makes it really useful for
upgrading old data or for doing

00:14:02.230 --> 00:14:04.000
conversions between character sets.

00:14:04.000 --> 00:14:06.620
But it also means that Unicode
inherited characters that it

00:14:06.690 --> 00:14:08.300
otherwise would not have included.

00:14:08.300 --> 00:14:14.460
And one of these is the FI ligature,
which is found at Unicode FB01.

00:14:14.670 --> 00:14:18.590
has an FI ligature,
so Unicode had to have one.

00:14:18.600 --> 00:14:22.560
Now, Unicode prefers that you do
ligatures by other mechanisms,

00:14:22.560 --> 00:14:25.600
and so that's considered
a compatibility character.

00:14:25.600 --> 00:14:28.600
It's there only for compatibility
with a different character set.

00:14:28.730 --> 00:14:30.860
So if you use NFC, it will be there.

00:14:30.860 --> 00:14:34.670
If you use NFKC,
the compatibility mapping is taken away,

00:14:34.670 --> 00:14:37.420
and it's split into two characters,
the two pieces.

00:14:37.420 --> 00:14:44.480
An even better example of a compatibility
character is F900 compared with 8C4.

00:14:44.610 --> 00:14:47.280
Now, if you look at these,
your first impression may be

00:14:47.280 --> 00:14:49.060
that they look exactly the same.

00:14:49.080 --> 00:14:53.440
But if you look at them really, really,
really closely,

00:14:53.440 --> 00:14:57.470
you'll notice that they do, in fact,
look exactly the same.

00:14:57.800 --> 00:15:01.760
The difference between the two
is that they are pronounced

00:15:01.760 --> 00:15:03.390
differently in Korean.

00:15:03.900 --> 00:15:06.400
Unicode does not distinguish
characters based on how they

00:15:06.400 --> 00:15:09.850
are pronounced in Korean,
but an older Korean character set did.

00:15:09.910 --> 00:15:14.570
So Unicode has F900 as a
compatibility character.

00:15:14.570 --> 00:15:17.070
And if you do one of the
compatibility mappings,

00:15:17.070 --> 00:15:19.860
that distinction,
which is not relevant to Unicode,

00:15:19.860 --> 00:15:20.950
will be removed.

00:15:21.440 --> 00:15:24.550
And finally, we have an example,
and you can just look at it,

00:15:24.770 --> 00:15:30.020
of the difference between NFD and
HFS+. This particular character is one

00:15:30.810 --> 00:15:35.540
character in HFS+ on your file systems,
and it's two in NFD.

00:15:35.540 --> 00:15:38.440
And again,
this is not a character you are, in fact,

00:15:38.440 --> 00:15:40.720
likely to have in very many file names.

00:15:41.310 --> 00:15:45.920
Finally, most importantly,
we want to talk about grapheme clusters.

00:15:45.920 --> 00:15:49.770
I already mentioned Unicode can have
characters represented with pieces.

00:15:49.790 --> 00:15:53.490
Now, what you see on the screen,
what you see on the printed page,

00:15:53.490 --> 00:15:54.690
this is called a grapheme.

00:15:54.700 --> 00:15:56.300
This is the basic unit of writing.

00:15:56.300 --> 00:15:59.320
And it can be built up out of pieces.

00:15:59.320 --> 00:16:00.760
And this is very useful in Unicode.

00:16:01.400 --> 00:16:04.500
Okay, here we have a rather rare example.

00:16:04.610 --> 00:16:08.200
This is a Greek alpha with a
macron and an acute accent.

00:16:08.200 --> 00:16:11.640
You may actually see this in
books on ancient Greek poetry.

00:16:11.640 --> 00:16:14.410
It's a legitimate thing
to want to represent.

00:16:14.420 --> 00:16:17.810
However,
the number of possible combinations

00:16:17.810 --> 00:16:23.040
of accents that do exist for Latin,
Greek, and Cyrillic is so astronomically

00:16:23.110 --> 00:16:26.170
high that to find and encode
them all separately would

00:16:26.330 --> 00:16:28.230
require prohibitive expense.

00:16:28.280 --> 00:16:31.380
So Unicode takes the easy route,
and it just lets you encode it by hand.

00:16:31.400 --> 00:16:32.640
So Unicode takes the easy route,
and it just lets you encode it by hand.

00:16:32.640 --> 00:16:35.820
Now, in practice,
what this means is that you cannot

00:16:35.820 --> 00:16:40.140
just jump into an arbitrary point
in text and assume that you are

00:16:40.140 --> 00:16:44.680
on the boundaries between things
that the user wants to distinguish.

00:16:44.680 --> 00:16:47.670
You might be in the middle
of a grapheme cluster.

00:16:47.680 --> 00:16:51.380
So if you are doing searching,
if you are doing substringing,

00:16:51.380 --> 00:16:53.620
this you need to be very much aware of.

00:16:53.720 --> 00:16:56.360
Because otherwise,
you might be doing things to the

00:16:56.360 --> 00:16:59.640
text that don't reflect what the
user is actually looking for.

00:17:01.310 --> 00:17:02.070
So that's Unicode.

00:17:02.300 --> 00:17:04.040
Brief introduction.

00:17:04.160 --> 00:17:04.880
How do you do Unicode?

00:17:04.880 --> 00:17:07.340
How do you do text on Mac OS?

00:17:07.500 --> 00:17:11.040
On the Mac and on the iPhone,
you use NSString.

00:17:11.190 --> 00:17:15.080
This is the class for representing text.

00:17:15.230 --> 00:17:18.610
It is toll-free bridged with
its core foundation counterpart,

00:17:18.610 --> 00:17:19.600
CFStringRef.

00:17:19.600 --> 00:17:22.100
That means that you can
use them interchangeably.

00:17:22.100 --> 00:17:25.400
If you have a CFStringRef and you
need a pointer to an NSString,

00:17:25.400 --> 00:17:27.810
you can just do a cast,
and that's all the

00:17:27.810 --> 00:17:29.690
conversion that's needed.

00:17:30.190 --> 00:17:32.820
NSString keeps you,
the application programmer,

00:17:32.820 --> 00:17:36.490
from having to deal with the
complexities of text on your own.

00:17:36.670 --> 00:17:38.880
Now, in this case,
there are some related classes

00:17:38.880 --> 00:17:39.980
that you may find useful.

00:17:40.270 --> 00:17:42.360
There's NSMutableString,
in case you are modifying

00:17:42.460 --> 00:17:43.860
your string after you make it.

00:17:43.860 --> 00:17:46.740
Perhaps you're creating
it one piece at a time.

00:17:46.900 --> 00:17:48.250
There's NSAttributedString.

00:17:48.260 --> 00:17:50.300
This is enormously useful.

00:17:50.400 --> 00:17:56.570
If you want to have a button or a table
or some other UI element have text

00:17:56.600 --> 00:17:59.800
that you get to control the font for,
that you get to specify

00:17:59.800 --> 00:18:04.750
the point size for,
on the fly, you use NSAttributedString,

00:18:04.750 --> 00:18:06.600
and it's drawn correctly.

00:18:06.840 --> 00:18:09.400
Finally,
there's NSMutableAttributedString, which,

00:18:09.480 --> 00:18:11.600
as the name implies, does both of these.

00:18:11.600 --> 00:18:14.990
We'll be looking primarily at NSString.

00:18:15.980 --> 00:18:17.660
How do you create them?

00:18:17.690 --> 00:18:21.590
There's an easy way, which, of course,
you're not supposed to do.

00:18:21.690 --> 00:18:23.660
Put them in your source code.

00:18:23.760 --> 00:18:28.310
And the way you do that is you have your
string constant and you put an at sign in

00:18:28.310 --> 00:18:33.370
front of it that tells the compiler that
this is an NSString and not a char star.

00:18:34.100 --> 00:18:38.840
Or the most flexible way is
using string with format.

00:18:39.080 --> 00:18:41.800
We'll discuss that in
a little more detail.

00:18:41.890 --> 00:18:46.800
Now, if you have an array
of 16-bit characters,

00:18:46.990 --> 00:18:49.830
unit chars,
and you know how long the array is,

00:18:49.840 --> 00:18:52.220
you can just hand that into
NSString and create a string with that,

00:18:52.220 --> 00:18:53.290
string with characters.

00:18:53.310 --> 00:18:57.150
Notice, do not use WCharty.

00:18:57.160 --> 00:19:00.950
WCharty on the Mac is
not 16 bits in size.

00:19:00.950 --> 00:19:02.140
It is on other platforms.

00:19:02.140 --> 00:19:03.380
It is not on the Mac.

00:19:03.440 --> 00:19:06.470
You need to use something
which is 16 bits in size,

00:19:06.470 --> 00:19:09.610
like a unit char or a
UN16T or something like that.

00:19:09.610 --> 00:19:11.400
Not WCharty.

00:19:11.800 --> 00:19:16.160
Finally, if you know the encoding
of an old piece of text,

00:19:16.290 --> 00:19:19.190
it is a C string that
you got handed somehow,

00:19:19.300 --> 00:19:21.950
it is an old file that you have,
it is something that is

00:19:21.950 --> 00:19:25.980
being pulled off the web,
or it is even in an NSData object,

00:19:26.050 --> 00:19:29.280
you know what the encoding is,
there are functions in

00:19:29.280 --> 00:19:32.700
NSString that let you create a
string and convert it to Unicode.

00:19:32.720 --> 00:19:35.640
So conversion to Unicode is simple.

00:19:35.640 --> 00:19:38.970
We won't show examples,
but conversion from

00:19:38.970 --> 00:19:41.250
Unicode is equally simple.

00:19:41.680 --> 00:19:44.780
Now let's look at string with
format in a little more detail.

00:19:44.930 --> 00:19:46.970
This is, as I say,
the way you will probably be doing

00:19:46.980 --> 00:19:48.460
most of your string creation.

00:19:48.600 --> 00:19:51.640
It's very simple,
because the syntax is almost

00:19:51.640 --> 00:19:53.600
exactly the same as sprintf.

00:19:53.870 --> 00:19:57.460
There are a couple of
differences that are very handy.

00:19:57.690 --> 00:20:00.950
The first is to use %@,
this lets you include

00:20:00.960 --> 00:20:04.090
an Objective-C object in
your formatted string.

00:20:04.310 --> 00:20:06.600
Usually you use this
for an NSString object.

00:20:06.830 --> 00:20:11.300
You can do it with other
Objective-C objects,

00:20:11.410 --> 00:20:13.440
but typically you will
want to use NSString.

00:20:13.440 --> 00:20:15.900
We'll show why later on.

00:20:15.900 --> 00:20:20.200
You can even specify the order of the
parameters in the formatted object.

00:20:20.200 --> 00:20:25.260
You use a % then a number indicating
the order of the parameter,

00:20:25.260 --> 00:20:28.280
the index of the parameter,
then the $ and @.

00:20:28.280 --> 00:20:31.080
These are one-based indices,
so you start with one,

00:20:31.080 --> 00:20:35.040
and this lets you specify the
order in a particular format.

00:20:35.090 --> 00:20:36.630
This is useful.

00:20:36.640 --> 00:20:39.220
Different languages order
the same elements of a

00:20:39.220 --> 00:20:40.920
sentence in a different way.

00:20:40.920 --> 00:20:43.840
If you know a Romance language,
something like Spanish or French,

00:20:43.840 --> 00:20:48.020
they will usually put adjectives,
for example, after the nouns they modify.

00:20:48.020 --> 00:20:50.440
English prefers to put them first.

00:20:50.440 --> 00:20:54.750
So you need to be able to control the
order of words in a sentence so that

00:20:54.880 --> 00:20:56.560
you can do localization properly.

00:20:58.510 --> 00:21:00.600
Now, let's do a couple of
examples here quickly.

00:21:00.600 --> 00:21:02.080
Let's start out with a very easy one.

00:21:02.080 --> 00:21:05.640
We have an NSString that
we want to create,

00:21:05.640 --> 00:21:09.840
and we hand in a template
to string with format.

00:21:09.960 --> 00:21:13.670
It takes one Objective-C object,
follows it with world.

00:21:13.950 --> 00:21:18.020
We hand in an NSString greetings
as a parameter,

00:21:18.020 --> 00:21:20.600
and we get greetings world.

00:21:20.920 --> 00:21:22.830
Now we try it again with two parameters.

00:21:22.910 --> 00:21:24.400
This time we want to control the order.

00:21:24.400 --> 00:21:27.640
So we have in our first instance,
the first parameter comes

00:21:27.650 --> 00:21:28.700
first in the sentence.

00:21:28.700 --> 00:21:30.200
The second parameter comes second.

00:21:30.200 --> 00:21:35.740
We hand in hello and
world as our parameters.

00:21:35.740 --> 00:21:35.740
And we get out hello world.

00:21:36.000 --> 00:21:37.620
Do the same thing with the order switch.

00:21:37.670 --> 00:21:40.960
In the last example,
we have the second parameter coming first

00:21:40.960 --> 00:21:43.770
and the first parameter coming second.

00:21:43.920 --> 00:21:48.120
Again, we hand in "hello" and "world,"
and instead of getting "hello

00:21:48.120 --> 00:21:51.030
world," we get "world hello."

00:21:51.310 --> 00:21:56.120
Now, you may have noticed something
about this third example.

00:21:56.220 --> 00:21:59.880
I cheated with regards
to the capitalization.

00:21:59.920 --> 00:22:01.960
I knew in advance which one
was going to come first,

00:22:01.960 --> 00:22:04.120
and so I capitalized appropriately.

00:22:04.290 --> 00:22:07.000
That's not going to
happen most of the time.

00:22:07.590 --> 00:22:11.100
To deal with that, in similar situations,
there is a rich array of functions

00:22:11.100 --> 00:22:14.000
that are available for NSString that
you can use to manipulate a

00:22:14.000 --> 00:22:15.690
string once you've created it.

00:22:15.800 --> 00:22:18.200
There is, for example,
there are a number of casing messages

00:22:18.200 --> 00:22:21.730
you can send an NSString object,
uppercase string, lowercase string,

00:22:21.790 --> 00:22:23.020
capitalized string.

00:22:23.020 --> 00:22:24.960
Typically,
you would use capitalized string

00:22:24.960 --> 00:22:26.450
in a case like the one we just saw.

00:22:26.450 --> 00:22:30.220
There is precomposed string
with compatibility mapping.

00:22:30.220 --> 00:22:33.930
This is one of a number of functions
that lets you convert to a particular

00:22:34.150 --> 00:22:37.260
Unicode normalization form,
in this case, NFKC.

00:22:37.500 --> 00:22:39.620
Is equal to string.

00:22:39.620 --> 00:22:41.360
You can compare strings.

00:22:41.360 --> 00:22:42.520
This is the simplest way to do it.

00:22:42.590 --> 00:22:45.000
There are variations on this
that give you more control.

00:22:45.000 --> 00:22:48.490
You can also find out the
relative order of two strings.

00:22:48.510 --> 00:22:51.450
If you need a substring,
substring with range, hand in a range.

00:22:51.460 --> 00:22:55.100
Now, if you're dealing with substrings,
remember, you have to be worried about

00:22:55.100 --> 00:22:56.500
graphing cluster boundaries.

00:22:56.500 --> 00:22:58.400
And so to do that,
we have some functions.

00:22:58.400 --> 00:23:02.950
We have range of composed characters,
sequence at index, hand in the index.

00:23:03.010 --> 00:23:06.950
You get back the range of the
graphing cluster that contains it.

00:23:07.170 --> 00:23:09.940
And similarly, with a range,
you can extend its boundaries so that

00:23:09.950 --> 00:23:11.960
they match graphing cluster boundaries.

00:23:11.970 --> 00:23:16.290
So these are the functions you use
to deal with graphing clusters.

00:23:16.990 --> 00:23:19.580
Now, all of this is no good if you
can't localize what you're

00:23:19.580 --> 00:23:21.700
going to display to the user.

00:23:21.780 --> 00:23:26.370
The way we do this on Mac OS is we
have what are called .strings files.

00:23:26.710 --> 00:23:30.290
And you can use a number of
different encodings for these.

00:23:30.480 --> 00:23:32.330
We strongly recommend UTF-16.

00:23:32.370 --> 00:23:34.690
In fact,
forget that you can do other encodings.

00:23:34.790 --> 00:23:37.430
Just use UTF-16.

00:23:37.610 --> 00:23:40.000
You can have problems otherwise.

00:23:40.150 --> 00:23:42.600
And these are simply plain text files.

00:23:42.690 --> 00:23:46.050
Each line, you have a key and a value.

00:23:46.520 --> 00:23:49.740
And you use different functions
then to access the data in them.

00:23:49.740 --> 00:23:57.370
The two most common will
be NSLocalizedString or the

00:23:57.370 --> 00:23:57.370
second most common will be
NSLocalizedStringWithTable.

00:23:57.870 --> 00:23:58.960
or maybe it's the other way around.

00:23:58.960 --> 00:23:59.400
I'm not sure.

00:23:59.400 --> 00:24:01.000
I haven't checked.

00:24:01.120 --> 00:24:02.680
But probably use one or the other.

00:24:02.740 --> 00:24:05.240
In both cases, you hand in a key,
the key that you want the

00:24:05.240 --> 00:24:07.200
value corresponding to.

00:24:07.370 --> 00:24:10.520
And when it's called,
the system will look through

00:24:10.520 --> 00:24:15.220
the localizations available,
find the best match, and return the value

00:24:15.410 --> 00:24:17.200
that corresponds to that.

00:24:17.200 --> 00:24:21.370
Now, both of these also take a
localization hint as a parameter.

00:24:21.550 --> 00:24:25.200
This is useful because of a
handy little tool we include on

00:24:25.220 --> 00:24:26.400
the system called GenStrings.

00:24:26.710 --> 00:24:30.410
GenStrings is a tool that you
run over your source files.

00:24:30.520 --> 00:24:35.120
It looks inside them for calls to
NSLocalizedString and NSLocalizedString

00:24:35.120 --> 00:24:38.030
with table and their variants,
and it creates the

00:24:38.320 --> 00:24:40.480
.strings files for you.

00:24:40.580 --> 00:24:42.500
Now, typically,
you don't need to hand in any command

00:24:42.500 --> 00:24:46.760
line arguments because it will usually
do exactly what you want to do.

00:24:46.920 --> 00:24:49.820
And those localization hints
that you included in your code,

00:24:49.980 --> 00:24:54.830
well, they show up as comments that
are read by the localizer.

00:24:54.930 --> 00:24:56.630
Let's look at an example here.

00:24:56.790 --> 00:25:00.630
So source code, mountains.m,
inside there I'm creating

00:25:00.630 --> 00:25:01.930
an NSString object.

00:25:02.000 --> 00:25:04.980
I'm using NSLocalizedString from table.

00:25:05.080 --> 00:25:07.530
The key I'm going to look for is
something called tallmountain.

00:25:07.700 --> 00:25:13.620
The table I'll be looking inside
is called mountains.strings.

00:25:13.830 --> 00:25:18.620
And the localization hint is name of
the tallest mountain in the world.

00:25:18.690 --> 00:25:19.700
OK, I look in my directory.

00:25:19.700 --> 00:25:21.520
There's no .strings file.

00:25:21.710 --> 00:25:24.190
I run genstrings over my source code,
and there it is,

00:25:24.310 --> 00:25:24.780
mountains.mountain.mountain.

00:25:24.780 --> 00:25:25.560
.strings.

00:25:25.560 --> 00:25:27.560
It's been created for me.

00:25:27.590 --> 00:25:29.420
I open it up with my
favorite text editor,

00:25:29.420 --> 00:25:33.760
and what I see is my
localization hint as a comment,

00:25:33.940 --> 00:25:38.100
my key,
and then a dummy value for the value.

00:25:38.130 --> 00:25:41.920
OK, now this I give to my localizers.

00:25:42.140 --> 00:25:44.580
My English localizer,
who probably has the

00:25:44.600 --> 00:25:47.110
cubicle next to mine,
hand it to him.

00:25:47.490 --> 00:25:48.400
He reads it, opens it.

00:25:48.400 --> 00:25:50.000
Name of the tallest
mountain in the world.

00:25:50.000 --> 00:25:53.390
Okay, the value for that key
has to be Mount Everest.

00:25:53.750 --> 00:25:57.650
sent it off to New Delhi to
my Hindi localizer.

00:25:57.770 --> 00:26:00.600
She opens it up in her text editor,
sees name of the tallest

00:26:00.640 --> 00:26:02.500
mountain in the world,
and for the value,

00:26:02.500 --> 00:26:05.900
she puts in however you
say Mount Everest in Hindi,

00:26:05.900 --> 00:26:07.030
which I cannot pronounce.

00:26:07.030 --> 00:26:07.810
I'm sorry to say.

00:26:07.810 --> 00:26:10.300
I don't need to.

00:26:10.390 --> 00:26:12.300
The localization is there for me.

00:26:12.560 --> 00:26:14.060
This is how you localize text.

00:26:14.060 --> 00:26:15.170
You use .strings files.

00:26:15.250 --> 00:26:19.250
Put every string that you're going
to show to the user in one of these,

00:26:19.320 --> 00:26:22.230
have a key for it,
and then use the functions that

00:26:22.230 --> 00:26:24.300
access the value for the key.

00:26:24.440 --> 00:26:25.700
That's strings.

00:26:25.840 --> 00:26:27.220
That was the hard bit.

00:26:28.030 --> 00:26:31.220
Now we're going to go on to bundles.

00:26:31.220 --> 00:26:31.220
Bundles are easy.

00:26:32.170 --> 00:26:35.340
Bundles are special folders,
and that's really all they are.

00:26:35.570 --> 00:26:38.330
They have a certain
structure that is used.

00:26:38.410 --> 00:26:41.030
They have identifiers,
which can be handy.

00:26:41.150 --> 00:26:45.460
Most of the time, the user will see them
as a single object.

00:26:46.170 --> 00:26:48.550
And in particular,
for internationalization,

00:26:48.560 --> 00:26:51.850
inside a bundle, inside the bundles that
we'll be dealing with,

00:26:52.020 --> 00:26:54.190
is a subfolder called resources.

00:26:54.290 --> 00:26:59.180
And inside those are subfolders
whose names end in L,

00:26:59.340 --> 00:27:00.340
language project.

00:27:00.340 --> 00:27:02.520
That's where the localizations live.

00:27:02.580 --> 00:27:03.620
What are bundles?

00:27:03.790 --> 00:27:05.150
Applications are bundles.

00:27:05.150 --> 00:27:07.600
They're folders with a certain structure.

00:27:07.600 --> 00:27:08.750
Frameworks are bundles.

00:27:08.750 --> 00:27:10.680
They're folders with a certain structure.

00:27:10.680 --> 00:27:12.830
Both of these can contain localizations.

00:27:14.090 --> 00:27:18.020
Another thing which you will
usually see as a bundle is a nib.

00:27:18.050 --> 00:27:21.700
Nib files are where
your UI elements live.

00:27:21.750 --> 00:27:26.150
And they contain your windows,
they contain your menus,

00:27:26.160 --> 00:27:26.900
things like that.

00:27:26.900 --> 00:27:30.060
You create them and edit
them with Interface Builder.

00:27:30.060 --> 00:27:33.200
Now, in Leopard,
we've introduced a ZIB format,

00:27:33.200 --> 00:27:36.900
which is an XML format that can
contain the contents of a nib.

00:27:36.900 --> 00:27:39.720
These play nicer with most
source control systems.

00:27:39.720 --> 00:27:43.500
But in the past,
these have always been bundles, nib.

00:27:46.300 --> 00:27:48.620
So how do we represent them on Mac OS?

00:27:48.790 --> 00:27:50.760
Well, we use the NSBundle class.

00:27:50.760 --> 00:27:52.640
This is the basic class.

00:27:52.670 --> 00:27:55.520
Be aware,
NSBundle is not toll-free bridged

00:27:55.520 --> 00:27:57.380
with its core foundation counterpart.

00:27:57.430 --> 00:28:01.020
This is the one place where you have
to be aware where you're getting

00:28:01.140 --> 00:28:05.070
the bundle from and what functions
you need to use to manipulate it.

00:28:05.240 --> 00:28:08.380
Again, here we're focusing on Cocoa,
so we'll be looking at NSBundle.

00:28:08.380 --> 00:28:11.660
The same functionality is available
pretty much for CFBundleRef.

00:28:11.910 --> 00:28:14.310
You just access it slightly differently.

00:28:14.320 --> 00:28:16.090
How do you get them?

00:28:16.090 --> 00:28:19.380
There are three main ways you will
probably get a bundle when you need it.

00:28:19.380 --> 00:28:21.770
The easiest is to call mainBundle.

00:28:22.040 --> 00:28:25.230
Hand this off to the NSBundle class,
and you get back the bundle that

00:28:25.290 --> 00:28:28.430
corresponds to the application
which is currently running,

00:28:28.430 --> 00:28:30.430
which is probably going to be you.

00:28:31.180 --> 00:28:33.680
Now, if you're a framework,
that doesn't do you any good.

00:28:33.680 --> 00:28:38.180
If you want to get some data
inside yourself as a framework,

00:28:38.250 --> 00:28:40.140
you can't use mainBundle.

00:28:40.140 --> 00:28:43.900
That will give you the bundle for
the application that's using you,

00:28:44.100 --> 00:28:44.540
not you.

00:28:44.570 --> 00:28:47.040
So you call bundleWithIdentifier.

00:28:47.040 --> 00:28:48.470
You know what your identifier is.

00:28:48.550 --> 00:28:50.300
I hope you know what your identifier is.

00:28:50.330 --> 00:28:52.710
And that way, you get inside yourself.

00:28:52.770 --> 00:28:57.470
Or, if you're an application and you want
to get inside a frameworks bundle,

00:28:57.470 --> 00:29:00.470
which will not happen very often,
but when it does,

00:29:00.500 --> 00:29:01.160
you will typically get a bundle.

00:29:01.160 --> 00:29:04.100
You will typically know a class
which is defined by that framework,

00:29:04.290 --> 00:29:06.660
and you simply call bundleForClass,
given the class.

00:29:06.820 --> 00:29:09.610
And you get the correct bundle back.

00:29:10.550 --> 00:29:12.950
You're not going to use
bundles a lot directly.

00:29:12.960 --> 00:29:15.940
Most of this is taken care
of for you by the system.

00:29:16.000 --> 00:29:19.820
If you do need to use bundles,
it will probably be because you need to

00:29:19.820 --> 00:29:24.360
get some sort of a resource file of a
type which isn't defined by the system.

00:29:24.410 --> 00:29:25.450
It isn't a nib.

00:29:25.530 --> 00:29:26.700
It isn't an image.

00:29:26.700 --> 00:29:27.680
It isn't a string.

00:29:28.320 --> 00:29:31.790
For that kind of data,
you will use the function

00:29:31.790 --> 00:29:33.930
path for resource of type.

00:29:33.980 --> 00:29:37.660
You hand in the name of the file,
you hand in its extension,

00:29:37.660 --> 00:29:42.940
and you get back a path to the properly
localized version of that file.

00:29:42.940 --> 00:29:48.730
There are different variants of this,
and you can use the

00:29:49.180 --> 00:29:51.100
But this is the one that you
will most often be using.

00:29:51.100 --> 00:29:52.230
Okay, that was bundles.

00:29:52.280 --> 00:29:53.790
They are also easy.

00:29:53.940 --> 00:29:55.880
Let's look at locales.

00:29:58.430 --> 00:29:59.890
What is a locale?

00:29:59.890 --> 00:30:05.970
Well, a locale is an object that
corresponds to a particular place.

00:30:06.490 --> 00:30:07.730
Places can be big.

00:30:07.840 --> 00:30:12.600
They can be entire countries: Russia,
China, Canada.

00:30:12.700 --> 00:30:20.150
They can be small: Wales, Liechtenstein,
my bedroom.

00:30:20.320 --> 00:30:23.300
Most often, they are not just a place,
they are a combination of

00:30:23.300 --> 00:30:24.270
a place and a language.

00:30:24.300 --> 00:30:28.730
This makes it possible to have one
locale for Welsh-speaking Wales and

00:30:28.740 --> 00:30:32.360
another for English-speaking Wales,
or French-speaking Canada and

00:30:32.380 --> 00:30:34.270
English-speaking Canada.

00:30:34.460 --> 00:30:41.590
defines a default set of
values and way of doing things.

00:30:41.590 --> 00:30:41.590
Date and time formats.

00:30:41.600 --> 00:30:43.160
What the local currency is.

00:30:43.190 --> 00:30:45.660
What units of measurements
are being used.

00:30:45.660 --> 00:30:47.340
What calendar is being used.

00:30:47.340 --> 00:30:49.250
This is all found inside a locale.

00:30:49.260 --> 00:30:52.370
The values that we supply on
Mac OS come from what is called

00:30:52.370 --> 00:30:55.840
the Common Locale Data Repository,
which has data on literally

00:30:55.840 --> 00:30:57.140
hundreds of locales.

00:30:57.140 --> 00:31:00.760
It's a massive open source project
in which Apple participates.

00:31:00.780 --> 00:31:02.860
Of course, you don't have to use these.

00:31:03.140 --> 00:31:06.500
You can override them yourself
if you want to live dangerously,

00:31:06.500 --> 00:31:11.580
or you can let the user override them if
you want to live rather less dangerously.

00:31:11.600 --> 00:31:12.700
Okay.

00:31:13.770 --> 00:31:16.040
Locales are not user preferences.

00:31:16.160 --> 00:31:17.120
They kind of are.

00:31:17.390 --> 00:31:20.700
They tell you how the
user wants to do things.

00:31:20.780 --> 00:31:24.490
But the main thing you need to be
aware of is a locale is kind of

00:31:24.580 --> 00:31:28.800
a preference that is common to an
entire place and which is accessed

00:31:29.310 --> 00:31:33.980
through not the preference mechanism
but through the locale mechanism.

00:31:34.920 --> 00:31:36.750
Similarly, locales are not localizations.

00:31:36.750 --> 00:31:38.500
Now, they contain localized data.

00:31:38.500 --> 00:31:41.160
They contain data that
changes from place to place.

00:31:41.300 --> 00:31:44.640
But what you need to think of as a
localization is what is unique to your

00:31:44.790 --> 00:31:47.320
program that varies from place to place.

00:31:47.510 --> 00:31:53.890
Your menus, your windows, your panels,
things like that.

00:31:53.890 --> 00:31:53.890
That's where the localization is.

00:31:54.250 --> 00:32:04.690
: Locales do contain localized data,
but it's not the same

00:32:04.690 --> 00:32:04.690
thing as your localization.

00:32:05.730 --> 00:32:07.600
Here's how you set them.

00:32:07.640 --> 00:32:11.500
On the Mac, you set locales,
you set place and language separately.

00:32:11.500 --> 00:32:15.370
To set the place,
you go to your international

00:32:15.450 --> 00:32:17.370
preferences panel.

00:32:17.370 --> 00:32:17.370
You go to the

00:32:19.150 --> 00:32:20.910
formats tab.

00:32:21.020 --> 00:32:25.560
I've set it to the United Kingdom.

00:32:25.560 --> 00:32:28.490
I'm formatting dates the British way.

00:32:28.490 --> 00:32:32.750
I'm using the British pound sterling.

00:32:32.750 --> 00:32:33.750
I'm on the metric system.

00:32:33.760 --> 00:32:35.100
I'm using the Gregorian calendar.

00:32:35.100 --> 00:32:37.360
All of this is set for me all at once.

00:32:37.360 --> 00:32:41.840
If I want to set the language,
I again go to international preferences.

00:32:41.840 --> 00:32:45.330
This time I look at the languages pane,
and here I have a list of languages.

00:32:45.370 --> 00:32:47.230
It's important to be aware of this.

00:32:47.360 --> 00:32:51.360
This is the order in which the user
would like to see localizations.

00:32:51.360 --> 00:32:56.200
Now, here they're saying I want to see
the English localization first.

00:32:56.200 --> 00:32:58.350
If you have one, show it to me.

00:32:58.480 --> 00:33:00.920
That's not going to be a terribly
useful list in this case because

00:33:00.920 --> 00:33:03.360
almost everything is going
to be localized to English.

00:33:03.800 --> 00:33:06.100
Here's another example.

00:33:06.280 --> 00:33:10.840
This is what you might see on a system
of somebody who's native Chinese.

00:33:10.920 --> 00:33:13.740
They prefer traditional Chinese,
but they can read simplified Chinese.

00:33:13.830 --> 00:33:16.640
They can manage Japanese and
even a little French.

00:33:16.780 --> 00:33:18.870
So if you have a traditional
Chinese localization,

00:33:18.900 --> 00:33:19.850
that's what they want.

00:33:20.070 --> 00:33:22.010
If you don't have one,
then they'd like to

00:33:22.020 --> 00:33:23.070
see simplified Chinese.

00:33:23.130 --> 00:33:26.240
If you don't have either of those,
they'll live with Japanese.

00:33:26.300 --> 00:33:30.270
And if you don't have any of those,
French is OK.

00:33:30.400 --> 00:33:35.030
And if you don't have French, OK,
I'll live with English.

00:33:35.110 --> 00:33:35.760
And that's how it works.

00:33:35.950 --> 00:33:39.130
This is how the system decides
which localization to show the user,

00:33:39.130 --> 00:33:40.820
if not all of them are available.

00:33:40.890 --> 00:33:44.260
So a localization,
this is an LPROJ folder that

00:33:44.260 --> 00:33:49.160
lives inside your application
bundle or your frameworks bundle.

00:33:49.160 --> 00:33:52.310
That's where your localization data,
localized data lives,

00:33:52.350 --> 00:33:55.410
your localized nibs,
your localized .strings files.

00:33:55.420 --> 00:33:58.330
The functions look inside
the various LPROJ folders,

00:33:58.340 --> 00:34:00.680
which are available in a certain order.

00:34:00.680 --> 00:34:02.220
That order is defined by the user.

00:34:02.220 --> 00:34:05.720
And when they find something acceptable,
then that's what they show to the user.

00:34:07.080 --> 00:34:11.780
The Lproj folders are named for the
language or the dialect that they cover.

00:34:11.990 --> 00:34:16.240
For this, we use a protocol,
best common practices 47,

00:34:16.240 --> 00:34:19.850
which is a way of defining in a
standard way locale identifiers

00:34:19.880 --> 00:34:21.610
and language identifiers.

00:34:21.640 --> 00:34:23.510
Here's an example.

00:34:23.580 --> 00:34:25.660
We're looking inside
an application bundle.

00:34:25.660 --> 00:34:27.090
Here's our contents.

00:34:27.110 --> 00:34:30.880
We have our resources subfolder,
and we have a number of

00:34:30.880 --> 00:34:33.220
different localizations here.

00:34:33.840 --> 00:34:36.920
We have EN-DSRT,
that's English with a Deseret alphabet,

00:34:36.920 --> 00:34:40.060
and then regular English,
and then French and Japanese and

00:34:40.060 --> 00:34:42.180
Russian and traditional Chinese.

00:34:42.180 --> 00:34:46.530
You'll notice my icon isn't localized,
so it's not inside an Lproj folder,

00:34:46.550 --> 00:34:48.190
but everything else is.

00:34:48.200 --> 00:34:51.380
Now, I include Deseret alphabet
not just to be cute.

00:34:53.110 --> 00:34:56.740
There's a really important point
you need to be aware of here.

00:34:56.880 --> 00:35:01.710
You, as an application developer,
and your users,

00:35:01.710 --> 00:35:07.780
are not limited to a predefined
set of localizations by Apple.

00:35:08.110 --> 00:35:12.930
If for some reason your users do in fact
want a Deseret Alphabet localization,

00:35:12.930 --> 00:35:17.840
you can provide it and they can use it,
and nothing has to be done to the system.

00:35:17.930 --> 00:35:19.880
Now,
Deseret Alphabet is not terribly likely.

00:35:19.880 --> 00:35:21.900
There are some other
languages that are likely.

00:35:21.900 --> 00:35:22.800
Thai, for example.

00:35:22.890 --> 00:35:26.820
We may not localize everything to Thai,
but a Thai locale can be provided,

00:35:26.820 --> 00:35:28.180
a Thai localization.

00:35:28.180 --> 00:35:32.740
So you are not limited by us
to a certain set of locales.

00:35:33.840 --> 00:35:34.840
Localization tools.

00:35:34.840 --> 00:35:38.290
There are a couple of things that
you can do to create localizations.

00:35:38.290 --> 00:35:39.830
You can hand edit them.

00:35:39.880 --> 00:35:44.120
You can hand edit the nibs and strings
yourself if you really want to.

00:35:44.150 --> 00:35:47.720
Big problem here is you may end
up with inconsistent translations.

00:35:47.720 --> 00:35:51.700
Two different translators will translate
the same thing two different ways.

00:35:51.780 --> 00:35:53.870
There are tools that help
simplify this process.

00:35:53.960 --> 00:35:56.300
Apple provides one called Apple Glot.

00:35:56.440 --> 00:35:58.900
There's also a third-party tool,
iLocalize.

00:35:58.970 --> 00:36:01.200
Both of these use glossaries
provided by Apple,

00:36:01.200 --> 00:36:04.080
which is basically a set of
the translations that we use.

00:36:04.080 --> 00:36:10.190
And you can take advantage of these
to get consistent translations.

00:36:11.340 --> 00:36:12.600
How do we represent locales?

00:36:12.600 --> 00:36:15.200
Well, we use the NSLocale class.

00:36:15.200 --> 00:36:19.180
This is the core class to
represent a locale object.

00:36:19.340 --> 00:36:23.580
It's toll-free bridged, again,
with its core foundation counterpart,

00:36:23.580 --> 00:36:24.700
NSLocaleRef.

00:36:25.500 --> 00:36:28.840
Which is, again, very handy,
but we'll be focusing on NSLocale.

00:36:28.840 --> 00:36:30.580
How do I create one?

00:36:30.600 --> 00:36:33.710
Well,

00:36:34.100 --> 00:36:37.180
The easiest way is to use current locale.

00:36:37.280 --> 00:36:42.340
That gives me the current locale,
kind of.

00:36:42.440 --> 00:36:47.050
It gives me whatever locale
was set when I was launched.

00:36:47.850 --> 00:36:50.290
Now, you may want to be a little
more responsive than that.

00:36:50.320 --> 00:36:53.210
You may want to actually,
if the user changes the

00:36:53.220 --> 00:36:56.400
locale while you're running,
you may want to reflect

00:36:56.400 --> 00:36:57.800
that back to them.

00:36:57.940 --> 00:37:00.290
And so in Leopard,
we've added a new function,

00:37:00.290 --> 00:37:02.220
auto-updating current locale.

00:37:02.220 --> 00:37:07.510
This gives you the actual, right now,
up-to-the-date current locale.

00:37:08.600 --> 00:37:11.370
If you're going to be responding
to when the locale changes,

00:37:11.370 --> 00:37:14.000
you need to be able to find
out when the locale changes.

00:37:14.010 --> 00:37:16.910
And so we have a new notification
you can take advantage of.

00:37:17.070 --> 00:37:20.590
NSCurrentLocale did change notification.

00:37:21.320 --> 00:37:25.200
If you react to this,
then you will find out when the

00:37:25.420 --> 00:37:30.300
locale has changed and you can
update things appropriately.

00:37:30.380 --> 00:37:32.790
And finally,
there's NSLocaleWithIdentifier.

00:37:32.800 --> 00:37:36.800
I mentioned there's a standard
way of giving locales identifiers.

00:37:36.970 --> 00:37:43.210
This lets you put in an arbitrary locale
and hopefully get something useful back.

00:37:43.270 --> 00:37:46.160
You can get a list of the locales
that come with the system,

00:37:46.180 --> 00:37:49.310
or you can create your own on
the fly if you really want to.

00:37:49.320 --> 00:37:51.710
So here I have an example.

00:37:51.830 --> 00:37:56.400
EN, English language, hyphen DSRT,
written with the Deseret alphabet,

00:37:56.400 --> 00:38:00.420
underscore US,
reflecting American practices,

00:38:00.420 --> 00:38:05.020
at calendar equals Japanese,
using the Japanese calendar instead

00:38:05.020 --> 00:38:07.140
of whatever the default was.

00:38:07.140 --> 00:38:11.940
I really doubt you will ever in
your life encounter this locale.

00:38:13.190 --> 00:38:15.510
for the record I have.

00:38:15.680 --> 00:38:16.550
It exists.

00:38:16.590 --> 00:38:18.020
You can define it.

00:38:18.020 --> 00:38:19.790
Your user can define it.

00:38:19.940 --> 00:38:22.920
If this is what they want,
this can be provided to them.

00:38:24.700 --> 00:38:26.520
What can you get from a locale?

00:38:26.600 --> 00:38:28.670
All kinds of stuff.

00:38:28.760 --> 00:38:30.270
What currency is set?

00:38:30.280 --> 00:38:34.320
What measurement system is being used?

00:38:34.670 --> 00:38:35.990
Where are you?

00:38:36.290 --> 00:38:37.360
So here we have an example.

00:38:37.360 --> 00:38:41.200
We get our locale,
auto-updating current locale.

00:38:41.350 --> 00:38:44.500
Find out the currency,
or in this case the currency code,

00:38:44.520 --> 00:38:46.180
NSLocale currency code.

00:38:46.180 --> 00:38:47.820
Hand that off to object for key.

00:38:47.820 --> 00:38:49.700
We find out what the currency code is.

00:38:49.820 --> 00:38:50.670
This is a string.

00:38:50.690 --> 00:38:53.200
We want to know if we're using
the metric system or not.

00:38:53.200 --> 00:38:55.700
NSLocale uses metric system.

00:38:55.700 --> 00:38:59.620
This gives us back an NSNumber,
which we interpret as a Boolean.

00:39:00.610 --> 00:39:02.060
Right off we know.

00:39:02.170 --> 00:39:07.460
Now, suppose I want to show the user the
name of the country where they are.

00:39:07.610 --> 00:39:10.800
Suppose somehow they
have forgotten this fact.

00:39:10.990 --> 00:39:12.440
Easy to do.

00:39:12.590 --> 00:39:15.940
First, I get the identifier,
the ID for the country,

00:39:15.940 --> 00:39:17.730
the standard country code.

00:39:17.850 --> 00:39:21.500
I have my locale, say object for key,
NSLocale country code,

00:39:21.500 --> 00:39:23.150
and I get back something like US.

00:39:23.160 --> 00:39:24.260
Now, this is an ID.

00:39:24.260 --> 00:39:26.390
This is not a user-visible string.

00:39:26.390 --> 00:39:30.940
NSLocale can hand you the proper
string for the user to see.

00:39:30.940 --> 00:39:34.280
Here we use a function,
display name for key.

00:39:34.280 --> 00:39:35.340
We have our locale.

00:39:35.340 --> 00:39:36.740
It's the current locale.

00:39:36.740 --> 00:39:39.260
We say, okay,
I want a country code converted

00:39:39.260 --> 00:39:40.860
to a user-visible string.

00:39:40.900 --> 00:39:44.830
And the country code in particular is US,
and it hands me back the

00:39:44.830 --> 00:39:46.480
string United States.

00:39:46.480 --> 00:39:50.410
So this lets you see the
proper localization for a

00:39:50.860 --> 00:39:52.780
particular piece of data.

00:39:56.120 --> 00:40:01.310
NSL CalObjects do not, however,
let you know

00:40:01.950 --> 00:40:02.900
is a localizer.

00:40:02.900 --> 00:40:07.340
He knows what the user's list
of preferred languages is.

00:40:07.340 --> 00:40:11.000
Fortunately, that is also easy to get.

00:40:11.000 --> 00:40:17.380
This is new in Leopard.

00:40:17.380 --> 00:40:17.380
You can give the NSLocale class,
not objects, but the class.

00:40:17.740 --> 00:40:19.440
hand off the message preferred languages.

00:40:19.440 --> 00:40:21.600
This gives you an array back.

00:40:21.780 --> 00:40:23.840
The array consists of NSStrings.

00:40:23.840 --> 00:40:30.400
These NSStrings are the proper
IDs for the languages in order.

00:40:30.620 --> 00:40:37.420
So we have here ZH-HANT,
traditional Chinese, followed by ZH-HANS,

00:40:37.760 --> 00:40:40.240
simplified Chinese, Japanese, French,
English, Russian,

00:40:40.240 --> 00:40:42.230
and so on down the line.

00:40:42.910 --> 00:40:44.960
This has been available for a long time.

00:40:44.960 --> 00:40:47.570
In the past, you got that through the
preferences mechanism,

00:40:47.710 --> 00:40:50.120
and it was clumsy and difficult,
and now it's much easier in

00:40:50.120 --> 00:40:52.160
case you need to have it.

00:40:52.270 --> 00:40:54.710
Usually, of course,
what you want to know is what the

00:40:54.710 --> 00:40:57.750
user has set to the current language,
so you get this array.

00:40:57.750 --> 00:40:59.880
Just look at the first element.

00:41:00.930 --> 00:41:03.040
When do you use locales?

00:41:03.190 --> 00:41:09.800
Well, more likely than not,
you will never need to use an NSLocale.

00:41:09.870 --> 00:41:13.300
Because the resource accessing
functions do the right thing for you.

00:41:13.420 --> 00:41:16.200
They are aware of what the current
locale is and they will give you back

00:41:16.200 --> 00:41:18.050
the correct localization based on that.

00:41:18.100 --> 00:41:25.040
Now, if you allow the user to override
whatever is set in System Preferences,

00:41:25.180 --> 00:41:28.350
your calendar application,
and you let the user set the

00:41:28.350 --> 00:41:33.440
calendar inside your application,
say, or something like that, okay,

00:41:33.440 --> 00:41:36.410
then you can create your
own locale and use it.

00:41:36.500 --> 00:41:38.300
You need to explicitly use the locale.

00:41:38.300 --> 00:41:42.360
Or if you want to show
data from multiple locales,

00:41:42.360 --> 00:41:46.110
multiple localizations, again,
this is a case where you would actually

00:41:46.110 --> 00:41:48.040
create and use an NSLocale option.

00:41:48.100 --> 00:41:49.430
project.

00:41:50.210 --> 00:41:51.100
All right.

00:41:51.180 --> 00:41:56.440
That's the basics of how to localize,
how to internationalize on Mac OS.

00:41:56.570 --> 00:42:01.170
Let's see some examples that
show how it actually works.

00:42:01.420 --> 00:42:06.200
So, first we want to get a localized nib,
and we want to get a localized data file,

00:42:06.200 --> 00:42:10.770
and finally we want to get
a localized string nib.

00:42:12.030 --> 00:42:14.240
Okay, remember,
nibs are where UI elements live.

00:42:14.240 --> 00:42:16.260
This provides you your menus,
things like that.

00:42:16.370 --> 00:42:18.300
All right,
I want my properly localized one.

00:42:18.300 --> 00:42:19.440
How do I do it?

00:42:19.620 --> 00:42:21.940
You probably have to do nothing.

00:42:22.150 --> 00:42:24.700
A lot of applications,
if basically all you're dealing

00:42:24.820 --> 00:42:27.420
with are nibs for your menus
and maybe your documents,

00:42:27.550 --> 00:42:29.550
well,
then everything is taken care of for you.

00:42:29.570 --> 00:42:32.830
When you're launched,
the correct localization is found,

00:42:32.830 --> 00:42:35.230
the correct nib is dealt
with in the system,

00:42:35.350 --> 00:42:38.100
and you just have to find
out when the nib is set up.

00:42:38.160 --> 00:42:39.240
You don't have to do any work.

00:42:40.290 --> 00:42:43.570
If you, however,
do something like have your own

00:42:43.870 --> 00:42:47.440
about box or you have a preferences
pane or something like that,

00:42:47.570 --> 00:42:49.000
well, okay, you need a nib for those.

00:42:49.020 --> 00:42:49.640
How do I do it?

00:42:49.670 --> 00:42:58.380
There's a function on NSBundle,
and it's loadNibNamed.

00:42:59.100 --> 00:43:03.780
You hand in the name of
the nib that you want.

00:43:04.020 --> 00:43:05.800
You hand in the object
that's going to own it.

00:43:05.800 --> 00:43:07.820
You're given back a Boolean
that lets you know whether or

00:43:07.820 --> 00:43:08.920
not it was found and loaded.

00:43:09.220 --> 00:43:11.500
And that's all the work you have to do.

00:43:11.500 --> 00:43:16.340
So finding the correct localization
is handled automatically for you.

00:43:16.760 --> 00:43:17.700
Now, what about a data file?

00:43:17.700 --> 00:43:20.200
Okay,
I have a data file inside my application.

00:43:20.200 --> 00:43:22.470
Oh, and it's localized.

00:43:22.580 --> 00:43:23.700
It varies from place to place.

00:43:23.700 --> 00:43:24.930
I want to make sure I get the right one.

00:43:24.930 --> 00:43:26.600
How do I do that?

00:43:26.750 --> 00:43:30.600
Well, again,
you use Path for Resource of Type.

00:43:30.710 --> 00:43:33.200
So, here's an example.

00:43:33.270 --> 00:43:34.420
I want my bundle.

00:43:34.420 --> 00:43:37.170
I'm an application, so I get my bundle.

00:43:37.740 --> 00:43:40.600
I'm looking for a file.

00:43:40.600 --> 00:43:42.390
The file name is Mountains.

00:43:42.560 --> 00:43:44.600
The file type is plist.

00:43:44.800 --> 00:43:46.590
Give me a path to it.

00:43:46.680 --> 00:43:48.000
Hand that off to the bundle.

00:43:48.110 --> 00:43:53.390
And you get the correct path for the
correct localization of that file.

00:43:53.610 --> 00:43:55.620
Maybe there is no localization at all.

00:43:55.680 --> 00:43:58.390
Maybe it's something
that isn't localized.

00:43:58.390 --> 00:43:58.390
That's okay.

00:43:58.890 --> 00:44:00.870
If there is a localization,
you're handled that.

00:44:00.930 --> 00:44:02.270
If there isn't one,
then you're handled that.

00:44:02.360 --> 00:44:03.950
Everything is taken care of for you.

00:44:04.110 --> 00:44:04.390
All right.

00:44:04.460 --> 00:44:07.500
Now, this is a P-list.

00:44:07.660 --> 00:44:10.600
P lists are handy because you
can put Objective C objects

00:44:10.600 --> 00:44:14.100
of them of certain types,
strings and numbers and so on.

00:44:14.250 --> 00:44:16.780
So here I have an array inside my P list.

00:44:16.850 --> 00:44:19.700
This is a file I created,
so I know what it is.

00:44:19.700 --> 00:44:23.100
So I just hand it off to NSArray,
array with contents of file,

00:44:23.100 --> 00:44:26.010
hand off the path I got,
and the correct localization

00:44:26.070 --> 00:44:29.150
for this data file is turned
into an array of objects.

00:44:29.400 --> 00:44:33.190
I can now step through the array
and do whatever it is I want to do.

00:44:33.370 --> 00:44:36.310
Last example,
we want to get a localized string.

00:44:36.310 --> 00:44:39.880
We're going to go through this
a bit more slowly because there

00:44:39.880 --> 00:44:41.650
are a couple of gotchas here.

00:44:41.770 --> 00:44:44.010
I'm going to show a string to the user.

00:44:44.010 --> 00:44:47.090
This string is going to
show them a mountain's name,

00:44:47.090 --> 00:44:49.710
how high it is,
and when it was first climbed.

00:44:49.910 --> 00:44:53.110
So there are three values
that I'm going to deal with.

00:44:53.110 --> 00:44:56.460
I presumably have a mountain
object that contains these.

00:44:56.600 --> 00:45:00.230
Now, user visible string,
that means I want it localized.

00:45:00.230 --> 00:45:03.260
So I start off by calling
NS localized string.

00:45:03.300 --> 00:45:08.750
I'm going to look for
a key sentence format.

00:45:08.960 --> 00:45:14.180
I'm going to look inside
mountains.strings to get the string.

00:45:14.180 --> 00:45:16.930
And I'm telling the localizer,
by the way, in case you need to know,

00:45:16.930 --> 00:45:17.890
this is a sentence.

00:45:17.890 --> 00:45:19.920
It has the mountain's name
as the first parameter,

00:45:20.080 --> 00:45:22.220
the height as the second parameter,
and the climb date as

00:45:22.220 --> 00:45:23.260
the third parameter.

00:45:23.490 --> 00:45:26.110
Notice that this is handy
not just for the localizer,

00:45:26.110 --> 00:45:29.210
but also for the programmer,
who probably forgot to comment

00:45:29.210 --> 00:45:30.680
their code here anyway.

00:45:30.760 --> 00:45:33.020
So there's your comment.

00:45:33.320 --> 00:45:33.580
Okay.

00:45:33.730 --> 00:45:35.200
I have my format.

00:45:35.200 --> 00:45:37.120
Now I want my localized name.

00:45:37.120 --> 00:45:38.050
Okay.

00:45:38.050 --> 00:45:40.760
I want a localized name.

00:45:40.760 --> 00:45:44.390
Now, this is assuming I'm using
just one table of mountains,

00:45:44.430 --> 00:45:46.190
and so I do need a localized name.

00:45:46.190 --> 00:45:48.800
So, again,
I call NSLocalizedString from table.

00:45:48.800 --> 00:45:50.070
I hand in the name of the mountain.

00:45:50.160 --> 00:45:52.340
I look inside names.strings.

00:45:52.340 --> 00:45:55.690
This time, it's not possible to have a
really useful localization hint.

00:45:55.700 --> 00:45:56.460
You could put one in.

00:45:56.460 --> 00:45:57.620
There's certainly no harm to it.

00:45:57.720 --> 00:45:58.940
In this case, we didn't.

00:45:58.940 --> 00:46:02.680
And you get back the correctly
localized name for the mountain.

00:46:04.160 --> 00:46:05.570
Equally easy.

00:46:05.760 --> 00:46:08.000
Here's where the gotchas come in.

00:46:08.110 --> 00:46:09.700
You have an NSNumber.

00:46:09.880 --> 00:46:13.890
You want to include it in a
formatted string that the user sees.

00:46:14.050 --> 00:46:17.160
String with format handles NSNumbers.

00:46:17.330 --> 00:46:20.000
You can hand it an NSNumber and
it will format for you.

00:46:20.120 --> 00:46:23.660
The temptation is going to be to do that.

00:46:23.660 --> 00:46:25.150
Don't do that.

00:46:25.840 --> 00:46:42.290
Numbers are formatted in different
ways in different parts of the world.

00:46:42.290 --> 00:46:42.290
French and English, yeah,
a Frenchman can live with the way

00:46:42.290 --> 00:46:42.290
English format numbers and vice versa.

00:46:42.290 --> 00:46:42.290
In fact, string with format doesn't
even put the commas in.

00:46:42.290 --> 00:46:42.290
There's no problem there, surely.

00:46:42.920 --> 00:46:47.840
Arabic countries do not use the
same set of numerals as the West.

00:46:47.960 --> 00:46:51.300
They will want to see the
Arabic numerals used instead of the

00:46:51.310 --> 00:46:53.760
Hindu Arabic numerals that we use.

00:46:53.900 --> 00:46:56.740
So you want a localized number.

00:46:56.850 --> 00:46:57.340
How do I do that?

00:46:57.340 --> 00:46:59.460
Well, I need a number formatter.

00:46:59.640 --> 00:47:02.140
Create it, initialize it.

00:47:02.180 --> 00:47:04.560
I tell it, okay,
this is going to be a decimal number.

00:47:04.640 --> 00:47:09.100
That means you use a decimal
point and a thousand separators,

00:47:09.100 --> 00:47:09.100
possibly.

00:47:09.520 --> 00:47:14.800
And then I just give it the number,
hand that off to string from number,

00:47:15.040 --> 00:47:18.290
and I get back a correctly
localized string.

00:47:18.800 --> 00:49:03.500
[Transcript missing]

00:49:04.190 --> 00:49:05.140
Okay.

00:49:05.190 --> 00:49:06.440
Here we go.

00:49:06.870 --> 00:49:09.800
Now, let's start off by looking a little
bit at our localization stuff.

00:49:09.800 --> 00:49:13.100
So let's go to System Preferences.

00:49:13.100 --> 00:49:15.100
International Preferences.

00:49:15.430 --> 00:49:19.180
We're set to the United States.

00:49:19.280 --> 00:49:22.400
We can live with this for the
moment if we really have to.

00:49:22.400 --> 00:49:24.390
Look at the number of regions available.

00:49:24.530 --> 00:49:27.550
That's not a terribly long list.

00:49:28.120 --> 00:49:34.330
Well, it happens that this is just
a list of the countries that

00:49:34.330 --> 00:49:34.330
have English locales defined.

00:49:34.560 --> 00:49:36.480
I must admit this is a really weird list.

00:49:36.600 --> 00:49:39.400
I would not have expected
Botswana and Belgium to have

00:49:39.400 --> 00:49:41.630
English locales defined for them,
but they do.

00:49:41.990 --> 00:49:44.340
So that data is there.

00:49:44.410 --> 00:49:48.080
If I want to see all the locales,
show all regions.

00:49:48.340 --> 00:49:51.720
This shows me all of the
places that we have data for.

00:49:51.770 --> 00:49:55.420
This is a much longer list.

00:49:56.520 --> 00:49:58.580
is grouped by language,
so it's easy to find

00:49:58.580 --> 00:49:59.820
what I'm looking for.

00:49:59.870 --> 00:50:04.330
Some places,
Afrikaans is only used in South Africa.

00:50:04.550 --> 00:50:07.760
Other places, Arabic is used in lots
of different countries.

00:50:07.760 --> 00:50:11.820
So in each of these cases,
you can have lots of different places

00:50:11.820 --> 00:50:14.260
that use a particular language.

00:50:14.260 --> 00:50:19.410
So there are lots and lots of different
places for which localization,

00:50:19.530 --> 00:50:21.480
localized data exists.

00:50:23.070 --> 00:50:24.650
All right.

00:50:24.750 --> 00:50:26.110
Let's switch back to
languages for the moment.

00:50:26.120 --> 00:50:26.330
All right.

00:50:26.430 --> 00:50:28.760
Now,
we're going to show off localization.

00:50:28.760 --> 00:50:32.440
So showing English first, well,
that's dull.

00:50:32.590 --> 00:50:35.990
Let's do French first,
which is far more interesting.

00:50:36.130 --> 00:50:40.980
And, okay,
let's leave things there for the moment.

00:50:41.880 --> 00:50:44.240
All right, here's our application.

00:50:44.400 --> 00:50:46.500
Launch it.

00:50:46.500 --> 00:50:52.290
And something has gone wrong.

00:50:52.290 --> 00:50:54.150
This isn't

00:50:55.460 --> 00:50:59.300
I tell you that because
you may not notice.

00:50:59.300 --> 00:51:00.380
What happened?

00:51:00.500 --> 00:51:03.140
Well, okay, let's look inside here.

00:51:03.250 --> 00:51:04.470
This is a bundle.

00:51:04.470 --> 00:51:05.750
It's a folder.

00:51:05.880 --> 00:51:07.340
Hold down control.

00:51:07.350 --> 00:51:09.920
Okay, show package contents.

00:51:10.510 --> 00:51:14.200
Okay, contents, resources.

00:51:14.230 --> 00:51:16.400
All right,
localizations that this application has,

00:51:16.400 --> 00:51:21.230
desert alphabet, English, Japanese,
Russian, traditional Chinese, no French.

00:51:21.380 --> 00:51:22.400
That's why we saw no French.

00:51:22.400 --> 00:51:24.400
There is no French localization.

00:51:24.400 --> 00:51:27.420
All right,
we'll deal with that problem in a minute.

00:51:28.070 --> 00:51:32.410
Now, let's look here.

00:51:32.410 --> 00:51:32.410
Actually, we do see some French.

00:51:33.040 --> 00:51:36.110
We've gotten as much French as the
system can provide in the absence

00:51:36.130 --> 00:51:37.500
of an actual French localization.

00:51:37.500 --> 00:51:39.500
The dates are French.

00:51:39.560 --> 00:51:41.950
That's been taken care of for me.

00:51:42.450 --> 00:51:43.830
Here we have a list of mountains.

00:51:43.930 --> 00:51:45.560
This is a fascinating list of mountains.

00:51:45.650 --> 00:51:47.300
We have some very tall mountains here.

00:51:47.300 --> 00:51:49.160
Mount Everest, K2, Annapurna.

00:51:49.290 --> 00:51:52.340
We have some very important
American mountains,

00:51:52.340 --> 00:51:55.350
Mount Whitney, Mount Shasta,
for the really patriotic

00:51:55.350 --> 00:51:56.220
Mount Washington.

00:51:56.320 --> 00:51:58.950
I have a couple of mountains that
I can see from my front porch,

00:51:58.950 --> 00:52:00.030
so they're there, too.

00:52:00.100 --> 00:52:00.860
That's fine.

00:52:00.860 --> 00:52:03.560
We have the date they were first climbed.

00:52:03.560 --> 00:52:06.150
I don't know when the Mount Olympus
in Salt Lake was first climbed,

00:52:06.260 --> 00:52:07.140
so I leave that blank.

00:52:07.140 --> 00:52:08.080
That's all right.

00:52:08.120 --> 00:52:09.780
I can sort everything.

00:52:09.780 --> 00:52:12.280
This is an NS table view,
so I can do that.

00:52:12.300 --> 00:52:13.270
I can do this very easily.

00:52:13.320 --> 00:52:15.040
Okay.

00:52:15.070 --> 00:52:18.220
Up at the top, I have a sentence about
whatever mountain is selected.

00:52:18.220 --> 00:52:20.300
I change the selection.

00:52:20.300 --> 00:52:21.420
That updates automatically.

00:52:21.420 --> 00:52:21.960
Okay.

00:52:21.960 --> 00:52:25.130
Now, I have a date and time picker.

00:52:25.130 --> 00:52:26.640
I did this just to be cute.

00:52:26.700 --> 00:52:27.850
I'll be honest.

00:52:27.880 --> 00:52:30.870
Simply because it's
doing the right thing.

00:52:30.870 --> 00:52:32.400
I had to do no work here.

00:52:32.410 --> 00:52:35.780
I simply put it in my application,
and it knows that the

00:52:35.920 --> 00:52:40.210
user wants to use French,
and so it gives them a French calendar.

00:52:41.500 --> 00:54:21.200
[Transcript missing]

00:54:21.780 --> 00:54:25.700
My application is aware of
when the locale changes.

00:54:25.700 --> 00:54:27.540
Here we go.

00:54:28.170 --> 00:54:31.350
Heights are now formatted the
way it's done in Luxembourg.

00:54:31.420 --> 00:54:34.270
To be honest,
this is not what I was expecting,

00:54:34.270 --> 00:54:36.190
because the French would
have left a space.

00:54:36.190 --> 00:54:39.370
People in Luxembourg prefer a period.

00:54:39.400 --> 00:54:43.670
I'm using the metric system now,
because I'm in Europe.

00:54:43.670 --> 00:54:46.700
The heights have switched to meters.

00:54:46.700 --> 00:54:49.130
The system won't change between
metric and English for you.

00:54:49.130 --> 00:54:49.700
I'm sorry.

00:54:49.700 --> 00:54:50.980
You do have to do that yourself.

00:54:51.830 --> 00:54:53.880
But at least you can find out
which you're supposed to use.

00:54:53.920 --> 00:54:58.140
Now, finally, down here,
in case you didn't notice,

00:54:58.170 --> 00:55:02.580
here I have a list of what locales
are available for this application,

00:55:02.580 --> 00:55:04.620
what localizations are available.

00:55:04.620 --> 00:55:06.960
English,
this is the English-English flag,

00:55:06.960 --> 00:55:08.700
as opposed to the British flag.

00:55:08.700 --> 00:55:11.420
Japanese, Russian,
and traditional Chinese.

00:55:11.420 --> 00:55:14.390
So here I'm getting data
from different locales.

00:55:14.500 --> 00:55:17.500
I'm running through the
list of available locales.

00:55:17.500 --> 00:55:21.000
I'm seeing which ones are
defined for this application.

00:55:21.240 --> 00:55:23.030
And I'm getting the flag icon from them.

00:55:23.040 --> 00:55:24.320
All right.

00:55:24.390 --> 00:55:27.920
So everything seems to be working,
just so you notice.

00:55:27.920 --> 00:55:32.740
If I change the order of the languages,
it does update here.

00:55:32.740 --> 00:55:34.810
So that's all working the way I want.

00:55:34.810 --> 00:55:35.900
Let's go back to French first.

00:55:36.020 --> 00:55:36.360
All right.

00:55:36.420 --> 00:55:38.570
Now,
we're missing the French localization.

00:55:38.570 --> 00:55:40.260
Very bad.

00:55:42.110 --> 00:55:47.690
If only there were a
French localization available.

00:55:49.660 --> 00:55:54.300
Fortunately, somebody, some kind soul,
has left a folder called

00:55:54.300 --> 00:55:56.360
fr.lproj on my desktop.

00:55:56.400 --> 00:56:02.580
Let us see what happens when
I put it inside my application.

00:56:02.620 --> 00:56:05.980
Launch, and we're in French.

00:56:06.370 --> 00:56:13.100
Now, localization can be done in an
entirely drop-in way on Mac OS.

00:56:13.100 --> 00:56:17.100
To add a localization,
you just add the L project and that's it.

00:56:17.100 --> 00:56:19.500
It is a very simple process.

00:56:19.700 --> 00:56:22.100
This means that localizations
can be added after the fact.

00:56:22.100 --> 00:56:27.800
After you ship, new localizations can be
added to your application.

00:56:27.800 --> 00:56:29.800
So, all right,
everything is in French now.

00:56:29.800 --> 00:56:33.450
Well,
we've done a couple of other changes,

00:56:33.450 --> 00:56:34.100
too.

00:56:34.700 --> 00:56:36.440
We've rearranged things.

00:56:36.440 --> 00:56:40.840
Our date and time picker is now
on the right instead of the left.

00:56:40.840 --> 00:56:42.790
You do see this.

00:56:43.340 --> 00:56:46.390
Not so much for French, not so much for
Western European languages,

00:56:46.390 --> 00:56:48.680
but definitely for
Middle Eastern languages.

00:56:48.780 --> 00:56:52.690
Languages which are written right
to left tend to prefer to have the

00:56:52.690 --> 00:56:55.300
UI elements reordered appropriately.

00:56:55.460 --> 00:57:00.900
So you should not assume that you
know how these windows are laid out.

00:57:01.040 --> 00:57:05.400
The localizer may need to change
it to fit local practices.

00:57:06.020 --> 00:57:09.890
And of course, we have now our list of
localizations showing up correctly.

00:57:10.210 --> 00:57:12.140
Now notice something else.

00:57:12.380 --> 00:57:16.820
Annapurna K2, Mount McKinley,
Mount Everest,

00:57:16.820 --> 00:57:19.970
list of mountains has changed.

00:57:20.470 --> 00:57:23.530
Now here,
I have a localized set of mountains

00:57:23.530 --> 00:57:24.770
and data for the mountains.

00:57:24.830 --> 00:57:28.620
So the people in France are evidently
not terribly interested in the mountains

00:57:28.730 --> 00:57:30.170
that are visible from my front porch.

00:57:30.260 --> 00:57:33.210
They would rather find
out about Le Cervin,

00:57:33.210 --> 00:57:34.600
the Matterhorn.

00:57:35.290 --> 00:57:38.640
So the French localizer has
changed the list of mountains to

00:57:38.770 --> 00:57:41.980
reflect what the user wants to see.

00:57:42.360 --> 00:57:45.000
You'll notice that I've done
another bit of cheating here.

00:57:45.000 --> 00:57:46.840
Well, not real cheating.

00:57:46.910 --> 00:57:48.910
Another little trick.

00:57:50.660 --> 00:57:56.460
In the middle of the sentence,
the Servant is not capitalized.

00:57:56.550 --> 00:57:57.600
Shouldn't be.

00:57:57.750 --> 00:57:59.520
It's in the middle of a sentence.

00:57:59.730 --> 00:58:03.780
When it's standing by itself, it is.

00:58:04.510 --> 00:58:07.680
So in this case,
I have my NSString that I got back,

00:58:07.680 --> 00:58:10.360
but before I hand it
off to the table view,

00:58:10.360 --> 00:58:13.930
I capitalized it because
it's standing by itself.

00:58:14.100 --> 00:58:16.110
So again,
the system is doing the right thing.

00:58:16.110 --> 00:58:21.610
Now, capitalizing French is really
not terribly difficult.

00:58:21.750 --> 00:58:24.760
Writing a capitalization routine
that can handle hundreds of different

00:58:24.760 --> 00:58:29.600
languages and 77 different scripts,
most of which you've never even heard of,

00:58:29.660 --> 00:58:31.500
that's a bit harder.

00:58:31.650 --> 00:58:34.180
Fortunately,
InnoString is doing the work for us.

00:58:34.180 --> 00:58:38.130
I just say I want the capitalized string,
and I get it back.

00:58:38.300 --> 00:58:39.200
All right, that's the demo.

00:58:39.200 --> 00:58:42.990
As I say, a version of this is currently
available on the website,

00:58:42.990 --> 00:58:46.140
and an updated version
will be available soon.

00:58:46.140 --> 00:58:49.200
If we can go back to the slides.

00:58:51.330 --> 00:58:52.240
All right.

00:58:52.510 --> 00:58:53.390
More information.

00:58:53.400 --> 00:58:58.300
The person to contact is Derek Horn,
the application technologies evangelist.

00:58:58.400 --> 00:58:59.960
Derek@apple.com.

00:59:00.120 --> 00:59:03.160
He will give you the help that
you need or possibly direct you

00:59:03.310 --> 00:59:04.900
to the place you need to go.

00:59:05.030 --> 00:59:07.300
Documentation,
if you want to find out how

00:59:07.300 --> 00:59:10.780
to internationalize on Mac OS,
excellent documentation is

00:59:10.790 --> 00:59:15.200
available at the developer website,
developer.apple.com.

00:59:15.290 --> 00:59:19.500
Let's be localized about this,
stroke internationalization.

00:59:19.640 --> 00:59:22.900
That's how the BBC seems
to say it all the time.

00:59:22.900 --> 00:59:27.830
If you want localization tools,
Apple's tools, these are a free download.

00:59:27.980 --> 00:59:31.180
This is where you can get
Apple Glot and other tools and

00:59:31.180 --> 00:59:33.400
the glossaries that we use.

00:59:33.500 --> 00:59:38.900
developer.apple.com/internationalization/
localization/tools.

00:59:39.010 --> 00:59:42.330
And if you want to know
more about Unicode,

00:59:42.330 --> 00:59:44.750
go to www.unicode.org.

00:59:45.490 --> 00:59:47.300
Excellent place to start.

00:59:47.300 --> 00:59:50.300
There are some sessions with
content related to this session.

00:59:50.300 --> 00:59:52.100
A couple of these have
already been presented,

00:59:52.100 --> 00:59:56.400
but you might want to go back and see
what was said there if you didn't attend.

00:59:56.400 --> 00:59:59.330
There is designing applications
with interface builder.

00:59:59.830 --> 01:00:04.100
Interface builder is your basic
tool for laying out your UI.

01:00:04.100 --> 01:00:06.100
That was yesterday at 5:00.

01:00:06.100 --> 01:00:09.400
This morning we had font
management and core text.

01:00:09.810 --> 01:00:14.520
There is a lot of overlap in terms of
engineering between people who display

01:00:14.610 --> 01:00:15.000
text and people who set up interface.

01:00:15.070 --> 01:00:17.190
There is a lot of overlap in content.

01:00:17.200 --> 01:00:21.290
So this is a session that you might
want to look into if you didn't attend.

01:00:21.320 --> 01:00:25.300
Coming up this evening,
we have text input on iPhone.

01:00:25.300 --> 01:00:27.300
This evening at 5:00.

01:00:27.300 --> 01:00:31.300
And then tomorrow we have
polishing your Cocoa application.

01:00:31.300 --> 01:00:34.620
This will be an excellent opportunity
to see how this all fits into

01:00:34.620 --> 01:00:36.290
the bigger picture of Cocoa.

01:00:36.300 --> 01:00:38.290
A couple of labs.

01:00:38.300 --> 01:00:41.130
We have an input method and
internationalization lab

01:00:41.220 --> 01:00:44.900
coming up this afternoon right
after this session at 3:30.

01:00:44.900 --> 01:00:48.900
iPhone text input lab tomorrow at 2:00.

01:00:48.900 --> 01:00:52.960
And finally, Friday afternoon,
you can stick around long enough if

01:00:52.960 --> 01:00:58.900
you really want for the core text lab,
2:00, foundations lab A.

01:00:58.900 --> 01:01:01.640
And again, there is going to be a
lot of expertise there,

01:01:01.640 --> 01:01:04.300
not just on core text but
also on internationalization

01:01:04.300 --> 01:01:05.900
if you have any questions.

01:01:06.040 --> 01:01:08.600
So in summary.

01:01:09.170 --> 01:01:13.570
Unicode is the way to do
internationalized text on the Mac,

01:01:13.570 --> 01:01:16.200
and not just on the Mac,
pretty much everywhere.

01:01:16.490 --> 01:01:18.260
Do not assume that you're
dealing with Unicode.

01:01:18.370 --> 01:01:21.500
Don't assume that you can deal with
text on a character-by-character basis.

01:01:21.610 --> 01:01:25.290
Remember, you have to deal with
chunks of characters.

01:01:25.480 --> 01:01:28.680
Above all,
use the APIs built into the system.

01:01:28.930 --> 01:01:32.200
This means that your
work is taken care of.

01:01:32.390 --> 01:01:35.200
Do not try to write your
own international support.

01:01:35.300 --> 01:01:38.100
Unless you are expert,
have a lot of time,

01:01:38.680 --> 01:01:41.960
something will go wrong along the way.

01:01:42.000 --> 01:01:43.760
Okay.

01:01:43.760 --> 01:01:47.120
CS101 should have taught you this,
but you know what?

01:01:47.290 --> 01:01:49.980
Programmers are lazy and
we sometimes forget it.

01:01:49.980 --> 01:01:52.850
Never show hard-coded
strings to the user.

01:01:53.070 --> 01:01:54.820
Never, never, never.

01:01:54.960 --> 01:01:58.740
Hard-coded strings are useful
in your application as keys,

01:01:58.740 --> 01:02:02.190
but never as something
that you show to the user.

01:02:02.190 --> 01:02:06.260
Also, this is a gotcha,
never assume anything about the

01:02:07.010 --> 01:02:09.390
relative layout of objects in your UI.

01:02:09.390 --> 01:02:13.190
They may have to change from
localization to localization.

01:02:13.300 --> 01:02:18.150
Don't assume that they're always
going to be laid out in the same way.

01:02:18.220 --> 01:02:21.340
Oh, and of course, never show unlocalized
numbers to the user.

01:02:21.340 --> 01:02:23.190
This is not a CS101 thing.

01:02:23.190 --> 01:02:25.150
This is something that is easy to forget.

01:02:25.150 --> 01:02:26.130
Don't do it.

01:02:26.130 --> 01:02:28.550
Always use a formatted number.

01:02:28.550 --> 01:02:30.600
Use NSNumberFormatter.

01:02:30.600 --> 01:02:31.920
Get the correct localization.
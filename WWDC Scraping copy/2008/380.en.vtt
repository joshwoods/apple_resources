WEBVTT

00:00:20.960 --> 00:00:22.800
Good afternoon.

00:00:22.950 --> 00:00:24.800
Welcome to Multi-Touch
Events and Gestures.

00:00:24.800 --> 00:00:25.800
My name is Jason Beaver.

00:00:25.800 --> 00:00:28.790
I am an engineer on the UIKit team.

00:00:28.970 --> 00:00:31.540
And I really hope today that
we can show you just how easy

00:00:31.540 --> 00:00:34.900
it is to use the multi-touch
interface to build really rich,

00:00:35.030 --> 00:00:38.300
powerful,
intuitive applications for your users.

00:00:41.470 --> 00:00:44.100
As you can see in the interface,
or the video on the screen,

00:00:44.100 --> 00:00:47.160
the touch interface
provides a really natural,

00:00:47.160 --> 00:00:52.470
intuitive way for your users to
interact with elements on the screen.

00:00:52.720 --> 00:00:57.390
They can touch on items, scroll around,
zoom in and out.

00:00:57.980 --> 00:01:00.800
All directly with the elements on
the screen instead of indirectly

00:01:00.800 --> 00:01:06.020
through touchpads and physical
buttons and things like that.

00:01:08.290 --> 00:01:11.090
This provides an experience
that's much closer to what

00:01:11.190 --> 00:01:15.580
users experience on the desktop,
where they interact directly with the

00:01:15.580 --> 00:01:17.920
items on the screen using the mouse.

00:01:18.250 --> 00:01:20.700
The finger isn't a mouse.

00:01:20.700 --> 00:01:23.480
You can't click on the screen or
touch on the screen with anywhere

00:01:23.480 --> 00:01:26.830
near the level of precision you
can with a mouse on the desktop.

00:01:26.930 --> 00:01:29.260
In fact,
when the user touches on the screen,

00:01:29.340 --> 00:01:32.300
the contact patch is actually elliptical.

00:01:32.400 --> 00:01:36.300
And the shape and size of this
contact patch varies based on

00:01:36.300 --> 00:01:38.750
which finger the user uses,
how hard they press,

00:01:38.800 --> 00:01:41.500
what angle they're holding their hand,
et cetera.

00:01:41.600 --> 00:01:44.470
In fact, even as they drag their
finger over the screen,

00:01:44.470 --> 00:01:47.080
the size and shape of
this ellipsoid changes.

00:01:47.290 --> 00:01:48.470
As a developer, though,
you really don't want to

00:01:48.570 --> 00:01:49.700
think about this ellipsoid.

00:01:49.700 --> 00:01:51.630
You just want to think
about a single touch point,

00:01:51.700 --> 00:01:54.990
the point where the user
was intending to touch.

00:01:55.090 --> 00:01:56.890
And you might think, well,
that's just the center of this ellipse,

00:01:56.890 --> 00:01:57.300
right?

00:01:57.300 --> 00:01:58.700
But it's not.

00:01:58.700 --> 00:02:01.850
When we've done studies and
tested where users touch,

00:02:01.920 --> 00:02:04.900
they think where they're touching is
very close to the tip of their finger.

00:02:05.040 --> 00:02:07.510
It's actually offset somewhat below that.

00:02:07.800 --> 00:02:10.810
So the system sort of
takes all this information,

00:02:10.810 --> 00:02:14.240
as well as the orientation of the screen,
and computes a single

00:02:14.240 --> 00:02:15.800
touch point for you.

00:02:18.540 --> 00:02:19.940
So what are we going to cover today?

00:02:19.940 --> 00:02:22.140
We're going to cover a
number of different topics.

00:02:22.190 --> 00:02:25.310
The first is, what is a touch sequence?

00:02:25.600 --> 00:02:28.000
How is it represented
to your application?

00:02:28.120 --> 00:02:30.560
And then how is it delivered
to your application?

00:02:30.650 --> 00:02:34.860
Then we'll talk about single touches,
multiple touches in the same view,

00:02:34.860 --> 00:02:37.500
and multiple touches in different views.

00:02:37.520 --> 00:02:40.650
And then we'll talk a little bit about
how the touches actually get routed to

00:02:40.650 --> 00:02:42.560
those views and how you can control that.

00:02:42.950 --> 00:02:46.090
As well as using UI control
when your needs for touch

00:02:46.150 --> 00:02:48.620
are a little more simplistic.

00:02:49.640 --> 00:02:53.530
So let's start with what
a touch sequence is.

00:02:53.640 --> 00:02:58.010
A touch sequence starts when the user's
finger contacts the surface of the

00:02:58.010 --> 00:03:03.500
screen and continues as the finger tracks
along the surface of the screen and ends

00:03:03.500 --> 00:03:06.000
when the finger lifts from the screen.

00:03:06.140 --> 00:03:09.460
So let's talk now about how
this is represented to you.

00:03:09.580 --> 00:03:13.690
Well, a finger is represented by an
instance of the UI touch class.

00:03:13.870 --> 00:03:15.980
There are three properties on UI Touch.

00:03:16.080 --> 00:03:17.880
The first is the timestamp.

00:03:18.210 --> 00:03:21.610
This represents the last time the state
of that finger changed in some way.

00:03:21.640 --> 00:03:24.990
The phase, which indicates what the
finger is currently doing.

00:03:25.000 --> 00:03:26.600
Did it just contact the screen?

00:03:26.600 --> 00:03:29.360
Is it moving around on the screen
or is it stationary on the screen?

00:03:29.360 --> 00:03:31.400
Or did it just lift from the screen?

00:03:32.140 --> 00:03:34.120
And finally, tap count.

00:03:34.350 --> 00:03:38.000
Now, a tap is a lot like a click
with a mouse on the desktop.

00:03:38.020 --> 00:03:40.540
If the user touches the
screen and touches just

00:03:40.630 --> 00:03:43.960
briefly enough and then lifts,
and there's relatively little motion,

00:03:43.960 --> 00:03:44.860
that's considered a tap.

00:03:44.960 --> 00:03:49.710
And if the user taps two or three times,
we increment tap count for

00:03:49.710 --> 00:03:53.990
you so that you can use that
to perform certain actions.

00:03:54.260 --> 00:03:55.860
There are a couple of
additional properties.

00:03:55.860 --> 00:03:59.000
The touch is associated
with a window and a view.

00:03:59.130 --> 00:04:01.300
This happens when the touch
first contacts the screen.

00:04:01.300 --> 00:04:04.800
The system determines which
window it's associated with.

00:04:04.910 --> 00:04:07.430
And then the window further figures
out which view it's associated with.

00:04:07.500 --> 00:04:09.900
And from that point forward,
the touch is directly

00:04:09.900 --> 00:04:12.840
associated with that view,
and the event is forwarded

00:04:12.840 --> 00:04:16.800
directly into that view as the
finger moves around on the screen.

00:04:16.890 --> 00:04:18.800
There are also a couple of methods
to figure out where the finger

00:04:18.800 --> 00:04:19.900
currently is on the screen.

00:04:19.900 --> 00:04:23.860
There's location in view and
previous location in view.

00:04:24.080 --> 00:04:28.200
Location in view tells where the touch
is in the view's coordinate system.

00:04:28.200 --> 00:04:30.000
The view that's passed
in is the argument here.

00:04:30.130 --> 00:04:33.330
And if the finger's in motion,
previous location in view tells

00:04:33.330 --> 00:04:35.440
you where it was right before this.

00:04:36.900 --> 00:04:41.850
Now, Events is a container for all
of the touches on the screen.

00:04:42.900 --> 00:04:48.000
It also has a timestamp indicating
last time the event was updated.

00:04:48.100 --> 00:04:50.970
And there are three methods to
access the touches inside this event.

00:04:51.220 --> 00:04:54.440
There's All Touches that access-- that
gives you a setback containing all

00:04:54.440 --> 00:04:56.340
the touches currently on the screen.

00:04:56.420 --> 00:04:58.940
And there's Touches for Window and
Touches for View to find out the touches

00:04:58.940 --> 00:05:01.610
that started in that window in view.

00:05:01.860 --> 00:05:04.340
So let's look at this
a little graphically.

00:05:04.380 --> 00:05:05.060
We have an event.

00:05:05.070 --> 00:05:08.120
This event has four
touches associated with it.

00:05:08.140 --> 00:05:10.840
And those touches are associated
with different windows.

00:05:10.840 --> 00:05:14.980
The first three are with window A,
and the last one is with window B.

00:05:15.610 --> 00:05:17.160
Furthermore,
those touches are associated with

00:05:17.160 --> 00:05:19.700
various views within those windows.

00:05:19.990 --> 00:05:23.060
If we ask the event for all the touches,
obviously we'll get back a set

00:05:23.180 --> 00:05:25.940
containing all of the touches.

00:05:26.040 --> 00:05:28.980
And if we ask for touches for
window and you pass in window A,

00:05:28.980 --> 00:05:30.380
we'll get back a set
with the first three,

00:05:30.380 --> 00:05:33.810
and for window B, we'll get back a set
containing the last one.

00:05:33.970 --> 00:05:35.870
Same with touches for view.

00:05:35.880 --> 00:05:38.390
If we ask for touches for
view for the first view,

00:05:38.520 --> 00:05:42.000
we'll get back the first two touches,
the third touch for view B,

00:05:42.000 --> 00:05:44.420
and the last touch for view C.

00:05:49.040 --> 00:05:53.450
So let's now talk about how those touches
are delivered to your application.

00:05:53.890 --> 00:05:55.800
To receive touches,
you need to be a subclass

00:05:56.090 --> 00:06:00.210
of the UI Responder class,
and there are four methods that

00:06:00.290 --> 00:06:01.170
you need to handle touches.

00:06:01.230 --> 00:06:04.800
The first is touchesBeganWithEvent.

00:06:04.900 --> 00:06:06.100
There's a couple things to
notice about this method.

00:06:06.100 --> 00:06:09.600
The first is that the
first argument is a set.

00:06:09.660 --> 00:06:12.180
If multiple fingers contact
your view simultaneously,

00:06:12.280 --> 00:06:15.680
you'll be passed a set
of all of those fingers.

00:06:16.410 --> 00:06:18.830
And the second is there's an
event argument at the end,

00:06:18.830 --> 00:06:21.530
and as we've talked about,
the event argument can be used to

00:06:21.530 --> 00:06:26.340
access other fingers that may already
be in contact with the screen.

00:06:26.470 --> 00:06:29.220
Now, as fingers move within your view,

00:06:29.800 --> 00:06:32.740
Your set of touches
moved with event message.

00:06:32.750 --> 00:06:34.690
And you're only told about the
touches that are in motion.

00:06:34.690 --> 00:06:38.300
If there are several fingers in contact
with your view but only one moves,

00:06:38.540 --> 00:06:42.240
that set will just contain the
one touch that's in motion.

00:06:43.100 --> 00:06:44.940
And finally, Touches Ended.

00:06:44.960 --> 00:06:47.080
This is sent when a finger
lifts from the screen.

00:06:47.100 --> 00:06:49.760
And again, the set will only contain
the fingers that have lifted.

00:06:49.790 --> 00:06:52.350
There may still be other touches
in contact with your view,

00:06:52.350 --> 00:06:55.800
and you can use the event
object to find out about those.

00:06:55.830 --> 00:06:58.290
And finally, Touches Cancelled.

00:06:58.740 --> 00:07:02.200
When there are certain system events,
such as an incoming phone call

00:07:02.250 --> 00:07:06.760
or an alert sheet popping up,
any fingers that are currently tracking

00:07:06.760 --> 00:07:08.490
on the screen will get canceled.

00:07:08.900 --> 00:07:12.460
And one of the most common problems
that we've seen in some of the

00:07:12.460 --> 00:07:18.140
apps we've encountered is people
not implementing touches canceled.

00:07:18.410 --> 00:07:21.430
Anytime your view changes its
internal state in any way,

00:07:21.430 --> 00:07:23.840
whether that's visually
or just in your model,

00:07:24.000 --> 00:07:26.560
when it's tracking a finger,
you need to always make sure you

00:07:26.560 --> 00:07:30.710
implement touches canceled to reset
that state in exactly the same way

00:07:30.710 --> 00:07:33.210
you would with your touches ended.

00:07:37.260 --> 00:07:40.090
So we've mentioned you have to
be a subclass of UIResponder.

00:07:40.130 --> 00:07:44.210
So what sorts of things are subclasses
of responder and can handle touches?

00:07:44.330 --> 00:07:49.140
Well, the application object is,
as well as UIView and UIViewController.

00:07:49.190 --> 00:07:52.960
And since UIView is a responder,
this means that pretty much

00:07:52.960 --> 00:07:54.920
everything you see on the screen

00:07:55.100 --> 00:07:57.930
is a responder and can
handle touch events.

00:07:57.930 --> 00:08:02.100
So it's from controls and labels,
image use, buttons, things like that.

00:08:03.720 --> 00:08:07.110
So let's see how this all
works now for a single touch.

00:08:07.230 --> 00:08:09.400
When the finger contacts the screen,
we'll figure out which window

00:08:09.400 --> 00:08:12.260
and view are associated with
that touch and send that view,

00:08:12.260 --> 00:08:14.560
touches began with event,
and we'll pass along a

00:08:14.560 --> 00:08:16.680
single touch instance,
and that's represented by the box

00:08:16.680 --> 00:08:18.540
in the upper right-hand corner.

00:08:18.600 --> 00:08:20.360
There's a couple things to notice here.

00:08:20.460 --> 00:08:22.930
The first is that the
address of that touch,

00:08:22.930 --> 00:08:26.510
here it's represented as 123,
will remain constant for

00:08:26.510 --> 00:08:28.150
the lifetime of that touch.

00:08:28.410 --> 00:08:30.590
When the finger actually
contacts the screen,

00:08:30.590 --> 00:08:32.600
we allocate a touch instance,
and then as it moves

00:08:32.600 --> 00:08:34.840
around on the screen,
we simply update that instance

00:08:35.270 --> 00:08:38.000
and tell you about the changes,
and it's not deallocated

00:08:38.000 --> 00:08:38.790
until the finger lifts.

00:08:38.950 --> 00:08:43.810
So you can actually use the uniqueness
of that instance address as a key to

00:08:43.850 --> 00:08:46.780
sort of keep track of touches over time.

00:08:46.920 --> 00:08:49.000
The next thing to notice is that
the phase of the touches began,

00:08:49.000 --> 00:08:50.760
indicating that it just
contacted the screen,

00:08:50.760 --> 00:08:55.310
and the location indicates where
on the screen it contacted.

00:08:55.680 --> 00:08:57.390
As it moves,
you're going to start to receive

00:08:57.450 --> 00:08:59.400
a series of touches moved bins.

00:08:59.530 --> 00:09:02.200
Notice the address is the same
and the phase is now moved,

00:09:02.280 --> 00:09:06.410
and the location is being updated
each time you receive the message.

00:09:06.980 --> 00:09:09.560
And when the finger finally
lifts from the screen,

00:09:09.560 --> 00:09:12.930
your touch is ended with event,
the phase is now ended,

00:09:13.000 --> 00:09:15.790
and the location represents
the last point that the finger

00:09:15.840 --> 00:09:17.900
was in contact with the screen.

00:09:18.520 --> 00:09:20.670
So we're going to look
at a simple demo now.

00:09:20.820 --> 00:09:23.140
We have a canvas, which is the white
area in the background,

00:09:23.180 --> 00:09:25.890
and a single image view in the middle,
and we want to allow the user to

00:09:25.900 --> 00:09:29.140
click within that image view and
drag that image around on the screen.

00:09:29.190 --> 00:09:31.640
Basically, we want to achieve an
effect kind of like this.

00:09:31.640 --> 00:09:38.750
So let's go over to Demos
and see how we do this.

00:09:44.130 --> 00:09:48.330
So I have a basic app structure here
created from one of the templates.

00:09:48.400 --> 00:09:49.570
There's only a couple
of things we've added.

00:09:49.580 --> 00:09:53.150
We've added a touch image view,
which I'll get into in a second.

00:09:53.560 --> 00:09:58.190
So this has a top-level application
delegate and a top-level view controller.

00:09:58.320 --> 00:10:00.700
So we're going to go
into the view controller,

00:10:00.800 --> 00:10:05.200
and in our viewDidLoad method,
we're going to add that image view.

00:10:05.240 --> 00:10:08.300
So the first thing we'll
do is load our image,

00:10:08.300 --> 00:10:10.710
the flowing rock image.

00:10:10.990 --> 00:10:13.950
And then we'll create a rectangle and
a touch image view from that rectangle.

00:10:14.040 --> 00:10:16.700
Now, a touch image view is just
a subclass of UI image view,

00:10:16.700 --> 00:10:19.980
and we'll get into that in just a second.

00:10:20.510 --> 00:10:25.400
We need to assign the TouchImageView's
image property to the image we loaded.

00:10:25.450 --> 00:10:28.710
And we'll just center
that view in the window.

00:10:29.260 --> 00:10:33.740
will then add it as a sub-view
of our View Controller's view

00:10:33.770 --> 00:10:36.170
and release the touch image view.

00:10:41.040 --> 00:10:42.980
So let's go over to the header
now of our touch image view.

00:10:42.980 --> 00:10:45.100
As I said,
it is a subclass of UI image view,

00:10:45.100 --> 00:10:48.230
but we need a couple of additional
instance variables here.

00:10:48.890 --> 00:10:53.430
We're going to need an affine transform
for how we'll manipulate this image.

00:10:53.790 --> 00:10:56.460
Now, for this first demo, really,
we're just allowing

00:10:56.460 --> 00:10:57.300
you to move it around.

00:10:57.300 --> 00:11:00.000
We could use this by just
positioning the view directly,

00:11:00.000 --> 00:11:02.000
but we're going to be expanding
this demo over the course of

00:11:02.000 --> 00:11:05.700
this session to allow multiple
fingers for scaling and rotating.

00:11:05.700 --> 00:11:08.300
So we'll do this with a transform.

00:11:08.340 --> 00:11:13.690
And we need a dictionary to record the
beginning points for all these fingers.

00:11:19.170 --> 00:11:22.430
Now, in our initWithFrame for
our touch image view,

00:11:22.430 --> 00:11:26.020
we need to set up the original transform
to be just the identity transform,

00:11:26.020 --> 00:11:29.400
indicating we don't want this
transformed at all initially.

00:11:29.590 --> 00:11:33.280
and we'll create that dictionary that
we're going to use for the begin points.

00:11:33.380 --> 00:11:36.830
We need to set one more thing because
this is a subclass of UI Image View.

00:11:37.070 --> 00:11:40.130
Image Views by default have
user interaction disabled,

00:11:40.260 --> 00:11:45.170
so we need to turn that back on to
allow us to receive the touch events.

00:11:46.000 --> 00:11:48.760
So now we need to provide
our implementations for

00:11:48.760 --> 00:11:49.940
the various touch handlers.

00:11:50.210 --> 00:11:53.020
So the first we'll start
out with is touches_began.

00:11:53.180 --> 00:11:55.330
In this case,
all we need to do is actually cache

00:11:55.330 --> 00:11:57.040
the begin points for the touches.

00:11:57.040 --> 00:11:59.100
We're not going to get into
the specifics of some of the

00:11:59.100 --> 00:12:01.040
methods that we'll see here.

00:12:01.050 --> 00:12:04.160
They're a little too complex to go with,
especially the ones that do

00:12:04.160 --> 00:12:05.790
the transforms in this session.

00:12:05.890 --> 00:12:09.140
But this demo is available
for download afterwards,

00:12:09.140 --> 00:12:11.430
and I'll talk about that in a little bit.

00:12:12.830 --> 00:12:16.510
So now on our touches moved,
we need to compute an

00:12:16.510 --> 00:12:17.420
incremental transform.

00:12:17.420 --> 00:12:19.350
Basically,
this is going to take that start

00:12:19.350 --> 00:12:23.000
point that's cached and the current
point and figure out a transform.

00:12:23.000 --> 00:12:26.820
In the case of a single finger,
it'll just be a translate transform.

00:12:26.820 --> 00:12:29.700
When we get into multiple fingers,
it will automatically handle

00:12:29.790 --> 00:12:31.770
rotate and scale for us.

00:12:32.590 --> 00:12:35.240
And then all we need to do is take
our original transform and that new

00:12:35.300 --> 00:12:39.530
transform and concatenate that and
set that as our view's transform.

00:12:41.640 --> 00:12:42.980
Now, when a finger -- when a
-- when a touch is ended,

00:12:43.120 --> 00:12:46.800
when a finger lifts,
we need to update that original transform

00:12:46.800 --> 00:12:52.440
so the image stays where it was and then
just remove those touches from the cache.

00:12:52.460 --> 00:12:55.100
Now, finally, we need to implement
our touches canceled,

00:12:55.130 --> 00:12:57.250
and we have a couple of choices here.

00:12:57.400 --> 00:13:00.680
If we want to -- we want that
image to snap back to where it was,

00:13:00.920 --> 00:13:04.720
we could just reset
our state and clean up.

00:13:04.750 --> 00:13:06.400
In this case, though,
we probably want the image to just

00:13:06.400 --> 00:13:08.910
stay wherever it was under the finger,
so we want to do the same thing

00:13:08.910 --> 00:13:09.920
we do when touch is ended.

00:13:09.920 --> 00:13:14.670
And so we can simply just
call touches ended from our

00:13:14.670 --> 00:13:17.860
touches canceled in this case.

00:13:17.990 --> 00:13:20.590
So now if we build and run on this.

00:13:27.300 --> 00:13:38.600
[Transcript missing]

00:13:49.710 --> 00:13:52.550
Okay, if we can go back to slides,
that's really all we need to

00:13:52.550 --> 00:13:54.940
do to handle a single touch.

00:13:58.350 --> 00:14:03.740
So now let's talk about how we
would handle multiple touches.

00:14:03.770 --> 00:14:06.430
Most views really only want
to handle a single touch.

00:14:06.450 --> 00:14:09.560
In fact, it would be extra work for most
views to deal with the fact that

00:14:09.560 --> 00:14:12.760
there may be multiple fingers
contacting that view at the same time.

00:14:12.940 --> 00:14:16.900
So by default,
if a finger is tracking in a view and

00:14:16.900 --> 00:14:19.990
another finger contacts that view,
it's simply ignored by the system.

00:14:20.000 --> 00:14:22.290
The view is never told about it.

00:14:22.610 --> 00:14:27.500
But if your view expects to and
knows how to handle multiple touches,

00:14:27.520 --> 00:14:31.900
all you have to do to enable that
is to set the UIView property

00:14:31.900 --> 00:14:34.180
MultipleTouchEnabled to Yes.

00:14:36.280 --> 00:14:37.950
So let's now look at a
multiple touch sequence.

00:14:38.050 --> 00:14:39.470
Obviously,
this is not the way you normally

00:14:39.480 --> 00:14:42.720
interact with your phone with two hands,
but...

00:14:43.910 --> 00:14:46.340
When the first finger
contacts the screen,

00:14:46.340 --> 00:14:49.320
that view will be sent a Touch As Began
with Event with a touch instance,

00:14:49.320 --> 00:14:51.080
and as it moves,
it will receive Touch As Moved.

00:14:51.230 --> 00:14:54.160
So far, this is exactly like
the single-touch case.

00:14:54.680 --> 00:15:02.590
When the next hand contacts,
or next finger contacts,

00:15:02.590 --> 00:15:02.590
you'll be sent another
Touches Began with Event.

00:15:02.770 --> 00:15:05.080
And that set will only
contain that new touch,

00:15:05.160 --> 00:15:08.710
the touch on the right here, address ABC.

00:15:09.580 --> 00:15:12.420
Notice that the other
touch is grayed out there.

00:15:12.620 --> 00:15:14.200
It's still in the event.

00:15:14.200 --> 00:15:15.900
If you ask the event for all
the touches for the view,

00:15:15.900 --> 00:15:16.900
you will see that touch.

00:15:16.900 --> 00:15:19.730
And you notice that its
phase is stationary.

00:15:20.840 --> 00:15:22.280
Now,
if both fingers move at the same time,

00:15:22.280 --> 00:15:25.740
your view will receive a touches
moved with event message.

00:15:25.810 --> 00:15:29.040
And because both fingers moved,
the set will contain both touches.

00:15:29.220 --> 00:15:31.550
Notice both--the phase for
both touches is in moved,

00:15:31.560 --> 00:15:33.660
and the locations have changed.

00:15:33.700 --> 00:15:36.500
And if just one moves, again,
you'll receive a touches moved,

00:15:36.540 --> 00:15:38.190
but the set will only contain
the finger that moved,

00:15:38.250 --> 00:15:41.720
the other touches there,
and mark stationary.

00:15:42.200 --> 00:15:46.000
And when the fingers both lift,
you're sent a Touches Ended With Event,

00:15:46.000 --> 00:15:48.740
and the set contains both touches.

00:15:48.780 --> 00:15:51.310
The phase is in the Ended state.

00:15:52.080 --> 00:15:55.480
So we're going to modify our demo
now to allow the user to put multiple

00:15:55.480 --> 00:16:00.070
fingers down in this view and rotate
and scale and move that image view.

00:16:00.240 --> 00:16:02.090
So this is the effect
we're trying to achieve.

00:16:02.140 --> 00:16:11.510
So let's look at now how to do that.

00:16:19.050 --> 00:16:22.100
So the first thing we need to
do is tell the system that our

00:16:22.100 --> 00:16:24.200
view can handle multiple touches.

00:16:24.280 --> 00:16:28.530
So we'll do that by setting the
multiple touch enabled property to yes.

00:16:28.780 --> 00:16:32.660
And then we need to do a little more work
in our touches began and touches ended,

00:16:32.660 --> 00:16:38.650
because we may receive these with other
fingers still in contact with the screen.

00:16:38.800 --> 00:16:41.110
So when our touches began,

00:16:41.860 --> 00:16:45.590
We need to figure out what touches
are already in contact with our view.

00:16:45.800 --> 00:16:50.360
So we do this by asking the event
for all the touches for our view,

00:16:50.410 --> 00:16:53.680
and then simply subtracting off
the touches that just came in.

00:16:53.680 --> 00:16:58.750
This gives us a set of touches that were
in contact before this touches began.

00:17:02.600 --> 00:17:06.880
And if there are any touches in that set,
we simply need to update our

00:17:06.900 --> 00:17:11.110
original transform and reset the
begin points for those touches,

00:17:11.110 --> 00:17:14.890
and then we can cache the begin points
for the new touches and move on.

00:17:14.970 --> 00:17:18.010
Now, the touches moved actually doesn't
have to change at all because

00:17:18.010 --> 00:17:21.150
the method that computes the
incremental transform already knows

00:17:21.150 --> 00:17:23.200
how to deal with multiple fingers.

00:17:23.250 --> 00:17:25.780
We need to do a little more work,
and our touch is ended,

00:17:25.780 --> 00:17:29.140
and it's somewhat analogous to the
stuff we did in the touches began.

00:17:29.350 --> 00:17:31.230
Basically,
we need to compute the remaining touches,

00:17:31.230 --> 00:17:32.680
and we do that in exactly the same way.

00:17:32.840 --> 00:17:37.300
We ask for the touches for view self,
subtract off the touches that are ending.

00:17:37.300 --> 00:17:39.480
That leaves the remaining touches.

00:17:39.540 --> 00:17:41.380
And then we just need to
cache their begin points.

00:17:41.470 --> 00:17:43.920
Now, we've already updated the
original transform here,

00:17:44.000 --> 00:17:45.320
so we don't need to do that.

00:17:45.320 --> 00:17:51.500
Now, if we build and run this,

00:17:56.400 --> 00:18:04.400
[Transcript missing]

00:18:12.710 --> 00:18:18.950
You can go back to slides.

00:18:19.300 --> 00:18:21.360
So that was how to
track in a single view.

00:18:21.400 --> 00:18:23.330
But what if those fingers are
tracking in different views?

00:18:23.440 --> 00:18:25.300
How do we handle that?

00:18:25.770 --> 00:18:26.970
So in this case,
we have a view on the left

00:18:27.070 --> 00:18:27.900
and right of the screen.

00:18:27.900 --> 00:18:31.420
When the finger contacts the left view,
it will receive a

00:18:31.420 --> 00:18:34.020
Touch As Began with event,
and as it moves, it will receive a

00:18:34.020 --> 00:18:36.740
Touch As Moved with event,
exactly like in the single-touch case.

00:18:36.740 --> 00:18:41.020
When a finger touches the other view,
it will receive a Touch As Began with

00:18:41.020 --> 00:18:43.620
event with the touch that landed in it.

00:18:43.740 --> 00:18:45.300
There's still the other touch there.

00:18:45.300 --> 00:18:47.690
It's marked Stationary,
but the view associated with that

00:18:47.750 --> 00:18:51.160
doesn't receive any notification
that a touch is moved because the

00:18:51.160 --> 00:18:53.260
touch in that view didn't move.

00:18:53.880 --> 00:18:56.760
Now, if they both move,
we're going to send two separate

00:18:57.070 --> 00:19:01.040
Touch As Moved with event to views,
and they'll each contain the one

00:19:01.040 --> 00:19:02.600
touch associated with that view.

00:19:02.600 --> 00:19:06.200
If just one moves, again,
we'll only send Touch As Moved

00:19:06.240 --> 00:19:09.320
to the one that actually has
a finger that's in motion.

00:19:10.840 --> 00:19:15.590
And if they both lift,
we'll again send touches ended with

00:19:15.590 --> 00:19:16.770
event to each of those views separately.

00:19:20.900 --> 00:19:26.740
So you want some control, though,
over how we deliver

00:19:26.740 --> 00:19:28.540
events to multiple views.

00:19:28.550 --> 00:19:31.390
It's not always appropriate for multiple
views to be tracking these fingers.

00:19:31.530 --> 00:19:34.220
For example,
if you have a table view with some

00:19:34.310 --> 00:19:37.460
sort of row that's highlighted and
you have two different buttons,

00:19:37.460 --> 00:19:40.240
one to edit that row and
one to delete that row,

00:19:40.240 --> 00:19:43.580
you probably don't want the user clicking
on both of those at the same time.

00:19:44.220 --> 00:19:47.860
So in that case, we provide a flag that
lets you control this,

00:19:47.860 --> 00:19:50.620
and that is the exclusive touch flag.

00:19:50.860 --> 00:19:54.920
The exclusive touch flag, if that is set,
then if there are fingers tracking

00:19:55.030 --> 00:19:58.410
in any other views within that
window and the user tries to touch

00:19:58.470 --> 00:20:01.200
on your exclusive touch view,
it's simply ignored.

00:20:01.200 --> 00:20:02.710
Your view's never told about it.

00:20:02.840 --> 00:20:04.960
And conversely,
if there's a finger already in your

00:20:05.120 --> 00:20:09.100
exclusive touch view and you try to
touch on some other view in that window,

00:20:09.140 --> 00:20:10.800
that touch is ignored.

00:20:10.850 --> 00:20:14.630
Basically what this does is it
guarantees that if your exclusive

00:20:14.630 --> 00:20:18.250
touch view is tracking any touches,
it's the only view within your

00:20:18.250 --> 00:20:20.390
window that's tracking touches.

00:20:22.570 --> 00:20:26.500
So now we're going to extend our
demo to have several image views.

00:20:26.520 --> 00:20:32.440
And we're first going to show how we can
move and scale all of these separately.

00:20:32.470 --> 00:20:34.970
And then we'll turn on the exclusive
touch flag and show how that limits us

00:20:35.030 --> 00:20:37.920
to only interacting with one at a time.

00:20:38.570 --> 00:20:40.200
So this is the effect we're
trying to achieve here.

00:20:40.200 --> 00:20:43.200
We're only showing
movement here in the video,

00:20:43.200 --> 00:20:46.370
but we'll be able to do
rotation and scale as well.

00:20:55.920 --> 00:20:58.880
So in our view controller,
we already loaded one image,

00:20:58.880 --> 00:21:00.230
and we have a block of code to do that.

00:21:00.240 --> 00:21:03.020
We'll have two more blocks of
code that are very similar,

00:21:03.120 --> 00:21:06.260
one to set the clownfish image
and one to set the stones image.

00:21:06.320 --> 00:21:12.730
And that's actually the
only change we need to make.

00:21:12.800 --> 00:21:15.120
If we run our demo now--

00:21:19.350 --> 00:21:20.900
You'll see we have multiple image views.

00:21:20.900 --> 00:21:23.650
I can click and move these,
and I can scale and rotate

00:21:23.650 --> 00:21:25.440
each of these independently.

00:21:34.620 --> 00:21:37.840
Limit that so that we only can
interact with one at a time.

00:21:37.880 --> 00:21:42.190
All I need to do to do that is
go back to our touch image view,

00:21:42.190 --> 00:21:44.260
and in our init with frame,

00:21:45.160 --> 00:21:48.120
I'll set the exclusive touch flag to yes.

00:21:48.260 --> 00:21:50.480
While we're here, I'm going to make one
other little change.

00:21:50.510 --> 00:21:51.880
Notice these views can now overlap.

00:21:51.880 --> 00:21:54.240
I want to allow the
user to reorder those.

00:21:54.360 --> 00:21:56.900
So I'm going to enable them
to double tap on one of those

00:21:56.900 --> 00:21:58.680
images to pop it to the front.

00:21:58.950 --> 00:22:02.360
All we need to do to do that is to
go down to where our touch has ended.

00:22:09.800 --> 00:22:12.910
And we'll just iterate through
the touches that are ending.

00:22:13.030 --> 00:22:16.140
We'll check to see if their tap
count is greater than or equal to 2.

00:22:16.160 --> 00:22:19.460
And we'll just move that to the
front of the view hierarchy.

00:22:30.400 --> 00:22:49.600
[Transcript missing]

00:23:01.440 --> 00:23:04.740
As I mentioned, this sample is available
up on the attendees site.

00:23:04.740 --> 00:23:06.000
The URL is here for that.

00:23:06.000 --> 00:23:08.110
I urge you to take a look at that.

00:23:10.290 --> 00:23:13.110
So let's now talk about how
touches are routed to your views.

00:23:13.200 --> 00:23:15.220
There's two parts of this
I want to talk about.

00:23:15.420 --> 00:23:17.940
The first is the responder chain.

00:23:18.590 --> 00:23:22.290
Now, I mentioned that--all along
I've mentioned that a touch is

00:23:22.310 --> 00:23:25.280
associated with a window and a view.

00:23:26.330 --> 00:23:29.540
And once we make that association,
we'll send touches began to that view.

00:23:29.540 --> 00:23:33.040
But what happens if that view
doesn't implement touches began?

00:23:33.130 --> 00:23:36.220
Well,
the system will try all of the objects in

00:23:36.220 --> 00:23:39.480
the responder chain to try to find some
object that knows how to handle this.

00:23:39.630 --> 00:23:42.580
So we'll start with the view, and again,
if it doesn't implement it,

00:23:42.680 --> 00:23:44.490
we'll see if that view
has a view controller.

00:23:44.810 --> 00:23:46.380
And if it does,
we'll ask that view controller

00:23:46.380 --> 00:23:48.520
to process the touches began.

00:23:48.530 --> 00:23:51.000
If it doesn't implement it,
we'll go to that view's

00:23:51.000 --> 00:23:52.670
super view and try it.

00:23:52.800 --> 00:23:54.520
Again,
it's super -- it's view controller.

00:23:54.630 --> 00:24:00.050
And we'll work our way up the super
view chain until we reach the window.

00:24:00.180 --> 00:24:03.400
The window is a subclass of view,
so obviously it can handle touches,

00:24:03.400 --> 00:24:06.100
and we'll see if this
window wants to handle it.

00:24:06.200 --> 00:24:08.340
And if not,
we'll forward it on to the application.

00:24:08.340 --> 00:24:12.530
And I mentioned the application is one
of those subclasses of UI Responder.

00:24:13.020 --> 00:24:17.740
Now, if no object handles the touch,
that's fine.

00:24:17.750 --> 00:24:21.920
We won't try to send it on any farther,
but as the finger continues to move,

00:24:22.090 --> 00:24:24.700
we'll still send touches
moved in exactly the same way.

00:24:24.700 --> 00:24:27.950
We'll start back at the view and
work our way up the responder chain,

00:24:27.950 --> 00:24:30.660
trying to find somebody
that handles the move.

00:24:30.920 --> 00:24:34.800
So what does this mean to you if all
you care about is when the finger ends,

00:24:34.800 --> 00:24:35.720
like when it lifts?

00:24:35.910 --> 00:24:38.680
You can simply implement
touches ended with event.

00:24:38.830 --> 00:24:42.110
The touches began and touches moved
will work their way up the responder

00:24:42.110 --> 00:24:45.200
chain and nobody will handle them,
and you'll still be

00:24:45.200 --> 00:24:47.050
sent the touches ended.

00:24:48.040 --> 00:24:50.500
Now, this is what the full
responder chain looks like.

00:24:50.500 --> 00:24:53.300
In most applications,
only the root-most view

00:24:53.300 --> 00:24:56.100
will have a view controller,
so this is a little more typical picture

00:24:56.100 --> 00:24:58.710
of what the responder chain looks like.

00:25:00.750 --> 00:25:05.000
The other part of touch
routing is hit testing.

00:25:05.050 --> 00:25:08.250
Hit testing is how we actually determine
which view within a window is the

00:25:08.250 --> 00:25:10.000
one that should receive the events.

00:25:10.060 --> 00:25:13.980
So when a touch contacts
someplace on the screen,

00:25:13.980 --> 00:25:17.530
the system will determine which
window that is and then ask the

00:25:17.530 --> 00:25:21.500
window to figure out which view
the touch should be routed to.

00:25:21.520 --> 00:25:24.880
And it does this by starting at
the back of the view hierarchy and

00:25:24.880 --> 00:25:28.280
sending a hit test with event message.

00:25:29.310 --> 00:25:31.400
Now, that view will check several
properties of itself.

00:25:31.540 --> 00:25:34.470
The first is,
is user interaction enabled?

00:25:34.660 --> 00:25:37.670
This was the property we had to
set on the image view to enable

00:25:37.670 --> 00:25:39.820
it to receive touch events.

00:25:41.210 --> 00:25:43.540
The next is, is that view hidden?

00:25:43.890 --> 00:25:45.990
Hidden views can't process touches.

00:25:46.090 --> 00:25:48.500
So if the view is hidden,
it'll return nil from hit test

00:25:48.610 --> 00:25:51.130
and the window will go on to try
to find some other view that's

00:25:51.130 --> 00:25:53.280
capable of handling that touch.

00:25:53.360 --> 00:25:54.320
We'll also check the alpha.

00:25:54.320 --> 00:25:57.060
If the alpha is zero,
that means the view is completely

00:25:57.060 --> 00:26:04.200
transparent and that's not a valid
view for hit testing or for tracking.

00:26:04.540 --> 00:26:08.660
And the last is we'll call
Point Inside with Event.

00:26:08.670 --> 00:26:13.660
This checks to see if the touch is
completely within the bounds of the view.

00:26:13.660 --> 00:26:16.910
If it's outside the view,
that's not a valid view for tracking.

00:26:18.500 --> 00:26:22.030
Now, then that view will go on and
recursively call HitTestWithEvent

00:26:22.200 --> 00:26:24.890
for all of its subviews,
and that'll work its way down the

00:26:24.890 --> 00:26:28.780
view hierarchy until it finds a
view that meets these criteria

00:26:28.780 --> 00:26:30.700
and doesn't have any subviews.

00:26:30.800 --> 00:26:34.950
So in this case, it's just our subview,
and it doesn't have any further children.

00:26:34.960 --> 00:26:38.780
The subview will check all the
same things and then return itself.

00:26:38.900 --> 00:26:40.630
At that point,
we create the touch instance.

00:26:40.680 --> 00:26:45.980
We assign the view property to that view
and the window property to the window.

00:26:46.860 --> 00:26:50.840
Now, not all views implement
the default hit testing,

00:26:50.870 --> 00:26:54.820
and you can override this to change how
hit testing works in your application.

00:26:54.910 --> 00:26:57.480
A good example is the scroll view.

00:26:57.970 --> 00:27:02.080
In a scroll view,
you want to be able to have a lot

00:27:02.080 --> 00:27:04.780
of content inside the scroll view,
but if you click on that,

00:27:04.970 --> 00:27:06.030
you still want to be able to scroll.

00:27:06.100 --> 00:27:07.620
You don't want, like,
there's a button in the middle

00:27:07.620 --> 00:27:11.850
of that and you hit the button,
you don't want that to block scrolling.

00:27:12.040 --> 00:27:14.720
So the way scroll view implements this

00:27:14.980 --> 00:27:17.920
So when the finger contacts the screen,
the window gets that,

00:27:18.120 --> 00:27:20.640
calls hit testing just like it has.

00:27:20.780 --> 00:27:22.640
ScrollView receives that.

00:27:22.660 --> 00:27:24.930
And it checks the exact same
parameters it does to make

00:27:24.930 --> 00:27:27.730
sure it's a valid hit target.

00:27:27.800 --> 00:27:32.500
And at this point,
the ScrollView simply returns itself.

00:27:32.660 --> 00:27:34.860
We create a touch instance at
this point where the view is

00:27:34.930 --> 00:27:37.170
associated with the ScrollView.

00:27:39.200 --> 00:27:41.870
So this means that as that finger
moves around on the screen,

00:27:41.870 --> 00:27:45.860
we're going to send the updates to
that touch directly to the scroll view,

00:27:45.900 --> 00:27:49.720
not to the view inside that the
user thinks they clicked on.

00:27:50.100 --> 00:27:53.000
Now,
the scroll view still needs to know which

00:27:53.000 --> 00:27:56.360
object the user actually touched on,
so it will internally go

00:27:56.360 --> 00:27:57.840
through the same process.

00:27:57.960 --> 00:28:01.170
It'll call hit test with event on
down the view hierarchy until it

00:28:01.170 --> 00:28:03.190
finds the actual object that was hit.

00:28:03.330 --> 00:28:08.490
But it'll just cache that internally
so that it can forward those events on.

00:28:09.180 --> 00:28:12.400
So if your object is
inside a scroll view,

00:28:12.410 --> 00:28:16.790
you may be sent a touches began
and touches moved to track a touch.

00:28:16.800 --> 00:28:21.220
But what happens if you call touches
for view and pass yourself in?

00:28:21.240 --> 00:28:23.610
In that case,
you're actually going to get

00:28:23.640 --> 00:28:25.160
a nil back or an empty set.

00:28:25.230 --> 00:28:28.840
There are no touches that are
actually associated with your views.

00:28:28.840 --> 00:28:31.270
So you need to be a little
careful in certain circumstances.

00:28:31.610 --> 00:28:35.500
If you do implement touch routing,
touch forwarding in your application,

00:28:35.570 --> 00:28:38.820
you need to recognize that
sometimes views will be asked

00:28:38.820 --> 00:28:42.100
to process touches that aren't
directly associated with them.

00:28:46.780 --> 00:28:48.570
So, up to this point,
we've talked entirely about

00:28:48.690 --> 00:28:51.240
handling the touches yourself.

00:28:51.330 --> 00:28:54.910
But if all you need from the touch
system is simple notification when

00:28:54.910 --> 00:28:59.690
something like a user touches somewhere
or lifts their finger from somewhere,

00:29:00.320 --> 00:29:06.690
You could avoid some of this complexity
by using the UI Control class.

00:29:07.170 --> 00:29:12.280
So UI Control defines several events
which you can associate actions with.

00:29:13.310 --> 00:29:16.310
It shows you it has events for when
the finger contacts the screen,

00:29:16.530 --> 00:29:19.110
or in the case of double
or triple tapping,

00:29:19.180 --> 00:29:21.830
contacts the screen with repeat.

00:29:22.270 --> 00:29:25.180
If the finger's dragging around
inside your control or has started

00:29:25.420 --> 00:29:28.640
in your control and is now dragging
around outside your control,

00:29:28.640 --> 00:29:31.090
there are events posted for that.

00:29:33.580 --> 00:29:35.740
When it is dragging,
if it reenters your control

00:29:35.740 --> 00:29:39.510
or exits your control,
there are events associated with that.

00:29:40.090 --> 00:29:43.440
And finally, when the finger lifts,
if it lifts inside your control

00:29:43.440 --> 00:29:46.790
or outside your control,
there are separate events for that.

00:29:46.890 --> 00:29:48.150
We also mentioned touches canceled.

00:29:48.350 --> 00:29:48.830
That happens.

00:29:48.880 --> 00:29:53.230
There's a touch cancel event that
you can associate an action with.

00:29:53.350 --> 00:29:57.400
So how do you associate those
actions with the control?

00:30:00.370 --> 00:30:07.000
There is a method on UI Control called
Add Target Action for Control Events.

00:30:07.070 --> 00:30:09.680
The target is the object
you want to be notified.

00:30:09.930 --> 00:30:15.060
The action is the method selector
that we will invoke on your object.

00:30:15.150 --> 00:30:18.540
And the control events are the
set of control events that you

00:30:18.540 --> 00:30:20.060
want to trigger those actions.

00:30:20.060 --> 00:30:22.050
And that's a bit mass,
so you can specify as

00:30:22.050 --> 00:30:23.720
many as you'd like there.

00:30:26.290 --> 00:30:30.020
So I should mention that this is a little
different than the way target action

00:30:30.020 --> 00:30:33.450
stuff works on the desktop for those
of you who are familiar with Cocoa.

00:30:33.720 --> 00:30:36.570
In Cocoa, there's only a single target
and action associated for

00:30:36.570 --> 00:30:38.400
sort of the entire control.

00:30:38.550 --> 00:30:42.560
In UIKit, notice it's add target action,
not set target action.

00:30:42.560 --> 00:30:45.640
You can have as many as you'd like,
and you can associate multiple

00:30:45.640 --> 00:30:49.110
targets and actions even with
the exact same control event.

00:30:49.910 --> 00:30:52.260
So let's look at the action signatures.

00:30:52.320 --> 00:30:53.590
This is also different from the desktop.

00:30:53.640 --> 00:30:58.220
In the desktop, the action method has to
have a single signature,

00:30:58.220 --> 00:31:00.990
and it's something that
takes a single argument.

00:31:01.700 --> 00:31:03.200
On the phone, though,
there's three possible

00:31:03.200 --> 00:31:05.440
signatures you can use.

00:31:05.540 --> 00:31:08.250
This first is a method that
doesn't take any arguments.

00:31:08.550 --> 00:31:11.680
Here it's called PerformAction,
but you can give this

00:31:11.680 --> 00:31:13.310
any name you might like.

00:31:13.750 --> 00:31:15.480
The second is one that
takes a single argument.

00:31:15.580 --> 00:31:19.640
In this case, it's the control that is
generating the control event.

00:31:19.680 --> 00:31:22.700
We're calling it performAction:
in this case, but again,

00:31:22.700 --> 00:31:24.770
you can use any name you'd like.

00:31:25.090 --> 00:31:28.200
And the last is a method
that takes two arguments:

00:31:28.240 --> 00:31:34.270
the control that's generating the
control event and the event object.

00:31:40.470 --> 00:31:45.060
So that's how you can associate
things with actual control events,

00:31:45.060 --> 00:31:48.190
but you still might want to do
your own tracking in a control.

00:31:48.290 --> 00:31:51.470
Since control is optimized
to handle single touches,

00:31:51.510 --> 00:31:53.960
there's some simplified
methods to do that.

00:31:54.130 --> 00:31:58.120
The first is begin tracking
with touch with event.

00:31:59.500 --> 00:32:01.830
The first argument here
is a touch instance,

00:32:01.870 --> 00:32:04.920
not a set of touches, because again,
the control is optimized to

00:32:04.920 --> 00:32:06.980
deal with a single touch.

00:32:07.310 --> 00:32:09.040
And there's a return
value of Boolean here,

00:32:09.040 --> 00:32:11.860
which is different than
touchesBeganWithEvent,

00:32:11.860 --> 00:32:13.980
which has a void return type.

00:32:14.540 --> 00:32:18.170
The return value here indicates whether
you want to continue processing events.

00:32:18.200 --> 00:32:22.400
If when the finger contacts the control
and you receive the Begin Tracking

00:32:22.400 --> 00:32:26.430
with Touch event or message,
if you determine at that point that

00:32:26.430 --> 00:32:30.300
you don't really care about this touch,
you can simply return No and

00:32:30.300 --> 00:32:33.860
you won't receive any future
updates about that touch.

00:32:33.860 --> 00:32:38.040
Now, compare this to handling the
touches more directly yourself.

00:32:38.040 --> 00:32:41.350
If in your touches began,
you didn't want to handle that touch,

00:32:41.850 --> 00:32:43.640
you'd have to keep some sort
of state around because you're

00:32:43.640 --> 00:32:46.400
going to continue to receive
touches moved and touches ended,

00:32:46.520 --> 00:32:49.880
and you're going to have to check that
state each time and make sure that,

00:32:49.960 --> 00:32:53.430
or check to see if you really
want to process that touch.

00:32:53.860 --> 00:32:58.140
As the finger moves,
you'll receive a "Continue tracking

00:32:58.140 --> 00:33:00.380
with touch with event" message.

00:33:00.640 --> 00:33:03.700
Again, it contains a single touch,
and there's a Boolean to indicate

00:33:03.700 --> 00:33:08.060
whether you want to continue
receiving updates about this touch.

00:33:08.170 --> 00:33:11.440
When the finger lifts,
there's an "End tracking with

00:33:11.440 --> 00:33:13.400
touch with event" message.

00:33:13.460 --> 00:33:16.280
And if it's canceled,
there is a corresponding "Cancel

00:33:16.280 --> 00:33:18.180
tracking with event" message.

00:33:19.780 --> 00:33:22.460
So we're going to look at a
simple little demo here that has

00:33:22.460 --> 00:33:25.260
a set of labels up at the top.

00:33:25.300 --> 00:33:37.300
[Transcript missing]

00:33:53.510 --> 00:33:54.760
Let's see,
so the first thing we want to do

00:33:54.760 --> 00:33:57.700
is we've got a new project here
with a similar type structure.

00:33:57.700 --> 00:34:00.690
It's got an application
delegate and a view controller.

00:34:01.620 --> 00:34:05.940
And in the ViewController,
we want to add a couple

00:34:05.940 --> 00:34:07.230
of instance variables.

00:34:07.340 --> 00:34:08.700
Oops, excuse me.

00:34:08.700 --> 00:34:10.970
I need to go switch.

00:34:16.600 --> 00:34:18.720
Which script I'm running?

00:34:18.990 --> 00:34:19.930
So we have a couple
of instance variables.

00:34:19.940 --> 00:34:22.940
The first is a rectangle that
we'll use to position each of

00:34:22.940 --> 00:34:25.360
those labels down the screen.

00:34:26.130 --> 00:34:28.700
will have an instance variable
for each of those labels.

00:34:28.750 --> 00:34:30.300
And finally,
the button at the bottom-- and

00:34:30.300 --> 00:34:33.160
button is just a subclass of control,
and we're using it here

00:34:33.170 --> 00:34:34.950
just for visual appearance--

00:34:39.400 --> 00:34:43.560
Now, in our implementation file,
we need to add a couple of methods.

00:34:43.570 --> 00:34:45.900
We'll add a convenience method
that'll create that label for us.

00:34:45.900 --> 00:34:48.930
So we'll add-- this is
called addLabelWithText.

00:34:49.270 --> 00:34:54.680
It'll create a label,
set its font and text color,

00:34:54.680 --> 00:34:57.420
and we'll align it to be in the center,
and then we'll set the

00:34:57.420 --> 00:35:01.610
alpha to this default value,
which in this case is 0.3.

00:35:02.290 --> 00:35:05.500
And then we'll assign the text,
add it as a subview of our

00:35:05.660 --> 00:35:08.270
view controller's view,
and release the label.

00:35:08.300 --> 00:35:13.000
Now we need to move that rectangle down
so we have a place to put the next label.

00:35:13.010 --> 00:35:16.020
We'll do that here,
and then we'll simply return the label.

00:35:16.120 --> 00:35:19.330
We also need another method that will
highlight this label for us and then

00:35:19.600 --> 00:35:22.250
unhighlight it in an animated fashion.

00:35:22.360 --> 00:35:24.990
So I have a method here
called HighlightLabel.

00:35:25.970 --> 00:35:28.710
Here we're just going
to set the alpha to 1,

00:35:28.710 --> 00:35:31.740
which makes it fully
opaque and fully blue.

00:35:31.800 --> 00:35:34.470
And then we'll begin
an animation context,

00:35:34.620 --> 00:35:38.460
set the animation duration
to 1 and 1/2 seconds,

00:35:38.520 --> 00:35:43.720
and reset the alpha back to
the default value of 0.3.

00:35:43.930 --> 00:35:46.890
And then we'll just commit that
animation to get it started.

00:35:49.700 --> 00:35:54.020
When our view did load,
we need to set the

00:35:54.020 --> 00:35:56.350
default label rectangle.

00:35:57.020 --> 00:35:59.100
And then we're going to add
a series of labels here.

00:35:59.100 --> 00:36:02.270
We'll just look at the first one,
but they're all roughly the same.

00:36:02.630 --> 00:36:05.590
Text will be the text that's
associated with that event.

00:36:05.630 --> 00:36:07.480
So in this case,
it's the Touchdown label,

00:36:07.650 --> 00:36:11.570
and we'll assign that
to the Touchdown label,

00:36:11.580 --> 00:36:12.600
Ivar.

00:36:12.640 --> 00:36:15.070
Now we'll create our button.

00:36:17.110 --> 00:36:20.200
We'll set its title to UI Control,
and for the control state Normal,

00:36:20.200 --> 00:36:22.160
because we're not setting it
for any other control state,

00:36:22.160 --> 00:36:26.410
it'll have this title for
all possible control states.

00:36:26.600 --> 00:36:29.280
We'll add that as our subview.

00:36:30.590 --> 00:36:33.520
And then now we need to associate
all the target and actions.

00:36:33.820 --> 00:36:35.300
So again, we've got several methods here.

00:36:35.300 --> 00:36:36.800
We'll just look at the first one.

00:36:36.830 --> 00:36:39.520
We're going to add ourself as the target.

00:36:39.650 --> 00:36:43.300
The selector is touchdown, again,
something we defined.

00:36:43.360 --> 00:36:45.500
For the control event, touchdown.

00:36:45.560 --> 00:36:47.770
And the rest are similar.

00:36:48.380 --> 00:36:52.650
Now we need to actually go provide
implementations for all those actions.

00:36:52.750 --> 00:36:53.990
Again, we've got a set here.

00:36:53.990 --> 00:36:54.860
We'll just look at the first one.

00:36:54.980 --> 00:36:57.100
Touchdown,
we'll simply call highlight label

00:36:57.100 --> 00:37:02.490
and pass in the touchdown label.

00:37:02.960 --> 00:37:06.920
Finally, we just need to make sure we're
cleaning up those IVARs properly.

00:37:15.250 --> 00:37:17.690
If we look at the demo,
we notice we have the labels at the

00:37:17.690 --> 00:37:19.400
top and the control at the bottom.

00:37:19.400 --> 00:37:21.320
And if I just touch in the control,
notice I get a touchdown.

00:37:21.320 --> 00:37:24.220
As I move around a little bit,
we're getting a drag inside.

00:37:24.220 --> 00:37:27.200
If I stop, notice it fades out,
meaning we're no longer getting it.

00:37:27.280 --> 00:37:30.300
But if I start moving my finger again,
we'll start receiving that again.

00:37:30.300 --> 00:37:33.100
The fact that it stays blue indicates
we're receiving that continually.

00:37:33.100 --> 00:37:35.720
And when I finally lift,
we'll get a touch up inside.

00:37:35.720 --> 00:37:39.430
If I click and I drag outside,
notice you'll get a drag exit.

00:37:39.430 --> 00:37:42.660
And then now we're dragging
outside the control.

00:37:42.660 --> 00:37:44.580
And when I move back in,
we'll get a drag enter.

00:37:45.530 --> 00:37:47.730
You may notice it doesn't
happen directly on the boundary.

00:37:47.730 --> 00:37:49.360
The boundary's actually
a little farther away.

00:37:49.360 --> 00:37:51.640
Because of the imprecision
of the touch system,

00:37:51.730 --> 00:37:54.400
there's a buffer sort of
built around the control.

00:37:54.400 --> 00:37:55.890
You have to touch in
the control to start,

00:37:56.040 --> 00:37:57.520
but once you do that,
you can actually move a

00:37:57.520 --> 00:37:59.120
little bit outside it,
and it won't.

00:37:59.120 --> 00:38:01.810
It'll still track inside it.

00:38:01.810 --> 00:38:04.230
So as you can see,
we're getting all the various

00:38:04.590 --> 00:38:07.280
kinds of events as we touch
up inside or even outside.

00:38:07.280 --> 00:38:09.060
And that's it.

00:38:20.130 --> 00:38:23.540
So we covered a lot
of stuff this morning.

00:38:23.540 --> 00:38:26.180
We talked a little bit about
how touches are represented and

00:38:26.180 --> 00:38:29.300
how they're delivered to you.

00:38:29.330 --> 00:38:32.990
And we talked about how to handle
single touches and multiple touches,

00:38:33.110 --> 00:38:35.000
what happens if those touches
are in multiple views,

00:38:35.000 --> 00:38:38.420
and how to control how those
touches are routed to those views,

00:38:38.420 --> 00:38:43.600
and how to use the UI Control class
to do some simpler touch handling.

00:38:43.600 --> 00:38:47.800
I really hope you guys will go out
and take a look at this touch demo

00:38:47.800 --> 00:38:50.660
that's available for download,
as well as some of the other ones

00:38:50.740 --> 00:38:52.600
that are up on developer.apple.com.

00:38:52.640 --> 00:38:54.600
And we're really looking forward
to seeing the kind of great

00:38:54.650 --> 00:38:55.900
stuff you guys can do with this.

00:38:55.900 --> 00:39:00.760
I know you can build some pretty powerful
interfaces with this multi-touch screen.

00:39:01.960 --> 00:39:05.200
If you want more information,
you can contact Derek Horn.

00:39:05.200 --> 00:39:08.170
There's also documentation
up on the Apple site.

00:39:09.260 --> 00:39:13.100
There is a lab Thursday morning,
tomorrow morning, in iPhone Lab B.

00:39:13.100 --> 00:39:16.710
I'll be there along with some
of the other UI kit engineers.

00:39:17.380 --> 00:39:19.940
There's also a related session
Friday morning at 10:30

00:39:19.940 --> 00:39:21.700
called "How Do I Do That?

00:39:21.990 --> 00:39:24.840
Tips and Tricks for iPhone
Application Development." They'll get

00:39:24.840 --> 00:39:27.780
into a little more detail there about
some of the scroll view stuff and how

00:39:28.020 --> 00:39:30.090
to use that and interact with that.
WEBVTT

00:00:21.050 --> 00:00:25.380
Good afternoon and welcome to
session 930 using DTrace on Mac OS X.

00:00:25.380 --> 00:00:26.120
I'm Steve Peters.

00:00:26.120 --> 00:00:28.740
I work in the Mac OS X performance group.

00:00:28.770 --> 00:00:31.520
My colleague James McIlree will
be joining me later for questions.

00:00:31.520 --> 00:00:34.240
He works in the performance tool group.

00:00:34.520 --> 00:00:37.950
And today,
we'd like to tell you about DTrace,

00:00:37.950 --> 00:00:42.710
new to Leopard anyway,
system observability facility.

00:00:43.550 --> 00:00:46.370
DTrace joins a rich collection
of Mac OS development tools,

00:00:46.470 --> 00:00:49.420
tools you've been hearing
about all this week.

00:00:49.440 --> 00:00:53.140
And the point of having you here today
is so that we can show you how you

00:00:53.210 --> 00:00:58.600
can use DTrace to gain greater insight
into the behavior of your projects.

00:00:58.990 --> 00:01:02.530
We're pleased, as always,
to acknowledge that DTrace is

00:01:02.530 --> 00:01:06.120
open source software that was
developed for Open Solaris by

00:01:06.130 --> 00:01:10.610
Sun and ported to Mac OS by Apple.

00:01:12.870 --> 00:01:15.080
So here's what we hope
you'll learn today.

00:01:15.480 --> 00:01:19.770
Quite a bit about what DTrace is and
a little bit about what it's not.

00:01:20.130 --> 00:01:21.370
How to use DTrace.

00:01:21.370 --> 00:01:25.210
You should be reasonably comfortable
at the command line with some simple

00:01:25.300 --> 00:01:28.800
DTrace scripts and toolkit invocations.

00:01:28.800 --> 00:01:30.260
If you're following
along in the audience,

00:01:30.260 --> 00:01:33.930
you'll be practicing it by
the time we're done today.

00:01:34.120 --> 00:01:36.840
We'll talk in some detail
about the language,

00:01:36.850 --> 00:01:38.970
the programming language for D.

00:01:40.120 --> 00:01:44.220
And we'll talk about the DTrace toolkit,
a prepackaged collection of

00:01:44.650 --> 00:01:48.540
commonly used scripts that can get
you up and running really quickly.

00:01:49.740 --> 00:01:52.440
And finally,
we'll have a bit of a rundown

00:01:52.440 --> 00:01:56.300
on the DTrace providers,
the sort of subject area experts

00:01:56.300 --> 00:02:00.770
underneath the hood in DTrace that
provide instrumentation information.

00:02:02.680 --> 00:02:07.470
So the high order bit,
this is actually a marketing slide,

00:02:07.650 --> 00:02:11.700
says that DTrace is a comprehensive,
dynamic tracing framework.

00:02:11.710 --> 00:02:16.040
DTrace provides a powerful
infrastructure to permit administrators,

00:02:16.120 --> 00:02:20.130
developers like yourselves,
and service personnel to concisely answer

00:02:20.130 --> 00:02:26.020
arbitrary questions about the behavior of
the operating system and user programs.

00:02:27.640 --> 00:02:31.440
So what are some of the advantages
of DTrace as we see them?

00:02:31.540 --> 00:02:35.850
It's really a unique tracing
technology in Leopard.

00:02:36.050 --> 00:02:39.480
A follow-up,
sort of supplants the existing

00:02:39.490 --> 00:02:42.340
K-Trace and trace mechanisms
available only in the kernel with

00:02:42.340 --> 00:02:46.650
a much more general mechanism,
one that has zero disabled cost,

00:02:46.810 --> 00:02:49.690
costs you nothing if it's not in use.

00:02:50.490 --> 00:02:51.440
It's entirely dynamic.

00:02:51.480 --> 00:02:55.000
There's no starting,
stopping of the system, of your program,

00:02:55.000 --> 00:03:00.160
no recompilation with different debug
tracing flag set or any reboot required.

00:03:00.220 --> 00:03:01.800
You can just go right to it.

00:03:01.850 --> 00:03:02.890
It's system-wide.

00:03:02.900 --> 00:03:07.040
You can see both user programs
that you've constructed

00:03:07.270 --> 00:03:09.270
and stuff in the kernel.

00:03:09.760 --> 00:03:12.460
Every thread in the system is visible.

00:03:12.530 --> 00:03:13.340
Always available.

00:03:13.500 --> 00:03:17.110
It's part of the user installs gone out
on every Leopard system we've shipped and

00:03:17.130 --> 00:03:19.040
will go out with Snow Leopard as well.

00:03:19.590 --> 00:03:20.160
Comprehensive.

00:03:20.160 --> 00:03:22.160
You can see bits down in the kernel.

00:03:22.420 --> 00:03:27.950
You can see methods and structures
up in your Cocoa application.

00:03:28.120 --> 00:03:30.010
And finally,
and I think the most important,

00:03:30.010 --> 00:03:31.290
DTrace is programmable.

00:03:31.330 --> 00:03:33.300
It's probably the first
of its kind facility,

00:03:33.300 --> 00:03:36.810
at least on Mac OS X,
for tracing that lets you really

00:03:36.950 --> 00:03:42.790
sort of arbitrarily collect,
compute, and display data, tracing data.

00:03:43.310 --> 00:03:50.440
So the style that these advantages
engender is one of following your nose.

00:03:50.440 --> 00:03:53.150
Pose a question,
design a little DTrace script,

00:03:53.150 --> 00:03:57.620
or use one that you already
know about to collect some data,

00:03:57.620 --> 00:03:58.290
answer the question.

00:03:58.350 --> 00:03:59.740
Perhaps it leads you to another question.

00:03:59.740 --> 00:04:02.880
You'll see that paradigm
repeated here today.

00:04:03.910 --> 00:04:07.570
and DTrace also turns out to be an
important enabling technology for

00:04:07.570 --> 00:04:09.900
the Instruments high-level GUI tool.

00:04:09.900 --> 00:04:13.780
And you can learn more about
Instruments in the advanced

00:04:13.830 --> 00:04:16.220
DTrace and Instruments session,
number 935,

00:04:16.260 --> 00:04:18.770
I believe tomorrow on your schedule.

00:04:22.040 --> 00:04:24.600
So just a little bit
about what DTrace isn't.

00:04:24.760 --> 00:04:27.690
It doesn't replace tried and true tools.

00:04:27.780 --> 00:04:30.240
You want to always use the
right tool for the job at hand,

00:04:30.240 --> 00:04:32.590
the one that gets you to
the finish line first.

00:04:32.650 --> 00:04:36.060
So for instruction level
tracing and timings,

00:04:36.060 --> 00:04:39.570
careful timings of the
hot loops in your program,

00:04:39.660 --> 00:04:40.970
look to Shark.

00:04:41.160 --> 00:04:46.020
That's a finely crafted application
that's been around and is tested and an

00:04:46.020 --> 00:04:49.010
ideal tool for that kind of application.

00:04:49.860 --> 00:04:53.470
For memory leaks,
there's the object alloc

00:04:53.470 --> 00:04:55.590
template in Instruments.

00:04:55.940 --> 00:04:57.940
And if you're just interested in seeing,
you know,

00:04:57.940 --> 00:05:02.130
where something's stuck in a loop,
just point Sampler at it.

00:05:02.500 --> 00:05:15.400
[Transcript missing]

00:05:16.090 --> 00:05:17.460
There's no magic with DTrace.

00:05:17.460 --> 00:05:21.120
It's a wonderful, powerful tool,
but you still have to use

00:05:21.120 --> 00:05:27.440
your debugging and engineering
intelligence to really apply it well.

00:05:27.510 --> 00:05:30.270
You need to understand
your problem in depth.

00:05:30.500 --> 00:05:35.770
Be able to generate sharp hypotheses
about what's going on here.

00:05:36.660 --> 00:05:38.530
System call time, am I blocking?

00:05:38.530 --> 00:05:43.770
Then create or choose an appropriate
DTrace script to make a crucial

00:05:43.770 --> 00:05:44.920
data collection experiment.

00:05:44.920 --> 00:05:47.260
And finally,
be able to interpret the results of that.

00:05:47.280 --> 00:05:51.710
I mean, these are all things that over
time as software engineers,

00:05:51.710 --> 00:05:54.090
we should all be quite adept with.

00:05:59.020 --> 00:06:03.730
So, sort of the second order bit,
how does DTrace work?

00:06:03.800 --> 00:06:08.100
Well, there's this general separation
into the pieces in user land

00:06:08.100 --> 00:06:10.410
and the pieces in the kernel.

00:06:12.520 --> 00:06:16.150
and close to that border are
the core pieces of DTrace.

00:06:16.260 --> 00:06:19.050
On the kernel side,
the DTrace virtual machine,

00:06:19.090 --> 00:06:21.500
a place where all the magic happens.

00:06:21.770 --> 00:06:25.700
Above the line, a framework,
libdtrace.dilib,

00:06:25.850 --> 00:06:29.120
and it basically takes care of
the communication with the DTrace

00:06:29.120 --> 00:06:32.940
virtual machine as well as the
language processing issues that

00:06:32.940 --> 00:06:36.490
arise from looking at your scripts.

00:06:41.270 --> 00:06:45.180
Underlying the DTrace virtual machine
are these subject area experts.

00:06:45.280 --> 00:06:49.340
These are modules of code that know
about a particular aspect of the

00:06:49.410 --> 00:06:53.270
system and how to expose interesting
trace points and instrumentation data.

00:06:53.280 --> 00:06:56.290
So, for example,
if you're interested in knowing where

00:06:56.510 --> 00:06:59.360
your program is making system calls,
Unix system calls,

00:06:59.360 --> 00:07:02.250
you'll be talking mostly
to the syscall provider.

00:07:02.320 --> 00:07:04.910
If you're interested in
understanding where I.O.

00:07:04.910 --> 00:07:07.290
starts and stops in time
and in the volume of I.O.

00:07:07.520 --> 00:07:09.600
that's going on,
you'll appeal to the I.O.

00:07:09.600 --> 00:07:10.370
provider.

00:07:11.200 --> 00:07:14.900
FBT is the function
boundary tracing provider.

00:07:14.900 --> 00:07:17.290
It provides most of the probes in DTrace.

00:07:17.290 --> 00:07:20.960
They are every C function
entry point inside the kernel.

00:07:20.960 --> 00:07:22.760
Kernel hackers love this stuff.

00:07:22.760 --> 00:07:25.240
Users may find it interesting at times.

00:07:31.800 --> 00:07:35.410
You talk to DTrace using scripts,
just like shell scripts,

00:07:35.470 --> 00:07:38.290
just like little C programs,
as you'll see.

00:07:38.400 --> 00:07:44.620
And those are digested by the DTrace
command and passed down the pipeline.

00:07:48.270 --> 00:07:52.370
Instruments also, as I mentioned earlier,
has DTrace underlying parts of it,

00:07:52.500 --> 00:07:56.640
and it eschews the command line
and just goes straight to the

00:07:56.640 --> 00:07:58.370
dialib and does its business.

00:08:02.470 --> 00:08:05.110
It's worth pointing out that
there's one really special provider,

00:08:05.110 --> 00:08:09.000
and it's not just because it was James'
piece of work that I mentioned this.

00:08:09.110 --> 00:08:11.420
It's called FastTrap.

00:08:11.870 --> 00:08:17.140
FastTrap knows how to cross that
userland kernel boundary for tracing.

00:08:17.150 --> 00:08:21.520
So if you're interested in
some of the trace points

00:08:21.520 --> 00:08:25.660
that we've put in lib system,
for example, in our Snow Leopard

00:08:25.670 --> 00:08:29.560
malloc implementation,
you'll ask the FastTrap provider

00:08:29.560 --> 00:08:31.380
to go find those for you.

00:08:31.810 --> 00:08:37.330
Similarly, in your application,
if you want to put either pre-position

00:08:37.340 --> 00:08:41.000
probes or walk up to the machine and say,
I need to look at this

00:08:41.080 --> 00:08:43.460
function right now,
the FastTrap provider is

00:08:43.460 --> 00:08:44.980
capable of doing that for you.

00:08:44.980 --> 00:08:48.120
It's a jack of all trades and
a really remarkable creation.

00:08:48.120 --> 00:08:50.930
So let's do a demo.

00:08:50.930 --> 00:08:54.020
I call this the ABCs of DTrace.

00:09:02.150 --> 00:09:04.960
So if we just talk to DTrace,
say its name,

00:09:04.960 --> 00:09:06.940
it tells us how to talk to it.

00:09:07.020 --> 00:09:09.700
It's a long, long list of options,
but as you'll see,

00:09:09.700 --> 00:09:12.000
you can get an enormous amount
done with just two or three.

00:09:12.000 --> 00:09:15.690
And we'll sort of stay
around two or three options

00:09:15.690 --> 00:09:18.120
in the examples that follow.

00:09:20.000 --> 00:09:24.930
Those subject area experts can tell
you what probe points are available.

00:09:24.940 --> 00:09:28.210
We can get a catalog of those,
and we get those by

00:09:28.400 --> 00:09:32.530
DTrace minus L,
that's a lowercase L down there.

00:09:32.790 --> 00:09:34.800
And off we go, and there are quite a few.

00:09:34.800 --> 00:09:40.200
Maybe we should pipe that through more.

00:09:40.210 --> 00:09:42.350
Ah, that's better.

00:09:44.460 --> 00:09:49.580
Let's look down at say line four.

00:09:49.850 --> 00:09:51.530
Yes, lockstat.

00:09:51.690 --> 00:09:53.480
Begins for lockstat.

00:09:53.520 --> 00:09:58.180
The column of numbers are
just indices on the far side.

00:09:58.500 --> 00:10:01.160
Then there's the name of the provider,
the subject matter expert.

00:10:01.170 --> 00:10:02.880
I didn't put lockstat
on the previous slide.

00:10:02.880 --> 00:10:03.340
I could have.

00:10:03.360 --> 00:10:05.690
There were lots of little
bubbles on the bottom.

00:10:05.690 --> 00:10:07.540
It could have been one of those.

00:10:07.610 --> 00:10:09.510
It instruments the Mach kernel.

00:10:09.530 --> 00:10:13.750
It tells you roughly where
its interest is centered.

00:10:14.110 --> 00:10:17.830
And then it tells us what function
in particular will be providing

00:10:17.830 --> 00:10:20.330
this piece of tracing location.

00:10:20.350 --> 00:10:23.840
And in this case,
it's lock mutex lock in the kernel.

00:10:23.860 --> 00:10:28.420
And there's a particular
semantic character to the piece

00:10:28.420 --> 00:10:29.480
of information that it provides.

00:10:29.480 --> 00:10:33.180
It's about when an adaptive
acquire is undertaken.

00:10:33.200 --> 00:10:39.790
And notice adaptive acquire appears a
couple of times in that name column.

00:10:40.090 --> 00:10:43.900
And those are different function
points in the system where

00:10:43.910 --> 00:10:45.100
an adaptive acquire is done.

00:10:45.100 --> 00:10:48.570
And we can aggregate those
together in a way you'll see.

00:10:48.860 --> 00:10:51.250
But there's sort of this
mix and match quality,

00:10:51.250 --> 00:10:51.800
right?

00:10:51.830 --> 00:10:55.670
So sort of four interesting pieces
of information about a probe.

00:10:55.920 --> 00:11:00.770
Its provider locks that in this case,
the module, the function, and a name.

00:11:03.640 --> 00:11:07.420
So I mentioned the FBT provider,
the function boundary tracing provider.

00:11:07.420 --> 00:11:10.180
Here's the beginning of its catalog.

00:11:10.180 --> 00:11:15.620
FBT instruments the Mach kernel,
and it starts out with AARP wakeup,

00:11:15.630 --> 00:11:17.060
the entry point.

00:11:17.400 --> 00:11:22.760
So if we set that probe,
set that to fire, whenever the system

00:11:22.760 --> 00:11:26.630
called into AARP wakeup,
we'd hear about it, and we could also set

00:11:26.630 --> 00:11:28.380
one on the next line,
the return.

00:11:28.380 --> 00:11:33.580
And similarly for,
I think there are 17,000 of these things.

00:11:33.580 --> 00:11:35.580
So let's move down.

00:11:41.410 --> 00:11:43.320
Yeah, that's the last one.

00:11:43.450 --> 00:11:44.600
ZMap return.

00:11:44.600 --> 00:11:46.360
Okay.

00:11:46.360 --> 00:11:52.600
Let me go on to the syscall provider.

00:11:52.600 --> 00:11:58.060
System calls are the programming
interfaces between user land

00:11:58.060 --> 00:12:00.120
and the BSD part of our kernel.

00:12:00.120 --> 00:12:04.070
Things like open, read, write, close,
exit, fork, exec.

00:12:04.130 --> 00:12:06.660
All the things you
learn about in Unix 101.

00:12:07.660 --> 00:12:11.090
And we have a,
DTrace has a provider that instruments

00:12:11.090 --> 00:12:12.810
the entry and return points.

00:12:12.890 --> 00:12:17.380
So you can see when those probes fire,
perhaps take a timestamp on the entry,

00:12:17.380 --> 00:12:21.090
see the return, get another timestamp,
notice an elapsed time.

00:12:21.100 --> 00:12:22.200
Just as an example.

00:12:28.680 --> 00:12:32.940
So VM info,
there are a bunch of those in here,

00:12:32.970 --> 00:12:35.180
give information about
the virtual memory system.

00:12:35.210 --> 00:12:40.170
When there's a page fault,
when stuff's being swapped, in and out,

00:12:40.170 --> 00:12:41.140
so forth.

00:12:42.670 --> 00:12:45.280
Here's an interesting one,
the last one I'll show.

00:12:45.300 --> 00:12:48.930
Yes.

00:12:49.950 --> 00:12:53.010
So at the very top of the screen,
I hope everybody can see,

00:12:53.240 --> 00:12:56.120
there's mention here of
the core data provider.

00:12:56.120 --> 00:12:58.390
That's one of our
frameworks up in user land,

00:12:58.400 --> 00:12:59.080
core data.

00:12:59.080 --> 00:13:05.960
And a rather long Objective C-like
method name for the function.

00:13:05.960 --> 00:13:08.960
And then the sort of semantic
context is that this probe

00:13:08.960 --> 00:13:13.000
fires when there's a data fault,
when there's a core data data fault.

00:13:13.300 --> 00:13:18.570
And the name, the provider name way
over on the far side,

00:13:18.840 --> 00:13:20.670
Core Data 152 is interesting.

00:13:20.680 --> 00:13:25.390
152 refers to the process number of
a process that's currently running.

00:13:25.510 --> 00:13:30.080
So here's a case where that
FastTrap provider has known to,

00:13:30.230 --> 00:13:33.580
knows how to catalog the fact
that it can find a probe up in

00:13:33.750 --> 00:13:38.650
Process 152 in the Core Data framework
on this Objective-C message

00:13:38.870 --> 00:13:42.630
with the begin fault name.

00:13:46.200 --> 00:13:47.510
Clear the screen.

00:13:47.820 --> 00:13:55.890
And so what I'd like to do is
take a look at how to set a probe,

00:13:55.950 --> 00:14:00.530
set a trap, a DTrace probe point,
and get some output from it.

00:14:00.650 --> 00:14:01.480
So here we go.

00:14:01.480 --> 00:14:03.820
Invoke the DTrace command.

00:14:03.820 --> 00:14:07.000
We'll use the minus N option,
which says I'm going to give

00:14:07.000 --> 00:14:09.870
you the DTrace program right
here on the command line,

00:14:09.880 --> 00:14:11.000
right between these two quotes.

00:14:11.890 --> 00:14:16.240
And pretty clearly we're going to
talk to the syscall provider here.

00:14:16.250 --> 00:14:19.570
And there's a whole bunch of colons
which basically say wildcard to anything.

00:14:19.700 --> 00:14:22.820
So whenever a system call
happens on this system,

00:14:22.820 --> 00:14:25.020
DTrace will let us know about it.

00:14:25.080 --> 00:14:26.760
So let's let that go.

00:14:26.760 --> 00:14:29.540
Let's click on the window.

00:14:29.680 --> 00:14:34.060
So there were 854 of those things,
and we're off to the races, right?

00:14:34.910 --> 00:14:36.350
Well,
let's slow that down a little bit and

00:14:36.380 --> 00:14:39.910
take a little bit more careful look.

00:14:41.850 --> 00:14:43.860
Again, 854 probes.

00:14:43.860 --> 00:14:47.480
All right, so the first one that hit,
hit on CPU number seven.

00:14:47.480 --> 00:14:49.860
Yes, Octo Machine.

00:14:50.160 --> 00:14:54.920
Hit a probe whose index number
in that list before was 17701.

00:14:54.920 --> 00:14:57.760
It's the iOctal probe,
and it was a return point.

00:14:57.760 --> 00:15:01.830
Probably the entry occurred
before we fired up this script.

00:15:01.940 --> 00:15:05.760
I kind of suspect that iOctal
actually came from DTrace itself,

00:15:05.760 --> 00:15:08.880
passing the program down
to be run or starting it.

00:15:08.940 --> 00:15:13.060
What's kind of interesting are
these sort of repeated patterns

00:15:13.060 --> 00:15:16.680
in the middle of SIGACTION,
SIGPROC MASK, MMAPS.

00:15:16.680 --> 00:15:18.090
I kind of wonder what's that about.

00:15:18.750 --> 00:15:20.600
And so that's kind of the
follow the nose paradigm.

00:15:20.620 --> 00:15:22.540
What's the next thing we
might want to look at here?

00:15:22.790 --> 00:15:28.240
Well, how about figuring out

00:15:36.100 --> 00:15:39.860
Which syscall is called how many times?

00:15:39.860 --> 00:15:43.620
So down here on the command line,
we've added a little bit to

00:15:43.620 --> 00:15:44.980
the description of the probe.

00:15:44.980 --> 00:15:49.780
We're only going to ask for
firings on the entry to that probe.

00:15:49.780 --> 00:15:51.780
And then here's some
stuff in curly braces.

00:15:51.780 --> 00:15:53.920
Well,
maybe that's sort of like program code.

00:15:53.920 --> 00:15:58.320
Yeah, it's the action that should take
place when that probe fires.

00:15:58.320 --> 00:16:03.020
And we've got something that
looks like storing into an array.

00:16:03.090 --> 00:16:06.080
Sure enough,
it's a special kind of an array.

00:16:06.100 --> 00:16:08.290
It's first of all an associative array.

00:16:08.360 --> 00:16:13.410
The stuff between the square brackets
can be just about any key value.

00:16:13.780 --> 00:16:17.880
and the at sign out in front indicates
that it's an aggregate array.

00:16:17.880 --> 00:16:20.040
And we'll talk a bit
more about aggregates,

00:16:20.110 --> 00:16:24.130
but aggregates basically solve
the problem of probes firing

00:16:24.130 --> 00:16:26.490
on many processors all at once.

00:16:26.500 --> 00:16:28.690
How do you get a coherent
collection of data?

00:16:28.690 --> 00:16:30.640
Aggregation solves that problem.

00:16:30.660 --> 00:16:34.840
And on the right hand side we're simply
indicating that every time this probe

00:16:34.940 --> 00:16:39.960
fires we should increment a count
in a particular slot of this array.

00:16:40.000 --> 00:16:40.700
Which slot?

00:16:40.780 --> 00:16:44.760
The one that's indexed by the
name of the system call it fired.

00:16:45.160 --> 00:16:47.630
Open, close, read, write, etc.

00:16:47.760 --> 00:16:50.180
Well,
it's best just to see what happened here.

00:16:50.180 --> 00:16:53.300
While we were talking that data
was being collected for us.

00:16:53.420 --> 00:16:57.470
And if I click in the window, we can see.

00:16:59.150 --> 00:17:02.620
On the far side,
we see the list of the system

00:17:02.740 --> 00:17:07.670
calls that were encountered during
the time that I was talking.

00:17:08.220 --> 00:17:14.140
The count ordered from smallest to
largest on the side closest to me.

00:17:14.250 --> 00:17:16.990
And wow, a lot of F controls,
a lot of I octals,

00:17:17.120 --> 00:17:18.500
a bunch of SIGPROC masks.

00:17:18.780 --> 00:17:23.400
Hmm, I wonder if we can figure out
who's making lots of system calls.

00:17:23.460 --> 00:17:27.870
Well, that's just sort of a variation
on the script we just ran.

00:17:30.250 --> 00:17:31.350
So off we go again.

00:17:31.650 --> 00:17:35.420
Same probe descriptor,
pretty much the same action,

00:17:35.440 --> 00:17:40.100
but this time we'll use a different
interpreter built-in variable.

00:17:40.100 --> 00:17:44.950
Every time the probe fires,
DTrace notes what was the exec name,

00:17:44.950 --> 00:17:48.520
the name of the process
that caused the firing,

00:17:48.530 --> 00:17:52.660
and that's available to the script
as a special built-in variable,

00:17:52.700 --> 00:17:54.800
just like in the shell.

00:17:54.870 --> 00:17:58.290
So while we were talking,
if I click in there.

00:17:58.990 --> 00:18:03.140
Ah, DTrace made a bunch of calls.

00:18:03.160 --> 00:18:05.520
NTPD, oh, interesting.

00:18:05.570 --> 00:18:07.880
Windows Server doing a lot of stuff.

00:18:07.880 --> 00:18:09.120
Ah.

00:18:09.160 --> 00:18:10.780
Well, let's dig into the Windows Server.

00:18:10.780 --> 00:18:16.240
That's sort of always an
interesting place to peer around in.

00:18:16.740 --> 00:18:20.480
And let's just count the system
calls made by the Windows server.

00:18:20.550 --> 00:18:25.700
And that introduces kind of the last
and final piece of deprogramming.

00:18:25.700 --> 00:18:27.160
You'll now have seen it all.

00:18:27.200 --> 00:18:29.350
And it's off and running.

00:18:29.400 --> 00:18:32.990
Same action as before.

00:18:33.060 --> 00:18:36.460
Same probes that we'd like to light up.

00:18:36.560 --> 00:18:41.360
But there's this bit enclosed in slashes,
and that's a predicate, that's a filter.

00:18:41.360 --> 00:18:44.740
And it says,
look at the built in variable name

00:18:44.740 --> 00:18:47.960
of the process when this is fired.

00:18:47.960 --> 00:18:50.840
If it's identically equal to
the string Windows Server,

00:18:50.850 --> 00:18:52.180
then go ahead and do this action.

00:18:52.180 --> 00:18:55.850
So we're filtering down on
just the system calls that are

00:18:55.860 --> 00:18:59.470
being fired by Windows Server.

00:19:00.940 --> 00:19:05.750
Maybe that's telling us a
little bit about the original

00:19:05.890 --> 00:19:09.510
observation we made that,
gee, sigalt stack, sigproc mask, mmap,

00:19:09.600 --> 00:19:11.270
and munmap are being hit a lot.

00:19:11.320 --> 00:19:14.220
Well, the Windows server is certainly
doing a lot of that damage.

00:19:14.220 --> 00:19:19.530
All right, I think at this point
I am back to the slides.

00:19:26.850 --> 00:19:29.430
So those were DTrace first words for us.

00:19:29.430 --> 00:19:31.580
And we were writing DTrace
programs at the command line.

00:19:31.580 --> 00:19:33.480
And here's just a quick review.

00:19:33.610 --> 00:19:36.100
And by the time we got to the--

00:19:36.850 --> 00:19:39.320
Last example,
we basically had introduced all

00:19:39.320 --> 00:19:41.430
the elements of a DTrace program.

00:19:41.430 --> 00:19:45.120
So let's look a little bit more
carefully about how we express those,

00:19:45.180 --> 00:19:48.600
the language D that's
used to program DTrace.

00:19:50.080 --> 00:19:52.090
It's actually a language
that's compiled to byte codes.

00:19:52.180 --> 00:19:55.970
It's passed to the kernel across
that boundary we showed in

00:19:56.080 --> 00:20:01.190
the first layer cake slide and
where the code is interpreted.

00:20:01.810 --> 00:20:04.640
Lib DTrace does the language
processes like I mentioned.

00:20:04.750 --> 00:20:07.040
The language is lightweight, small,
simple.

00:20:07.070 --> 00:20:09.330
Don't expect very
powerful features from it.

00:20:09.600 --> 00:20:13.800
It's got to be interpreted
in the kernel when very

00:20:13.800 --> 00:20:15.250
elementary events are occurring.

00:20:15.260 --> 00:20:19.680
So you don't want to spend a lot of
time working stuff out down there.

00:20:20.100 --> 00:20:21.850
So for example, there is no control flow.

00:20:21.910 --> 00:20:25.110
There are no loops in the D language.

00:20:25.490 --> 00:20:27.260
No user defined functions.

00:20:27.430 --> 00:20:29.730
There's some convenience features.

00:20:29.730 --> 00:20:34.230
You don't have to declare variables
much like a shell or Perl script.

00:20:34.700 --> 00:20:39.260
And for the deep,
deep details on the D language

00:20:39.260 --> 00:20:42.400
and plenty of examples,
there are these, the

00:20:42.550 --> 00:20:45.040
DTrace heavyweight
documentation on the SunSite.

00:20:45.060 --> 00:20:47.890
And they've also put together
more like a quick reference card

00:20:48.110 --> 00:20:51.450
that's handy once you've got it.

00:20:55.500 --> 00:20:58.130
So a D program is built
up of probe clauses,

00:20:58.130 --> 00:20:59.670
and you've already seen probe clauses.

00:20:59.760 --> 00:21:03.530
They consist of a probe descriptor,
predicate and closing slashes,

00:21:03.570 --> 00:21:07.170
some curly braces,
and some computation within.

00:21:08.120 --> 00:21:10.340
The basic unit of the D language.

00:21:10.340 --> 00:21:13.710
As you've seen in our very first example,
we only gave a probe descriptor

00:21:13.940 --> 00:21:15.680
and DTrace did something sensible.

00:21:15.680 --> 00:21:19.710
So it's lazy and it will
infer actions for you.

00:21:21.220 --> 00:21:24.120
Probe descriptor has four components.

00:21:24.170 --> 00:21:28.420
So they sort of map right onto that
catalog listing we did at the outset.

00:21:28.680 --> 00:21:31.650
Provider, module, function, and name.

00:21:32.270 --> 00:21:36.430
They describe what probes
we would like to enable.

00:21:36.490 --> 00:21:41.060
They support some wild carding by
either omitting an orange labeled

00:21:41.060 --> 00:21:45.960
piece entirely or there's a simple
globbing language that you can use.

00:21:46.000 --> 00:21:48.150
And it's the only required
part of a probe clause.

00:21:48.380 --> 00:21:52.140
Every example had some sort of
probe descriptor telling DTrace,

00:21:52.320 --> 00:21:55.300
who do I consult to get
some tracing information?

00:21:56.150 --> 00:21:58.860
We were able to list those
using DTrace minus L,

00:21:58.860 --> 00:22:01.040
that's lowercase l.

00:22:01.050 --> 00:22:05.660
And here's an example that sort
of narrows that down onto just

00:22:05.670 --> 00:22:09.790
the system calls that have the,

00:22:10.000 --> 00:22:17.600
[Transcript missing]

00:22:22.160 --> 00:22:28.580
Here's a probe descriptor that says
light up all the system call probes,

00:22:28.590 --> 00:22:32.460
entry and returns that
DTrace knows about.

00:22:33.100 --> 00:22:34.340
This is a little bit more interesting.

00:22:34.340 --> 00:22:39.600
Here's an appeal to the FastTrap
provider to set a probe point on

00:22:39.600 --> 00:22:47.750
the return of the printf function
in lib system in process 1017.

00:22:50.690 --> 00:22:52.830
Since we do a bunch of
Objective-C on our systems,

00:22:52.840 --> 00:22:57.330
Apple did an extension to the
PID provider called the objcprovider.

00:22:57.550 --> 00:23:02.060
In this example, the objcprovider,
which talks to FastTrap

00:23:02.150 --> 00:23:06.220
down at the bottom,
places entry probes on all the

00:23:06.220 --> 00:23:13.080
instance methods that begin with
the word draw in process 10.17.

00:23:13.140 --> 00:23:17.600
So you'll see a few examples
of that in a little bit.

00:23:18.530 --> 00:23:22.390
Predicates, enclosed in slashes,
Boolean expressions.

00:23:22.470 --> 00:23:26.390
It's a condition that's evaluated
each time a probe is triggered.

00:23:26.630 --> 00:23:30.030
We use predicates to focus,
to limit the amount of data,

00:23:30.110 --> 00:23:36.070
to home in on just one particular
place in the system that is causing

00:23:36.200 --> 00:23:38.690
us trouble or instance or...

00:23:39.800 --> 00:23:42.210
Some examples.

00:23:42.300 --> 00:23:47.410
Suppose we were interested
in all the times Safari

00:23:48.170 --> 00:23:49.260
Open to file.

00:23:49.260 --> 00:23:51.860
Here's one way to get at that.

00:23:51.860 --> 00:23:58.110
We set the provider to be syscall
open entry and then filter

00:23:58.110 --> 00:24:00.380
that down by using exec name.

00:24:02.560 --> 00:24:08.800
Suppose it was interesting to see the
fifth and subsequent open system calls.

00:24:08.830 --> 00:24:12.800
Well, we could keep a global counter and
increment it within the predicate.

00:24:12.810 --> 00:24:16.920
When it came true, we'd go on and execute
the action statements.

00:24:16.920 --> 00:24:20.990
Unless otherwise specified,
global variables are initialized to zero,

00:24:20.990 --> 00:24:23.040
so this actually makes good sense.

00:24:25.520 --> 00:24:30.340
We mentioned before that the interpreter
maintains some built-in variables.

00:24:30.340 --> 00:24:33.330
Well, one of the things it does
is when a probe fires,

00:24:33.330 --> 00:24:37.430
it collects the arguments to that
probe and lines them up on arg0,

00:24:37.430 --> 00:24:39.340
1, 2, 3, 4, and 5.

00:24:39.800 --> 00:24:44.200
So here in this predicate,
we've called for arg1 to open.

00:24:44.200 --> 00:24:47.040
And if you remember open,
it has two arguments,

00:24:47.040 --> 00:24:51.190
a path name and then a flags field,
an integer of flags.

00:24:51.200 --> 00:24:57.000
And did a little Boolean arithmetic
with a flag called ononblock.

00:24:57.000 --> 00:25:01.150
So this example looks for all
non-blocking opens that go on

00:25:01.150 --> 00:25:03.320
on the system at any point.

00:25:05.860 --> 00:25:08.800
Action statements.

00:25:08.910 --> 00:25:11.840
Expressions in the D language,
they look a whole lot like C,

00:25:12.030 --> 00:25:15.780
the usual collection of operators.

00:25:16.700 --> 00:25:20.600
You can do assignments to
keep some state around.

00:25:20.600 --> 00:25:22.300
You can make calls to built-in functions.

00:25:22.300 --> 00:25:27.340
We've already seen a little bit of this,
or we will in a moment.

00:25:27.340 --> 00:25:30.700
D has its own version of printf,
so you can produce interesting

00:25:30.700 --> 00:25:33.800
and nicely formatted trace output.

00:25:33.800 --> 00:25:37.800
It's able to take the stack,
the kernel stack,

00:25:37.880 --> 00:25:42.680
with the stack operator and return
that as a vector of numbers.

00:25:42.680 --> 00:25:45.200
It can compute lengths on strings.

00:25:45.200 --> 00:25:49.130
It can do a very interesting and
somewhat mysterious operation

00:25:49.130 --> 00:25:51.510
called copy-in and so forth.

00:25:52.410 --> 00:25:54.530
We've already mentioned
special variables.

00:25:54.660 --> 00:26:00.060
We've seen quite a few of these:
execname, probefunc, arg0 through arg5,

00:26:00.200 --> 00:26:01.180
timestamp.

00:26:01.240 --> 00:26:04.650
Every time a probe fires,
a timestamp is collected,

00:26:04.730 --> 00:26:10.530
and for the duration of that action,
the business between the braces,

00:26:10.730 --> 00:26:15.080
the timestamp is held and
you can compute with it.

00:26:17.350 --> 00:26:19.400
An assignment can create user variables.

00:26:19.440 --> 00:26:21.490
Just another convenience item.

00:26:21.540 --> 00:26:25.550
Just mention the variable assigned
to it and it pops to life.

00:26:26.880 --> 00:26:30.810
So some examples use
of the printf function.

00:26:30.810 --> 00:26:37.100
When Safari makes an open call,
we grab that string argument from open

00:26:37.260 --> 00:26:43.360
that's held in built-in variable arg0,
massage it with the copy inster built in,

00:26:43.360 --> 00:26:47.080
we'll talk about that in a minute,
and then printf it.

00:26:48.920 --> 00:26:53.010
Here we can take that same string and
assign it to a global program variable,

00:26:53.010 --> 00:26:56.690
perhaps to save that name
until a call is made,

00:26:56.840 --> 00:27:00.120
the return from the call is made.

00:27:00.120 --> 00:27:03.070
It might be interesting for some reason.

00:27:03.500 --> 00:27:07.570
and finally it might be interesting
to collect the stack in user land

00:27:07.830 --> 00:27:12.630
where Safari made an open call.

00:27:12.670 --> 00:27:16.390
So let's look at a couple of
examples of how that stuff works.

00:27:28.940 --> 00:27:31.960
So here's a script whose
probe descriptor says,

00:27:31.960 --> 00:27:35.930
I'd like you to place enable
instrumentation at all the open

00:27:35.930 --> 00:27:38.020
syscall entry points in the system.

00:27:38.020 --> 00:27:40.860
There are a couple of variants on open,
and I wanted to make

00:27:40.860 --> 00:27:43.780
sure to catch them all,
so I wildcarded them.

00:27:43.780 --> 00:27:47.770
Open, open Unix 2003 for POSIX support,
so forth.

00:27:47.880 --> 00:27:51.870
And when that probe is encountered,
do the following action.

00:27:52.040 --> 00:27:56.240
Printf the name of the process
that did the open and the name

00:27:56.240 --> 00:27:57.920
of the file that's opened.

00:27:58.100 --> 00:28:00.440
And I put another argument
here I wanted to introduce,

00:28:00.440 --> 00:28:04.290
the -q option, to suppress some of the
labeling information.

00:28:04.300 --> 00:28:07.420
We'll just see the exec name
and the name of the file that's

00:28:07.490 --> 00:28:08.700
being opened when we run this.

00:28:08.760 --> 00:28:11.840
So let's send this off to the races.

00:28:11.890 --> 00:28:14.260
And we can open address book.

00:28:14.300 --> 00:28:15.750
Oh, yeah, cool.

00:28:18.450 --> 00:28:25.850
So in that short sequence of time,
the system opened a

00:28:25.850 --> 00:28:28.020
heck of a lot of files.

00:28:28.020 --> 00:28:30.400
There's address book
getting itself started,

00:28:30.400 --> 00:28:36.160
calls into core data, interesting,
or at least opens the

00:28:36.160 --> 00:28:37.470
framework to get itself going.

00:28:43.880 --> 00:28:45.740
So now let's take a look at
something that's happening

00:28:45.740 --> 00:28:49.490
up in user land with DTrace.

00:29:01.780 --> 00:29:07.370
The user... Oh, I didn't finish the...

00:29:11.730 --> 00:29:14.900
There we go.

00:29:14.900 --> 00:29:19.080
All that for Hello World.

00:29:19.080 --> 00:29:19.080
All right.

00:29:19.080 --> 00:29:19.080
So anyway, here's--

00:29:21.120 --> 00:29:23.740
Here's the familiar Hello World.

00:29:23.750 --> 00:29:27.050
It does the obvious thing.

00:29:27.330 --> 00:29:30.020
Might be interesting to know if,

00:29:30.260 --> 00:29:33.970
In producing that string output,
was memory management called?

00:29:34.020 --> 00:29:36.080
So let's have a look at that.

00:29:40.600 --> 00:29:50.000
[Transcript missing]

00:29:51.210 --> 00:29:54.060
Library Call,
Lib C Library Call is encountered.

00:29:54.100 --> 00:29:54.740
All right.

00:29:54.810 --> 00:29:58.430
Well, this program runs very,
very quickly, and it would be a heck of a

00:29:58.430 --> 00:30:01.760
trick to get DTrace to connect,
to start the program and then

00:30:01.860 --> 00:30:03.480
get DTrace to connect to it.

00:30:03.480 --> 00:30:09.720
So DTrace puts those facilities together,
glues them together by the -c argument.

00:30:09.720 --> 00:30:12.430
So the notion here is DTrace will
do all the language processing,

00:30:12.430 --> 00:30:16.400
compilation, and transferring down to the
virtual machine it needs to do.

00:30:16.400 --> 00:30:20.980
Then it will start hello,
pause it right at the beginning,

00:30:20.980 --> 00:30:25.720
the necessary probes and then let
it run and we'll see what happens.

00:30:29.000 --> 00:30:31.310
And so there we go.

00:30:31.410 --> 00:30:34.120
Hello WWDC was printed.

00:30:34.200 --> 00:30:36.950
Sure enough,
the process exited and then DTrace

00:30:37.050 --> 00:30:38.450
produced the output that it saw.

00:30:38.540 --> 00:30:44.180
Oh, sure enough,
malloc was called here and here's

00:30:44.240 --> 00:30:47.170
the stack that we collected.

00:30:47.170 --> 00:30:47.170
We used the UStack.

00:30:48.100 --> 00:30:53.070
and David Koehn,
and the rest of the team.

00:30:53.070 --> 00:30:54.620
Thank you.

00:30:55.040 --> 00:30:58.780
It might be interesting to know
just how much got malloc'd here.

00:30:58.830 --> 00:31:01.740
That's sort of a simple modification.

00:31:03.030 --> 00:31:05.400
Semicolon, what the heck is C like?

00:31:05.400 --> 00:31:09.630
And we'll trace arg0,
the only arg to malloc,

00:31:09.630 --> 00:31:12.270
which is how much we wanted malloc'd.

00:31:12.520 --> 00:31:13.100
And off we go.

00:31:13.100 --> 00:31:16.040
And yep, sure enough,
there's our stack trace.

00:31:16.060 --> 00:31:18.320
And we were allocating
a page worth of data,

00:31:18.350 --> 00:31:19.580
4,096 bytes.

00:31:19.600 --> 00:31:27.370
Okay, back to the slides, please.

00:31:31.610 --> 00:31:37.690
So a bit more about action statements.

00:31:37.750 --> 00:31:40.730
For kernel hackers,
this is sort of a really interesting

00:31:40.740 --> 00:31:44.380
and important feature of the language.

00:31:44.550 --> 00:31:47.880
If you know the name
of a kernel variable,

00:31:48.160 --> 00:31:51.740
Pre-seed it with a back quote,
and that becomes a variable

00:31:51.740 --> 00:31:54.880
known to the D language.

00:31:58.400 --> 00:32:00.700
You can do structure and array access.

00:32:00.700 --> 00:32:10.040
If proc 0 is known to be the name
of a proc structure in the kernel,

00:32:10.040 --> 00:32:10.040
which it is,

00:32:10.650 --> 00:32:14.620
We can peer into it using the dot
operator in just this fashion.

00:32:14.710 --> 00:32:20.710
If we hold a pointer to a PROC structure,
we can cast it and chase that pointer.

00:32:21.380 --> 00:32:26.680
Here's a more elaborate example of
chasing down a string of a chain of

00:32:26.680 --> 00:32:31.530
pointers and finally doing an array
access on the CR group structure.

00:32:34.240 --> 00:32:37.860
So in all of this,
it's evident that DTrace

00:32:37.860 --> 00:32:40.510
must be symbol savvy,
know where the symbols are,

00:32:40.570 --> 00:32:44.570
and actually understand the types because
it knows how to sort of glom through a

00:32:44.570 --> 00:32:48.440
structure and figure out offsets and know
how to dig in and find particular fields.

00:32:50.570 --> 00:32:53.350
In particular, DTrace has a very deep
knowledge of the Mach kernel.

00:32:53.350 --> 00:32:57.090
It knows every type definition,
the form of every struct and union,

00:32:57.100 --> 00:32:59.850
and every global variable
and external symbol.

00:32:59.910 --> 00:33:03.080
Perhaps you've seen on your
leopard systems down on the

00:33:03.080 --> 00:33:06.260
root of the file system,
/mockkernel.ctfsys.

00:33:06.270 --> 00:33:07.360
That's what that's about.

00:33:07.380 --> 00:33:11.930
That's basically where that information
is collated for use by DTrace.

00:33:13.340 --> 00:33:16.800
In user land, up in user land,
the PID provider,

00:33:16.800 --> 00:33:20.400
courtesy of the magic of
the FastTrap business,

00:33:20.400 --> 00:33:26.560
can deal with unstripped binaries and
find external symbols in your code.

00:33:26.560 --> 00:33:29.320
Just like GDB.

00:33:31.010 --> 00:33:36.470
Furthermore, if you've got types
and structs and unions,

00:33:36.650 --> 00:33:41.250
DTrace with the uppercase C argument
will invoke the preprocessor and

00:33:41.390 --> 00:33:45.020
can bring in your regular C.h files.

00:33:45.020 --> 00:33:48.320
So you can include mytypes.h,
for example.

00:33:48.320 --> 00:33:54.190
And then the D language program
will have full access to the...

00:33:54.890 --> 00:33:59.650
Types, Unions, Structures in MyTypes.h.

00:33:59.650 --> 00:34:02.030
I believe we're on to...

00:34:02.230 --> 00:34:03.590
Oops.

00:34:03.700 --> 00:34:04.150
Ah, yeah.

00:34:04.150 --> 00:34:08.640
So before doing this demo,
I wanted to just set the stage a bit.

00:34:09.120 --> 00:34:13.640
Here's Hello World one more time,
but using a little bit different

00:34:13.640 --> 00:34:15.830
set of libc interfaces.

00:34:15.840 --> 00:34:17.960
These are the file stream interfaces.

00:34:17.960 --> 00:34:22.620
So instead of calling the
sort of the simple printf,

00:34:22.740 --> 00:34:27.660
we're calling fprintf using
the global variable std error,

00:34:27.660 --> 00:34:32.880
which is declared in stdio.h
to be a pointer to type file,

00:34:33.090 --> 00:34:34.280
uppercase.

00:34:34.280 --> 00:34:37.450
And it turns out that
within the file structure,

00:34:37.450 --> 00:34:42.600
there's a little integer field that we'll
try to get our hands on and look at.

00:34:42.620 --> 00:34:47.940
And it'll basically demonstrate
how we can peer into.

00:34:47.960 --> 00:34:51.160
.h files with the D language.

00:34:51.180 --> 00:34:53.860
So here's the script that
we'll use to do that.

00:34:53.860 --> 00:35:00.400
It too includes stdio.h,
sets a probe on the entry to fprintf.

00:35:00.560 --> 00:35:04.560
grabs hold of arg0 when that probe fires.

00:35:04.560 --> 00:35:10.060
That'll be standard error,
the pointer to the file structure.

00:35:10.080 --> 00:35:13.580
We're going to copy that into
the DTrace virtual machine,

00:35:13.620 --> 00:35:17.300
get a pointer to it called pfile,
and then trace out that small

00:35:17.300 --> 00:35:21.070
integer file descriptor that's
held in the underbar file

00:35:21.380 --> 00:35:25.380
component of big file structure.

00:35:25.410 --> 00:35:27.500
Now we're ready for the demo.

00:35:36.450 --> 00:35:40.240
There's the program.

00:35:40.280 --> 00:35:42.280
There's the D.

00:35:43.110 --> 00:35:47.750
And here we'll run this,
again taking advantage of the dash C,

00:35:47.750 --> 00:35:51.600
twice taking advantage of dash C,
both upper case and lower case,

00:35:51.630 --> 00:35:59.760
to both run the preprocessor,
to pull in the definitions in studio,

00:35:59.760 --> 00:35:59.760
fire up Hello Printf,

00:36:00.200 --> 00:36:03.880
See the fprintf entry point encountered.

00:36:03.970 --> 00:36:11.200
Grab arg0 and trace the underbar file,
file ID.

00:36:11.260 --> 00:36:13.600
And sure enough, that's two, right?

00:36:13.630 --> 00:36:15.200
Standard in, standard error.

00:36:15.270 --> 00:36:17.200
Standard out, standard error.

00:36:17.790 --> 00:36:22.560
Zero based.

00:36:22.600 --> 00:36:26.050
All right,
back to the slides one more time.

00:36:34.270 --> 00:36:37.610
So I've sort of been putting
off talking about copy-in,

00:36:37.610 --> 00:36:43.530
and actually a good way to do that is
to take sort of the broad principles

00:36:43.530 --> 00:36:49.060
of operation picture of DTrace,
sort of the structure and

00:36:49.060 --> 00:36:51.070
interpretation of D programs.

00:36:51.070 --> 00:36:54.870
It goes something like this.

00:36:56.090 --> 00:36:59.430
We have a D program, a script, a file,
or perhaps something right on the

00:36:59.510 --> 00:37:04.000
command line that we feed into
the DTrace command line program.

00:37:04.110 --> 00:37:06.750
It does its language processing.

00:37:07.650 --> 00:37:14.190
passes that down into the in
kernel DTrace virtual machine.

00:37:16.620 --> 00:37:22.890
Where the actions are stored off,
the probes are analyzed,

00:37:23.330 --> 00:37:27.940
The subject matter expert is consulted,
in this case FastTrap.

00:37:27.960 --> 00:37:32.240
We're trying to reach up into
user land and set a probe in libc.

00:37:32.280 --> 00:37:37.150
Everything gets prepared.

00:37:39.330 --> 00:37:41.530
HelloFP starts to run.

00:37:41.730 --> 00:37:45.210
The trap has been set by FastTrap.

00:37:46.360 --> 00:37:51.740
Printf gets called,
passing as arg0 std::er,

00:37:51.740 --> 00:37:55.620
a pointer to a file structure.

00:37:55.700 --> 00:37:58.900
At that point, FastTrap takes over.

00:38:01.310 --> 00:38:05.350
jumps into the interpreter in
the virtual machine and the

00:38:05.440 --> 00:38:07.680
action begins to be executed.

00:38:07.820 --> 00:38:09.780
What's the action?

00:38:09.930 --> 00:38:11.820
Copy in.

00:38:12.530 --> 00:38:16.360
From the given pointer in user land,
that file structure is up

00:38:16.500 --> 00:38:20.030
there in your address space,
copy that somewhere into

00:38:20.030 --> 00:38:23.590
the D virtual machine,
88 bytes worth.

00:38:26.200 --> 00:38:28.280
There we go.

00:38:28.280 --> 00:38:30.950
So now in the same virtual,
the same address space,

00:38:30.960 --> 00:38:34.700
the same DTrace virtual machine
as the action that's running,

00:38:34.710 --> 00:38:36.960
we now have the file structure.

00:38:36.960 --> 00:38:43.150
We now hold a pointer to it,
we can dereference it

00:38:43.150 --> 00:38:43.150
and trace the value out,
spitting it back out.

00:38:45.020 --> 00:38:48.900
If that made sense to you,
you've just cleared the biggest hurdle

00:38:48.900 --> 00:38:50.400
in understanding how DTrace works.

00:38:50.490 --> 00:38:53.080
That's the model to keep in your head,
and it will keep you out

00:38:53.080 --> 00:38:56.870
of all sorts of trouble,
and I think make your development as

00:38:56.870 --> 00:39:00.700
a deprogrammer go much more quickly.

00:39:02.000 --> 00:39:06.220
A few more words about
language components.

00:39:06.220 --> 00:39:07.600
Variables.

00:39:07.630 --> 00:39:10.470
Globals like foo and bar,
you just mention them, they come to life,

00:39:10.560 --> 00:39:12.620
they have global scope.

00:39:13.490 --> 00:39:19.270
Here we actually do declare one just
for documentation purposes or whatnot,

00:39:19.280 --> 00:39:20.600
and for initialization.

00:39:20.600 --> 00:39:26.970
We initialize first open to be zero,
and this probe will fire when the open

00:39:27.040 --> 00:39:31.630
system call is encountered by Perl,
an execution of Perl,

00:39:31.630 --> 00:39:35.990
and it's the very first
open that Perl has done.

00:39:36.430 --> 00:39:38.840
After that,
first open gets assigned a timestamp,

00:39:38.840 --> 00:39:42.370
which is usually a non-zero value,
and that probe will no longer pass

00:39:42.850 --> 00:39:45.390
into its action phase if fired.

00:39:45.390 --> 00:39:47.690
It'll be filtered out.

00:39:51.510 --> 00:39:53.060
There are thread local variables.

00:39:53.060 --> 00:39:57.090
It may be interesting as threads
course through the system,

00:39:57.090 --> 00:40:00.740
different system calls,
different points in your code,

00:40:00.740 --> 00:40:04.370
to collect information and maintain
that state through the lifetime

00:40:04.410 --> 00:40:06.200
of the execution of a thread.

00:40:06.330 --> 00:40:10.530
Those are denoted by
the self arrow prefix.

00:40:11.670 --> 00:40:12.800
And here's an example.

00:40:13.010 --> 00:40:18.240
So again using the system call provider,
when Perl calls open

00:40:18.240 --> 00:40:22.200
on a particular thread,
a little piece of state that's forever

00:40:22.200 --> 00:40:27.180
associated with that thread called
self numThreadOpens is incremented.

00:40:27.300 --> 00:40:31.180
So there may be other threads that
Perl spawns doing other opens.

00:40:31.290 --> 00:40:34.760
These will be kept sorted out.

00:40:38.910 --> 00:40:41.700
There are also probe local variables.

00:40:41.730 --> 00:40:45.040
These are introduced by
the prefix this arrow.

00:40:45.100 --> 00:40:50.290
They're basically alive for
the extent of the curly braces.

00:40:50.590 --> 00:40:51.770
After that, they disappear.

00:40:51.990 --> 00:40:53.750
Useful for intermediate computations.

00:40:53.790 --> 00:40:57.610
You just want to hold some computation,
not have to repeat it.

00:40:57.610 --> 00:40:59.850
Just introduce a local variable.

00:41:04.860 --> 00:41:09.110
OK, so sort of orthogonal to
the scoping are the shapes.

00:41:09.150 --> 00:41:11.120
I've seen a bunch of scalars.

00:41:11.120 --> 00:41:14.990
The global foo,
the thread local self bar,

00:41:15.590 --> 00:41:18.620
probe local call this baz.

00:41:18.650 --> 00:41:22.010
Talked a little bit
about associative arrays.

00:41:22.330 --> 00:41:26.950
Use the familiar square brackets,
but the key value there, in this case,

00:41:26.950 --> 00:41:32.790
FD,
can be any type known to the D language.

00:41:35.530 --> 00:41:38.040
And then we have aggregations.

00:41:38.100 --> 00:41:41.930
These look like associative arrays,
but are introduced with the @ sign.

00:41:42.100 --> 00:41:45.290
A very special purpose in D.

00:41:46.190 --> 00:41:51.330
As I mentioned, hinted at earlier,
the problem that needs to be solved

00:41:51.710 --> 00:41:56.000
We've got multiple processors
running simultaneously.

00:41:56.040 --> 00:41:59.950
We could have identical probes
fire essentially at the same

00:41:59.990 --> 00:42:02.690
time on all those processors.

00:42:03.100 --> 00:42:07.790
How do we arbitrate access to the
state we're trying to collect?

00:42:08.120 --> 00:42:10.290
How do we keep one
coherent copy of the state?

00:42:10.290 --> 00:42:12.370
Well,
we've kind of fudged it a little bit,

00:42:12.370 --> 00:42:17.640
and we use something that's familiar
from big MP scientific programs,

00:42:17.640 --> 00:42:18.800
use a reduction operator.

00:42:19.190 --> 00:42:23.440
Basically, we can maintain copies of
that state on each processor,

00:42:23.440 --> 00:42:26.740
not have to worry about
arbitrating between it,

00:42:26.810 --> 00:42:29.580
but we can only do specific
kinds of functions,

00:42:30.520 --> 00:42:35.540
make specific kinds of arithmetic
updates to that state that can eventually

00:42:35.710 --> 00:42:40.660
be combined at the bottom to reduce,
well, it's a reduction operator,

00:42:40.660 --> 00:42:45.430
to produce the values we're looking for.

00:42:48.440 --> 00:42:51.300
These are the arithmetic
functions that are permitted.

00:42:51.360 --> 00:42:54.890
They all have this
property that they can be

00:42:56.100 --> 00:42:59.670
The DTrace is a powerful
software tracing tool.

00:42:59.670 --> 00:43:04.930
Learn how to interact directly with
DTrace using command line tools.

00:43:04.930 --> 00:43:09.250
See how DTrace scripts can be
used to understand the runtime

00:43:09.300 --> 00:43:14.200
behavior of an application,
the kernel, or the entire system.

00:43:14.200 --> 00:43:18.570
See how DTrace scripts can be
used to understand the runtime

00:43:18.570 --> 00:43:23.980
behavior of an application,
the kernel, or the entire system.

00:43:24.040 --> 00:43:25.860
A valuable session for
all Mac OS X developers.

00:43:26.030 --> 00:43:33.210
See how DTrace scripts can be
used to understand the runtime

00:43:33.210 --> 00:43:41.430
behavior of an application,
the kernel, or the entire system.

00:43:48.350 --> 00:43:52.300
So an interesting Unix function is MMAP.

00:43:52.300 --> 00:43:57.680
It asks the kernel to give us
some new piece of virtual memory,

00:43:57.790 --> 00:44:00.380
perhaps backed by a file,
perhaps just anonymous

00:44:00.380 --> 00:44:01.300
zero-filled memory.

00:44:01.300 --> 00:44:05.300
It's going on all the
time on these systems.

00:44:05.300 --> 00:44:10.000
It would not be unusual to see
MMAPs firing simultaneously

00:44:10.000 --> 00:44:12.300
on multiple processors.

00:44:12.300 --> 00:44:15.580
Suppose we wanted to just sort of
sum up what all the MMAP activity

00:44:15.700 --> 00:44:17.220
going on on the system was.

00:44:17.420 --> 00:44:19.300
Here's one way to get after that.

00:44:19.300 --> 00:44:21.250
It uses aggregates, of course.

00:44:21.890 --> 00:44:25.180
So the probe descriptor
syscall mmap entry.

00:44:25.300 --> 00:44:31.100
We're going to collect in an aggregation
introduced by the at sign the sum of

00:44:31.240 --> 00:44:32.970
the first argument passed to mmap.

00:44:33.070 --> 00:44:34.410
That's how much we want to map.

00:44:34.480 --> 00:44:39.340
And we're going to sort of
index that by the name of the

00:44:39.340 --> 00:44:42.060
process that did the mmap.

00:44:42.110 --> 00:44:43.740
So off we go.

00:44:43.740 --> 00:44:45.060
Let's see.

00:44:45.140 --> 00:44:50.010
Let's open up address
book again and quit that.

00:44:50.280 --> 00:44:51.770
Come back here and see what we got.

00:44:53.900 --> 00:44:57.540
So again, on the far side,
the name of the process

00:44:57.960 --> 00:44:59.970
where the probe fired.

00:45:00.120 --> 00:45:02.840
The side closer to me,
the aggregate sum across all

00:45:02.840 --> 00:45:07.980
eight processors on this machine
of the sizes of the M-MAP calls

00:45:07.980 --> 00:45:10.160
aggregated together and summed.

00:45:10.420 --> 00:45:14.270
Address book weighing in at
a little bit more than 74

00:45:14.270 --> 00:45:16.930
megabytes to get itself started.

00:45:16.930 --> 00:45:21.540
And I wonder if MDS also started
up something afresh here since

00:45:21.540 --> 00:45:23.060
it has just about the same size.

00:45:23.060 --> 00:45:27.970
I suspect that's the mapping in of the
frameworks mainly that we're seeing.

00:45:32.710 --> 00:45:35.960
So there's a big number,
sort of the big sum.

00:45:36.020 --> 00:45:38.270
Suppose we wanted to look a
little bit more carefully at

00:45:38.270 --> 00:45:41.010
the distribution of MMAP sizes.

00:45:41.020 --> 00:45:46.690
Are we seeing lots of small ones,
a bimodal, a trimodal mixture?

00:45:46.920 --> 00:45:48.530
Let's take a look.

00:45:49.000 --> 00:45:50.940
Clear the screen.

00:45:51.090 --> 00:45:55.460
And here we'll use the
quantize aggregate operator.

00:45:56.820 --> 00:45:59.750
Same probe points,
collected the same way,

00:45:59.820 --> 00:46:03.690
but the function that we're using
on each of the eight processors

00:46:04.600 --> 00:46:08.900
is collect the distribution,
and at the end we'll bring those

00:46:09.020 --> 00:46:10.970
together to present them on the screen.

00:46:12.110 --> 00:46:14.760
So off we go.

00:46:14.760 --> 00:46:16.240
Address book again.

00:46:16.240 --> 00:46:17.630
Workhorse.

00:46:17.680 --> 00:46:18.290
Quit that.

00:46:18.390 --> 00:46:19.050
Come back here.

00:46:19.100 --> 00:46:19.950
Bloop.

00:46:19.950 --> 00:46:20.500
All right.

00:46:20.630 --> 00:46:23.230
If you turn your head sideways,
what you get is a little

00:46:23.390 --> 00:46:28.630
histogram with sort of binary,
binarily growing bin

00:46:28.630 --> 00:46:34.600
sizes that tell us that,
well, address book made about 49

00:46:34.600 --> 00:46:38.240
MMAP calls for 131K chunks.

00:46:38.240 --> 00:46:44.310
It made 81 for 16K chunks and so forth.

00:46:44.450 --> 00:46:49.580
And it's actually sorted this out by all
the processes that were running on the

00:46:49.580 --> 00:46:53.540
system and making MMAP calls at the time.

00:46:53.540 --> 00:46:56.070
It looks like address
book was making the most.

00:46:56.070 --> 00:46:57.800
Sure, it was being launched.

00:46:57.890 --> 00:46:59.970
One might expect.

00:47:04.400 --> 00:47:09.900
[Transcript missing]

00:47:16.040 --> 00:47:20.830
Key value to an associative
array can be quite complicated.

00:47:20.860 --> 00:47:25.260
Here it's the vector of addresses that,
first six addresses

00:47:25.260 --> 00:47:26.860
that appear in a stack.

00:47:26.920 --> 00:47:33.470
So it's possible to focus in on where
particular M-Map calls are being made.

00:47:34.300 --> 00:47:35.820
Let's look and see how that works.

00:47:35.870 --> 00:47:40.860
It's probably easier
seen than spoken over.

00:47:40.870 --> 00:47:41.970
One more time.

00:47:41.980 --> 00:47:45.480
Let's use Safari this time.

00:47:45.490 --> 00:47:48.760
Maybe we'll see some places we recognize.

00:47:49.700 --> 00:47:58.280
So we get this collection of backtraces,
six deep, right?

00:47:58.310 --> 00:48:00.340
We asked for six deep user stack traces.

00:48:00.340 --> 00:48:06.540
Size organized by the amount
of MMAP activity that took

00:48:06.540 --> 00:48:09.780
place at that stack site,
at that call site.

00:48:10.630 --> 00:48:26.690
And as a bonus,
the stack's been symbolicated.

00:48:26.690 --> 00:48:26.690
So here, looks like the LibC malloc has
asked for about 16 megabytes.

00:48:26.690 --> 00:48:26.690
I happen to know that's two
zones of a particular kind.

00:48:27.080 --> 00:48:32.710
Cash FM Map Data,
called into MMap from Carbon Core,

00:48:33.060 --> 00:48:36.130
asked for another guy who
wants 16 megabytes of data,

00:48:36.200 --> 00:48:36.920
and so forth.

00:48:36.920 --> 00:48:42.030
So this is a very powerful facility,
allowing...

00:48:42.460 --> 00:48:44.570
You know,
sort of really interesting compositing

00:48:44.590 --> 00:48:50.340
of data across all machines,
sort of filtered on a process of

00:48:50.730 --> 00:48:53.720
interest and displayed in a...

00:48:53.840 --> 00:48:56.770
Sort of immediate attention grabbing way,
you know, you get to see the big numbers

00:48:56.770 --> 00:48:58.580
at the bottom right away.

00:48:58.580 --> 00:48:59.080
This is good.

00:48:59.080 --> 00:49:01.480
Sure.

00:49:08.200 --> 00:49:11.980
So the key thing here was we were able
to use something quite complicated as

00:49:12.000 --> 00:49:15.170
the key value to this associative array.

00:49:16.800 --> 00:49:20.460
Every time that key appeared again,
every time that call

00:49:20.460 --> 00:49:24.700
stack was run through,
made the Nmap call the identical place,

00:49:24.830 --> 00:49:26.770
the sum got added into there.

00:49:26.850 --> 00:49:28.330
Could have happened on
any of the processors,

00:49:28.400 --> 00:49:30.730
could have happened simultaneously,
it's all taken care

00:49:30.730 --> 00:49:32.060
of by the aggregation.

00:49:32.360 --> 00:49:36.210
At the end,
all that's pulled together and we

00:49:36.210 --> 00:49:42.780
get these big numbers that order the
particular chunks of stack traces.

00:49:42.860 --> 00:49:45.170
Back to the slides, please.

00:49:51.060 --> 00:49:52.940
So a change of gears here.

00:49:52.950 --> 00:49:57.350
By this point,
I expect everybody will be a

00:49:57.350 --> 00:50:01.450
fruitful DTrace programmer,
at least understand the

00:50:01.960 --> 00:50:05.460
elements of the D language.

00:50:05.760 --> 00:50:10.160
A lot of work has been done in
creating the DTrace toolkit to sort

00:50:10.160 --> 00:50:12.880
of move you along even more quickly.

00:50:12.960 --> 00:50:15.380
So the toolkit is freeware.

00:50:15.420 --> 00:50:18.120
It was made for Solaris,
but we found that many of

00:50:18.130 --> 00:50:21.600
the scripts were interesting,
useful, and appropriate for Mac OS X,

00:50:21.600 --> 00:50:25.660
so we were able to quickly
port them for Leopard.

00:50:26.240 --> 00:50:29.540
These are just handy analysis
tools for common investigations,

00:50:29.560 --> 00:50:33.110
just like the things we've been
doing throughout this hour.

00:50:35.110 --> 00:50:40.580
They consist of DTrace scripts handed
directly to the DTrace interpreter,

00:50:40.580 --> 00:50:45.000
or D scripts wrapped by shell
scripts that do some argument

00:50:45.000 --> 00:50:47.790
marshaling and pretty printing.

00:50:48.490 --> 00:50:49.550
They're easily customized.

00:50:49.560 --> 00:50:51.590
The source is present on the system.

00:50:51.590 --> 00:50:54.740
You can look at them, copy them,
customize them.

00:50:54.810 --> 00:50:55.390
Browse and learn.

00:50:55.400 --> 00:51:01.030
They're a great way to learn sort of
the deeper techniques in deprogramming.

00:51:01.040 --> 00:51:03.540
We've got 46 of these
things on the system now.

00:51:03.540 --> 00:51:04.970
They sit in user bin.

00:51:05.100 --> 00:51:09.260
Got man pages, examples, and

00:51:10.230 --> 00:51:12.730
Here's the roster.

00:51:12.820 --> 00:51:15.280
Not expected to remember that.

00:51:15.330 --> 00:51:18.940
What would be helpful to remember is
that among the most useful of these

00:51:18.940 --> 00:51:22.510
scripts is somebody called DTrace.

00:51:22.880 --> 00:51:29.600
This is sort of a Solaris
history around the name trust.

00:51:29.600 --> 00:51:31.860
It's a way to look at system calls.

00:51:31.890 --> 00:51:34.040
Works just fine on Mac OS X.

00:51:34.050 --> 00:51:35.320
Name of the command is DTrace.

00:51:35.360 --> 00:51:39.420
You give it the -h argument
it describes itself.

00:51:39.440 --> 00:51:41.940
And it's a way to get after system calls.

00:51:41.970 --> 00:51:43.720
And you can get--

00:51:44.160 --> 00:51:48.560
information filtered down by process ID,
by process name,

00:51:48.560 --> 00:51:52.830
or actually execute a command
directly by DTrace and watch

00:51:52.830 --> 00:51:55.190
all its system call activity.

00:51:55.190 --> 00:52:01.310
So you know underneath the covers there's
a DTrace minus C lurking somewhere.

00:52:05.650 --> 00:52:09.200
You can drill down and look
at just one system call.

00:52:09.200 --> 00:52:15.790
We can aggregate using the little dash
lowercase c option to get call counts

00:52:15.840 --> 00:52:21.400
aggregated by the probe function,
the particular system call.

00:52:21.980 --> 00:52:28.050
And here's a convenient way to catch
times going in and out of system calls.

00:52:28.080 --> 00:52:31.050
The D, E, and O options.

00:52:36.320 --> 00:52:38.660
And finally,
you might want to catch the stack

00:52:38.660 --> 00:52:42.790
back traces in your program where
the system calls are being made from,

00:52:42.800 --> 00:52:44.240
minus S.

00:52:44.240 --> 00:52:47.430
So you know there's a stack action
somewhere buried underneath this.

00:52:47.440 --> 00:52:53.000
Okay, last demo of the afternoon is
to take a quick look at DTrace.

00:52:58.300 --> 00:52:59.300
Let's see what it's doing.

00:52:59.300 --> 00:53:01.850
I've got to get that out of the way.

00:53:01.860 --> 00:53:03.730
Clear this.

00:53:06.530 --> 00:53:09.620
So here's DTrace.

00:53:09.670 --> 00:53:12.720
We're going to filter down to
just look at what the doc is

00:53:12.720 --> 00:53:15.040
doing in terms of system calls.

00:53:15.090 --> 00:53:17.610
And at the end,
we'd like to aggregate and just get

00:53:17.670 --> 00:53:23.230
a rough summary of where the system,
how many system calls are being made.

00:53:23.360 --> 00:53:26.220
So let's make the doc do something.

00:53:26.250 --> 00:53:28.860
So tell me about, whoa,
just even touching the thing,

00:53:28.910 --> 00:53:33.910
even touching it, sets off a wonderful
collection of system calls.

00:53:34.410 --> 00:53:36.300
Can you fan that up for me?

00:53:36.300 --> 00:53:36.800
Great.

00:53:36.800 --> 00:53:36.990
All right.

00:53:37.080 --> 00:53:39.300
So there's a bunch going on here.

00:53:39.300 --> 00:53:43.900
And if we quit this, sure enough,
interesting,

00:53:43.900 --> 00:53:49.060
we see maps and unmaps as the most
frequent system call made in that short

00:53:49.140 --> 00:53:51.910
interval of time working with the doc.

00:53:51.960 --> 00:53:53.790
Cool.

00:53:53.830 --> 00:53:53.940
All right.

00:53:53.940 --> 00:53:59.700
Back to the slides for a few more words.

00:54:01.900 --> 00:54:05.050
Sort of a taxonomy of
the DTrace providers,

00:54:05.090 --> 00:54:07.000
just to sum up here.

00:54:07.060 --> 00:54:13.440
The PID and Objective-C providers,
we can see function entry points,

00:54:13.440 --> 00:54:14.590
returns, and

00:54:14.900 --> 00:54:24.900
[Transcript missing]

00:54:25.770 --> 00:54:29.930
It's possible to place
prepositioned probes in your

00:54:29.930 --> 00:54:32.340
frameworks and your programs.

00:54:32.340 --> 00:54:37.510
These are called user static probes,
much like the core data probe

00:54:37.510 --> 00:54:39.740
I showed at the very outset.

00:54:39.920 --> 00:54:41.540
There's a bit more to
be learned about that.

00:54:41.590 --> 00:54:45.610
Go see the advanced talk in session 935.

00:54:45.840 --> 00:54:48.930
All those are courtesy
of the FastTrap provider.

00:54:49.790 --> 00:54:53.100
There's a profile provider that
lets you do statistical sampling.

00:54:53.100 --> 00:54:57.950
Basically it fires off at a fixed
rate and when the probe fires you

00:54:57.950 --> 00:55:02.620
can collect a stack for example and
see what's going on in the system.

00:55:02.890 --> 00:55:05.220
collects some timestamp data of interest.

00:55:05.360 --> 00:55:11.240
PLockstat, the locking statistics for
the userland Pthread library.

00:55:11.370 --> 00:55:15.650
And finally, in a variety of open
source software packages,

00:55:15.650 --> 00:55:19.040
we're seeing prepositioned probe
points to learn interesting

00:55:19.040 --> 00:55:22.160
things about the behavior of Perl,
Python, and Ruby.

00:55:22.160 --> 00:55:25.900
So you can see how your Perl
scripts are behaving and so forth.

00:55:27.490 --> 00:55:29.530
Down in the kernel,
we've talked a great deal

00:55:29.530 --> 00:55:31.150
about the system call provider.

00:55:31.250 --> 00:55:35.580
There's sort of a complementary facility
for the Mach side of our kernel.

00:55:35.580 --> 00:55:38.350
Mach defines some traps
like Mach message send,

00:55:38.350 --> 00:55:39.840
Mach message receive.

00:55:39.840 --> 00:55:45.300
Mach trap is a provider that
can enable and show some

00:55:45.330 --> 00:55:49.210
information about those probes.

00:55:49.700 --> 00:55:53.080
And the FBT provider,
which we didn't exercise at all today,

00:55:53.080 --> 00:55:58.000
but offers very deep,
detailed information into the behavior

00:55:58.000 --> 00:56:02.210
of the kernel by instrumenting all
the C entry points and returns,

00:56:02.220 --> 00:56:04.460
or nearly all the C entry
points and returns.

00:56:06.520 --> 00:56:11.160
The proc provider based in the
kernel gives interesting insight

00:56:11.160 --> 00:56:17.560
into the life events of a process,
process start, process exit,

00:56:17.580 --> 00:56:19.000
process waiting.

00:56:19.000 --> 00:56:23.430
I/O, start and finish times and
volume of I/O being conducted,

00:56:23.600 --> 00:56:29.310
VM info, virtual memory system,
lock stat, internal kernel lock.

00:56:30.070 --> 00:56:32.960
So to summarize,
what I hope you've gotten out of

00:56:33.020 --> 00:56:38.790
this talk is that DTrace engenders an
approach that's to tracing and diagnosis

00:56:38.790 --> 00:56:42.650
and observing that's incremental,
it's exploratory, improvisational,

00:56:42.720 --> 00:56:43.290
quite a bit of fun.

00:56:43.340 --> 00:56:47.910
It's just great to dive into your
system in interesting and new ways.

00:56:48.490 --> 00:56:51.220
Aggregation is an
enormously powerful tool.

00:56:51.420 --> 00:56:55.180
It very, very quickly

00:56:56.000 --> 00:57:08.220
Cuts and Dices the information in
a way that makes it digestible.

00:57:08.220 --> 00:57:08.220
Often just looking at the bottom
few entries of an aggregate can

00:57:08.220 --> 00:57:08.220
tell you quite a bit about a
question you have about the system.

00:57:09.020 --> 00:57:13.300
You'll find all these DTrace
facilities in Leopard and Snow Leopard.

00:57:13.340 --> 00:57:17.790
And for more information,
consult these sources.
WEBVTT

00:00:20.330 --> 00:00:20.630
Good morning.

00:00:20.640 --> 00:00:27.490
So this morning, Tuesday of WWDC,
we're going to actually start

00:00:27.490 --> 00:00:28.300
into some of our sessions.

00:00:28.300 --> 00:00:32.040
And this one is getting
started with OpenGL on the Mac.

00:00:32.100 --> 00:00:38.130
And it's an interesting session
because it talks to a few audiences.

00:00:38.240 --> 00:00:41.490
It doesn't talk to someone
specifically who's really

00:00:41.490 --> 00:00:44.350
experienced on the Mac or really
experienced with OpenGL on the Mac,

00:00:44.460 --> 00:00:47.450
but it does talk to people
both who are new to the Mac or

00:00:47.670 --> 00:00:49.010
maybe who are new to OpenGL.

00:00:49.020 --> 00:00:50.220
So I'm Jeff Stahl.

00:00:50.220 --> 00:00:53.210
I work in GPU software,
and I'll be taking you

00:00:53.210 --> 00:00:54.910
through our session today.

00:00:56.440 --> 00:00:59.160
So the first thing we're going to
talk about really is what is OpenGL.

00:00:59.160 --> 00:01:01.650
So there may be some of you in the
audience who are experienced with

00:01:01.650 --> 00:01:03.240
OpenGL who actually know what it is.

00:01:03.280 --> 00:01:05.310
In this case, it will just be a little
bit of a refresher.

00:01:05.310 --> 00:01:06.870
Talk about why use it.

00:01:06.890 --> 00:01:10.870
We'll go into some reasons why OpenGL is
interesting both from a 3D games

00:01:11.050 --> 00:01:13.620
aspect or from a 2D application aspect.

00:01:13.620 --> 00:01:17.610
Because I think that one thing you
saw yesterday from the keynote and

00:01:17.610 --> 00:01:21.290
the State of the Union addresses
is that OpenGL is really a great

00:01:21.330 --> 00:01:25.300
way to get accelerated graphics,
not just how to do 3D games.

00:01:25.620 --> 00:01:27.460
Then I'm going to talk
about learning OpenGL.

00:01:27.480 --> 00:01:29.590
So the folks in here who
may not know OpenGL at all,

00:01:29.590 --> 00:01:32.730
I'll give you some resources,
point you in the right direction.

00:01:32.850 --> 00:01:35.630
So after this session,
which you've taken some nuggets,

00:01:35.630 --> 00:01:38.850
but really you're not going to
remember every single thing I say.

00:01:38.850 --> 00:01:41.550
You'll have places to go to
find the information you need

00:01:41.590 --> 00:01:43.580
to work with OpenGL on Mac OS X.

00:01:43.580 --> 00:01:46.890
And taking this session,
combining it with the session this

00:01:46.890 --> 00:01:50.830
afternoon on OpenGL ES on the iPhone,
I think you'll have a great start on

00:01:50.830 --> 00:01:53.260
working on OpenGL ES on the iPhone also.

00:01:54.840 --> 00:01:58.960
So next thing I'll go into is a little
bit of an intermediate level topics.

00:01:59.040 --> 00:02:02.240
We're talking about platform
specific data and things you

00:02:02.240 --> 00:02:05.620
need to know to really get
started with OpenGL on the Mac.

00:02:05.710 --> 00:02:08.340
A little bit about the architecture
on the Mac OS X where it may be

00:02:08.340 --> 00:02:09.860
different than other platforms.

00:02:09.940 --> 00:02:13.080
A little bit on OpenGL ES on
the iPhone to kind of get you

00:02:13.200 --> 00:02:14.930
prepped for this afternoon.

00:02:14.930 --> 00:02:15.830
At 5 p.m.

00:02:15.830 --> 00:02:18.220
we have a session specifically on that.

00:02:18.220 --> 00:02:21.350
And then finally,
I'll finish up with some techniques

00:02:21.530 --> 00:02:24.020
that involve combining the
Mac OS API with OpenGL ES on the iPhone.

00:02:24.060 --> 00:02:26.260
with OpenGL and talk about our tools.

00:02:27.900 --> 00:04:48.900
[Transcript missing]

00:04:49.380 --> 00:04:51.380
So OpenGL, what does it do?

00:04:51.380 --> 00:04:56.620
The basic thing that OpenGL does,
it takes vertices, transforms them,

00:04:56.620 --> 00:05:00.030
applies visual operations
and outputs a fragment.

00:05:00.040 --> 00:05:02.230
And that's going to be a little bit
different than we talk about later in

00:05:02.230 --> 00:05:03.400
the week when we talk about OpenCL.

00:05:03.400 --> 00:05:07.560
Because OpenGL really has
this many-to-one or this

00:05:07.560 --> 00:05:09.800
gather kind of concept.

00:05:09.800 --> 00:05:12.820
We take vertices,
determine where the vertices will

00:05:12.900 --> 00:05:16.950
be on the screen from 3D space to 2D
space or from 2D space to 2D space if

00:05:16.960 --> 00:05:19.800
you're just working in two dimensions.

00:05:19.960 --> 00:05:22.640
And then we actually determine
what fragments that covers and

00:05:22.660 --> 00:05:24.790
OpenGL iterates across those fragments.

00:05:24.800 --> 00:05:26.800
So let's see actually how that looks.

00:05:26.800 --> 00:05:30.710
So we take something,
this kind of zoom-in shot from Modo,

00:05:30.790 --> 00:05:33.130
from Luxology,
and let's look at kind of what you

00:05:33.190 --> 00:05:34.700
would think about this in 3D space.

00:05:34.800 --> 00:05:35.800
So you have a grid.

00:05:35.800 --> 00:05:39.800
You have a grid of polygons
that cover this in 3D space.

00:05:39.800 --> 00:05:41.800
These are the vertices you send in.

00:05:41.800 --> 00:05:43.800
And if we zoom in on one
little area right here,

00:05:43.860 --> 00:05:47.280
we can see from the triangle standpoint,
there's this one triangle

00:05:47.280 --> 00:05:48.800
we're going to focus on.

00:05:48.880 --> 00:05:50.740
That triangle is sent in in 3D space.

00:05:50.850 --> 00:05:52.730
It's transformed to be 2D space.

00:05:52.800 --> 00:05:55.800
So instead of thinking of
that triangle as perspective,

00:05:55.800 --> 00:06:00.800
actually think of it as the pixels
it covers relative to your viewpoint.

00:06:00.800 --> 00:06:03.800
So what that comes out is you have,
there's a triangle.

00:06:03.970 --> 00:06:06.660
And those are the actual pixels
that make up that triangle.

00:06:06.900 --> 00:06:09.770
And what OpenGL does is it
actually iterates across those.

00:06:09.830 --> 00:06:11.800
It's iterating across
each one of those pixels,

00:06:11.800 --> 00:06:13.800
taking the texture coordinates
that you've passed in

00:06:13.800 --> 00:06:17.620
when you drew this image,
and it actually colorizes each

00:06:17.620 --> 00:06:19.800
pixel based on the texture lookup.

00:06:19.800 --> 00:06:23.740
It's actually, when you break it down,
a pretty simple operation.

00:06:23.800 --> 00:06:27.250
I mean, it takes,
it does linear math on a set of

00:06:27.250 --> 00:06:29.800
vertices to convert to 2D space.

00:06:29.840 --> 00:06:33.720
And then it interpolates from one
end to the other and draws colors.

00:06:33.800 --> 00:06:34.800
That's all it really does.

00:06:34.800 --> 00:06:36.800
It happens that the
colors have meaning to us.

00:06:36.800 --> 00:06:39.800
That the 3D graphics
we have have meaning.

00:06:39.800 --> 00:06:44.490
putting those all in the 2D space really
gives you the picture you're expecting.

00:06:45.030 --> 00:06:47.370
So, moving on, let's look at OpenGL ES.

00:06:47.500 --> 00:06:48.510
So we know what OpenGL is.

00:06:48.510 --> 00:06:50.930
What's different about OpenGL ES?

00:06:51.050 --> 00:06:54.020
Why is OpenGL ES different
and why is it not in OpenGL?

00:06:54.020 --> 00:06:56.680
Well,
OpenGL ES has a specific purpose in life

00:06:56.760 --> 00:07:00.770
and that's to support embedded systems,
obviously the OpenGL ES.

00:07:00.770 --> 00:07:04.480
It's actually a reduced form of OpenGL.

00:07:04.920 --> 00:07:09.160
It takes some OpenGL 1.5
and it kind of optimizes it.

00:07:09.290 --> 00:07:13.310
It takes out some of the kind of
crufty older stuff and makes it so it

00:07:13.390 --> 00:07:15.240
really fits well on embedded systems.

00:07:15.240 --> 00:07:19.220
You'll find that many apps,
if you write a modern OpenGL app,

00:07:19.230 --> 00:07:22.570
it'll work very well in
OpenGL ES in most cases.

00:07:22.580 --> 00:07:25.970
And we'll talk about that today,
how you can go from an OpenGL app,

00:07:26.020 --> 00:07:30.220
or we'll talk about it later today,
this afternoon, go from an OpenGL app

00:07:30.220 --> 00:07:31.570
to an OpenGL ES app.

00:07:32.840 --> 00:07:35.220
It removes some redundant
pieces of the API.

00:07:35.220 --> 00:07:38.250
Obviously,
OpenGL evolves over time and ES had a

00:07:38.250 --> 00:07:40.210
nice idea of it could take a snapshot.

00:07:40.220 --> 00:07:43.380
It could say, okay,
what do we want from this piece of time?

00:07:43.380 --> 00:07:44.550
And it could say, we don't need this.

00:07:44.670 --> 00:07:46.600
This has already been superseded
by other things we have.

00:07:46.600 --> 00:07:47.940
So it could remove those at a time.

00:07:47.940 --> 00:07:50.640
And also,
the one important thing about OpenGL ES,

00:07:50.640 --> 00:07:53.550
it doesn't require some
kind of software fallback.

00:07:53.560 --> 00:07:55.550
So in almost every case,
you can assume your hardware

00:07:55.590 --> 00:07:57.280
accelerated on your embedded platform.

00:07:57.280 --> 00:08:00.640
So a little bit, OpenGL ES,
same as OpenGL, kind of in mindset,

00:08:00.660 --> 00:08:02.560
a little bit different in focus.

00:08:02.720 --> 00:08:03.780
Thank you.

00:08:05.600 --> 00:08:06.400
So what is OpenCL?

00:08:06.400 --> 00:08:07.740
We talked about OpenCL yesterday.

00:08:07.740 --> 00:08:10.460
OpenCL is kind of a new thing,
but isn't it the same as OpenGL,

00:08:10.460 --> 00:08:13.760
or isn't it like OpenGL with
some stuff added or taken away?

00:08:13.840 --> 00:08:17.830
It's actually a completely
different code path on the top end.

00:08:17.840 --> 00:08:21.940
It's a completely different API,
and really, it's compute focused.

00:08:21.940 --> 00:08:25.580
It can use the same graphics hardware,
or it can use the same CPU underneath,

00:08:25.710 --> 00:08:28.760
but the idea is you basically
build compute kernels,

00:08:28.810 --> 00:08:30.740
and you execute them on
the graphics hardware.

00:08:30.790 --> 00:08:32.290
It doesn't know anything about 3D.

00:08:32.370 --> 00:08:34.050
It doesn't know anything about graphics,
or pixels,

00:08:34.080 --> 00:08:35.000
or those kind of things at all.

00:08:35.000 --> 00:08:38.380
Think of it as just a computation engine.

00:08:38.490 --> 00:08:41.680
But if you wrap your mind around that,
you can say there are some things

00:08:41.690 --> 00:08:46.650
you used to do in OpenGL that
weren't really 3D operations.

00:08:46.660 --> 00:08:50.320
For example, the denoise operation we
saw yesterday in the demo.

00:08:50.320 --> 00:08:53.740
Denoising that movie is not
particularly a graphics operation.

00:08:53.750 --> 00:08:55.660
Sure, you're working on pixels,
but you're really working

00:08:55.720 --> 00:08:56.820
on a pile of data.

00:08:56.930 --> 00:08:59.250
So really,
it's an algorithm run on a piece of data.

00:08:59.500 --> 00:09:01.600
And so OpenCL kind of focuses on that.

00:09:01.760 --> 00:09:02.900
It's a very simple API.

00:09:03.180 --> 00:09:04.470
It just executes kernels.

00:09:04.500 --> 00:09:07.210
It's designed for parallel data.

00:09:07.550 --> 00:09:12.160
You can get very low latency across
the multiple CPU cores you have,

00:09:12.160 --> 00:09:16.380
or you can do access to a GPU,
and it's very high bandwidth

00:09:16.380 --> 00:09:17.940
of working with data.

00:09:18.210 --> 00:09:22.390
So the idea is performance
critical data parallel algorithms

00:09:22.400 --> 00:09:24.750
are the target for OpenGL.

00:09:25.320 --> 00:09:27.750
So I mentioned the OpenGL.org site.

00:09:27.760 --> 00:09:28.620
I mentioned Kronos.

00:09:28.730 --> 00:09:29.910
And so what is Kronos?

00:09:29.910 --> 00:09:36.490
Kronos is an international standards body
and it has over 100 member companies.

00:09:36.490 --> 00:09:41.530
The interesting thing here is it actually
controls the specifications for OpenGL,

00:09:41.810 --> 00:09:46.420
OpenGL ES, and we've opened a new compute
working group and Apple is proposing

00:09:46.420 --> 00:09:50.400
to Kronos a standard that we would
like to be the basis for OpenCL also

00:09:50.550 --> 00:09:53.060
to come under the Kronos auspices.

00:09:53.710 --> 00:09:56.090
And as you can see,
some of the leaders in the industry

00:09:56.090 --> 00:10:00.250
in the graphics area and also in
embedded technology are members

00:10:00.250 --> 00:10:02.610
of Kronos and promoters of Kronos.

00:10:02.610 --> 00:10:04.240
And we're very involved in this.

00:10:04.330 --> 00:10:08.250
We want actually to produce APIs that
can be run on multiple platforms

00:10:08.660 --> 00:10:12.490
that are standard internationally
and you can actually adopt and be

00:10:12.530 --> 00:10:15.860
comfortable in adopting that you're
not going to be kind of scattered and

00:10:15.860 --> 00:10:19.370
taking a shotgun approach to how many
APIs you use in your application.

00:10:22.200 --> 00:10:25.230
So I've kind of talked to this already,
but I think we definitely want to

00:10:25.230 --> 00:10:27.800
talk about why should you use OpenGL?

00:10:27.800 --> 00:10:28.920
Why is it interesting to you?

00:10:28.940 --> 00:10:30.120
Why are you sitting
in the audience today?

00:10:30.120 --> 00:10:31.480
What is interesting about OpenGL?

00:10:31.480 --> 00:10:34.910
So it's a graphics
hardware abstraction layer.

00:10:34.910 --> 00:10:40.250
As you saw again yesterday,
the horsepower in the GPU is phenomenal.

00:10:40.260 --> 00:10:45.320
And it doesn't even matter in
some cases if you're using OpenGL.

00:10:45.320 --> 00:10:47.360
You may actually want to use
a CPU for some high-quality

00:10:47.360 --> 00:10:48.730
render or something like that.

00:10:48.820 --> 00:10:50.720
So OpenGL can also go that route.

00:10:50.740 --> 00:10:55.000
It's not required to get to the GPU,
but definitely it is the

00:10:55.000 --> 00:10:56.490
gateway to get to the GPU.

00:10:56.500 --> 00:10:59.220
So it's basically, as I've said,
it's the way to do high-performance

00:10:59.330 --> 00:11:00.350
graphics on Mac OS X.

00:11:00.360 --> 00:11:03.560
So anything from, you know,
you've got Doom,

00:11:03.560 --> 00:11:07.480
kind of games to get that kind of thing,
to Google Earth.

00:11:07.560 --> 00:11:09.280
So this is massive streaming textures.

00:11:09.280 --> 00:11:10.860
So you're streaming
textures to something.

00:11:10.860 --> 00:11:14.370
You're applying it over a mesh or
on a flat surface with perspective,

00:11:14.370 --> 00:11:17.390
and you can get like a
Google Earth kind of application.

00:11:17.680 --> 00:11:19.320
Or you can do something like iChat.

00:11:19.320 --> 00:11:20.930
iChat, the video effects.

00:11:21.090 --> 00:11:24.700
We use OpenGL to enable
that kind of immersive,

00:11:25.150 --> 00:11:28.460
interesting feel for
that iChat conference.

00:11:28.460 --> 00:11:31.090
And also, you've probably all
worked with iChat effects.

00:11:31.210 --> 00:11:34.520
iChat effects obviously power
with Core Image and OpenGL.

00:11:34.520 --> 00:11:39.320
Again, using the GPU to get access to
that graphics hardware power.

00:11:41.160 --> 00:11:46.460
So OpenGL today is this kind of,
it's used in Mac OS for 2D effects,

00:11:46.660 --> 00:11:50.220
used for the windowing services,
so we talked about Expose and the

00:11:50.230 --> 00:11:53.570
windowing compositing system use it,
image processing and

00:11:53.690 --> 00:11:55.400
digital video effects.

00:11:55.420 --> 00:11:58.510
Also, another thing is for
people in here who think,

00:11:58.550 --> 00:12:01.160
you know, after this talk,
they're thinking, you know,

00:12:01.160 --> 00:12:04.260
OpenGL seems a little
bit too low level for me.

00:12:04.260 --> 00:12:05.300
I need something a little bit higher.

00:12:05.300 --> 00:12:05.920
We have that.

00:12:06.000 --> 00:12:09.000
We have Core Image,
we have Core Animation,

00:12:09.000 --> 00:12:11.440
as we talked about yesterday,
which was originally

00:12:11.440 --> 00:12:13.980
developed for the iPhone,
is also available on the desktop.

00:12:14.000 --> 00:12:18.180
We have Core Video, Quartz Composer,
which is a great way to simply

00:12:18.430 --> 00:12:21.970
prototype or to build very high
level applications as the graphical

00:12:22.070 --> 00:12:24.440
programming interface works wonderfully.

00:12:24.500 --> 00:12:28.110
And also, we have Quartz GL,
which is the acceleration of

00:12:28.120 --> 00:12:30.500
desktop elements through OpenGL.

00:12:30.500 --> 00:12:34.320
And these pieces you can either
adopt or sometimes you get for free.

00:12:34.500 --> 00:12:36.420
So, you can use OpenGL with your apps.

00:12:36.540 --> 00:12:39.140
And you don't have to use OpenGL,
but underneath the covers

00:12:39.140 --> 00:12:40.500
you will be using OpenGL.

00:12:40.500 --> 00:12:42.850
So, things you take away from here
will actually give you a better

00:12:42.850 --> 00:12:44.500
understanding of how these pieces work.

00:12:44.500 --> 00:12:45.500
They're all built on top of OpenGL.

00:12:45.500 --> 00:12:47.280
There's no real secrets here.

00:12:47.600 --> 00:12:49.500
There's no weird wire
that goes in the back.

00:12:49.500 --> 00:12:52.500
These are all built right on top
of our OpenGL implementation.

00:12:53.850 --> 00:12:56.660
So we talked a little bit
about OpenGL and OpenCL.

00:12:56.660 --> 00:12:59.500
I want to kind of stress the
difference here because there is

00:12:59.500 --> 00:13:01.160
definitely a choice between the two.

00:13:01.160 --> 00:13:03.600
So OpenGL, graphics-centric obviously.

00:13:03.600 --> 00:13:06.150
So things like StarCraft II,
if you're building into

00:13:06.150 --> 00:13:09.080
the next StarCraft II,
I would be the next, next thing.

00:13:09.080 --> 00:13:11.200
But if you're building
something like that,

00:13:11.200 --> 00:13:14.760
like we see in the picture up there,
OpenGL is like the way you want to go.

00:13:14.760 --> 00:13:15.760
That's something you want to have.

00:13:15.760 --> 00:13:20.610
A 3D graphics game application
makes sense to use OpenGL.

00:13:20.620 --> 00:13:23.780
But then if you're doing protein folding,
if you're doing protein folding,

00:13:23.780 --> 00:13:23.780
you're going to have to use OpenGL.

00:13:23.890 --> 00:13:26.600
So if you're doing protein folding,
it's an algorithmic simulation.

00:13:26.630 --> 00:13:28.140
A simulation of protein folding.

00:13:28.140 --> 00:13:30.800
It sure has a graphical interface,
but really the algorithm

00:13:30.800 --> 00:13:33.440
behind it is very,
is very a scientific kind of algorithm.

00:13:33.440 --> 00:13:35.070
It's a compute-oriented algorithm.

00:13:35.190 --> 00:13:37.320
It's not a graphics-oriented algorithm.

00:13:37.320 --> 00:13:39.020
There's a display component of it.

00:13:39.070 --> 00:13:41.660
But in that case, you probably,
for the algorithm side,

00:13:41.750 --> 00:13:43.210
OpenCL is a great place to look.

00:13:43.210 --> 00:13:45.560
OpenGL also is very broad.

00:13:45.600 --> 00:13:50.250
All of our, basically all of our hardware
that's been out for since about

00:13:50.380 --> 00:13:53.600
2000 support OpenGL in one fashion.

00:13:53.800 --> 00:13:56.270
Some of the hardware, obviously,
is less capable.

00:13:56.270 --> 00:13:57.260
Some is more capable.

00:13:57.350 --> 00:14:00.280
So you have to do a lot of some
work to figure out the capabilities.

00:14:00.280 --> 00:14:03.190
You have to figure out,
am I on an integrated graphics machine?

00:14:03.190 --> 00:14:05.840
Am I on a desktop with a very
high power discrete graphics?

00:14:05.840 --> 00:14:07.730
Maybe I have two graphics cards.

00:14:07.780 --> 00:14:09.100
So you have to do that work.

00:14:09.170 --> 00:14:11.990
For OpenCL,
we have a more constrained market.

00:14:12.000 --> 00:14:15.060
There's only a certain level
of capability in graphics cards

00:14:15.060 --> 00:14:16.800
that actually support OpenCL.

00:14:16.800 --> 00:14:19.950
So it's more limited hardware choices,
but the hardware choices have the

00:14:19.950 --> 00:14:21.760
same robust feature set across them.

00:14:21.760 --> 00:14:26.000
So there's, if it works on,
the hardware you have supports OpenCL,

00:14:26.000 --> 00:14:27.040
it supports OpenCL.

00:14:27.040 --> 00:14:29.680
There's not a lot of choices,
and you don't have to write a lot

00:14:29.680 --> 00:14:30.790
of different code paths in your app.

00:14:30.800 --> 00:14:34.720
So both have their advantages,
but may affect your adoption.

00:14:36.770 --> 00:14:37.960
So let's talk about learning OpenGL.

00:14:37.960 --> 00:14:41.770
So I figure some of you in this room
probably have not used OpenGL and

00:14:41.770 --> 00:14:43.750
want to know how to learn it.

00:14:43.830 --> 00:14:47.340
I'm not going to do a 101 OpenGL.

00:14:47.340 --> 00:14:49.550
We could take a week kind of
doing that depending on what

00:14:49.650 --> 00:14:50.480
topics we wanted to cover.

00:14:50.480 --> 00:14:53.700
But what I will do is talk about
resources for learning OpenGL.

00:14:53.700 --> 00:14:56.820
And I'm serious when I'm saying
there's a lot of resources out there.

00:14:56.820 --> 00:14:59.790
There's a tremendous amount of
reference material both in books and

00:14:59.790 --> 00:15:04.350
on the web that really probably cover
most of what you need to do to get

00:15:04.360 --> 00:15:08.600
started and get started and move very
quickly into getting good content out.

00:15:08.600 --> 00:15:12.080
I find that either from our
reference library or web references,

00:15:12.080 --> 00:15:14.980
you almost always can find
something that someone's,

00:15:14.990 --> 00:15:17.860
to solve the problem that
you have using OpenGL.

00:15:17.860 --> 00:15:20.190
So first, OpenGL.org.

00:15:20.240 --> 00:15:21.380
I mentioned Kronos before.

00:15:21.500 --> 00:15:24.480
OpenGL.org is the website for OpenGL.

00:15:24.480 --> 00:15:26.700
I suggest you bookmark that.

00:15:26.810 --> 00:15:28.920
On that website is the
OpenGL specification.

00:15:28.920 --> 00:15:31.170
So I would go to the website,
get the specification,

00:15:31.260 --> 00:15:33.190
and use that as your reference material.

00:15:33.200 --> 00:15:36.320
That should be the thing that you
have on your desktop in your reference

00:15:36.400 --> 00:15:39.370
material folder and that you use
it while you're programming OpenGL.

00:15:40.820 --> 00:15:43.780
Also, if you're learning it,
simply search on the web

00:15:43.780 --> 00:15:45.290
for some OpenGL tutorial.

00:15:45.580 --> 00:15:46.460
You'll come up with a lot of things.

00:15:46.520 --> 00:15:48.120
A good example is the Nehe tutorials.

00:15:48.200 --> 00:15:51.940
There's 40 or 50 tutorials that are
just little kind of snippets of code.

00:15:51.940 --> 00:15:53.850
They're not perfect,
but they actually do show some

00:15:54.180 --> 00:15:55.610
definitely interesting techniques.

00:15:55.730 --> 00:16:02.810
And so if you're brand new to OpenGL,
these are a very good way to

00:16:02.810 --> 00:16:03.800
actually kind of get some ideas
and get started in what's going on.

00:16:04.330 --> 00:16:07.250
The Red Book is the
OpenGL programming guide,

00:16:07.290 --> 00:16:09.270
affectionately known as the Red Book.

00:16:09.480 --> 00:16:13.380
The Red Book is a great take
you from the very beginnings to

00:16:13.380 --> 00:16:16.000
reasonably advanced in OpenGL.

00:16:16.040 --> 00:16:18.780
The caveat I have is it's
been updated over time,

00:16:18.780 --> 00:16:22.230
but it still uses some really
old programming paradigms.

00:16:22.360 --> 00:16:23.800
So we'll talk about
that a little bit later.

00:16:23.800 --> 00:16:30.110
But the Red Book, good book to have,
but be careful about how modern

00:16:30.110 --> 00:16:30.110
some of the techniques are.

00:16:30.340 --> 00:16:30.800
The Green Book.

00:16:30.850 --> 00:16:32.480
The Green Book just came out recently.

00:16:32.480 --> 00:16:35.560
The Green Book is basically
OpenGL programming on Mac OS X.

00:16:35.560 --> 00:16:37.870
It's a, I'll say,
a complement to some of the things

00:16:37.900 --> 00:16:39.260
we have on our developer website.

00:16:39.260 --> 00:16:40.320
It talks about Cocoa.

00:16:40.320 --> 00:16:42.280
It talks about performance on Mac OS X.

00:16:42.280 --> 00:16:45.240
It's probably a good book to
definitely peruse and look at

00:16:45.250 --> 00:16:48.260
and decide if it fits your needs
to go out and purchase that also.

00:16:48.260 --> 00:16:52.660
And finally, developer.app.com.opengl.

00:16:52.660 --> 00:16:56.500
This is a, I'm going to bookmark this
as a great resource for any

00:16:56.500 --> 00:16:57.620
person developing OpenGL.

00:16:57.920 --> 00:16:58.990
First, sample code.

00:16:58.990 --> 00:17:01.800
Almost everything I'm going to talk
about today is available in some

00:17:01.890 --> 00:17:03.420
form or fashion as sample code.

00:17:03.420 --> 00:17:05.830
So you can grab the sample code,
download it, play with it.

00:17:05.900 --> 00:17:08.840
It may be a little bit more advanced
than what I show or maybe a little

00:17:08.840 --> 00:17:10.670
bit simpler than what I show,
but it's probably up there.

00:17:10.680 --> 00:17:15.980
Also, there is the OpenGL programming
guide for Mac OS X.

00:17:15.990 --> 00:17:19.700
That was recently rewritten a few
months ago after a major rewrite a

00:17:19.700 --> 00:17:23.480
couple years ago and it really is up
to date with the latest techniques.

00:17:23.480 --> 00:17:26.030
And when I talk about virtual
screens later and you're going,

00:17:26.030 --> 00:17:28.220
what the heck is he talking about?

00:17:28.220 --> 00:17:29.910
You can go to the programming guide.

00:17:30.190 --> 00:17:31.320
They have a complete section on it.

00:17:31.330 --> 00:17:33.340
Read through it and I think
you'll understand where I'm

00:17:33.460 --> 00:17:35.510
coming from and you'll understand
the techniques behind it.

00:17:35.510 --> 00:17:37.690
It will really help you in the
future working with OpenGL.

00:17:37.760 --> 00:17:42.340
So those are some resources to actually
when you're working with OpenGL.

00:17:42.340 --> 00:17:46.660
So I think that's the end of
the kind of intro about OpenGL,

00:17:46.660 --> 00:17:48.850
where to learn it, what it is.

00:17:48.850 --> 00:17:51.430
And so let's talk about something
that's really Mac specific.

00:17:51.430 --> 00:17:53.970
So we're talking about Mac specific data.

00:17:53.980 --> 00:17:59.100
So OpenGL spec is a
cross-platform industry standard.

00:17:59.140 --> 00:18:02.380
What that means is it takes
into no account the windowing

00:18:02.420 --> 00:18:03.370
system on that platform.

00:18:03.490 --> 00:18:05.020
So it doesn't know anything about Cocoa.

00:18:05.180 --> 00:18:06.870
It doesn't know anything about Carbon.

00:18:06.870 --> 00:18:10.040
It doesn't know anything
about an NS window or a view.

00:18:10.040 --> 00:18:16.580
Nor it doesn't know about our
iPhone and its Eagle API for getting

00:18:16.580 --> 00:18:19.090
access to the OS specific pieces.

00:18:19.270 --> 00:18:23.190
So it is just talking
about GL drawing triangles,

00:18:23.190 --> 00:18:25.410
textures, those kind of things.

00:18:25.430 --> 00:18:28.920
So there are a few pieces of data
that are critical for working with

00:18:28.920 --> 00:18:30.210
Mac OS X you should understand.

00:18:30.220 --> 00:18:34.770
Virtual screens, pixel formats, context,
and drawables.

00:18:36.310 --> 00:18:37.180
These are well documented.

00:18:37.180 --> 00:18:38.820
I'm going to give you an
overview of them here,

00:18:38.820 --> 00:18:41.870
but I really strongly suggest, again,
that you go to the programming

00:18:41.870 --> 00:18:44.950
guide after the session,
later on, and look through it.

00:18:45.110 --> 00:18:47.670
Because I think you'll see that you'll
understand if you go through that.

00:18:47.900 --> 00:18:51.430
And I can't really stress that enough,
because if you spend an hour

00:18:51.430 --> 00:18:55.040
this evening reading through
the programming and skimming and

00:18:55.040 --> 00:18:58.150
understanding those concepts,
the rest of it will be easy.

00:18:58.290 --> 00:19:00.820
If you don't,
you'll end up copying code from a sample.

00:19:00.820 --> 00:19:03.610
And you'll probably use that
code significantly without really

00:19:03.610 --> 00:19:06.480
understanding the nuances of it,
which later on, I'm sure there'll be

00:19:06.480 --> 00:19:07.630
something that comes along.

00:19:07.640 --> 00:19:10.880
They'll be like, oh, yeah,
that's why I was doing it this way.

00:19:10.880 --> 00:19:12.900
So I really suggest take a little
bit of time to look at that,

00:19:12.900 --> 00:19:14.600
because it'll really
help you in the future.

00:19:17.010 --> 00:19:19.800
So desktop-specific data flow.

00:19:19.800 --> 00:19:22.460
So what are these things,
these pixel formats and these

00:19:22.650 --> 00:19:23.740
virtual screens and stuff?

00:19:23.860 --> 00:19:26.490
So you have an application
in gray down there.

00:19:26.660 --> 00:19:28.360
The first thing you do
is create a pixel format.

00:19:28.480 --> 00:19:29.670
So what is a pixel format?

00:19:29.720 --> 00:19:33.100
A pixel format is really
just made up of two pieces.

00:19:33.100 --> 00:19:36.580
To specify a pixel format,
we have two pieces of information.

00:19:36.580 --> 00:19:38.920
One is the render attributes.

00:19:39.050 --> 00:19:42.050
And the render attributes
are things like accelerated,

00:19:42.180 --> 00:19:44.880
or software, or a specific render.

00:19:45.180 --> 00:19:48.400
It actually determines the
list of renderers that you can

00:19:48.410 --> 00:19:49.660
support with that pixel format.

00:19:49.730 --> 00:19:50.440
So it makes sense.

00:19:50.440 --> 00:19:53.680
You have the things that say,
I only want accelerated renderers.

00:19:53.740 --> 00:19:55.600
Or I want only software renderers.

00:19:55.750 --> 00:19:56.880
Those are render attributes.

00:19:57.000 --> 00:19:58.260
The other thing is buffer attributes.

00:19:58.350 --> 00:20:00.580
And buffer attributes are
things like double buffer,

00:20:00.630 --> 00:20:04.810
or depth buffer,
or how deep the depth buffer is.

00:20:04.870 --> 00:20:06.420
All those things are buffer attributes.

00:20:06.520 --> 00:20:08.580
So when you think about it,
you have render attributes.

00:20:08.610 --> 00:20:11.400
And then you have the list of
buffers you're going to create and

00:20:11.400 --> 00:20:12.150
how you're going to create them.

00:20:12.160 --> 00:20:13.820
Those are those two
pieces that make it up.

00:20:13.930 --> 00:20:16.080
So in pixel format,
you specify the two pieces.

00:20:16.160 --> 00:20:19.790
A really simple thing is just to say,
accelerated double buffered,

00:20:19.950 --> 00:20:21.240
or just double buffered.

00:20:21.370 --> 00:20:23.540
So that would be a basic starting point.

00:20:23.540 --> 00:20:25.880
But now you understand
where that comes from.

00:20:26.000 --> 00:20:28.640
So once you have the pixel format,
you can build the context

00:20:28.640 --> 00:20:29.700
using the pixel format.

00:20:29.700 --> 00:20:33.480
So you're basically telling the context,
when you give it a pixel format,

00:20:33.520 --> 00:20:36.110
what kind of things
you're going to support.

00:20:36.230 --> 00:20:40.000
What kind of the accelerated
are you going to support?

00:20:40.000 --> 00:20:42.180
What kind of set of buffers
are you going to create?

00:20:42.280 --> 00:20:43.740
The key here is a context.

00:20:43.840 --> 00:20:47.470
The OpenGL context-- think of
that as a big state bucket.

00:20:47.670 --> 00:20:49.720
So OpenGL is a state machine.

00:20:49.720 --> 00:20:54.640
OpenGL takes-- the best way to
describe for OpenGL on a state

00:20:54.640 --> 00:20:56.340
machine is you have a pen.

00:20:56.340 --> 00:20:57.640
And the context is your pen.

00:20:57.640 --> 00:20:58.560
And you pick up a pen.

00:20:58.600 --> 00:21:00.330
And let's say it's a fat blue pen.

00:21:00.620 --> 00:21:01.920
And you start drawing with it.

00:21:01.930 --> 00:21:04.340
Until you change that
and change your pen,

00:21:04.370 --> 00:21:05.820
you have a fat blue pen.

00:21:05.830 --> 00:21:09.490
If you pick up the thin red pen,
then you actually make calls.

00:21:09.570 --> 00:21:11.980
You say,
I'm going to change my current color.

00:21:11.980 --> 00:21:15.030
I'm going to change
the type of pen I have.

00:21:15.080 --> 00:21:17.320
If I clear color,
all those calls are setting states.

00:21:17.320 --> 00:21:20.470
So until you change the state,
it keeps that current state around.

00:21:20.550 --> 00:21:24.620
So the OpenGL context
is really like the pen.

00:21:24.620 --> 00:21:25.900
And it contains the state.

00:21:26.140 --> 00:21:29.040
So really,
what your current state is is what

00:21:29.040 --> 00:21:31.290
kind of pen you're drawing with.

00:21:31.420 --> 00:21:33.360
Once you create the context, you can,
if you want to,

00:21:33.430 --> 00:21:34.320
get rid of the pixel format.

00:21:34.320 --> 00:21:37.460
It's only used basically to tell the
context how it's supposed to be created.

00:21:37.460 --> 00:21:39.190
One reason that they're separate,
you think, well,

00:21:39.240 --> 00:21:40.160
why aren't they together?

00:21:40.160 --> 00:21:48.140
It's because you may want to create one
pixel format and create multiple context.

00:21:48.140 --> 00:21:51.360
So the pixel format is a separate piece,
and you can keep it around

00:21:51.360 --> 00:21:51.360
or throw it away as need be.

00:21:51.360 --> 00:21:51.360
So we'll throw it away in this case.

00:21:51.700 --> 00:21:53.000
Then you create a drawable.

00:21:53.030 --> 00:21:58.000
So the drawable is your view,
your window, a full screen,

00:21:58.000 --> 00:21:59.770
all those things make up drawables.

00:21:59.900 --> 00:22:02.450
And basically that provides
the surface dimensions.

00:22:02.600 --> 00:22:05.200
So remember the buffer
attributes determine depth.

00:22:05.330 --> 00:22:09.540
They determine whether you have a depth
buffer and how many buffers you may have.

00:22:09.700 --> 00:22:14.380
So when you put all those together,
you get drawable dimensions,

00:22:14.380 --> 00:22:18.680
you get types of drawables,
and you get the types of renders

00:22:18.680 --> 00:22:19.110
that are supposed to support those.

00:22:19.570 --> 00:22:21.790
When you actually
instantiate this and attach,

00:22:21.900 --> 00:22:23.180
you actually pick a current renderer.

00:22:23.350 --> 00:22:26.620
So for example, I have a screen attached
to a graphics card.

00:22:26.620 --> 00:22:27.820
That would be the current renderer.

00:22:27.820 --> 00:22:30.360
Maybe this graphics card that
it's rendering on the screen.

00:22:30.360 --> 00:22:33.240
And the target surface,
the OpenGL buffers get created.

00:22:33.240 --> 00:22:37.330
So when you actually use OpenGL,
the application issues

00:22:37.370 --> 00:22:39.580
calls through the context.

00:22:39.580 --> 00:22:41.700
You always have a current
context for a call.

00:22:41.700 --> 00:22:44.240
So every GL call has a
context it's going through.

00:22:44.240 --> 00:22:45.400
The PIN it's using.

00:22:45.870 --> 00:22:48.100
They issue the call through
the current context.

00:22:48.160 --> 00:22:51.500
It uses the current renderer and
draws to the current set of buffers,

00:22:51.580 --> 00:22:55.500
which then are shown on
the drawable on the screen.

00:22:55.500 --> 00:22:57.860
So if you make sense, all these pieces of
information are specified.

00:22:57.980 --> 00:23:01.440
And again, this is all referenced in
some of the reference material

00:23:01.440 --> 00:23:02.150
I talked about earlier.

00:23:02.160 --> 00:23:04.510
So you can review and go
through it and understand it.

00:23:04.580 --> 00:23:07.660
But understanding this kind of
concept initially is very good.

00:23:07.660 --> 00:23:09.670
So virtual screens,
we talked about those a little bit.

00:23:09.700 --> 00:23:13.140
Actually, we didn't talk about
particularly virtual screens.

00:23:13.140 --> 00:23:15.470
Virtual screens embody
this kind of concept of,

00:23:15.930 --> 00:23:18.220
of a renderer in a pixel format.

00:23:18.220 --> 00:23:22.160
A virtual screen, so my two examples were
accelerated or software.

00:23:22.160 --> 00:23:25.980
And those things could be limiting
yourself to a single renderer.

00:23:25.980 --> 00:23:27.340
What say you didn't specify those?

00:23:27.440 --> 00:23:28.440
You just go double buffered.

00:23:28.460 --> 00:23:30.540
Well, what kind of renderers
could support that?

00:23:30.560 --> 00:23:33.000
Well, you could support your graphics
cards could support it.

00:23:33.000 --> 00:23:34.890
And your software
renderer could support it.

00:23:35.030 --> 00:23:37.280
So what that means,
you might have two virtual screens.

00:23:37.280 --> 00:23:39.580
You have two renderers
associated with a pixel format.

00:23:39.580 --> 00:23:43.220
And basically,
any time you change virtual screens,

00:23:43.220 --> 00:23:46.860
you can look at your renderer,
and you can see, oh,

00:23:46.860 --> 00:23:47.360
I have a virtual screen.

00:23:47.360 --> 00:23:49.240
Any time that changes means
your renderer changed.

00:23:49.270 --> 00:23:50.520
Why is this important to you?

00:23:50.520 --> 00:23:51.570
Why do I care about virtual screens?

00:23:51.700 --> 00:23:52.860
Can't you just have one virtual screen?

00:23:52.860 --> 00:23:53.860
It would be a lot easier.

00:23:53.860 --> 00:23:55.260
You wouldn't even have a slide for it.

00:23:55.280 --> 00:23:57.870
But if you understand that
you might have multi cards,

00:23:58.000 --> 00:23:59.860
the cards may be disparate capabilities.

00:23:59.920 --> 00:24:01.840
The software renderer may not
have the same capabilities

00:24:02.180 --> 00:24:03.150
as the hardware renderer.

00:24:03.160 --> 00:24:05.180
You may want to know about
those kind of things.

00:24:05.310 --> 00:24:08.030
You may actually have a card
that's not connected to any heads.

00:24:08.040 --> 00:24:10.740
It's just their compute
asset or graphics asset.

00:24:10.830 --> 00:24:14.130
And in that case, when you change to it,
you want that, that flag to say, hey,

00:24:14.300 --> 00:24:14.300
you've changed virtual screen.

00:24:14.330 --> 00:24:15.480
So basically,
you're going to have a virtual screen.

00:24:15.640 --> 00:24:18.300
Basically, you have one virtual screen
that's active at a time.

00:24:18.300 --> 00:24:19.990
One renderer is active at a time.

00:24:20.170 --> 00:24:23.660
Your virtual screen will change
when you change renderers,

00:24:23.680 --> 00:24:26.360
and you should check to see
what capabilities are available.

00:24:26.640 --> 00:24:29.420
If you do this,
you'll be extremely well-suited

00:24:29.440 --> 00:24:31.790
for handling multiple cards,
multiple heads.

00:24:32.050 --> 00:24:35.900
Someone puts a projector in with a
different card or something like that.

00:24:35.900 --> 00:24:38.420
Things change, you'll understand all
those kind of things.

00:24:38.510 --> 00:24:42.640
One thing we haven't talked about much in
the past is to allow offline renderers.

00:24:42.640 --> 00:24:44.160
It's something new we've added.

00:24:44.360 --> 00:24:48.700
We've added it to be able to use
multiple cards as just rendering assets.

00:24:48.790 --> 00:24:50.370
So for example,
if you have a very high-end

00:24:50.370 --> 00:24:52.660
application that you want
to do a lot of rendering on,

00:24:52.730 --> 00:24:55.590
and the card that's connected to the
display is not enough power for you,

00:24:55.670 --> 00:24:57.920
you can now go out and buy
an extra graphics card.

00:24:57.960 --> 00:24:59.840
You don't even have to
hook a device to it.

00:25:00.050 --> 00:25:01.210
It's still a compute asset.

00:25:01.220 --> 00:25:02.330
It's still powered up.

00:25:02.430 --> 00:25:03.360
It's still there.

00:25:03.420 --> 00:25:06.020
You can still set the
virtual screen to go to it,

00:25:06.080 --> 00:25:07.700
and you can actually render on it.

00:25:07.800 --> 00:25:10.190
So you can use it as, like,
I'm thinking of kind of

00:25:10.310 --> 00:25:11.600
Final Cut Pro kind of app.

00:25:11.690 --> 00:25:14.000
If you're doing a Final Cut Pro and
you have this lot of offline

00:25:14.000 --> 00:25:16.990
rendering you're doing,
you can have one card just displaying

00:25:16.990 --> 00:25:21.820
your content and one card working
as a kind of computational asset.

00:25:21.860 --> 00:25:25.040
In fact, some of the demos we showed
yesterday with OpenCL,

00:25:25.040 --> 00:25:26.670
OpenCL takes advantage of this.

00:25:26.850 --> 00:25:29.700
Two cards in the machine,
one card was a compute asset,

00:25:29.720 --> 00:25:31.480
one card we used for OpenGL.

00:25:31.640 --> 00:25:34.780
So in this way,
you can take advantage of that, you know,

00:25:34.820 --> 00:25:37.850
tremendous horsepower that just
may be sitting idle in the machine.

00:25:37.860 --> 00:25:40.420
Again, allow offline renderers,
shows renderers that do not

00:25:40.690 --> 00:25:42.760
have a display attached to it.

00:25:42.760 --> 00:25:44.820
And at the end,
it might be interesting to

00:25:44.820 --> 00:25:47.400
get a render ID to know what
kind of renderer you have.

00:25:47.540 --> 00:25:48.600
This is the kind of way to do it.

00:25:48.650 --> 00:25:50.780
You get render ID,
and render ID is supposed to be

00:25:50.780 --> 00:25:51.780
with the families of renderers.

00:25:51.780 --> 00:25:55.180
You have the GeForce render
ID for various GeForce families,

00:25:55.240 --> 00:25:57.180
and the Radeon families
are the software render ID.

00:25:57.180 --> 00:26:00.470
So if you want to say, hey,
am I on the software renderer,

00:26:00.630 --> 00:26:02.250
you can use this little snippet of code.

00:26:02.380 --> 00:26:04.820
This kind of code is, again,
in the resources.

00:26:05.020 --> 00:26:08.060
It's not,
you don't have to copy it down madly,

00:26:08.180 --> 00:26:11.030
because all these code pieces
are taken from other samples or

00:26:11.030 --> 00:26:13.480
resources I'm going to talk about.

00:26:13.790 --> 00:26:14.440
So pixel formats.

00:26:14.510 --> 00:26:16.420
I think we talked a lot
about those already.

00:26:16.420 --> 00:26:18.880
I wanted to highlight some
options you have here.

00:26:19.010 --> 00:26:21.010
So offline renders, we talked about that.

00:26:21.020 --> 00:26:23.370
That's something that
goes in the pixel format.

00:26:23.410 --> 00:26:24.940
Require accelerator renders.

00:26:24.940 --> 00:26:26.670
Accelerated again or no recovery.

00:26:26.670 --> 00:26:29.660
So what that says is, accelerated says,
the key here is I'm saying

00:26:29.660 --> 00:26:31.380
require accelerator renderers.

00:26:31.470 --> 00:26:34.310
Accelerated says I definitely
want an accelerator renderer.

00:26:34.590 --> 00:26:37.310
No recovery says I don't want
to fall back to software ever.

00:26:37.380 --> 00:26:40.890
So if your application needs to run on
an accelerator renderer all the time,

00:26:40.890 --> 00:26:43.680
those are the things
you're going to want to do.

00:26:43.700 --> 00:26:44.760
So those are the two
things you want to specify.

00:26:44.760 --> 00:26:46.510
If you want to run in software,
for example,

00:26:46.610 --> 00:26:47.970
let's say you want to run on the CPU.

00:26:47.970 --> 00:26:49.620
You have the GPU doing something else.

00:26:49.660 --> 00:26:53.290
We have some applications internal to
Apple that do high quality rendering kind

00:26:53.330 --> 00:26:56.540
of in the background on the CPU while
the GPU is doing something else.

00:26:56.610 --> 00:27:00.130
You can specify that with a render
ID and it gives a generic float ID.

00:27:00.140 --> 00:27:03.100
That's our current floating
point software renderer.

00:27:03.160 --> 00:27:05.780
And then one note about this,
just for trivia's sake,

00:27:05.780 --> 00:27:09.180
is our new software renderer
actually is hardware accelerated.

00:27:09.180 --> 00:27:11.660
We actually do all the work in
software and then we actually

00:27:11.850 --> 00:27:15.140
use a graphics card to help blend
those things onto the screen.

00:27:15.140 --> 00:27:18.470
So we actually only touch the
pixels we need to touch and we can,

00:27:18.480 --> 00:27:20.660
if you're going to the screen,
we actually use the hardware

00:27:20.660 --> 00:27:22.670
to assist getting those pixels
on the screen to make it even

00:27:22.800 --> 00:27:24.000
faster than it ever has been.

00:27:24.000 --> 00:27:27.320
And finally, if you really just wanted
to render to system memory,

00:27:27.320 --> 00:27:28.200
you can use the off screen.

00:27:28.200 --> 00:27:30.800
This won't be accelerated,
but definitely will give you a system

00:27:30.800 --> 00:27:32.280
memory buffer with your results.

00:27:34.530 --> 00:27:34.950
Context.

00:27:35.040 --> 00:27:36.640
Again, we talked about many of
these things already.

00:27:36.640 --> 00:27:37.660
State bucket.

00:27:37.660 --> 00:27:39.490
It really represents the open jail state.

00:27:39.490 --> 00:27:40.720
It's the pen you're drawing with.

00:27:40.750 --> 00:27:44.200
So you need to change the pen when
you want to change your drawing.

00:27:44.200 --> 00:27:48.000
And remember, you can do something over
here with that red pen.

00:27:48.360 --> 00:27:51.320
Program goes on, goes off in subroutine,
goes off in the function here,

00:27:51.320 --> 00:27:52.910
goes into some other thread over here.

00:27:52.920 --> 00:27:54.600
You come back and you
start drawing again.

00:27:54.600 --> 00:27:55.650
What are you drawing with?

00:27:55.650 --> 00:27:57.040
You're drawing with the red pen.

00:27:57.040 --> 00:27:59.140
If you didn't change
anything in that context,

00:27:59.140 --> 00:28:01.320
you're still drawing
with everything you set.

00:28:01.410 --> 00:28:03.230
So it's not like a set and reset.

00:28:03.230 --> 00:28:04.340
You don't set some things.

00:28:04.400 --> 00:28:07.580
You can do a function and
have it reset back to current,

00:28:07.580 --> 00:28:09.680
what you default automatically.

00:28:09.780 --> 00:28:13.740
This does mean there's a thought
process in handling state.

00:28:13.740 --> 00:28:17.840
The thought process is you
don't want to make two mistakes.

00:28:17.900 --> 00:28:20.220
One mistake is you overset state.

00:28:20.220 --> 00:28:24.440
You really absolutely define
every single state change for

00:28:24.440 --> 00:28:25.480
every single time you draw.

00:28:25.480 --> 00:28:27.530
So you don't want to go, okay,
I'm going to set the color,

00:28:27.530 --> 00:28:30.740
I'm going to set the clear color,
I'm going to set the blend mode

00:28:30.740 --> 00:28:34.350
and go through all these states no
matter whether you changed it or not.

00:28:34.380 --> 00:28:35.680
It's just a waste.

00:28:35.690 --> 00:28:37.500
State calls can be expensive.

00:28:37.730 --> 00:28:40.800
Having this huge amount of state
setting and then draw and then a huge

00:28:40.800 --> 00:28:43.610
amount of state setting and then draw
is probably not the right approach.

00:28:43.610 --> 00:28:46.790
The other approach is actually
probably not correct is to say,

00:28:46.790 --> 00:28:47.940
okay, I have default state.

00:28:48.030 --> 00:28:52.270
I'm going to change a few things from
default and now I'm done with that state.

00:28:52.290 --> 00:28:53.440
I'm going to change them back to default.

00:28:53.530 --> 00:28:55.680
I'm going to change
some things to default.

00:28:55.770 --> 00:28:57.140
I'm going to go back to default.

00:28:57.140 --> 00:29:00.030
That's not a good approach either.

00:29:00.040 --> 00:29:02.480
The best approach actually is to
understand the states you need to

00:29:02.480 --> 00:29:05.830
draw and do the minimal amount of
changes to get to those states.

00:29:05.900 --> 00:29:08.610
Some bookkeeping on your end?

00:29:08.620 --> 00:29:09.310
Yes.

00:29:09.550 --> 00:29:12.890
And you may not want to do it everywhere,
but you definitely want to do it in the

00:29:12.990 --> 00:29:14.490
cases that are performance critical.

00:29:14.540 --> 00:29:18.060
You want to minimize the state changes,
coalesce states of the same,

00:29:18.060 --> 00:29:22.400
and actually try and draw everything
with the same pen at the same time.

00:29:22.400 --> 00:29:26.020
So instead of drawing the tree
with the green and the brown and

00:29:26.020 --> 00:29:29.120
some flowers on it and then going
over to the bush which is green and

00:29:29.120 --> 00:29:32.590
brown and has some flowers on it,
you want to draw all the leaves and then

00:29:32.630 --> 00:29:36.100
all the brown twigs and bark and that
kind of stuff and then all the flowers.

00:29:36.110 --> 00:29:37.130
If you want to think about it that way.

00:29:37.190 --> 00:29:39.540
That's the efficient way to do it.

00:29:41.100 --> 00:31:37.100
[Transcript missing]

00:31:37.310 --> 00:31:38.530
I'm sorry, that's Wednesday afternoon.

00:31:38.540 --> 00:31:40.330
Wednesday afternoon,
I believe it's the last

00:31:40.420 --> 00:31:42.180
session of the day,
so it's 5:00 PM.

00:31:42.310 --> 00:31:46.380
We have a performance tuning for OpenGL,
and that session will talk about

00:31:46.380 --> 00:31:49.580
the multi-threaded OpenGL engine
and how to turn it on.

00:31:49.580 --> 00:31:53.040
And I suggest, again, that some apps,
depending on your CPU load,

00:31:53.040 --> 00:31:55.320
can really benefit by that.

00:31:55.430 --> 00:31:58.340
Finally,
one thing you want to note is in OpenGL,

00:31:58.600 --> 00:32:00.520
they're not normally VBL synchronized.

00:32:00.620 --> 00:32:03.230
So if you do want to synchronize
yourself with a vertical blank,

00:32:03.260 --> 00:32:05.260
you want to turn that on.

00:32:06.160 --> 00:32:06.490
Drawable.

00:32:06.490 --> 00:32:08.240
This is really,
this actually is pretty simple.

00:32:08.280 --> 00:32:10.360
It's just your pixels in RAM or VRAM.

00:32:10.590 --> 00:32:13.430
It actually represents your screen
or your window or that kind of thing.

00:32:13.440 --> 00:32:17.190
So it could be full-screen,
it could be a view,

00:32:17.190 --> 00:32:17.190
it could be an off-screen,
that kind of thing.

00:32:17.980 --> 00:32:20.430
So let's move a little bit on to
a little bit about architecture.

00:32:20.440 --> 00:32:21.650
Now I've covered all the data types.

00:32:21.700 --> 00:32:24.120
I've covered kind of how
these pieces fit together.

00:32:24.120 --> 00:32:25.380
Let's talk about the architecture.

00:32:25.380 --> 00:32:27.420
So you've seen this
kind of diagram before.

00:32:27.420 --> 00:32:31.340
So this is Mac OS X user experience
applications all the way down

00:32:31.360 --> 00:32:33.240
the kind of complete stack.

00:32:33.330 --> 00:32:34.830
So what are we talking about right here?

00:32:34.840 --> 00:32:38.480
We're talking about the space
between OpenGL and kind of

00:32:38.480 --> 00:32:40.650
the application frameworks.

00:32:40.700 --> 00:32:41.860
What's the architecture there?

00:32:41.860 --> 00:32:43.520
And it's pretty straightforward actually.

00:32:43.520 --> 00:32:45.520
It looks a little bit complicated.

00:32:45.640 --> 00:32:48.020
But I think if you understand
that you kind of have,

00:32:48.070 --> 00:32:49.420
it's like a kind of a menu.

00:32:49.420 --> 00:32:52.580
On the side with the gray box,
you actually pick one of

00:32:52.580 --> 00:32:54.340
those kind of interfaces.

00:32:54.450 --> 00:32:55.720
Those are the different
system interfaces.

00:32:55.780 --> 00:32:57.860
We have a GLUT,
which is a very high-level interface.

00:32:57.970 --> 00:32:59.110
We have NSOpenGL view.

00:32:59.110 --> 00:33:00.930
We have AGL as a Carbon interface.

00:33:01.000 --> 00:33:03.090
And we have CGL as a really
low-level interface that

00:33:03.090 --> 00:33:04.300
things are built on top of.

00:33:04.460 --> 00:33:06.050
And then also you obviously
have the green side,

00:33:06.050 --> 00:33:06.900
which is the OpenGL.

00:33:06.900 --> 00:33:10.350
Your application will talk
to pixel formats and context

00:33:10.350 --> 00:33:12.180
via one of the gray pieces.

00:33:12.180 --> 00:33:15.560
And you'll talk to
OpenGL via the green side.

00:33:15.710 --> 00:33:18.340
So that's kind of,
you kind of have a piece that is the

00:33:18.340 --> 00:33:20.540
application windowing system API.

00:33:20.540 --> 00:33:23.560
And you have another piece
that's actually OpenGL itself.

00:33:23.640 --> 00:33:25.360
And those both talk to the OpenGL engine.

00:33:27.370 --> 00:33:28.420
Four interfaces I'm going to talk about.

00:33:28.520 --> 00:33:33.540
NSOpenGL, CGL, AGL and GLUT.

00:33:33.580 --> 00:33:34.740
I think I already talked about it.

00:33:34.740 --> 00:33:36.980
NSOpenGL is the Cocoa interface.

00:33:36.980 --> 00:33:41.460
So that's the windowing system interface
that's set up for OpenGL and Cocoa.

00:33:41.550 --> 00:33:43.360
CGL is our low-level interface.

00:33:43.360 --> 00:33:46.760
You probably want to use it if
you're a full-screen app only.

00:33:47.660 --> 00:33:53.510
AGL is the Carbon interface and
GLUT is a kind of a high-level,

00:33:53.510 --> 00:33:58.120
source-level cross-platform interface
that has some event handling.

00:33:58.120 --> 00:33:59.120
It's a pretty simple interface.

00:33:59.180 --> 00:34:01.730
So NSOpenGL, Cocoa interface.

00:34:01.730 --> 00:34:03.820
This is an NSOpenGL view.

00:34:03.820 --> 00:34:06.980
It's a subclass of NSView and
you probably want a subclass

00:34:07.110 --> 00:34:09.480
NSOpenGL view for your own application.

00:34:09.500 --> 00:34:11.740
Contains a single pixel
format and context.

00:34:11.740 --> 00:34:16.140
And the reason that's important is if you
find you want to do multiple contexts,

00:34:16.140 --> 00:34:19.140
multiple windows,
you realize you probably don't

00:34:19.140 --> 00:34:21.040
want to use NSOpenGL view directly.

00:34:21.080 --> 00:34:23.720
What you probably want to do
is we have a sample that shows

00:34:23.790 --> 00:34:26.700
you how to basically replicate
that capabilities and extend it.

00:34:26.730 --> 00:34:29.450
So you can use the sample as a
basis to extend NSOpenGL view

00:34:29.450 --> 00:34:30.730
in a custom direction.

00:34:30.760 --> 00:34:33.130
You can create it via
Nib in interface builder.

00:34:33.260 --> 00:34:36.010
There's, like I said,
there's some special cases

00:34:36.090 --> 00:34:37.830
with context and pixel formats.

00:34:37.840 --> 00:34:40.950
And there's a lot of sample
code using this so it's

00:34:41.060 --> 00:34:43.260
really simple to instantiate.

00:34:43.300 --> 00:34:47.240
So why don't we go to the demo machine.

00:34:47.240 --> 00:34:47.580
And I'm going to show you how to do that.

00:34:47.660 --> 00:34:51.340
And we'll talk about how to use,
how to set up your first

00:34:51.380 --> 00:34:54.070
OpenGL application.

00:34:54.380 --> 00:34:55.940
No tricks, nothing up my sleeves.

00:34:56.060 --> 00:34:58.600
There's nothing,
I've done nothing to the demo machine.

00:34:58.720 --> 00:35:02.730
So I'm gonna, this is, after the session,
this is exactly what you can do.

00:35:02.730 --> 00:35:04.950
So you can launch Xcode.

00:35:05.130 --> 00:35:06.820
We'll create a new project.

00:35:06.820 --> 00:35:08.630
A Cocoa application.

00:35:08.660 --> 00:35:15.900
We'll call it OpenGL Getting Started.

00:35:20.140 --> 00:35:23.200
So this is my OpenGL application,
but it really doesn't do anything now,

00:35:23.200 --> 00:35:24.150
obviously.

00:35:24.300 --> 00:35:29.760
So the first thing we
want to do... Outstanding!

00:35:29.830 --> 00:35:32.740
Love that!

00:35:32.860 --> 00:35:36.240
No, we don't want to.

00:35:36.340 --> 00:35:38.940
Luckily that's not my part.

00:35:41.090 --> 00:35:43.520
Let's just call it GL.

00:35:43.520 --> 00:35:46.180
Maybe it likes two
letters better than a C.

00:35:48.480 --> 00:35:50.060
Maybe we're better this time.

00:35:50.180 --> 00:35:51.880
Didn't like me resizing probably before.

00:35:51.880 --> 00:35:55.260
So the first thing we'll look
at is we'll look at our nib.

00:35:55.280 --> 00:35:59.720
The way this starts out,
you have an empty window

00:35:59.720 --> 00:36:02.020
kind of thing in your nib,
and you really need to put something

00:36:02.020 --> 00:36:03.320
in it that represents OpenGL.

00:36:03.320 --> 00:36:05.390
So what we have is this
is your window right here,

00:36:05.420 --> 00:36:09.120
and over in your library
you have an OpenGL view,

00:36:09.120 --> 00:36:10.620
which represents the NSOpenGL view.

00:36:10.620 --> 00:36:11.750
So we can drop it in here.

00:36:11.760 --> 00:36:16.260
We'll resize it out to be a
reasonable size for your window.

00:36:18.680 --> 00:36:21.990
And then we'll go up to the
inspector here and do a few things.

00:36:22.130 --> 00:36:26.080
First, let's make it a subclass.

00:36:26.140 --> 00:36:26.210
So it's my...

00:36:30.200 --> 00:36:33.730
So we do my NSOpenGL view and
additionally we'll go into

00:36:33.730 --> 00:36:37.420
here and we will look at this
first pane of the NSOpenGL.

00:36:37.420 --> 00:36:42.130
This first pane is a lot of those
things I talked about in pixel formats.

00:36:42.140 --> 00:36:47.300
You notice there's a double buffer,
there's stereo, there's multi-sample,

00:36:47.330 --> 00:36:49.650
default render, allow offline.

00:36:49.650 --> 00:36:53.240
All those things are
things you can specify.

00:36:53.240 --> 00:36:55.930
So in this case I'm going to go
default color and what's at a depth

00:36:55.930 --> 00:36:59.270
buffer of 24-bit just so we have it
and we'll make it double buffered.

00:37:00.250 --> 00:37:02.780
So that's basically my pixel
format definition if you

00:37:02.850 --> 00:37:03.770
want to look at it that way.

00:37:03.770 --> 00:37:08.330
So I do that and the last thing is we
want to make it so it kind of actually

00:37:08.330 --> 00:37:10.080
looks nice when we zoom around.

00:37:10.080 --> 00:37:12.560
So we'll make it so it
expands with the window.

00:37:12.560 --> 00:37:17.000
We'll save that and we
will write the class files.

00:37:17.010 --> 00:37:19.460
Don't want to do Ruby,
we want to do Objective-C.

00:37:19.460 --> 00:37:22.940
And there we go.

00:37:22.940 --> 00:37:24.420
We'll add it to our project.

00:37:24.420 --> 00:37:29.640
So if you notice in the background we've
got some things added to our projects.

00:37:30.250 --> 00:37:33.800
We'll quit that and if you notice
now we have these two NSOpenGL view.

00:37:33.800 --> 00:37:39.190
They're very empty though so it's
not particularly interesting.

00:37:39.190 --> 00:37:39.190
So let's make that a little bit bigger.

00:37:39.700 --> 00:37:40.690
So this is the Vue.M.

00:37:40.700 --> 00:37:41.490
It doesn't do anything.

00:37:41.490 --> 00:37:44.760
Now here's my little trick that
you probably have seen before.

00:37:44.760 --> 00:37:46.960
Obviously,
we have a little bit of pieces here.

00:37:46.960 --> 00:37:51.340
But what's interesting is to draw OpenGL,
all you need is that piece.

00:37:51.340 --> 00:37:53.870
It basically says make
my context current,

00:37:53.870 --> 00:37:56.440
set a clear color, and clear the buffer.

00:37:56.440 --> 00:37:58.360
So all we're doing is
really clearing the buffer.

00:37:58.360 --> 00:38:00.150
And then at the end,
the flush buffer basically

00:38:00.150 --> 00:38:01.460
pushed my data to the screen.

00:38:01.460 --> 00:38:05.980
So I'm going to copy that,
drop it in here.

00:38:09.790 --> 00:38:11.400
Save that.

00:38:15.500 --> 00:38:17.920
Oh, shoot, I know what I forgot.

00:38:18.000 --> 00:38:21.900
My app, my project doesn't know
anything about OpenGL.

00:38:21.940 --> 00:38:28.870
So we also need to tell it two things.

00:38:28.870 --> 00:38:28.870
First, import

00:38:30.820 --> 00:38:34.330
And we'll do, this is a framework so if
you're not familiar with

00:38:34.330 --> 00:38:38.690
Cocoa it's basically like that.

00:38:40.200 --> 00:38:43.640
And it's gl.h is the header you want.

00:38:43.640 --> 00:38:47.580
And the last thing is,
in here when you create an OpenGL view,

00:38:47.880 --> 00:38:50.650
they want you to specify the subclass.

00:38:50.790 --> 00:38:54.270
So in this case, it's going to be a NS...

00:38:57.770 --> 00:39:00.860
Send us OpenGL view subclass.

00:39:00.910 --> 00:39:01.720
Thank you.

00:39:01.720 --> 00:39:06.000
Xcode is good about telling
me those things too.

00:39:06.080 --> 00:39:10.400
Now let's see how we're doing.

00:39:10.400 --> 00:39:13.890
Hmm hmm hmm hmm hmm.

00:39:16.600 --> 00:39:20.600
Okay, oh, oh, it's this thing,
I have something wrong here, oh.

00:39:20.600 --> 00:39:22.600
Jail clear.

00:39:22.730 --> 00:39:25.200
Oh, last thing,
I did forget one more thing.

00:39:25.200 --> 00:39:26.200
Frameworks.

00:39:26.200 --> 00:39:29.980
So it has some frameworks included,
but it does not have

00:39:30.010 --> 00:39:31.600
the OpenGL framework.

00:39:31.650 --> 00:39:35.790
So if I have a right click, I do.

00:39:36.400 --> 00:39:37.900
Let's do this.

00:39:37.940 --> 00:39:39.540
Linked frameworks.

00:39:39.580 --> 00:39:42.540
Add existing framework with
OpenGL's existing framework.

00:39:42.630 --> 00:39:43.610
Takes you right there.

00:39:43.760 --> 00:39:45.670
We'll scroll down.

00:39:46.460 --> 00:39:49.800
And add OpenGL framework, add that.

00:39:49.830 --> 00:39:52.670
Yes, default.

00:39:53.330 --> 00:39:53.630
There we go.

00:39:53.660 --> 00:39:59.920
So all this did, very simply,
is build a window that clears

00:39:59.920 --> 00:40:01.180
its OpenGL view to red.

00:40:01.230 --> 00:40:06.140
But the interesting thing is that's
the basic pieces of the code you need.

00:40:06.140 --> 00:40:08.530
If you did an NS log,
you'd see every time I resize it,

00:40:08.760 --> 00:40:12.680
it actually calls my draw routine,
so that's all done for you.

00:40:12.680 --> 00:40:14.880
You can add normal Cocoa interaction.

00:40:15.010 --> 00:40:17.850
You could add a button to that if you
wanted to that triggered some action.

00:40:17.900 --> 00:40:21.050
But really, this is the basis of getting
OpenGL up on the Mac.

00:40:21.180 --> 00:40:25.310
So there's not kind of this black magic,
hard to get your

00:40:25.310 --> 00:40:27.110
application up and running.

00:40:27.120 --> 00:40:29.200
If you remember to
spell things correctly,

00:40:29.200 --> 00:40:32.500
link the right frameworks in,
add the right header files,

00:40:32.500 --> 00:40:34.020
then you're golden.

00:40:34.040 --> 00:40:34.760
It's easy.

00:40:34.760 --> 00:40:35.740
So let's go back to the slides.

00:40:35.800 --> 00:40:37.030
All right.

00:40:44.210 --> 00:40:46.510
So let's talk for a minute about Glut.

00:40:46.510 --> 00:40:49.590
Glut is a cross-platform
source-compatible API.

00:40:49.590 --> 00:40:53.300
What that means is it's an API that
you'll see a snippet of code on

00:40:53.300 --> 00:40:55.380
the web that says built with Glut.

00:40:55.410 --> 00:40:59.920
And you can just grab that piece of code,
drop it into an NS new Cocoa project,

00:40:59.980 --> 00:41:03.570
add the Glut framework that we have,
and basically it'll work

00:41:03.590 --> 00:41:05.170
almost out of the box.

00:41:05.250 --> 00:41:07.360
So we have, there's a Glut example
in the sample code.

00:41:07.360 --> 00:41:08.920
It's really a simple API.

00:41:08.920 --> 00:41:12.100
It has some event handling,
has window handling, it's callback-based.

00:41:12.100 --> 00:41:15.470
It really is kind of good for that quick,
I want to test something

00:41:15.530 --> 00:41:16.280
out kind of thing.

00:41:16.280 --> 00:41:19.100
But as you saw,
Cocoa is pretty good for that, too.

00:41:19.100 --> 00:41:20.080
There's a few things.

00:41:20.150 --> 00:41:22.680
If you want to handle a couple
multiple windows or you want to

00:41:23.010 --> 00:41:25.530
handle certain kinds of input,
Cocoa may be a little bit longer,

00:41:25.530 --> 00:41:27.900
but I think I would recommend
going with Cocoa if you're

00:41:27.900 --> 00:41:29.620
writing something yourself.

00:41:29.620 --> 00:41:32.600
The reason I bring Glut up is there's
a lot of code out there that may

00:41:32.600 --> 00:41:34.180
be a source file that runs in Glut.

00:41:34.250 --> 00:41:36.570
And to know that you can
just create a Cocoa project,

00:41:36.570 --> 00:41:39.460
add that Glut framework,
and add your source code in,

00:41:39.460 --> 00:41:41.330
you'll get to see how it runs.

00:41:41.440 --> 00:41:43.800
So we have support for this on the Mac.

00:41:45.190 --> 00:41:46.880
So let's talk about
OpenGL ES on the iPhone.

00:41:46.880 --> 00:41:50.070
I'm going to do a very,
very light intro into kind of how it

00:41:50.070 --> 00:41:52.440
fits into this ecosystem of OpenGL.

00:41:52.440 --> 00:41:54.040
And today at 5 p.m.

00:41:54.040 --> 00:41:56.270
in Presidio,
we're going to talk in depth about

00:41:56.420 --> 00:41:58.160
building OpenGL ES apps on the iPhone.

00:41:58.160 --> 00:41:59.870
And I really suggest,
if you're interested in that,

00:41:59.940 --> 00:42:00.960
you go to that session.

00:42:00.960 --> 00:42:04.110
All of our engineers will be there,
and they'll be talking in

00:42:04.110 --> 00:42:05.330
depth about this topic.

00:42:05.340 --> 00:42:07.480
So it's a little bit different.

00:42:07.480 --> 00:42:10.170
Going back to that same kind of diagram,
a little bit different

00:42:10.170 --> 00:42:10.880
than you saw before.

00:42:10.880 --> 00:42:15.600
The application has, as we talked about,
a native Windows system API,

00:42:15.600 --> 00:42:20.340
and then it has an OpenGL platform API,
which we saw was AGL or NSOpenGL,

00:42:20.340 --> 00:42:21.060
those kind of things.

00:42:21.230 --> 00:42:22.840
And then there's OpenGL ES down there.

00:42:22.940 --> 00:42:25.820
And they both talk to pieces
of the low-level hardware.

00:42:25.820 --> 00:42:28.540
What does this mean for ES on the iPhone?

00:42:28.540 --> 00:42:33.340
What it means is we have an
API instead of NSOpenGL or AGL.

00:42:33.340 --> 00:42:34.500
We call it Eagle.

00:42:34.500 --> 00:42:40.290
Embedded Apple GL is the
Windows system API interface there.

00:42:40.460 --> 00:42:43.500
And we use core animation, actually,
instead of, you know, an application.

00:42:43.840 --> 00:42:45.630
We call it an AppKit view or
something like that as the

00:42:45.630 --> 00:42:47.580
kind of windowing system API.

00:42:47.580 --> 00:42:49.020
So those are the two
pieces you'll talk to,

00:42:49.270 --> 00:42:50.650
Eagle and core animation.

00:42:50.660 --> 00:42:54.120
And it turns out that core
animation actually will call back

00:42:54.290 --> 00:42:55.780
through OpenGL ES for compositing.

00:42:55.780 --> 00:42:58.880
So it's kind of like the Windows server
you think of on the Mac OS X,

00:42:58.880 --> 00:42:59.740
how it uses OpenGL.

00:42:59.740 --> 00:43:02.480
So you'll go through Eagle,
you go through core animation,

00:43:02.480 --> 00:43:06.240
and core animation could go
back through the Windows server

00:43:06.440 --> 00:43:08.340
or the OpenGL for compositing.

00:43:08.340 --> 00:43:09.710
What this means is two things.

00:43:09.850 --> 00:43:12.660
First,
you can composite layers using OpenGL.

00:43:12.660 --> 00:43:15.960
The second thing it means,
is that your OpenGL applications

00:43:16.060 --> 00:43:18.120
can actually,
will actually run full speed.

00:43:18.120 --> 00:43:20.380
They're only composited
when they need to be.

00:43:20.380 --> 00:43:23.700
They can run full speed to
the native windowing system.

00:43:26.640 --> 00:43:29.980
So basically the Eagle defines
the OS interface for

00:43:29.980 --> 00:43:31.560
OpenGL ES as we talked about.

00:43:31.760 --> 00:43:35.360
It manages your OpenGL ES context so
it's the same kind of context idea,

00:43:35.360 --> 00:43:37.440
the same idea about context supplies.

00:43:37.460 --> 00:43:41.090
It works with core animation on the
iPhone to display content because that

00:43:41.120 --> 00:43:42.840
really is your Windows server there.

00:43:42.990 --> 00:43:45.130
And it provides the
configuration of your drawables.

00:43:45.260 --> 00:43:48.440
So it's kind of the
same set of operations,

00:43:48.480 --> 00:43:51.300
a little bit different way of doing it,
the same set of operations that you'll

00:43:51.300 --> 00:43:53.990
see on the desktop you see on the iPhone.

00:43:54.920 --> 00:43:58.040
So finally,
the section we want to finish up with

00:43:58.040 --> 00:43:59.390
here is talking about techniques.

00:43:59.430 --> 00:44:01.700
I'll go through about three different
techniques that will help you

00:44:01.700 --> 00:44:05.200
interface with Mac OS X using OpenGL.

00:44:05.410 --> 00:44:07.760
First, I'll talk about a few
more than three actually.

00:44:07.890 --> 00:44:10.990
So I'll talk about five, I guess.

00:44:11.120 --> 00:44:12.760
I'll talk about detecting functionality.

00:44:12.900 --> 00:44:14.410
I'll talk about drawing
with vertex buffers.

00:44:14.480 --> 00:44:15.480
I'll talk about texturing.

00:44:15.510 --> 00:44:17.470
And lastly,
I'll talk a little bit about shaders.

00:44:17.660 --> 00:44:19.900
You may have heard of OpenGL shading
language and show you kind of

00:44:19.900 --> 00:44:22.190
where it fits into the puzzle.

00:44:22.480 --> 00:44:23.780
So first detecting functionality.

00:44:23.810 --> 00:44:26.460
We talked about OpenGL,
broad set of hardware support.

00:44:26.460 --> 00:44:30.460
You may need to understand what your
hardware you're running on is capable of.

00:44:30.500 --> 00:44:32.540
So you can use the
Git string to get GL version.

00:44:32.540 --> 00:44:35.540
So depending on the version,
it defines a set of functionality.

00:44:35.540 --> 00:44:37.060
You can also check extensions.

00:44:37.060 --> 00:44:40.790
You can get the extension string and say,
hey, I need this certain extension that

00:44:40.790 --> 00:44:44.030
extends OpenGL capability to make
sure that I can run my application.

00:44:44.100 --> 00:44:45.040
You can do that.

00:44:45.040 --> 00:44:47.590
And the other thing is the
Git integer is a way to check limits.

00:44:47.610 --> 00:44:49.370
So you can say, like,
how big of a texture can

00:44:49.370 --> 00:44:52.380
I actually load into the graphics
card I'm currently running on?

00:44:52.400 --> 00:44:54.360
The Git integer tells
you those kind of things.

00:44:54.360 --> 00:44:57.650
All this, again, there is a,
I believe there's a Q&A or a tech note

00:44:57.650 --> 00:44:59.460
specifically on detecting functionality.

00:44:59.460 --> 00:45:01.260
It goes into a lot of
depth on this subject.

00:45:01.260 --> 00:45:03.730
And I'll point you to that as if
you want to read more about it,

00:45:03.780 --> 00:45:07.080
talking about the different levels of
functionality in each version of OpenGL,

00:45:07.100 --> 00:45:07.860
for example.

00:45:10.170 --> 00:45:11.610
So, drawing with vertex buffer objects.

00:45:11.630 --> 00:45:14.240
Why do I want to tell you
about vertex buffer objects?

00:45:14.240 --> 00:45:16.380
Why am I interested in
vertex buffer objects?

00:45:16.430 --> 00:45:19.700
It actually is a fairly advanced topic.

00:45:19.990 --> 00:45:20.350
Could be.

00:45:20.360 --> 00:45:22.480
I mean, it could,
there's a lot of information out there.

00:45:22.480 --> 00:45:25.120
But the reason why is because
I don't want you writing this code.

00:45:25.160 --> 00:45:29.380
I don't want you writing begin,
end with a bunch of vertices in it.

00:45:29.510 --> 00:45:32.400
This is the first example in the first
edition of the Red Book and this is

00:45:32.480 --> 00:45:34.360
basically what we call immediate mode.

00:45:34.360 --> 00:45:38.180
This is, the best example I can give is,
hey, we all have to go grocery

00:45:38.180 --> 00:45:39.440
shopping at times.

00:45:40.350 --> 00:45:42.600
Immediate mode is,
I look at my list at home,

00:45:42.600 --> 00:45:43.550
I say I need tomatoes.

00:45:43.590 --> 00:45:44.720
Well, I don't need tomatoes.

00:45:44.720 --> 00:45:45.850
I can't get tomatoes today.

00:45:45.920 --> 00:45:46.840
I'll eat cucumbers.

00:45:46.930 --> 00:45:47.900
So, I'll go get cucumbers.

00:45:47.900 --> 00:45:52.580
So, I run to the store, cucumbers,
run back home.

00:45:52.580 --> 00:45:56.550
Steak, go to the store, get steak,
go back home.

00:45:58.160 --> 00:45:58.500
Potatoes.

00:45:58.500 --> 00:45:59.560
Go to the store, get potatoes.

00:45:59.620 --> 00:46:00.030
Go back home.

00:46:00.060 --> 00:46:01.920
As you see,
you're spending a lot of time in the car.

00:46:01.960 --> 00:46:05.700
The immediate mode spends
a lot of time in API calls.

00:46:05.700 --> 00:46:07.340
Spends a lot of time begin-end.

00:46:07.340 --> 00:46:08.130
And think about it.

00:46:08.130 --> 00:46:10.040
If you have a thousand
triangles you're drawing,

00:46:10.040 --> 00:46:11.790
you could have a thousand begin-ends.

00:46:11.800 --> 00:46:13.920
If you have different state changes,
you could have more.

00:46:13.920 --> 00:46:15.660
Quake 3.

00:46:15.660 --> 00:46:19.940
So Quake 3 is a 2002 application.

00:46:19.940 --> 00:46:23.020
It has about 10,000 triangles per frame.

00:46:23.020 --> 00:46:24.820
Think about that if you did begin-end.

00:46:24.820 --> 00:46:27.950
There's 10,000 API calls that
you need to make just to get

00:46:28.100 --> 00:46:29.170
those triangles to the screen.

00:46:29.180 --> 00:46:32.980
Vertex buffer object allow you to
encapsulate that in a single call.

00:46:32.980 --> 00:46:36.460
So your call overhead
is significantly less.

00:46:36.480 --> 00:46:40.720
And in the end,
it's just as easy to use as begin-end.

00:46:40.720 --> 00:46:43.120
So that's my point today is that
I'm going to show you how to use

00:46:43.180 --> 00:46:46.080
simple vertex buffer objects and say
they're just as easy as a begin-end.

00:46:46.080 --> 00:46:50.300
You can get away from begin-end,
start out day one vertex buffer objects,

00:46:50.300 --> 00:46:51.440
and just stay there.

00:46:52.810 --> 00:46:54.150
So, vertex buffer object.

00:46:54.280 --> 00:46:54.940
What is a VBO?

00:46:54.940 --> 00:46:55.860
Well, it's an object.

00:46:55.860 --> 00:46:58.110
So there's some object API in OpenGL.

00:46:58.190 --> 00:47:01.300
And basically,
it's a buffer of vertex attributes.

00:47:01.370 --> 00:47:06.140
Vertex attributes are vertex position,
vertex colors, texture coordinates.

00:47:06.140 --> 00:47:07.740
Those kind of things
are vertex attributes.

00:47:07.740 --> 00:47:10.420
So it's a buffer of those
accessible through an object ID.

00:47:10.420 --> 00:47:11.920
Really simple to create objects.

00:47:12.110 --> 00:47:13.750
First, we have a vertex buffer object.

00:47:13.830 --> 00:47:15.520
It references a bunch of stuff.

00:47:15.520 --> 00:47:18.070
And in this case, we have vertices,
we have colors,

00:47:18.070 --> 00:47:19.960
and we have texture coordinates.

00:47:20.050 --> 00:47:22.610
And think of those as each like a buffer,
sub-buffer.

00:47:22.720 --> 00:47:24.420
Inside what the object points to.

00:47:24.420 --> 00:47:27.050
So the object is your pointer,
and you have a bunch of data

00:47:27.050 --> 00:47:27.920
that you're pointing to.

00:47:27.920 --> 00:47:29.520
So setting up data for VBOs.

00:47:29.520 --> 00:47:32.260
This could be complicated,
but it really isn't.

00:47:32.320 --> 00:47:35.750
This data you see here is exactly
the same data you saw with begin-end.

00:47:35.750 --> 00:47:38.810
So it's just a, I just declared,
you know, vertex data and gave

00:47:38.810 --> 00:47:40.060
some information to it.

00:47:40.060 --> 00:47:42.820
You can declare it,
it can be dynamic or it can be static.

00:47:42.820 --> 00:47:44.990
In this case,
I just declared it statically.

00:47:45.190 --> 00:47:48.040
And you can actually simply get
access to that and simply draw a

00:47:48.040 --> 00:47:52.110
triangle using vertex buffer objects
instead of going through begin-end.

00:47:52.700 --> 00:47:55.810
So what are the steps you need to
do to use vertex buffer objects?

00:47:55.840 --> 00:47:57.340
First, you gen a buffer.

00:47:57.510 --> 00:48:02.240
The gen, glgen is something you'll
learn to use a lot in OpenGL.

00:48:02.390 --> 00:48:04.820
You do textures, vertex buffer objects,
everything,

00:48:04.830 --> 00:48:07.460
all the objects in OpenGL gets
generated in the same way.

00:48:07.460 --> 00:48:10.210
And then you bind to that buffer.

00:48:12.840 --> 00:48:15.710
After you bind to the buffer, say,
this is current.

00:48:15.750 --> 00:48:16.740
This is what I'm working on.

00:48:16.740 --> 00:48:17.440
Remember, state machine.

00:48:17.440 --> 00:48:18.770
This is the current
buffer I'm working on.

00:48:18.860 --> 00:48:21.140
I'm going to actually
load some buffer data.

00:48:21.140 --> 00:48:21.800
Look at this.

00:48:21.900 --> 00:48:24.940
I just use size of the vertex data
and a pointer to the vertex data.

00:48:24.940 --> 00:48:26.350
And I say static draw.

00:48:26.360 --> 00:48:27.830
Static data,
I'm going to want to draw it.

00:48:27.940 --> 00:48:30.280
So it's a really simple
setup for the vertex buffer.

00:48:30.370 --> 00:48:33.800
And then the last piece is,
which is kind of the little nuance

00:48:33.890 --> 00:48:35.980
of the vertex buffer object,
is you have to specify a vertex

00:48:36.040 --> 00:48:39.230
pointer that points to the
beginning of that data and says,

00:48:39.370 --> 00:48:40.060
here's what I'm going to draw.

00:48:40.240 --> 00:48:43.100
So again, we take the type,
which is three component.

00:48:43.100 --> 00:48:43.670
It's float.

00:48:43.680 --> 00:48:45.120
And we have an offset of zero.

00:48:45.120 --> 00:48:46.760
So basically, we're saying at the
beginning of the data,

00:48:46.760 --> 00:48:49.860
I have three components per vertex.

00:48:49.960 --> 00:48:51.180
I have floating point data.

00:48:51.180 --> 00:48:52.270
That's what you're going to draw with.

00:48:52.360 --> 00:48:56.320
And finally, drawing,
you bind the buffer, you enable it,

00:48:56.420 --> 00:48:57.630
and you draw with it.

00:48:57.660 --> 00:48:59.220
Really simple.

00:48:59.220 --> 00:49:01.470
You can get away from begin, end,
forever.

00:49:05.350 --> 00:49:06.590
So let's talk about texture
loading a little bit.

00:49:06.690 --> 00:49:08.960
Moving on to a different topic,
talking about this

00:49:08.960 --> 00:49:10.160
more Mac OS X specific.

00:49:10.160 --> 00:49:12.000
So texture loading, two ways to do it.

00:49:12.040 --> 00:49:16.260
Either purely through our Cocoa API or
through Quartz and Image.io.

00:49:16.260 --> 00:49:19.290
Through Cocoa, basically,
you take a bitmap representation

00:49:19.290 --> 00:49:20.470
of a view or of an image.

00:49:20.470 --> 00:49:23.750
And that's pretty simple,
straightforward Cocoa code here.

00:49:23.960 --> 00:49:26.810
For Image.io,
it's a little bit more flexibility,

00:49:26.810 --> 00:49:29.640
a little bit more code,
but gives you a way to look at

00:49:29.730 --> 00:49:33.330
more like the raw data that you
have in the buffer or in the image.

00:49:33.330 --> 00:49:35.160
So let's jump right in and say,

00:49:36.600 --> 00:49:38.180
And it's bitmap image rep from NS view.

00:49:38.180 --> 00:49:39.760
So we have an NS view.

00:49:39.760 --> 00:49:42.340
So you have an NS view
with some content in it,

00:49:42.340 --> 00:49:44.550
whatever that is,
an image or whatever you have.

00:49:44.560 --> 00:49:47.080
You could have grabbed the
view from somewhere else.

00:49:47.510 --> 00:49:49.680
Basically, you're going to allocate
a bitmap image rep,

00:49:49.720 --> 00:49:53.180
and then you're going to initialize
it with a knit with focus view rec.

00:49:53.280 --> 00:49:55.840
And what that does is basically says,
I have a view,

00:49:56.220 --> 00:50:00.320
initialize the bitmap contents
with the contents of the view,

00:50:00.380 --> 00:50:01.590
and this bounds.

00:50:01.600 --> 00:50:05.800
So basically what you're doing is you're
stamping down that view onto an actual

00:50:05.800 --> 00:50:07.800
array of pixels that OpenGL can access.

00:50:07.800 --> 00:50:09.040
So it's pretty simple again.

00:50:09.040 --> 00:50:12.240
Basically, you're going to allocate it,
you're going to lock the focus,

00:50:12.240 --> 00:50:14.130
you're going to knit
the view with the rec,

00:50:14.200 --> 00:50:15.220
and then you unlock the focus.

00:50:15.220 --> 00:50:17.640
So it's really straightforward
kind of Cocoa code.

00:50:17.640 --> 00:50:21.520
But this gives OpenGL a bitmap that
it can actually use for texturing.

00:50:21.520 --> 00:50:22.780
So what do you do with it then?

00:50:22.780 --> 00:50:25.000
A few things to learn here about OpenGL.

00:50:25.000 --> 00:50:31.170
Pixel Store I is a way to set
up information to OpenGL about

00:50:31.170 --> 00:50:32.280
how your data is arranged.

00:50:32.360 --> 00:50:35.490
In this case, all you want to say is,
"Hey, I'm going to set up a bitmap.

00:50:35.500 --> 00:50:38.810
"It's really default arrangement." I'm
going to say the length of the row of

00:50:38.980 --> 00:50:43.300
the incoming data is the pixels wide,
is a bitmap pixel width.

00:50:43.620 --> 00:50:48.240
And I'm also going to say the alignment
of these pixels are just simply aligned.

00:50:48.240 --> 00:50:49.370
There's no strange alignment.

00:50:49.730 --> 00:50:51.480
There's no skipping
or anything like that.

00:50:51.590 --> 00:50:54.490
So that basically says to OpenGL,
it's very simple access.

00:50:54.580 --> 00:50:55.990
It's very straightforward access.

00:50:56.040 --> 00:50:57.380
I'm going to gen a texture.

00:50:57.380 --> 00:50:58.720
Remember that gen statement
we showed earlier?

00:50:58.720 --> 00:51:01.460
This gives me a gen a texture,
and I'm going to bind to that texture.

00:51:01.460 --> 00:51:02.170
I make it current.

00:51:02.310 --> 00:51:03.940
So it's my current texture
that I'm working with.

00:51:03.940 --> 00:51:05.560
It's a state machine thing.

00:51:05.610 --> 00:51:09.900
When we go back, all I'm going to do here
is do the text to image 2D.

00:51:09.900 --> 00:51:12.820
And the text image 2D call is
the thing that takes the bitmap,

00:51:12.820 --> 00:51:15.850
basically,
and grabs it and uses it for OpenGL.

00:51:15.960 --> 00:51:17.800
The samples that will
show how to do this,

00:51:17.880 --> 00:51:19.900
but I wanted to show
you this code to say,

00:51:19.900 --> 00:51:23.180
basically, you're going to have a view
or an image or whatever.

00:51:23.240 --> 00:51:25.140
You draw into a bitmap.

00:51:25.210 --> 00:51:30.780
You basically set your striding
up of what OpenGL's current

00:51:30.780 --> 00:51:33.640
striding is so it understands
the way your pixels are laid out.

00:51:33.640 --> 00:51:36.380
You create a texture,
and you draw into the texture,

00:51:36.380 --> 00:51:38.400
or you create the whole GL text image 2D.

00:51:38.400 --> 00:51:39.850
And then you can release a bitmap.

00:51:39.930 --> 00:51:43.980
You don't need the bitmap anymore because
you've captured that data in OpenGL.

00:51:45.750 --> 00:51:48.520
So let me jump back to my demo.

00:51:48.520 --> 00:51:50.350
I'm going to encapsulate some
of the things we talked about.

00:51:50.360 --> 00:51:53.220
So this is great that
we have this app here,

00:51:53.220 --> 00:51:57.400
but what I really want to do is actually
I want to show you the VBO example more.

00:51:57.400 --> 00:52:01.680
In this case,
we're going to keep the same code

00:52:01.680 --> 00:52:02.600
that we've worked with already.

00:52:02.600 --> 00:52:03.920
We're going to expand it a little bit.

00:52:04.030 --> 00:52:09.700
So this may look interesting to you
because this code right here is basically

00:52:10.790 --> 00:52:14.460
similar to the code we saw on the slides,
which is just vertex data.

00:52:14.460 --> 00:52:15.380
So we're going to grab that.

00:52:15.380 --> 00:52:17.420
And we're going to go back to our thing.

00:52:17.420 --> 00:52:20.750
And that's just global...

00:52:22.200 --> 00:52:40.200
[Transcript missing]

00:52:42.670 --> 00:52:47.430
And then I'm going to jump down
here to my draw rec routine.

00:52:47.430 --> 00:52:49.360
And actually I'm going to grab all
three of these routines at this point

00:52:49.360 --> 00:52:55.010
and I'll go through each of them
exactly what they do and show you...

00:52:56.120 --> 00:52:58.640
is just covering what
we talked about before.

00:52:58.640 --> 00:53:00.940
So I'm going to replace that
simple draw rack with a little

00:53:00.940 --> 00:53:01.980
bit more complicated one.

00:53:01.980 --> 00:53:03.620
Okay, so what do we have here?

00:53:03.640 --> 00:53:06.070
So this first thing is set viewport.

00:53:06.080 --> 00:53:09.030
And set viewport is called
by the draw routine.

00:53:09.040 --> 00:53:13.070
And all it really does is get
the bounds of the view we have,

00:53:13.120 --> 00:53:16.550
the NSOpenGL view bounds,
and basically calls a GL set viewport.

00:53:16.750 --> 00:53:19.360
What this does is it scales
your OpenGL content to the

00:53:19.620 --> 00:53:21.030
viewport as it changes.

00:53:21.040 --> 00:53:24.390
So the only reason I'm doing this is
so I can drag the window bigger and

00:53:24.390 --> 00:53:27.010
smaller and you can actually see the
OpenGL content correctly scaling.

00:53:27.240 --> 00:53:29.490
You'll know if you didn't do this
correctly because your OpenGL content

00:53:29.510 --> 00:53:34.700
will still be constrained to a
kind of a static rectangle in your

00:53:34.710 --> 00:53:36.600
viewport even as you change sizes.

00:53:36.690 --> 00:53:41.300
So this is what that GL viewport
basically makes a GL viewport respond

00:53:41.420 --> 00:53:43.710
to the entire size of the view.

00:53:44.190 --> 00:53:45.910
So prepare OpenGL is
something I've added.

00:53:45.910 --> 00:53:50.640
It's an override of a class
interface prepare OpenGL.

00:53:50.840 --> 00:53:52.140
And basically it sets a clear color.

00:53:52.140 --> 00:53:54.300
So it sets a clear color to
a color that we did before.

00:53:54.300 --> 00:53:57.060
It does exactly the buffer
generation that we did before.

00:53:57.060 --> 00:53:58.630
It gens a color buffer.

00:53:58.630 --> 00:53:59.830
It binds to that.

00:53:59.880 --> 00:54:04.250
It then puts the data in from the color
buffer with the size of the color data.

00:54:04.250 --> 00:54:07.490
I mean that's what we saw
before right on the slides.

00:54:07.570 --> 00:54:09.920
And then sets a color pointer
to the beginning of it.

00:54:09.950 --> 00:54:11.380
There's three components in this.

00:54:11.380 --> 00:54:12.850
They're unsigned byte components.

00:54:12.850 --> 00:54:14.080
Remember 0 to 255.

00:54:14.100 --> 00:54:16.770
So that's what I supplied
in my color data.

00:54:16.770 --> 00:54:23.660
For the vertex data buffer,
I generate the buffer, bind to it,

00:54:23.880 --> 00:54:26.440
set the data, and set the vertex pointer.

00:54:29.070 --> 00:54:29.670
and my draw rack.

00:54:29.770 --> 00:54:31.570
A little bit more complicated,
but still pretty simple.

00:54:31.570 --> 00:54:32.350
We saw the beginning of it.

00:54:32.580 --> 00:54:33.220
Make current context.

00:54:33.220 --> 00:54:34.050
We saw that last time.

00:54:34.320 --> 00:54:37.020
There's my set viewport call,
so that makes sure my content

00:54:37.020 --> 00:54:38.520
is scaled to the viewport.

00:54:38.520 --> 00:54:39.710
We're going to clear our buffer.

00:54:39.710 --> 00:54:41.740
Since we're double buffered,
we want to be clear and have a

00:54:41.740 --> 00:54:44.560
clear draw surface every time,
so we're going to clear our color buffer.

00:54:44.560 --> 00:54:47.410
We're going to enable client state
for GL vertex array and color array,

00:54:47.420 --> 00:54:48.650
so we're going to do that.

00:54:48.680 --> 00:54:51.920
And then we're going to call
draw arrays with triangles,

00:54:52.250 --> 00:54:54.500
and we have six points in there to draw.

00:54:55.000 --> 00:54:55.980
And so that's the size.

00:54:55.980 --> 00:54:57.900
So remember,
these are enabling the client

00:54:58.090 --> 00:55:00.150
state that we just talked about,
the vertex buffer object,

00:55:00.150 --> 00:55:02.400
then we disable the client state,
and we swap.

00:55:02.530 --> 00:55:04.140
So pretty straightforward code.

00:55:04.140 --> 00:55:06.510
Things we saw on the slides,
and we're going to see now if this

00:55:06.510 --> 00:55:09.920
actually works and draws something that's
slightly more interesting than red.

00:55:09.940 --> 00:55:12.060
So that looks good to me.

00:55:12.060 --> 00:55:17.280
So what we have here is, very simply,
we just did two triangles,

00:55:17.280 --> 00:55:19.580
and let's actually prove
that we did two triangles.

00:55:19.580 --> 00:55:22.400
Let me see if I can do this
without breaking everything.

00:55:29.740 --> 00:55:33.140
So if I only draw three of the points,
I have a single triangle.

00:55:33.260 --> 00:55:35.280
So we specify the colors
for those three triangles.

00:55:35.520 --> 00:55:38.070
We specify the vertex points
for each of those triangles.

00:55:38.330 --> 00:55:41.930
The viewport ensures that our
view scales well when we drag.

00:55:41.930 --> 00:55:46.950
And now you can actually write apps
that do not require begin end and

00:55:47.000 --> 00:55:49.900
you can use vertex buffer objects.

00:55:50.140 --> 00:55:52.630
Hop back to the slides.

00:55:58.580 --> 00:55:59.940
So we talked about one kind of texturing.

00:55:59.940 --> 00:56:01.460
Now I'm going to talk about a
different kind of texturing.

00:56:01.460 --> 00:56:03.280
So this is texturing
with Quartz and ImageIO.

00:56:03.280 --> 00:56:06.450
So we talked about the kind
of pure Cocoa version of it.

00:56:06.520 --> 00:56:11.880
In this case, it's a little bit different
using mostly Core Graphics calls.

00:56:12.070 --> 00:56:15.660
We see Core Graphics image
source create with URL as a call.

00:56:15.660 --> 00:56:17.870
We see the create image and index.

00:56:17.870 --> 00:56:21.200
And the key here is the
CG data provider copy data.

00:56:21.200 --> 00:56:22.970
So why would I want to use this?

00:56:22.970 --> 00:56:26.850
Calls a little bit longer,
maybe a little bit more complicated code,

00:56:26.850 --> 00:56:28.470
vice using the NS version of it.

00:56:28.500 --> 00:56:31.980
The reason why I want to use this is
because that CG data provider call,

00:56:32.070 --> 00:56:36.020
that data provider call says I just
want kind of a raw copy of that data.

00:56:36.020 --> 00:56:37.630
You have to understand
what the format is,

00:56:37.640 --> 00:56:39.950
but basically you're going to
get just a raw copy of the data.

00:56:39.950 --> 00:56:41.620
So there's no pre-multiplied alpha.

00:56:41.620 --> 00:56:45.460
So if you're using, for example, shaders,
and when you actually stamp

00:56:45.580 --> 00:56:48.410
the image down in Cocoa,
you're actually drawing it and

00:56:48.410 --> 00:56:50.520
you're drawing into that bitmap.

00:56:50.530 --> 00:56:53.500
So you actually have the alphas
pre-multiplied through to

00:56:53.500 --> 00:56:55.220
get the values in the bitmap.

00:56:55.220 --> 00:56:58.140
This preserves the
native pixels you have.

00:56:58.280 --> 00:57:00.990
So in some cases,
especially with shaders,

00:57:00.990 --> 00:57:03.500
you want to use this kind
of algorithm to do it.

00:57:03.550 --> 00:57:06.550
And then you get the data by
a byte pointer to the data.

00:57:06.550 --> 00:57:09.340
So you just get a basically
pointer to the data.

00:57:09.340 --> 00:57:12.540
And kind of the rest is pretty
much the same as we saw before.

00:57:12.540 --> 00:57:14.450
In this case,
you're just going to use the

00:57:14.450 --> 00:57:15.980
CG things to get the image width.

00:57:16.070 --> 00:57:18.280
You're going to unpack row length,
the width.

00:57:18.280 --> 00:57:20.300
You're going to set
the alignment the same,

00:57:20.300 --> 00:57:22.260
gen textures and text image 2D.

00:57:22.260 --> 00:57:25.230
So it's exactly the same kind of setup.

00:57:25.350 --> 00:57:28.140
The only beginning is that
CG data provider call.

00:57:28.160 --> 00:57:29.430
So I'm going to go back to it.

00:57:29.590 --> 00:57:31.560
CG data provider copy data.

00:57:31.560 --> 00:57:33.760
That is the key for this.

00:57:33.760 --> 00:57:36.930
I think we have it in our documentation.

00:57:36.960 --> 00:57:42.320
And I think there's at least one
sample that uses this technique.

00:57:42.320 --> 00:57:45.300
So if you need to preserve your
component data or have strange data,

00:57:45.300 --> 00:57:47.690
kind of a strange format,
you want to get it directly,

00:57:47.700 --> 00:57:48.860
this is the way to do it.

00:57:52.000 --> 00:57:53.760
So let's move on and talk
about shaders a little bit.

00:57:53.780 --> 00:57:57.620
So shaders are kind of more of
an advanced topic in OpenGL,

00:57:57.620 --> 00:58:00.390
but there's an interesting use for it,
even if you're kind of beginning

00:58:00.400 --> 00:58:01.780
OpenGL or just getting into it.

00:58:01.840 --> 00:58:05.970
The fact is that you can do kind of
direct manipulation of your drawing

00:58:06.030 --> 00:58:10.030
without writing a lot of code or
without understanding the nuances

00:58:10.160 --> 00:58:11.350
of a fixed function pipeline.

00:58:11.360 --> 00:58:15.650
So what is GLSL, OpenGL Shading Language?

00:58:15.660 --> 00:58:18.300
It's a high-level,
it's a C-like language for shading.

00:58:18.300 --> 00:58:22.500
It's integrated into the OpenGL API and
really simplifies the pipeline.

00:58:22.500 --> 00:58:26.500
That diagram I showed earlier had
a lot of boxes on it and had some

00:58:26.740 --> 00:58:28.260
vertex data and pixel data coming in.

00:58:28.260 --> 00:58:30.620
Well, with shading,
you really simplify it to you

00:58:31.000 --> 00:58:34.280
have texture data on the side
that's available to your shaders,

00:58:34.280 --> 00:58:35.740
and you have those vertex attributes.

00:58:35.740 --> 00:58:36.820
Remember we talked about those.

00:58:37.200 --> 00:58:42.250
Those are vertex position, colors,
texture cords.

00:58:42.260 --> 00:58:43.310
Those kind of things come in.

00:58:43.320 --> 00:58:44.680
You go through a vertex shader.

00:58:44.680 --> 00:58:46.610
You can go through a
geometry shader if you want.

00:58:46.620 --> 00:58:48.920
You can go through a fragment shader,
and you go out to the screen.

00:58:48.920 --> 00:58:50.230
All pieces are optional.

00:58:50.490 --> 00:58:53.370
So for example,
you can have an application that

00:58:53.770 --> 00:58:55.820
did the normal 3D transform.

00:58:55.820 --> 00:58:57.200
You drew some 3D object.

00:58:57.200 --> 00:59:00.500
You do all that in OpenGL in
the fixed function,

00:59:00.500 --> 00:59:02.860
and you just put a fragment shader
on the back end to do some special

00:59:02.860 --> 00:59:04.400
operation with the pixels itself.

00:59:04.420 --> 00:59:05.590
All right.

00:59:06.900 --> 00:59:07.640
So vertex shader.

00:59:07.660 --> 00:59:10.140
So vertex shader replaces that, again,
that front-end piece.

00:59:10.250 --> 00:59:12.610
So it's transformation,
texture coordinate generation,

00:59:12.610 --> 00:59:14.340
and the lighting parts of the OpenGL API.

00:59:14.340 --> 00:59:17.450
So if you look at this
piece of code up here,

00:59:17.460 --> 00:59:18.500
again, it looks like C.

00:59:18.500 --> 00:59:19.520
It's pretty straightforward.

00:59:19.520 --> 00:59:20.650
It has a main.

00:59:20.660 --> 00:59:22.730
And really what it's saying
is it does two things.

00:59:22.870 --> 00:59:23.700
First, it defines a color.

00:59:23.700 --> 00:59:28.060
So it takes some information that
was sent in and defines a color.

00:59:28.060 --> 00:59:31.750
The color is defined as a varying,
which means in GLSL parlance,

00:59:31.750 --> 00:59:34.400
it means it's an output
of a vertex shader.

00:59:34.740 --> 00:59:37.130
And then the other thing is it
uses a built-in function called

00:59:37.180 --> 00:59:38.880
ftransform to transform the position.

00:59:38.930 --> 00:59:41.600
So this is kind of your
simplest kind of vertex shader.

00:59:41.600 --> 00:59:43.900
But what this does, it gets you,
if you don't use lighting

00:59:43.900 --> 00:59:45.600
or anything like that,
if you're just using,

00:59:45.600 --> 00:59:48.340
just want to transform your things,
it actually kind of gets you from

00:59:48.340 --> 00:59:51.500
the basic shader usage and you can
get to your fragment shader next if

00:59:51.600 --> 00:59:53.330
you want to do some things in this.

00:59:53.420 --> 00:59:55.480
This would be fine for
someone who's using,

00:59:55.480 --> 00:59:59.550
just wants that basic piece of the
transform 3D to 2D part of the pipeline.

00:59:59.560 --> 01:00:06.740
The fragment shader, actually,
it's... It's a very simple view in life.

01:00:06.740 --> 01:00:10.890
What it needs to do in life is actually
take the inputs from the vertex shader

01:00:10.970 --> 01:00:11.690
and actually write one fragment.

01:00:11.760 --> 01:00:14.700
So remember we talked
at the very beginning,

01:00:14.730 --> 01:00:17.740
we talked about OpenGL taking a bunch
of stuff and writing one fragment out.

01:00:17.740 --> 01:00:19.730
That's what the fragment shader does.

01:00:19.840 --> 01:00:20.740
You know, there's a frag color.

01:00:20.740 --> 01:00:21.710
You define frag color.

01:00:21.750 --> 01:00:24.440
A fragment shader does not define
frag color or optionally depth

01:00:24.540 --> 01:00:25.700
if you have a depth buffer.

01:00:25.820 --> 01:00:26.740
It's basically undefined.

01:00:26.740 --> 01:00:29.690
So for a fragment shader,
in almost every case,

01:00:29.690 --> 01:00:31.740
you want to define frag color.

01:00:31.740 --> 01:00:33.740
Remember that little chameleon
shot in the background?

01:00:33.740 --> 01:00:34.230
Yeah.

01:00:34.240 --> 01:00:34.740
Yeah.

01:00:34.740 --> 01:00:36.720
beginning,
how it walks across each pixel.

01:00:36.800 --> 01:00:39.870
The fragment shader is actually
executed on each one of those pixels.

01:00:39.970 --> 01:00:42.630
So if you think about it,
your job in life as a fragment shader

01:00:42.630 --> 01:00:45.010
is to color that pixel a certain color.

01:00:45.120 --> 01:00:47.720
Could be based on a texture,
could be based on a lot of things,

01:00:47.720 --> 01:00:51.080
but in general, it's to color that pixel.

01:00:51.080 --> 01:00:54.700
So let's go back to the demo machine,
and I'll do one more demo.

01:00:58.370 --> 01:01:01.450
In this case,
I'm going to open our new shader builder.

01:01:01.450 --> 01:01:03.800
And I'll go find it.

01:01:06.660 --> 01:01:09.880
So we have Shader Builder
is new for Snow Leopard.

01:01:09.880 --> 01:01:13.610
I believe it will be in
a Leopard update also,

01:01:13.670 --> 01:01:18.080
but it definitely is on
your seed for Snow Leopard.

01:01:18.080 --> 01:01:22.210
And the simple thing I'm going to
do here is just open two shaders.

01:01:22.730 --> 01:01:24.690
And I'll talk you through
it because they're a little

01:01:24.690 --> 01:01:26.580
bit small on the side here.

01:01:26.610 --> 01:01:30.000
But basically the first one you create
if you do command N is a vertex shader

01:01:30.000 --> 01:01:31.230
and the second one is a fragment shader.

01:01:31.240 --> 01:01:37.340
So if I pull off the rendering view here,
what these shaders do is actually

01:01:37.370 --> 01:01:39.390
render this thing and say,
well,

01:01:39.450 --> 01:01:41.240
how do I know that renders this thing?

01:01:41.790 --> 01:01:43.300
Well, let's do this.

01:01:43.500 --> 01:01:45.940
Let's just say,
this is my fragment shader.

01:01:45.940 --> 01:01:47.370
I'll say vec4.

01:01:47.500 --> 01:01:49.400
The red means it didn't compile.

01:01:49.400 --> 01:01:51.400
I'm going to say 1, 0.

01:01:51.400 --> 01:01:54.730
I'm going to say vec4 of white,
basically.

01:01:54.740 --> 01:01:59.250
So as you can see,
I just typed in here and as I was typing,

01:01:59.300 --> 01:02:03.310
I'm actually changing
the output of the shader.

01:02:03.320 --> 01:02:06.760
One interesting thing you can see here
is how you can actually affect something.

01:02:06.760 --> 01:02:08.430
Let's say this is basically
what you want to do.

01:02:08.440 --> 01:02:11.320
You want to have an application that
draws a texture and then color-opticates.

01:02:11.400 --> 01:02:13.390
You want to put some
kind of coloring onto it.

01:02:13.670 --> 01:02:18.190
Well, what that means is that I want
to do some kind of colorization.

01:02:18.200 --> 01:02:21.210
So that means I probably want
to multiply by some factor.

01:02:21.320 --> 01:02:24.050
We'll call it color here.

01:02:24.200 --> 01:02:26.780
And obviously I have to define color.

01:02:27.090 --> 01:02:32.980
We'll make it a vec4 so I can even
control alpha and we'll do vec4 color.

01:02:33.200 --> 01:02:35.530
Actually, I don't want to put it there.

01:02:35.530 --> 01:02:37.200
I want to put it at the top.

01:02:37.200 --> 01:02:40.930
We'll make it a uniform qualifier.

01:02:45.290 --> 01:02:46.840
And now I don't get anything.

01:02:46.840 --> 01:02:49.040
Oh, that's... Okay, hold on.

01:02:49.040 --> 01:02:50.040
Uniforms.

01:02:50.040 --> 01:02:51.010
Okay, uniforms.

01:02:51.100 --> 01:02:53.040
Uniforms are things that are
sent in from the program.

01:02:53.040 --> 01:02:55.540
And when I added uniform
to a fragment shader,

01:02:55.540 --> 01:03:01.540
it actually appeared in the shader
builder in this kind of API,

01:03:01.540 --> 01:03:02.540
so you can actually change it.

01:03:02.540 --> 01:03:04.540
You can change this programmatically
normally in a program,

01:03:04.540 --> 01:03:08.540
but for development's sake,
I'll turn the alpha up a little bit.

01:03:08.840 --> 01:03:10.540
Turn these on.

01:03:10.540 --> 01:03:14.060
And let's animate these.

01:03:16.510 --> 01:03:19.900
So basically what this is is kind of one
line of code which now I'm controlling

01:03:19.900 --> 01:03:21.640
the actual kind of color output.

01:03:21.640 --> 01:03:24.840
What you saw is that one line
wants to set a fragment color.

01:03:24.840 --> 01:03:28.320
The fragment color does a texture lookup,
multiplies by GL's current color,

01:03:28.320 --> 01:03:31.020
and then I've added the fact
that it multiplies by that color

01:03:31.020 --> 01:03:32.040
that I can set in a uniform.

01:03:32.140 --> 01:03:36.560
The fact that these animations are going
is really all it is is a single call in

01:03:36.670 --> 01:03:39.600
your application that says GL uniform,
set it to this value.

01:03:39.600 --> 01:03:42.520
So you can imagine that if
you have an application,

01:03:42.580 --> 01:03:45.720
for example,
that wants to do some kind of exposure

01:03:45.720 --> 01:03:47.920
control for example on images.

01:03:47.920 --> 01:03:50.100
You could do that very
simply in a fragment shader.

01:03:50.100 --> 01:03:51.600
You have the image loaded as a texture.

01:03:51.670 --> 01:03:52.530
We showed you how to do that.

01:03:52.770 --> 01:03:55.850
You do the normal OpenGL pipeline
and you create your own fragment

01:03:55.850 --> 01:03:58.420
shader that all it does is say
texture and then multiplies by

01:03:58.420 --> 01:03:59.760
some kind of exposure control.

01:03:59.760 --> 01:04:01.320
You can do lots of algorithms too.

01:04:01.320 --> 01:04:04.370
There's a lot of image manipulation
algorithms or kind of vertex

01:04:04.380 --> 01:04:07.160
manipulation algorithms you can do.

01:04:07.160 --> 01:04:11.460
So that's just a simple intro to
what shading languages can do,

01:04:11.460 --> 01:04:14.550
direct manipulation of the
OpenGL pipeline and ShaderBuilder,

01:04:14.550 --> 01:04:15.660
which is one of our tools.

01:04:16.380 --> 01:04:23.180
So what that really does is take me to,
if you can go back to slides,

01:04:23.200 --> 01:04:25.580
the last section of our talk.

01:04:28.250 --> 01:04:30.200
Let me say,
for further information on shading,

01:04:30.200 --> 01:04:32.490
on the shading language,
the Orange Book is available.

01:04:32.650 --> 01:04:33.180
Great book.

01:04:33.190 --> 01:04:36.010
And it really takes you
from the beginning to the

01:04:36.010 --> 01:04:37.780
end of shading languages.

01:04:37.780 --> 01:04:41.700
Shows a lot of examples and also
has a good reference material in it.

01:04:42.140 --> 01:04:44.800
So looking at ShaderBuilder
takes me right into tools.

01:04:44.840 --> 01:04:50.980
So we have five tools for you,
for developers that work with OpenGL.

01:04:50.980 --> 01:04:52.900
The first one is the OpenGL Profiler.

01:04:52.900 --> 01:04:53.540
I mentioned it.

01:04:53.640 --> 01:04:57.300
The OpenGL Profiler we talked
about in the Wednesday 5 p.m.

01:04:57.300 --> 01:04:59.450
tuning session,
and we'll go into detail of

01:04:59.450 --> 01:05:01.720
using the OpenGL Profiler,
and I really recommend

01:05:01.800 --> 01:05:02.750
you looking at that.

01:05:02.770 --> 01:05:05.740
It's on Leopard, it's on Snow Leopard,
and it's been one of them.

01:05:05.760 --> 01:05:07.960
We built it because it's a
tool that we needed to use,

01:05:08.000 --> 01:05:11.120
and I think you'll find that you
can break on OpenGL commands,

01:05:11.220 --> 01:05:12.920
you can look at your buffers
and see their content,

01:05:12.920 --> 01:05:15.060
you can look at textures,
you can look at object IDs,

01:05:15.060 --> 01:05:16.980
all these kind of things
you can do in the Profiler.

01:05:16.980 --> 01:05:20.190
You can go look at your resources,
you can look at that shader.

01:05:20.200 --> 01:05:23.140
So you can break on a command in OpenGL,
you can look at what your shader is,

01:05:23.140 --> 01:05:24.310
and you can change the shader on the fly.

01:05:24.320 --> 01:05:27.400
So you can debug your application,
changing the shader on the fly,

01:05:27.400 --> 01:05:30.690
without having to pull the shader
out into a different environment.

01:05:30.700 --> 01:05:32.440
The Driver Monitor.

01:05:32.440 --> 01:05:33.990
Driver Monitor is more GPU-centric.

01:05:34.000 --> 01:05:37.000
It talks about the GPU,
shows how much VRAM you have free,

01:05:37.000 --> 01:05:39.720
shows the number of contacts
and surfaces that are going,

01:05:39.720 --> 01:05:40.440
shows how busy the GPU is.

01:05:40.440 --> 01:05:43.580
So it's a little bit more
of a deep-level tool,

01:05:43.580 --> 01:05:46.180
but it's something to keep in your
hip pocket just in case you need it.

01:05:46.260 --> 01:05:47.990
Shader Builder, we just saw that.

01:05:48.090 --> 01:05:49.470
Shader Builder is a great place.

01:05:49.560 --> 01:05:53.120
We've improved it a lot to support
both the early version of Fragment

01:05:53.120 --> 01:05:56.070
Programs and also the new version,
kind of the shaders,

01:05:56.080 --> 01:05:59.850
and you can integrate the two together,
and you have the ability to use textures,

01:05:59.980 --> 01:06:01.300
cube maps, those kind of things.

01:06:01.300 --> 01:06:04.160
It's a great place to play around with
shaders and start developing shaders.

01:06:04.680 --> 01:06:04.940
Shark.

01:06:05.000 --> 01:06:06.850
Everyone needs to learn about Shark.

01:06:07.010 --> 01:06:09.200
Shark is a tremendous profiling tool.

01:06:09.200 --> 01:06:10.970
It'll show you where your time,
where your time is being spent,

01:06:10.980 --> 01:06:13.240
whether it's in OpenGL,
whether it's in your app,

01:06:13.320 --> 01:06:16.160
and you'll be able to see
exactly what your app is doing.

01:06:16.160 --> 01:06:18.460
It's really critical
when you're debugging,

01:06:18.460 --> 01:06:21.300
profiling, and looking at the
time spent in your app.

01:06:21.320 --> 01:06:24.230
You start with Shark,
make a data-centric approach,

01:06:24.320 --> 01:06:28.220
really learn what your app's doing
before you start making guesses.

01:06:28.340 --> 01:06:29.910
So Shark is a great tool to do that.

01:06:30.000 --> 01:06:31.120
And finally, instruments.

01:06:31.140 --> 01:06:33.330
Many of the things, for example,
that's in Driver Monitor are

01:06:33.330 --> 01:06:34.240
now in instruments.

01:06:34.240 --> 01:06:38.400
You can compare what your app's doing at
certain times to what the GPU's doing.

01:06:38.400 --> 01:06:40.180
You can tie those things together.

01:06:40.340 --> 01:06:43.800
Instruments is another great app
to look at how your app's behaving

01:06:43.800 --> 01:06:45.900
and understand how you can get
better performance out of it.

01:06:48.510 --> 01:06:49.730
So where do you go from here?

01:06:49.820 --> 01:06:51.500
I divide this in three categories.

01:06:51.580 --> 01:06:54.320
If you're learning OpenGL,
let's start with the Redbook,

01:06:54.340 --> 01:06:56.060
start with some tutorials online.

01:06:56.060 --> 01:06:57.360
That's a great place to go.

01:06:57.450 --> 01:06:59.000
There's some examples in there.

01:06:59.150 --> 01:07:01.600
Start with the basic kind
of NS Cocoa OpenGL app.

01:07:01.680 --> 01:07:04.130
If you're coming to the Mac,
you know OpenGL,

01:07:04.130 --> 01:07:07.900
but you don't know Mac stuff very well,
the OpenGL programming guide on

01:07:07.900 --> 01:07:12.170
developer.apple.com slash OpenGL,
that is the place you want to go next.

01:07:12.170 --> 01:07:14.970
That's that take some time
this evening or on the plane

01:07:14.990 --> 01:07:18.310
back or in the car sometime,
not when you're driving.

01:07:18.400 --> 01:07:19.400
Someone else is driving.

01:07:19.400 --> 01:07:21.050
And read through it.

01:07:21.050 --> 01:07:22.580
Download the PDF.

01:07:22.580 --> 01:07:25.610
Have it at your side because that really
talks about kind of the texturing thing,

01:07:25.610 --> 01:07:28.130
talks about virtual screens,
talks about a lot of those things that

01:07:28.130 --> 01:07:30.620
you may want to know that you didn't
know and it'll give you that good

01:07:30.620 --> 01:07:32.300
background to make good decisions.

01:07:32.300 --> 01:07:34.020
And also make sure you use our tools.

01:07:34.030 --> 01:07:36.060
Make sure you got the right tools there.

01:07:36.060 --> 01:07:38.790
If you're expanding your knowledge,
so if you've been in this

01:07:38.790 --> 01:07:41.450
session and you're kind of,
hey, I know most of this stuff,

01:07:41.450 --> 01:07:43.970
but I learned a nuance or two,
I hope it was worth your time,

01:07:44.070 --> 01:07:46.340
but I'll point you to shading, obviously.

01:07:46.340 --> 01:07:48.320
Let's look at the
Orange Book and Shading Language.

01:07:48.400 --> 01:07:50.020
Look at the compute sessions.

01:07:50.020 --> 01:07:51.930
Look at how your app,
you had a typical app

01:07:51.980 --> 01:07:54.720
that was an OpenGL app,
but you're really doing numerical

01:07:54.720 --> 01:07:57.740
computing and you may want to
move more to a compute aspect.

01:07:57.740 --> 01:08:00.720
And finally, look back at the
OpenGL programming guide.

01:08:00.810 --> 01:08:01.870
Look at the details.

01:08:01.910 --> 01:08:03.380
Understand the details.

01:08:03.380 --> 01:08:06.980
Understand that off-screen thing,
the offline renders so you can get that

01:08:07.110 --> 01:08:10.250
full computing power out of the box
and you can support someone putting

01:08:10.400 --> 01:08:12.230
additional cards in their machine.

01:08:12.260 --> 01:08:15.460
That would be a great thing to
add more robustness to your app.

01:08:15.540 --> 01:08:18.380
So a lot of different directions to
go for different types of people.

01:08:18.440 --> 01:08:20.120
And where you stand in your development.

01:08:20.120 --> 01:08:22.490
And I hope you have a great week.

01:08:22.580 --> 01:08:25.380
For more information,
we have a mailing list.

01:08:25.460 --> 01:08:29.000
Mac at mac-opengl at list.apple.com.

01:08:29.000 --> 01:08:31.700
We have, obviously,
the documentation and sample code.

01:08:31.700 --> 01:08:37.330
And finally, for specific questions,
you can send an email to Alan Schaefer,

01:08:37.330 --> 01:08:39.920
our graphics and media
technology evangelist.

01:08:40.000 --> 01:08:42.580
His name is aschaefer at apple.com.

01:08:42.580 --> 01:08:45.450
And I really thank you for your time.

01:08:45.470 --> 01:08:47.460
Let me just point you to some
of the sessions I mentioned.

01:08:48.400 --> 01:08:53.560
Today and this afternoon at 5,
we have the ES iPhone app development.

01:08:53.560 --> 01:08:56.340
Tomorrow, if you look at those,
it's kind of like 3.30 and 5,

01:08:56.340 --> 01:08:58.360
so they're following each other in SOMA.

01:08:58.360 --> 01:09:01.460
So we have the two more
advanced OpenGL sessions.

01:09:01.460 --> 01:09:06.620
And then the OpenCL sessions are
Thursday morning in Russian Hill,

01:09:06.620 --> 01:09:09.840
two sessions, one following each other,
9 a.m.

01:09:09.840 --> 01:09:11.080
and 10.30 a.m.

01:09:11.080 --> 01:09:14.300
The lab for all these things
is in three different times.

01:09:14.450 --> 01:09:17.360
The ES lab is Wednesday at 10.30 a.m.

01:09:17.380 --> 01:09:18.030
in the morning.

01:09:18.500 --> 01:09:22.270
The OpenGL for the Mac lab is at 2.00.

01:09:22.290 --> 01:09:25.940
And at the same time,
the OpenCL is also at 2.00 on Thursday.

01:09:25.970 --> 01:09:28.640
So we have OpenCL and OpenGL,
two different labs just across

01:09:28.640 --> 01:09:29.500
the hall from each other.

01:09:29.500 --> 01:09:32.490
All the engineers will be
there to answer your questions.

01:09:32.500 --> 01:09:36.000
The ES lab will be on Wednesday,
the day before, in the morning,

01:09:36.000 --> 01:09:37.210
and the engineers will be there.
WEBVTT

00:00:20.310 --> 00:00:22.200
Hi, everybody.

00:00:22.200 --> 00:00:25.570
Are we all happy?

00:00:27.600 --> 00:00:28.600
All right.

00:00:28.600 --> 00:00:31.390
I'm here to talk about LLVM.

00:00:31.630 --> 00:00:33.800
I hope you're in the right place.

00:00:33.800 --> 00:00:35.490
So my name is Chris Lattener.

00:00:35.490 --> 00:00:38.550
I'm one of the people that
are hacking away in LLVM,

00:00:38.550 --> 00:00:41.680
slaving away to make it
a great compiler for you.

00:00:41.880 --> 00:00:46.540
Today's talk is actually a great talk
because we get to have several other

00:00:46.540 --> 00:00:49.780
people that have been slaving away,
hacking away, making it awesome,

00:00:49.840 --> 00:00:52.740
and they'll be talking more
about specific features.

00:00:52.990 --> 00:00:55.220
So if you're here,
I assume that you probably

00:00:55.220 --> 00:00:56.590
have some idea what LLVM is.

00:00:56.760 --> 00:01:00.360
And a lot of you probably went to
the compiler state of the union,

00:01:00.450 --> 00:01:04.720
so I'm going to skip over some
of the details of what it is.

00:01:04.720 --> 00:01:07.000
To put it briefly, it's a compiler.

00:01:07.600 --> 00:01:18.500
[Transcript missing]

00:01:18.740 --> 00:01:21.480
So, one thing, again,
I want to emphasize is

00:01:21.480 --> 00:01:22.970
that LLVM is open source.

00:01:22.970 --> 00:01:26.980
And for our integration with Xcode,
one nice thing about LLVM is

00:01:26.980 --> 00:01:30.610
that it uses a BSD license,
which means that you can use it in a

00:01:30.610 --> 00:01:34.230
commercial project and you don't have,
you can use it in many

00:01:34.230 --> 00:01:38.070
different ways that you can't
do with a GPL-like license.

00:01:38.220 --> 00:01:41.650
And so, as we push forward,
we think this is really important.

00:01:41.650 --> 00:01:44.960
This lets us do a lot of things with
LLVM that we wouldn't be able to

00:01:45.030 --> 00:01:47.220
do if the licenses were different.

00:01:47.220 --> 00:01:50.430
This is also great because a lot of
other companies have taken LLVM and

00:01:50.430 --> 00:01:52.220
have done great things with it.

00:01:52.230 --> 00:01:54.890
And if you go to the LLVM web page,
which is LLVM.org,

00:01:54.890 --> 00:01:56.220
you can read about some of that.

00:01:56.220 --> 00:01:58.720
Several companies that are
probably here are probably using

00:01:58.720 --> 00:02:00.120
it and they may not know about it.

00:02:00.220 --> 00:02:04.860
So, today I want to talk about LLVM-GCC,
or I want,

00:02:04.870 --> 00:02:09.920
we will be talking about LLVM-GCC,
we'll be talking a lot more about Clang,

00:02:09.920 --> 00:02:12.220
and we'll be talking about
applications of Clang.

00:02:12.220 --> 00:02:15.900
So, this is old hat.

00:02:16.220 --> 00:02:17.220
I think it's a little
bit of a different thing.

00:02:17.220 --> 00:02:20.530
So,
a compiler is broken into three pieces,

00:02:20.530 --> 00:02:24.220
the parser, the optimizer,
and the backend.

00:02:24.220 --> 00:02:27.930
When you're using LLVM-GCC,
the backend and the optimizer come from

00:02:27.930 --> 00:02:30.060
LLVM and the frontend comes from GCC.

00:02:30.220 --> 00:02:33.860
The great feature of this is
that GCC does all the parsing,

00:02:33.860 --> 00:02:37.220
which means if your code
parses with GCC 4.2,

00:02:37.220 --> 00:02:39.220
it will parse with LLVM-GCC 4.2.

00:02:39.220 --> 00:02:41.190
By changing the optimizer
and the backend,

00:02:41.190 --> 00:02:44.400
we now get better performance,
lower compile times when the optimizer

00:02:44.400 --> 00:02:46.220
is enabled and features like that.

00:02:46.220 --> 00:02:49.140
So, later we'll be talking
significantly more about Clang,

00:02:49.240 --> 00:02:53.220
talking about its architecture,
the implications for Xcode,

00:02:53.260 --> 00:02:56.210
giving detailed timing
information and things like that.

00:02:56.220 --> 00:02:58.150
It's a great project.

00:02:58.220 --> 00:03:01.800
There's a huge amount of work going
on both by us and in the community,

00:03:01.830 --> 00:03:05.220
and I'm really excited that
we'll be able to talk about that.

00:03:05.220 --> 00:03:11.220
So, the overall roadmap for this talk
is we'll talk about LLVM-GCC 4.2.

00:03:11.220 --> 00:03:15.220
This is on your Xcode 3.1 DVDs
and available on Snow Leopard.

00:03:15.220 --> 00:03:17.220
And so, we'll talk about performance.

00:03:17.220 --> 00:03:19.230
We'll talk about link time optimization,
how to get the most out

00:03:19.230 --> 00:03:22.220
of link time optimization,
what you can do to your code.

00:03:22.220 --> 00:03:24.090
After that, we'll talk about Clang.

00:03:24.240 --> 00:03:26.220
Clang is this new frontend.

00:03:26.220 --> 00:03:28.220
There's a whole broad
range of things we can do.

00:03:28.220 --> 00:03:31.220
We think this is going to have a
huge impact on your build times.

00:03:31.220 --> 00:03:33.720
It will let us do a lot of
exciting things with Xcode,

00:03:33.720 --> 00:03:35.140
and we'll talk about that.

00:03:35.220 --> 00:03:38.220
Finally,
we'll talk about applications of Clang.

00:03:38.220 --> 00:03:41.350
And this is great stuff
that it's not shipping yet,

00:03:41.390 --> 00:03:44.220
and Clang itself is
also not shipping yet.

00:03:44.220 --> 00:03:48.020
But there's a huge amount of things
that you can do when you have a

00:03:48.020 --> 00:03:50.220
compiler's view of the source code.

00:03:50.220 --> 00:03:52.210
And with a compiler's
view of the source code,

00:03:52.210 --> 00:03:56.220
you can do lots of fun things
and help find bugs in your code,

00:03:56.220 --> 00:03:59.190
for example,
which is one we'll talk about in depth.

00:03:59.220 --> 00:04:02.200
So,
this is enough of me up here blabbing.

00:04:02.240 --> 00:04:05.210
I'd like to have Devang Patel come up.

00:04:05.420 --> 00:04:09.020
Devang is, among other things,
the guy who implemented link

00:04:09.020 --> 00:04:11.220
time optimization in LLVM-GCC.

00:04:11.220 --> 00:04:13.210
So, Devang, please take it away.

00:04:13.220 --> 00:04:15.330
Thanks, Chris.

00:04:18.290 --> 00:04:19.350
Good afternoon.

00:04:19.570 --> 00:04:23.410
I'm Devang, member of LLVM team at Apple.

00:04:23.510 --> 00:04:29.440
Today, I'm going to describe how you
can use LLVM-gcc to help improve

00:04:29.440 --> 00:04:32.240
performance of your application.

00:04:32.370 --> 00:04:34.390
So, let's start.

00:04:34.900 --> 00:04:41.340
LLVM-GCC is a drop-in replacement
for the GCC 4.2 compiler.

00:04:41.470 --> 00:04:44.000
Both of the compilers
are binary compatible,

00:04:44.100 --> 00:04:49.660
which means you can mix and match object
files generated by these two compilers.

00:04:49.720 --> 00:04:55.860
LLVM-GCC supports C, C++, Objective-C,
and Objective-C++ languages.

00:04:55.990 --> 00:05:00.780
It supports x86 32-bit as well as 64-bit.

00:05:01.200 --> 00:05:07.580
LLVM-GCC also supports PowerPCs 32-bit,
but it doesn't support PowerPCs 64-bit.

00:05:07.800 --> 00:05:13.190
LLVM-GCC is now available in Xcode 3.1.

00:05:14.570 --> 00:05:21.370
LLVM-GCC supports all the standard
features supported by GCC 4.2 frontend.

00:05:21.470 --> 00:05:24.200
In fact,
it takes advantage of some of the

00:05:24.200 --> 00:05:26.400
features more than GCC itself.

00:05:26.740 --> 00:05:26.920
How?

00:05:27.030 --> 00:05:28.920
We'll see today.

00:05:29.010 --> 00:05:32.820
LLVM-GCC also supports
link time optimization.

00:05:32.920 --> 00:05:36.040
We'll discuss this in detail today.

00:05:36.160 --> 00:05:38.390
This is our very first release.

00:05:38.480 --> 00:05:42.080
In this release, OpenMP is not supported.

00:05:42.530 --> 00:05:45.900
Debugging of optimized
code is also not supported.

00:05:46.240 --> 00:05:49.760
Please read release notes
for more information.

00:05:50.750 --> 00:05:53.890
So now you know that this
new compiler is available.

00:05:53.960 --> 00:05:56.010
How do you use it?

00:05:56.140 --> 00:05:58.000
It's very simple.

00:05:58.000 --> 00:06:01.650
You can select this compiler
in Xcode's compiler drop-down

00:06:01.790 --> 00:06:04.600
selection list in the build panel.

00:06:04.600 --> 00:06:07.620
On the command line,
this compiler is installed inside

00:06:07.620 --> 00:06:09.550
your Xcode installation folder.

00:06:09.790 --> 00:06:13.520
If you have installed
Xcode in /developer,

00:06:13.750 --> 00:06:19.820
then this compiler is available
at /developer/user/bin/llvm/gcc.

00:06:19.820 --> 00:06:24.380
This compiler accepts all
GCC standard command line options.

00:06:24.700 --> 00:06:28.440
So now you know you have a new compiler,
you can use it.

00:06:28.440 --> 00:06:30.360
Why do you want to use it?

00:06:30.480 --> 00:06:36.520
Well, one of the new features in this new
compiler is link time optimization.

00:06:36.520 --> 00:06:40.080
You may ask,
what is link time optimization?

00:06:40.630 --> 00:06:44.190
Well, traditionally,
when you compile your source file,

00:06:44.490 --> 00:06:48.490
the compiler will generate
optimized object files.

00:06:48.660 --> 00:06:52.390
Linker will take these object
files and link it together to

00:06:52.420 --> 00:06:54.830
create your final application.

00:06:54.990 --> 00:06:58.190
Now when the optimizer is
optimizing your source file,

00:06:58.190 --> 00:07:00.380
it cannot see across the source file.

00:07:00.420 --> 00:07:04.180
So the optimizer has to make
conservative assumptions.

00:07:04.180 --> 00:07:08.740
Now what if you can do the
optimization at the link time,

00:07:08.930 --> 00:07:10.170
where you can see everything?

00:07:10.180 --> 00:07:13.380
This is known as link time optimization.

00:07:13.380 --> 00:07:18.250
LLVM supports completely
transparent link time optimization,

00:07:18.320 --> 00:07:23.110
which works across programming languages,
which means you can take a

00:07:23.110 --> 00:07:26.380
C function from one source file
and you can align it in a C++

00:07:26.380 --> 00:07:28.620
function in a second source file.

00:07:28.660 --> 00:07:30.660
How does it work?

00:07:30.660 --> 00:07:34.780
Well, it's very simple.

00:07:35.310 --> 00:07:39.390
You compile your source file
using -o for the LLVM gcc.

00:07:39.390 --> 00:07:44.740
The compiler will generate a .o file,
the linker will take that .o file

00:07:44.740 --> 00:07:50.320
and link it together with other input
files to create your final binary.

00:07:50.790 --> 00:07:55.150
However,
one thing new in this situation is the

00:07:55.150 --> 00:08:00.620
.org file generated by the compiler
is not native Mac OS X object file.

00:08:00.870 --> 00:08:06.310
In fact, it contains LLVM bitcode.

00:08:06.310 --> 00:08:06.310
But don't worry.

00:08:06.580 --> 00:08:12.460
Xcode 3.1 linker knows how
to handle LLVM bitcode files.

00:08:12.460 --> 00:08:18.030
The linker will use the LLVM optimizer
to optimize all the available

00:08:18.190 --> 00:08:23.980
LLVM bitcode files on the fly and
generate native Mac OS X object files,

00:08:24.340 --> 00:08:28.770
which will be linked with other
object files on the input.

00:08:28.980 --> 00:08:33.140
and others will be linked with other
object files to create the final binary.

00:08:35.210 --> 00:08:40.470
If this sounds complicated,
then let's take a look at the example.

00:08:42.720 --> 00:08:47.280
Here we have one simple source
file which defines two functions:

00:08:47.380 --> 00:08:52.600
get_number, which returns one integer,
and we have a main that invokes

00:08:52.680 --> 00:08:58.070
the external function do_something.

00:08:58.210 --> 00:08:58.210
If you optimize this source file,

00:08:58.510 --> 00:09:01.830
Using highest compile time optimization,
the optimizer will not

00:09:01.970 --> 00:09:04.400
be able to do anything.

00:09:04.610 --> 00:09:06.970
The code is already simplified.

00:09:07.390 --> 00:09:10.620
Now let's take a look at
the second source file.

00:09:10.620 --> 00:09:13.620
This source file has one
static variable flag,

00:09:13.620 --> 00:09:17.540
which is modified by a
function called foobar.

00:09:17.630 --> 00:09:20.920
And finally,
this source file defines do something

00:09:20.960 --> 00:09:23.610
that is used by the first source file.

00:09:23.890 --> 00:09:28.000
Once again, if you optimize this source
file using the highest

00:09:28.030 --> 00:09:32.300
optimization available to you,
the optimizer doesn't have enough room

00:09:32.300 --> 00:09:34.230
to do anything at the compile time.

00:09:34.320 --> 00:09:37.840
The code is already in very simple form.

00:09:37.990 --> 00:09:46.070
But what if we compile only one source
file using link time optimization?

00:09:46.500 --> 00:09:51.110
The compiler will generate the
LLVM bitcode for this source file.

00:09:51.230 --> 00:09:53.500
Linker will accept this source file.

00:09:53.520 --> 00:09:59.910
The linker will accept
this LLVM bitcode file,

00:09:59.990 --> 00:10:03.650
and it will ask the
optimizer to optimize it.

00:10:03.820 --> 00:10:07.190
But linker will provide
some additional information.

00:10:07.900 --> 00:10:11.880
Linker will inform the optimizer
that this function foobar

00:10:12.050 --> 00:10:14.640
is not used anywhere else.

00:10:15.900 --> 00:10:20.700
Second thing Linker will inform that
this function is hidden because we are

00:10:20.700 --> 00:10:26.440
building a static application where only
one function is externally visible main.

00:10:26.460 --> 00:10:28.500
Now this is very important.

00:10:28.530 --> 00:10:33.020
If we are building a dynamic library,
then Linker will not

00:10:33.020 --> 00:10:34.700
make this symbol hidden.

00:10:34.860 --> 00:10:38.700
You will have to do it yourself by
using various visibility controls.

00:10:38.700 --> 00:10:40.820
We'll see it in detail today.

00:10:42.100 --> 00:10:46.750
So now, based on this information,
the function is not used anywhere else,

00:10:46.750 --> 00:10:47.810
and it is hidden.

00:10:47.810 --> 00:10:51.080
The optimizer will simply remove it.

00:10:51.080 --> 00:10:55.190
Once this function is gone,

00:10:55.730 --> 00:11:01.300
The optimizer will immediately recognize
that this condition is always false.

00:11:01.300 --> 00:11:05.320
So it is safe to remove
this code as well.

00:11:05.560 --> 00:11:09.270
Once this condition is gone,
the optimizer will recognize that

00:11:09.740 --> 00:11:18.640
we have a static variable that is
initialized but not used anywhere else.

00:11:18.640 --> 00:11:18.640
So we can remove that also.

00:11:19.230 --> 00:11:21.090
Now the linker will join the fun.

00:11:21.140 --> 00:11:24.940
Linker will realize that this
function is not used anywhere else,

00:11:25.200 --> 00:11:27.580
so I can remove that one also.

00:11:27.790 --> 00:11:31.450
The Xcode linker supports
date code stripping.

00:11:32.520 --> 00:11:38.330
Now you can see that additional
information provided by the linker helped

00:11:38.740 --> 00:11:45.400
optimizer to significantly optimize
this code which was not possible earlier.

00:11:45.400 --> 00:11:46.150
But we are not done yet.

00:11:46.160 --> 00:11:52.890
If we compile the first source file
using LLVM link time optimization

00:11:53.580 --> 00:11:59.540
then the linker will provide both the
LLVM bit code file to the LLVM optimizer.

00:11:59.550 --> 00:12:04.270
Now the optimizer will be able to
simply in line do something into

00:12:04.270 --> 00:12:07.600
the main and you will get this.

00:12:07.600 --> 00:12:12.400
This is the power of
link time optimization.

00:12:13.650 --> 00:12:16.780
Before I wrap up this example,
I would like to point out two things.

00:12:16.780 --> 00:12:22.940
Sometimes you cannot compile
everything in your project.

00:12:23.140 --> 00:12:29.040
You may link libraries from third party,
but try to compile as much

00:12:29.040 --> 00:12:31.420
as possible using -04.

00:12:31.420 --> 00:12:33.970
More is better for the optimizer.

00:12:35.060 --> 00:12:39.980
Second, as we saw with the foo bar
function in the example,

00:12:39.980 --> 00:12:43.730
use visibility control
as much as possible.

00:12:44.360 --> 00:12:48.440
Hide as many symbols as possible.

00:12:48.820 --> 00:12:51.110
It has one additional advantage.

00:12:51.310 --> 00:12:56.310
It will help you reduce your
application's launch time.

00:12:56.630 --> 00:12:59.810
There are various ways you
can control symbol visibility.

00:12:59.880 --> 00:13:05.770
You can use static variables,
you can use anonymous namespace in C++,

00:13:05.770 --> 00:13:11.090
or you can use GCC's
visibility attributes.

00:13:11.960 --> 00:13:16.910
or you can use exported
symbol list at the link time.

00:13:16.910 --> 00:13:20.380
We have one excellent tech
note that describes everything.

00:13:20.380 --> 00:13:23.100
It's very useful.

00:13:24.020 --> 00:13:30.550
So now you want to know how
to use this new technology.

00:13:30.880 --> 00:13:33.250
It is as simple as you would expect.

00:13:33.480 --> 00:13:37.840
It's just a checkbox in
the Xcode's build panel.

00:13:37.840 --> 00:13:42.630
On the command line,
you just use optimizations in level 04.

00:13:43.790 --> 00:13:51.570
So, now let's look at the performance we
are gaining using this new technology.

00:13:51.620 --> 00:13:56.940
Tuesday, Chris talked about the
performance improvements we

00:13:57.010 --> 00:13:59.300
are seeing in H.264 decoder.

00:13:59.300 --> 00:14:04.750
Today, we will look at the performance
for the SPEC 2000 benchmark.

00:14:05.440 --> 00:14:08.690
This benchmark is a collection of C, C++,
and Fortran programs.

00:14:08.710 --> 00:14:12.170
We are just focusing
on C and C++ programs.

00:14:12.180 --> 00:14:20.020
We are comparing LLVM-GCC's
performance with respect to GCC 4.2.

00:14:20.960 --> 00:14:23.830
Before we look at the numbers,
I would like to clarify two things.

00:14:23.840 --> 00:14:29.550
Number one, we are measuring the relative
performance of two compilers.

00:14:29.550 --> 00:14:34.820
We are not focusing on getting
the absolute base spec numbers

00:14:34.920 --> 00:14:37.180
for the spec benchmark.

00:14:37.190 --> 00:14:42.750
Second, your mileage may vary.

00:14:42.750 --> 00:14:42.750
The

00:14:43.340 --> 00:14:46.440
Your application may not see
the performance improvements we

00:14:46.450 --> 00:14:47.840
are seeing in these benchmarks.

00:14:47.840 --> 00:14:53.750
You should measure and analyze the
performance of your application.

00:14:54.730 --> 00:14:56.900
So let's look at the performance number.

00:14:56.930 --> 00:15:01.380
Here we are comparing the average
spec numbers for these two compilers,

00:15:01.460 --> 00:15:07.880
gcc 4.2 and llvm-gcc 4.2 at
various optimization levels.

00:15:07.900 --> 00:15:11.420
X axis represents the
optimization levels.

00:15:11.440 --> 00:15:15.100
On the Y axis, we are representing the
relative performance.

00:15:15.100 --> 00:15:21.050
If the performance is as good as,
which means if the average spec number

00:15:21.050 --> 00:15:25.380
is as good as the average spec number
for gcc at optimization level O2,

00:15:25.380 --> 00:15:29.980
then it's 100%. If it is more
than 100%, which means the

00:15:30.070 --> 00:15:32.690
compiler is producing faster code,
which is good.

00:15:32.710 --> 00:15:36.000
If it is less than 100%,
then it is not good.

00:15:36.000 --> 00:15:42.820
So let's look at what the compiler
can do at optimization level O2.

00:15:43.070 --> 00:15:52.470
At optimization level O2,
LLVM/GCC-produced code runs 5% faster.

00:15:52.700 --> 00:15:56.180
We ask both the optimizers
to do additional work.

00:15:56.180 --> 00:16:01.880
Let them aggressively inline your code,
which will enable further

00:16:01.880 --> 00:16:03.990
optimization opportunities.

00:16:04.320 --> 00:16:06.860
Well, both of them performed well.

00:16:06.950 --> 00:16:11.450
However, once again,
LLVM GCC-produced code outperforms

00:16:11.470 --> 00:16:14.980
the code produced by GCC.

00:16:15.750 --> 00:16:19.820
You may ask,
what about link time optimization?

00:16:19.820 --> 00:16:24.440
We looked at one carefully created
example and see what it can do,

00:16:24.690 --> 00:16:30.960
but how about real-life
benchmark numbers?

00:16:30.960 --> 00:16:35.310
We expect it to do better, but how much?

00:16:36.770 --> 00:16:42.140
Well, we are getting 25% performance
improvement by turning on

00:16:42.140 --> 00:16:44.340
link time optimization.

00:16:49.650 --> 00:16:54.790
We do not have numbers for GCC at
O4 because GCC 4.2 doesn't support

00:16:54.890 --> 00:16:58.240
link time optimization right now.

00:16:58.800 --> 00:17:05.790
Now you may ask, okay, 25% performance
improvement is really good.

00:17:05.800 --> 00:17:07.280
It's excellent.

00:17:07.780 --> 00:17:09.700
But what's the cost?

00:17:10.090 --> 00:17:15.210
Well, let's take a look at the compile
time numbers for this benchmark.

00:17:15.420 --> 00:17:19.400
Here we are measuring how long does
it take to build this benchmark

00:17:19.430 --> 00:17:21.830
at various optimization levels.

00:17:22.250 --> 00:17:26.200
Once again,
we are comparing it with GCC 4.2

00:17:26.380 --> 00:17:28.780
at optimization level O2.

00:17:28.780 --> 00:17:32.180
If the compiler is building
this benchmark faster,

00:17:32.420 --> 00:17:35.940
the number will be less
than 100%, which is good.

00:17:36.130 --> 00:17:40.970
If the compiler is slower,
the number will be more than

00:17:41.300 --> 00:17:45.520
100%, which is not good.

00:17:45.520 --> 00:17:45.520
At optimization level O2,

00:17:46.240 --> 00:17:57.070
LLVM-GCC is 30% faster than GCC.

00:17:57.070 --> 00:17:57.070
And if you remember the previous slide,
it produced 5% better code.

00:17:57.260 --> 00:18:01.450
Now, when we ask both the
optimizers to do more work,

00:18:01.450 --> 00:18:03.170
they take longer.

00:18:03.500 --> 00:18:11.000
But once again, LLVM-GCC is very,
very fast compared to GCC.

00:18:11.070 --> 00:18:14.850
How about link time optimization?

00:18:16.160 --> 00:18:21.050
As you know, at link time optimization,
we do all the work that we do at

00:18:21.300 --> 00:18:25.970
the compile time optimization,
plus at the link time,

00:18:26.070 --> 00:18:28.760
the optimizer works on entire

00:18:29.080 --> 00:18:32.170
All entire object files in your project.

00:18:32.400 --> 00:18:37.550
It's an extremely large dataset,
so I expect it to take longer.

00:18:37.550 --> 00:18:40.450
But how much?

00:18:41.340 --> 00:18:46.880
Well, it is almost as fast as
GCC at optimization level O2,

00:18:47.100 --> 00:18:47.990
which is significant.

00:18:47.990 --> 00:18:54.050
In other words, you are not spending any
extra time and you are getting

00:18:54.100 --> 00:18:55.980
25% performance improvement.

00:19:00.600 --> 00:19:04.200
So let's summarize the
performance numbers.

00:19:04.200 --> 00:19:06.990
At optimization level O2,

00:19:07.600 --> 00:19:13.250
LLVM GCC compiles 30% faster
and produces 5% better code.

00:19:13.260 --> 00:19:17.310
At optimization level 04,
LLVM GCC is as fast as

00:19:17.310 --> 00:19:23.690
GCC at optimization level 02,
but generates 25% better code.

00:19:25.190 --> 00:19:28.180
But I'm not satisfied.

00:19:28.310 --> 00:19:34.820
I want 25% better code and 30%
faster compiler at the same time.

00:19:34.890 --> 00:19:36.490
Why not?

00:19:37.520 --> 00:19:40.100
So what can we do?

00:19:40.100 --> 00:19:43.160
Let's take a look at compile
time numbers once again.

00:19:43.160 --> 00:19:45.010
We saw this slide.

00:19:45.640 --> 00:19:48.850
When we collected these measurements,
there is one component that

00:19:48.870 --> 00:19:51.500
is common in all measurements.

00:19:51.500 --> 00:19:54.440
That is gcc 4.2 frontend.

00:19:54.440 --> 00:19:58.300
llvm-gcc uses gcc 4.2 frontend.

00:19:58.320 --> 00:20:01.300
So how much time is
spent in this frontend?

00:20:04.130 --> 00:20:09.220
Now you can realize that
LLVM optimizer and code generators

00:20:09.820 --> 00:20:13.780
are amazingly fast compared to
GCC optimizer and code generator.

00:20:13.780 --> 00:20:20.220
In fact, at optimization level O2,
they are almost twice as fast as

00:20:20.220 --> 00:20:22.040
GCC's optimizer and code generator.

00:20:22.060 --> 00:20:28.620
So the obvious question I have is,
is it possible to use a faster front end?

00:20:30.700 --> 00:20:33.150
I'm inviting Steve Naroff
to answer the question.

00:20:33.200 --> 00:20:36.700
Thank you.

00:20:38.700 --> 00:20:40.460
Thanks, Devang.

00:20:45.650 --> 00:20:46.400
Hi, folks.

00:20:46.650 --> 00:20:51.750
So I'm Steve Naroff,
and I work on Clang in the LLVM team.

00:20:51.790 --> 00:20:55.280
I'm going to expand a little bit on the
tools old timer to give you some context.

00:20:55.350 --> 00:21:00.240
It might help you understand
my perspective in the talk.

00:21:00.240 --> 00:21:05.300
In the mid-'80s,
I was the tech lead on Objective-C,

00:21:05.300 --> 00:21:09.880
and after that I went to work for
Next and implemented the GNU native

00:21:09.880 --> 00:21:14.390
implementation of Objective-C,
and after that went on to

00:21:14.390 --> 00:21:16.810
manage the tools effort at Next.

00:21:16.880 --> 00:21:21.520
And while at Apple,
I've worked on several things like

00:21:21.950 --> 00:21:27.620
Java and the PB to Xcode transition,
many different things.

00:21:27.620 --> 00:21:32.340
So anyway, that's the old timer part,
mid-'80s.

00:21:32.340 --> 00:21:34.790
And I'm here to talk about Clang.

00:21:34.910 --> 00:21:39.300
So this talk is divided into
our motivation for Clang.

00:21:39.530 --> 00:21:41.270
We'll talk about some goals.

00:21:41.500 --> 00:21:43.840
We'll talk about some specific numbers.

00:21:43.930 --> 00:21:48.400
And then we'll get a little bit into our
future plans for integrating with Xcode.

00:21:48.550 --> 00:21:52.800
The number one motivation
we have is fast compilation.

00:21:53.000 --> 00:21:58.520
Now, as Devang just mentioned,
the back end is actually quite fast,

00:21:58.550 --> 00:22:00.790
even when generating really good code.

00:22:00.920 --> 00:22:04.400
Realize that this is a huge innovation.

00:22:04.550 --> 00:22:07.690
Most C compilers,
static C compilers like GCC,

00:22:07.690 --> 00:22:12.070
when they were developed,
the people working on the back end really

00:22:12.070 --> 00:22:14.400
didn't care about compile time at all.

00:22:14.590 --> 00:22:17.160
Their main goal was
generating the best code,

00:22:17.160 --> 00:22:20.300
and they didn't really care
how long it would take.

00:22:20.320 --> 00:22:23.900
So it's really important that today,
when we want to use the

00:22:23.900 --> 00:22:27.880
C compiler in a just-in-time
compilation mode or at runtime,

00:22:28.290 --> 00:22:30.400
that the back end is quite fast.

00:22:30.400 --> 00:22:34.000
And that has obviously a great side
effect on your development time.

00:22:34.000 --> 00:22:39.280
So we're inspired in the Clang
front end to basically marry a great

00:22:39.280 --> 00:22:44.620
fast front end with the LLVM back
end to give you fast compilation,

00:22:44.630 --> 00:22:50.500
because compilation obviously
involves the front end and back end.

00:22:51.980 --> 00:22:56.210
Another important motivation is many
C compilers don't really give you

00:22:56.210 --> 00:22:58.390
great error diagnostics messages.

00:22:58.440 --> 00:23:02.090
The messages that a compiler
spits out when you do something

00:23:02.090 --> 00:23:04.150
bad is its user interface,
right?

00:23:04.310 --> 00:23:07.290
That's the main UI the
compiler has to you is to tell

00:23:07.290 --> 00:23:09.060
you what you've done wrong.

00:23:09.060 --> 00:23:12.710
It doesn't say much if you've done right,
unfortunately.

00:23:12.710 --> 00:23:14.570
It doesn't pat you on the back.

00:23:14.650 --> 00:23:19.220
But it's really important that we
give you precise location information.

00:23:19.240 --> 00:23:21.780
I'll show you a little bit more.

00:23:21.900 --> 00:23:23.830
We'll talk more of that later.

00:23:24.060 --> 00:23:28.260
And certainly we want to enable a
whole new class of programming tools.

00:23:28.360 --> 00:23:31.810
Last year we introduced
refactoring in Xcode,

00:23:31.810 --> 00:23:34.480
and it was surprisingly difficult to do.

00:23:34.780 --> 00:23:41.160
We did it because it was important,
it's a great feature,

00:23:41.160 --> 00:23:44.090
but we want Clang to make doing
refactoring and other great

00:23:44.090 --> 00:23:44.090
programming tools really simple.

00:23:47.740 --> 00:23:52.880
So one of the key goals here is to
make a drop-in replacement for GCC.

00:23:52.880 --> 00:23:57.690
We would love to not implement
all the funky extensions in GCC,

00:23:57.690 --> 00:23:59.720
but that's not pragmatic.

00:23:59.840 --> 00:24:04.410
It's not pragmatic because Apple uses
GCC internally extensively,

00:24:04.460 --> 00:24:05.500
as you know.

00:24:05.500 --> 00:24:08.190
We compile our entire
operating system with it,

00:24:08.310 --> 00:24:10.760
and we use a lot of these extensions.

00:24:10.760 --> 00:24:15.720
And even -- there's some code
that doesn't even know it's using

00:24:15.720 --> 00:24:19.320
extensions that is using extensions,
and we find that out later.

00:24:19.320 --> 00:24:20.660
So it's interesting.

00:24:20.660 --> 00:24:24.890
We really need to be
drop-in compatible with GCC,

00:24:24.890 --> 00:24:29.110
and we're working really hard at
that and have implemented many

00:24:29.110 --> 00:24:31.180
of the GCC features already.

00:24:31.180 --> 00:24:32.960
Also we want language conformance.

00:24:32.960 --> 00:24:35.660
Right now we're doing a great
job with C and Objective-C.

00:24:35.920 --> 00:24:40.370
C++ is to come, and when we do C++,
it has to conform to the spec.

00:24:40.370 --> 00:24:42.980
We're not going to be deviating at all.

00:24:43.740 --> 00:24:47.560
One second, let me get some water.

00:24:52.520 --> 00:24:55.000
So, as I said before,
we want to spur innovation

00:24:55.220 --> 00:24:57.580
for the next decade.

00:24:58.080 --> 00:25:02.170
I want to talk a little bit about
the open source community that

00:25:02.170 --> 00:25:04.800
LLVM has and Clang is modeled after.

00:25:04.920 --> 00:25:06.120
It's really progressive.

00:25:06.310 --> 00:25:08.800
I use that word very specifically.

00:25:08.910 --> 00:25:11.340
For instance,
when people talk about open source,

00:25:11.520 --> 00:25:14.800
there's this feeling that, oh,
open source is good, right?

00:25:14.800 --> 00:25:16.590
That if it's open source, it's good.

00:25:16.970 --> 00:25:20.810
Well, just like with companies,
corporate cultures, teams,

00:25:20.850 --> 00:25:25.960
there are good teams, bad teams,
good cultures, bad cultures.

00:25:25.960 --> 00:25:32.000
And I think the community that the
LLVM community has is extremely friendly.

00:25:32.000 --> 00:25:36.230
It's very open to change,
and it's very open to great engineering.

00:25:36.230 --> 00:25:37.000
Okay?

00:25:37.000 --> 00:25:42.010
So the leadership that's driving
LLVM and that we hope to drive Clang

00:25:42.010 --> 00:25:46.100
is really concerned about making great
software because we feel that great

00:25:46.190 --> 00:25:50.300
software can be optimized better,
can be extended, and more importantly,

00:25:50.400 --> 00:25:53.920
can be extended by people who
aren't necessarily compiler.

00:25:53.920 --> 00:25:56.510
Chris Latten, Devang Patel, Steve Naroff,
Ted Kremenek So a lot

00:25:56.510 --> 00:26:00.760
of you use the language,
and if you wanted to develop an

00:26:00.760 --> 00:26:04.820
extension to a tool we're providing,
since you know the language,

00:26:04.870 --> 00:26:08.900
if we're giving you APIs to the function
objects and the statement objects,

00:26:08.900 --> 00:26:11.860
you should be able to, in theory,
write your own refactorings

00:26:11.860 --> 00:26:12.840
that are custom.

00:26:12.840 --> 00:26:13.560
Okay?

00:26:13.560 --> 00:26:16.600
A lot of the refactorings
we do today are canned,

00:26:16.600 --> 00:26:17.480
so to speak.

00:26:17.480 --> 00:26:20.840
We would like to offer a
much more extensible API.

00:26:20.840 --> 00:26:25.900
If you wanted to do your own searching
browser that's custom to your tool,

00:26:25.900 --> 00:26:25.930
you could do that.

00:26:26.050 --> 00:26:30.800
There's many different things that are
exciting when you have an API that's

00:26:30.910 --> 00:26:35.270
approachable by software engineers,
not necessarily compiler experts.

00:26:35.310 --> 00:26:40.680
And we've been told by many people
who have downloaded Clang that the

00:26:40.750 --> 00:26:43.790
API is really pleasant to work with.

00:26:49.330 --> 00:26:52.010
So I guess I've already covered it.

00:26:52.140 --> 00:26:55.420
Modularity is critical here.

00:26:55.420 --> 00:27:00.370
We firmly believe that the
only way to really have great

00:27:00.440 --> 00:27:02.430
performance is through great design.

00:27:02.560 --> 00:27:06.180
And so we're sticking to that.

00:27:06.220 --> 00:27:12.060
And, you know, as far as I'm concerned,
the C-based tools have stagnated, okay?

00:27:12.080 --> 00:27:16.240
Xcode is wonderful considering
what it has to live with,

00:27:16.300 --> 00:27:18.190
and I'm going to talk about that later.

00:27:18.340 --> 00:27:21.290
But, um, uh,

00:27:21.750 --> 00:27:26.260
It's just a shame that because
the C compilers that are in

00:27:26.300 --> 00:27:29.480
use today were developed 25,
30 years ago,

00:27:29.480 --> 00:27:34.690
that they've basically stunted the
growth of great development environments.

00:27:34.800 --> 00:27:39.120
And we believe Clang can
basically do -- make a huge step

00:27:39.150 --> 00:27:41.920
forward in enabling great IDs.

00:27:41.920 --> 00:27:44.390
Obviously,
we're most concerned with Xcode,

00:27:44.550 --> 00:27:47.360
but Clang can be used in
various other contexts.

00:27:47.430 --> 00:27:49.110
A good example is Eclipse.

00:27:49.220 --> 00:27:52.160
Many of you probably have heard
of Eclipse in the Java world.

00:27:52.160 --> 00:27:54.690
Well,
it's an IDE that's written in Java and

00:27:54.690 --> 00:27:57.300
that supports many different languages.

00:27:57.490 --> 00:28:03.000
Well, it turns out that for Java,
Eclipse is a wonderful tool.

00:28:03.230 --> 00:28:06.060
For C, it's less than wonderful.

00:28:06.060 --> 00:28:11.000
And part of the reason is that
it uses GCC as its plugin.

00:28:11.380 --> 00:28:15.040
And again, GCC was not developed
with modularity APIs,

00:28:15.090 --> 00:28:17.120
extensibility, all that kind of stuff.

00:28:17.140 --> 00:28:21.080
So anyway, we're excited about this.

00:28:21.760 --> 00:28:25.280
I'm going to shift gears now and
talk a little bit about diagnostics.

00:28:25.280 --> 00:28:28.910
Here's some code that is meaningless.

00:28:29.160 --> 00:28:30.900
It's just for the example.

00:28:30.900 --> 00:28:33.000
It has two statements there.

00:28:33.000 --> 00:28:37.990
Now, when you compile this with GCC,
you can see the first statement,

00:28:37.990 --> 00:28:42.970
it says that there's an invalid
type argument to unary star,

00:28:42.970 --> 00:28:48.170
and the second error is it says
invalid operands to binary plus.

00:28:48.440 --> 00:28:53.100
Well, the problem is the second
statement has many pluses.

00:28:53.190 --> 00:28:54.550
I think there's three there.

00:28:54.560 --> 00:28:58.700
And you don't know what it applies to.

00:28:58.760 --> 00:29:03.970
So with Clang,
what's wonderful is the first

00:29:03.990 --> 00:29:06.990
diagnostic is actually telling
you what the problem is.

00:29:06.990 --> 00:29:10.070
It's saying indirection
requires a pointer operand,

00:29:10.250 --> 00:29:11.330
and int is invalid.

00:29:11.430 --> 00:29:14.360
So it's giving you the
type that it's confused by,

00:29:14.360 --> 00:29:16.570
which GCC wasn't giving you.

00:29:16.580 --> 00:29:16.620
Okay.

00:29:17.130 --> 00:29:17.520
Okay.

00:29:17.520 --> 00:29:17.530
Okay.

00:29:17.540 --> 00:29:17.560
Okay.

00:29:17.570 --> 00:29:17.580
Okay.

00:29:17.610 --> 00:29:17.640
Okay.

00:29:17.660 --> 00:29:20.820
it is telling you exactly
what you need to know.

00:29:20.820 --> 00:29:25.500
The second error is giving
you pinpoint control on the

00:29:25.630 --> 00:29:27.690
plus sign you can see there.

00:29:27.690 --> 00:29:32.870
And having the range data on all the
expressions enables us to do some really

00:29:32.870 --> 00:29:35.530
great things with error diagnostics.

00:29:35.530 --> 00:29:39.800
It also enables us to do a much
better job with rewriting since

00:29:39.880 --> 00:29:44.220
the Clang ASTs have precise
information on the source code.

00:29:44.290 --> 00:29:47.860
And I'm going to talk a little
bit more about that later.

00:29:47.860 --> 00:29:48.780
So we're proud of this.

00:29:56.250 --> 00:29:58.090
So now let's talk a little
bit about performance.

00:29:58.160 --> 00:30:04.020
This project is an open source project,
Postgres SQL,

00:30:04.160 --> 00:30:08.700
and front end times mean we're taking
the project and compiling it with Clang.

00:30:08.700 --> 00:30:10.200
Let me be more precise.

00:30:10.200 --> 00:30:10.960
I said compiling.

00:30:10.960 --> 00:30:15.830
That's not exactly -- well,
let me be more precise.

00:30:15.930 --> 00:30:21.390
So what we're doing here is we're
compiling -- if some of you are

00:30:21.390 --> 00:30:27.040
familiar with -f syntax only,
it basically says do lexical analysis,

00:30:27.160 --> 00:30:30.800
do preprocessing, do parsing,
do type analysis,

00:30:30.830 --> 00:30:36.060
and build your internal data structures,
but don't generate code.

00:30:36.060 --> 00:30:36.510
Right?

00:30:36.510 --> 00:30:39.100
So it does all those activities.

00:30:39.100 --> 00:30:47.410
And for gcc 4.2, it will parse,
preprocess, lexically analyze the

00:30:47.420 --> 00:30:51.440
Postgres SQL project,
which is about 665K lines

00:30:51.440 --> 00:30:53.450
of code in 49 seconds.

00:30:53.960 --> 00:30:54.290
Okay?

00:30:54.470 --> 00:30:58.620
So with Clang, we do it in 21 seconds.

00:30:58.620 --> 00:31:04.290
So that's about a 2.3%
times faster improvement.

00:31:06.520 --> 00:31:11.620
I want to emphasize that we are doing
the same exact thing GCC is doing.

00:31:11.680 --> 00:31:15.590
We're trying to compete
with GCC on its turf,

00:31:15.590 --> 00:31:17.080
so to speak.

00:31:17.080 --> 00:31:19.870
No fancy games like I'll
be talking about later.

00:31:24.480 --> 00:31:27.820
So here's the Xcode front end times.

00:31:28.020 --> 00:31:33.610
Now, Xcode's a very big project.

00:31:33.610 --> 00:31:33.610
And, um, it's

00:31:33.730 --> 00:31:49.470
and I are going to talk
about the LLVM-gcc 4.2.

00:31:49.470 --> 00:31:49.590
It consists of hundreds,
thousands of modules.

00:31:49.590 --> 00:31:49.590
And gcc 4.2 compiles it in roughly
-- that translates into 16 minutes.

00:31:49.590 --> 00:31:49.590
It's 972 seconds.

00:31:51.990 --> 00:32:00.660
With Clang, we do it in 420 seconds or,
let's see, six minutes, right?

00:32:00.660 --> 00:32:01.360
Seven minutes.

00:32:01.360 --> 00:32:05.300
So,
trying to get a little improvement there.

00:32:05.370 --> 00:32:07.940
So, seven minutes,
that saves nine minutes.

00:32:07.940 --> 00:32:08.740
Okay?

00:32:08.740 --> 00:32:12.160
Now, again, it's consistent.

00:32:12.160 --> 00:32:16.400
The reason we're showing you a
C project versus an Objective-C project,

00:32:16.400 --> 00:32:21.000
it turns out that Objective-C,
like many object-oriented languages,

00:32:21.050 --> 00:32:25.260
the code usually contains more
type information in headers,

00:32:25.640 --> 00:32:25.960
right?

00:32:25.960 --> 00:32:30.260
The compilation of your program or the
parsing and preprocessing of your program

00:32:30.640 --> 00:32:35.380
is heavily dependent on the number of
headers and the contents of the headers.

00:32:35.380 --> 00:32:40.350
For example, in Xcode, believe it or not,
we push, like,

00:32:40.490 --> 00:32:46.050
16 gigs -- 16 gig bytes through
the whole preprocessor and

00:32:46.050 --> 00:32:48.810
parser when we're doing our job.

00:32:48.910 --> 00:32:51.430
So, it's a tremendous volume of data.

00:32:51.540 --> 00:32:55.280
And C projects, in fact,
don't have the same girth

00:32:55.280 --> 00:32:57.350
of header information.

00:32:57.540 --> 00:33:02.460
So, the fact that we're
scaling is quite good now.

00:33:02.500 --> 00:33:05.320
One last point I want to make on this.

00:33:05.320 --> 00:33:09.200
So, how do we beat GCC,
which has been around for so long,

00:33:09.200 --> 00:33:11.810
so many people are hacking on it?

00:33:11.840 --> 00:33:16.570
What could they be doing wrong, right?

00:33:16.970 --> 00:33:22.540
All we're really doing is using
smart algorithms and data structures.

00:33:22.540 --> 00:33:26.940
It sounds a little bit absurd,
but that's all we're doing.

00:33:29.500 --> 00:33:30.420
Well, one other thing.

00:33:30.560 --> 00:33:33.100
This is like the fourth parser
I've written in my career,

00:33:33.120 --> 00:33:35.640
so that does account for something,
right?

00:33:35.640 --> 00:33:36.930
We have experience with this.

00:33:37.220 --> 00:33:39.840
We've seen mistakes.

00:33:39.840 --> 00:33:42.710
Chris and I, the team,
we've seen different compilers,

00:33:42.710 --> 00:33:44.280
and we've learned from them.

00:33:44.280 --> 00:33:47.320
So this is -- it's
something that -- I mean,

00:33:47.340 --> 00:33:52.400
I can trivialize by saying it's
smart algorithms and data structures,

00:33:52.400 --> 00:33:56.720
but there is a lot of experience
we've gained through the years,

00:33:56.720 --> 00:33:56.720
and we're benefiting from it.

00:33:58.530 --> 00:34:06.120
So now I'm going to move from
time and talk about architecture.

00:34:06.120 --> 00:34:12.000
What I have here is a diagram
of Xcode's architecture today.

00:34:12.000 --> 00:34:13.210
And it's very high level.

00:34:13.470 --> 00:34:19.110
But the idea here is the Xcode IDE has
a built-in preprocessor parser for C,

00:34:19.230 --> 00:34:20.740
Objective-C, and C++.

00:34:20.880 --> 00:34:28.000
And that built-in machinery enables
the IDE to do things like code sense,

00:34:28.000 --> 00:34:30.910
indexing, refactoring.

00:34:31.620 --> 00:34:36.500
That infrastructure does not
know how to do code generation.

00:34:36.500 --> 00:34:42.360
So when you ask Xcode to build,
it's delegating the code generation,

00:34:42.360 --> 00:34:44.120
so to speak, to GCC.

00:34:44.120 --> 00:34:46.980
GCC is a Unix command line tool.

00:34:46.980 --> 00:34:50.940
When you run it with a source file,
if you run it on three files,

00:34:50.940 --> 00:34:54.190
it forgets what it did the previous time,
right?

00:34:54.190 --> 00:35:00.310
It's a batch compiler where it
will run and forget what it did,

00:35:00.410 --> 00:35:01.480
run and forget what it did, and so on.

00:35:01.500 --> 00:35:05.080
On the other hand,
the built-in preprocessor actually

00:35:05.190 --> 00:35:09.750
has some interesting optimizations
for basically caching headers

00:35:09.750 --> 00:35:14.290
and doing other interesting
optimizations because it's running

00:35:14.340 --> 00:35:18.760
in process and does not live and die,
live and die as a batch compiler does.

00:35:18.760 --> 00:35:22.760
So what's wrong with the picture?

00:35:23.630 --> 00:35:27.040
The problem is we're parsing twice,
right?

00:35:27.170 --> 00:35:32.010
The built-in parser is parsing,
then GCC is parsing.

00:35:32.050 --> 00:35:35.200
And it's error prone, right?

00:35:35.200 --> 00:35:39.130
Considering this architecture, again,
Xcode does a remarkable job.

00:35:39.270 --> 00:35:42.230
And since I've been involved
in it from its inception,

00:35:42.320 --> 00:35:45.540
I'm the last person that's going
to stand up here and belittle

00:35:45.850 --> 00:35:48.100
our wonderful tool called Xcode.

00:35:48.100 --> 00:35:52.640
However, it could be doing a lot more,
and I'm going to talk about

00:35:52.720 --> 00:35:55.000
that in the coming slide.

00:35:55.030 --> 00:36:04.110
It basically leads to compromises, okay?

00:36:04.110 --> 00:36:04.110
For example, if you're going to use a lot

00:36:05.030 --> 00:36:10.660
If you are trying to find a symbol
in Xcode and you can't find a symbol,

00:36:10.900 --> 00:36:15.300
but your code compiles with GCC,
right there is a huge disconnect.

00:36:15.410 --> 00:36:19.670
It's like, my code compiles,
how come it can't find a symbol?

00:36:19.670 --> 00:36:22.170
Well, the answer is this architecture.

00:36:22.450 --> 00:36:25.750
Because, for example,
getting two preprocessors

00:36:25.760 --> 00:36:30.730
to agree on exactly the same
input is actually really hard.

00:36:31.090 --> 00:36:33.000
It's extremely hard.

00:36:33.000 --> 00:36:37.170
And so the duplication of effort
leads to bugs and it leads to

00:36:37.280 --> 00:36:39.920
considerable engineering effort.

00:36:39.920 --> 00:36:41.820
As you know, we just added blocks.

00:36:41.820 --> 00:36:43.780
Well, we prototype blocks in Clang.

00:36:43.870 --> 00:36:48.820
We wanted to make sure we got them
right before we wrestled with GCC.

00:36:48.820 --> 00:36:52.520
And it would be great to live
in a world where we could just

00:36:53.290 --> 00:36:54.800
basically add our features to Clang.

00:36:54.800 --> 00:36:56.890
Because as you've noticed,
we've been doing a lot

00:36:57.000 --> 00:36:59.260
more with Objective-C over
the past couple of years.

00:36:59.260 --> 00:37:02.330
We've added garbage collection,
properties, now we're doing blocks.

00:37:02.430 --> 00:37:04.920
There's a lot of interesting
work going on there.

00:37:05.030 --> 00:37:11.390
And we don't want to have to modify three
or four or five compilers to do our job.

00:37:12.800 --> 00:37:19.580
So the vision here is that we have
an efficient implementation here

00:37:19.590 --> 00:37:26.540
that uses Clang that will directly
generate code from within the IDE.

00:37:26.540 --> 00:37:29.400
No need to parse twice in process.

00:37:29.450 --> 00:37:31.290
We can do many things here.

00:37:31.390 --> 00:37:32.410
We can cache files.

00:37:32.410 --> 00:37:33.800
We can cache tokens.

00:37:33.800 --> 00:37:37.620
We can cache abstract syntax trees,
which leads to a much more

00:37:37.620 --> 00:37:39.580
incremental development environment.

00:37:39.580 --> 00:37:46.580
So the excitement we have
here is really significant,

00:37:46.580 --> 00:37:52.630
and we hope to deliver
some of this next WWDC.

00:37:53.740 --> 00:37:57.190
Again, the unified parser will
give us fewer bugs,

00:37:57.190 --> 00:38:00.960
and it will greatly simplify our
life in making language changes,

00:38:00.960 --> 00:38:04.470
which to some degree
doesn't affect you guys.

00:38:04.470 --> 00:38:10.500
But if we're going to move quickly and
implement the features all of you desire,

00:38:10.500 --> 00:38:15.720
it is important to basically make
our lives easy and simplify our life.

00:38:15.870 --> 00:38:22.140
And we don't like wrestling with GCC.

00:38:27.020 --> 00:38:33.800
So we're using this quite extensively
for several internal projects.

00:38:33.800 --> 00:38:36.420
People are really happy with
what they're seeing so far.

00:38:36.520 --> 00:38:38.440
We're actively fixing bugs.

00:38:38.440 --> 00:38:42.060
We have some wonderful people
in the open source community

00:38:42.490 --> 00:38:44.440
that have been helping us.

00:38:44.570 --> 00:38:48.450
I'm just wildly impressed with
the quality of people that have

00:38:48.450 --> 00:38:50.360
been attracted to the project.

00:38:50.450 --> 00:38:55.190
Some very talented people in
universities have gathered around.

00:38:55.340 --> 00:38:58.420
And we're thrilled with the progress.

00:38:58.420 --> 00:39:00.540
C99 and Objective-C are shaping up well.

00:39:00.540 --> 00:39:04.700
As I said,
Clang basically parses all of Xcode.

00:39:04.800 --> 00:39:09.380
And Xcode is one of the more challenging
Objective-C programs on the planet.

00:39:09.480 --> 00:39:13.330
There were several things that
I had to fix in Clang that I didn't

00:39:13.330 --> 00:39:15.740
even know existed in the language.

00:39:15.740 --> 00:39:19.430
And since I've been
involved from the beginning,

00:39:19.430 --> 00:39:21.840
that's pretty interesting.

00:39:22.720 --> 00:39:25.340
And some of them are bad,
and we're filing bugs

00:39:25.340 --> 00:39:27.160
against GCC in some cases.

00:39:27.280 --> 00:39:30.650
But again, we're going to be bug for
bug compatible if it's going

00:39:30.810 --> 00:39:32.570
to be a drop in replacement.

00:39:32.680 --> 00:39:35.080
So anyway, C++ is under development.

00:39:35.110 --> 00:39:36.190
It's still very early.

00:39:36.190 --> 00:39:41.590
Again, we have some excellent people
across the globe who are helping us.

00:39:41.590 --> 00:39:47.840
And we really sense that this is the time
to have something great and replace GCC.

00:39:47.950 --> 00:39:49.140
And we hope you agree.

00:39:49.140 --> 00:39:52.600
So with that, I'm going to bring up an
extremely talented person

00:39:52.670 --> 00:39:56.190
who works with us on this,
Ted Kremenek.

00:40:02.700 --> 00:40:03.600
Hi, everyone.

00:40:03.600 --> 00:40:08.350
So we're very excited about Clang,
and I think Steve put it very eloquently.

00:40:08.440 --> 00:40:11.060
So in this last part of this session,
I'm going to be talking

00:40:11.100 --> 00:40:14.200
about other applications that
we have in mind for Clang,

00:40:14.570 --> 00:40:16.930
besides it just being
the basis of a great C,

00:40:16.940 --> 00:40:22.630
Objective-C, C++, and if it wasn't clear,
also Objective-C++ compiler.

00:40:22.740 --> 00:40:25.410
So the things I'm going to be
talking about really tie into

00:40:25.410 --> 00:40:28.610
our vision of innovations,
features we want to

00:40:28.800 --> 00:40:30.190
put into Xcode one day.

00:40:30.560 --> 00:40:34.620
But in the general sense,
this really speaks to our belief that

00:40:34.620 --> 00:40:38.810
Clang just provides a strong foundation
for building great programming tools.

00:40:38.820 --> 00:40:43.700
And this is something we think that will
continue to happen in the Clang space,

00:40:43.700 --> 00:40:45.560
and so we're very excited about it.

00:40:45.560 --> 00:40:47.340
The only caveat I want to say
is a lot of these things that

00:40:47.470 --> 00:40:49.930
we're going to talk about,
think of them as more

00:40:49.930 --> 00:40:53.030
as speculative ideas,
crazy ideas that we have on the table

00:40:53.060 --> 00:40:56.700
that we're actively thinking about,
but they're not necessarily

00:40:56.850 --> 00:40:58.590
immediate feature promises.

00:40:58.790 --> 00:41:02.990
So, on to the first crazy idea.

00:41:03.220 --> 00:41:08.450
As Steve said, faster compilation is the
primary goal of Clang.

00:41:08.540 --> 00:41:12.600
And once you move Clang into
Xcode using the same front-end

00:41:12.600 --> 00:41:17.170
technology used by the compiler,
essentially the difference

00:41:17.170 --> 00:41:20.960
between the command line compiler
and the IDE just vaporizes.

00:41:21.060 --> 00:41:24.470
And there's just a ton of
optimizations you can do in this space,

00:41:24.470 --> 00:41:27.220
and Steve actually
mentioned several of them.

00:41:27.350 --> 00:41:31.560
Now, Xcode has this feature today
called predictive compilation.

00:41:31.630 --> 00:41:35.810
It allows it to fire off to GCC in
the background while you're still

00:41:35.820 --> 00:41:39.880
editing your code to try and compile
files that have recently changed,

00:41:39.980 --> 00:41:43.310
so by the time you hit build and go,
hopefully most of the work

00:41:43.310 --> 00:41:44.800
has already been done.

00:41:44.870 --> 00:41:47.600
But if we move over to Clang,
there's a lot more we

00:41:47.600 --> 00:41:48.940
can do in this space.

00:41:49.060 --> 00:41:52.180
Essentially,
we can incrementally reparse your files,

00:41:52.370 --> 00:41:55.810
building up the same data structures that
a command line compiler would build up.

00:41:55.820 --> 00:42:00.040
So at any point in time,
we're ready to go and generate new code.

00:42:00.120 --> 00:42:03.780
And so not only can you just
speed up recompiling individual

00:42:03.780 --> 00:42:07.500
files that have changed,
but we can potentially do things like

00:42:07.500 --> 00:42:10.780
only recompile the functions or the
methods that have actually changed,

00:42:10.780 --> 00:42:15.320
since Xcode will have cached all the
information from its previous builds.

00:42:15.320 --> 00:42:19.090
And this alone will lead
to tremendous performance

00:42:19.090 --> 00:42:21.770
increases when we're compiling.

00:42:23.020 --> 00:42:26.460
So the second thing that we're really
thinking about is just making a

00:42:26.460 --> 00:42:30.520
better user experience within Xcode.

00:42:30.610 --> 00:42:33.470
And if you're familiar with it,
there's this great

00:42:33.470 --> 00:42:35.960
feature called CodeSense,
and we also do indexing.

00:42:36.060 --> 00:42:38.060
So it allows you to do
things like auto-completion.

00:42:38.090 --> 00:42:40.490
You're typing a function
that you want to call,

00:42:40.490 --> 00:42:43.460
and Xcode gives you a suggestion
of what function to use.

00:42:43.460 --> 00:42:47.750
And also you can do things like jump to
definitions of a function or a method.

00:42:47.760 --> 00:42:50.500
So this very quick
navigation of your code.

00:42:50.500 --> 00:42:55.830
The problem is that whether or not you're
using Xcode or Visual Studio or whatever,

00:42:55.830 --> 00:43:00.680
we all know that the best IDEs out
there are easily confused by commonplace

00:43:00.680 --> 00:43:05.240
language features and C-based languages,
like preprocessor macros.

00:43:05.240 --> 00:43:09.380
And even templates are not really
handled very well by any IDE.

00:43:09.380 --> 00:43:12.680
And the idea is if we move
Xcode over to using Clang,

00:43:12.690 --> 00:43:16.520
if the compiler can understand it,
so can the IDE.

00:43:16.520 --> 00:43:17.600
And then all these features will
just be able to get to the code.

00:43:17.600 --> 00:43:20.060
And so this will just
fluidly work together.

00:43:20.120 --> 00:43:23.880
And also all this rich source level
information will be in the IDE so we

00:43:23.880 --> 00:43:28.500
can expound and do more interesting kind
of behavioral experiences in the IDE.

00:43:28.720 --> 00:43:32.170
And our hope is with this we
can make Xcode the best IDE on

00:43:32.180 --> 00:43:36.940
the planet for editing C,
C++, and Objective-C.

00:43:37.830 --> 00:43:41.270
Now the third thing I want
to talk about is refactoring.

00:43:41.390 --> 00:43:44.340
Refactoring is a technology
that's in Xcode today,

00:43:44.420 --> 00:43:45.620
and we're very happy about it.

00:43:45.700 --> 00:43:48.700
Now if you're not familiar
with what refactoring is,

00:43:48.700 --> 00:43:52.690
it's essentially harnessing the ID's
knowledge of your entire code base

00:43:52.690 --> 00:43:55.700
to do high level structural edits.

00:43:55.710 --> 00:43:58.640
So it could be things like renaming
variables across a whole project,

00:43:58.740 --> 00:44:02.700
or moving an instant variable
from a class to its parent class,

00:44:02.700 --> 00:44:05.700
splitting classes apart,
extracting functions

00:44:05.700 --> 00:44:07.700
from a piece of code.

00:44:07.700 --> 00:44:10.030
So a lot of these kinds of
evolutionary kind of design

00:44:10.030 --> 00:44:13.010
changes that you would want to do,
that could be error prone

00:44:13.120 --> 00:44:14.690
or tedious to do by hand.

00:44:14.700 --> 00:44:17.700
So it's great if the
tools can do this for us.

00:44:17.700 --> 00:44:21.340
Now the problem is that refactoring
tools basically use the same

00:44:21.340 --> 00:44:24.490
front end technology as the
IDE that they're housed in.

00:44:24.700 --> 00:44:26.790
And so if the IDE doesn't
understand the code,

00:44:26.840 --> 00:44:28.700
neither will the refactoring tool.

00:44:28.700 --> 00:44:31.700
And the refactoring tool
is going to edit your code.

00:44:31.700 --> 00:44:35.680
It's going to go make suggestions
of how the code should be changed.

00:44:35.700 --> 00:44:36.320
And if it doesn't understand your code,
it's going to go make suggestions

00:44:36.320 --> 00:44:36.690
of how the code should be changed.

00:44:36.750 --> 00:44:37.700
And if it doesn't understand your code,
it's going to go make suggestions

00:44:37.700 --> 00:44:37.700
of how the code should be changed.

00:44:37.700 --> 00:44:38.700
So if the IDE doesn't
understand your code,

00:44:38.700 --> 00:44:40.700
the transformations aren't
necessarily guaranteed to be accurate.

00:44:40.940 --> 00:44:44.690
And they're not necessarily
guaranteed to be complete.

00:44:44.790 --> 00:44:47.120
And we provide a user interface
with our refactoring tool to try

00:44:47.180 --> 00:44:51.700
and deal with the case that it's not
necessarily going to be 100% accurate.

00:44:51.700 --> 00:44:54.690
And that you make the
changes that you want to do.

00:44:54.930 --> 00:44:57.470
But on an aside,
it's just basically if our

00:44:57.470 --> 00:45:01.820
refactoring technology can't
understand the code perfectly,

00:45:01.820 --> 00:45:04.950
it also prohibits us from
doing a lot of transformations

00:45:04.950 --> 00:45:06.700
that we could otherwise do.

00:45:06.700 --> 00:45:09.700
So along with moving
Xcode over to using Clang,

00:45:09.700 --> 00:45:14.580
we'd like to move all of our refactoring
technology over to using Clang as well.

00:45:14.700 --> 00:45:16.700
And this is going to buy us two things.

00:45:16.700 --> 00:45:19.650
More accuracy with our transformations.

00:45:19.700 --> 00:45:22.670
This is going to enable more
refactoring opportunities as well.

00:45:22.700 --> 00:45:25.620
And we want it to be very scalable.

00:45:25.700 --> 00:45:28.700
Clang is designed to be very
fast and memory efficient.

00:45:28.700 --> 00:45:31.140
And so we'd like to do
transformations that operate

00:45:31.140 --> 00:45:32.700
at the speed of your thought.

00:45:32.700 --> 00:45:35.690
That have millions or even thousands
or millions of lines of code.

00:45:35.700 --> 00:45:39.680
of lines of code in
seconds or milliseconds.

00:45:39.870 --> 00:45:42.640
Now the last thing that I want
to talk about is a feature

00:45:42.640 --> 00:45:44.340
that is not in Xcode today.

00:45:44.340 --> 00:45:49.410
We have refactoring, we have indexing,
code sense, and we do a fair amount

00:45:49.810 --> 00:45:51.840
of predictive compilation.

00:45:52.000 --> 00:45:56.180
The last feature is something that we
are actively investing interest in,

00:45:56.180 --> 00:45:59.700
and that's automatic bug
finding using static analysis.

00:46:00.030 --> 00:46:02.570
Now, if you're not familiar
with static analysis is,

00:46:02.570 --> 00:46:06.340
I'm going to take a
broader picture first.

00:46:06.340 --> 00:46:08.940
And that is,
wouldn't it be great if the IDE was more

00:46:08.940 --> 00:46:10.740
than just a great editing environment?

00:46:10.740 --> 00:46:14.390
What if it could help you be very
proactive about trying to make your

00:46:14.450 --> 00:46:16.510
code better before you even run it?

00:46:16.520 --> 00:46:20.540
Chris Latten, Devang Patel, Steve Naroff,
Ted Kremenek Now, if you're not familiar

00:46:20.540 --> 00:46:22.560
with static analysis is,
I'm going to take a

00:46:22.600 --> 00:46:23.750
broader picture first.

00:46:23.820 --> 00:46:26.150
And that is,
wouldn't it be great if the IDE was more

00:46:26.150 --> 00:46:27.960
than just a great editing environment?

00:46:28.080 --> 00:46:31.180
What if it could help you be very
proactive about trying to make your

00:46:31.180 --> 00:46:33.370
code better before you even run it?

00:46:33.560 --> 00:46:37.840
Now we're already familiar with compilers
providing us some kind of feedback

00:46:37.840 --> 00:46:41.200
in the form of compile time warnings.

00:46:41.200 --> 00:46:44.100
And so these go beyond compile
time errors where your code

00:46:44.100 --> 00:46:45.480
just doesn't compile at all.

00:46:45.610 --> 00:46:49.530
These are suggestions of I see something
in your code that looks kind of dubious,

00:46:49.530 --> 00:46:53.220
and if you were to run it,
I think something wrong would happen.

00:46:53.220 --> 00:46:56.970
So here's an actual diagnostic from
the commit Clang command line driver

00:46:57.440 --> 00:47:01.970
indicating a format string specifier in
this call to printf that's just wrong.

00:47:01.970 --> 00:47:02.640
It's bogus.

00:47:02.740 --> 00:47:06.500
It will result in unpleasant
behavior at runtime.

00:47:06.500 --> 00:47:09.820
And GCC also emits a
similar kind of diagnostic.

00:47:09.820 --> 00:47:12.600
And the real power of these kinds
of warnings is that they're cheap,

00:47:12.620 --> 00:47:14.740
they can happen as you're
compiling your code,

00:47:14.750 --> 00:47:17.300
or we can proactively check
for these things once Clang

00:47:17.370 --> 00:47:18.880
is integrated into Xcode.

00:47:18.880 --> 00:47:24.040
And they're really effective at reducing
the number of bugs in your program.

00:47:24.040 --> 00:47:26.640
But we can go a lot further than this.

00:47:26.640 --> 00:47:30.680
There has been a lot of work in this
area called static analysis where

00:47:30.980 --> 00:47:34.880
essentially instead of finding a bug
that occurs on a particular statement,

00:47:35.010 --> 00:47:39.020
like in the case of this example,
we can find bugs that require a very

00:47:39.020 --> 00:47:41.160
specific set of events to happen.

00:47:41.160 --> 00:47:43.860
So a certain set of
branches have to be taken.

00:47:43.860 --> 00:47:48.840
A specific path through your code has
to be taken in order for a bug to occur.

00:47:48.840 --> 00:47:52.880
And the real awesome feature of
this is essentially you're trading

00:47:52.910 --> 00:47:55.730
CPU time for checking out your program.

00:47:55.790 --> 00:47:59.000
You know, so this is maybe idle time
actually while you're editing.

00:47:59.000 --> 00:47:59.950
And you're editing your code.

00:48:00.040 --> 00:48:03.170
So these are free cycles
that are available for use.

00:48:03.280 --> 00:48:06.010
And it really complements the
traditional ways in which we try to

00:48:06.010 --> 00:48:08.950
do quality assurance on our code,
such as testing.

00:48:09.140 --> 00:48:13.840
Because the compiler basically has
an inexhaustible attention to detail.

00:48:13.900 --> 00:48:15.980
It's fine to just crank
away at your code,

00:48:15.980 --> 00:48:19.170
reason about all the different
ways that it could be exercised

00:48:19.370 --> 00:48:23.380
in order to find those corner
cases in which bugs could occur.

00:48:23.720 --> 00:48:26.480
So I'm going to give you a
flavor of a few bugs that we

00:48:26.520 --> 00:48:27.950
can find with static analysis.

00:48:28.070 --> 00:48:29.720
This is really just
the tip of the iceberg.

00:48:29.890 --> 00:48:31.610
These are very simple examples,
obviously,

00:48:31.610 --> 00:48:33.520
for the purpose of presentation.

00:48:33.660 --> 00:48:36.590
There's a lot more we can do.

00:48:37.860 --> 00:48:43.790
So this is a mockup of a real
bug found in Xcode using static

00:48:43.860 --> 00:48:46.690
analysis technology built on Clang.

00:48:46.810 --> 00:48:51.140
So it involves this switch statement
where there's several cases where

00:48:51.140 --> 00:48:55.860
on each case the value of str is
assigned a separate string literal.

00:48:55.860 --> 00:48:59.820
So this is like a dispatch
on some enumeration value.

00:48:59.980 --> 00:49:02.960
And the diagnostic emitted by
the static analysis tool is,

00:49:02.960 --> 00:49:05.800
hey, I see that this value that
you stored to str is just,

00:49:05.810 --> 00:49:07.760
it's never read later.

00:49:07.800 --> 00:49:10.070
And what happens is that there's
a missing break statement

00:49:10.380 --> 00:49:13.250
between case 1 and case 2.

00:49:13.460 --> 00:49:15.200
And what happens is str
is just overwritten,

00:49:15.200 --> 00:49:19.970
so case 1 always looks like case 2.

00:49:20.200 --> 00:49:23.400
Having a missing break statement,
not having a break statement,

00:49:23.400 --> 00:49:24.980
is not a crime in itself.

00:49:25.200 --> 00:49:29.120
There's real reasons why you'd want to
structure your control flow that way.

00:49:29.180 --> 00:49:33.190
But logically, semantically,
this is not what the programmer wanted.

00:49:33.240 --> 00:49:36.430
They have dead code here
that just-- it's meaningless.

00:49:36.620 --> 00:49:40.820
And so by reasoning about the
logical inconsistency of the program,

00:49:40.870 --> 00:49:43.950
we can pinpoint some very
interesting bugs in this way.

00:49:44.100 --> 00:49:46.380
And this particular
check for dead stores,

00:49:46.480 --> 00:49:51.170
we found a lot of interesting
bugs in many of our software.

00:49:52.910 --> 00:49:56.070
So the other class of bugs
which I think really hit home to

00:49:56.070 --> 00:49:59.360
almost everybody is memory leaks.

00:49:59.360 --> 00:50:03.760
So whether or not you're writing
an app that uses garbage collection

00:50:03.760 --> 00:50:07.770
or doesn't use garbage collection,
any real program has to do some

00:50:07.850 --> 00:50:10.540
amount of manual resource management.

00:50:10.540 --> 00:50:12.780
So it could be dynamically
allocated memory,

00:50:12.820 --> 00:50:15.660
it could be files that you open, sockets,
you know, whatever.

00:50:15.660 --> 00:50:19.380
There are always things that we have to
manually manage despite having maybe a

00:50:19.450 --> 00:50:26.340
magic garbage collector to come around
and clean up some of our unused memory.

00:50:26.340 --> 00:50:31.680
And I think static analysis can go a long
way to catching misuses of resources,

00:50:31.750 --> 00:50:34.480
leaks, using a resource after
it's no longer available,

00:50:34.490 --> 00:50:37.900
because we tend to use these
resources in very stylistic,

00:50:37.900 --> 00:50:39.540
idiomatic ways.

00:50:39.540 --> 00:50:43.440
So this particular example involves
some objective C code that I mocked up.

00:50:43.440 --> 00:50:46.480
It involves allocating
an object at the top,

00:50:46.480 --> 00:50:50.550
an NSMutable dictionary object,
then we decal some method,

00:50:50.550 --> 00:50:55.150
and then on some error condition we go,
oh, well, I don't know what to do,

00:50:55.150 --> 00:50:56.300
so I'm going to return.

00:50:56.420 --> 00:50:59.250
And therefore there's actually a
leak here because the reference

00:50:59.380 --> 00:51:04.580
count associated with the dict
object isn't actually decremented.

00:51:04.670 --> 00:51:07.440
So if you're not familiar with
this idiom in objective C,

00:51:07.440 --> 00:51:09.640
these are reference counted objects.

00:51:09.640 --> 00:51:13.920
And so this kind of error -- you have
to correctly use retain and release in

00:51:13.920 --> 00:51:16.740
order to manage the reference counts.

00:51:16.900 --> 00:51:18.620
But because we use retain and release,
we're not going to be able

00:51:18.620 --> 00:51:18.620
to get the reference counts.

00:51:18.620 --> 00:51:21.260
So if we use retain and
release very stylistically,

00:51:21.260 --> 00:51:23.660
it's very easy for
static analysis to catch.

00:51:23.670 --> 00:51:25.960
And you can imagine the same
kind of checking could apply

00:51:26.090 --> 00:51:28.950
to things like new and delete,
malloc and free and so forth.

00:51:29.240 --> 00:51:33.060
So I think there's a lot of kind of
memory leaks and other related bugs

00:51:33.160 --> 00:51:35.580
we can find with static analysis.

00:51:36.370 --> 00:51:37.310
And that's just the start.

00:51:37.430 --> 00:51:39.340
I think there's a lot of
things that we can check.

00:51:39.660 --> 00:51:44.500
Security bugs, API rules, crashes,
assertion failures, data races.

00:51:44.540 --> 00:51:47.750
There's a lot of opportunities
for static analysis to greatly

00:51:47.750 --> 00:51:50.180
improve the quality of our code.

00:51:51.450 --> 00:51:54.500
So there are a few design goals
that we have in place for building

00:51:54.720 --> 00:51:58.260
a tool that would be useful for you.

00:51:58.480 --> 00:52:01.190
The first one is usability.

00:52:02.220 --> 00:52:06.230
The problem is that bugs in the real
world can actually be fairly complex.

00:52:06.390 --> 00:52:12.010
They can require a convoluted path
through your code to actually trigger.

00:52:12.440 --> 00:52:16.600
The one thing about Clang is we have
very rich source level information.

00:52:16.690 --> 00:52:19.360
And this is going to enable
us to give very precise

00:52:19.360 --> 00:52:22.460
diagnostic about in this file,
at this line,

00:52:22.760 --> 00:52:27.060
maybe even within this macro expansion,
something bad happened,

00:52:27.060 --> 00:52:30.600
pinpoint you to directly
where the problem occurs.

00:52:30.770 --> 00:52:36.740
Now the other problem is that some bugs
found by static analysis aren't real.

00:52:36.900 --> 00:52:41.190
I think the notorious term
here is false positives.

00:52:41.720 --> 00:52:45.170
The problem is that static analysis
is reasoning about complex runtime

00:52:45.170 --> 00:52:47.900
behavior without running your program.

00:52:48.030 --> 00:52:50.900
And so it's just not perfect.

00:52:51.070 --> 00:52:54.920
Our design goal is to address this
by trying to have as few number

00:52:54.920 --> 00:52:58.130
of false positives as possible,
because otherwise the

00:52:58.130 --> 00:52:59.240
tool is just useless.

00:52:59.240 --> 00:53:03.160
If you just get too much noise,
you don't want to invest any

00:53:03.160 --> 00:53:05.340
time in using the tool at all.

00:53:05.800 --> 00:53:09.460
Now the second thing
is Objective-C support.

00:53:09.590 --> 00:53:13.540
Clang supports Objective-C, C,
and eventually C++.

00:53:13.650 --> 00:53:16.410
So anything that Clang supports,
the static analysis

00:53:16.420 --> 00:53:22.010
technology I'm talking about,
should also support it as well.

00:53:22.240 --> 00:53:25.480
The Mac and the iPhone,
Objective-C is the language

00:53:25.500 --> 00:53:27.200
to build applications.

00:53:27.310 --> 00:53:31.090
And so we're really interested in
having strong support for Objective-C.

00:53:31.190 --> 00:53:33.860
And there's no other static
analysis tool out there that

00:53:33.980 --> 00:53:35.740
has any support for Objective-C.

00:53:35.740 --> 00:53:38.670
Now,
Objective-C is a highly dynamic language.

00:53:38.710 --> 00:53:41.870
This is not necessarily --
this is not really going to be

00:53:41.870 --> 00:53:43.730
a problem for static analysis.

00:53:43.830 --> 00:53:47.540
The things that we're mainly concerned
with is that we have these huge APIs.

00:53:47.540 --> 00:53:49.750
You're using them to develop apps.

00:53:49.750 --> 00:53:54.340
We think we can systematically enforce
a lot of the rules involved with

00:53:54.340 --> 00:53:57.540
those APIs by using static analysis.

00:53:57.590 --> 00:54:00.960
So as you are typing your code,
you can be less concerned that you're

00:54:00.960 --> 00:54:04.530
just doing the wrong thing because
you don't know some hidden rule.

00:54:04.540 --> 00:54:08.320
The static analysis can be there
to try and enforce those hidden

00:54:08.490 --> 00:54:10.510
rules that you don't know about.

00:54:10.570 --> 00:54:14.520
And these can be things from, you know,
very complicated rules that you

00:54:14.540 --> 00:54:16.980
must call one method after another,
to even very simple rules that

00:54:16.980 --> 00:54:17.540
you can't really know about.

00:54:17.540 --> 00:54:21.740
things such as you should never
pass nil to a particular method.

00:54:21.920 --> 00:54:26.430
The other thing we're very concerned
about is memory management errors.

00:54:26.450 --> 00:54:28.190
The phone is all reference counted.

00:54:28.420 --> 00:54:30.200
There's no garbage collection there.

00:54:30.310 --> 00:54:33.240
And even if you use garbage
collection on the Mac,

00:54:33.590 --> 00:54:37.610
there's some special rules you must
obey in order for the garbage collector

00:54:37.700 --> 00:54:39.750
to work correctly with your code.

00:54:39.830 --> 00:54:44.710
And so we think we can enforce
a lot of these rules using

00:54:44.710 --> 00:54:44.710
static analysis as well.

00:54:46.640 --> 00:54:48.670
So where are we now today with this?

00:54:48.670 --> 00:54:49.860
This isn't vapor.

00:54:49.860 --> 00:54:54.200
We've made a strong initial investment
in static analysis based on Clang.

00:54:54.200 --> 00:54:58.610
It's probably one of the biggest
applications we've developed so far.

00:54:58.610 --> 00:55:01.530
We're actively researching
and developing it.

00:55:01.550 --> 00:55:04.860
We actually have an alpha,
maybe beta quality memory leak

00:55:04.980 --> 00:55:07.080
checker for foundation objects.

00:55:07.080 --> 00:55:10.670
So that retain release bug,
that's an actual diagnostic that

00:55:10.790 --> 00:55:12.640
would be emitted by the tool.

00:55:12.640 --> 00:55:16.340
And we've used it and
found and fixed bugs.

00:55:16.500 --> 00:55:21.280
In the phone, in Xcode itself,
in the Mac OS X kernel,

00:55:21.650 --> 00:55:24.650
and various frameworks that
we have available at Apple.

00:55:24.950 --> 00:55:29.500
So you already are benefiting from
the effects of this technology.

00:55:29.500 --> 00:55:32.770
Now while we're not
shipping it today in Xcode,

00:55:32.770 --> 00:55:36.500
it's not available at
developer.apple.com.

00:55:36.500 --> 00:55:39.500
It is, like the rest of Clang,
100% open source.

00:55:39.500 --> 00:55:46.210
And you can download and try it out today
if you wish by going to clang.llvm.org.

00:55:53.130 --> 00:56:01.590
The only caveat is this is
a very early stage tool.

00:56:01.800 --> 00:56:02.630
So that's it.

00:56:02.950 --> 00:56:04.840
So we talked about a lot of things today.

00:56:04.840 --> 00:56:07.690
We talked about what LLVM is.

00:56:07.780 --> 00:56:10.350
And we talked about what
we're delivering to you,

00:56:10.350 --> 00:56:12.140
what's built on LLVM.

00:56:12.160 --> 00:56:16.900
The Vang talked about LLVM GCC and how
it's a truly awesome standalone compiler.

00:56:16.960 --> 00:56:20.340
It can give you both faster
compiles on much of your code,

00:56:20.410 --> 00:56:23.890
and we think it's going to
generate much faster executables

00:56:23.890 --> 00:56:25.680
for many real workloads.

00:56:25.680 --> 00:56:29.480
You need to try it out to really
measure its benefits to you,

00:56:29.480 --> 00:56:32.950
but you can easily try it out within
Xcode from the drag down option,

00:56:32.970 --> 00:56:36.940
just like the compiler you're using,
or you can use it from the command

00:56:36.940 --> 00:56:41.170
line from developer user bin LLVM GCC.

00:56:41.380 --> 00:56:44.090
Steve talked about Clang,
this vision for this new

00:56:44.090 --> 00:56:46.520
C front end that we're building.

00:56:46.520 --> 00:56:47.730
It's more than vision.

00:56:47.730 --> 00:56:51.080
We have a really active code base,
and we can parse almost

00:56:51.090 --> 00:56:53.440
all of C and Objective C.

00:56:53.590 --> 00:56:55.040
We're actively developing it still.

00:56:55.040 --> 00:56:56.810
There's a rich developer
community around it,

00:56:56.810 --> 00:56:59.070
and we're very excited about
the new kind of tools it's

00:56:59.070 --> 00:57:00.720
going to enable us to build.

00:57:00.940 --> 00:57:06.960
Better refactoring, static analysis,
and most importantly, a better Xcode.

00:57:06.960 --> 00:57:10.360
And the great thing is all
of this is open source.

00:57:10.400 --> 00:57:13.700
The LLVM project you can
visit by going to LLVM.org,

00:57:13.700 --> 00:57:19.800
and Clang has a specific project for
more information at clang.llvm.org.

00:57:19.800 --> 00:57:23.420
And if you have other specific questions,
please contact Michael Jurowicz,

00:57:23.420 --> 00:57:25.440
our developer tools evangelist.

00:57:25.440 --> 00:57:29.500
He's also here to answer other
specific questions if you want about

00:57:29.500 --> 00:57:31.380
this session and related material.
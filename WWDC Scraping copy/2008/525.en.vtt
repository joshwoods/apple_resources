WEBVTT

00:00:20.160 --> 00:00:22.700
Okay, this is
Cocoa Development Using Scripting.

00:00:22.700 --> 00:00:23.510
Thank you all for coming.

00:00:23.510 --> 00:00:25.330
Actually, it's fairly impressive.

00:00:25.380 --> 00:00:28.290
I've never seen a room this
full before for one of my style.

00:00:29.320 --> 00:00:30.240
I'm Chris Nebel.

00:00:30.240 --> 00:00:32.320
I'm one of the engineers who
makes all this stuff work.

00:00:32.360 --> 00:00:35.630
And yes, that is what it says
on my business cards.

00:00:39.080 --> 00:00:43.000
So if you think of Mac OS code,
Mac OS development as

00:00:43.000 --> 00:00:46.160
like a big metro area,
say San Francisco,

00:00:46.880 --> 00:00:52.620
Then Cocoa, the system frameworks,
those are city center, downtown.

00:00:52.620 --> 00:00:54.430
This is the hub of all the development.

00:00:54.450 --> 00:00:56.980
This is where you go when you want
the system to do something for you.

00:00:57.040 --> 00:00:59.850
Client code, then,
stuff like your applications,

00:00:59.850 --> 00:01:02.360
is distributed around the outlying areas.

00:01:02.400 --> 00:01:05.780
Now, if you're writing in Objective-C,
then you're just a bit further

00:01:05.780 --> 00:01:08.710
south down the peninsula,
like Daly City or somewhere.

00:01:08.720 --> 00:01:11.110
Getting to Cocoa from here,
you need the system to

00:01:11.120 --> 00:01:14.080
do something for you,
you commute in, you get what you need,

00:01:14.080 --> 00:01:15.010
you come back.

00:01:15.880 --> 00:01:17.790
Getting to Cocoa from
Objective-C is trivial.

00:01:17.820 --> 00:01:20.990
You just stroll across the border,
which you probably won't even

00:01:20.990 --> 00:01:22.700
notice there is a border.

00:01:23.090 --> 00:01:24.960
But there are other
interesting areas too,

00:01:25.010 --> 00:01:26.500
with other interesting things in them.

00:01:26.570 --> 00:01:30.830
We've got other scripting languages,
we've got interesting services which

00:01:30.980 --> 00:01:32.510
are not strictly part of Cocoa.

00:01:32.850 --> 00:01:33.740
How do you get to these things?

00:01:33.810 --> 00:01:35.590
This isn't just a matter of walking.

00:01:35.870 --> 00:01:38.750
So the answer in real life, of course,
is you build bridges.

00:01:38.880 --> 00:01:41.550
And that is the answer in
the code world as well,

00:01:41.700 --> 00:01:45.140
except that our bridges are
made out of Objective-C.

00:01:46.970 --> 00:01:49.660
So we'll spend some time talking
about what you can do with a bridge,

00:01:49.660 --> 00:01:51.510
how to use Cocoa from
a scripting language,

00:01:51.520 --> 00:01:54.580
and how to use scriptable
applications from Cocoa.

00:01:54.610 --> 00:01:57.410
And we'll talk a bit about
exactly how the bridge works,

00:01:57.420 --> 00:02:00.210
how you can build one of these things.

00:02:01.800 --> 00:02:05.400
So first off, bridging two languages.

00:02:05.450 --> 00:02:08.200
So you want to write
a Mac OS application.

00:02:08.200 --> 00:02:10.720
You've got great idea, new killer app.

00:02:10.720 --> 00:02:12.760
The basics of what you need.

00:02:12.770 --> 00:02:14.210
First off, use Cocoa.

00:02:14.250 --> 00:02:16.840
Cocoa is the system
framework on Mac OS X.

00:02:16.840 --> 00:02:18.520
This is where we put
all of our good stuff.

00:02:18.520 --> 00:02:20.640
There's lots and lots of stuff in here.

00:02:20.640 --> 00:02:23.340
AppKit for doing all your UI, core data,
core animation.

00:02:23.340 --> 00:02:24.760
The list just goes on and on.

00:02:24.760 --> 00:02:26.020
Awesome tools to go with it.

00:02:26.020 --> 00:02:29.700
There's Xcode, Interface Builder,
Instruments.

00:02:30.700 --> 00:02:49.900
[Transcript missing]

00:02:50.750 --> 00:02:53.200
You know,
there are various reasons for this.

00:02:53.200 --> 00:02:55.570
Maybe you've got some big
hunk of pre-existing code,

00:02:55.580 --> 00:02:57.630
some other language you don't
want to mess with rewriting this.

00:02:57.750 --> 00:03:00.600
Maybe you're using some
specialized framework that doesn't

00:03:00.600 --> 00:03:03.440
have an equivalent in Cocoa,
like Twisted for Python.

00:03:03.600 --> 00:03:08.220
Maybe, you know,
you just prefer something else, okay?

00:03:08.370 --> 00:03:10.150
That's okay.

00:03:12.600 --> 00:03:15.540
The first thing to realize
is that Cocoa is not the

00:03:15.540 --> 00:03:17.460
same thing as Objective-C.

00:03:17.550 --> 00:03:18.460
Cocoa is a framework.

00:03:18.620 --> 00:03:19.620
Objective-C is a language.

00:03:19.650 --> 00:03:21.730
You can pull those two apart.

00:03:21.980 --> 00:03:25.120
The tricky bit is that
Objective-C is not just a language.

00:03:25.170 --> 00:03:29.500
It's a syntax and it's a runtime,
and you can pull those apart, too.

00:03:29.560 --> 00:03:31.440
If you can call the runtime,
then you can get to any

00:03:31.440 --> 00:03:33.800
Objective-C service,
which means you can get to Cocoa.

00:03:33.920 --> 00:03:37.520
And the runtime has a straight C API.

00:03:37.840 --> 00:03:39.300
So anything that can
call plain C functions,

00:03:39.300 --> 00:03:41.580
which is just about everything,
can call the runtime and

00:03:41.580 --> 00:03:42.720
therefore get through to Cocoa.

00:03:42.720 --> 00:03:44.670
And this is where a
Cocoa bridge comes in.

00:03:44.680 --> 00:03:47.670
A Cocoa bridge handles all the
grunt work of calling the runtime

00:03:47.680 --> 00:03:50.940
and translating data back and forth
from Cocoa to wherever it is you

00:03:50.940 --> 00:03:53.090
are actually interested in being.

00:03:54.210 --> 00:03:56.800
So there are Cocoa bridges
for a variety of languages,

00:03:56.800 --> 00:03:58.210
and now we'll take a look at a few.

00:03:58.460 --> 00:04:00.830
And we're going to take kind of
a Rosetta Stone approach to this,

00:04:00.830 --> 00:04:01.960
using Currency Converter.

00:04:02.020 --> 00:04:03.950
If you haven't seen this before,
Currency Converter is

00:04:03.980 --> 00:04:09.010
the basic introduction to
Cocoa tutorial application.

00:04:11.090 --> 00:04:13.000
So we're going to look
at some of the code.

00:04:13.050 --> 00:04:15.040
And this is what it looks
like in Objective-C.

00:04:15.040 --> 00:04:16.500
This is part of it anyway.

00:04:16.500 --> 00:04:17.980
This is the controller class.

00:04:18.040 --> 00:04:21.450
One of Cocoa's key concepts is
model-view-controller separation.

00:04:21.520 --> 00:04:23.430
Model is what your
application actually does.

00:04:23.580 --> 00:04:26.160
View is what it looks like on screen,
Windows and whatnot.

00:04:26.270 --> 00:04:28.910
And controllers mediate between the two.

00:04:29.920 --> 00:04:33.580
So this is the Objective-C code
for the controller class.

00:04:33.580 --> 00:04:35.600
So we'll compare what this
looks like in various languages.

00:04:35.600 --> 00:04:36.630
Again, this is Objective-C.

00:04:36.640 --> 00:04:39.300
And the three particular
things to notice here are,

00:04:39.450 --> 00:04:40.800
one, the class declaration.

00:04:40.800 --> 00:04:43.020
This being C-based,
it's split into an interface

00:04:43.020 --> 00:04:44.740
part and an implementation part.

00:04:44.740 --> 00:04:46.600
Those would go in separate
files in Objective-C.

00:04:47.340 --> 00:04:50.540
In the interface part,
there are declarations for

00:04:50.540 --> 00:04:53.540
three instance variables,
IB outlets.

00:04:53.540 --> 00:05:00.570
These will get connected to
text fields in the interface.

00:05:00.570 --> 00:05:00.580
So you can see the text fields from code.

00:05:01.020 --> 00:05:02.970
And the third bit is the action method.

00:05:03.000 --> 00:05:04.480
This gets called when
we press the button,

00:05:04.480 --> 00:05:07.890
and this handles the work of getting
the information out of the text fields.

00:05:07.990 --> 00:05:10.380
That's the second and third lines.

00:05:10.530 --> 00:05:14.900
Does the conversion and then puts
the result back into the third field.

00:05:14.900 --> 00:05:19.900
And you might be looking at that
convert amount bit and thinking,

00:05:19.900 --> 00:05:23.380
"Why on earth is he creating an
entire object just to multiply

00:05:23.390 --> 00:05:25.900
two numbers?" Because that's
really all this is going to do.

00:05:25.900 --> 00:05:27.900
This is model-view-controller
separation going on.

00:05:27.900 --> 00:05:29.040
Yes, it's trivial.

00:05:29.040 --> 00:05:32.870
Yes, it's a bit silly at this size,
but it shows separating out the models.

00:05:32.900 --> 00:05:34.900
So that's how the tutorial is written.

00:05:36.600 --> 00:05:38.900
So first off, let's look at Python.

00:05:39.030 --> 00:05:40.810
How does this look in Python?

00:05:40.860 --> 00:05:43.600
The bridge for Python is
originally called PyObjc.

00:05:43.600 --> 00:05:44.430
It's quite old.

00:05:44.440 --> 00:05:46.500
It actually predates Mac OS X.

00:05:46.500 --> 00:05:48.500
In these days, it's built into Leopard.

00:05:48.530 --> 00:05:50.480
It's got full Xcode and
Interface Builder support.

00:05:50.500 --> 00:05:53.490
There are project templates in Xcode.

00:05:53.500 --> 00:05:56.500
Xcode knows how to do syntax
coloring and code folding,

00:05:56.500 --> 00:05:56.500
etc.

00:05:56.500 --> 00:06:00.170
Interface Builder knows how
to read Python files so it

00:06:00.170 --> 00:06:02.500
can auto-fill fields for you.

00:06:02.500 --> 00:06:04.500
There are lots of examples
and developer examples.

00:06:04.710 --> 00:06:06.500
This is what the code looks like.

00:06:06.500 --> 00:06:08.500
Three bits here.

00:06:08.580 --> 00:06:09.460
Here's the class declaration.

00:06:09.490 --> 00:06:10.500
Pretty straightforward.

00:06:10.500 --> 00:06:12.500
It inherits from NSObject.

00:06:12.830 --> 00:06:18.500
Here are our three instance variables.

00:06:18.500 --> 00:06:21.750
The objc_ivar is just a bit of
magic to let the Python interpreter

00:06:21.760 --> 00:06:24.620
know that these need to be
hooked up to Objective-C.

00:06:25.360 --> 00:06:27.690
And finally, the convert method.

00:06:27.950 --> 00:06:30.900
So again, get two values,
do the conversion, put it back.

00:06:30.980 --> 00:06:33.440
Pretty much like the Objective-C version,
but with a little less

00:06:33.470 --> 00:06:35.150
memory management going on.

00:06:36.550 --> 00:06:38.090
Next, Ruby.

00:06:38.100 --> 00:06:39.890
The bridge here is called RubyCocoa.

00:06:39.890 --> 00:06:41.730
It's available as open
source back to Panther.

00:06:41.800 --> 00:06:43.890
Again,
it's built into Leopard these days.

00:06:44.020 --> 00:06:45.810
Again,
full Xcode and interface builder support,

00:06:45.820 --> 00:06:48.000
all the good stuff, lots of examples.

00:06:48.070 --> 00:06:49.720
And the code, again,
looks pretty much the same.

00:06:49.780 --> 00:06:53.900
There's just syntactic differences
thanks to working in Ruby now.

00:06:54.150 --> 00:06:56.100
Here is the class definition.

00:06:56.190 --> 00:06:59.980
Here are the three IB outlet
instance variables.

00:07:00.050 --> 00:07:03.570
And our convert action, again,
the same four lines.

00:07:04.850 --> 00:07:08.950
And finally, we have AppleScript.

00:07:08.990 --> 00:07:11.300
This is called AppleScript Studio.

00:07:11.340 --> 00:07:14.390
It's created back in Panther.

00:07:16.000 --> 00:07:42.400
[Transcript missing]

00:07:42.770 --> 00:07:46.130
And the reason for this is
that Studio just works kind of

00:07:46.140 --> 00:07:47.480
differently from all the others.

00:07:47.500 --> 00:07:49.810
And that actually causes
a bunch of problems.

00:07:49.810 --> 00:07:54.010
The basic point is that
Studio bridges directly to AppKit.

00:07:54.030 --> 00:07:56.770
It doesn't really go
through Objective-C at all.

00:07:57.180 --> 00:08:01.000
There's a lot of things that
are just different in Studio.

00:08:01.000 --> 00:08:03.540
There's a dedicated palette for
Studio in Interface Builder.

00:08:03.540 --> 00:08:05.100
It's only used for Studio.

00:08:05.160 --> 00:08:09.270
When you're using Studio,
you ignore three other panes in Interface

00:08:09.270 --> 00:08:10.820
Builder that you would ordinarily use.

00:08:10.820 --> 00:08:14.700
You, like I mentioned before,
you refer to controls using the

00:08:14.700 --> 00:08:17.290
UI hierarchy instead of using outlets.

00:08:17.360 --> 00:08:19.780
That's kind of a serious problem
because it means that when

00:08:19.780 --> 00:08:23.010
you reorganize your interface,
if you put a control inside a box,

00:08:23.050 --> 00:08:25.700
your hierarchy is changed and now
your code needs to change as well.

00:08:25.700 --> 00:08:29.220
You don't have that problem
in the other languages.

00:08:29.450 --> 00:08:32.560
Actions are referred to not using
target action like you normally do,

00:08:32.630 --> 00:08:35.320
but instead using fixed names that
describe the particular action,

00:08:35.320 --> 00:08:40.470
such as "clicked" or "on scroll
wheel," something like that.

00:08:41.280 --> 00:08:42.040
It goes further, too.

00:08:42.040 --> 00:08:45.120
There's no KVC support,
which means you fundamentally

00:08:45.120 --> 00:08:46.330
can't use outlets.

00:08:46.330 --> 00:08:49.620
And you also can't use Cocoa bindings,
which is a really useful feature

00:08:49.640 --> 00:08:53.480
that lets you save quite a
bit of code in some cases.

00:08:53.680 --> 00:08:56.900
And perhaps most problematic of all,
there's custom glue required

00:08:56.980 --> 00:09:00.430
for every class that you want
to write in AppleScript Studio.

00:09:00.620 --> 00:09:02.050
And we have to provide that glue.

00:09:02.150 --> 00:09:04.840
So what's available in
AppleScript Studio always

00:09:04.880 --> 00:09:07.800
lags behind what's available
to the rest of the system.

00:09:09.620 --> 00:09:11.940
To deal with all this,
we are adding something

00:09:11.940 --> 00:09:13.160
new in Snow Leopard.

00:09:13.170 --> 00:09:15.830
We are taking a big step sideways.

00:09:16.460 --> 00:09:19.090
and introducing a bridge that
we're calling internally,

00:09:19.090 --> 00:09:20.580
at least, AppleScript Objective-C.

00:09:20.580 --> 00:09:22.640
It's just another Cocoa bridge.

00:09:22.640 --> 00:09:23.780
It will be built into Snow Leopard.

00:09:23.780 --> 00:09:27.610
This is a true Objective-C bridge
like the others for Python and Ruby,

00:09:27.610 --> 00:09:31.440
which means that the usual
Objective-C techniques just work.

00:09:31.440 --> 00:09:35.080
You use normal interface builder,
you use outlets, you use bindings.

00:09:35.110 --> 00:09:38.580
Everything is exactly the same as
it is in all the other languages.

00:09:38.580 --> 00:09:39.900
It's exact parity.

00:09:39.950 --> 00:09:42.830
All the normal
Cocoa techniques just work.

00:09:44.030 --> 00:09:50.490
Now, to show this off, I'd like to get
Barry Langdon-Lassagne up here.

00:09:50.900 --> 00:09:54.480
And we will run through
Currency Converter and a few

00:09:54.480 --> 00:09:57.030
other things in AppleScript.

00:09:57.110 --> 00:09:59.060
So if we can switch over
to the demo machine,

00:09:59.060 --> 00:09:59.600
please.

00:09:59.700 --> 00:10:00.640
Hi, Chris.

00:10:00.750 --> 00:10:01.630
Good afternoon, everybody.

00:10:01.770 --> 00:10:05.070
That's not what shows
up on my business card.

00:10:06.660 --> 00:10:09.850
So all of the examples and sample
code we're going to show you,

00:10:09.880 --> 00:10:12.420
this will all work on the version
of Snow Leopard that you guys

00:10:12.420 --> 00:10:13.630
were seated with this week.

00:10:13.720 --> 00:10:16.670
But I'm not sure if the examples
have been uploaded yet to

00:10:16.670 --> 00:10:18.480
the website for this session.

00:10:18.480 --> 00:10:19.240
Real soon now.

00:10:19.240 --> 00:10:20.670
Real soon now, yes.

00:10:20.780 --> 00:10:23.680
So sometime this week,
if they're not already up there.

00:10:25.340 --> 00:10:28.700
Okay, so we're going to continue
on with Currency Converter.

00:10:28.710 --> 00:10:33.640
So if we open the project here,
there we go, and open the script,

00:10:33.640 --> 00:10:35.690
we can see what this looks like.

00:10:36.880 --> 00:10:39.920
So the first thing up at the
top is that mystery model class,

00:10:39.980 --> 00:10:41.300
the MyConverter that
we were seeing before.

00:10:41.300 --> 00:10:43.040
This implementation
should surprise nobody.

00:10:43.040 --> 00:10:44.510
It just multiplies the two numbers.

00:10:44.550 --> 00:10:47.300
The part we're really looking
at is the controller class.

00:10:47.300 --> 00:10:50.320
And now this looks a lot more
like what we were seeing before,

00:10:50.320 --> 00:10:52.510
a lot more like the Objective-C version.

00:10:52.520 --> 00:10:57.570
There is ScriptMyController,
an AppleScript script object appears as a

00:10:57.710 --> 00:11:00.720
class as far as Objective-C is concerned.

00:11:01.350 --> 00:11:08.410
We've got our three properties,
instance variables.

00:11:08.410 --> 00:11:08.410
These are simply initialized
to missing value,

00:11:08.410 --> 00:11:08.410
which is AppleScript's equivalent of nil.

00:11:08.930 --> 00:11:12.630
And finally, we have our convert action,
which is now called convert again,

00:11:12.640 --> 00:11:15.190
and again, the same four lines.

00:11:16.150 --> 00:11:18.780
And if we look at a little
more detail at some of these,

00:11:18.780 --> 00:11:22.680
take the first line,
a simple assignment in AppleScript.

00:11:22.730 --> 00:11:24.580
And in particular,
look at what it's assigning to,

00:11:24.580 --> 00:11:25.770
RateField's float value.

00:11:25.810 --> 00:11:29.340
RateField is a reference
to an Objective-C object,

00:11:29.380 --> 00:11:32.860
and it's going to send it
the float value message.

00:11:33.440 --> 00:11:35.800
And that is simply the
Objective-C selector name,

00:11:35.990 --> 00:11:37.340
float value.

00:11:37.340 --> 00:11:39.390
And because it's just the regular
Objective-C selector name,

00:11:39.400 --> 00:11:43.980
we can just option double click on
it and get the documentation for it.

00:11:47.550 --> 00:11:48.790
We're actually using
the NS Control version.

00:11:48.800 --> 00:11:49.500
Read all about it.

00:11:49.500 --> 00:11:50.330
Lovely.

00:11:50.360 --> 00:11:52.940
There it is.

00:11:52.980 --> 00:11:57.800
And to compare, like I said,
it's the selector name.

00:11:57.970 --> 00:12:01.520
If we look at the last line,
set float value, you'll notice it's set

00:12:01.520 --> 00:12:03.100
float value underscore.

00:12:03.130 --> 00:12:06.120
In Objective-C, the selector name would
have colons in it,

00:12:06.170 --> 00:12:08.870
but colons aren't legal in AppleScript,
so they get turned into

00:12:08.870 --> 00:12:10.210
underscores instead.

00:12:10.320 --> 00:12:14.320
This is the same heuristic that
the Ruby and Python bridges use.

00:12:14.320 --> 00:12:17.400
You take the selector name,
turn the colons into underscores.

00:12:17.480 --> 00:12:21.730
That becomes the function name and the
parameters appear inside parentheses.

00:12:22.300 --> 00:12:36.400
[Transcript missing]

00:12:37.440 --> 00:12:40.290
So that's the code,
which again looks very much like

00:12:40.300 --> 00:12:44.400
the Objective-C code and like the
Python code and like the Ruby code.

00:12:44.400 --> 00:12:47.060
Now we have to hook it
up in Interface Builder.

00:12:50.460 --> 00:12:53.640
We've got the interface
already laid out here,

00:12:53.640 --> 00:12:57.190
and we've got an instance of my
controller already in the Nib.

00:12:57.350 --> 00:13:01.860
We need to actually connect
this to the interface fields.

00:13:01.940 --> 00:13:07.700
So if you pop up the
Connection Inspector,

00:13:07.700 --> 00:13:07.700
this is one of my
favorite features in IB3.

00:13:08.560 --> 00:13:13.200
We can see all the outlets that we have,
which correspond to the properties

00:13:13.330 --> 00:13:16.640
in the script and the action,
which corresponds to the handler.

00:13:16.830 --> 00:13:20.570
So if we wire these up,
connect the outlet field

00:13:20.630 --> 00:13:22.960
to the first text field,

00:13:23.410 --> 00:13:24.300
Second one.

00:13:24.300 --> 00:13:27.700
You've never seen Interface Builder?

00:13:27.700 --> 00:13:29.090
Did you guys just get here?

00:13:32.400 --> 00:13:33.230
That's the third one.

00:13:33.240 --> 00:13:36.480
And finally, the Convert action method
to the Convert button.

00:13:36.680 --> 00:13:38.020
Lovely.

00:13:38.020 --> 00:13:39.820
Save, build, and go.

00:13:44.100 --> 00:13:55.600
[Transcript missing]

00:13:57.050 --> 00:13:58.990
"$1.25, great.

00:13:59.120 --> 00:14:03.350
25 simoleons,
I feel so rich." So there you go,

00:14:03.450 --> 00:14:05.060
that works.

00:14:08.650 --> 00:14:11.420
And the thing to note here is that
this is exactly the same steps

00:14:11.460 --> 00:14:14.720
that we would go through in the
Objective-C tutorial or what we

00:14:14.760 --> 00:14:17.140
would have done in Python or Ruby.

00:14:17.140 --> 00:14:19.350
The interface builder
part is exactly the same.

00:14:19.360 --> 00:14:22.290
It's not different like it
was in AppleScript Studio.

00:14:22.700 --> 00:14:25.250
So how many Studio developers
have we got here?

00:14:25.500 --> 00:14:26.920
A little show of hands?

00:14:26.960 --> 00:14:28.910
Okay, a few people.

00:14:28.930 --> 00:14:30.670
So the Studio developers
may be saying now,

00:14:30.680 --> 00:14:33.850
"Okay, parity, that's nice and all,
but that code was longer than

00:14:33.850 --> 00:14:35.160
what I had to write in Studio.

00:14:35.220 --> 00:14:38.420
I'm not impressed." Fine.

00:14:38.420 --> 00:14:40.700
We have access to all of Cocoa here.

00:14:40.700 --> 00:14:43.630
So let's do the same currency converter,
but this time we're going

00:14:43.630 --> 00:14:44.730
to use Cocoa Bindings.

00:14:44.730 --> 00:14:47.780
Cocoa Bindings is a very nifty
feature which was introduced back

00:14:47.780 --> 00:14:52.160
in Panther that lets Cocoa fill in a
lot of the controller code for you.

00:14:52.160 --> 00:14:54.690
So here's the script that
we have that uses bindings.

00:14:54.710 --> 00:14:56.940
And now it's a lot shorter.

00:14:56.940 --> 00:14:58.300
And this is all model code.

00:14:58.640 --> 00:15:01.870
Notice we still have three properties,
but they're not references

00:15:01.870 --> 00:15:03.310
to text fields anymore.

00:15:03.310 --> 00:15:04.960
They're just the numbers.

00:15:05.100 --> 00:15:15.500
[Transcript missing]

00:15:17.520 --> 00:15:21.380
So let's open the nib and do that.

00:15:21.400 --> 00:15:24.440
So this time,
instead of using the Connections panel,

00:15:24.440 --> 00:15:28.460
we're going to use the
Cocoa Bindings Inspector.

00:15:28.570 --> 00:15:32.260
We've already got our model object,
and we've also got an object controller.

00:15:32.260 --> 00:15:34.720
This is the Cocoa class that
does the controller code,

00:15:34.760 --> 00:15:37.760
which we used to have to write by hand.

00:15:37.860 --> 00:15:41.200
So if we pick the first
one of the text fields,

00:15:42.590 --> 00:15:46.380
We can go to the Bindings pane here
and say this text field gets its value.

00:15:46.570 --> 00:15:53.570
It is bound to the Object Controller and
with a keypath of Amount.

00:15:55.420 --> 00:15:56.500
And now we'll do the same thing.

00:15:56.500 --> 00:15:59.540
The second text field is bound to the
object controller's exchange rate.

00:15:59.540 --> 00:16:03.870
And finally, the last one bound to total.

00:16:04.710 --> 00:16:07.000
And the Connect button will wire
up the same way as we did before,

00:16:07.000 --> 00:16:12.200
connect that to my
model's convert method.

00:16:12.320 --> 00:16:14.390
OK, save, build, and go.

00:16:21.110 --> 00:16:22.030
All right.

00:16:22.090 --> 00:16:24.020
Chris Nebel, Barry Langdon-Lassagne Okay,
same numbers as before, 20 bucks,

00:16:24.020 --> 00:16:28.780
simoleon 25 to the dollar, convert,
and there you go.

00:16:28.780 --> 00:16:33.380
So currency converter now in, I think,
eight lines of code, not bad.

00:16:39.170 --> 00:16:42.850
So now the studio people are saying, OK,
it's shorter,

00:16:42.860 --> 00:16:44.250
but it's still just currency converter.

00:16:44.300 --> 00:16:47.330
Try something hard like a table,
smart guy.

00:16:47.890 --> 00:16:49.240
Let's do that.

00:16:49.240 --> 00:16:49.840
You're in luck.

00:16:49.860 --> 00:16:52.540
I have one right here.

00:16:52.630 --> 00:16:54.190
How astonishing.

00:16:55.650 --> 00:16:57.600
Tables are, of course, very useful.

00:16:57.600 --> 00:16:58.840
Turn up in all sorts of situations.

00:16:58.840 --> 00:17:01.560
They can also be fairly
complicated to code for.

00:17:01.570 --> 00:17:04.510
But Cocoa Bindings makes
it relatively simple.

00:17:04.510 --> 00:17:06.360
Let's take a look at the script.

00:17:06.680 --> 00:17:09.070
Again, Bindings let us write
just the model code.

00:17:09.070 --> 00:17:12.180
What we're doing here is kind
of an address book on the cheap.

00:17:12.180 --> 00:17:14.450
It will be a table of
people -- first name,

00:17:14.450 --> 00:17:15.590
last name, and e-mail.

00:17:15.590 --> 00:17:19.280
And we're using just basic properties
to hold the first name and last name.

00:17:19.440 --> 00:17:22.630
But then for the e-mail property,
we're using a function

00:17:22.660 --> 00:17:24.260
to compute it on the fly.

00:17:24.260 --> 00:17:27.070
We'll mash the first name and last
name together and go fetch the

00:17:27.070 --> 00:17:28.800
e-mail address out of address book.

00:17:28.800 --> 00:17:31.600
This is what AppleScript is good at,
is talking to other applications,

00:17:31.600 --> 00:17:33.110
so it talks to address book.

00:17:33.190 --> 00:17:35.400
And just in case this person
hasn't got an e-mail address,

00:17:35.400 --> 00:17:38.890
it's wrapped in a try block that
will return nothing if it fails.

00:17:40.970 --> 00:17:43.740
So that forms the basic
person model object.

00:17:43.830 --> 00:17:48.030
The other object, my model,
is simply here to hold a list of people.

00:17:48.040 --> 00:17:49.820
That's the people property.

00:17:49.870 --> 00:17:52.550
And we've also got,
mostly to save us typing time,

00:17:52.620 --> 00:17:53.730
an awake from nib method.

00:17:53.740 --> 00:17:58.620
This will get called automatically
by Cocoa when we load the nib.

00:17:59.790 --> 00:18:02.780
And again, it's just got straight
AppleScript in it as well.

00:18:02.990 --> 00:18:04.280
Yep.

00:18:04.280 --> 00:18:05.130
OK.

00:18:05.230 --> 00:18:07.750
So this will simply grab some
people out of Address Book to

00:18:07.820 --> 00:18:09.540
populate the table for us,
so we get to see

00:18:09.540 --> 00:18:10.580
something when we launch.

00:18:10.630 --> 00:18:13.010
Everything else happens
in Interface Builder.

00:18:15.560 --> 00:18:21.230
So we've got the table already laid out,
and we've got my model instance there.

00:18:21.350 --> 00:18:23.940
The first thing we need
is an array controller.

00:18:24.250 --> 00:18:26.960
We saw an object controller before.

00:18:26.970 --> 00:18:30.580
Cocoa also has a class to
manage an array of objects.

00:18:30.580 --> 00:18:33.640
So the first thing we need to tell
the array is what it's an array of.

00:18:33.640 --> 00:18:36.160
So if we go to the

00:18:36.920 --> 00:18:42.060
You can tell it's going to be
managing an array of class MyPerson,

00:18:42.060 --> 00:18:45.310
which matches the script
object that we defined first.

00:18:45.630 --> 00:18:48.010
And we fill in the keys we're
going to be interested in.

00:18:48.180 --> 00:18:50.680
This isn't strictly necessary,
but it saves us some typing later.

00:18:50.790 --> 00:18:56.170
So first name, last name, and email.

00:18:56.260 --> 00:18:57.420
Great.

00:18:57.530 --> 00:18:59.480
So now we bind that array controller.

00:18:59.500 --> 00:19:00.670
Where is it going to get its array from?

00:19:00.740 --> 00:19:02.180
We bind that array controller.

00:19:02.250 --> 00:19:04.440
Switch to the Bindings pane.

00:19:06.240 --> 00:19:12.110
And we bind the content
array to my model.

00:19:12.480 --> 00:19:16.630
And the people key,
which matches that people

00:19:16.920 --> 00:19:19.750
property in the script.

00:19:20.860 --> 00:19:22.850
Okay, so now the array controller
knows about the model.

00:19:22.940 --> 00:19:25.800
Now we have to teach the table
about the array controller.

00:19:25.800 --> 00:19:27.690
So we do this one column at a time.

00:19:27.810 --> 00:19:32.200
Take the first column,
and its value is going to be bound to

00:19:32.200 --> 00:19:36.790
the array controller and its first name,
keypath.

00:19:37.840 --> 00:19:40.340
"Second column, similar,
bind to the array controller,

00:19:40.340 --> 00:19:42.360
and this goes to the last name.

00:19:42.390 --> 00:19:45.110
And last column, email.

00:19:45.150 --> 00:19:47.800
And the fact that email is really
a function makes no difference

00:19:47.820 --> 00:19:48.860
as far as Cocoa is concerned.

00:19:48.880 --> 00:19:51.800
It doesn't distinguish between
a plain property and a function

00:19:51.800 --> 00:19:52.770
that takes no arguments."

00:19:54.500 --> 00:20:12.100
[Transcript missing]

00:20:15.160 --> 00:20:16.200
And there it is.

00:20:16.540 --> 00:20:18.130
It's already populated
out of our address book.

00:20:18.160 --> 00:20:19.330
It's fetching the email.

00:20:19.410 --> 00:20:22.710
If we click the plus button,
we'll get a new row.

00:20:31.410 --> 00:20:34.140
And that in, you know,
about a page worth of code.

00:20:34.170 --> 00:20:34.960
Not bad.

00:20:35.050 --> 00:20:37.120
And ArrayController gets us
some extra behavior for free,

00:20:37.120 --> 00:20:38.290
like sorting of columns.

00:20:38.330 --> 00:20:39.760
We didn't have to write
any code to do that.

00:20:39.900 --> 00:20:42.750
And it gets us some
additional behavior as well.

00:20:43.360 --> 00:20:46.220
Let's take this one step further and do
something you really can't do in Studio.

00:20:46.310 --> 00:20:48.480
We're going to add a search field.

00:20:51.980 --> 00:20:55.340
We've never added Glue for
NSSearchField in Studio,

00:20:55.340 --> 00:20:58.620
but hey, this is just Cocoa,
so we can do a search field.

00:20:58.690 --> 00:21:04.250
So the first step, obviously,
is add a search field to the interface.

00:21:04.330 --> 00:21:06.100
Drag that in.

00:21:09.640 --> 00:21:13.030
And NSArrayController is so cool
that we're not going to have to

00:21:13.030 --> 00:21:14.300
write any code to hook this up.

00:21:14.300 --> 00:21:16.900
We're not going to have to
add anything to our script.

00:21:17.030 --> 00:21:18.940
All this happens using bindings.

00:21:19.050 --> 00:21:23.340
If we scroll down a bit,
we get to the Predicates section.

00:21:23.470 --> 00:21:29.330
Search fields and array controllers know
about each other through predicates.

00:21:29.850 --> 00:21:36.090
So we bind this to the array
controller and the predicate field.

00:21:36.120 --> 00:21:39.020
Admittedly, this is a little code-like,
but the syntax is all

00:21:39.020 --> 00:21:40.600
documented in NSPredicate.

00:21:40.650 --> 00:21:42.680
We need first name contains dollar value.

00:21:42.710 --> 00:21:45.940
Dollar value is simply whatever's
been typed into the search field.

00:21:45.990 --> 00:21:48.740
Or last name contains value.

00:21:49.990 --> 00:21:52.140
We don't want to annoy
people with case sensitivity,

00:21:52.140 --> 00:21:56.900
so we'll put a little qualifier
on the contains operator there.

00:21:56.900 --> 00:22:00.900
Cd means not case sensitive,
not diacritic sensitive either.

00:22:03.400 --> 00:22:03.730
And that's it.

00:22:03.810 --> 00:22:05.300
This is all done in the Nib.

00:22:05.330 --> 00:22:12.390
If we build and run,
we should get our same table as before

00:22:12.470 --> 00:22:18.380
and happily filter down to Larson.

00:22:18.380 --> 00:22:18.740
Pretty simple.

00:22:18.740 --> 00:22:22.930
It works.

00:22:22.940 --> 00:22:24.160
Okay.

00:22:24.260 --> 00:22:26.010
Thank

00:22:31.100 --> 00:22:37.460
Back to slides, please.

00:22:37.460 --> 00:22:39.340
So, summing up for Cocoa Bridges.

00:22:39.340 --> 00:22:42.230
The basic point here is that you can
choose the language that works for you.

00:22:42.240 --> 00:22:45.030
You are not obliged to use Objective-C,
you are not obliged to use Python,

00:22:45.030 --> 00:22:47.100
you are not obliged to use Ruby,
or whatever.

00:22:47.110 --> 00:22:53.390
Whatever it is that is
right for your project,

00:22:53.390 --> 00:22:53.940
your personal preferences, whatever.

00:22:53.940 --> 00:22:53.940
It's okay.

00:22:56.240 --> 00:22:59.420
Bridge languages work great
for casual development,

00:22:59.420 --> 00:23:00.740
in-house development, even shrink wrap.

00:23:00.830 --> 00:23:02.840
There are people shipping
shrink wrap applications that

00:23:02.870 --> 00:23:04.040
are actually built in Python.

00:23:04.090 --> 00:23:05.590
And it's awesome for experimenting.

00:23:05.590 --> 00:23:09.350
One of the great things about using an
interpreted language to run Cocoa is

00:23:09.350 --> 00:23:11.180
that you often have an interpreter.

00:23:11.180 --> 00:23:12.740
You can just type a line
and see what happens.

00:23:12.740 --> 00:23:15.780
It's my favorite way to experiment
with new frameworks now.

00:23:16.200 --> 00:23:18.470
The three that we've mentioned, Python,
Ruby, and AppleScript,

00:23:18.520 --> 00:23:20.060
those are the ones that
are built into the system,

00:23:20.100 --> 00:23:22.930
but there are others besides,
typically available as open source.

00:23:22.940 --> 00:23:26.020
There are bridges for Perl,
there's a bridge for Lua, Common Lisp,

00:23:26.130 --> 00:23:27.640
there are a couple of
dedicated languages,

00:23:27.690 --> 00:23:29.640
Fscript and GNU,
which is kind of a scheme dialect.

00:23:29.710 --> 00:23:31.820
Probably a bunch more
I don't even know about.

00:23:31.840 --> 00:23:34.170
So, awesome stuff.

00:23:34.170 --> 00:23:35.550
Try it out.

00:23:37.560 --> 00:23:39.500
So that's Cocoa Bridging.

00:23:39.640 --> 00:23:42.360
Now let's talk about
bridging to services,

00:23:42.430 --> 00:23:45.810
specifically bridging to
scriptable applications.

00:23:46.330 --> 00:23:49.410
Scriptable applications have been
around in Mac OS for a long time.

00:23:49.430 --> 00:23:51.900
They actually date back to Mac OS 7.

00:23:51.900 --> 00:23:53.260
If you are writing an
application yourself,

00:23:53.330 --> 00:23:54.900
we highly encourage you
to make it scriptable.

00:23:54.950 --> 00:23:58.040
There's a session tomorrow at 2
o'clock on doing precisely that.

00:23:58.160 --> 00:24:01.330
I believe it's called
Making Your Application Scriptable.

00:24:01.500 --> 00:24:04.900
And the traditional way you
control a scriptable application,

00:24:04.900 --> 00:24:06.970
or at least the historic way,
is by using AppleScript.

00:24:07.060 --> 00:24:10.240
AppleScript was designed specifically
to talk to scriptable applications.

00:24:10.300 --> 00:24:12.150
It's very good at it.

00:24:12.690 --> 00:24:14.560
But you're a real developer.

00:24:14.560 --> 00:24:17.100
You're writing a real
application in Objective-C.

00:24:17.270 --> 00:24:18.890
How do you do this?

00:24:19.080 --> 00:24:21.940
There's nothing really magical
about NSAppleScript that lets you

00:24:21.940 --> 00:24:23.600
control scriptable applications.

00:24:23.600 --> 00:24:26.500
All it's really doing behind the scenes
is it's constructing Apple Events,

00:24:26.500 --> 00:24:30.120
a kind of IPC protocol,
a little remote message send.

00:24:30.240 --> 00:24:33.860
And that's what iTunes is
really paying attention to.

00:24:33.860 --> 00:24:38.000
And Apple Events have a plain C API,
so really anyone can use them.

00:24:40.290 --> 00:24:45.710
And there's even an Objective-C wrapper
for Apple Events called

00:24:45.710 --> 00:24:47.260
NSAppleEventDescriptor.

00:24:47.260 --> 00:24:49.270
So if you code using these,
then this is basically

00:24:49.600 --> 00:24:51.320
as efficient as possible.

00:24:51.320 --> 00:24:53.620
You're not taking any of the overhead
for the AppleScript interpreter.

00:24:53.620 --> 00:24:54.960
It's just the message sends.

00:24:54.970 --> 00:24:56.360
So very fast, very efficient.

00:24:56.500 --> 00:25:01.270
Say you want to get the name of the
currently playing track in iTunes.

00:25:01.280 --> 00:25:02.560
You know, lots of applications.

00:25:02.560 --> 00:25:05.030
The basic point of using a
scriptable application is that you

00:25:05.030 --> 00:25:07.450
can leverage other applications,
right?

00:25:07.490 --> 00:25:10.340
You can get them to do features for you.

00:25:10.340 --> 00:25:13.080
So an iTunes controller is
a fairly common example.

00:25:13.150 --> 00:25:15.800
Say you want to get the name of the
currently playing track in iTunes.

00:25:15.800 --> 00:25:17.700
NSAppleEventDescriptor, great.

00:25:17.720 --> 00:25:19.360
All you have to write is this.

00:25:20.460 --> 00:25:25.500
So what people actually do
is they write an AppleScript.

00:25:25.550 --> 00:25:27.520
And they run it from within
their application using

00:25:27.520 --> 00:25:29.090
the NSAppleScript class.

00:25:29.160 --> 00:25:30.800
So it's obviously a lot simpler to write.

00:25:30.980 --> 00:25:33.390
The thing is it doesn't work very well.

00:25:33.740 --> 00:25:36.200
Because now you are taking the hit
for the AppleScript interpreter.

00:25:36.250 --> 00:25:40.720
So you impose a bunch of extra time,
use a bunch of extra memory.

00:25:40.750 --> 00:25:42.700
It doesn't integrate all
that well with Objective-C.

00:25:42.700 --> 00:25:44.800
What we really want is just
an NSString eventually,

00:25:44.800 --> 00:25:46.520
but that's not what we
get out of NSAppleScript.

00:25:46.580 --> 00:25:48.860
We get something else,
actually another NSApple

00:25:48.910 --> 00:25:51.870
event descriptor,
from which we have to extract a string.

00:25:52.480 --> 00:25:57.000
So what we'd really like is something
that is simple to use like NSAppleScript,

00:25:57.010 --> 00:25:59.620
ideally even simpler,
and yet has the performance

00:25:59.650 --> 00:26:01.990
of NSAppleEventDescriptor.

00:26:04.390 --> 00:26:06.060
And that's what Scripting
Bridge is all about.

00:26:06.090 --> 00:26:10.980
Except this was introduced in Leopard,
and we're not calling it

00:26:10.990 --> 00:26:11.920
Scripting Bridge anymore.

00:26:12.000 --> 00:26:14.920
Scripting Bridge was a fine name as
long as we always thought scripting

00:26:14.920 --> 00:26:17.240
meant application scripting,
which it kind of used to,

00:26:17.240 --> 00:26:19.780
but obviously we're using
scripting for a lot more now,

00:26:19.790 --> 00:26:21.190
a lot of different things.

00:26:21.480 --> 00:26:23.630
So,
Scripting Bridge was a bit too confusing.

00:26:23.640 --> 00:26:25.290
We're naming it a bit
more specifically now.

00:26:25.340 --> 00:26:26.880
It's the Apple Event Bridge.

00:26:26.920 --> 00:26:30.160
I'm probably going to screw this
up at least once while I'm talking.

00:26:30.160 --> 00:26:31.400
Bear with me.

00:26:31.410 --> 00:26:33.360
So, here's what it looks like.

00:26:33.990 --> 00:26:36.660
First step is you generate
a header for the application

00:26:36.660 --> 00:26:38.860
that you're interested in,
in this case, iTunes.

00:26:38.860 --> 00:26:42.020
So this defines a bunch of classes.

00:26:42.500 --> 00:27:02.200
[Transcript missing]

00:27:02.650 --> 00:27:07.360
And if you happen to like Objective-C 2,
the property .syntax

00:27:07.410 --> 00:27:08.270
works great with that too.

00:27:08.560 --> 00:27:11.300
Even saves you two more characters.

00:27:12.660 --> 00:27:16.030
And because this is simply
an Objective-C Cocoa service,

00:27:16.050 --> 00:27:19.320
it works with bridged languages as well,
except that you don't have to

00:27:19.330 --> 00:27:21.820
bother with the first two steps,
because you don't really need a

00:27:21.820 --> 00:27:23.400
header and there's no link phase.

00:27:23.400 --> 00:27:26.240
Here's what the same code
looks like in Python.

00:27:26.240 --> 00:27:28.640
Again, get a reference to iTunes.

00:27:28.700 --> 00:27:32.440
Print iTunes current track name.

00:27:32.500 --> 00:27:34.990
And same thing again in Ruby.

00:27:38.210 --> 00:27:40.580
And to show off something
a bit more complicated,

00:27:40.680 --> 00:27:44.690
if I can get Barry back up here,
we'll do another demo.

00:27:46.520 --> 00:27:49.810
So one of our evangelists
had an interesting problem,

00:27:49.850 --> 00:27:54.270
that he's got his home stereo
hooked up to his iTunes library.

00:27:55.200 --> 00:27:57.500
The thing is that the standard
infrared remote doesn't

00:27:57.510 --> 00:27:59.540
really work very well for him,
because he's frequently

00:27:59.540 --> 00:28:00.200
out of line of sight.

00:28:00.250 --> 00:28:02.440
He's actually got speakers in lots
of different rooms of his house.

00:28:02.440 --> 00:28:05.310
He's got speakers in the living room,
he's got speakers in the den,

00:28:05.310 --> 00:28:08.690
speakers in the backyard by the jacuzzi,
speakers underwater in the jacuzzi,

00:28:08.700 --> 00:28:09.350
whatever.

00:28:09.400 --> 00:28:11.600
In the basement with the bowling alley.

00:28:11.800 --> 00:28:13.400
Yeah, that too.

00:28:13.410 --> 00:28:15.380
Is Matt here?

00:28:18.400 --> 00:28:34.700
[Transcript missing]

00:28:35.000 --> 00:28:39.830
He happens to know Ruby,
and Ruby has a nice package that lets

00:28:39.860 --> 00:28:42.380
you write quick and dirty web servers.

00:28:42.500 --> 00:28:44.000
So here's what some of
the code looks like.

00:28:44.000 --> 00:28:47.240
So the web server package
is called Mongrel.

00:28:47.450 --> 00:28:50.630
So it uses Mongrel on one end to
do all the webby kind of stuff.

00:28:50.720 --> 00:28:52.880
And then it uses Scripting Bridge,
Apple Event Bridge,

00:28:52.880 --> 00:28:56.450
on the other side to talk to iTunes.

00:28:57.540 --> 00:28:58.310
There.

00:28:58.420 --> 00:29:00.040
Yeah, we'll have to fix that in
the online version too.

00:29:00.040 --> 00:29:05.640
It's spelt Scripting Bridge,
it's pronounced Apple Event Bridge.

00:29:10.670 --> 00:29:14.550
So there's the includes.

00:29:14.570 --> 00:29:17.370
One of the first things it does
as part of its initialization is

00:29:17.370 --> 00:29:21.470
it gets a reference to iTunes,
similar to what we saw on the slides.

00:29:21.730 --> 00:29:24.140
And then the various controls
on the web page that it presents

00:29:24.210 --> 00:29:26.130
are hooked up to iTunes actions.

00:29:26.130 --> 00:29:30.470
So, for instance,
here is the next button handler that when

00:29:30.480 --> 00:29:33.720
you push the next button on the web page,
it simply tells iTunes,

00:29:33.720 --> 00:29:34.640
go to the next track.

00:29:34.670 --> 00:29:38.230
And if you're not already playing,
then start playing.

00:29:39.200 --> 00:29:41.770
and there's even some eye
candy features in here.

00:29:41.880 --> 00:29:45.080
There's a bit to go fetch the
album artwork from iTunes,

00:29:45.090 --> 00:29:48.540
turn it into a JPEG and stick
that as part of the web page.

00:29:50.010 --> 00:29:52.540
So let's see how this works.

00:29:52.540 --> 00:29:54.440
I believe we have the
server already fired up.

00:29:54.440 --> 00:29:55.390
Yep, it's running.

00:29:55.400 --> 00:29:56.280
OK.

00:29:56.300 --> 00:29:58.380
And we don't have an
iPhone projector here,

00:29:58.380 --> 00:30:01.130
so we're actually going to
use the simulator for this.

00:30:01.170 --> 00:30:03.590
If we go to Safari--

00:30:05.930 --> 00:30:06.800
Here's our web page.

00:30:06.800 --> 00:30:07.560
Press play to start iTunes.

00:30:07.560 --> 00:30:10.680
Let's do that.

00:30:10.740 --> 00:30:15.970
iTunes launches and starts playing.

00:30:17.100 --> 00:30:34.100
[Transcript missing]

00:30:36.070 --> 00:30:38.480
We can pause that.

00:30:38.520 --> 00:30:40.850
If we skip to the next track,
it starts playing like

00:30:40.850 --> 00:30:42.070
we saw in the code.

00:30:43.530 --> 00:30:45.000
I absolutely love this song.

00:30:45.000 --> 00:30:46.700
It's actually by a couple
of old friends of mine,

00:30:46.780 --> 00:30:49.330
but we do not have time to
listen to the whole thing,

00:30:49.330 --> 00:30:50.320
so pause again.

00:30:50.360 --> 00:30:53.060
But it is available on iTunes.

00:30:53.060 --> 00:30:55.820
Okay, thank you very much.

00:30:55.900 --> 00:31:01.090
Oh, I think -- Oh, wait,
do we have one more thing?

00:31:02.940 --> 00:31:05.260
I have to try this to
see if it works for real,

00:31:05.260 --> 00:31:08.570
if I really can use this as a remote.

00:31:08.610 --> 00:31:10.880
We'll see.

00:31:10.950 --> 00:31:14.560
This is the part where I need demo gods.

00:31:14.650 --> 00:31:16.700
Can you hear it?

00:31:16.760 --> 00:31:18.380
Next song.

00:31:19.400 --> 00:31:32.000
[Transcript missing]

00:31:38.080 --> 00:31:38.960
So Apple Event Bridge.

00:31:39.160 --> 00:31:40.960
Like I said,
the basic point here is make other

00:31:40.960 --> 00:31:42.680
applications do your work for you.

00:31:42.680 --> 00:31:45.520
If you need to send mail to something,
send an attachment,

00:31:45.520 --> 00:31:46.850
you can tell mail to do that.

00:31:46.980 --> 00:31:49.470
You need to file a photo,
tell iPhoto to do that.

00:31:49.570 --> 00:31:52.560
There are entire applications
that have been built on top of

00:31:52.680 --> 00:31:57.450
Excel or OmniGraffle or OmniOutline,
which is effectively a display engine.

00:31:58.780 --> 00:32:00.560
And if you're going to do this,
if you're going to script

00:32:00.620 --> 00:32:02.700
other applications,
do it efficiently.

00:32:02.700 --> 00:32:06.010
If you're using built-in logic,
use Apple Event Bridge.

00:32:06.040 --> 00:32:08.180
This is the fast way to do this.

00:32:08.330 --> 00:32:10.800
NSAppleScript still has its place,
but its place is for running

00:32:10.800 --> 00:32:12.670
user-supplied scripts,
stuff that is not built

00:32:12.680 --> 00:32:13.640
into your application.

00:32:13.680 --> 00:32:16.480
You don't know what it is at build time.

00:32:16.550 --> 00:32:19.690
If it's built into your application,
use the Apple Event Bridge.

00:32:23.700 --> 00:32:28.500
So how the heck does all this stuff work?

00:32:28.560 --> 00:32:32.120
So the basic game with all of these is
that you've got two different runtimes,

00:32:32.220 --> 00:32:34.600
which are not inherently compatible.

00:32:36.750 --> 00:32:43.610
The game is to make each side think that
it's talking to more stuff just like it.

00:32:43.640 --> 00:32:46.830
Nobody here but us chickens.

00:32:47.720 --> 00:32:52.600
So Cocoa objects know how to
send Objective-C messages.

00:32:52.650 --> 00:32:54.700
Python does not understand Objective-C.

00:32:54.840 --> 00:32:56.080
This is where the Cocoa Bridge comes in.

00:32:56.160 --> 00:33:01.740
The Cocoa Bridge will create these little
shells of Objective-C around the object.

00:33:01.740 --> 00:33:03.530
So from the outside,
they look like Objective-C.

00:33:03.550 --> 00:33:04.720
In reality, the message hits this.

00:33:04.720 --> 00:33:07.720
It gets translated into something
that Python can understand.

00:33:07.720 --> 00:33:11.790
And then going the other way,

00:33:13.550 --> 00:33:15.380
It's basically the same thing.

00:33:15.590 --> 00:33:19.740
The Cocoa objects get wrapped in
these crunchy little Python shells.

00:33:19.740 --> 00:33:21.480
So they look like Python objects,
but they're really not.

00:33:21.610 --> 00:33:24.370
The message gets
translated again going in.

00:33:25.860 --> 00:33:29.640
So this presumes a fair
amount of introspectability

00:33:29.640 --> 00:33:33.040
and dynamism in your runtime,
which fortunately Objective-C has,

00:33:33.040 --> 00:33:36.100
and so do a lot of the
scripting languages.

00:33:38.120 --> 00:33:41.600
So there are four basic
capabilities that you need.

00:33:41.650 --> 00:33:45.800
And it all comes down to inspecting
existing stuff and creating new things.

00:33:45.800 --> 00:33:47.150
So you need to be able
to do this to classes.

00:33:47.230 --> 00:33:49.840
You need to be able to get a
list of all the classes that are

00:33:49.850 --> 00:33:51.340
currently defined in the runtime.

00:33:51.340 --> 00:33:56.500
The Objective-C interface for most of
this is defined in Objective-C runtime.h.

00:33:56.500 --> 00:33:58.510
So, for instance,
getting a list of classes,

00:33:58.590 --> 00:34:00.340
you use Objective-C get class list.

00:34:00.340 --> 00:34:02.510
So you can find out what
all the classes are.

00:34:02.520 --> 00:34:07.900
And then you need to construct
those shells for the Python objects.

00:34:08.020 --> 00:34:12.550
You can create new classes in the
runtime just on the fly using allocate

00:34:12.680 --> 00:34:16.070
class pair and register class pair.

00:34:17.730 --> 00:34:20.590
So then when it comes time
to actually send messages,

00:34:20.660 --> 00:34:22.160
it's the same kind of idea.

00:34:22.160 --> 00:34:25.200
You need to be able to grab
a message and pick it apart.

00:34:25.340 --> 00:34:27.550
What's the message exactly?

00:34:27.620 --> 00:34:28.400
What are its parameters?

00:34:28.410 --> 00:34:30.200
Where is it going?

00:34:30.990 --> 00:34:33.680
and then be able to pass
it on to something else.

00:34:34.030 --> 00:34:36.960
The basic mechanism for
this is forward invocation.

00:34:36.960 --> 00:34:39.840
This is the message
forwarding system in Cocoa,

00:34:39.840 --> 00:34:42.650
and it's actually used for lots of stuff,
not the least of which is NSProxy,

00:34:42.650 --> 00:34:45.570
which things like distributed
objects are based on.

00:34:45.580 --> 00:34:48.940
Core Data also uses this
kind of technique heavily.

00:34:50.950 --> 00:34:54.650
And you can even go one step
further in Tiger and actually create

00:34:54.650 --> 00:34:56.210
method implementations on the fly.

00:34:56.300 --> 00:35:00.130
There's a library called libffi,
it's short for

00:35:00.130 --> 00:35:03.670
Foreign Function Interface,
that lets you construct

00:35:04.360 --> 00:35:07.640
arbitrary C functions on the fly.

00:35:07.680 --> 00:35:09.920
They just look like regular
C function pointers,

00:35:09.920 --> 00:35:11.420
you can call them just
like anything else.

00:35:11.460 --> 00:35:13.580
And you can plug those into the object.

00:35:13.640 --> 00:35:17.710
So you call this method,
it just turns into this function call.

00:35:18.920 --> 00:35:22.010
And finally, you need to be able to
create new messages that,

00:35:22.030 --> 00:35:23.790
okay, I got this Python thing coming in.

00:35:23.800 --> 00:35:25.800
I need to turn that into
an Objective-C message.

00:35:25.800 --> 00:35:28.800
There's an Objective-C interface
for doing this called NSInvocation.

00:35:28.800 --> 00:35:30.790
That's kind of a nice high-level version.

00:35:30.900 --> 00:35:34.790
Or you can go the grungy low-level
route with ObjcMessageSend.

00:35:38.030 --> 00:35:41.700
So there's some interesting things you're
going to run into if you try to do this.

00:35:41.700 --> 00:35:46.190
One is that Cocoa has a bunch of sort
of object machinery that it deals with,

00:35:46.190 --> 00:35:49.970
which, say, the Python code is not
really expected to deal with.

00:35:49.970 --> 00:35:53.670
This is stuff like message forwarding,
so messages like response to selector,

00:35:53.790 --> 00:35:55.830
key value coding,
so you can get things like

00:35:55.830 --> 00:35:58.550
value for undefined key,
key value observation,

00:35:58.550 --> 00:36:02.500
which bindings is based on,
things like will change value for key.

00:36:02.500 --> 00:36:05.840
So your bridge is going to need to pick
these up and handle them appropriately,

00:36:05.840 --> 00:36:08.470
like there's stuff in the
AppleScript bridge to pick up value

00:36:08.470 --> 00:36:12.680
for undefined key and turn that
into an AppleScript property access.

00:36:13.690 --> 00:36:15.720
The next thing is that the
type information in the

00:36:15.720 --> 00:36:16.900
runtime may not be enough.

00:36:17.080 --> 00:36:20.600
The Objective-C runtime has a fairly
C-ish view of the runtime system.

00:36:20.740 --> 00:36:22.940
So, for instance, Boolean.

00:36:23.010 --> 00:36:26.800
As far as Objective-C is concerned,
bool is just a typedef for signed char.

00:36:26.800 --> 00:36:27.940
It's just another integral type.

00:36:27.940 --> 00:36:30.100
And that's not good
enough for some languages.

00:36:30.100 --> 00:36:32.360
Like in Ruby,
all integers are considered true.

00:36:32.360 --> 00:36:36.080
There's none of this C, zero is false,
everything else is true business.

00:36:37.160 --> 00:36:38.810
Fortunately, there's metadata available.

00:36:38.890 --> 00:36:42.380
There are bridge support files in
every system framework that describe

00:36:42.470 --> 00:36:44.790
full metadata for all the APIs.

00:36:44.880 --> 00:36:47.620
So you can find out that, oh,
this really was a Boolean here.

00:36:47.620 --> 00:36:49.040
This is an object pointer.

00:36:49.040 --> 00:36:50.380
What is an object pointer to?

00:36:50.380 --> 00:36:51.990
You can get an exact type.

00:36:51.990 --> 00:36:54.870
The Objective-C runtime
won't tell you that.

00:36:56.410 --> 00:36:59.900
Next up, we talked about forward
invocation a little bit.

00:36:59.900 --> 00:37:01.540
So you can do this
dynamically all the time,

00:37:01.540 --> 00:37:05.420
but that can get slow if you're
sending an awful lot of messages.

00:37:05.550 --> 00:37:07.340
So this is where libffi comes in.

00:37:07.440 --> 00:37:11.170
If you get a message once,
you can do it dynamically the first time,

00:37:11.170 --> 00:37:15.420
but then construct a real method
implementation using libffi.

00:37:15.420 --> 00:37:19.100
And from that point on,
that particular method can be fast.

00:37:19.100 --> 00:37:21.600
Core Data, I believe,
uses this technique now

00:37:21.600 --> 00:37:23.110
to improve performance.

00:37:25.420 --> 00:37:27.300
And finally, this one is a little tricky.

00:37:28.340 --> 00:37:34.020
Obviously,
Cocoa has a whole set of basic types,

00:37:34.040 --> 00:37:35.550
strings, arrays, that sort of thing.

00:37:35.760 --> 00:37:37.900
Your scripting language probably
has most of these same types.

00:37:37.930 --> 00:37:39.460
It definitely has a string.

00:37:39.610 --> 00:37:43.820
And it's kind of nice if NSString turns
into just a regular scripting string,

00:37:43.820 --> 00:37:48.530
so that way the scripting users don't
have to think of NSStrings as NSStrings.

00:37:49.680 --> 00:37:52.700
What you can do,
and this presumes a lot of

00:37:52.700 --> 00:37:55.560
control over the interpreter,
is you can actually build the

00:37:55.620 --> 00:37:57.140
interpreter on top of foundations.

00:37:57.160 --> 00:37:59.380
So the scripting string
just is an NSString.

00:37:59.390 --> 00:38:02.360
There's a project called Mac Ruby,
you can go check this

00:38:02.370 --> 00:38:05.320
out on Mac OS Forge,
which is doing precisely this with Ruby.

00:38:05.320 --> 00:38:07.040
It's basing Ruby on top of foundation.

00:38:07.040 --> 00:38:09.130
So a Ruby string is an NSString.

00:38:09.160 --> 00:38:10.840
A Ruby array is an NSArray.

00:38:10.840 --> 00:38:13.770
It even goes one step further and
uses Objective-C messaging for

00:38:13.770 --> 00:38:15.380
all the Ruby messaging as well.

00:38:15.400 --> 00:38:17.550
So all the bridging overhead,
it just goes away.

00:38:18.930 --> 00:38:21.910
So it's extremely efficient.

00:38:26.030 --> 00:38:28.450
Now, not surprisingly,
this is considered an advanced topic.

00:38:28.450 --> 00:38:30.500
This is not for everybody.

00:38:30.540 --> 00:38:34.030
That said, it is all public API,
and it is all documented.

00:38:34.160 --> 00:38:36.760
There's no magic secret
sauce that only we know.

00:38:36.760 --> 00:38:37.880
Anyone can do this.

00:38:37.910 --> 00:38:41.490
And a lot of the bridges are open source,
so you can go look at how

00:38:41.490 --> 00:38:43.170
other people have done this.

00:38:43.640 --> 00:38:46.400
If you're interested in bridging to
some language that isn't on this list,

00:38:46.440 --> 00:38:48.400
by all means, come and talk to us.

00:38:48.400 --> 00:38:50.710
We can help out,
and we'd just like to know that you exist

00:38:50.710 --> 00:38:52.490
so we can tell other people about it.

00:38:55.880 --> 00:38:58.560
Summing up the whole thing,
if you're developing a

00:38:58.560 --> 00:39:01.040
Mac OS X application,
you've got the next killer app,

00:39:01.040 --> 00:39:02.970
you're just burning to write,
write using Cocoa.

00:39:03.050 --> 00:39:04.400
This is where all of our attention goes.

00:39:04.430 --> 00:39:05.810
This is where all the good stuff is.

00:39:05.840 --> 00:39:09.390
This is where you get all
the good system services.

00:39:09.770 --> 00:39:13.760
That said, write the code using the
language that works for you.

00:39:13.760 --> 00:39:16.850
Objective-C, Python, Ruby, it's all good.

00:39:17.150 --> 00:39:22.100
We are not in the business of
dictating what language you should use.

00:39:26.040 --> 00:39:27.190
I should actually qualify that.

00:39:27.200 --> 00:39:29.800
I forgot to do this earlier.

00:39:29.830 --> 00:39:31.680
I said you can write whatever
language works for you.

00:39:31.680 --> 00:39:35.700
That said, we do still recommend that you
learn Objective-C and ideally

00:39:35.700 --> 00:39:37.490
that you learn it first.

00:39:37.490 --> 00:39:40.000
There are two big reasons for this.

00:39:40.000 --> 00:39:44.050
One is that all of the documentation
and a lot of the sample code

00:39:44.070 --> 00:39:47.110
is written in Objective-C and
you'd like to be able to read

00:39:48.060 --> 00:39:50.520
The other reason is a bit more subtle.

00:39:50.630 --> 00:39:53.090
Cocoa was designed as
an Objective-C library.

00:39:53.090 --> 00:39:56.860
It was not designed as a Python library
or a Ruby library or what have you.

00:39:56.980 --> 00:39:59.140
And therefore,
it is following its own conventions.

00:39:59.140 --> 00:40:03.320
It is not following the languages
of your favorite scripting language.

00:40:03.860 --> 00:40:08.480
So if you expect it to behave
as if it's a native library,

00:40:08.640 --> 00:40:11.150
you're just kind of setting
yourself up for pain.

00:40:11.790 --> 00:40:16.340
A lot of people can, in fact,
learn both of these at the same time.

00:40:16.340 --> 00:40:19.090
They can pick these apart,
keep them separate in their brains.

00:40:19.210 --> 00:40:21.160
Some people can't.

00:40:21.270 --> 00:40:22.390
Your mileage may vary.

00:40:22.470 --> 00:40:24.430
Consider yourself warned.

00:40:27.130 --> 00:40:30.840
You can extend your application
using scriptable applications.

00:40:30.840 --> 00:40:33.720
Make other applications
do your work for you.

00:40:34.280 --> 00:40:37.550
Like I said, use Mail to send mail,
iPhoto to file pictures,

00:40:37.710 --> 00:40:41.340
use Excel to create charts for you,
et cetera.

00:40:41.820 --> 00:40:43.920
If your favorite language
doesn't bridge to Cocoa,

00:40:44.050 --> 00:40:48.210
you know, it's not on the system,
nobody's written a bridge for us yet,

00:40:48.460 --> 00:40:49.080
Talk to us.

00:40:49.370 --> 00:40:52.300
We may be able to hook you up
with someone who is interested.

00:40:52.300 --> 00:40:53.660
Maybe you can write it yourself.

00:40:53.760 --> 00:40:55.180
We'd love to have more bridges.

00:40:55.180 --> 00:40:57.820
We'd love to have more
languages supported.

00:41:00.130 --> 00:41:01.160
Here are the people to talk to.

00:41:01.280 --> 00:41:03.720
Sal Segoyan is our
Product Marketing Manager.

00:41:03.780 --> 00:41:06.880
John Montbriand is our DTS contact.

00:41:09.180 --> 00:41:12.140
Sample code is, or will be,
real soon now,

00:41:12.140 --> 00:41:18.800
I'm told it'll be up by tomorrow morning,
available on the developer site.

00:41:18.860 --> 00:41:22.160
Both the Currency Converter example and
the iTunes Web example will be up there.

00:41:25.780 --> 00:41:27.980
We have lab time on Friday.

00:41:27.980 --> 00:41:31.660
That's our dedicated lab
time from 10:30 to 1:45.

00:41:31.690 --> 00:41:37.040
Failing that,
come find us at various other sessions.

00:41:37.060 --> 00:41:38.540
We'd be happy to help out.

00:41:38.650 --> 00:41:40.950
Also,
I mentioned the Making Your Applications

00:41:41.030 --> 00:41:42.140
Scriptable session.

00:41:42.140 --> 00:41:43.240
That's tomorrow at 2:00.
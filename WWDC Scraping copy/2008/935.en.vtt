WEBVTT

00:00:21.230 --> 00:00:22.130
Good morning everyone.

00:00:22.260 --> 00:00:24.400
Glad to see we've packed
the house at 9 a.m.

00:00:24.400 --> 00:00:25.940
on Friday morning after the party.

00:00:25.940 --> 00:00:28.390
I hope you all had a great time.

00:00:30.560 --> 00:00:31.280
All right.

00:00:31.570 --> 00:00:32.660
My name is Dave Payne.

00:00:32.660 --> 00:00:35.100
I'm the manager of the
Analysis Tools team,

00:00:35.100 --> 00:00:38.460
so that's debugging and
performance analysis tools.

00:00:38.460 --> 00:00:42.100
In the session this morning,
we're going to look at some new

00:00:42.100 --> 00:00:46.140
ways to try to understand the
behavior of your applications.

00:00:46.140 --> 00:00:50.480
We'll take a look at reviewing
Instruments and DTrace,

00:00:50.500 --> 00:00:54.980
look at how to trace functions
and methods in your application,

00:00:55.310 --> 00:00:58.970
how to build custom
Instruments with DTrace,

00:00:59.200 --> 00:01:04.990
and how to build static probes with
DTrace and use those static probes.

00:01:05.610 --> 00:01:09.070
So this session is relevant for pretty
much everyone at the conference.

00:01:09.270 --> 00:01:14.520
Mac developers where we introduced
Instruments and DTrace in Leopard.

00:01:14.520 --> 00:01:19.200
For iPhone developers,
you can use Instruments with either the

00:01:19.200 --> 00:01:22.430
iPhone simulator or on the iPhone itself.

00:01:22.550 --> 00:01:26.350
DTrace is available for your
iPhone applications when you're

00:01:26.350 --> 00:01:30.670
running in the iPhone simulator
because they're really effectively

00:01:30.750 --> 00:01:32.970
a Mac application at that point.

00:01:33.980 --> 00:01:38.810
And Information Technologies people
can use Instruments to analyze your

00:01:38.810 --> 00:01:43.190
entire system and see what's going on,
for example, on a server.

00:01:44.100 --> 00:01:48.720
So as a recap,
Instruments is a great way to visualize

00:01:48.940 --> 00:01:53.920
the behavior and performance of your
application or your entire system.

00:01:53.920 --> 00:01:59.950
It allows you to collect multiple
types of event data simultaneously in

00:01:59.950 --> 00:02:04.670
different tracks and then filter that
data down and sort it in different

00:02:04.670 --> 00:02:09.410
ways to really do data mining and hone
in to find the problems you're having.

00:02:09.720 --> 00:02:15.970
This lets you turn your classical edit,
build, debug cycle into edit, build,

00:02:15.970 --> 00:02:21.920
debug, analyze, performance tune,
so streamline that entire cycle.

00:02:24.350 --> 00:02:28.700
Instruments comes with quite a
variety of built-in instrumentation

00:02:28.700 --> 00:02:30.470
that's very powerful.

00:02:30.610 --> 00:02:33.900
Much of this is based on the
Leopard frameworks like the

00:02:33.900 --> 00:02:38.020
ObjectAlloc and Leaks instruments,
CPU Sampler.

00:02:38.060 --> 00:02:42.730
And then we have a number of built-in
instruments that are based on DTrace.

00:02:42.700 --> 00:04:59.300
[Transcript missing]

00:05:00.100 --> 00:07:45.600
[Transcript missing]

00:07:45.850 --> 00:07:50.800
So let me do a virtual demo and show
you how that works in action here.

00:07:50.800 --> 00:07:57.290
So I go into a terminal window and
I can use the sudo dtrace-l command

00:07:57.290 --> 00:07:59.780
to list all the probes in the system.

00:07:59.780 --> 00:08:02.800
We had about 25,000 of them on Leopard.

00:08:02.800 --> 00:08:05.300
When we tried it
recently on Snow Leopard,

00:08:05.390 --> 00:08:07.490
we had over 60,000.

00:08:07.500 --> 00:08:12.570
And a lot of them are duplicated probes
from static probes in the framework that

00:08:12.570 --> 00:08:15.470
appear in multiple different processes.

00:08:15.700 --> 00:08:19.760
But you can see here that,
so this is a listing of all the

00:08:19.760 --> 00:08:22.420
built-in probes that are available.

00:08:22.420 --> 00:08:26.850
They're a bunch of different providers
in a variety of different modules,

00:08:26.940 --> 00:08:29.810
different functions, and different names.

00:08:31.350 --> 00:08:38.080
So I've written a simple little
script here called syscalldemo.d.

00:08:38.370 --> 00:08:42.240
So the probe descriptor here is
saying I want to use the syscall

00:08:42.240 --> 00:08:47.640
provider to watch system calls,
and specifically the open system call.

00:08:47.640 --> 00:08:52.240
I want to trap on the
entry of open system call.

00:08:52.240 --> 00:08:57.000
And I'm using a predicate on this
to say I'm really only interested

00:08:57.000 --> 00:09:01.650
in it if the executable name is
calculator when this probe fires.

00:09:02.320 --> 00:09:04.320
Then I have a couple
of action statements.

00:09:04.320 --> 00:09:08.860
One to do a printf line to
say what app opened what file.

00:09:08.860 --> 00:09:13.000
So in this case I use, again,
exec name as a built-in variable.

00:09:13.000 --> 00:09:17.100
It's always going to be calculator in
this example because of the predicate.

00:09:17.100 --> 00:09:23.460
Then I can use arg0,
which is the file name argument to open.

00:09:23.460 --> 00:09:27.240
Now because the probe is
firing in kernel space,

00:09:27.340 --> 00:09:31.880
it doesn't directly have
access to the file name there.

00:09:31.880 --> 00:09:33.540
All it gets is the pointer.

00:09:33.600 --> 00:09:39.510
But it can use a DTrace function called
copy in string to reach out into user

00:09:39.640 --> 00:09:44.350
space and copy that C string into the
kernel for recording with this event.

00:09:44.420 --> 00:09:50.360
I'm also using the uStack50 call to
say I want to see the first 50 frames

00:09:50.360 --> 00:09:53.040
of the stack when this event fires.

00:09:53.200 --> 00:09:58.490
So let me go ahead and
execute this script.

00:09:58.680 --> 00:10:03.460
So I do a sudo DTrace-S to
say this particular script.

00:10:03.600 --> 00:10:06.180
We see that it matches one probe.

00:10:06.200 --> 00:10:10.040
I flip over to Calculator,
change the window size a couple of times,

00:10:10.040 --> 00:10:12.900
and we've seen that it
fired a couple of events.

00:10:12.980 --> 00:10:16.360
Flip back over to Terminal,
scroll up to the top,

00:10:16.540 --> 00:10:21.760
and we can see that we get
the printf line at the top.

00:10:21.840 --> 00:10:26.420
Calculator opened a
global preference file,

00:10:26.430 --> 00:10:32.460
and then down below /dev/autoFS/nowait,
and we see the backtrace of

00:10:32.460 --> 00:10:33.980
where these events occurred.

00:10:34.260 --> 00:10:36.380
So you can do this on the command line.

00:10:36.380 --> 00:10:40.960
You can write any scripts
that you need to write there.

00:10:43.110 --> 00:10:45.750
So we've referred to DTrace providers.

00:10:46.050 --> 00:10:49.590
I like to think of the providers
as being in three categories:

00:10:49.820 --> 00:10:53.500
system-wide providers,
per-process providers,

00:10:53.530 --> 00:10:56.500
and user-land static probes.

00:10:57.000 --> 00:16:18.500
[Transcript missing]

00:16:20.310 --> 00:16:25.460
So let's take a look at how you'd
use this to build custom instruments.

00:16:25.620 --> 00:16:28.160
So first off,
why would you want to do that?

00:16:28.230 --> 00:16:29.850
Well, you know your own code.

00:16:29.860 --> 00:16:33.980
We can't imagine all the problems that
you're going to want to solve because

00:16:33.980 --> 00:16:36.570
they're particular to your domain.

00:16:36.580 --> 00:16:40.110
And you can also tailor instruments
for different types of tasks,

00:16:40.110 --> 00:16:44.640
such as bug hunting, assertion checking,
regression testing.

00:16:44.640 --> 00:16:50.070
You could use the UI recorder
instruments with custom instruments

00:16:50.120 --> 00:16:55.520
that you've written to execute your
application time and time again.

00:16:55.740 --> 00:17:03.450
Say each time you modify your code,
you could rerun a UI recording and make

00:17:03.450 --> 00:17:08.040
sure that you get similar results from
your custom instruments to make sure

00:17:08.040 --> 00:17:10.760
that you haven't broken your program.

00:17:10.800 --> 00:17:14.620
Or you could do network administration
tools in your environment.

00:17:14.620 --> 00:17:17.140
Again, very similar to DTrace itself.

00:17:17.450 --> 00:17:21.200
You can pose and answer
arbitrary questions in this way.

00:17:21.440 --> 00:17:24.180
So for example, assertion checking.

00:17:24.180 --> 00:17:27.540
A lot of times you'll use
something like NSAssert to check

00:17:27.540 --> 00:17:29.600
input parameters to functions.

00:17:29.600 --> 00:17:34.440
Most people compile these out
of their production release.

00:17:34.440 --> 00:17:39.700
But with DTrace,
you could put probes on functions

00:17:39.700 --> 00:17:46.060
that you could turn on at runtime,
gather the input, and check those sort of

00:17:46.330 --> 00:17:48.620
externally from your program.

00:17:48.640 --> 00:17:53.050
You can also use the DTrace
actions and its other mechanisms to

00:17:53.550 --> 00:17:56.160
maintain state of what's going on.

00:17:56.230 --> 00:17:58.750
So you can do broader
levels of validity checking.

00:17:58.900 --> 00:18:00.440
You know,
if function A got these arguments,

00:18:00.550 --> 00:18:03.430
then function B should have this.

00:18:04.370 --> 00:18:09.100
To build a new DTrace instrument,
you use the Build New Instrument

00:18:09.240 --> 00:18:13.000
or Trace Symbol menu items
from the Instrument menu.

00:18:13.000 --> 00:18:17.480
You can also edit an existing
DTrace instrument by using

00:18:17.570 --> 00:18:20.430
the Edit Instrument menu item.

00:18:20.440 --> 00:18:23.490
Or if you have an instrument
in a trace document,

00:18:23.490 --> 00:18:27.880
you can just double-click on it to
bring up the instrument builder.

00:18:30.220 --> 00:18:33.120
So for example,
the easiest way to leverage the

00:18:33.130 --> 00:18:35.760
flexibility of DTrace is Trace Symbol.

00:18:35.760 --> 00:18:40.180
You just enter in a function
name that you want to trace,

00:18:40.180 --> 00:18:44.380
such as fprintf or nslog,
or an Objective-C method name.

00:18:44.380 --> 00:18:47.620
In this case,
Instrument Builder knows about

00:18:47.620 --> 00:18:53.600
Objective-C and it converts the colons in
your method names to asterisks for you.

00:18:53.600 --> 00:18:56.680
When you're using the Trace Symbol,
you can also use

00:18:56.750 --> 00:18:58.520
wildcards in class names.

00:18:58.520 --> 00:19:02.600
So you could say, for example,
I want to trace all my set methods,

00:19:02.770 --> 00:19:11.400
which would include those for access
or set methods on properties that get

00:19:11.400 --> 00:19:13.360
generated by the compiler for you.

00:19:13.440 --> 00:19:16.930
Or you could trace a method
on multiple different classes.

00:19:17.040 --> 00:19:21.600
When you bring up the Instrument Builder,
it comes down as a sheet

00:19:21.730 --> 00:19:23.590
on your trace document.

00:19:23.860 --> 00:19:27.790
There's multiple different categories,
areas in the Instrument Builder sheet.

00:19:27.790 --> 00:19:32.890
The top area is a way to communicate
to instruments how this instrument

00:19:32.890 --> 00:19:34.840
should appear in the library.

00:19:34.840 --> 00:19:37.760
So it lets you specify
a human-readable name,

00:19:37.850 --> 00:19:41.200
a category in the instrument's
library to put it in,

00:19:41.200 --> 00:19:46.230
and a human-readable description,
which gets looked at when you type

00:19:46.230 --> 00:19:49.210
into the filter field of the library.

00:19:50.190 --> 00:19:54.370
There's a data field in case you need
to declare any variables for this,

00:19:54.370 --> 00:19:58.400
and a lot of times you won't need to
because DTrace doesn't require it.

00:19:58.500 --> 00:20:01.170
If you need to initialize
any variable values,

00:20:01.170 --> 00:20:03.140
you can do it in the begin field.

00:20:03.140 --> 00:20:07.710
And then the heart of the Instrument
Builder is the probe clause.

00:20:07.780 --> 00:20:11.190
So there's three different
sections of this.

00:20:11.310 --> 00:20:17.200
One is the probe condition
where you specify the probe

00:20:17.400 --> 00:20:18.990
itself and any predicates.

00:20:19.920 --> 00:20:20.520
And then the probe condition
where you specify the probe

00:20:20.520 --> 00:20:20.910
itself and any predicates.

00:20:21.030 --> 00:20:24.360
So in this case,
we're using the profile provider

00:20:24.360 --> 00:20:26.820
to fire at one-second intervals.

00:20:26.920 --> 00:20:30.410
And you can see there's
a pop-up for what type,

00:20:30.530 --> 00:20:32.490
which is the provider.

00:20:32.940 --> 00:20:37.060
Then there's the action
portion of your script.

00:20:37.060 --> 00:20:40.700
And finally,
something custom for Instruments is

00:20:41.090 --> 00:20:47.660
what data do we want to record to have
it appear in the detail view for this

00:20:48.150 --> 00:20:53.020
instrument or be shown in the track view.

00:20:53.930 --> 00:20:57.880
And finally, there's an end section,
which a lot of times you won't need to

00:20:57.880 --> 00:21:02.150
use with instruments that you build here.

00:21:02.430 --> 00:21:05.310
Once you've created your new instrument,
you can just hit the

00:21:05.410 --> 00:21:06.910
Save button and it gets saved.

00:21:06.940 --> 00:21:10.520
If you are editing an
existing instrument,

00:21:10.520 --> 00:21:14.340
then we say, well, okay,
we want to be safe here by default

00:21:14.340 --> 00:21:19.560
and not trash your old instrument or
the data that is recorded with it.

00:21:19.680 --> 00:21:21.870
So the default is to save a copy.

00:21:21.880 --> 00:21:24.750
But you'll note that we
have a checkbox on the left,

00:21:24.750 --> 00:21:28.350
and this is new to Xcode 3.1,
that says preserve previous

00:21:28.370 --> 00:21:30.520
instruments and recorded data.

00:21:30.960 --> 00:21:34.210
So when we're doing a save copy,
that checkbox is checked.

00:21:34.300 --> 00:21:39.200
But if you uncheck that,
that lets you experiment with one

00:21:39.200 --> 00:21:45.400
instrument and do an iterative,
edit the instrument, save it, try it,

00:21:45.400 --> 00:21:49.480
edit again, save it, try it,
until you get an instrument

00:21:49.640 --> 00:21:51.020
that you're happy with.

00:21:51.190 --> 00:21:53.900
So rather than getting six
instruments created out of that,

00:21:54.120 --> 00:21:55.240
you can just edit one.

00:21:55.240 --> 00:21:56.340
So that's really convenient.

00:21:56.340 --> 00:21:59.940
I like it too.

00:22:01.700 --> 00:22:06.980
So now we'd like to take a
case study of exploring our

00:22:06.980 --> 00:22:08.920
poor little baffle application.

00:22:08.920 --> 00:22:13.240
So I'd like to call up my colleague,
Chad Woolf.

00:22:17.400 --> 00:22:18.400
Thank you, Dave.

00:22:18.400 --> 00:22:22.890
Yeah, we're going to take a look at the
Baffle Cocoa application again.

00:22:22.940 --> 00:22:24.120
That's the Mr.

00:22:24.120 --> 00:22:27.400
Bill application of WWDC 2008.

00:22:27.400 --> 00:22:35.400
So, Dave has shown you how we can create
custom instruments using DTrace.

00:22:35.400 --> 00:22:38.190
So let's look at an example.

00:22:38.460 --> 00:22:42.550
So our Baffle Koku
application is up there.

00:22:42.550 --> 00:22:46.460
And on a Friday we get an email saying,
OK, we've added a new feature.

00:22:46.510 --> 00:22:50.960
This new feature allows you to flip
back and forth through the list of words

00:22:50.960 --> 00:22:54.360
that you've gotten in various games.

00:22:54.390 --> 00:22:57.150
And so please update your sources.

00:22:57.150 --> 00:22:58.230
And so I did.

00:22:58.230 --> 00:23:01.500
Merged it with my code,
took a look at it.

00:23:01.660 --> 00:23:05.140
So I started a new game, finished it,
got three words,

00:23:05.140 --> 00:23:07.870
and I go to the back button.

00:23:08.580 --> 00:23:11.500
But when I click it,
I notice that the word list

00:23:11.610 --> 00:23:12.720
is kind of bizarre looking.

00:23:12.720 --> 00:23:13.940
That's not really what I remembered.

00:23:13.940 --> 00:23:20.300
So what I'm looking at here is it looks
like a list of the same number of words.

00:23:20.300 --> 00:23:21.970
The score is correct.

00:23:22.090 --> 00:23:25.760
Then the number of letters in
each word seem to be matching.

00:23:25.760 --> 00:23:28.120
But the letters themselves
are a little scrambled.

00:23:28.900 --> 00:23:32.840
So let's take a look at what we
know about the BaffleCoco app.

00:23:33.000 --> 00:23:37.580
It has a word list on the right and
the pieces on the board on the left.

00:23:37.930 --> 00:23:46.440
Now, the word list on the right,
each word is represented

00:23:46.440 --> 00:23:50.800
by a BG Baffle word object.

00:23:50.800 --> 00:23:50.800
And the pieces on the board
are represented by the

00:23:50.800 --> 00:23:50.800
BG Baffle piece object.

00:23:51.100 --> 00:23:56.420
Now what's interesting is the BG Baffle
word actually refers or is composed of

00:23:56.420 --> 00:24:01.580
pieces so that when you execute its get
me your string representation there,

00:24:01.580 --> 00:24:06.920
it iterates through that array of pieces
and constructs you string dynamically.

00:24:08.030 --> 00:24:10.450
So that's potentially pretty suspect.

00:24:10.450 --> 00:24:13.720
But without jumping to any conclusions,
we definitely want to look at

00:24:13.720 --> 00:24:17.040
both possibilities and that is
maybe the word is being changed.

00:24:17.040 --> 00:24:21.440
So I copy the word into the history
list and then maybe something's

00:24:21.440 --> 00:24:24.190
inserting pieces or removing pieces.

00:24:24.220 --> 00:24:27.790
Those are the two methods that
we have for changing a word.

00:24:27.890 --> 00:24:30.060
Or the other possibility,
which seems a little bit more

00:24:30.180 --> 00:24:32.880
likely based on what we've seen,
is that the pieces

00:24:32.880 --> 00:24:34.760
themselves are changing.

00:24:34.780 --> 00:24:38.600
And this can happen potentially
if we didn't do a deep copy.

00:24:38.600 --> 00:24:41.150
We copied the words,
but we didn't also copy the pieces,

00:24:41.150 --> 00:24:43.910
and maybe they're being
referred to the same,

00:24:43.910 --> 00:24:47.760
or maybe the words are referring to the
same pieces that are still on the board.

00:24:48.120 --> 00:24:54.650
So I'm going to hop into Instruments over
here with our running baffle application.

00:24:58.470 --> 00:25:01.710
Now without, without,
now see I'll show you how it's

00:25:01.710 --> 00:25:04.010
exhibiting the problem here.

00:25:04.050 --> 00:25:07.290
Okay, that's obviously trash
but the score is valid.

00:25:07.890 --> 00:25:11.760
And without taking it down,
I'm going to call up Instruments.

00:25:11.830 --> 00:25:12.880
Sometimes when you're
debugging something,

00:25:12.880 --> 00:25:15.100
you don't want to take it down,
so attaching to it through

00:25:15.100 --> 00:25:16.620
Instruments is a great idea.

00:25:16.620 --> 00:25:20.270
Starting from a blank template,
I'm going to go to Instrument,

00:25:20.270 --> 00:25:22.480
and I'm going to say Trace Symbol.

00:25:22.480 --> 00:25:25.760
The first thing we wanted to
look at was our Word class,

00:25:25.760 --> 00:25:30.190
and we wanted to see if our Word class
was being modified before or after it

00:25:30.280 --> 00:25:32.350
was being copied into the old list.

00:25:33.120 --> 00:25:39.200
So I type in bgbaffleword
with an asterisk,

00:25:39.200 --> 00:25:42.970
so I'm going to trace all
methods being sent on all

00:25:42.970 --> 00:25:45.550
objects of the baffle word class.

00:25:46.300 --> 00:25:50.880
Instruments creates for us a
custom instrument here in DTrace.

00:25:50.880 --> 00:25:53.360
Let's take a quick look at that.

00:25:54.560 --> 00:25:57.330
So when you say trace a symbol,
you'll see that it creates

00:25:57.330 --> 00:25:59.740
two probes for you,
an entry and a return.

00:25:59.750 --> 00:26:02.260
You'll see that the provider
is the Objective-C provider,

00:26:02.260 --> 00:26:08.050
the class is the baffle word,
and the method here is the asterisk,

00:26:08.110 --> 00:26:11.840
meaning we want to trace them all.

00:26:12.110 --> 00:26:15.070
Upon entry,
we save off the start time and the

00:26:15.160 --> 00:26:18.240
object ID pointer here in our action.

00:26:18.960 --> 00:26:23.770
And on the return from the method,
we will be sending some information

00:26:23.830 --> 00:26:25.580
to Instruments down here.

00:26:25.580 --> 00:26:27.920
And that's the self pointer
that recorded during the entry

00:26:27.920 --> 00:26:32.270
and the duration of the call,
which is the current timestamp minus

00:26:32.270 --> 00:26:35.600
the time that the return probe fired.

00:26:35.680 --> 00:26:37.890
Now what we are going to be missing here,
and I want to add,

00:26:38.090 --> 00:26:41.030
is because we're wildcarding this,
we don't know which

00:26:41.030 --> 00:26:42.270
method is actually firing.

00:26:42.330 --> 00:26:44.880
So we want to send that piece
of information to Instruments

00:26:45.000 --> 00:26:46.350
as well for recording.

00:26:46.450 --> 00:26:49.390
So I'll go down to here to
record the following data.

00:26:49.480 --> 00:26:53.810
Say record in Instruments,
and then choose from the

00:26:53.810 --> 00:26:56.910
list of options here,
the function.

00:26:57.240 --> 00:27:01.090
Now in the Objective-C provider,
the module is the class,

00:27:01.200 --> 00:27:04.360
the method is the function,
and the name is either entry or return.

00:27:04.360 --> 00:27:07.120
So function is definitely
what we want there,

00:27:07.120 --> 00:27:08.550
and we'll save that.

00:27:10.240 --> 00:27:15.340
So let's target our running
baffle Cocoa process.

00:27:15.340 --> 00:27:19.260
And we'll record the trace.

00:27:19.260 --> 00:27:20.250
Go back.

00:27:20.500 --> 00:27:22.470
Now I'm going to run through
a game here real quickly so

00:27:22.470 --> 00:27:24.910
you can see some trace data.

00:27:27.090 --> 00:27:32.590
Unfortunately, I'm not very good at this,
but I've got a paycheck riding on it.

00:27:32.660 --> 00:27:36.100
Okay, that should be enough.

00:27:39.060 --> 00:27:41.480
Now we go back here,
we'll stop the trace,

00:27:41.580 --> 00:27:44.550
we'll take a look at what we got.

00:27:44.670 --> 00:27:47.200
So you see we have the caller,
which is the call site,

00:27:47.200 --> 00:27:50.620
which is where the methods
were being invoked.

00:27:50.730 --> 00:27:54.450
We have the actual method,
which is what I set up, the self pointer,

00:27:54.470 --> 00:27:55.830
and the duration.

00:27:55.890 --> 00:27:57.960
Now this is a lot of data.

00:27:57.960 --> 00:28:01.420
You can go through it
with some filtering.

00:28:01.490 --> 00:28:04.530
And you can also go into the
extended detail view to see

00:28:04.530 --> 00:28:05.970
a nice image of the stack.

00:28:06.080 --> 00:28:07.950
Click through here.

00:28:08.420 --> 00:28:13.220
What we're looking for in our word
is we want to see if the insert or

00:28:13.260 --> 00:28:17.300
remove methods are being called,
specifically the insert,

00:28:17.300 --> 00:28:18.900
after we've made a copy.

00:28:18.900 --> 00:28:26.120
So let's go and we'll filter
down to insert object in pieces.

00:28:26.120 --> 00:28:29.030
Okay, we see a bunch of hits there.

00:28:30.160 --> 00:28:33.540
And we see the last hit is at sample 502.

00:28:33.560 --> 00:28:35.520
So keep that in mind,
because now we're going

00:28:35.520 --> 00:28:37.740
to look for the copies.

00:28:39.300 --> 00:28:41.300
So we look with copy with zone.

00:28:41.300 --> 00:28:43.480
We see it happening in
a few different places,

00:28:43.570 --> 00:28:44.840
here and here.

00:28:44.860 --> 00:28:48.970
Now the last one's at 5.03,
so that's a good indication that we

00:28:48.970 --> 00:28:53.780
haven't actually modified any words
after we made the copies of those words.

00:28:53.860 --> 00:28:56.600
So that's not likely to be the problem.

00:28:56.910 --> 00:29:01.980
So let me close our trace document and
we'll take a look at our other guess.

00:29:02.080 --> 00:29:05.810
And our other guess was
that when we go back here,

00:29:05.810 --> 00:29:09.890
the words themselves are
actually being changed because

00:29:09.960 --> 00:29:12.280
the pieces are being changed.

00:29:12.670 --> 00:29:15.590
So in order to look at that,
what we really want to do is

00:29:15.600 --> 00:29:19.800
you want to see if a piece
has been added into a word.

00:29:19.840 --> 00:29:23.930
And if that piece has been added into a
word and then somehow that piece changes,

00:29:23.940 --> 00:29:25.300
you want that flag.

00:29:25.340 --> 00:29:26.990
Pieces, of course,
can change because you get to shake

00:29:27.000 --> 00:29:27.900
the board as much as you want.

00:29:27.950 --> 00:29:30.810
But if those pieces are
actually part of an existing

00:29:30.810 --> 00:29:33.640
word somewhere in the document,
you definitely want to

00:29:33.720 --> 00:29:34.760
have that flag instead.

00:29:34.840 --> 00:29:38.030
So I created an instrument
ahead of time here.

00:29:38.380 --> 00:29:41.010
So we're going to call
up Instruments again.

00:29:42.160 --> 00:29:45.480
I'll go to my Word Corruption
Check instrument,

00:29:45.480 --> 00:29:48.110
and we'll take a look
at how I built that.

00:29:50.110 --> 00:29:54.290
So using associative
arrays inside DTrace,

00:29:54.290 --> 00:29:58.880
what we can do is on the entry
to the insert object in pieces,

00:29:58.880 --> 00:30:03.600
we can take that piece object that
was being passed into our word,

00:30:03.600 --> 00:30:06.780
and we can record it in a
global associative array.

00:30:06.780 --> 00:30:10.610
So now we know that, okay,
this piece object ID is now

00:30:10.760 --> 00:30:15.130
being used in a word somewhere,
so let's increment a counter,

00:30:15.350 --> 00:30:19.560
and that's here in our used
in words global variable.

00:30:20.210 --> 00:30:25.390
So we can see that we have
a function where arg2 is the

00:30:25.390 --> 00:30:28.780
first argument to the function,
which is actually object

00:30:28.780 --> 00:30:28.780
being inserted into the word.

00:30:29.420 --> 00:30:31.810
And we'll just pass some
information there for tracing

00:30:31.810 --> 00:30:34.800
saying that we're tracking a piece.

00:30:34.940 --> 00:30:38.690
And then for completeness,
we'll go down to Remove Object from

00:30:38.800 --> 00:30:41.000
Pieces in case the user backtracks.

00:30:41.100 --> 00:30:45.370
We don't want that piece to be wrongly
flagged as being part of a word,

00:30:45.370 --> 00:30:47.350
so we'll just say that
we're dropping the piece.

00:30:47.480 --> 00:30:55.530
We'll go into our Used in Words global
and remove our reference count there.

00:30:55.830 --> 00:30:59.800
And then finally, those, by the way,
those methods are being set

00:30:59.800 --> 00:31:01.740
inside the baffle word class.

00:31:01.740 --> 00:31:04.940
It might have been obvious,
but I figure I might repeat that.

00:31:05.050 --> 00:31:07.850
But the,
now the new probe that I want to put

00:31:07.900 --> 00:31:12.260
in here is in the actual piece itself,
because I want to track any

00:31:12.260 --> 00:31:16.700
time a method that starts with
set is being called on a piece.

00:31:17.200 --> 00:31:24.390
But the predicate suggests that it should
only fire if the used in words contains

00:31:24.390 --> 00:31:27.720
that guy and the count is not zero.

00:31:27.720 --> 00:31:31.900
So if a piece is being referenced,
that will show up as a non-zero

00:31:31.900 --> 00:31:34.160
number and this probe will fire.

00:31:34.580 --> 00:31:37.990
So let's take a look at that and
see if the problem is actually

00:31:37.990 --> 00:31:40.840
changing pieces inside of a word.

00:31:40.930 --> 00:31:43.900
So we'll attach to our
baffle_coco process again,

00:31:43.950 --> 00:31:45.800
hit record.

00:31:45.840 --> 00:31:49.500
I'll run over to our baffle process,
we'll start a new game.

00:31:49.500 --> 00:31:53.790
Can I buy a vowel?

00:31:53.880 --> 00:31:55.490
Okay, here we go.

00:32:00.200 --> 00:32:09.800
Okay, now let's take a look at what
we recorded in Instruments.

00:32:09.800 --> 00:32:13.000
You'll see that the string
I recorded for what I'm doing here,

00:32:13.000 --> 00:32:15.420
my event string, tracking pieces,
is getting recorded.

00:32:15.420 --> 00:32:17.160
We're seeing inserts firing.

00:32:17.160 --> 00:32:21.720
We're seeing the object ID of the piece.

00:32:21.720 --> 00:32:23.880
But we're not seeing our message.

00:32:23.880 --> 00:32:27.400
So maybe that is actually
happening when we shake.

00:32:27.400 --> 00:32:29.250
Let's take a look at that.

00:32:31.360 --> 00:32:34.340
See now there's where
that probe is firing.

00:32:34.390 --> 00:32:38.460
And you'll notice the set methods
being called are set visible letter.

00:32:38.520 --> 00:32:41.470
So that does indeed
seem to be the problem.

00:32:42.750 --> 00:32:47.270
So let's go back to our code here,
see if we can find that problem.

00:32:47.330 --> 00:32:50.570
Now I was saying that I had
merged some changes in when

00:32:50.570 --> 00:32:55.040
they had added their feature,
and my features that I added had to be,

00:32:55.040 --> 00:32:57.470
were actually related to that.

00:32:58.720 --> 00:33:02.000
But I realize now that, okay,
when we do make the copy,

00:33:02.000 --> 00:33:04.440
we do need a deep copy on this.

00:33:04.820 --> 00:33:07.850
So let me go back into Word.

00:33:08.310 --> 00:33:21.990
Baffle Word Class.

00:33:21.990 --> 00:33:21.990
We'll go to our copy
with zone method here.

00:33:21.990 --> 00:33:21.990
We see that yes, I'm adding the piece
to the array directly.

00:33:21.990 --> 00:33:21.990
That's probably not a great idea.

00:33:21.990 --> 00:33:21.990
So let's make a copy of the piece.

00:33:23.200 --> 00:33:46.200
[Transcript missing]

00:33:47.850 --> 00:33:52.030
All right, now we're going to hit record
again on this new process.

00:33:52.160 --> 00:33:54.850
This is a neat feature in
Instruments is that it will look

00:33:54.850 --> 00:33:56.560
for a process of the same name.

00:33:56.560 --> 00:33:59.330
Since the other one I quit, it'll say,
oh, OK, here's one.

00:33:59.330 --> 00:34:00.480
Is this the one you want?

00:34:00.490 --> 00:34:01.540
It's a new process ID.

00:34:01.540 --> 00:34:02.420
Say, sure.

00:34:04.660 --> 00:34:07.800
So now let's go and
test that theory again,

00:34:07.800 --> 00:34:10.030
now that we've fixed it.

00:34:10.220 --> 00:34:14.920
And again, we don't really need to create
any sort of real words here.

00:34:14.920 --> 00:34:18.320
We just need to get to
the end of the game.

00:34:18.400 --> 00:34:20.560
Watch the sands run out.

00:34:23.710 --> 00:34:26.190
Okay, now we can shake it up again.

00:34:26.190 --> 00:34:27.810
And let's see if we have the problem.

00:34:27.960 --> 00:34:31.420
We see tracking piece,
and then we see dropping piece,

00:34:31.420 --> 00:34:34.580
but we don't actually see the
error that we had seen before.

00:34:34.580 --> 00:34:37.740
So it looks like we fixed it.

00:34:38.410 --> 00:34:42.040
Now, with that in mind,
you can do a lot of really advanced

00:34:42.110 --> 00:34:46.180
tracing here with assertion checking
and building custom instruments to

00:34:46.190 --> 00:34:49.110
look at the behavior in your code,
especially if you're doing a

00:34:49.110 --> 00:34:50.340
lot of programming by contract.

00:34:50.410 --> 00:34:54.710
Say you're looking at a delegate
and you want to make sure that the

00:34:54.720 --> 00:35:00.080
delegate's D-alloc is never called
before you've set the delegate to nil.

00:35:00.080 --> 00:35:01.020
That's an example.

00:35:03.590 --> 00:35:05.560
And all this stuff really
works great on the Mac,

00:35:05.660 --> 00:35:09.370
but unfortunately the D-Trace facility
does not exist on the iPhone itself.

00:35:09.500 --> 00:35:14.010
However,
this does work in the iPhone simulator.

00:35:14.270 --> 00:35:20.190
So let me quickly show you how you can
launch the touch version of our app.

00:35:20.340 --> 00:35:27.960
And that will start it up
inside the iPhone simulator.

00:35:31.840 --> 00:35:33.590
I'm going to run through
that one more time.

00:35:33.610 --> 00:35:36.090
Now,
the Cocoa version and the Touch version

00:35:36.100 --> 00:35:38.580
share a similar code base.

00:35:39.760 --> 00:35:42.500
And you can see the probes firing.

00:35:42.500 --> 00:35:45.630
Now I hadn't made the
change to the touch version,

00:35:45.630 --> 00:35:48.140
so we should still see the error.

00:35:51.710 --> 00:35:54.060
Okay, create a new game and shake.

00:35:54.070 --> 00:35:58.010
Go back here to Instruments,
and we see that our probe with

00:35:58.010 --> 00:36:01.990
the referenced piece modified
is actually still firing even

00:36:01.990 --> 00:36:04.370
inside of an app in the simulator.

00:36:05.190 --> 00:36:06.760
So that's the end of the demo for this.

00:36:06.800 --> 00:36:10.500
I'd like to call Dave back up
here to talk about UserLance

00:36:10.500 --> 00:36:11.530
Static Probes and DTrace.

00:36:24.670 --> 00:36:25.600
Okay, very good.

00:36:25.600 --> 00:36:26.100
Thanks, Chad.

00:36:26.100 --> 00:36:31.740
So this is really nice being able
to just put probes on functions

00:36:31.740 --> 00:36:34.540
and methods in your code,
but what if we actually

00:36:34.540 --> 00:36:38.100
want to add instrumentation
directly into your source code?

00:36:38.100 --> 00:36:39.200
How can we do that?

00:36:39.220 --> 00:36:42.310
So we're going to talk
about DTrace static probes.

00:36:42.330 --> 00:36:44.700
We'll look at what are static probes.

00:36:44.700 --> 00:36:49.240
We'll talk about some places that
we've added static probes inside

00:36:49.240 --> 00:36:53.490
of Apple's frameworks so that
you can gain benefit from that.

00:36:54.320 --> 00:36:57.750
We'll show how to add static
probes to your own code and

00:36:57.750 --> 00:36:59.820
then to use those static probes.

00:37:00.060 --> 00:37:01.820
So what are static probes?

00:37:02.010 --> 00:37:07.180
Well, these are you want to come up with
semantically meaningful probe points that

00:37:07.370 --> 00:37:10.030
you would put in your user space code.

00:37:10.030 --> 00:37:12.660
You don't want to just have
them necessarily be the same

00:37:12.660 --> 00:37:14.000
names as your functions.

00:37:14.000 --> 00:37:17.790
You want to decide what your operations
are that you're trying to trace and have

00:37:17.790 --> 00:37:19.620
probes that are named based on that.

00:37:19.620 --> 00:37:22.480
This way, if you change the function,
you're going to have

00:37:22.480 --> 00:37:23.870
a name based on that.

00:37:24.000 --> 00:37:27.610
So if you change the function names,
then the probe names are still nice

00:37:27.610 --> 00:37:31.240
and stable and your scripts and
instruments will continue to work.

00:37:31.280 --> 00:37:35.000
Static probes give you a great
way to do tracing and logging.

00:37:35.270 --> 00:37:39.040
We like to think of it as any
place that you might have put

00:37:39.040 --> 00:37:41.240
an NS log statement or a printf.

00:37:41.290 --> 00:37:45.000
You could use static probes that
you could dynamically enable

00:37:45.000 --> 00:37:46.800
if you need them at runtime.

00:37:46.920 --> 00:37:50.670
Again, if they're not in use,
they're zero cost.

00:37:50.750 --> 00:37:54.940
Static probes will provide us a way
that we can record Objective-C object

00:37:54.940 --> 00:37:58.150
descriptions as probe arguments,
and we'll look at that.

00:37:58.440 --> 00:38:01.160
You can focus on just
one process with these,

00:38:01.210 --> 00:38:06.570
or if you're putting them into a library,
you could look with an instrument at

00:38:06.570 --> 00:38:09.470
all the processes that use this probe.

00:38:09.700 --> 00:38:13.040
For example, we have probes in Core Data.

00:38:13.040 --> 00:38:18.200
If you wanted to look at the begin
fetch operation on all processes,

00:38:18.200 --> 00:38:23.140
you could use Core Data star
colon colon colon begin fetch.

00:38:23.140 --> 00:38:26.850
The star, again,
this includes the process

00:38:26.850 --> 00:38:29.610
ID and the provider name here.

00:38:31.760 --> 00:38:35.600
So, static probes in Apple's frameworks.

00:38:35.600 --> 00:38:41.020
We saw the pseudo DTrace-L in
my earlier virtual demo.

00:38:41.020 --> 00:38:46.120
You could grep for a specific
process ID and see what static

00:38:46.150 --> 00:38:49.450
probes are in that process from this.

00:38:49.520 --> 00:38:51.910
So, for example,
if you do this on Safari,

00:38:51.910 --> 00:38:54.010
you'll see core data probes in that.

00:38:54.020 --> 00:38:57.560
With Leopard,
we had static probes that we had

00:38:58.030 --> 00:39:04.000
implemented for what's called the
standard DTrace P-Lock stat provider.

00:39:04.000 --> 00:39:09.140
So, this is P-threads information
here looking at locking behavior.

00:39:09.140 --> 00:39:11.560
We have probes on core data.

00:39:11.560 --> 00:39:15.480
Spotlight provides
probes in the MDS daemon.

00:39:15.480 --> 00:39:19.080
And we had static probes
on the scripting languages.

00:39:19.300 --> 00:39:20.670
Ruby, Python, and Perl.

00:39:20.780 --> 00:39:23.340
So, you can see what's going on in those.

00:39:23.360 --> 00:39:26.490
For Snow Leopard,
we're investigating static probes

00:39:26.490 --> 00:39:29.940
in more places in the system,
including Grand Central Dispatch,

00:39:30.130 --> 00:39:34.640
as Leanne showed in her demos
in the Instruments session.

00:39:34.780 --> 00:39:40.370
and Dan Pettit are the team members.

00:39:41.290 --> 00:39:49.590
They'll be working with us
on the application and system

00:39:49.600 --> 00:39:54.500
development side of things.

00:39:54.500 --> 00:39:59.330
They'll be working with us on
the application side of things.

00:39:59.700 --> 00:40:02.620
So looking at the
Core Data static probes,

00:40:02.830 --> 00:40:08.740
we can see a pattern here that there's
a begin and end probe for a number

00:40:08.740 --> 00:40:11.920
of different operations in Core Data,
such as faulting,

00:40:11.920 --> 00:40:15.340
faulting with cache misses,
relationship faulting,

00:40:15.340 --> 00:40:19.250
relationship faulting with cache misses,
fetching, and saving.

00:40:19.260 --> 00:40:21.790
And it's recording the relevant
arguments in each case.

00:40:21.790 --> 00:40:26.490
So you could actually write a
fairly simple DTrace script that

00:40:26.490 --> 00:40:30.740
would actually capture all of the
information for what's going on with

00:40:30.740 --> 00:40:37.100
Core Data in your entire process with
just a few printf statements here.

00:40:38.490 --> 00:40:41.970
But we've actually made
these core data probes a bit

00:40:42.100 --> 00:40:44.400
easier to use in Instruments.

00:40:44.400 --> 00:40:51.400
We've got custom Instruments already
built into the Instruments library here,

00:40:51.400 --> 00:40:55.550
so several different types
of core data instruments.

00:40:56.210 --> 00:40:59.370
So, if you want to write static
probes for your own applications,

00:40:59.420 --> 00:41:00.680
what do you want to think about?

00:41:00.750 --> 00:41:04.680
Well, you want to identify what are the
interesting operations you want to trace.

00:41:04.810 --> 00:41:09.030
A lot of times you'll have, for example,
fairly expensive things or things

00:41:09.030 --> 00:41:12.800
that take differing amounts of time,
and you typically want to see

00:41:12.800 --> 00:41:17.090
a probe at the begin of that
operation and at the end.

00:41:17.210 --> 00:41:21.070
And then you might also want to
look at progress along the way,

00:41:21.180 --> 00:41:23.200
because there might be
meaningful points where,

00:41:23.200 --> 00:41:26.360
you know, if I'm processing 10 files,
then tell me when I've

00:41:26.360 --> 00:41:28.100
gotten through each file.

00:41:28.220 --> 00:41:31.300
At each of these probe points,
you want to think about what is

00:41:31.360 --> 00:41:35.100
the interesting data that you would
want to record at that probe point

00:41:35.100 --> 00:41:39.100
so that you could write scripts
with it to get log messages out,

00:41:39.100 --> 00:41:44.380
or display that information in
a detailed view in Instruments

00:41:44.380 --> 00:41:46.990
or graph it in the track view.

00:41:47.100 --> 00:41:54.100
And then you want to tell the clients of
your probes what your probe points are.

00:41:54.100 --> 00:41:59.250
So, the series of steps you'd go through
to add static probes to a process is

00:41:59.460 --> 00:42:06.100
first write a provider description file,
then set up the build dependencies

00:42:06.100 --> 00:42:09.930
by referencing the header file
for that in a source file.

00:42:10.100 --> 00:42:14.100
We'll build it to
generate the header file,

00:42:14.100 --> 00:42:17.070
and then add the probe
invocations to your code.

00:42:17.100 --> 00:42:18.270
Amen.

00:42:18.510 --> 00:42:21.000
So we're going to take a
look at an example here.

00:42:21.050 --> 00:42:25.450
And you know,
Chad's paycheck really is depending on

00:42:25.450 --> 00:42:27.520
how good he is with this Boggle game.

00:42:27.520 --> 00:42:30.210
And I'd like to be able to
study this a little bit.

00:42:30.300 --> 00:42:34.090
So I want to put a probe
on when he starts the word,

00:42:34.090 --> 00:42:37.660
as he's going through,
hitting each letter,

00:42:37.770 --> 00:42:40.060
and when he ends the word.

00:42:40.060 --> 00:42:43.660
So I want to be able to see what the
timestamps on all these are and what

00:42:44.110 --> 00:42:46.290
letters he's looked at along the way.

00:42:48.580 --> 00:42:54.470
When we're recording data with probes,
in the DTrace language,

00:42:54.470 --> 00:43:00.230
the probe argument types must be C data
types such as ints or shorts or longs,

00:43:00.230 --> 00:43:02.240
char star, void star.

00:43:02.720 --> 00:43:07.200
If you want to record
Cocoa object descriptions,

00:43:07.490 --> 00:43:20.550
here's your opportunity to do that.

00:43:20.590 --> 00:43:20.620
You would need to record
those object descriptions,

00:43:20.620 --> 00:43:20.620
convert them into char stars by using
UTF-8 string and then casting them.

00:43:21.750 --> 00:43:26.220
So our second step here is
to reference the header file.

00:43:26.360 --> 00:43:30.880
So in our example here, we see that the
gamecontroller.m source file,

00:43:30.880 --> 00:43:36.560
we're adding an import statement
to import bgbaffleprobes.h.

00:43:37.680 --> 00:43:43.920
The Xcode build system,
if it sees a reference to a .h file,

00:43:43.920 --> 00:43:51.140
it knows that, oh, okay,
I see a .d file of that same base name,

00:43:51.140 --> 00:43:53.370
so I know how to generate the .h file.

00:43:53.380 --> 00:43:58.230
So step three is to just build,
and that would generate

00:43:58.240 --> 00:44:04.270
the header file for you,
and then code completion could be used.

00:44:04.320 --> 00:44:06.940
If you're using a make-based project,
you can add a reference

00:44:06.940 --> 00:44:07.300
to the header file.

00:44:07.300 --> 00:44:11.610
So the next step here is to add a
rule to your make file using DTrace-h,

00:44:11.610 --> 00:44:15.960
where the -h says generate a header
file using this source file name,

00:44:15.960 --> 00:44:19.930
the .d file, and write it into this
-o output file name.

00:44:19.940 --> 00:44:23.750
So I've described here the
way that this should work,

00:44:23.750 --> 00:44:28.380
and it sometimes does work,
but it's slightly buggy with the Xcode

00:44:28.540 --> 00:44:31.520
build system dependencies right now.

00:44:31.520 --> 00:44:32.650
We need to fix that.

00:44:32.880 --> 00:44:35.390
Chad will show you how to
work around that issue at

00:44:35.390 --> 00:44:37.140
the moment when we do a demo.

00:44:37.280 --> 00:44:38.520
Amen.

00:44:39.070 --> 00:44:43.230
The header file that does get generated,
it's not really meant

00:44:43.230 --> 00:44:44.220
to be human readable.

00:44:44.220 --> 00:44:47.180
A large part of it is fairly obtuse.

00:44:47.210 --> 00:44:51.060
The important parts of it is
that it takes your probe name,

00:44:51.060 --> 00:44:55.030
such as start word,
and it generates macros for that.

00:44:55.100 --> 00:44:58.720
So the form of the macro
is the provider name,

00:44:58.720 --> 00:45:02.080
then an underscore,
and then the probe name with

00:45:02.390 --> 00:45:04.520
everything converted to upper case.

00:45:04.520 --> 00:45:08.280
So you don't want to use a probe name
that's like start dash word because

00:45:08.280 --> 00:45:10.870
when you use that in source code,
of course,

00:45:10.870 --> 00:45:12.260
that would look like a minus sign.

00:45:12.260 --> 00:45:15.820
So it generates two macros,
baffle start word and

00:45:15.820 --> 00:45:18.040
baffle start word enabled.

00:45:19.670 --> 00:45:27.140
Now I can go into the source code and add
probe invocations as my final step here.

00:45:27.140 --> 00:45:33.940
So, in the baffle method,
add visible letter of piece,

00:45:33.980 --> 00:45:38.900
if I look at the array of
touched pieces that I've got,

00:45:38.970 --> 00:45:42.560
if I don't have any yet,
if the count of that array is zero,

00:45:42.560 --> 00:45:47.770
then I must be starting a word and
I can call the baffle start word probe.

00:45:48.100 --> 00:45:53.630
Then after I've added a letter in,
any letter, I can go ahead and invoke the

00:45:53.780 --> 00:45:58.880
baffle word progress method,
passing in the word up to that point.

00:45:58.880 --> 00:46:01.540
And you can see we've done
the UTF-8 string conversion.

00:46:01.580 --> 00:46:04.930
And finally,
when we are done and we commit the word,

00:46:04.930 --> 00:46:07.550
we can put the baffle end word probe in.

00:46:07.550 --> 00:46:12.750
Now you may be looking at this saying,
whoa, you said this was zero

00:46:12.750 --> 00:46:14.730
cost if it's not in use.

00:46:16.600 --> 00:46:18.570
And you can see we've
done the UTF-8 string,

00:46:18.570 --> 00:46:21.310
that looks like it could be kind
of expensive if I'm not using it,

00:46:21.420 --> 00:46:23.840
and that doing a count on an array,
I mean, what's up with this?

00:46:23.900 --> 00:46:27.590
Well, that's where the isEnabled
probes come into action.

00:46:27.590 --> 00:46:32.570
So, DTrace offers these
isEnabled probes to say,

00:46:32.570 --> 00:46:38.240
only execute the code inside
this condition if the probe is

00:46:38.260 --> 00:46:41.500
actually enabled at runtime.

00:46:41.560 --> 00:46:46.470
So, we can surround the baffle start
word and baffle word progress.

00:46:46.670 --> 00:46:50.270
So,
we can do that with a couple of snippets

00:46:50.280 --> 00:46:55.010
of code with an if on that condition,
and that converts this just into

00:46:55.010 --> 00:46:57.900
one quick test and branch at runtime
when the probe isn't enabled.

00:46:57.940 --> 00:47:01.660
We don't need to do that with
baffle end word in this case because

00:47:01.770 --> 00:47:06.860
there's no argument marshalling code,
and we just have a couple of no ops

00:47:06.860 --> 00:47:09.800
in the code when it's not enabled.

00:47:10.560 --> 00:47:13.690
So with that,
I'd like to bring Chad back up to add

00:47:13.690 --> 00:47:19.680
some static probes into his example
so that I can watch his progress here.

00:47:19.680 --> 00:47:22.530
Thank you, Dave.

00:47:26.440 --> 00:47:30.900
Alright,
so this got a lot more exciting for me.

00:47:30.900 --> 00:47:35.980
Okay, so I have my baffle word,
I'm sorry, my baffle Cocoa application

00:47:36.020 --> 00:47:38.430
project up here in Xcode.

00:47:38.900 --> 00:47:42.440
And we've created the file ahead
of time with the descriptor.

00:47:42.600 --> 00:47:45.360
I'm just going to-- the
descriptions of the static probes,

00:47:45.420 --> 00:47:49.480
I'm going to drag that
into my Xcode project here.

00:47:49.780 --> 00:47:52.490
Add that to the current target.

00:47:52.560 --> 00:47:54.840
So let's take a quick look at that.

00:47:54.890 --> 00:47:58.520
That's the provider's baffle
and then the probes are defined.

00:47:58.720 --> 00:48:01.150
It's a very simple syntax.

00:48:03.000 --> 00:48:05.440
Now,
we talked about using code completion,

00:48:05.590 --> 00:48:08.740
and there is a situation where
the header file doesn't exist

00:48:08.740 --> 00:48:11.500
yet because it has to be built.

00:48:11.500 --> 00:48:15.000
But if you want code completion
to work right out of the box,

00:48:15.000 --> 00:48:17.990
you can come over here
to select the file,

00:48:18.000 --> 00:48:21.990
the .d file,
and then say build and compile.

00:48:22.180 --> 00:48:24.090
And that does actually generate
the header file for you.

00:48:24.170 --> 00:48:28.350
So when you come down to the site
where we wanted to add these probes,

00:48:28.350 --> 00:48:30.320
which is in the game controller,

00:48:31.370 --> 00:48:39.740
If you import your header file,
then when we go down to the sites

00:48:39.740 --> 00:48:43.560
where we want to add the code,
the code completion will work for you.

00:48:43.650 --> 00:48:50.340
Because those macros can be a
little hard to type in by hand.

00:48:50.360 --> 00:48:52.670
So let me show you that.

00:48:54.100 --> 00:48:59.430
See, so you got all the code completion
after I hit the compile in the .d file.

00:49:02.070 --> 00:49:05.280
Now, someone in the code was nice enough
to leave a comment behind saying

00:49:05.280 --> 00:49:09.980
where I could insert this to find
out where the beginning of a word is.

00:49:10.070 --> 00:49:11.980
So we'll use that.

00:49:12.700 --> 00:49:15.040
Now this is just the code
that Dave showed you on the

00:49:15.040 --> 00:49:20.510
slides for starting a word,
doing our test with the is enabled

00:49:20.510 --> 00:49:22.590
and then the start word probe firing.

00:49:22.600 --> 00:49:25.930
So skim down through the code.

00:49:25.960 --> 00:49:28.210
Oh look, another comment.

00:49:29.500 --> 00:49:31.860
Okay, this is the word progress.

00:49:31.860 --> 00:49:33.920
Looks like somebody thought we
were thought ahead of time when

00:49:33.920 --> 00:49:35.770
they were commenting the code.

00:49:36.390 --> 00:49:40.150
This is the one we have the
UTF-8 string conversion on the

00:49:40.150 --> 00:49:43.400
current string of that word.

00:49:44.540 --> 00:49:48.400
And then inside the
commit word method here,

00:49:48.400 --> 00:49:55.700
we're going to go to the word
has ended and add in our end.

00:49:55.700 --> 00:49:57.410
Actually, that one I could
probably type in my hand.

00:50:01.520 --> 00:50:06.400
Endword of my code completion.

00:50:06.460 --> 00:50:10.400
Okay, now let's compile and build
that up and give it a run.

00:50:10.500 --> 00:50:12.340
Save the file.

00:50:12.850 --> 00:50:15.780
Good, so now we have an application
in there with static probes.

00:50:15.790 --> 00:50:20.720
So we went from having no probes
at all to a fully instrumented

00:50:20.760 --> 00:50:23.800
baffle game of death for me.

00:50:23.870 --> 00:50:26.720
So now I can start Instruments.

00:50:26.930 --> 00:50:29.310
I can go to a blank template.

00:50:30.360 --> 00:50:35.020
We created an instrument ahead
of time to look at our static

00:50:35.020 --> 00:50:37.140
probes called Word Progression.

00:50:37.140 --> 00:50:41.110
So let's go in there and take a look at
that in the DTrace instrument builder.

00:50:41.840 --> 00:50:49.470
So when you specify a static probe,
you come in here to the type of custom.

00:50:49.770 --> 00:50:51.190
And you specify the provider.

00:50:51.200 --> 00:50:54.360
Now your provider as
a DTrace static probe,

00:50:54.360 --> 00:50:58.140
when you do say a DTrace-L or you
look at it here in Instruments,

00:50:58.230 --> 00:51:00.340
it will say baffle,
which is the provider name,

00:51:00.390 --> 00:51:02.010
plus it'll have the PID appended to it.

00:51:02.080 --> 00:51:05.990
When you're specifying a
custom one inside Instruments,

00:51:06.000 --> 00:51:08.020
you want to say baffle star.

00:51:08.020 --> 00:51:11.310
You don't have to worry about
it maybe picking up probes and

00:51:11.310 --> 00:51:15.040
other processes because if you
target a process in Instruments,

00:51:15.050 --> 00:51:17.210
it'll do the filtering for you.

00:51:17.310 --> 00:51:20.750
For this particular probe,
I record the probe that's

00:51:20.910 --> 00:51:24.340
firing in Instruments,
and part of my action is to record

00:51:24.340 --> 00:51:26.600
the timestamp of when it starts.

00:51:27.060 --> 00:51:31.480
As the word progress continues,
we just simply put a record

00:51:31.480 --> 00:51:36.400
to instruments action
here that says take arg0,

00:51:36.400 --> 00:51:38.080
which is that string
that's being passed in.

00:51:38.090 --> 00:51:41.010
We want to treat it as a string.

00:51:41.160 --> 00:51:44.670
Now, you should note that when
treating something as a string,

00:51:44.680 --> 00:51:49.540
let's say coming right in from Arc 0,
when we generate the DTrace code,

00:51:49.540 --> 00:51:52.450
it actually does a copy and stir
and all of that's managed for you.

00:51:52.480 --> 00:51:54.160
So you can say, Arc 0, it's a string.

00:51:54.160 --> 00:51:55.670
Please send it out to Instruments.

00:51:55.670 --> 00:51:57.250
And that's what we're doing here.

00:51:59.350 --> 00:52:09.160
And then down here on the end word probe,
this is start word,

00:52:09.160 --> 00:52:12.350
this is word progress,
and then this last one is end word.

00:52:12.350 --> 00:52:17.920
So at the end word what we're
going to do is send the current

00:52:17.950 --> 00:52:22.360
time minus the start time out to
Instruments and call out duration.

00:52:23.500 --> 00:52:28.300
So let's send that,
or let's point that at our Baffle

00:52:28.300 --> 00:52:30.580
Cocoa instrumented app here.

00:52:30.860 --> 00:52:34.860
We'll hit record, go back to Baffle.

00:52:34.860 --> 00:52:36.640
Now I'm going to need some
audience participation here.

00:52:36.640 --> 00:52:39.520
I'll see how if I can do it.

00:52:45.900 --> 00:52:54.000
[Transcript missing]

00:52:54.880 --> 00:52:57.610
All right, I got busted.

00:52:57.660 --> 00:53:00.740
Okay, going back to Instruments,
let me stop the trace.

00:53:00.740 --> 00:53:03.290
You can see the call sequence.

00:53:03.320 --> 00:53:08.000
You can see start word probe firing,
and then the word progression here,

00:53:08.000 --> 00:53:11.270
and then how long it took me to
complete that word in milliseconds

00:53:11.270 --> 00:53:13.620
because Dave really likes his accuracy.

00:53:15.850 --> 00:53:19.530
One of the really neat things
about this is it looks like an

00:53:19.530 --> 00:53:23.170
alternative for replacing logging,
and in some ways it is,

00:53:23.170 --> 00:53:26.440
but there's not many logging features
that can actually give you the stack

00:53:26.550 --> 00:53:28.220
trace of when that log message fired.

00:53:28.220 --> 00:53:31.150
And that's something really
interesting that you can do

00:53:31.150 --> 00:53:32.780
with DTrace static probes.

00:53:33.650 --> 00:53:36.410
In addition, you might notice these
fields are left blank.

00:53:36.440 --> 00:53:41.060
If you have a static probe and it's
used in several different functions,

00:53:41.060 --> 00:53:44.130
you can actually specify the
function that you want that

00:53:44.130 --> 00:53:46.670
specific probe invocation in.

00:53:46.680 --> 00:53:49.790
And also in a specific library,
if all of a sudden your code is kind of

00:53:49.790 --> 00:53:52.500
migrated to a few different libraries,
you can specify that

00:53:52.590 --> 00:53:53.980
there in the descriptor.

00:53:53.980 --> 00:53:56.680
But that's basically how you
would get up and running.

00:53:56.680 --> 00:53:57.800
It's very simple.

00:53:57.800 --> 00:54:03.470
The workaround that Dave was mentioning
is really just a quit exercise.

00:54:03.540 --> 00:54:04.530
You can just go to the DTrax
code and then come back in.

00:54:04.540 --> 00:54:06.870
And once you do that,
if you modify the .d file,

00:54:06.950 --> 00:54:10.100
it'll generate the header,
and then the header will cause any

00:54:10.100 --> 00:54:12.600
file that references it to recompile.

00:54:12.600 --> 00:54:16.550
But we're going to work on that,
and that's the end of the demo,

00:54:16.550 --> 00:54:19.540
and hope you guys have
a good rest of the week.

00:54:19.620 --> 00:54:20.460
I'm out of here.

00:54:20.460 --> 00:54:21.550
Dave, come back up.

00:54:21.780 --> 00:54:25.130
Thank you.

00:54:28.920 --> 00:54:29.550
Okay, very good.

00:54:29.560 --> 00:54:33.330
So to recap one more time,
tell them what you're going to tell them,

00:54:33.330 --> 00:54:35.010
tell them and then tell
them what you told them.

00:54:35.080 --> 00:54:39.880
We added static probes by writing
a provider description file,

00:54:39.880 --> 00:54:44.400
by adding a reference to the
header file for that descriptor

00:54:44.400 --> 00:54:46.500
file in our source file.

00:54:46.500 --> 00:54:51.550
We generated the header file by
doing a compile on the .d file,

00:54:51.550 --> 00:54:55.890
and then we added the probe
invocations to our code.

00:54:56.860 --> 00:55:00.670
Then, an additional step,
you might want to create a custom

00:55:00.670 --> 00:55:06.040
instrument in Instruments to
use these static probes as well.

00:55:06.220 --> 00:55:10.420
So in summary for our session,
hopefully this has given you some new

00:55:10.420 --> 00:55:15.320
ideas about new ways to understand
the behavior of your application.

00:55:15.320 --> 00:55:20.320
So this can span the range from
classical debugging and logging on

00:55:20.460 --> 00:55:23.440
through to performance analysis.

00:55:23.690 --> 00:55:28.460
We looked at how to trace
functions and methods,

00:55:28.460 --> 00:55:31.860
both a specific function as
well as using wild carding.

00:55:31.860 --> 00:55:36.280
For example,
on the set methods on properties,

00:55:36.280 --> 00:55:40.200
you can look at accesses on
synthesized properties that way.

00:55:40.200 --> 00:55:41.020
Pretty cool.

00:55:41.020 --> 00:55:45.130
We looked at building custom
DTrace-based instruments and then

00:55:45.180 --> 00:55:49.730
building our own static probes and
using those in our source code.

00:55:51.700 --> 00:55:55.080
For more information,
you can contact Michael Jurowicz,

00:55:55.080 --> 00:55:56.210
our evangelist.

00:55:56.340 --> 00:55:58.030
He'll be on stage for Q&A in a moment.

00:55:58.040 --> 00:56:03.060
You can look at the general
documentation for the WWDC,

00:56:03.060 --> 00:56:07.900
also the DTrace documentation
at the Sun website.

00:56:07.900 --> 00:56:11.540
And I noticed in the introduction
to DTrace session yesterday that

00:56:11.670 --> 00:56:15.010
Steve Peters had a number of
additional reference materials

00:56:15.010 --> 00:56:16.740
at the end of that session.

00:56:16.740 --> 00:56:21.100
So perhaps you caught some
of these earlier sessions.

00:56:21.260 --> 00:56:23.330
But if you didn't,
you'll be able to go back on

00:56:23.330 --> 00:56:24.810
the videos and look at these.

00:56:24.860 --> 00:56:29.310
Getting started with instruments,
debugging and profiling

00:56:29.310 --> 00:56:33.160
your iPhone application,
using DTrace on Mac OS X,

00:56:33.160 --> 00:56:37.300
and then also performance tuning
your application with Shark,

00:56:37.300 --> 00:56:42.470
which is a great CPU profiling
tool that can do very fine-grained

00:56:42.610 --> 00:56:45.390
profiling of your application.
# Wwdc2025 247

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Summary

Transcript

Code

What’s new in Xcode 26Discover the latest productivity and performance advancements in Xcode 26. Learn how to leverage large language models in your development workflow. Explore editing and debugging enhancements, improved performance and testing tools, and Swift Build - the open-source build system engine used by Xcode.Chapters0:00 -Introduction0:49 -Optimizations1:42 -Workspace and editing10:37 -Intelligence17:47 -Debugging and performance27:50 -Builds30:15 -Testing36:10 -Wrap-upResourcesAnalyzing CPU usage with the Processor Trace instrumentEnabling enhanced security for your appMeasuring your app’s power use with Power ProfilerUnderstanding and improving SwiftUI performanceXcode updatesHD VideoSD VideoRelated VideosWWDC25Code-along: Explore localization with XcodeCreate icons with Icon ComposerOptimize CPU performance with InstrumentsOptimize SwiftUI performance with InstrumentsProfile and optimize power usage in your appRecord, replay, and review: UI automation with XcodeSay hello to the new look of app iconsWhat’s new in SwiftWhat’s new in SwiftUIWWDC24Demystify explicitly built modulesTech TalksExplore UI animation hitches and the render loop

Discover the latest productivity and performance advancements in Xcode 26. Learn how to leverage large language models in your development workflow. Explore editing and debugging enhancements, improved performance and testing tools, and Swift Build - the open-source build system engine used by Xcode.

0:00 -Introduction

0:49 -Optimizations

1:42 -Workspace and editing

10:37 -Intelligence

17:47 -Debugging and performance

27:50 -Builds

30:15 -Testing

36:10 -Wrap-up

Analyzing CPU usage with the Processor Trace instrument

Enabling enhanced security for your app

Measuring your app’s power use with Power Profiler

Understanding and improving SwiftUI performance

Xcode updates

HD VideoSD Video

HD Video

SD Video

Code-along: Explore localization with Xcode

Create icons with Icon Composer

Optimize CPU performance with Instruments

Optimize SwiftUI performance with Instruments

Profile and optimize power usage in your app

Record, replay, and review: UI automation with Xcode

Say hello to the new look of app icons

What’s new in Swift

What’s new in SwiftUI

Demystify explicitly built modules

Explore UI animation hitches and the render loop

Search this video…Hi, I’m Eliza. I work on Swift Previews.And I’m Chris.I work on Xcode.Developing great apps takes a lot of work, whether it’s writing code,exploring and prototyping new features,debugging, improving performance and more.We’re excited to share with you some of the awesome improvementsin Xcode this year to help support you in your app development.We’ll start with some optimizations to Xcode’s download size and performance.Then, we’ll explore improvements in the workspace and source editor,and try out some exciting new code intelligence features.Chris will then talk through some new features in debugging & performance,What’s new in builds, and wrap up with some updates in testing.Let’s get started with optimizations!Over the last few years we’ve been working to make Xcode smallerso you can get your tools even fasterand download only the components that you need.This year, Xcode is 24% smaller.Simulator runtimes no longer contain Intel support by default,and the Metal toolchain will only be downloaded if your project needs it.Altogether, this year’s Xcode has a smaller download sizethan Xcode 6 did in 2014!We’ve also optimized text input in Xcode this year,improving typing latency in some complex expressions by up to 50%.We’ve also made some substantial optimizationsto Xcode’s loading performance.It’s now 40% faster to load a workspace.For large projects, this makes a big difference.Which leads us to updates in the workspace and editing.There are tons of enhancements to the source editor in Xcode this year.Let’s start with editor tabs.This year’s Xcode improves the behavior of editor tabsto make them a lot more intuitive.Just like in Safari, I can open a tab and decide where to go from there,using this new start page.And I can pin a tab to fix it on a particular file.This puts me in control of exactly how many tabs I have.Whether that's just one, one for every file, or a perfectly curated set.Now, let’s talk about search.When exploring an unfamiliar project, or even navigating a familiar one,it’s crucial to be able to search your code effectively.This year, Xcode has a really cool new search mode called “Multiple Words search”which uses search engine techniques to find clusters of words in your project.In this search mode, I can enter a set of words.For example, here, I’m trying to find where in my project I’m creatingclipped resizable images.Xcode will now find all the clusters of these words in proximity to each otheracross your documents, sorting the documents by relevance.The clusters can span multiple lines and the search terms can appear in any order,making this a really powerful feature!There’s a big step forward this year for accessibility in Xcode.You can now easily use Voice Control to write Swift code, and you can pronouncethe Swift code just as you’d naturally read it aloud.In this mode, Voice Control understands Swift syntax.It will figure out where spaces should appear,whether expressions correspond to operatorsor should be camel-cased, and so on.To fully appreciate how cool this is, it’s best to see it in action.With Swift Mode for Voice Control,I can navigate and edit my Swift code just by speaking to my Mac.Let’s use this to add a field to our landmark inspectorfor the landmark’s continent.“Start listening”“Swift mode”“Select labeled content”“Four”“Go to the end of the line”“New line, new line”“If let continent equals landmark dot continent""Open brace"“New line”“Labeled content paren quote continent quotecomma value colon continent”“Correct quote continent”“One”“Stop listening”Notice that the continent field now appears near the bottom of my preview,and I didn’t touch my keyboard once!Now, let’s talk about iterating on code.Using Previews has always been a great way to quickly iterate on your UI code.This year, we’re introducing a new macro called Playgroundwhich you can use to quickly iterate on any code.As with previews, you can add a playground inline in your document,and the results of the code execution will appear in their own canvas tab.Let me show you a demo.I’ve noticed a bug in the Landmarks app where landmarksare showing up in the wrong place on the map.I’m going to use a playground to poke around at the landmark structand see if I can figure out what’s going on.Importing the Playgrounds module gives me access to the playground macro.Let’s load a sample landmark so we can examine its data.In the canvas, I see an entry for each expression in my playground.I just have one, which is the landmark structure for the Grand Canyon,and I can see the values for each of its properties.Some of the property types have a Quick Look icon.Let’s look more closely at the coordinate property.Okay, that seems odd...the Grand Canyon shouldn’t be inside a city.I can add another expression to my playground to get more informationabout the region for this landmark.As I modify the playground,expressions in it are re-run, and the canvas updates automatically.Yeah… the Grand Canyon is definitely not in China.Let’s figure out what’s going on here.When we load landmarks from a file, we use a regular expressionto parse the location coordinates from a string.This is the regular expression we’re using.Maybe there’s a problem with it that’s causingour coordinates to be parsed incorrectly?Let’s investigate that in another playground.When I add a new playground I get a new tab in the canvas.Let's add some code to this playground.We’re going to call the function where that regular expression is defined.I’m using a sample input string, and extracting some computed resultsinto local variables so they're easier to examine.Some types, such as regular expression match results,have custom visualizations in the canvas,and in this case, I can see that Xcodehighlights the match range in the original string.The match range makes it clear that there was a problem capturing the minus sign.And now the bug makes sense,as the negative longitude would have been parsed as a positive number,putting the Grand Canyon in the wrong place.I’m going to fix the expression, andif you watch the playground in the canvas while I do this,you’ll see that the results update immediately.I can see in the visualization that the minus signis now included in the range matched by the regular expression.And if I switch back to the original playground,I see that the Grand Canyon is now in the right place!And that’s Playgrounds.They’re great for understanding existing code as well as for trying out new ideas.And the new #Playground macro is also being open-sourced to bring the experienceto Swift developers writing for other platforms.Check out the post on Swift Forums and join in on the conversation!Now, let’s talk about icons.Icon Composer is a new app bundled with Xcode 26.With Icon Composer, you can create beautifully designed, sophisticated,multi-layered icons that work across multiple platforms and software versions.Over the last few years, we’ve made it easier to create icons for all platforms.But this year, icons don’t only differdepending on the platform you’re building for.They now vary in modes, including dark and tinted modeson iOS, iPadOS, and macOS.And there’s a new look for watchOS as well.Now, all of this can be achieved in one single file using Icon Composer.You can take advantage of the full range of our material effectsand even add dynamic properties to your layers,like blur, shadow, specular highlights, and translucency.Not only that, the tool is great for creating flat iconsthat are compatible with previous operating systems,web pages, or anywhere else you need them.To learn more about app icons, and how to use Icon Composer,check out “Say hello to the new look of app icons”and “Create app icons with Icon Composer.”Bringing your app to more users around the globe is incredibly valuable.Supporting different languages helps people feel at home in your app.And with string catalogs, localization can be a breeze.String Catalogs have gotten some big enhancements this year,to make life easier for both developers and translators.For developers, we’ve added type-safe Swift symbols for localized strings.Developers wanting more precise control over strings can define them directlyin the String Catalog, which now produces Swift symbolsthat can be accessed in code.These symbols even appear as auto-complete suggestions!And to assist translators, String Catalogs can now automatically generate commentsthat describe string context.Xcode accomplishes this by intelligently analyzing where and howa localized string is used in your project.It then generates comments using the on-device model.For more on string catalogs,please have a look at the code-along session “Explore localization with Xcode”.Which brings us to intelligence.Xcode is getting some additional exciting new intelligence features.Xcode can now use large language models such as ChatGPTto provide coding assistance.You can ask general questions about Swift — like“tell me about swift concurrency”.And because of the integration with Xcode,the model can take your code into considerationand answer specific questions about your project,or even make changes on your behalf.In addition, we’re introducing a handy lighter-weight menuthat you can use to automatically apply changes to selected code.When you bring up coding tools, you have quick access to common actions,or you can type a custom query into the text field.Let’s look at these features in more detail.This app has a view that shows my favorite landmark collections,but I’m not familiar with the code,and I don’t know where that’s implemented.So I’m going to ask Xcode.Xcode sends the project context to the model,and it replies with an explanationthat describes the relevant source files and what they do.The model can also ask for more information from Xcodeabout additional context it needs while it’s coming up with an answer.The “info” button in the transcript shows us the context that Xcode sent.The response also contains linksso you can quickly navigate to any mentioned file.This looks like the right one.This is a great way to explore an unfamiliar code base.Now, let’s add a feature!Let’s ask Xcode to add ratings to landmark collections.Here, I’m using the `@` characterto directly reference a symbol we want the model to modify.Typing the ‘@‘ symbol into my prompt lets me reference symbols, source files,or any issues in my project that I want the response to focus on.This can be useful when you have specific changes in mind.I can even attach files for the query to reference.Images are especially useful,since many large language models can generate codefrom just a sketch of a user interface.The automatic context and code changes do the right thing out of the box,but if you can also have more control if you want to.This toggle controls whether Xcode includes informationabout your project with the query.If you were asking a general question about Swift, for example,you might choose to turn off project context.But most of the time you’d want to leave it on.This toggle lets you controlwhether to automatically apply any code changes in the response.If it’s off, you can review each change before deciding whether to apply it.Okay, it looks like the response is completeand all the changes have been made to my project.I can click to see a summary of the changesthat were made — these look good.I can type a new message to continue the conversation.Let’s ask the model to add that rating to the user interface.The model can figure out what ‘it’ refers to here,because new messages preserve the context of earlier queries and replies.This change looks pretty good!I can continue making changes in the context of the previous ones.Let’s have a bit of fun and make it go to eleven.Once again, the model knows what I mean by “it” here.Ta-da!Now we have 11 stars!By default, changes are applied automatically to your code.But Xcode keeps a snapshot of your code before each change is applied,so you can easily view and unwind them using the modification historyin the conversation view.Here I can examine every line of codechanged during each stage of the conversation.I can scrub back and forth through time to applyor revert individual sets of changes.In this case, I’m happy with all the changesso I’ll cancel out of the modification history.So far, I’ve been using the code assistant to make changesthat affect multiple files in my project.When I want to focus on a particular section of code,I can also use coding tools right from my source editor.Let’s use coding tools to add a playground that will exercise our Landmark struct.Coding tools has buttons for quick actions to apply to my code,or I can enter a custom query.In this case, let’s select the action to generate a playground.Because the model has access to the context —for newly generated code as well as for existing code —it can create playgrounds that exercise the code in interesting ways.Now we have a playground that lets me inspect a sample landmark!In addition to explaining or modifying code,Xcode is great at helping me fix issues in my code.For example, here I have an error where I’m trying to use a `ForEach` viewwith a type that doesn’t conform to `Identifiable`.There’s a new option this year to generate a fix —this will bring up the coding assistant.Because the model has access to the type declarationas well as the place where the error is detected,it can figure out which file needs to be modified to fix the error.In this case, the fix was to add a protocol conformance in activity.swift.And now the error is resolved.Xcode is also great at fixing other issues.For example, I find I sometimes let deprecation warnings linger in codebecause they’re not causing immediate problems.Now I can save time by asking Xcode to fix them for me!There are many ways to add a model in Xcode.First, you can enable ChatGPT with just a few clicks.You’ll get a limited number of requests each day,and you can bring your own ChatGPT account for even more requests.If you’d like to use another provider, like Anthropic,you can simply enter your API keyand interact with models like Claude 4 Opus and Sonnet.You can choose which models to show from each provider,and can mark your favorites for quick access.And you can also use local models,running on your Mac or private network, thanks to tools like Ollama and LM Studio!You can add as many providers as you want in Xcode’s preferences.Once you’ve configured a set of models,you can quickly switch between themin the coding assistant when beginning a new conversation.So that’s a look through some of the new featuresin Xcode’s workspace and source editor,and how you can use code intelligence to get more creative and productive.Now, I’ll hand it over to Chris, to tell us about debugging and performance.Thanks, Eliza!Catching bugs and improving your app's performance are crucial stepsto providing a great app experience.This year, we have a few exciting updates,starting with the debugger.Debugging Swift concurrency code has gainedsome great livability improvements in this year’s Xcode.As you step through code running in a Swift task,Xcode now follows execution into asynchronous functions,even if that requires switching threads.And Xcode’s debugger UI will now show task IDs.Here, for example, the current Swift Taskis displayed in the backtrace view on the leftand in the Program Counter annotation on the right.And in the variables view you’ll see easy-to-readrepresentations of concurrency types,such as Tasks, TaskGroups, and actors.In this example, it’s much easier to see the Task variable’s properties,such as its priority and any child tasks.Xcode 26 makes debugging Swift concurrency code easier than ever.For more information on Swift concurrency see “What’s New in Swift”.If you’ve ever added functionality to your appthat requires accessing a private resource,like the user’s location or the camera,you may have experienced your app stopping abruptly in the debugger,with an error about a missing “usage description”.“Usage descriptions” are required when accessing private resources,so the system can include them in an authorization prompt,to help the user know why the app is requesting access.This year’s Xcode now understandswhen an app has stopped due to a missing usage descriptionand explains what is missing.From the annotation, you can jump directly to documentation to learn more.But the quickest way to fix the issue is to use the new “Add” button,which will take you directly to the Signing & Capabilities editor.The necessary capability will be added for you,as the Signing & Capabilities editor in Xcode 26now supports editing many capabilities that require usage descriptions,so you can edit them all in one place.Xcode will take care of updating the underlying Info plist,build settings, or entitlements for you.So now, all you need to do is enter your usage description.Then you can re-run and verify that the capabilitynow prompts for permission, as expected.Instruments is a powerful tool for analyzing the performance of your appsand ships as part of every Xcode install.For CPU analysis, Instruments contains some powerful tools,providing multiple options for profiling your code’s performanceon modern Apple silicon hardware.Previously,Instruments used sampling-based profilers to understand CPU usage,which are great choices for analyzing long-running workloads.But what does it mean for a profiler to be sampling based?It literally means that the tool samples the CPUs periodically,expecting that call stacks sampled are responsiblefor the same relative CPU usage overall.But sampling by its very nature is only an approximation of the full workload,which is why it is more practical for long-running workload analysis.In our illustration, the orange sections of executionwere not captured by sampling, for example.Recent Apple silicon devices can capture a processor tracewhere the CPU stores information about the code it runs,including the branches it takes, and the instructions it jumps to.The CPU streams this information to an area on the file systemso that it can be analyzed with the Processor Trace instrument.Rather than periodic sampling,Processor Trace captures informationabout every low-level branching decision the CPU makes,on all running threads, with very little runtime overhead.This means that the Processor Trace timelinecan present a high-fidelity visualization of execution flow.Unlike traditional sampling profilers that can miss critical code pathsbetween sampling intervals,this tool reveals every branch taken and function called —including compiler-generated code, like ARC memory management in Swift.Processor Trace is a fundamental shift in how you can measure software performance,with every function call captured, on all threads, with little overhead.Processor Trace was introduced with Xcode 16.3and is supported by M4 and iPhone 16 devices.Processor Trace is great for understanding the execution of your codeand where CPU time is being spent.In contrast, the significantly updated CPU Counters instrumentwill help you understand how your code is interacting with the CPU.This tool will help guide you in making microarchitecture optimizations.CPU Counters now uses preset modes that group related counters together,to provide a guided approach to learning about how your code is handled by the CPU.These modes include a general CPU Bottlenecks mode,which is a good starting point for this type of analysis.CPU Bottlenecks breaks down the CPU's sustainable instruction bandwidthinto either useful work, or bottlenecked for one of three broad reasons:Either the CPU had to wait for execution units or memory to become available;Or the CPU couldn’t deliver instructions quickly enough;Or the CPU incorrectly predicted future workand needed to get back on track.In addition to the bottleneck analysis approach,the Instruction Characteristics and Metrics modesoffer a more traditional use of the countersto get absolute counts of consumption.These let you focus on tuning critical instruction sequencesby analyzing branches, cache behavior, and numerical operations directly.CPU Counters also includes detailed documentationto help understand what the modes and counters represent.To learn a lot more about Processor Trace and CPU Counterssee “Optimize CPU performance with Instruments”.SwiftUI makes it easier than ever to build highly interactive apps.For the best user experience, performance is critical.In this year’s OS releases we’ve made a number of improvementsto SwiftUI performance.For example, Lists can update up to 16 times fasterwithout any additional changes from your app.Even with these improvements,your app still might not be performing as well as you’d like it to,and you’ll want to find out why your views are updating frequently.To help with that, the next-generation SwiftUI instrument included with Xcode 26,captures detailed information about the causes and effectsof SwiftUI updates.This makes it easier than ever to understandwhen and why your views update.The timeline gives a quick overviewof when SwiftUI is doing work on the main thread,and when individual view updates take a long timeand put you at risk of a hitch or hang.The “View Body Updates” summary tells youhow many times each view in your app updated.If the number of updates to one of your views is much larger than you expect,open the cause-and-effect graph to help understand why.To learn more about SwiftUI’s performance improvements,see “What’s new in SwiftUI”.For more information on how to use the SwiftUI instrument,check out “Optimize SwiftUI performance with Instruments”.People love apps they can rely on throughout their day,and a crucial part of that reliability is excellent battery life.While debugging your app,perhaps you've noticed high energy impact in Xcode, signaling a problem.But finding the root cause can be tough.In these situations, what you really need is the ability to run your app,reproduce the issue, and record power metrics.The Power Profiler instrument is the perfect tool for this.It lets you profile your appand record power metrics which can then be visualized.The Power Profiler track shows system power usage,correlated with the thermal and charging states of the device,helping to identify unexpected power spikes.The process track shows the impact the application hason various device power subcomponentslike CPU, GPU, Display, and Networking.Power Profiler supports two modes of tracing:Tethered recording, with Instruments directly connected to the target device;And "passive" recording,where a trace can be initiated on a device from Developer Settings,without being tethered.The trace can then later be imported into Instruments for analysis.By recording stable workloads,you can use the Power Profiler instrumentto observe how your choice of algorithms and APIsaffects sustainability of a workload.Learn more by checking out “Profile and optimize power usage in your app”.While Instruments is greatfor analyzing the performance of your app during development,the Xcode Organizer allows you to monitor the power and performanceimpact of your shipping apps via metrics and diagnostics.The Organizer in Xcode 16 introduced a feature called Trending Insightsto Disk Write diagnostics, with a flame icon in the source list.These help call out issues that have increased in impact,that you may want to pay attention to.In this year’s Xcode, we’ve taken this one step furtherby bringing Trending Insights to Hang and Launch diagnostics as well,where the flame icon calls out Hang and Launch timesthat are trending in the wrong direction.Additionally, the Insights area now provides clarity about the trendby charting the increase across the last 5 app versions.This not only provides a starting point for performance optimizations,but also helps you understand where you could have introduced codethat led to the overall increase in impact.And now that you know what to prioritize,you can share a diagnostic report with your colleagues using URL sharing.Another area in the Organizer to help you understandhow well your app is performing across versions is Metrics.Metrics have been expanded in Xcode 26 with the addition of Recommendations.Metric Recommendations compare your app’s metrics with other sources –including similar apps and your app’s historical data –to provide an important reference point for understandinghow well your app is performing across its user base.In this example, our app’s launch time is measured at around 564 milliseconds.However, based on similar apps' metrics,Xcode is recommending that our app’s launch timeshould be closer to 425 milliseconds,which gives us a clear target to aim for.This year, metric recommendations are available for the Launch Time metric.Apple will enable recommendations for other metrics over time.Next, I’d like to talk about Xcode’s build system.In Xcode 16, we introduced Explicitly Built Modules,enabled for C and Objective-C code.In Xcode 26, we’re excited to announcethat we are enabling Explicitly Built Modules for Swift code by default.With Explicit Modules, Xcode splits upthe processing of each compilation unit into three phases:Scanning, building modules, and finally building the original source code.This separation gives the build system better control of module build tasksto optimize the build pipeline.Building explicit modules improves build efficiency and reliability,with more precise and deterministic sharing of modules.It also improves the speed of debugging Swift code,as the debugger can reuse the already built modules.For more information, refer to “Demystify explicitly built modules”.Earlier this year, Apple open sourced Swift Build,a powerful and extensible build enginethat is used by Xcode and Swift Playground,as well as the internal build process for Apple’s own operating systems.We've also been working to incorporate Swift Build into Swift Package Manager,to unify the build experience across Swift open source toolchains and Xcode.We’re also adding support for all platformssupported by the Swift ecosystem,including Linux, Windows, Android, and more.You can preview this new implementation on your own packagesusing the “build-system” option of the Swift command line tool.Or see your changes live in Xcodeusing the instructions in the Swift Build repository.For the first time, the community can contributeto the implementation of the build enginethat powers Xcode and the Swift ecosystem.To learn more about Swift Build or get involved in development,check out the repository on GitHub.In our interconnected world,users view security as an increasingly critical requirement for applications.Xcode’s new Enhanced Security capability provides your appswith the same protections used in Apple’s apps, such as pointer authentication.You can enable these security settings for your appby adding the “Enhanced Security” capabilityin the “Signing and Capabilities” editor.We recommend enabling it for applications with a significant attack surface,such as social media, messaging, image viewing, and browsing.Get more details about Enhanced Security in the Apple Developer documentation.Next, let’s talk about Testing.Xcode’s UI testing has had a significant upgrade this year.UI automation recording has been enhancedwith a completely new code generation system.This is great news, as I wanted to implement a UI test for Landmarks,to test the Collection editing UI.Let’s use the UI automation recording featureof Xcode 26 to build my test for me.I’ve already got a test target configured for this projectand a new test method ready to fill out.By placing the cursor in the body of the test method,Xcode reveals a “Start Recording” button in the editor gutter.We can hit that button to start a recording session.Xcode then prompts to confirm and lets me knowthat the file will be in read-only mode until the recording is complete.Now, Xcode prepares the session.It launches the app in the simulator, in recording mode.Now, I can perform the exact interactions that I want my test to perform.I’ll start by navigating to the “Collections” screen.And notice how Xcode is adding code to my test method for each of my interactions.Very cool!Next, I’ll add a new collection and switch it to “edit” mode.Editing a collection is the main purpose of this test.So I’ll interact with each of the fields on this screen, to edit the title,description, and add a landmark.This one looks perfect!That completes our steps to add and edit a new collection.Finally, as a simple verification of our edit,let’s select the landmark we added to the collection to navigate to its details.That’s all we need for this UI test.Back in the source editor,I’ll hit “Stop Recording” in the editor gutterto end the test recording session.Now, let’s use the test diamond to see our test in action.Notice how Xcode has generated concise code for all of our interactions.Plus, we get multiple identifier options for many elements.We can use those to fine tune how an element is identified in our tests.It’s so much easier to make a new UI testwhen you can simply perform the interactions in the appthat you want the test to perform.And that’s an example of recording a UI test in Xcode 26.Xcode takes care of all the heavy liftingof converting your interactions into the best possible test code.But UI testing code generation doesn’t stop there.The same code generation has been integratedinto the test report’s Automation Explorer.Here, I’ve got a Test Report open, containing a UI test failure.It looks like the test was trying to tap a TextFieldbut couldn’t find one with the specified identifier.On the right, the Automation Explorercontains a full video recording of the test.We can replay the whole test in real time, if we need to.The current video frame is showing the point when the failure occurred.We can certainly see a description field in the app’s UI.What’s awesome about UI testing is that Xcode records attributesabout every identifiable element while running a test.We can then inspect elements in the Automation Explorer after the fact.So let’s inspect the “description” element.Looking at the element’s details, it has the correct identifier,but its type is actually a Text View,not a Text Field, as the test was expecting.It looks like the app’s UI had been updatedto support multi-line descriptions.Helpfully, the correct code snippetto identify this element was generated for us.We can simply copy the code from the popoverand update our test to make the correction.And that’s the improved UI testing experience.In addition to enhanced UI recording,this year’s Xcode also has better device supportfor automated hardware interactions,including hardware keyboard and hardware button presses.All together these enhancements make UI testinga much more streamlined experience.So give it a try, add some UI tests to your project todayand take advantage of Xcode Cloud to run your tests autonomously.To learn a lot more,please see “Record, replay, and review: UI automation in Xcode”.UI testing is also great for measuring the responsiveness of your UI,using the “measure” API.In Xcode 26, we’ve expanded the APIby adding an XCTHitchMetricso you can now catch hitches in your app during testing.For example, as shown here, you could use XCTHitchMetricto test the scrolling animation performance of your app.XCTHitchMetric reports multiple metrics for your app’s hitch performance,such as Hitch Time Ratio.Hitch Time Ratio represents the total amount of time your app was hitchingover the duration of the measured portion of your test.For more information on hitches,see the tech talk “Explore UI animation hitches and the render loop”.Another great way to regression test your code is with Runtime API Checks.This year’s Xcode is bringing more Runtime API Checks to tests,configured in the Test Plan configuration editor.Tests can now surface framework runtime issuesas well as call out threading problems using the Thread Performance Checker.The Thread Performance Checker detects threading issues like priority inversionsand non-UI work on the main thread.Here, for example,Thread Performance Checker is notifying us of an APIthat shouldn’t be called on the main threadif we want to keep our app responsive.Test Plans also provide an option to fail a testif runtime API checks find any issues.Now your tests can provide you assurancethat your code continues to follow API best practices.Those are just some of the new and exciting features this year.Xcode 26 can help you be more efficient while writing code,can guide you as you build new features,and gives you new tools that make it easy to support more platforms and languages.It can help you whether you’re debugging at your desk,inspecting the performance of your app in the wild,or testing your user interfaces.Download Xcode 26 to create, build, and debug your code.And use Xcode Cloud to test and distribute your app.Ask us any questions you may have in the Developer Forums.And to learn more, please check out our release notes on developer.apple.com.Thanks for watching!

Hi, I’m Eliza. I work on Swift Previews.And I’m Chris.I work on Xcode.Developing great apps takes a lot of work, whether it’s writing code,exploring and prototyping new features,debugging, improving performance and more.We’re excited to share with you some of the awesome improvementsin Xcode this year to help support you in your app development.We’ll start with some optimizations to Xcode’s download size and performance.Then, we’ll explore improvements in the workspace and source editor,and try out some exciting new code intelligence features.Chris will then talk through some new features in debugging & performance,What’s new in builds, and wrap up with some updates in testing.Let’s get started with optimizations!Over the last few years we’ve been working to make Xcode smallerso you can get your tools even fasterand download only the components that you need.This year, Xcode is 24% smaller.Simulator runtimes no longer contain Intel support by default,and the Metal toolchain will only be downloaded if your project needs it.

Altogether, this year’s Xcode has a smaller download sizethan Xcode 6 did in 2014!We’ve also optimized text input in Xcode this year,improving typing latency in some complex expressions by up to 50%.

We’ve also made some substantial optimizationsto Xcode’s loading performance.It’s now 40% faster to load a workspace.For large projects, this makes a big difference.Which leads us to updates in the workspace and editing.There are tons of enhancements to the source editor in Xcode this year.Let’s start with editor tabs.This year’s Xcode improves the behavior of editor tabsto make them a lot more intuitive.

Just like in Safari, I can open a tab and decide where to go from there,using this new start page.

And I can pin a tab to fix it on a particular file.This puts me in control of exactly how many tabs I have.Whether that's just one, one for every file, or a perfectly curated set.

Now, let’s talk about search.When exploring an unfamiliar project, or even navigating a familiar one,it’s crucial to be able to search your code effectively.This year, Xcode has a really cool new search mode called “Multiple Words search”which uses search engine techniques to find clusters of words in your project.In this search mode, I can enter a set of words.

For example, here, I’m trying to find where in my project I’m creatingclipped resizable images.

Xcode will now find all the clusters of these words in proximity to each otheracross your documents, sorting the documents by relevance.

The clusters can span multiple lines and the search terms can appear in any order,making this a really powerful feature!There’s a big step forward this year for accessibility in Xcode.You can now easily use Voice Control to write Swift code, and you can pronouncethe Swift code just as you’d naturally read it aloud.In this mode, Voice Control understands Swift syntax.It will figure out where spaces should appear,whether expressions correspond to operatorsor should be camel-cased, and so on.To fully appreciate how cool this is, it’s best to see it in action.With Swift Mode for Voice Control,I can navigate and edit my Swift code just by speaking to my Mac.Let’s use this to add a field to our landmark inspectorfor the landmark’s continent.

“Start listening”“Swift mode”“Select labeled content”“Four”“Go to the end of the line”“New line, new line”“If let continent equals landmark dot continent""Open brace"“New line”“Labeled content paren quote continent quotecomma value colon continent”“Correct quote continent”“One”“Stop listening”Notice that the continent field now appears near the bottom of my preview,and I didn’t touch my keyboard once!Now, let’s talk about iterating on code.Using Previews has always been a great way to quickly iterate on your UI code.This year, we’re introducing a new macro called Playgroundwhich you can use to quickly iterate on any code.

As with previews, you can add a playground inline in your document,and the results of the code execution will appear in their own canvas tab.Let me show you a demo.I’ve noticed a bug in the Landmarks app where landmarksare showing up in the wrong place on the map.I’m going to use a playground to poke around at the landmark structand see if I can figure out what’s going on.

Importing the Playgrounds module gives me access to the playground macro.

Let’s load a sample landmark so we can examine its data.

In the canvas, I see an entry for each expression in my playground.I just have one, which is the landmark structure for the Grand Canyon,and I can see the values for each of its properties.Some of the property types have a Quick Look icon.Let’s look more closely at the coordinate property.

Okay, that seems odd...the Grand Canyon shouldn’t be inside a city.I can add another expression to my playground to get more informationabout the region for this landmark.As I modify the playground,expressions in it are re-run, and the canvas updates automatically.

Yeah… the Grand Canyon is definitely not in China.Let’s figure out what’s going on here.When we load landmarks from a file, we use a regular expressionto parse the location coordinates from a string.This is the regular expression we’re using.Maybe there’s a problem with it that’s causingour coordinates to be parsed incorrectly?Let’s investigate that in another playground.When I add a new playground I get a new tab in the canvas.

Let's add some code to this playground.

We’re going to call the function where that regular expression is defined.

I’m using a sample input string, and extracting some computed resultsinto local variables so they're easier to examine.Some types, such as regular expression match results,have custom visualizations in the canvas,and in this case, I can see that Xcodehighlights the match range in the original string.

The match range makes it clear that there was a problem capturing the minus sign.And now the bug makes sense,as the negative longitude would have been parsed as a positive number,putting the Grand Canyon in the wrong place.

I’m going to fix the expression, andif you watch the playground in the canvas while I do this,you’ll see that the results update immediately.I can see in the visualization that the minus signis now included in the range matched by the regular expression.

And if I switch back to the original playground,I see that the Grand Canyon is now in the right place!And that’s Playgrounds.They’re great for understanding existing code as well as for trying out new ideas.

And the new #Playground macro is also being open-sourced to bring the experienceto Swift developers writing for other platforms.Check out the post on Swift Forums and join in on the conversation!Now, let’s talk about icons.Icon Composer is a new app bundled with Xcode 26.

With Icon Composer, you can create beautifully designed, sophisticated,multi-layered icons that work across multiple platforms and software versions.

Over the last few years, we’ve made it easier to create icons for all platforms.But this year, icons don’t only differdepending on the platform you’re building for.They now vary in modes, including dark and tinted modeson iOS, iPadOS, and macOS.And there’s a new look for watchOS as well.

Now, all of this can be achieved in one single file using Icon Composer.

You can take advantage of the full range of our material effectsand even add dynamic properties to your layers,like blur, shadow, specular highlights, and translucency.Not only that, the tool is great for creating flat iconsthat are compatible with previous operating systems,web pages, or anywhere else you need them.

To learn more about app icons, and how to use Icon Composer,check out “Say hello to the new look of app icons”and “Create app icons with Icon Composer.”Bringing your app to more users around the globe is incredibly valuable.Supporting different languages helps people feel at home in your app.And with string catalogs, localization can be a breeze.String Catalogs have gotten some big enhancements this year,to make life easier for both developers and translators.

For developers, we’ve added type-safe Swift symbols for localized strings.

Developers wanting more precise control over strings can define them directlyin the String Catalog, which now produces Swift symbolsthat can be accessed in code.These symbols even appear as auto-complete suggestions!And to assist translators, String Catalogs can now automatically generate commentsthat describe string context.

Xcode accomplishes this by intelligently analyzing where and howa localized string is used in your project.

It then generates comments using the on-device model.

For more on string catalogs,please have a look at the code-along session “Explore localization with Xcode”.Which brings us to intelligence.Xcode is getting some additional exciting new intelligence features.Xcode can now use large language models such as ChatGPTto provide coding assistance.You can ask general questions about Swift — like“tell me about swift concurrency”.

And because of the integration with Xcode,the model can take your code into considerationand answer specific questions about your project,or even make changes on your behalf.

In addition, we’re introducing a handy lighter-weight menuthat you can use to automatically apply changes to selected code.When you bring up coding tools, you have quick access to common actions,or you can type a custom query into the text field.Let’s look at these features in more detail.This app has a view that shows my favorite landmark collections,but I’m not familiar with the code,and I don’t know where that’s implemented.So I’m going to ask Xcode.

Xcode sends the project context to the model,and it replies with an explanationthat describes the relevant source files and what they do.The model can also ask for more information from Xcodeabout additional context it needs while it’s coming up with an answer.

The “info” button in the transcript shows us the context that Xcode sent.

The response also contains linksso you can quickly navigate to any mentioned file.

This looks like the right one.This is a great way to explore an unfamiliar code base.

Now, let’s add a feature!Let’s ask Xcode to add ratings to landmark collections.

Here, I’m using the `@` characterto directly reference a symbol we want the model to modify.

Typing the ‘@‘ symbol into my prompt lets me reference symbols, source files,or any issues in my project that I want the response to focus on.This can be useful when you have specific changes in mind.I can even attach files for the query to reference.Images are especially useful,since many large language models can generate codefrom just a sketch of a user interface.The automatic context and code changes do the right thing out of the box,but if you can also have more control if you want to.This toggle controls whether Xcode includes informationabout your project with the query.If you were asking a general question about Swift, for example,you might choose to turn off project context.But most of the time you’d want to leave it on.This toggle lets you controlwhether to automatically apply any code changes in the response.If it’s off, you can review each change before deciding whether to apply it.Okay, it looks like the response is completeand all the changes have been made to my project.I can click to see a summary of the changesthat were made — these look good.

I can type a new message to continue the conversation.Let’s ask the model to add that rating to the user interface.

The model can figure out what ‘it’ refers to here,because new messages preserve the context of earlier queries and replies.

This change looks pretty good!I can continue making changes in the context of the previous ones.Let’s have a bit of fun and make it go to eleven.

Once again, the model knows what I mean by “it” here.

Ta-da!Now we have 11 stars!By default, changes are applied automatically to your code.But Xcode keeps a snapshot of your code before each change is applied,so you can easily view and unwind them using the modification historyin the conversation view.Here I can examine every line of codechanged during each stage of the conversation.

I can scrub back and forth through time to applyor revert individual sets of changes.In this case, I’m happy with all the changesso I’ll cancel out of the modification history.

So far, I’ve been using the code assistant to make changesthat affect multiple files in my project.When I want to focus on a particular section of code,I can also use coding tools right from my source editor.

Let’s use coding tools to add a playground that will exercise our Landmark struct.Coding tools has buttons for quick actions to apply to my code,or I can enter a custom query.In this case, let’s select the action to generate a playground.Because the model has access to the context —for newly generated code as well as for existing code —it can create playgrounds that exercise the code in interesting ways.Now we have a playground that lets me inspect a sample landmark!In addition to explaining or modifying code,Xcode is great at helping me fix issues in my code.For example, here I have an error where I’m trying to use a `ForEach` viewwith a type that doesn’t conform to `Identifiable`.There’s a new option this year to generate a fix —this will bring up the coding assistant.

Because the model has access to the type declarationas well as the place where the error is detected,it can figure out which file needs to be modified to fix the error.In this case, the fix was to add a protocol conformance in activity.swift.

And now the error is resolved.Xcode is also great at fixing other issues.For example, I find I sometimes let deprecation warnings linger in codebecause they’re not causing immediate problems.Now I can save time by asking Xcode to fix them for me!There are many ways to add a model in Xcode.First, you can enable ChatGPT with just a few clicks.You’ll get a limited number of requests each day,and you can bring your own ChatGPT account for even more requests.

If you’d like to use another provider, like Anthropic,you can simply enter your API keyand interact with models like Claude 4 Opus and Sonnet.

You can choose which models to show from each provider,and can mark your favorites for quick access.And you can also use local models,running on your Mac or private network, thanks to tools like Ollama and LM Studio!You can add as many providers as you want in Xcode’s preferences.

Once you’ve configured a set of models,you can quickly switch between themin the coding assistant when beginning a new conversation.So that’s a look through some of the new featuresin Xcode’s workspace and source editor,and how you can use code intelligence to get more creative and productive.Now, I’ll hand it over to Chris, to tell us about debugging and performance.Thanks, Eliza!Catching bugs and improving your app's performance are crucial stepsto providing a great app experience.This year, we have a few exciting updates,starting with the debugger.Debugging Swift concurrency code has gainedsome great livability improvements in this year’s Xcode.As you step through code running in a Swift task,Xcode now follows execution into asynchronous functions,even if that requires switching threads.And Xcode’s debugger UI will now show task IDs.Here, for example, the current Swift Taskis displayed in the backtrace view on the leftand in the Program Counter annotation on the right.And in the variables view you’ll see easy-to-readrepresentations of concurrency types,such as Tasks, TaskGroups, and actors.In this example, it’s much easier to see the Task variable’s properties,such as its priority and any child tasks.

Xcode 26 makes debugging Swift concurrency code easier than ever.For more information on Swift concurrency see “What’s New in Swift”.

If you’ve ever added functionality to your appthat requires accessing a private resource,like the user’s location or the camera,you may have experienced your app stopping abruptly in the debugger,with an error about a missing “usage description”.

“Usage descriptions” are required when accessing private resources,so the system can include them in an authorization prompt,to help the user know why the app is requesting access.This year’s Xcode now understandswhen an app has stopped due to a missing usage descriptionand explains what is missing.From the annotation, you can jump directly to documentation to learn more.But the quickest way to fix the issue is to use the new “Add” button,which will take you directly to the Signing & Capabilities editor.The necessary capability will be added for you,as the Signing & Capabilities editor in Xcode 26now supports editing many capabilities that require usage descriptions,so you can edit them all in one place.Xcode will take care of updating the underlying Info plist,build settings, or entitlements for you.

So now, all you need to do is enter your usage description.Then you can re-run and verify that the capabilitynow prompts for permission, as expected.Instruments is a powerful tool for analyzing the performance of your appsand ships as part of every Xcode install.For CPU analysis, Instruments contains some powerful tools,providing multiple options for profiling your code’s performanceon modern Apple silicon hardware.Previously,Instruments used sampling-based profilers to understand CPU usage,which are great choices for analyzing long-running workloads.

But what does it mean for a profiler to be sampling based?It literally means that the tool samples the CPUs periodically,expecting that call stacks sampled are responsiblefor the same relative CPU usage overall.

But sampling by its very nature is only an approximation of the full workload,which is why it is more practical for long-running workload analysis.In our illustration, the orange sections of executionwere not captured by sampling, for example.Recent Apple silicon devices can capture a processor tracewhere the CPU stores information about the code it runs,including the branches it takes, and the instructions it jumps to.The CPU streams this information to an area on the file systemso that it can be analyzed with the Processor Trace instrument.

Rather than periodic sampling,Processor Trace captures informationabout every low-level branching decision the CPU makes,on all running threads, with very little runtime overhead.This means that the Processor Trace timelinecan present a high-fidelity visualization of execution flow.Unlike traditional sampling profilers that can miss critical code pathsbetween sampling intervals,this tool reveals every branch taken and function called —including compiler-generated code, like ARC memory management in Swift.Processor Trace is a fundamental shift in how you can measure software performance,with every function call captured, on all threads, with little overhead.Processor Trace was introduced with Xcode 16.3and is supported by M4 and iPhone 16 devices.

Processor Trace is great for understanding the execution of your codeand where CPU time is being spent.In contrast, the significantly updated CPU Counters instrumentwill help you understand how your code is interacting with the CPU.

This tool will help guide you in making microarchitecture optimizations.

CPU Counters now uses preset modes that group related counters together,to provide a guided approach to learning about how your code is handled by the CPU.

These modes include a general CPU Bottlenecks mode,which is a good starting point for this type of analysis.

CPU Bottlenecks breaks down the CPU's sustainable instruction bandwidthinto either useful work, or bottlenecked for one of three broad reasons:Either the CPU had to wait for execution units or memory to become available;Or the CPU couldn’t deliver instructions quickly enough;Or the CPU incorrectly predicted future workand needed to get back on track.

In addition to the bottleneck analysis approach,the Instruction Characteristics and Metrics modesoffer a more traditional use of the countersto get absolute counts of consumption.These let you focus on tuning critical instruction sequencesby analyzing branches, cache behavior, and numerical operations directly.

CPU Counters also includes detailed documentationto help understand what the modes and counters represent.

To learn a lot more about Processor Trace and CPU Counterssee “Optimize CPU performance with Instruments”.SwiftUI makes it easier than ever to build highly interactive apps.For the best user experience, performance is critical.In this year’s OS releases we’ve made a number of improvementsto SwiftUI performance.For example, Lists can update up to 16 times fasterwithout any additional changes from your app.Even with these improvements,your app still might not be performing as well as you’d like it to,and you’ll want to find out why your views are updating frequently.

To help with that, the next-generation SwiftUI instrument included with Xcode 26,captures detailed information about the causes and effectsof SwiftUI updates.This makes it easier than ever to understandwhen and why your views update.The timeline gives a quick overviewof when SwiftUI is doing work on the main thread,and when individual view updates take a long timeand put you at risk of a hitch or hang.The “View Body Updates” summary tells youhow many times each view in your app updated.

If the number of updates to one of your views is much larger than you expect,open the cause-and-effect graph to help understand why.

To learn more about SwiftUI’s performance improvements,see “What’s new in SwiftUI”.For more information on how to use the SwiftUI instrument,check out “Optimize SwiftUI performance with Instruments”.

People love apps they can rely on throughout their day,and a crucial part of that reliability is excellent battery life.While debugging your app,perhaps you've noticed high energy impact in Xcode, signaling a problem.But finding the root cause can be tough.

In these situations, what you really need is the ability to run your app,reproduce the issue, and record power metrics.The Power Profiler instrument is the perfect tool for this.It lets you profile your appand record power metrics which can then be visualized.The Power Profiler track shows system power usage,correlated with the thermal and charging states of the device,helping to identify unexpected power spikes.The process track shows the impact the application hason various device power subcomponentslike CPU, GPU, Display, and Networking.

Power Profiler supports two modes of tracing:Tethered recording, with Instruments directly connected to the target device;And "passive" recording,where a trace can be initiated on a device from Developer Settings,without being tethered.The trace can then later be imported into Instruments for analysis.By recording stable workloads,you can use the Power Profiler instrumentto observe how your choice of algorithms and APIsaffects sustainability of a workload.Learn more by checking out “Profile and optimize power usage in your app”.While Instruments is greatfor analyzing the performance of your app during development,the Xcode Organizer allows you to monitor the power and performanceimpact of your shipping apps via metrics and diagnostics.

The Organizer in Xcode 16 introduced a feature called Trending Insightsto Disk Write diagnostics, with a flame icon in the source list.These help call out issues that have increased in impact,that you may want to pay attention to.

In this year’s Xcode, we’ve taken this one step furtherby bringing Trending Insights to Hang and Launch diagnostics as well,where the flame icon calls out Hang and Launch timesthat are trending in the wrong direction.Additionally, the Insights area now provides clarity about the trendby charting the increase across the last 5 app versions.This not only provides a starting point for performance optimizations,but also helps you understand where you could have introduced codethat led to the overall increase in impact.

And now that you know what to prioritize,you can share a diagnostic report with your colleagues using URL sharing.

Another area in the Organizer to help you understandhow well your app is performing across versions is Metrics.Metrics have been expanded in Xcode 26 with the addition of Recommendations.Metric Recommendations compare your app’s metrics with other sources –including similar apps and your app’s historical data –to provide an important reference point for understandinghow well your app is performing across its user base.In this example, our app’s launch time is measured at around 564 milliseconds.However, based on similar apps' metrics,Xcode is recommending that our app’s launch timeshould be closer to 425 milliseconds,which gives us a clear target to aim for.This year, metric recommendations are available for the Launch Time metric.Apple will enable recommendations for other metrics over time.Next, I’d like to talk about Xcode’s build system.In Xcode 16, we introduced Explicitly Built Modules,enabled for C and Objective-C code.In Xcode 26, we’re excited to announcethat we are enabling Explicitly Built Modules for Swift code by default.

With Explicit Modules, Xcode splits upthe processing of each compilation unit into three phases:Scanning, building modules, and finally building the original source code.

This separation gives the build system better control of module build tasksto optimize the build pipeline.

Building explicit modules improves build efficiency and reliability,with more precise and deterministic sharing of modules.It also improves the speed of debugging Swift code,as the debugger can reuse the already built modules.For more information, refer to “Demystify explicitly built modules”.

Earlier this year, Apple open sourced Swift Build,a powerful and extensible build enginethat is used by Xcode and Swift Playground,as well as the internal build process for Apple’s own operating systems.

We've also been working to incorporate Swift Build into Swift Package Manager,to unify the build experience across Swift open source toolchains and Xcode.We’re also adding support for all platformssupported by the Swift ecosystem,including Linux, Windows, Android, and more.You can preview this new implementation on your own packagesusing the “build-system” option of the Swift command line tool.Or see your changes live in Xcodeusing the instructions in the Swift Build repository.

For the first time, the community can contributeto the implementation of the build enginethat powers Xcode and the Swift ecosystem.To learn more about Swift Build or get involved in development,check out the repository on GitHub.

In our interconnected world,users view security as an increasingly critical requirement for applications.Xcode’s new Enhanced Security capability provides your appswith the same protections used in Apple’s apps, such as pointer authentication.You can enable these security settings for your appby adding the “Enhanced Security” capabilityin the “Signing and Capabilities” editor.

We recommend enabling it for applications with a significant attack surface,such as social media, messaging, image viewing, and browsing.

Get more details about Enhanced Security in the Apple Developer documentation.Next, let’s talk about Testing.Xcode’s UI testing has had a significant upgrade this year.UI automation recording has been enhancedwith a completely new code generation system.This is great news, as I wanted to implement a UI test for Landmarks,to test the Collection editing UI.Let’s use the UI automation recording featureof Xcode 26 to build my test for me.I’ve already got a test target configured for this projectand a new test method ready to fill out.

By placing the cursor in the body of the test method,Xcode reveals a “Start Recording” button in the editor gutter.We can hit that button to start a recording session.

Xcode then prompts to confirm and lets me knowthat the file will be in read-only mode until the recording is complete.

Now, Xcode prepares the session.It launches the app in the simulator, in recording mode.

Now, I can perform the exact interactions that I want my test to perform.

I’ll start by navigating to the “Collections” screen.

And notice how Xcode is adding code to my test method for each of my interactions.Very cool!Next, I’ll add a new collection and switch it to “edit” mode.

Editing a collection is the main purpose of this test.So I’ll interact with each of the fields on this screen, to edit the title,description, and add a landmark.

This one looks perfect!That completes our steps to add and edit a new collection.Finally, as a simple verification of our edit,let’s select the landmark we added to the collection to navigate to its details.

That’s all we need for this UI test.Back in the source editor,I’ll hit “Stop Recording” in the editor gutterto end the test recording session.

Now, let’s use the test diamond to see our test in action.

Notice how Xcode has generated concise code for all of our interactions.Plus, we get multiple identifier options for many elements.

We can use those to fine tune how an element is identified in our tests.It’s so much easier to make a new UI testwhen you can simply perform the interactions in the appthat you want the test to perform.

And that’s an example of recording a UI test in Xcode 26.Xcode takes care of all the heavy liftingof converting your interactions into the best possible test code.But UI testing code generation doesn’t stop there.The same code generation has been integratedinto the test report’s Automation Explorer.

Here, I’ve got a Test Report open, containing a UI test failure.It looks like the test was trying to tap a TextFieldbut couldn’t find one with the specified identifier.On the right, the Automation Explorercontains a full video recording of the test.We can replay the whole test in real time, if we need to.

The current video frame is showing the point when the failure occurred.We can certainly see a description field in the app’s UI.What’s awesome about UI testing is that Xcode records attributesabout every identifiable element while running a test.We can then inspect elements in the Automation Explorer after the fact.So let’s inspect the “description” element.Looking at the element’s details, it has the correct identifier,but its type is actually a Text View,not a Text Field, as the test was expecting.It looks like the app’s UI had been updatedto support multi-line descriptions.Helpfully, the correct code snippetto identify this element was generated for us.We can simply copy the code from the popoverand update our test to make the correction.

And that’s the improved UI testing experience.In addition to enhanced UI recording,this year’s Xcode also has better device supportfor automated hardware interactions,including hardware keyboard and hardware button presses.

All together these enhancements make UI testinga much more streamlined experience.So give it a try, add some UI tests to your project todayand take advantage of Xcode Cloud to run your tests autonomously.To learn a lot more,please see “Record, replay, and review: UI automation in Xcode”.

UI testing is also great for measuring the responsiveness of your UI,using the “measure” API.In Xcode 26, we’ve expanded the APIby adding an XCTHitchMetricso you can now catch hitches in your app during testing.For example, as shown here, you could use XCTHitchMetricto test the scrolling animation performance of your app.

XCTHitchMetric reports multiple metrics for your app’s hitch performance,such as Hitch Time Ratio.

Hitch Time Ratio represents the total amount of time your app was hitchingover the duration of the measured portion of your test.

For more information on hitches,see the tech talk “Explore UI animation hitches and the render loop”.

Another great way to regression test your code is with Runtime API Checks.This year’s Xcode is bringing more Runtime API Checks to tests,configured in the Test Plan configuration editor.

Tests can now surface framework runtime issuesas well as call out threading problems using the Thread Performance Checker.

The Thread Performance Checker detects threading issues like priority inversionsand non-UI work on the main thread.Here, for example,Thread Performance Checker is notifying us of an APIthat shouldn’t be called on the main threadif we want to keep our app responsive.

Test Plans also provide an option to fail a testif runtime API checks find any issues.Now your tests can provide you assurancethat your code continues to follow API best practices.Those are just some of the new and exciting features this year.Xcode 26 can help you be more efficient while writing code,can guide you as you build new features,and gives you new tools that make it easy to support more platforms and languages.It can help you whether you’re debugging at your desk,inspecting the performance of your app in the wild,or testing your user interfaces.

Download Xcode 26 to create, build, and debug your code.And use Xcode Cloud to test and distribute your app.Ask us any questions you may have in the Developer Forums.And to learn more, please check out our release notes on developer.apple.com.Thanks for watching!

5:25 -Using Playgrounds

5:30 -Using Playgrounds

5:37 -Using Playgrounds

6:10 -Using Playgrounds

6:33 -Regex to scan for floating point numbers

6:42 -Adding another playground

6:49 -Adding another playground

7:33 -Updated regular expression

18:49 -Checking for camera authorization

34:40 -Test scrolling animation performance with XCTHitchMetric

0:00 -IntroductionLearn about Xcode's improvements for app developers, including optimizations for download size and performance, enhancements to the workspace and source editor, new code intelligence features, debugging and performance tools, build updates, and testing improvements.0:49 -OptimizationsXcode features significant optimizations this year, resulting in a 24% smaller download size, achieved by removing default Intel support from Simulator runtimes and conditional downloads of the Metal toolchain. Text input is improved by up to 50% in complex expressions, and workspace loading performance is boosted by 40%, particularly benefiting large projects.1:42 -Workspace and editingThis year's Xcode release brings significant improvements to the source editor, enhancing user experience and productivity. The editor tabs now feature a new start page, similar to Safari, and allow users to pin tabs, providing greater control over the workspace.

The search functionality is revamped with the introduction of Multiple Words search. This new mode utilizes search engine techniques to find clusters of words in the project, enabling you to locate specific code snippets more efficiently, even if the search terms appear in different orders or across multiple lines.

Accessibility has also taken a major leap forward. Xcode now supports Swift Mode for Voice Control, allowing you to write and pronounce Swift code naturally. Voice Control understands Swift syntax, automatically inserting spaces and formatting code correctly, making it a powerful tool for developers with accessibility needs, or those who prefer voice-based input.

Beyond these core improvements, Xcode introduces a new macro called '#Playground', enabling you to iterate on any code quickly. You can add playgrounds inline in documents, and the results of code execution appear in a separate canvas tab, providing real-time feedback as code is modified.

A new app called Icon Composer is bundled with Xcode, simplifying the process of creating multilayered icons that work across various platforms and modes, such as dark and tinted.10:37 -IntelligenceXcode 26 integrates large language models like ChatGPT to enhance coding assistance. You can now ask general questions about Swift or specific questions about their projects, and the model can provide explanations, make changes, or generate code. 

A new lightweight menu allows you to automatically apply changes to selected code. The model can also analyze the context of the entire project, enabling it to understand references and make relevant modifications.

You have control over whether the system includes project context and whether it applies code changes  automatically. Xcode keeps snapshots of code before each change, allowing for easy review and reversal.

Beyond code explanation and modification, Xcode can now generate playgrounds, fix errors, and resolve deprecation warnings. You can choose from various language model providers, including ChatGPT, Anthropic, or local models, and switch between them easily within Xcode.17:47 -Debugging and performanceThe new Xcode introduces significant enhancements to debugging and performance analysis for app developers. 

Debugging Swift concurrency code is now more streamlined, with Xcode following execution into asynchronous functions, displaying task IDs, and providing easy-to-read representations of concurrency types. Xcode also now automatically identifies when an app stops due to a missing usage description for accessing private resources, offering a direct Add button to fix the issue in the Signing & Capabilities editor.

For performance analysis, there's an updated Instruments. The Processor Trace instrument, introduced in Xcode 16.3 and supported by M4 and iPhone 16 devices, captures every low-level branching decision the CPU makes, providing a high-fidelity visualization of execution flow. The CPU Counters instrument is also significantly updated, using preset modes to help you understand how your code interacts with the CPU, enabling microarchitecture optimizations and identifying bottlenecks. 

Instruments also includes new features for SwiftUI, enabling you to track view updates and identify performance bottlenecks. The Power Profiler instrument helps optimize battery life by recording power metrics and visualizing system power usage and the impact of the application on various device components.

The Xcode Organizer is updated with expanded Trending Insights, which highlights increasing performance issues like hangs and disk writes across app versions. Metrics are expanded to include Recommendations, comparing an app's performance with similar apps and historical data, providing clear targets for improvement, such as launch time optimization.27:50 -BuildsXcode 26 enhances build efficiency by enabling Explicitly Built Modules by default, improving reliability and debugging speed. Swift Build, the open source build engine, is being integrated into Swift Package Manager for cross-platform support and community contributions. Xcode also introduces Enhanced Security capabilities for apps, akin to those used in Apple's apps, to bolster protection against attacks.30:15 -TestingXcode's UI testing capabilities are also significantly improved. The new code-generation system enhances UI automation recording, allowing you to create tests more efficiently. 

By using the recording feature, you can interact with the app in Simulator, and Xcode automatically generates concise test code for each action. This capability streamlines the test-creation process, making it easier to build comprehensive UI tests.

The Automation Explorer in test reports further aids debugging by providing video recordings and element-inspection tools. Xcode also now includes expanded support for measuring UI responsiveness, detecting hitches, and performing runtime API checks, ensuring code adheres to best practices and remains responsive and stable.36:10 -Wrap-upXcode 26 enhances coding efficiency, feature building, and language support. It aids in debugging, performance inspection, and UI testing. You can download Xcode 26 and utilize Xcode Cloud for testing and distribution.

0:00 -Introduction

Learn about Xcode's improvements for app developers, including optimizations for download size and performance, enhancements to the workspace and source editor, new code intelligence features, debugging and performance tools, build updates, and testing improvements.

Learn about Xcode's improvements for app developers, including optimizations for download size and performance, enhancements to the workspace and source editor, new code intelligence features, debugging and performance tools, build updates, and testing improvements.

0:49 -Optimizations

Xcode features significant optimizations this year, resulting in a 24% smaller download size, achieved by removing default Intel support from Simulator runtimes and conditional downloads of the Metal toolchain. Text input is improved by up to 50% in complex expressions, and workspace loading performance is boosted by 40%, particularly benefiting large projects.

Xcode features significant optimizations this year, resulting in a 24% smaller download size, achieved by removing default Intel support from Simulator runtimes and conditional downloads of the Metal toolchain. Text input is improved by up to 50% in complex expressions, and workspace loading performance is boosted by 40%, particularly benefiting large projects.

1:42 -Workspace and editing

This year's Xcode release brings significant improvements to the source editor, enhancing user experience and productivity. The editor tabs now feature a new start page, similar to Safari, and allow users to pin tabs, providing greater control over the workspace.

The search functionality is revamped with the introduction of Multiple Words search. This new mode utilizes search engine techniques to find clusters of words in the project, enabling you to locate specific code snippets more efficiently, even if the search terms appear in different orders or across multiple lines.

Accessibility has also taken a major leap forward. Xcode now supports Swift Mode for Voice Control, allowing you to write and pronounce Swift code naturally. Voice Control understands Swift syntax, automatically inserting spaces and formatting code correctly, making it a powerful tool for developers with accessibility needs, or those who prefer voice-based input.

Beyond these core improvements, Xcode introduces a new macro called '#Playground', enabling you to iterate on any code quickly. You can add playgrounds inline in documents, and the results of code execution appear in a separate canvas tab, providing real-time feedback as code is modified.

A new app called Icon Composer is bundled with Xcode, simplifying the process of creating multilayered icons that work across various platforms and modes, such as dark and tinted.

This year's Xcode release brings significant improvements to the source editor, enhancing user experience and productivity. The editor tabs now feature a new start page, similar to Safari, and allow users to pin tabs, providing greater control over the workspace.

The search functionality is revamped with the introduction of Multiple Words search. This new mode utilizes search engine techniques to find clusters of words in the project, enabling you to locate specific code snippets more efficiently, even if the search terms appear in different orders or across multiple lines.

Accessibility has also taken a major leap forward. Xcode now supports Swift Mode for Voice Control, allowing you to write and pronounce Swift code naturally. Voice Control understands Swift syntax, automatically inserting spaces and formatting code correctly, making it a powerful tool for developers with accessibility needs, or those who prefer voice-based input.

Beyond these core improvements, Xcode introduces a new macro called '#Playground', enabling you to iterate on any code quickly. You can add playgrounds inline in documents, and the results of code execution appear in a separate canvas tab, providing real-time feedback as code is modified.

A new app called Icon Composer is bundled with Xcode, simplifying the process of creating multilayered icons that work across various platforms and modes, such as dark and tinted.

10:37 -Intelligence

Xcode 26 integrates large language models like ChatGPT to enhance coding assistance. You can now ask general questions about Swift or specific questions about their projects, and the model can provide explanations, make changes, or generate code. 

A new lightweight menu allows you to automatically apply changes to selected code. The model can also analyze the context of the entire project, enabling it to understand references and make relevant modifications.

You have control over whether the system includes project context and whether it applies code changes  automatically. Xcode keeps snapshots of code before each change, allowing for easy review and reversal.

Beyond code explanation and modification, Xcode can now generate playgrounds, fix errors, and resolve deprecation warnings. You can choose from various language model providers, including ChatGPT, Anthropic, or local models, and switch between them easily within Xcode.

Xcode 26 integrates large language models like ChatGPT to enhance coding assistance. You can now ask general questions about Swift or specific questions about their projects, and the model can provide explanations, make changes, or generate code. 

A new lightweight menu allows you to automatically apply changes to selected code. The model can also analyze the context of the entire project, enabling it to understand references and make relevant modifications.

You have control over whether the system includes project context and whether it applies code changes  automatically. Xcode keeps snapshots of code before each change, allowing for easy review and reversal.

Beyond code explanation and modification, Xcode can now generate playgrounds, fix errors, and resolve deprecation warnings. You can choose from various language model providers, including ChatGPT, Anthropic, or local models, and switch between them easily within Xcode.

17:47 -Debugging and performance

The new Xcode introduces significant enhancements to debugging and performance analysis for app developers. 

Debugging Swift concurrency code is now more streamlined, with Xcode following execution into asynchronous functions, displaying task IDs, and providing easy-to-read representations of concurrency types. Xcode also now automatically identifies when an app stops due to a missing usage description for accessing private resources, offering a direct Add button to fix the issue in the Signing & Capabilities editor.

For performance analysis, there's an updated Instruments. The Processor Trace instrument, introduced in Xcode 16.3 and supported by M4 and iPhone 16 devices, captures every low-level branching decision the CPU makes, providing a high-fidelity visualization of execution flow. The CPU Counters instrument is also significantly updated, using preset modes to help you understand how your code interacts with the CPU, enabling microarchitecture optimizations and identifying bottlenecks. 

Instruments also includes new features for SwiftUI, enabling you to track view updates and identify performance bottlenecks. The Power Profiler instrument helps optimize battery life by recording power metrics and visualizing system power usage and the impact of the application on various device components.

The Xcode Organizer is updated with expanded Trending Insights, which highlights increasing performance issues like hangs and disk writes across app versions. Metrics are expanded to include Recommendations, comparing an app's performance with similar apps and historical data, providing clear targets for improvement, such as launch time optimization.

The new Xcode introduces significant enhancements to debugging and performance analysis for app developers. 

Debugging Swift concurrency code is now more streamlined, with Xcode following execution into asynchronous functions, displaying task IDs, and providing easy-to-read representations of concurrency types. Xcode also now automatically identifies when an app stops due to a missing usage description for accessing private resources, offering a direct Add button to fix the issue in the Signing & Capabilities editor.

For performance analysis, there's an updated Instruments. The Processor Trace instrument, introduced in Xcode 16.3 and supported by M4 and iPhone 16 devices, captures every low-level branching decision the CPU makes, providing a high-fidelity visualization of execution flow. The CPU Counters instrument is also significantly updated, using preset modes to help you understand how your code interacts with the CPU, enabling microarchitecture optimizations and identifying bottlenecks. 

Instruments also includes new features for SwiftUI, enabling you to track view updates and identify performance bottlenecks. The Power Profiler instrument helps optimize battery life by recording power metrics and visualizing system power usage and the impact of the application on various device components.

The Xcode Organizer is updated with expanded Trending Insights, which highlights increasing performance issues like hangs and disk writes across app versions. Metrics are expanded to include Recommendations, comparing an app's performance with similar apps and historical data, providing clear targets for improvement, such as launch time optimization.

27:50 -Builds

Xcode 26 enhances build efficiency by enabling Explicitly Built Modules by default, improving reliability and debugging speed. Swift Build, the open source build engine, is being integrated into Swift Package Manager for cross-platform support and community contributions. Xcode also introduces Enhanced Security capabilities for apps, akin to those used in Apple's apps, to bolster protection against attacks.

Xcode 26 enhances build efficiency by enabling Explicitly Built Modules by default, improving reliability and debugging speed. Swift Build, the open source build engine, is being integrated into Swift Package Manager for cross-platform support and community contributions. Xcode also introduces Enhanced Security capabilities for apps, akin to those used in Apple's apps, to bolster protection against attacks.

30:15 -Testing

Xcode's UI testing capabilities are also significantly improved. The new code-generation system enhances UI automation recording, allowing you to create tests more efficiently. 

By using the recording feature, you can interact with the app in Simulator, and Xcode automatically generates concise test code for each action. This capability streamlines the test-creation process, making it easier to build comprehensive UI tests.

The Automation Explorer in test reports further aids debugging by providing video recordings and element-inspection tools. Xcode also now includes expanded support for measuring UI responsiveness, detecting hitches, and performing runtime API checks, ensuring code adheres to best practices and remains responsive and stable.

Xcode's UI testing capabilities are also significantly improved. The new code-generation system enhances UI automation recording, allowing you to create tests more efficiently. 

By using the recording feature, you can interact with the app in Simulator, and Xcode automatically generates concise test code for each action. This capability streamlines the test-creation process, making it easier to build comprehensive UI tests.

The Automation Explorer in test reports further aids debugging by providing video recordings and element-inspection tools. Xcode also now includes expanded support for measuring UI responsiveness, detecting hitches, and performing runtime API checks, ensuring code adheres to best practices and remains responsive and stable.

36:10 -Wrap-up

Xcode 26 enhances coding efficiency, feature building, and language support. It aids in debugging, performance inspection, and UI testing. You can download Xcode 26 and utilize Xcode Cloud for testing and distribution.

Xcode 26 enhances coding efficiency, feature building, and language support. It aids in debugging, performance inspection, and UI testing. You can download Xcode 26 and utilize Xcode Cloud for testing and distribution.

## Code Samples

```swift
import
 Playgrounds
```

```swift
#
Playground
 {
  
}
```

```swift
let
 landmark 
=
 
Landmark
.exampleData.first
```

```swift
let
 region 
=
 landmark
?
.coordinateRegion
```

```swift
func
 
scanForFloatingPointNumbers
() -> [
Regex
<
Substring
>.
Match
] {
    
return
 
self
.matches(of: 
/
[
0
-
9
]
*
[.][
0
-
9
]
+/
)
}
```

```swift
let
 string 
=
 
"lon: -113.16096, lat: 36.21904"


let
 longitude 
=
 string.scanForFloatingPointNumbers().first

let
 latitude 
=
 string.scanForFloatingPointNumbers().last
```

```swift
func
 
scanForFloatingPointNumbers
() -> [
Regex
<
Substring
>.
Match
] {
    
return
 
self
.matches(of: 
/
[
+-
]
?
[
0
-
9
]
*
[.][
0
-
9
]
+/
)
}
```

```swift
// Checking for camera authorization



var
 isCameraAuthorized: 
Bool
 {
    
get
 
async
 {
        
let
 status 
=
 
AVCaptureDevice
.authorizationStatus(for: .video)

        
// Determine if the user previously authorized camera access.

        
var
 isAuthorized 
=
 status 
==
 .authorized

        
// If the system hasn't determined the user's authorization status,

        
// explicitly prompt them for approval.

        
if
 status 
==
 .notDetermined {
            isAuthorized 
=
 
await
 
AVCaptureDevice
.requestAccess(for: .video)
        }

        
return
 isAuthorized
    }
}
```

```swift
// XCTHitchMetric



func
 
testScrollingAnimationPerformance
() 
throws
 {
    
// Custom performance test measure options.

    
let
 measureOptions 
=
 
XCTMeasureOptions
()
    measureOptions.invocationOptions 
=
 .manuallyStop

    
// App being tested.

    
let
 app 
=
 
XCUIApplication
()

    
// Launch app and get reference to scroll view.

    app.launch()
    
let
 scrollView 
=
 app.scrollViews.firstMatch

    measure(metrics: [
XCTHitchMetric
(application: app)], options: measureOptions) {
        scrollView.swipeUp(velocity: .fast)
        stopMeasuring()
        scrollView.swipeDown(velocity: .fast)
    }
}
```


# Wwdc2025 205

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Summary

Transcript

Discover Metal 4Learn how to get started leveraging the powerful new features of Metal 4 in your existing Metal apps. We'll cover how Metal enables you to get the most out of Apple silicon and program the hardware more efficiently. You'll also learn how Metal 4 provides you with new capabilities to integrate machine learning into your Metal code.Chapters0:00 -Intro1:44 -Encode commands4:03 -Manage resources10:43 -Compile shaders13:52 -Integrate machine learning17:26 -Optimize with MetalFX19:22 -Start adopting Metal 423:08 -Next stepsResourcesProcessing a texture in a compute functionUnderstanding the Metal 4 core APIUsing a Render Pipeline to Render PrimitivesUsing the Metal 4 compilation APIHD VideoSD VideoRelated VideosWWDC25Combine Metal 4 machine learning and graphicsExplore Metal 4 gamesGo further with Metal 4 gamesLevel up your gamesWhat’s new in Metal rendering for immersive apps

Learn how to get started leveraging the powerful new features of Metal 4 in your existing Metal apps. We'll cover how Metal enables you to get the most out of Apple silicon and program the hardware more efficiently. You'll also learn how Metal 4 provides you with new capabilities to integrate machine learning into your Metal code.

0:00 -Intro

1:44 -Encode commands

4:03 -Manage resources

10:43 -Compile shaders

13:52 -Integrate machine learning

17:26 -Optimize with MetalFX

19:22 -Start adopting Metal 4

23:08 -Next steps

Processing a texture in a compute function

Understanding the Metal 4 core API

Using a Render Pipeline to Render Primitives

Using the Metal 4 compilation API

HD VideoSD Video

HD Video

SD Video

Combine Metal 4 machine learning and graphics

Explore Metal 4 games

Go further with Metal 4 games

Level up your games

What’s new in Metal rendering for immersive apps

Search this video…Hello and welcome.I’m Aaron and I’m excited to sharethe details of a big update to the Metal API.Metal is Apple’s low-level graphics and compute API.It has powered multiple generations of complex applications,including the latest games like Cyberpunk 2077,as well as powerful pro apps.Metal has become central to the way developers think about renderingand compute on Apple platforms.Building on over a decade of experienceMetal 4 takes the API to the next level,enabling developers to deliver the most demanding games and pro apps.Metal 4 is built with the next generations of games,graphics and compute apps in mind.It unlocks the full performance potential of Apple silicon,while also ensuring you’ll find it familiarand approachable if you’re comingfrom other graphics and compute APIs like DirectX.Metal 4 is part of the same Metal frameworkthat you may already have in your appand it’s supported by devices equipped with the Apple M1 and later,as well as the A14 Bionic and later.Metal 4 starts with an entirely new command structurewith explicit memory management,and it changes the way resources are managedto enable richer and more complex visuals.Shader compilation is quicker with more optionsso your app can reduce redundant compilation,and machine learning can now be integrated seamlesslywith the rest of your Metal app.New built-in solutions are also availablevia MetalFX to boost your app’s performance.I’ll also show you how to get started with your Metal 4 adoption.I'll start with how your app encodes and submits commands.Metal is represented in the system by a Metal device,which the OS provides to your app.Once you have a Metal device, you can create command queuesto send work to the hardware.And command buffers that contain the work to be sent.Command encoders allow you to encode commands into those command buffers.You can take advantage of Metal 4using the same Metal device that your app uses today.Metal 4 provides a new but familiar model for encoding commands,and introduces new versions of the rest of these objects.Those changes start with the new MTL4CommandQueuewhich your app can obtain using the Metal device.Metal 4 decouples command buffers from the queue that will use them,so your app requests for a MTL4CommandBuffer from the device as well.Command buffers are independent of one another,making it easy for your app to encode them in parallel.Apps take advantage of encoders for different types of commandsincluding draws, dispatches, blits, and building acceleration structures.Metal 4 consolidates existing command encoders.With the new unified compute encoder,your app can also manage blitand acceleration structure command encoding.This reduces the total number of encoders required.There’s a new MTL4RenderCommandEncoder as well.It features an attachment map that your app can use to map logical shader outputsto physical color attachments.Your app can configure the attachment map of a single render encoderwith all the necessary color attachments, and can swap between them on the fly.This saves you the need to allocate additional render encoders,saving your app memory and unnecessary code.Your app can use any combination of the available encoder types to encode commandsinto command buffers.Command buffers are backed by memory.As your app encodes commands, data is written into this memory.In Metal 4, this memory is managed by a MTL4CommandAllocator.Use the device to create a command allocator to take direct controlof your app’s command buffer memory use.Memory management is essential to maximizing what modern apps can fit intotheir available system resources.And those apps are using more resources than ever.Your app manages resources differently in Metal 4.Metal uses two fundamental types of resources.Metal buffers store generic data formatted by your app and Metal textures storeimage formatted data.In the past, applications used fewer resources,sometimes even a single buffer and texture per object.And then applications added more textures to improve the level of surface details.And then, to introduce more variety in their rendering,they also added more geometry.Modern applications continued the trend, and they pulled in more and more resourcesto support complex new use cases.But while the number of resources increased,APIs only exposed a fixed set of resource bind points,to set the resources for each draw or dispatch.Historically each draw would typically only use a few.For example, this bunny has just a texture and a buffer for its geometry.And then for each draw,each object can change buffers for geometry and texturesto alter surface appearance.However, as draw call counts increasedand shaders became more complex,the impact of managing bind points per draw added to the CPU time.So, applications changed to bindless,where the bound resources are moved to another buffer to store the bindings.That way, the app just needs to bind a single argument buffer for each object,or even the entire scene.And this means you can greatly reduce the number of bind points you need.To help your app avoid paying for extra bind points,Metal 4 provides a new MTL4ArgumentTable typeto store the binding points your app needs.Argument tables are specified for each stage on an encoder,but can be shared across stages.You create tables with a size based on the bind points that your application needs.For example, in the bindless case,the argument table just needs one buffer binding.The GPU also needs to be able to access all of these resources.This is where residency comes in.Apple silicon provides you with a large, unified memory space.You can use it to store all your app’s resources,but Metal still needs to know what resources to make resident.In Metal 4, your app uses residency sets to specify the resourcesthat Metal should make resident.This is to ensure they are accessible to the hardware.Residency sets are easy to integrate into per frame encodingand committing of command buffers.You just need to make surethat the residency set contains all the required resourcesfor the command buffer you commit.But since the residency set contents rarely change,populating the residency set can be done at app start up.And once the set is created, you can add it to a Metal 4 command queue.All command buffers committed to that queue will then include those resources.If you need to make any updates,this should be a much lower cost at runtime.For applications which stream resources in and out on a separate thread,you can move the cost of updating the residency setto that thread and update the residency setin parallel with encoding.A great example of a game that benefitedfrom residency sets is Control Ultimate Edition.The Technical Publishing Director of Remedy Entertainment,Tuukka Taipalvesi, had this to sayControl Ultimate Edition found residency sets easy to integrate.While separating resources into different residency sets based on useand managing resource residency on a background thread,we saw significant reductions in the overheads of managing residencyand lower memory usage when ray-tracing is disabled.Delivering beautiful games like Control requires more resources than ever.You may even require more memory than is available,especially when targeting a range of devices.To get the most out of the available memory,your app can dynamically control how resources use that memory.This requires fine grained control of how memory is allocated to resources,since not all the resources are required at once.Apps can adjust quality by controlling the resident level of detail to supportthe same content across a wider variety of devices.Your app can do this using placement sparse resources.Metal 4 supports buffers and textures allocated as placement sparse resources.These resources are allocated without any pages to store their data.With placement sparse resources, pages come from a placement heap.Your app allocates pages from the placement heapto provide storage for the resource contents.With Metal 4's focus on concurrency by default,you need to ensure that updates to resources are synchronized.To simplify synchronization,Metal 4 introduces a Barrier API that provides low overhead,stage-to-stage synchronization that maps well to barriers in other APIs.You can see barriers in action in the Metal 4 sample,“processing a texture in a compute function”.The app starts with a colored image,applies a compute shader that converts it to greyscale,and then renders that converted texture to the screen.These steps have a dependency on the shared resource:the output of the texture processing.The sample ensures that resource writes and readsoccur in the correct order, using Metal 4 barriers.Without synchronization, these steps could run in any order,and that will either mean using the wrong texture contentsor even worse, if the two steps overlap,that will result in a corrupted output.To get the order right, the app uses a barrier.Barriers work stage to stage.So you'll need to consider which stage each operation runs in,based on the stages in the encoder.Processing the texture will execute on a compute command encoderas a dispatch stage operation.And the render will be part of a render command encoder,which reads the texture in a fragment operation.So the barrier you need is a dispatch to fragment barrier,that waits for dispatch stage work to completebefore letting any fragment work start.Using barriers effectively is important to achieve the best performance in your app,especially with a large number of resources.In addition to resources, modern apps also manage a massive number of shaders.Those shaders need to be compiled before they can be sent to the hardware,to render and compute for your app.Shaders are written in the Metal Shading Language,and lowered to Metal IR.The IR is then compiled to GPU binaries that can be natively executedby the hardware.As the developer, you have control over when shader compilation occurs.The Metal device provides an interface to send shadersto the OS for compilation by the CPU.Metal 4 manages compilation with dedicated compilation contexts.The new MTL4Compiler interface is now separate from the device.Your app uses the device to allocate the compiler interface.The interface provides clear,explicit control of when your app performs compilation on the CPU.You can also leverage the MTL4Compiler to take advantage of scheduling improvementsin the shader compilation stack.The MTL4Compiler inherits the quality of service classassigned to the thread requesting compilation.When multiple threads compile at the same time,the OS will prioritize requests from higher priority threadsto ensure your app’s most important shaders are processed firstbefore moving on to other compilations.Explicit control of shader compilation is important,since modern apps have more shaders than ever.During pipeline state generation,your app must compile each shader the first timebefore GPU work can proceed.Sometimes, pipelines share common Metal IR.For example, your app may apply different color statesto render with differing transparency.And that same situation may apply to other sets of pipelines as well.With Metal 4, you can optimize for this case,so you can reduce the time spentin shader compilation.Render pipelines can now use flexible render pipeline statesto build common Metal IR once.This creates an unspecialized pipeline.Your app then specializes the pipeline with the intended color state.Metal will re-use the compiled Metal IRto efficiently create a specialized pipeline to execute.Flexible render pipeline states save compilation time when re-using Metal IRacross shader pipelines.Your app creates an unspecialized pipeline oncebefore specializing it for each of the necessary color states.You can repeat this process for other pipelines that share Metal IR,and share the compilation results from eachto reduce the time your app spends compiling shaders.On-device compilation still costs CPU time.The most performant path is still to eliminate on-device compilation entirely.Metal 4 streamlines the harvesting of pipeline configurations.For more information on how to take advantageof Metal 4’s compilation workflow,as well as more details on command encoding,follow-up and Explore Metal 4 games.Metal 4 makes it easier than ever to integrate machine learning,which opens up entirely new possibilities for your app.Rendering techniques like upscaling, asset compression, animation blending,and neural shading, each benefit from the targeted application of machine learning.To apply these techniques efficiently,apps need to operate on complicated data sets and structures.Buffers are flexible, but leave much of the heavy lifting to the appand textures aren’t a great fit.Metal 4 adds support for tensors,a fundamental machine learning resource type,supported across all contexts.Metal tensors are multi-dimensional data containers.They are extendable well beyond two dimensions,providing the flexibility to describe the data layoutnecessary for practical machine learning usage.Metal 4 integrates tensors directly into the API…as well as into the Metal shading language.Tensors offload the complex indexing into multidimensional data,so your Metal 4 app can focus on using themto apply machine learning in novel ways.To make that even easier, Metal 4 expands the set of supported command encoders.The new machine learning command encoderenables you to execute large-scale networksdirectly within your Metal app.Machine learning encoders function in a similar wayto existing Metal encoder types.Tensors are consumed as resources mapped into an argument table.Encoding is done to the same Metal 4 command buffers, and it supports barriersfor synchronization with your other Metal 4 encoders.Metal 4 machine learning encoders are compatible with networks expressedin the existing CoreML package format.Use the Metal toolchain to convert these into a Metal package,and then feed the network directly to your encoder.The new machine learning encoder is perfect for large networksthat need command level interleaving with the rest of your Metal app.If you have smaller networks, Metal 4 also gives you the flexibility to integratethem directly into your existing shader pipelines.For example, neural material evaluation replaces traditional material textureswith latent texture data.Your app samples those latent textures to create input tensors,performs inference using the sampled values,and uses the final output to perform shading.Splitting each step into its own pipeline is inefficient,since each step needs to sync tensors from device memory,operate on them, and sync outputs back for later operations.To get the best performance,your app should combine these steps into a single shader dispatch,so that each operation can share common thread memory.Implementing inference is a complex task,but Metal 4 has you covered with Metal performance primitives.Metal performance primitives are shader primitives designedto execute complex calculations,and they can natively operate on tensors.Each one is optimized to run blazingly fast on Apple silicon.Tensor ops are perfect for embedding small networks into your shaders.Your app can take advantage of them as part of the Metal Shading Language,and when you do, the OS shader compiler inlines shader code,optimized for the device being used, directly into your shader.To learn more about how to use Metal’s new machine learning capabilities,you can watch Combine Metal 4 machine learning and graphics.Metal 4 provides you with all the tools you needto integrate cutting edge Machine Learning techniques.You can also take advantageof production-ready solutions built into MetalFX.Apple devices have incredible,high resolution screens that are perfect for showcasing your amazing games.MetalFX allows your app to deliver high resolutions at even greater refresh rateswhen rendering complex scenes with realistic reflections.Rendering high resolution images can consume the GPUfor a significant period of time.Instead, your app can render low resolution imagesand use MetalFX to upscale them.The combined time to render your final image is reducedand that means your app can save time for each frame it renders.You can use the time saved to render the next frame sooner.And if you want to hit the highest refresh rates without sacrificing quality,MetalFX has a great solution built right in.This year, MetalFX adds support for frame interpolation.Your app can use it to generate intermediate frames in much less timethan it would take to render each frame from scratch.You can use those intermediate frames to achieve even higher frame rates.Ray tracing is another techniquethat apps use to achieve realistic rendering results,by tracing rays from the camera to a light source.However if too few rays are cast,the resulting image will be too noisy to use.MetalFX also now supports denoising during the upscale process,so your app can remove the noise from images rendered with fewer rays,and deliver full-size results.MetalFX helps you produce high quality results your players will love,at increased refresh rates.Your game can combine it with Metal 4 ray tracing to achieve incredible results.You can learn more about how to use these featuresin “Go further with Metal 4 games."Your app can combine all of these features to do incredible things.And Metal 4 is designed to make porting both approachable and modular.An app is composed of several key categories of functionality, including:how it compiles shaders,how it encodes and submits commands to the hardware,and finally, its management of resources.Each of these can be approached separately in their own distinct phases.Compilation is perhaps the easiest first step to take.You can allocate a Metal 4 compiler and insert itinto your app's compilation flows to improve quality-of-service.Once you’ve adopted the new compilation interface,your app can integrate flexible render pipelinesto speed up render pipeline compilationor take advantage of harvesting improvementsto improve ahead of time compilation.Whether you adopt the new compiler or not,your app can also benefit from generating commands with Metal 4.With Metal 4’s command encoding and generation model,you can take greater control of your memory allocations.You can also leverage native parallel encoding across encoder typesto get encoding done quickerand Metal 4’s completely new set of machine learning capabilitiesunlock new possibilities for your rendering pipelines.Your app can adopt the machine learning encoder, or shader ML,based on the network you want to integrate.You can then take it a step further with Metal 4’s resource management.Residency sets are an easy win.Integrate them to simplify the process of residency management.Barriers allow your app to synchronize resourceaccess across different passes efficientlyAnd placement sparse resources enable youto build resource streaming into your Metal app.As the developer, you are in the best positionto judge how to make your app better.And Metal 4 gives you the flexibility to adopt the new functionalitywhere you need it most.Placement sparse is a great example of a feature that enables a specific use case.Here’s how you can integrate it into your existing Metal app.Your Metal app already commits work using the existing Metal command queuewhile placement sparse mapping operationsrequire a MTL4CommandQueue.You can use a Metal event to synchronize workbetween your app’s Metal and MTL4CommandQueue.The first signal event call unblocks the MTL4CommandQueueto update placement sparse resource mappings.A second signal event call notifies your appto continue the render work using the placement sparse resources.You can use the same Metal event from before.Your app should submit work that doesn’t depend on those resourcesbefore waiting on the event to ensure the hardware remains fully utilized.Metal comes with an advanced set of developer tools to help you debugand optimize your Metal apps.And this year, these same tools come with support for Metal 4.API and Shader Validation save you valuable timeby identifying common problems.and the comprehensive Metal Debugger helps you deep dive into your Metal 4 usage.The Metal performance HUD providesa real-time overlay to monitor your app’s performance,and Metal System Trace lets you dig into performance traces from your app.You can learn about all of these tools and find their documentationon the Apple Developer website.Also, check out "Level up your games" for great techniques to debugand further optimize your games.Xcode 26 also comes with a new Metal 4 template built in.Start a new project and select Game templatesbefore choosing Metal 4 as your game technology.With the built in Xcode template,it’s easy to get a basic render going and start your Metal 4 journey.Now that you’ve discovered what Metal 4 can do,you’re ready to learn how to apply it to the needs of your app.If you’re developing a game,you can dive In and explore how to useMetal 4’s new command encoding and compilation features.After that, you can learn how to go furtherand optimize your game with MetalFX,and discover how to take advantage of Metal 4 ray tracing.Or, you can learn how to use Metal 4to combine Machine Learning and graphics in your Metal app.Metal 4 enables a new generation of apps and games with an incredible feature set.You’ve only just scratched the surfacewith the foundation you'll need to dive in.You can start using Metal 4 in your newor existing apps with the upcoming developer beta.The sample code is a great example of how to start your Metal 4 adoption.It’s available now.Thanks for watching!

Hello and welcome.I’m Aaron and I’m excited to sharethe details of a big update to the Metal API.

Metal is Apple’s low-level graphics and compute API.It has powered multiple generations of complex applications,including the latest games like Cyberpunk 2077,as well as powerful pro apps.

Metal has become central to the way developers think about renderingand compute on Apple platforms.

Building on over a decade of experienceMetal 4 takes the API to the next level,enabling developers to deliver the most demanding games and pro apps.Metal 4 is built with the next generations of games,graphics and compute apps in mind.It unlocks the full performance potential of Apple silicon,while also ensuring you’ll find it familiarand approachable if you’re comingfrom other graphics and compute APIs like DirectX.

Metal 4 is part of the same Metal frameworkthat you may already have in your appand it’s supported by devices equipped with the Apple M1 and later,as well as the A14 Bionic and later.Metal 4 starts with an entirely new command structurewith explicit memory management,and it changes the way resources are managedto enable richer and more complex visuals.

Shader compilation is quicker with more optionsso your app can reduce redundant compilation,and machine learning can now be integrated seamlesslywith the rest of your Metal app.

New built-in solutions are also availablevia MetalFX to boost your app’s performance.

I’ll also show you how to get started with your Metal 4 adoption.

I'll start with how your app encodes and submits commands.

Metal is represented in the system by a Metal device,which the OS provides to your app.

Once you have a Metal device, you can create command queuesto send work to the hardware.And command buffers that contain the work to be sent.Command encoders allow you to encode commands into those command buffers.You can take advantage of Metal 4using the same Metal device that your app uses today.

Metal 4 provides a new but familiar model for encoding commands,and introduces new versions of the rest of these objects.

Those changes start with the new MTL4CommandQueuewhich your app can obtain using the Metal device.Metal 4 decouples command buffers from the queue that will use them,so your app requests for a MTL4CommandBuffer from the device as well.Command buffers are independent of one another,making it easy for your app to encode them in parallel.Apps take advantage of encoders for different types of commandsincluding draws, dispatches, blits, and building acceleration structures.

Metal 4 consolidates existing command encoders.With the new unified compute encoder,your app can also manage blitand acceleration structure command encoding.This reduces the total number of encoders required.There’s a new MTL4RenderCommandEncoder as well.It features an attachment map that your app can use to map logical shader outputsto physical color attachments.Your app can configure the attachment map of a single render encoderwith all the necessary color attachments, and can swap between them on the fly.This saves you the need to allocate additional render encoders,saving your app memory and unnecessary code.Your app can use any combination of the available encoder types to encode commandsinto command buffers.Command buffers are backed by memory.As your app encodes commands, data is written into this memory.

In Metal 4, this memory is managed by a MTL4CommandAllocator.

Use the device to create a command allocator to take direct controlof your app’s command buffer memory use.

Memory management is essential to maximizing what modern apps can fit intotheir available system resources.

And those apps are using more resources than ever.

Your app manages resources differently in Metal 4.

Metal uses two fundamental types of resources.Metal buffers store generic data formatted by your app and Metal textures storeimage formatted data.

In the past, applications used fewer resources,sometimes even a single buffer and texture per object.And then applications added more textures to improve the level of surface details.And then, to introduce more variety in their rendering,they also added more geometry.

Modern applications continued the trend, and they pulled in more and more resourcesto support complex new use cases.

But while the number of resources increased,APIs only exposed a fixed set of resource bind points,to set the resources for each draw or dispatch.

Historically each draw would typically only use a few.For example, this bunny has just a texture and a buffer for its geometry.And then for each draw,each object can change buffers for geometry and texturesto alter surface appearance.

However, as draw call counts increasedand shaders became more complex,the impact of managing bind points per draw added to the CPU time.

So, applications changed to bindless,where the bound resources are moved to another buffer to store the bindings.That way, the app just needs to bind a single argument buffer for each object,or even the entire scene.And this means you can greatly reduce the number of bind points you need.

To help your app avoid paying for extra bind points,Metal 4 provides a new MTL4ArgumentTable typeto store the binding points your app needs.Argument tables are specified for each stage on an encoder,but can be shared across stages.You create tables with a size based on the bind points that your application needs.For example, in the bindless case,the argument table just needs one buffer binding.

The GPU also needs to be able to access all of these resources.This is where residency comes in.Apple silicon provides you with a large, unified memory space.You can use it to store all your app’s resources,but Metal still needs to know what resources to make resident.In Metal 4, your app uses residency sets to specify the resourcesthat Metal should make resident.This is to ensure they are accessible to the hardware.

Residency sets are easy to integrate into per frame encodingand committing of command buffers.You just need to make surethat the residency set contains all the required resourcesfor the command buffer you commit.But since the residency set contents rarely change,populating the residency set can be done at app start up.

And once the set is created, you can add it to a Metal 4 command queue.All command buffers committed to that queue will then include those resources.If you need to make any updates,this should be a much lower cost at runtime.For applications which stream resources in and out on a separate thread,you can move the cost of updating the residency setto that thread and update the residency setin parallel with encoding.

A great example of a game that benefitedfrom residency sets is Control Ultimate Edition.The Technical Publishing Director of Remedy Entertainment,Tuukka Taipalvesi, had this to sayControl Ultimate Edition found residency sets easy to integrate.While separating resources into different residency sets based on useand managing resource residency on a background thread,we saw significant reductions in the overheads of managing residencyand lower memory usage when ray-tracing is disabled.

Delivering beautiful games like Control requires more resources than ever.You may even require more memory than is available,especially when targeting a range of devices.To get the most out of the available memory,your app can dynamically control how resources use that memory.

This requires fine grained control of how memory is allocated to resources,since not all the resources are required at once.

Apps can adjust quality by controlling the resident level of detail to supportthe same content across a wider variety of devices.Your app can do this using placement sparse resources.

Metal 4 supports buffers and textures allocated as placement sparse resources.

These resources are allocated without any pages to store their data.

With placement sparse resources, pages come from a placement heap.

Your app allocates pages from the placement heapto provide storage for the resource contents.

With Metal 4's focus on concurrency by default,you need to ensure that updates to resources are synchronized.To simplify synchronization,Metal 4 introduces a Barrier API that provides low overhead,stage-to-stage synchronization that maps well to barriers in other APIs.

You can see barriers in action in the Metal 4 sample,“processing a texture in a compute function”.The app starts with a colored image,applies a compute shader that converts it to greyscale,and then renders that converted texture to the screen.

These steps have a dependency on the shared resource:the output of the texture processing.The sample ensures that resource writes and readsoccur in the correct order, using Metal 4 barriers.

Without synchronization, these steps could run in any order,and that will either mean using the wrong texture contentsor even worse, if the two steps overlap,that will result in a corrupted output.

To get the order right, the app uses a barrier.

Barriers work stage to stage.So you'll need to consider which stage each operation runs in,based on the stages in the encoder.

Processing the texture will execute on a compute command encoderas a dispatch stage operation.

And the render will be part of a render command encoder,which reads the texture in a fragment operation.So the barrier you need is a dispatch to fragment barrier,that waits for dispatch stage work to completebefore letting any fragment work start.Using barriers effectively is important to achieve the best performance in your app,especially with a large number of resources.

In addition to resources, modern apps also manage a massive number of shaders.Those shaders need to be compiled before they can be sent to the hardware,to render and compute for your app.Shaders are written in the Metal Shading Language,and lowered to Metal IR.The IR is then compiled to GPU binaries that can be natively executedby the hardware.As the developer, you have control over when shader compilation occurs.The Metal device provides an interface to send shadersto the OS for compilation by the CPU.

Metal 4 manages compilation with dedicated compilation contexts.The new MTL4Compiler interface is now separate from the device.Your app uses the device to allocate the compiler interface.The interface provides clear,explicit control of when your app performs compilation on the CPU.

You can also leverage the MTL4Compiler to take advantage of scheduling improvementsin the shader compilation stack.The MTL4Compiler inherits the quality of service classassigned to the thread requesting compilation.

When multiple threads compile at the same time,the OS will prioritize requests from higher priority threadsto ensure your app’s most important shaders are processed firstbefore moving on to other compilations.

Explicit control of shader compilation is important,since modern apps have more shaders than ever.

During pipeline state generation,your app must compile each shader the first timebefore GPU work can proceed.

Sometimes, pipelines share common Metal IR.For example, your app may apply different color statesto render with differing transparency.

And that same situation may apply to other sets of pipelines as well.With Metal 4, you can optimize for this case,so you can reduce the time spentin shader compilation.

Render pipelines can now use flexible render pipeline statesto build common Metal IR once.

This creates an unspecialized pipeline.Your app then specializes the pipeline with the intended color state.Metal will re-use the compiled Metal IRto efficiently create a specialized pipeline to execute.

Flexible render pipeline states save compilation time when re-using Metal IRacross shader pipelines.

Your app creates an unspecialized pipeline oncebefore specializing it for each of the necessary color states.

You can repeat this process for other pipelines that share Metal IR,and share the compilation results from eachto reduce the time your app spends compiling shaders.

On-device compilation still costs CPU time.

The most performant path is still to eliminate on-device compilation entirely.Metal 4 streamlines the harvesting of pipeline configurations.For more information on how to take advantageof Metal 4’s compilation workflow,as well as more details on command encoding,follow-up and Explore Metal 4 games.Metal 4 makes it easier than ever to integrate machine learning,which opens up entirely new possibilities for your app.

Rendering techniques like upscaling, asset compression, animation blending,and neural shading, each benefit from the targeted application of machine learning.To apply these techniques efficiently,apps need to operate on complicated data sets and structures.

Buffers are flexible, but leave much of the heavy lifting to the appand textures aren’t a great fit.

Metal 4 adds support for tensors,a fundamental machine learning resource type,supported across all contexts.

Metal tensors are multi-dimensional data containers.

They are extendable well beyond two dimensions,providing the flexibility to describe the data layoutnecessary for practical machine learning usage.

Metal 4 integrates tensors directly into the API…as well as into the Metal shading language.Tensors offload the complex indexing into multidimensional data,so your Metal 4 app can focus on using themto apply machine learning in novel ways.To make that even easier, Metal 4 expands the set of supported command encoders.

The new machine learning command encoderenables you to execute large-scale networksdirectly within your Metal app.

Machine learning encoders function in a similar wayto existing Metal encoder types.

Tensors are consumed as resources mapped into an argument table.Encoding is done to the same Metal 4 command buffers, and it supports barriersfor synchronization with your other Metal 4 encoders.

Metal 4 machine learning encoders are compatible with networks expressedin the existing CoreML package format.Use the Metal toolchain to convert these into a Metal package,and then feed the network directly to your encoder.The new machine learning encoder is perfect for large networksthat need command level interleaving with the rest of your Metal app.If you have smaller networks, Metal 4 also gives you the flexibility to integratethem directly into your existing shader pipelines.For example, neural material evaluation replaces traditional material textureswith latent texture data.Your app samples those latent textures to create input tensors,performs inference using the sampled values,and uses the final output to perform shading.

Splitting each step into its own pipeline is inefficient,since each step needs to sync tensors from device memory,operate on them, and sync outputs back for later operations.

To get the best performance,your app should combine these steps into a single shader dispatch,so that each operation can share common thread memory.Implementing inference is a complex task,but Metal 4 has you covered with Metal performance primitives.Metal performance primitives are shader primitives designedto execute complex calculations,and they can natively operate on tensors.Each one is optimized to run blazingly fast on Apple silicon.

Tensor ops are perfect for embedding small networks into your shaders.Your app can take advantage of them as part of the Metal Shading Language,and when you do, the OS shader compiler inlines shader code,optimized for the device being used, directly into your shader.

To learn more about how to use Metal’s new machine learning capabilities,you can watch Combine Metal 4 machine learning and graphics.

Metal 4 provides you with all the tools you needto integrate cutting edge Machine Learning techniques.You can also take advantageof production-ready solutions built into MetalFX.Apple devices have incredible,high resolution screens that are perfect for showcasing your amazing games.MetalFX allows your app to deliver high resolutions at even greater refresh rateswhen rendering complex scenes with realistic reflections.

Rendering high resolution images can consume the GPUfor a significant period of time.Instead, your app can render low resolution imagesand use MetalFX to upscale them.The combined time to render your final image is reducedand that means your app can save time for each frame it renders.You can use the time saved to render the next frame sooner.And if you want to hit the highest refresh rates without sacrificing quality,MetalFX has a great solution built right in.

This year, MetalFX adds support for frame interpolation.

Your app can use it to generate intermediate frames in much less timethan it would take to render each frame from scratch.You can use those intermediate frames to achieve even higher frame rates.

Ray tracing is another techniquethat apps use to achieve realistic rendering results,by tracing rays from the camera to a light source.However if too few rays are cast,the resulting image will be too noisy to use.

MetalFX also now supports denoising during the upscale process,so your app can remove the noise from images rendered with fewer rays,and deliver full-size results.MetalFX helps you produce high quality results your players will love,at increased refresh rates.Your game can combine it with Metal 4 ray tracing to achieve incredible results.You can learn more about how to use these featuresin “Go further with Metal 4 games."Your app can combine all of these features to do incredible things.And Metal 4 is designed to make porting both approachable and modular.An app is composed of several key categories of functionality, including:how it compiles shaders,how it encodes and submits commands to the hardware,and finally, its management of resources.Each of these can be approached separately in their own distinct phases.Compilation is perhaps the easiest first step to take.You can allocate a Metal 4 compiler and insert itinto your app's compilation flows to improve quality-of-service.

Once you’ve adopted the new compilation interface,your app can integrate flexible render pipelinesto speed up render pipeline compilationor take advantage of harvesting improvementsto improve ahead of time compilation.

Whether you adopt the new compiler or not,your app can also benefit from generating commands with Metal 4.

With Metal 4’s command encoding and generation model,you can take greater control of your memory allocations.You can also leverage native parallel encoding across encoder typesto get encoding done quickerand Metal 4’s completely new set of machine learning capabilitiesunlock new possibilities for your rendering pipelines.

Your app can adopt the machine learning encoder, or shader ML,based on the network you want to integrate.

You can then take it a step further with Metal 4’s resource management.

Residency sets are an easy win.Integrate them to simplify the process of residency management.Barriers allow your app to synchronize resourceaccess across different passes efficientlyAnd placement sparse resources enable youto build resource streaming into your Metal app.As the developer, you are in the best positionto judge how to make your app better.And Metal 4 gives you the flexibility to adopt the new functionalitywhere you need it most.Placement sparse is a great example of a feature that enables a specific use case.Here’s how you can integrate it into your existing Metal app.Your Metal app already commits work using the existing Metal command queuewhile placement sparse mapping operationsrequire a MTL4CommandQueue.

You can use a Metal event to synchronize workbetween your app’s Metal and MTL4CommandQueue.

The first signal event call unblocks the MTL4CommandQueueto update placement sparse resource mappings.A second signal event call notifies your appto continue the render work using the placement sparse resources.You can use the same Metal event from before.

Your app should submit work that doesn’t depend on those resourcesbefore waiting on the event to ensure the hardware remains fully utilized.

Metal comes with an advanced set of developer tools to help you debugand optimize your Metal apps.And this year, these same tools come with support for Metal 4.

API and Shader Validation save you valuable timeby identifying common problems.and the comprehensive Metal Debugger helps you deep dive into your Metal 4 usage.The Metal performance HUD providesa real-time overlay to monitor your app’s performance,and Metal System Trace lets you dig into performance traces from your app.

You can learn about all of these tools and find their documentationon the Apple Developer website.Also, check out "Level up your games" for great techniques to debugand further optimize your games.Xcode 26 also comes with a new Metal 4 template built in.Start a new project and select Game templatesbefore choosing Metal 4 as your game technology.With the built in Xcode template,it’s easy to get a basic render going and start your Metal 4 journey.

Now that you’ve discovered what Metal 4 can do,you’re ready to learn how to apply it to the needs of your app.If you’re developing a game,you can dive In and explore how to useMetal 4’s new command encoding and compilation features.

After that, you can learn how to go furtherand optimize your game with MetalFX,and discover how to take advantage of Metal 4 ray tracing.Or, you can learn how to use Metal 4to combine Machine Learning and graphics in your Metal app.Metal 4 enables a new generation of apps and games with an incredible feature set.You’ve only just scratched the surfacewith the foundation you'll need to dive in.You can start using Metal 4 in your newor existing apps with the upcoming developer beta.The sample code is a great example of how to start your Metal 4 adoption.

It’s available now.

Thanks for watching!

0:00 -IntroApple's Metal API gets a major upgrade with Metal 4, built with the next generations of games, graphics and compute apps in mind. It offers explicit memory management, more robust resource management, faster shader compilation, seamless ML integration, and new MetalFX performance features. Metal 4 is compatible with M1 (and later) and A14 Bionic (and later) Apple chips. and builds upon the existing Metal framework.1:44 -Encode commandsYou can take advantage of Metal 4 using the same MTLDevice that your app uses today. Metal 4 introduces new objects for greater flexibility, such as ‘MTL4CommandAllocator’ for direct control of the command buffer memory and ‘MTL4RenderCommandEncoder’ with an attachment map that maps logical shader outputs to physical color attachments. Your app can configure and swap between color attachments using a single render encoder, saving memory and code.4:03 -Manage resourcesMetal 4 optimizes resource management for modern applications, which are using significantly more buffers and textures than ever before. With the new MTL4ArgumentTable type, you can store the binding points to the resources your app needs. Use residency sets to specify the resources that Metal should make resident to the GPU. Populating the residency set can be done at app start up, and later updates come with a minimal CPU cost. Metal 4 buffers and textures can be allocated as placement sparse resources, giving you fine-grained control of how memory is allocated to those resources. Metal 4 also introduces a low-overhead barrier API for stage-to-stage synchronization of resources.10:43 -Compile shadersMetal 4 introduces the new MTL4Compiler interface, which provides you with explicit control over when your app performs shader compilation on the CPU. With new flexible render pipeline states, you can create an unspecialized pipeline which can then be specialized by re-using common Metal IR for different color states, reducing the time your app spends compiling shaders.13:52 -Integrate machine learningMetal 4 makes it easier than ever to integrate machine learning into your apps and games. Rendering techniques like upscaling, asset compression, animation blending, and neural shading all benefit. Metal 4 adds support for tensors, multi-dimensional data containers specifically designed for machine learning, tensors directly into the API as well as in the Metal shading language.17:26 -Optimize with MetalFXMetalFX allows your app to deliver high resolutions at even greater refresh rates when rendering complex scenes with realistic reflections. Your app can render low-resolution images, and MetalFX will upscale them. MetalFX also adds support for frame interpolation, which your app can use to generate intermediate frames much faster than generating them from scratch, so you can achieve even higher frame rates. For ray-traced scenes, MetalFX also now supports denoising during the upscale process, so your app can deliver full-size results from images rendered with fewer rays.19:22 -Start adopting Metal 4Metal 4 is designed to make porting both approachable and modular. You can adopt it into your existing Metal app or game using a modular approach. Focus on the area that will deliver the most impact: how it compiles shaders, how it encodes and submits commands to the hardware, or its management of resources. For many, residency sets are an easy win. Placement sparse is also a great example of a feature that enables a specific use case, and it’s simple to integrate it into an existing Metal app. Along the way, use Metal’s advanced set of developer tools which support Metal 4, helping you debug and optimize your Metal apps.

Beyond compilation, Metal 4 offers command encoding and generation models that provide greater control over memory allocations, enable native parallel encoding, and introduce machine learning capabilities for optimizing rendering pipelines.

Resource management in Metal 4 is also simplified through features like residency sets, barriers, and placement sparse resources, which allow for efficient resource streaming.

Metal 4 comes with an advanced set of developer tools for debugging, optimization, and performance monitoring. Xcode 26 includes a new Metal 4 template, making it easy to get started with building and optimizing Metal 4 apps.23:08 -Next stepsMetal 4 enables a new generation of apps and games with an incredible feature set. The sample code, a great example of how to start your Metal 4 adoption, is available now.

0:00 -Intro

Apple's Metal API gets a major upgrade with Metal 4, built with the next generations of games, graphics and compute apps in mind. It offers explicit memory management, more robust resource management, faster shader compilation, seamless ML integration, and new MetalFX performance features. Metal 4 is compatible with M1 (and later) and A14 Bionic (and later) Apple chips. and builds upon the existing Metal framework.

Apple's Metal API gets a major upgrade with Metal 4, built with the next generations of games, graphics and compute apps in mind. It offers explicit memory management, more robust resource management, faster shader compilation, seamless ML integration, and new MetalFX performance features. Metal 4 is compatible with M1 (and later) and A14 Bionic (and later) Apple chips. and builds upon the existing Metal framework.

1:44 -Encode commands

You can take advantage of Metal 4 using the same MTLDevice that your app uses today. Metal 4 introduces new objects for greater flexibility, such as ‘MTL4CommandAllocator’ for direct control of the command buffer memory and ‘MTL4RenderCommandEncoder’ with an attachment map that maps logical shader outputs to physical color attachments. Your app can configure and swap between color attachments using a single render encoder, saving memory and code.

You can take advantage of Metal 4 using the same MTLDevice that your app uses today. Metal 4 introduces new objects for greater flexibility, such as ‘MTL4CommandAllocator’ for direct control of the command buffer memory and ‘MTL4RenderCommandEncoder’ with an attachment map that maps logical shader outputs to physical color attachments. Your app can configure and swap between color attachments using a single render encoder, saving memory and code.

4:03 -Manage resources

Metal 4 optimizes resource management for modern applications, which are using significantly more buffers and textures than ever before. With the new MTL4ArgumentTable type, you can store the binding points to the resources your app needs. Use residency sets to specify the resources that Metal should make resident to the GPU. Populating the residency set can be done at app start up, and later updates come with a minimal CPU cost. Metal 4 buffers and textures can be allocated as placement sparse resources, giving you fine-grained control of how memory is allocated to those resources. Metal 4 also introduces a low-overhead barrier API for stage-to-stage synchronization of resources.

Metal 4 optimizes resource management for modern applications, which are using significantly more buffers and textures than ever before. With the new MTL4ArgumentTable type, you can store the binding points to the resources your app needs. Use residency sets to specify the resources that Metal should make resident to the GPU. Populating the residency set can be done at app start up, and later updates come with a minimal CPU cost. Metal 4 buffers and textures can be allocated as placement sparse resources, giving you fine-grained control of how memory is allocated to those resources. Metal 4 also introduces a low-overhead barrier API for stage-to-stage synchronization of resources.

10:43 -Compile shaders

Metal 4 introduces the new MTL4Compiler interface, which provides you with explicit control over when your app performs shader compilation on the CPU. With new flexible render pipeline states, you can create an unspecialized pipeline which can then be specialized by re-using common Metal IR for different color states, reducing the time your app spends compiling shaders.

Metal 4 introduces the new MTL4Compiler interface, which provides you with explicit control over when your app performs shader compilation on the CPU. With new flexible render pipeline states, you can create an unspecialized pipeline which can then be specialized by re-using common Metal IR for different color states, reducing the time your app spends compiling shaders.

13:52 -Integrate machine learning

Metal 4 makes it easier than ever to integrate machine learning into your apps and games. Rendering techniques like upscaling, asset compression, animation blending, and neural shading all benefit. Metal 4 adds support for tensors, multi-dimensional data containers specifically designed for machine learning, tensors directly into the API as well as in the Metal shading language.

Metal 4 makes it easier than ever to integrate machine learning into your apps and games. Rendering techniques like upscaling, asset compression, animation blending, and neural shading all benefit. Metal 4 adds support for tensors, multi-dimensional data containers specifically designed for machine learning, tensors directly into the API as well as in the Metal shading language.

17:26 -Optimize with MetalFX

MetalFX allows your app to deliver high resolutions at even greater refresh rates when rendering complex scenes with realistic reflections. Your app can render low-resolution images, and MetalFX will upscale them. MetalFX also adds support for frame interpolation, which your app can use to generate intermediate frames much faster than generating them from scratch, so you can achieve even higher frame rates. For ray-traced scenes, MetalFX also now supports denoising during the upscale process, so your app can deliver full-size results from images rendered with fewer rays.

MetalFX allows your app to deliver high resolutions at even greater refresh rates when rendering complex scenes with realistic reflections. Your app can render low-resolution images, and MetalFX will upscale them. MetalFX also adds support for frame interpolation, which your app can use to generate intermediate frames much faster than generating them from scratch, so you can achieve even higher frame rates. For ray-traced scenes, MetalFX also now supports denoising during the upscale process, so your app can deliver full-size results from images rendered with fewer rays.

19:22 -Start adopting Metal 4

Metal 4 is designed to make porting both approachable and modular. You can adopt it into your existing Metal app or game using a modular approach. Focus on the area that will deliver the most impact: how it compiles shaders, how it encodes and submits commands to the hardware, or its management of resources. For many, residency sets are an easy win. Placement sparse is also a great example of a feature that enables a specific use case, and it’s simple to integrate it into an existing Metal app. Along the way, use Metal’s advanced set of developer tools which support Metal 4, helping you debug and optimize your Metal apps.

Beyond compilation, Metal 4 offers command encoding and generation models that provide greater control over memory allocations, enable native parallel encoding, and introduce machine learning capabilities for optimizing rendering pipelines.

Resource management in Metal 4 is also simplified through features like residency sets, barriers, and placement sparse resources, which allow for efficient resource streaming.

Metal 4 comes with an advanced set of developer tools for debugging, optimization, and performance monitoring. Xcode 26 includes a new Metal 4 template, making it easy to get started with building and optimizing Metal 4 apps.

Metal 4 is designed to make porting both approachable and modular. You can adopt it into your existing Metal app or game using a modular approach. Focus on the area that will deliver the most impact: how it compiles shaders, how it encodes and submits commands to the hardware, or its management of resources. For many, residency sets are an easy win. Placement sparse is also a great example of a feature that enables a specific use case, and it’s simple to integrate it into an existing Metal app. Along the way, use Metal’s advanced set of developer tools which support Metal 4, helping you debug and optimize your Metal apps.

Beyond compilation, Metal 4 offers command encoding and generation models that provide greater control over memory allocations, enable native parallel encoding, and introduce machine learning capabilities for optimizing rendering pipelines.

Resource management in Metal 4 is also simplified through features like residency sets, barriers, and placement sparse resources, which allow for efficient resource streaming.

Metal 4 comes with an advanced set of developer tools for debugging, optimization, and performance monitoring. Xcode 26 includes a new Metal 4 template, making it easy to get started with building and optimizing Metal 4 apps.

23:08 -Next steps

Metal 4 enables a new generation of apps and games with an incredible feature set. The sample code, a great example of how to start your Metal 4 adoption, is available now.

Metal 4 enables a new generation of apps and games with an incredible feature set. The sample code, a great example of how to start your Metal 4 adoption, is available now.

## Code Samples


# Wwdc2025 256

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Summary

Transcript

Code

What’s new in SwiftUILearn what's new in SwiftUI to build great apps for any Apple platform. We'll explore how to give your app a brand new look and feel with Liquid Glass. Discover how to boost performance with framework enhancements and new instruments, and integrate advanced capabilities like web content and rich text editing. We'll also show you how SwiftUI is expanding to more places, including laying out views in three dimensions.Chapters0:00 -Introduction1:22 -Make the new design shine6:59 -Framework foundations14:33 -SwiftUI across the system20:04 -Expand SwiftUI views25:01 -Next stepsResourcesAdopting Liquid GlassApplying Liquid Glass to custom viewsdragContainer(for:in:selection:_:)draggable(containerItemID:)Human Interface GuidelinesPopulating SwiftUI menus with adaptive controlsHD VideoSD VideoRelated VideosWWDC25Better together: SwiftUI and RealityKitBring Swift Charts to the third dimensionBuild a SwiftUI app with the new designCode-along: Cook up a rich text experience in SwiftUI with AttributedStringCode-along: Explore localization with XcodeCustomize your app for Assistive AccessElevate the design of your iPad appEmbracing Swift concurrencyExplore concurrency in SwiftUIMeet SwiftUI spatial layoutMeet WebKit for SwiftUIOptimize SwiftUI performance with InstrumentsSet the scene with SwiftUI in visionOSWhat’s new in Metal rendering for immersive appsWhat’s new in visionOS 26What’s new in widgets

Learn what's new in SwiftUI to build great apps for any Apple platform. We'll explore how to give your app a brand new look and feel with Liquid Glass. Discover how to boost performance with framework enhancements and new instruments, and integrate advanced capabilities like web content and rich text editing. We'll also show you how SwiftUI is expanding to more places, including laying out views in three dimensions.

0:00 -Introduction

1:22 -Make the new design shine

6:59 -Framework foundations

14:33 -SwiftUI across the system

20:04 -Expand SwiftUI views

25:01 -Next steps

Adopting Liquid Glass

Applying Liquid Glass to custom views

dragContainer(for:in:selection:_:)

draggable(containerItemID:)

Human Interface Guidelines

Populating SwiftUI menus with adaptive controls

HD VideoSD Video

HD Video

SD Video

Better together: SwiftUI and RealityKit

Bring Swift Charts to the third dimension

Build a SwiftUI app with the new design

Code-along: Cook up a rich text experience in SwiftUI with AttributedString

Code-along: Explore localization with Xcode

Customize your app for Assistive Access

Elevate the design of your iPad app

Embracing Swift concurrency

Explore concurrency in SwiftUI

Meet SwiftUI spatial layout

Meet WebKit for SwiftUI

Optimize SwiftUI performance with Instruments

Set the scene with SwiftUI in visionOS

What’s new in Metal rendering for immersive apps

What’s new in visionOS 26

What’s new in widgets

Search this video…Hi, I'm Anna.And I'm Peter.We're engineers on the SwiftUI team.We’re stoked to talk to you about what’s new in SwiftUI.From low level performance improvementsall the way up through the buttons in your user interface,there are some major improvements to share across the system.It’s easier to interact with text and web-based content,and SwiftUI is in even more places.One of mine and Anna’s greatest loves right below SwiftUIis taking pictures while hiking.Peter and I have built an app to help us plan and share our trips.It uses a ton of the enhancements to SwiftUIto make it look and feel great.First, I’ll show off all the new system featuresand how we made our app shine with them.I'll share enhancements to performance, animations, and layout.Peter will take you through the new places you can use SwiftUIthroughout all of Apple’s platforms.Finally, he’ll highlight expanded features in SwiftUI views,including support for web content and rich text.Let’s get started,with how you can make your app truly shine with a new design.The new design system enables a bright and fluid experiencethat's consistent across Apple platforms.After Peter and I re-compile our app, it gets the brand new appearance.The structure of our app hasn't changed,but navigation containers have been updated for the new design.On iPad and macOS, our app sidebar has a glassy appearancethat reflects the content around it.Tab bars have also been updated.On iPhone, they have a new, more compact appearance.Beyond tab bars, most toolbar items now appear in Liquid Glass.During navigation transitions, these items can even morph.Check it out.Our app uses the new toolbar spacer API to adjust the sections of toolbar items.We use a fixed spacerto separate the up-down buttons from the settings button.To make toolbar items more prominent, Liquid Glass in toolbars supports tinting.Peter and I apply a bordered prominent button stylewith a tint color to get this effect.When people scroll down in our app, the toolbar now applies a blur effectto the bar content on the edge that’s being scrolled.This scroll edge effect ensures our bar content remains legibleregardless of whatever is underneath.To find that next trip, people often search for it.Search is now bottom aligned on iPhone, which makes it more ergonomic to reach.Our existing code places the searchable modifieron the outside of the NavigationSplitView.Peter and I didn’t have to make any code changes to get the bottom aligned search.With this same placement on iPad,our app gets the new search appearance in the top trailing corner.With searchable, it’s never been faster to find what you’re looking for.For tab-based apps where search is a destination,the Search tab now appears separated from the rest of the tabs in the tab barand morphs into the search field.Set your tab as having a search role to get the updated appearance.Controls throughout the system also feel fresh,like toggles, segmented pickers, and sliders.Our custom views aren't left out either.There are APIs to let them take advantage of the new design too.We apply a glass effect to our custom view,so it beautifully reflects the content around it,like our previous photos.These updates are just scratching the surfaceof what you can build with the new design.To learn more about how to take advantage of it,from adoption best practices to advanced customizations,check out “Build a SwiftUI app with the new design”In iPadOS 26, there have also been some exciting improvementsto the ways that people can interact with your app.When people swipe down, apps now display a menu bar,which provides faster access to common actions.The commands API used to construct the menu bar on macOSnow creates the same result on iPad.I've added some text editing commands,since our app allows people to jot down notes for their next trip.When planning a trip, people are often looking at multiple apps at once.Windowing on iPad has become even more flexible.People can fluidly resize your app.For apps like ours that use split view navigation,the system automatically shows and hides columns based on the available space.To get your app ready for resizing,Migrate off APIs that fix the screen to full size, like UIRequiresFullscreen.This property list key is deprecated in iPadOS 26.To learn how to design your iPad appfor resizable windows and the new menu bar,watch “Elevate the design of your iPad app.”Window resizing on macOS is more fluid too.For resizes that are caused by changes in the content view size,SwiftUI now synchronizes the animation between that content and the window.Our app has adopted the new window resize anchorto tailor where the animation originates from.It’s great for preserving continuity between different parts of content,like switching tabs in our settings view.Enhancements to the building blocks of SwiftUIalso make our app more powerful.From supercharged performance to ease of use improvementsand new ways to lay out your content,it’s a great year to be building apps with SwiftUI.Performance improvements to the frameworkbenefit apps across all of Apple’s platforms, from our app to yours.There are major improvements to share in several key areas.Including lists, scrolling, and profiling.I’m particularly excited about the improvements to lists on macOS.On macOS, lists of over 100,000 items now load 6x faster.And these lists update up to 16x faster.Larger lists have even bigger performance gains,and there are improvements to all platforms.This improves the experience for people using our trip planning app,whether they're viewing their trips, filtering them, or updating existing ones.Scrolling has some serious wins too.When people scroll in your app,the system gives SwiftUI a certain amount of time to render the next frame.If all the work isn’t done by that deadline,it causes a dropped frame.No one wants this.It can cause your app to feel glitchy or slow.Now, SwiftUI has improved scheduling of user interface updateson iOS and macOS.This improves responsiveness and lets SwiftUI do even more workto prepare for upcoming frames.All in all, it reduces the chance of your app dropping a framewhile scrolling quickly at high frame rates.When you put lazy stacks, like the LazyVStack in this diagram,inside scroll views,SwiftUI delays loading the contained views until they’re about to appear.Now, nested scrollviews with lazy stacks get this same behavior.This is great for building views like photo carousels.To understand what performance issues still remain in our app,I can use the new SwiftUI performance instrument in Xcode.It has a variety of lanes that allow me to quickly inspectdifferent performance problem areas,like long view body updates or platform view updates.It looks like we still have some work to do to make our appas lightning fast as Peter can hike.To dive deeper into the new instrument,watch “Optimize SwiftUI performance with instruments”.Concurrent programming is another fundamental part of building your app.Swift support for structured concurrencyallows verifying data race safety at compile time.This helped Peter and I find bugs in our concurrent codebefore they affected our app.To learn more about adding structured concurrency to your app,watch “Embracing Swift concurrency.”Follow it up with “Explore concurrency in SwiftUI”to discover how SwiftUI leverages Swift concurrency.While our app concurrently loads in its data,Peter and I show an animation.We animate this using the Animatable protocol,where we define a custom animatable data propertythat animates all our shapes properties except the drawing direction.Once I add that full animatable data declaration,that’s a lot of code to just exclude the drawing direction.Using the new Animatable macro,I’m able to delete the custom animatable data propertyand let SwiftUI automatically synthesize it for me.I use the AnimatableIgnored macroto exclude properties I don’t want to animate, like the drawing direction.Layout is in new dimensions, three dimensions to be exact.SwiftUI has new depth-based variants of modifiers you already know,making it possible to do more volumetric layout directly in SwiftUI.On visionOS, our app lets us plan our hiking routes.I want to add a feature that shows the sun in the skybased on where I’ll be hiking at that time.Instead of a normal 2D alignment,I use the new Alignment3D type to align the sun.I place the sun using the Spatial Overlay modifierand adjust the overlay’s alignment based on the time of day.That's awesome!Now I'm never getting sunburned again.This is just scratching the surface of what you can dowith the enhancements to spatial layout in visionOS 26.Watch “Meet SwiftUI spatial layout”to learn more about new tools to build spatial experiences.Peter and I always have backpacks that are way too full.So we added a volume to our app to help us spec out our packs.The new manipulable modifier allows people to interact with the objects in our app.Here, we take a model of a water bottleand enable people to pick it up and move it.To make it obvious which items we still need to pack,we use the new scene snapping APIsto read this information out of the environment.Based on that, we add a pedestal to items that are snapped to the table.Using the new volumetric APIs, it's possible to build sometruly special experiences.That's awesome!SwiftUI has many more enhancementsto windows, volumes, and scenes on visionOS,from window restoration to new scene types.Learn how to use themin “Set the scene with SwiftUI in visionOS.”Check out “What’s new in visionOS” to hear all about what’s new on the platform.Wow, those are some pretty picture-perfect enhancements.It seems like this is going to make preparing for our next photo hike a snap.I know!Just look at this photo I took on my last trip.It was a real safari.That looks great, Anna.A nice spot to expand the viewfinder, just like SwiftUI this year.Your app can take advantage of SwiftUI across the system.With enhancements to Scene and new APIs in Widgets and Controls,apps can be more a part of the platform than ever.And SwiftUI works even better alongside other frameworks.Scenes are the root containers for views in your app.They represent discrete parts of your interface.You can get access to scenes by declaring them in your app’s body.For example, a WindowGroup.This year, you can also request SwiftUI scenes from your UIKitand AppKit lifecycle apps with scene bridging.Scene bridging is really cool!It allows your UIKit and AppKit lifecycle appsto interoperate with SwiftUI scenes.Apps can use it to open SwiftUI-only scene typesor use SwiftUI-exclusive features right from UIKit or AppKit code.You can use scene types like MenuBarExtra and ImmersiveSpace.It also works for scene modifiers,like windowStyle and immersiveEnvironmentBehavior.Scene Bridging works with the new scene types in SwiftUI this year.Like RemoteImmersiveSpace, in macOS Tahoe and visionOS 26,your Mac app can render stereo content on Apple Vision Pro using a new scene.RemoteImmersiveSpace is a macOS sceneto render stereo content on Apple Vision Pro.You render in a RemoteImmersiveSpace with CompositorServices.Your Mac app can use hover effects and input events.To learn more about CompositorServices, Metal,and using them with RemoteImmersiveSpace,Check out “What’s new in Metal rendering for immersive apps.”And AssistiveAccess, which is a special modefor users with cognitive disabilities.Your app can also show UI when someone has their iPhone in this modeby adopting the new AssistiveAccess scene type.To learn more about this APIand how you can adopt AssistiveAccess in your app in iOS 26,check out “Customize your app for Assistive Access.”SwiftUI has some great enhancements to working with AppKit this year.In addition to scene bridging, you can show sheets with SwiftUI views in them.This is a great way to incrementally adopt SwiftUI in your app.You can bridge your AppKit gestures over to SwiftUIusing NSGestureRecognizerRepresentable,and you can use NSHostingView in Interface Builder.SwiftUI also offers more API to work alongside RealityKitwith a ton of improvements this year.These enhancements simplify every part of interacting with RealityKitfrom your SwiftUI code.RealityKit Entities now conform to Observable,which makes it easy to observe changes in your SwiftUI views.There’s improved coordinate conversion API.and there’s enhanced support for presentations right from RealityKit.Using a new component, it’s possible to present SwiftUI popoverslike this directly from a RealityKit Entity.This is great for marking exactly where we want to go on our next photo hike.There’s even more to the integration between SwiftUI and RealityKit,like attachment components, synchronizing animations,binding to components, and new sizing behaviors for RealityView.To learn about SwiftUI and RealityKit’s continued friendship,check out “Better Together: SwiftUI & RealityKit.”I am a big fan of Controls in Control Center.I use them frequently on my phone to control my house,control my device with shortcuts, and control camera experiences.This year, watchOS 26 and macOS Tahoe are getting custom controls.Anna and I are really jazzed about using controls on these platforms.On the Mac, you can access custom controls right from Control Center.And on the watch, when we’re out for a walk,we can mark our favorite photo locations with a tap.Awesome!I’m a big fan of Widgets, too.I like getting information from my apps at a glance.This year, widgets are coming to visionOS and CarPlay.On visionOS, we can customize the appearance of widgetsin the shared space.We’ve added a countdown widget to our appand used the new levelOfDetail environment value.When we get close to the widget, it expands to show some photos we tooklast time we were there.This is a great way to keep an eye on when we’ll take our next photo hike.Only 7 days to go!There’s more new to widgets this year, like Live Activities on CarPlay,push-based updating API, and new APIs for relevance on watchOS.To learn more, check out “What’s new in widgets.”SwiftUI has expanded the capability of views this year.From editing with rich text to charting in 3D,there are some great new viewsand enhancements to existing ones in SwiftUI.To embed web content directly in your app,WebKit now has a full set of SwiftUI APIs, includingWebView.WebView is a new SwiftUI view for showing web content in your app.It’s powered by WebKit, just like Safari.Your app can show URLs by initializing a WebView.To customize and interact with the page, WebViews can also show WebPages,a new observable model type designed from the ground up for Swift.WebPage enables rich interaction with the web.You can programmatically navigate on the page and access page properties.There’s a lot more to WebKit’s new support for SwiftUI,like customizing user agents, calling JavaScript,custom URL schemes, and more.To learn more about all these new WebKit APIs,point your Internet communicator at “Meet WebKit for SwiftUI.”We’ve been trying to convince our families that our hikes aren’t that hilly.With the new support for 3D in Swift Charts,we can show them just that.To show 3D charts, we declare a Chart3D.Chart3D shows plots in three dimensions.We can use the new Z-specific modifiers to specify scales in 3D space.No wonder I was sneezing on that last hike.It was sinusoidal!To learn more about how to add 3D charts to your app,watch “Bring Swift Charts to the third dimension.”To help us share trip data with other apps,Anna and I adopted Drag and Drop in our Mac app.Drag and Drop has some major enhancements this year for your apps.We can drag around multiple items using the new variantof the draggable modifier,along with the new dragContainer modifier.This makes our view a container for drag items.We return the items to transfer based on the selection.This works with the custom selection behavior in our app.When we use this modifier,SwiftUI requests drag items lazily when a drop occurs.Using the new DragConfiguration API,we can customize the supported operations for drags from our app.Here, we allow deleting.To observe events, we use the new onDragSessionUpdated modifier.We check for the ended with delete phase before deleting the photos.Now, when we drag to the trash in the Dock, the photos are deleted.To customize how drag previews look during a drag,we can specify a formation.The stack formation places the items nicely on top of one another.Great!Besides plotting and sharing our trips,Anna and I also want to let our friends follow along and participate.We’ve been working on a way for them to comment on our photos.SwiftUI’s new support for rich text editingis great for experiences like this.TextView now supports AttributedString!By passing a binding to an AttributedString into TextEditor,we’ve allowed our friends to comment on our pictures with rich textusing the built-in text formatting controls.Awesome!Do you smell that?Smells like delicious rich text in SwiftUI.There’s a menu of options for rich text and localization this year.Check out “Cook up a rich text experience in SwiftUI with AttributedString”to explore more.You can customize paragraph styles, transform attributes,and even constrain attributes that people are allowed to use in your app.Enjoy dessert with “Explore localization with Xcode”to dive into crafting great experiences for every language.It’s so exciting to see all the new places to use SwiftUI.And lots of bridges to other things.Check out this pic from my last hike.We should go there next time.Well, it’s time for us to go take some more photos using our new apps.In your apps,go check out the brand new look and feel with the new design,and use the new APIs to polish your app.Inspect the performance of your app with the new performance instrument.Take your app to new depths with the additionsto volume and the new spatial layout.Add richer experiences to your apps using the enhancements to rich text and WebKit.And take advantage of controls and widgets being in more places than ever.We hope you enjoy your adventures this year in SwiftUI.I wonder if those performance improvementsmight help me tackle the hills on our next hike.You're ready to go?Let's do it.

Hi, I'm Anna.And I'm Peter.We're engineers on the SwiftUI team.We’re stoked to talk to you about what’s new in SwiftUI.From low level performance improvementsall the way up through the buttons in your user interface,there are some major improvements to share across the system.It’s easier to interact with text and web-based content,and SwiftUI is in even more places.One of mine and Anna’s greatest loves right below SwiftUIis taking pictures while hiking.Peter and I have built an app to help us plan and share our trips.It uses a ton of the enhancements to SwiftUIto make it look and feel great.First, I’ll show off all the new system featuresand how we made our app shine with them.I'll share enhancements to performance, animations, and layout.

Peter will take you through the new places you can use SwiftUIthroughout all of Apple’s platforms.

Finally, he’ll highlight expanded features in SwiftUI views,including support for web content and rich text.

Let’s get started,with how you can make your app truly shine with a new design.The new design system enables a bright and fluid experiencethat's consistent across Apple platforms.

After Peter and I re-compile our app, it gets the brand new appearance.

The structure of our app hasn't changed,but navigation containers have been updated for the new design.

On iPad and macOS, our app sidebar has a glassy appearancethat reflects the content around it.

Tab bars have also been updated.On iPhone, they have a new, more compact appearance.

Beyond tab bars, most toolbar items now appear in Liquid Glass.

During navigation transitions, these items can even morph.Check it out.

Our app uses the new toolbar spacer API to adjust the sections of toolbar items.

We use a fixed spacerto separate the up-down buttons from the settings button.

To make toolbar items more prominent, Liquid Glass in toolbars supports tinting.

Peter and I apply a bordered prominent button stylewith a tint color to get this effect.

When people scroll down in our app, the toolbar now applies a blur effectto the bar content on the edge that’s being scrolled.This scroll edge effect ensures our bar content remains legibleregardless of whatever is underneath.

To find that next trip, people often search for it.

Search is now bottom aligned on iPhone, which makes it more ergonomic to reach.

Our existing code places the searchable modifieron the outside of the NavigationSplitView.

Peter and I didn’t have to make any code changes to get the bottom aligned search.

With this same placement on iPad,our app gets the new search appearance in the top trailing corner.

With searchable, it’s never been faster to find what you’re looking for.

For tab-based apps where search is a destination,the Search tab now appears separated from the rest of the tabs in the tab barand morphs into the search field.

Set your tab as having a search role to get the updated appearance.

Controls throughout the system also feel fresh,like toggles, segmented pickers, and sliders.Our custom views aren't left out either.There are APIs to let them take advantage of the new design too.

We apply a glass effect to our custom view,so it beautifully reflects the content around it,like our previous photos.These updates are just scratching the surfaceof what you can build with the new design.

To learn more about how to take advantage of it,from adoption best practices to advanced customizations,check out “Build a SwiftUI app with the new design”In iPadOS 26, there have also been some exciting improvementsto the ways that people can interact with your app.

When people swipe down, apps now display a menu bar,which provides faster access to common actions.

The commands API used to construct the menu bar on macOSnow creates the same result on iPad.I've added some text editing commands,since our app allows people to jot down notes for their next trip.When planning a trip, people are often looking at multiple apps at once.Windowing on iPad has become even more flexible.People can fluidly resize your app.

For apps like ours that use split view navigation,the system automatically shows and hides columns based on the available space.

To get your app ready for resizing,Migrate off APIs that fix the screen to full size, like UIRequiresFullscreen.

This property list key is deprecated in iPadOS 26.

To learn how to design your iPad appfor resizable windows and the new menu bar,watch “Elevate the design of your iPad app.”Window resizing on macOS is more fluid too.

For resizes that are caused by changes in the content view size,SwiftUI now synchronizes the animation between that content and the window.

Our app has adopted the new window resize anchorto tailor where the animation originates from.

It’s great for preserving continuity between different parts of content,like switching tabs in our settings view.Enhancements to the building blocks of SwiftUIalso make our app more powerful.

From supercharged performance to ease of use improvementsand new ways to lay out your content,it’s a great year to be building apps with SwiftUI.Performance improvements to the frameworkbenefit apps across all of Apple’s platforms, from our app to yours.There are major improvements to share in several key areas.Including lists, scrolling, and profiling.

I’m particularly excited about the improvements to lists on macOS.

On macOS, lists of over 100,000 items now load 6x faster.

And these lists update up to 16x faster.Larger lists have even bigger performance gains,and there are improvements to all platforms.

This improves the experience for people using our trip planning app,whether they're viewing their trips, filtering them, or updating existing ones.Scrolling has some serious wins too.

When people scroll in your app,the system gives SwiftUI a certain amount of time to render the next frame.If all the work isn’t done by that deadline,it causes a dropped frame.No one wants this.It can cause your app to feel glitchy or slow.

Now, SwiftUI has improved scheduling of user interface updateson iOS and macOS.This improves responsiveness and lets SwiftUI do even more workto prepare for upcoming frames.All in all, it reduces the chance of your app dropping a framewhile scrolling quickly at high frame rates.When you put lazy stacks, like the LazyVStack in this diagram,inside scroll views,SwiftUI delays loading the contained views until they’re about to appear.Now, nested scrollviews with lazy stacks get this same behavior.This is great for building views like photo carousels.

To understand what performance issues still remain in our app,I can use the new SwiftUI performance instrument in Xcode.

It has a variety of lanes that allow me to quickly inspectdifferent performance problem areas,like long view body updates or platform view updates.

It looks like we still have some work to do to make our appas lightning fast as Peter can hike.

To dive deeper into the new instrument,watch “Optimize SwiftUI performance with instruments”.

Concurrent programming is another fundamental part of building your app.Swift support for structured concurrencyallows verifying data race safety at compile time.

This helped Peter and I find bugs in our concurrent codebefore they affected our app.To learn more about adding structured concurrency to your app,watch “Embracing Swift concurrency.”Follow it up with “Explore concurrency in SwiftUI”to discover how SwiftUI leverages Swift concurrency.

While our app concurrently loads in its data,Peter and I show an animation.

We animate this using the Animatable protocol,where we define a custom animatable data propertythat animates all our shapes properties except the drawing direction.

Once I add that full animatable data declaration,that’s a lot of code to just exclude the drawing direction.Using the new Animatable macro,I’m able to delete the custom animatable data propertyand let SwiftUI automatically synthesize it for me.

I use the AnimatableIgnored macroto exclude properties I don’t want to animate, like the drawing direction.Layout is in new dimensions, three dimensions to be exact.

SwiftUI has new depth-based variants of modifiers you already know,making it possible to do more volumetric layout directly in SwiftUI.On visionOS, our app lets us plan our hiking routes.I want to add a feature that shows the sun in the skybased on where I’ll be hiking at that time.

Instead of a normal 2D alignment,I use the new Alignment3D type to align the sun.

I place the sun using the Spatial Overlay modifierand adjust the overlay’s alignment based on the time of day.

That's awesome!Now I'm never getting sunburned again.

This is just scratching the surface of what you can dowith the enhancements to spatial layout in visionOS 26.Watch “Meet SwiftUI spatial layout”to learn more about new tools to build spatial experiences.Peter and I always have backpacks that are way too full.So we added a volume to our app to help us spec out our packs.The new manipulable modifier allows people to interact with the objects in our app.Here, we take a model of a water bottleand enable people to pick it up and move it.

To make it obvious which items we still need to pack,we use the new scene snapping APIsto read this information out of the environment.

Based on that, we add a pedestal to items that are snapped to the table.

Using the new volumetric APIs, it's possible to build sometruly special experiences.

That's awesome!SwiftUI has many more enhancementsto windows, volumes, and scenes on visionOS,from window restoration to new scene types.Learn how to use themin “Set the scene with SwiftUI in visionOS.”Check out “What’s new in visionOS” to hear all about what’s new on the platform.Wow, those are some pretty picture-perfect enhancements.It seems like this is going to make preparing for our next photo hike a snap.I know!Just look at this photo I took on my last trip.

It was a real safari.That looks great, Anna.A nice spot to expand the viewfinder, just like SwiftUI this year.Your app can take advantage of SwiftUI across the system.With enhancements to Scene and new APIs in Widgets and Controls,apps can be more a part of the platform than ever.And SwiftUI works even better alongside other frameworks.Scenes are the root containers for views in your app.They represent discrete parts of your interface.You can get access to scenes by declaring them in your app’s body.For example, a WindowGroup.This year, you can also request SwiftUI scenes from your UIKitand AppKit lifecycle apps with scene bridging.Scene bridging is really cool!It allows your UIKit and AppKit lifecycle appsto interoperate with SwiftUI scenes.Apps can use it to open SwiftUI-only scene typesor use SwiftUI-exclusive features right from UIKit or AppKit code.You can use scene types like MenuBarExtra and ImmersiveSpace.It also works for scene modifiers,like windowStyle and immersiveEnvironmentBehavior.Scene Bridging works with the new scene types in SwiftUI this year.Like RemoteImmersiveSpace, in macOS Tahoe and visionOS 26,your Mac app can render stereo content on Apple Vision Pro using a new scene.

RemoteImmersiveSpace is a macOS sceneto render stereo content on Apple Vision Pro.You render in a RemoteImmersiveSpace with CompositorServices.Your Mac app can use hover effects and input events.To learn more about CompositorServices, Metal,and using them with RemoteImmersiveSpace,Check out “What’s new in Metal rendering for immersive apps.”And AssistiveAccess, which is a special modefor users with cognitive disabilities.Your app can also show UI when someone has their iPhone in this modeby adopting the new AssistiveAccess scene type.To learn more about this APIand how you can adopt AssistiveAccess in your app in iOS 26,check out “Customize your app for Assistive Access.”SwiftUI has some great enhancements to working with AppKit this year.In addition to scene bridging, you can show sheets with SwiftUI views in them.This is a great way to incrementally adopt SwiftUI in your app.You can bridge your AppKit gestures over to SwiftUIusing NSGestureRecognizerRepresentable,and you can use NSHostingView in Interface Builder.

SwiftUI also offers more API to work alongside RealityKitwith a ton of improvements this year.These enhancements simplify every part of interacting with RealityKitfrom your SwiftUI code.RealityKit Entities now conform to Observable,which makes it easy to observe changes in your SwiftUI views.There’s improved coordinate conversion API.and there’s enhanced support for presentations right from RealityKit.Using a new component, it’s possible to present SwiftUI popoverslike this directly from a RealityKit Entity.This is great for marking exactly where we want to go on our next photo hike.

There’s even more to the integration between SwiftUI and RealityKit,like attachment components, synchronizing animations,binding to components, and new sizing behaviors for RealityView.To learn about SwiftUI and RealityKit’s continued friendship,check out “Better Together: SwiftUI & RealityKit.”I am a big fan of Controls in Control Center.I use them frequently on my phone to control my house,control my device with shortcuts, and control camera experiences.This year, watchOS 26 and macOS Tahoe are getting custom controls.Anna and I are really jazzed about using controls on these platforms.On the Mac, you can access custom controls right from Control Center.

And on the watch, when we’re out for a walk,we can mark our favorite photo locations with a tap.Awesome!I’m a big fan of Widgets, too.I like getting information from my apps at a glance.This year, widgets are coming to visionOS and CarPlay.On visionOS, we can customize the appearance of widgetsin the shared space.We’ve added a countdown widget to our appand used the new levelOfDetail environment value.

When we get close to the widget, it expands to show some photos we tooklast time we were there.This is a great way to keep an eye on when we’ll take our next photo hike.Only 7 days to go!There’s more new to widgets this year, like Live Activities on CarPlay,push-based updating API, and new APIs for relevance on watchOS.To learn more, check out “What’s new in widgets.”SwiftUI has expanded the capability of views this year.From editing with rich text to charting in 3D,there are some great new viewsand enhancements to existing ones in SwiftUI.To embed web content directly in your app,WebKit now has a full set of SwiftUI APIs, includingWebView.WebView is a new SwiftUI view for showing web content in your app.It’s powered by WebKit, just like Safari.Your app can show URLs by initializing a WebView.

To customize and interact with the page, WebViews can also show WebPages,a new observable model type designed from the ground up for Swift.WebPage enables rich interaction with the web.You can programmatically navigate on the page and access page properties.

There’s a lot more to WebKit’s new support for SwiftUI,like customizing user agents, calling JavaScript,custom URL schemes, and more.To learn more about all these new WebKit APIs,point your Internet communicator at “Meet WebKit for SwiftUI.”We’ve been trying to convince our families that our hikes aren’t that hilly.With the new support for 3D in Swift Charts,we can show them just that.

To show 3D charts, we declare a Chart3D.

Chart3D shows plots in three dimensions.We can use the new Z-specific modifiers to specify scales in 3D space.No wonder I was sneezing on that last hike.It was sinusoidal!To learn more about how to add 3D charts to your app,watch “Bring Swift Charts to the third dimension.”To help us share trip data with other apps,Anna and I adopted Drag and Drop in our Mac app.Drag and Drop has some major enhancements this year for your apps.

We can drag around multiple items using the new variantof the draggable modifier,along with the new dragContainer modifier.This makes our view a container for drag items.We return the items to transfer based on the selection.

This works with the custom selection behavior in our app.When we use this modifier,SwiftUI requests drag items lazily when a drop occurs.

Using the new DragConfiguration API,we can customize the supported operations for drags from our app.Here, we allow deleting.To observe events, we use the new onDragSessionUpdated modifier.We check for the ended with delete phase before deleting the photos.

Now, when we drag to the trash in the Dock, the photos are deleted.

To customize how drag previews look during a drag,we can specify a formation.

The stack formation places the items nicely on top of one another.Great!Besides plotting and sharing our trips,Anna and I also want to let our friends follow along and participate.We’ve been working on a way for them to comment on our photos.SwiftUI’s new support for rich text editingis great for experiences like this.

TextView now supports AttributedString!By passing a binding to an AttributedString into TextEditor,we’ve allowed our friends to comment on our pictures with rich textusing the built-in text formatting controls.Awesome!Do you smell that?Smells like delicious rich text in SwiftUI.

There’s a menu of options for rich text and localization this year.Check out “Cook up a rich text experience in SwiftUI with AttributedString”to explore more.You can customize paragraph styles, transform attributes,and even constrain attributes that people are allowed to use in your app.Enjoy dessert with “Explore localization with Xcode”to dive into crafting great experiences for every language.It’s so exciting to see all the new places to use SwiftUI.And lots of bridges to other things.Check out this pic from my last hike.

We should go there next time.Well, it’s time for us to go take some more photos using our new apps.In your apps,go check out the brand new look and feel with the new design,and use the new APIs to polish your app.Inspect the performance of your app with the new performance instrument.Take your app to new depths with the additionsto volume and the new spatial layout.Add richer experiences to your apps using the enhancements to rich text and WebKit.And take advantage of controls and widgets being in more places than ever.We hope you enjoy your adventures this year in SwiftUI.I wonder if those performance improvementsmight help me tackle the hills on our next hike.You're ready to go?Let's do it.

2:27 -Toolbar spacer

2:52 -Toolbar item tint

3:30 -Searchable

4:12 -Search tab

4:37 -Glass effect

5:20 -Menu bar commands

6:40 -Window resize anchor

11:24 -@Animatable macro

12:15 -Spatial overlay

13:04 -Manipulable and surface snapping

15:00 -SwiftUI scenes

16:28 -Assistive Access scene

17:52 -SwiftUI presentations from RealityKit

19:24 -Level of detail

20:28 -WebView

20:44 -WebView with WebPage

21:35 -3D charts

22:18 -macOS drag and drop

23:55 -Rich text view

0:00 -IntroductionAnna and Peter introduce the session, highlighting major improvements in SwiftUI ranging from performance to UI elements. They mention a hiking app they built to showcase these enhancements. They will be covering new system features, performance, animations, layout, new platforms for SwiftUI, web content support, and rich text.1:22 -Make the new design shineThis section focuses on the new design system and how it impacts the look and feel of apps. It discusses updated navigation containers, tab bars, and toolbar appearances. It also covers improvements to search and controls. The section concludes with enhancements to iPad interactions, including a new menu bar and flexible window resizing, and improved window resizing on macOS.

**APIs Introduced/Highlighted:**
**Toolbar Spacer API:** Used to adjust the sections of toolbar items.
**Tinting of Liquid Glass in Toolbars:** Allows for more prominent toolbar items using bordered prominent button styles with a tint color.
**Scroll Edge Effect:** Applies a blur effect to toolbar content when scrolling.
**Search Roles in Tab Bars:** Allows the search tab to appear separate from the rest of the tabs in the tab bar.
**Commands API:** Used to construct the menu bar on macOS and now creates the same result on iPad.
**Window Resize Anchor:** Used to tailor where the window resizing animation originates from.
**UIRequiresFullscreen Deprecation:** Property list key is deprecated in iPadOS 26.6:59 -Framework foundationsThis section covers improvements to SwiftUI's building blocks, including performance, ease of use, and layout. It details performance gains in lists and scrolling, and introduces the new SwiftUI performance instrument in Xcode. It also discusses the Animatable macro and new APIs for volumetric layout, including those for visionOS.

**APIs Introduced/Highlighted:**
**SwiftUI Performance Instrument (Xcode):** A new tool for inspecting performance problem areas.
**Animatable Macro:** Simplifies the use of the Animatable protocol by automatically synthesizing the animatable data property.
**AnimatableIgnored Macro:** Excludes properties from animation when using the Animatable macro.
**Alignment3D:** A new type for aligning views in 3D space.
**Spatial Overlay Modifier:** Used to place views in 3D space.
**Manipulable Modifier:** Allows users to interact with objects in the app.
**Scene Snapping APIs:** Used to read information out of the environment.14:33 -SwiftUI across the systemThis section focuses on expanding the reach of SwiftUI across different Apple platforms. It discusses scene bridging, allowing UIKit and AppKit apps to interoperate with SwiftUI scenes. It covers the RemoteImmersiveSpace scene for rendering stereo content on Apple Vision Pro from macOS. It also mentions AssistiveAccess scene type for special mode for users with cognitive disabilities. The section also covers enhancements to working with AppKit, RealityKit, Controls, and Widgets.

**APIs Introduced/Highlighted:**
**Scene Bridging:** Allows UIKit and AppKit apps to use SwiftUI scenes.
**MenuBarExtra Scene:** A new scene type.
**ImmersiveSpace Scene:** A new scene type.
**RemoteImmersiveSpace Scene:** A macOS scene for rendering stereo content on Apple Vision Pro.
**AssistiveAccess Scene:** A scene type for showing UI when someone has their iPhone in Assistive Access mode.
**NSGestureRecognizerRepresentable:** Used to bridge AppKit gestures over to SwiftUI.
**Observable Conformance for RealityKit Entities:** Makes it easier to observe changes in RealityKit entities from SwiftUI views.
**LevelOfDetail Environment Value:** Used to customize the appearance of widgets based on proximity.20:04 -Expand SwiftUI viewsThis section highlights expanded capabilities of SwiftUI views. It covers the new WebView for embedding web content, enhancements to Swift Charts for 3D charting, improvements to Drag and Drop, and new support for rich text editing using AttributedString in TextView.

**APIs Introduced/Highlighted:**
**WebView:** A new SwiftUI view for showing web content in your app.
**WebPage:** A new observable model type designed for Swift to enable rich interaction with web content.
**Chart3D:** Used to show plots in three dimensions.
**Z-Specific Modifiers (Swift Charts):** Used to specify scales in 3D space.
**Draggable Modifier (Multiple Items):** Allows dragging multiple items.
**DragContainer Modifier:** Makes a view a container for drag items.
**DragConfiguration API:** Used to customize the supported operations for drags.
**OnDragSessionUpdated Modifier:** Used to observe drag events.
**TextView with AttributedString:** Allows for rich text editing in SwiftUI.25:01 -Next stepsThe presenters summarize the key takeaways from the session, encouraging developers to explore the new features and APIs. They highlight the new design, performance instrument, volumetric layout, rich text enhancements, and expanded platform support for controls and widgets.

0:00 -Introduction

Anna and Peter introduce the session, highlighting major improvements in SwiftUI ranging from performance to UI elements. They mention a hiking app they built to showcase these enhancements. They will be covering new system features, performance, animations, layout, new platforms for SwiftUI, web content support, and rich text.

Anna and Peter introduce the session, highlighting major improvements in SwiftUI ranging from performance to UI elements. They mention a hiking app they built to showcase these enhancements. They will be covering new system features, performance, animations, layout, new platforms for SwiftUI, web content support, and rich text.

1:22 -Make the new design shine

This section focuses on the new design system and how it impacts the look and feel of apps. It discusses updated navigation containers, tab bars, and toolbar appearances. It also covers improvements to search and controls. The section concludes with enhancements to iPad interactions, including a new menu bar and flexible window resizing, and improved window resizing on macOS.

**APIs Introduced/Highlighted:**
**Toolbar Spacer API:** Used to adjust the sections of toolbar items.
**Tinting of Liquid Glass in Toolbars:** Allows for more prominent toolbar items using bordered prominent button styles with a tint color.
**Scroll Edge Effect:** Applies a blur effect to toolbar content when scrolling.
**Search Roles in Tab Bars:** Allows the search tab to appear separate from the rest of the tabs in the tab bar.
**Commands API:** Used to construct the menu bar on macOS and now creates the same result on iPad.
**Window Resize Anchor:** Used to tailor where the window resizing animation originates from.
**UIRequiresFullscreen Deprecation:** Property list key is deprecated in iPadOS 26.

This section focuses on the new design system and how it impacts the look and feel of apps. It discusses updated navigation containers, tab bars, and toolbar appearances. It also covers improvements to search and controls. The section concludes with enhancements to iPad interactions, including a new menu bar and flexible window resizing, and improved window resizing on macOS.

**APIs Introduced/Highlighted:**
**Toolbar Spacer API:** Used to adjust the sections of toolbar items.
**Tinting of Liquid Glass in Toolbars:** Allows for more prominent toolbar items using bordered prominent button styles with a tint color.
**Scroll Edge Effect:** Applies a blur effect to toolbar content when scrolling.
**Search Roles in Tab Bars:** Allows the search tab to appear separate from the rest of the tabs in the tab bar.
**Commands API:** Used to construct the menu bar on macOS and now creates the same result on iPad.
**Window Resize Anchor:** Used to tailor where the window resizing animation originates from.
**UIRequiresFullscreen Deprecation:** Property list key is deprecated in iPadOS 26.

6:59 -Framework foundations

This section covers improvements to SwiftUI's building blocks, including performance, ease of use, and layout. It details performance gains in lists and scrolling, and introduces the new SwiftUI performance instrument in Xcode. It also discusses the Animatable macro and new APIs for volumetric layout, including those for visionOS.

**APIs Introduced/Highlighted:**
**SwiftUI Performance Instrument (Xcode):** A new tool for inspecting performance problem areas.
**Animatable Macro:** Simplifies the use of the Animatable protocol by automatically synthesizing the animatable data property.
**AnimatableIgnored Macro:** Excludes properties from animation when using the Animatable macro.
**Alignment3D:** A new type for aligning views in 3D space.
**Spatial Overlay Modifier:** Used to place views in 3D space.
**Manipulable Modifier:** Allows users to interact with objects in the app.
**Scene Snapping APIs:** Used to read information out of the environment.

This section covers improvements to SwiftUI's building blocks, including performance, ease of use, and layout. It details performance gains in lists and scrolling, and introduces the new SwiftUI performance instrument in Xcode. It also discusses the Animatable macro and new APIs for volumetric layout, including those for visionOS.

**APIs Introduced/Highlighted:**
**SwiftUI Performance Instrument (Xcode):** A new tool for inspecting performance problem areas.
**Animatable Macro:** Simplifies the use of the Animatable protocol by automatically synthesizing the animatable data property.
**AnimatableIgnored Macro:** Excludes properties from animation when using the Animatable macro.
**Alignment3D:** A new type for aligning views in 3D space.
**Spatial Overlay Modifier:** Used to place views in 3D space.
**Manipulable Modifier:** Allows users to interact with objects in the app.
**Scene Snapping APIs:** Used to read information out of the environment.

14:33 -SwiftUI across the system

This section focuses on expanding the reach of SwiftUI across different Apple platforms. It discusses scene bridging, allowing UIKit and AppKit apps to interoperate with SwiftUI scenes. It covers the RemoteImmersiveSpace scene for rendering stereo content on Apple Vision Pro from macOS. It also mentions AssistiveAccess scene type for special mode for users with cognitive disabilities. The section also covers enhancements to working with AppKit, RealityKit, Controls, and Widgets.

**APIs Introduced/Highlighted:**
**Scene Bridging:** Allows UIKit and AppKit apps to use SwiftUI scenes.
**MenuBarExtra Scene:** A new scene type.
**ImmersiveSpace Scene:** A new scene type.
**RemoteImmersiveSpace Scene:** A macOS scene for rendering stereo content on Apple Vision Pro.
**AssistiveAccess Scene:** A scene type for showing UI when someone has their iPhone in Assistive Access mode.
**NSGestureRecognizerRepresentable:** Used to bridge AppKit gestures over to SwiftUI.
**Observable Conformance for RealityKit Entities:** Makes it easier to observe changes in RealityKit entities from SwiftUI views.
**LevelOfDetail Environment Value:** Used to customize the appearance of widgets based on proximity.

This section focuses on expanding the reach of SwiftUI across different Apple platforms. It discusses scene bridging, allowing UIKit and AppKit apps to interoperate with SwiftUI scenes. It covers the RemoteImmersiveSpace scene for rendering stereo content on Apple Vision Pro from macOS. It also mentions AssistiveAccess scene type for special mode for users with cognitive disabilities. The section also covers enhancements to working with AppKit, RealityKit, Controls, and Widgets.

**APIs Introduced/Highlighted:**
**Scene Bridging:** Allows UIKit and AppKit apps to use SwiftUI scenes.
**MenuBarExtra Scene:** A new scene type.
**ImmersiveSpace Scene:** A new scene type.
**RemoteImmersiveSpace Scene:** A macOS scene for rendering stereo content on Apple Vision Pro.
**AssistiveAccess Scene:** A scene type for showing UI when someone has their iPhone in Assistive Access mode.
**NSGestureRecognizerRepresentable:** Used to bridge AppKit gestures over to SwiftUI.
**Observable Conformance for RealityKit Entities:** Makes it easier to observe changes in RealityKit entities from SwiftUI views.
**LevelOfDetail Environment Value:** Used to customize the appearance of widgets based on proximity.

20:04 -Expand SwiftUI views

This section highlights expanded capabilities of SwiftUI views. It covers the new WebView for embedding web content, enhancements to Swift Charts for 3D charting, improvements to Drag and Drop, and new support for rich text editing using AttributedString in TextView.

**APIs Introduced/Highlighted:**
**WebView:** A new SwiftUI view for showing web content in your app.
**WebPage:** A new observable model type designed for Swift to enable rich interaction with web content.
**Chart3D:** Used to show plots in three dimensions.
**Z-Specific Modifiers (Swift Charts):** Used to specify scales in 3D space.
**Draggable Modifier (Multiple Items):** Allows dragging multiple items.
**DragContainer Modifier:** Makes a view a container for drag items.
**DragConfiguration API:** Used to customize the supported operations for drags.
**OnDragSessionUpdated Modifier:** Used to observe drag events.
**TextView with AttributedString:** Allows for rich text editing in SwiftUI.

This section highlights expanded capabilities of SwiftUI views. It covers the new WebView for embedding web content, enhancements to Swift Charts for 3D charting, improvements to Drag and Drop, and new support for rich text editing using AttributedString in TextView.

**APIs Introduced/Highlighted:**
**WebView:** A new SwiftUI view for showing web content in your app.
**WebPage:** A new observable model type designed for Swift to enable rich interaction with web content.
**Chart3D:** Used to show plots in three dimensions.
**Z-Specific Modifiers (Swift Charts):** Used to specify scales in 3D space.
**Draggable Modifier (Multiple Items):** Allows dragging multiple items.
**DragContainer Modifier:** Makes a view a container for drag items.
**DragConfiguration API:** Used to customize the supported operations for drags.
**OnDragSessionUpdated Modifier:** Used to observe drag events.
**TextView with AttributedString:** Allows for rich text editing in SwiftUI.

25:01 -Next steps

The presenters summarize the key takeaways from the session, encouraging developers to explore the new features and APIs. They highlight the new design, performance instrument, volumetric layout, rich text enhancements, and expanded platform support for controls and widgets.

The presenters summarize the key takeaways from the session, encouraging developers to explore the new features and APIs. They highlight the new design, performance instrument, volumetric layout, rich text enhancements, and expanded platform support for controls and widgets.

## Code Samples

```swift
import
 SwiftUI


struct
 
TripDetailView
: 
View
 {
    
var
 body: 
some
 
View
 {
        
NavigationStack
 {
            
TripList
()
                .toolbar {
                    
ToolbarItemGroup
(placement: .primaryAction) {
                        
UpButton
()
                        
DownButton
()
                    }

                    
ToolbarSpacer
(.fixed, placement: .primaryAction)

                    
ToolbarItem
(placement: .primaryAction) {
                        
SettingsButton
()
                    }
                }
        }
    }
}


struct
 
TripList
: 
View
 {
    
var
 body: 
some
 
View
 {
        
Text
(
"TripList"
)
    }
}


struct
 
UpButton
: 
View
 {
    
var
 body: 
some
 
View
 {
        
Button
(
"Up"
, systemImage: 
"chevron.up"
) { }
    }
}


struct
 
DownButton
: 
View
 {
    
var
 body: 
some
 
View
 {
        
Button
(
"Down"
, systemImage: 
"chevron.down"
) { }
    }
}


struct
 
SettingsButton
: 
View
 {
    
var
 body: 
some
 
View
 {
        
Button
(
"List Settings"
, systemImage: 
"ellipsis"
) { }
    }
}
```

```swift
import
 SwiftUI


struct
 
InspectorView
: 
View
 {
    
var
 body: 
some
 
View
 {
        
NavigationStack
 {
            
InspectorMap
()
                .toolbar {
                    
ToolbarItem
(placement: .primaryAction) {
                        
SaveLocationButton
()
                            .buttonStyle(.borderedProminent)
                            .tint(.pink)
                    }
                }
        }
    }
}


struct
 
InspectorMap
: 
View
 {
    
var
 body: 
some
 
View
 {
        
Text
(
"InspectorMap"
)
    }
}


struct
 
SaveLocationButton
: 
View
 {
    
var
 body: 
some
 
View
 {
        
Button
(
"SaveLocationButton"
) { }
    }
}
```

```swift
import
 SwiftUI


struct
 
PlannerSplitView
: 
View
 {
    
@State
 
private
 
var
 query: 
String
 
=
 
""


    
var
 body: 
some
 
View
 {
        
NavigationSplitView
 {
            
Text
(
"Sidebar"
)
        } detail: {
            
Text
(
"Detail"
)
        }
        .searchable(
            text: 
$query
,
            prompt: 
"What are you looking for?"

        )
    }
}
```

```swift
import
 SwiftUI


struct
 
HealthTabView
: 
View
 {
    
@State
 
private
 
var
 text: 
String
 
=
 
""

    
    
var
 body: 
some
 
View
 {
        
TabView
 {
            
Tab
(
"Summary"
, systemImage: 
"heart"
) {
                
NavigationStack
 {
                    
Text
(
"Summary"
)
                }
            }
            
Tab
(
"Sharing"
, systemImage: 
"person.2"
) {
                
NavigationStack
 {
                    
Text
(
"Sharing"
)
                }
            }
            
Tab
(role: .search) {
                
NavigationStack
 {
                    
Text
(
"Search"
)
                }
            }
        }
        .searchable(text: 
$text
)
    }
}
```

```swift
import
 SwiftUI


struct
 
ToTopButton
: 
View
 {
    
var
 body: 
some
 
View
 {
        
Button
(
"To Top"
, systemImage: 
"chevron.up"
) {
            scrollToTop()
        }
        .padding()
        .glassEffect()
    }

    
func
 
scrollToTop
() {
        
// Scroll to top of view

    }
}
```

```swift
import
 SwiftUI


@main


struct
 
TravelPhotographyApp
: 
App
 {
    
var
 body: 
some
 
Scene
 {
        
WindowGroup
 {
            
RootView
()
        }
        .commands {
            
TextEditingCommands
()
        }
    }
}


struct
 
RootView
: 
View
 {
    
var
 body: 
some
 
View
 {
        
Text
(
"RootView"
)
    }
}
```

```swift
import
 SwiftUI


struct
 
SettingsTabView
: 
View
 {
    
@State
 
private
 
var
 selection: 
SectionTab
 
=
 .general
    
var
 body: 
some
 
View
 {
        
TabView
(selection: 
$selection
.animation()) {
            
Tab
(
"General"
, systemImage: 
"gear"
, value: .general) {
                
Text
(
"General"
)
            }
            
Tab
(
"Sections"
, systemImage: 
"list.bullet"
, value: .sections) {
                
Text
(
"Sections"
)
            }
        }
        .windowResizeAnchor(.top)
    }
}


enum
 
SectionTab
: 
Hashable
 {
    
case
 general
    
case
 sections
}
```

```swift
import
 SwiftUI


@Animatable


struct
 
LoadingArc
: 
Shape
 {
    
var
 center: 
CGPoint

    
var
 radius: 
CGFloat

    
var
 startAngle: 
Angle

    
var
 endAngle: 
Angle

    
@AnimatableIgnored
 
var
 drawPathClockwise: 
Bool


    
func
 
path
(
in
 
rect
: 
CGRect
) -> 
Path
 {
        
// Creates a `Path` arc using properties

        
return
 
Path
()
    }
}
```

```swift
import
 RealityKit

import
 SwiftUI


struct
 
Map
: 
View
 {
    
@Binding
 
var
 timeAlignment: 
Alignment3D


    
var
 body: 
some
 
View
 {
        
Model3D
(named: 
"Map"
)
            .spatialOverlay(
                alignment: timeAlignment
            ) {
                
Sun
()
            }
    }
}


struct
 
Sun
: 
View
 {
    
var
 body: 
some
 
View
 {
        
Model3D
(named: 
"Sun"
)
    }
}
```

```swift
import
 ARKit

import
 RealityKit

import
 SwiftUI


struct
 
BackpackWaterBottle
: 
View
 {
    
@Environment
(\.surfaceSnappingInfo) 
var
 snappingInfo: 
SurfaceSnappingInfo


    
var
 body: 
some
 
View
 {
        
VStackLayout
().depthAlignment(.center) {
            waterBottleView
                .manipulable()

            
Pedestal
()
                .opacity(
                    snappingInfo.classification 
==
 .table 
?
 
1.0
 : 
0.0
)
        }
    }

    
var
 waterBottleView: 
some
 
View
 {
        
Model3D
(named: 
"waterBottle"
)
    }
}


struct
 
WaterBottleView
: 
View
 {
    
var
 body: 
some
 
View
 {
        
Model3D
(named: 
"waterBottle"
)
    }
}


struct
 
Pedestal
: 
View
 {
    
var
 body: 
some
 
View
 {
        
Model3D
(named: 
"pedestal"
)
    }
}
```

```swift
import
 SwiftUI


@main


struct
 
PhotoWalk
: 
App
 {
    
var
 body: 
some
 
Scene
 {
        
WindowGroup
(id: 
"AppContents"
) {
            
PhotoWalkContent
()
        }
    }
}


struct
 
PhotoWalkContent
: 
View
 {
    
var
 body: 
some
 
View
 {
        
Text
(
"PhotoWalkContent"
)
    }
}
```

```swift
import
 SwiftUI


@main


struct
 
PhotoWalk
: 
App
 {
  
var
 body: 
some
 
Scene
 {
    
WindowGroup
 {
      
ContentView
()
    }

    
AssistiveAccess
 {
      
AssistiveAccessContentView
()
    }
  }
}


struct
 
ContentView
: 
View
 {
  
var
 body: 
some
 
View
 {
    
Text
(
"ContentView"
)
  }
}


struct
 
AssistiveAccessContentView
: 
View
 {
  
var
 body: 
some
 
View
 {
    
Text
(
"AssistiveAccessContentView"
)
  }
}
```

```swift
import
 RealityKit

import
 SwiftUI


struct
 
PopoverComponentView
: 
View
 {
    
@State
 
private
 
var
 popoverPresented: 
Bool
 
=
 
false

    
var
 body: 
some
 
View
 {
        
RealityView
 { c 
in

            
let
 mapEntity 
=
 
Entity
()

            
let
 popover 
=
 
Entity
()
            mapEntity.addChild(popover)
            popover.components[
PresentationComponent
.
self
] 
=
 
PresentationComponent
(
                isPresented: 
$popoverPresented
,
                configuration: .popover(arrowEdge: .bottom),
                content: 
DetailsView
()
            )
        }
    }
}


struct
 
DetailsView
: 
View
 {
    
var
 body: 
some
 
View
 {
        
Text
(
"DetailsView"
)
    }
}
```

```swift
import
 SwiftUI

import
 WidgetKit


struct
 
PhotoCountdownView
: 
View
 {
    
@Environment
(\.levelOfDetail) 
var
 levelOfDetail: 
LevelOfDetail

    
var
 body: 
some
 
View
 {
        
switch
 levelOfDetail {
        
case
 .default:
            
RecentPhotosView
()
        
case
 .simplified:
            
CountdownView
()
        
default
:
            
Text
(
"Unknown level of detail"
)
        }
    }
}


struct
 
RecentPhotosView
: 
View
 {
    
var
 body: 
some
 
View
 {
        
Text
(
"RecentPhotosView"
)
    }
}


struct
 
CountdownView
: 
View
 {
    
var
 body: 
some
 
View
 {
        
Text
(
"CountdownView"
)
    }
}
```

```swift
import
 SwiftUI

import
 WebKit


struct
 
HikeGuideWebView
: 
View
 {
    
var
 body: 
some
 
View
 {
        
WebView
(url: sunshineMountainURL)
    }

    
var
 sunshineMountainURL: 
URL
 {
        
URL
(string: 
"sunshineMountainURL"
)
!

    }
}
```

```swift
import
 SwiftUI

import
 WebKit


struct
 
InAppBrowser
: 
View
 {
    
@State
 
private
 
var
 page 
=
 
WebPage
()

    
var
 body: 
some
 
View
 {
        
WebView
(page)
            .ignoresSafeArea()
            .onAppear {
                page.load(
URLRequest
(url: sunshineMountainURL))
            }
    }

    
var
 sunshineMountainURL: 
URL
 {
        
URL
(string: 
"sunshineMountainURL"
)
!

    }
}
```

```swift
import
 Charts

import
 SwiftUI


struct
 
HikePlotView
: 
View
 {
    
var
 body: 
some
 
View
 {
        
Chart3D
 {
            
SurfacePlot
(
                x: 
"x"
, y: 
"y"
, z: 
"z"
) { x, y 
in

                    sin(x) 
*
 cos(y)
                }
                .foregroundStyle(
Gradient
(colors: [.orange, .pink]))
        }
        .chartXScale(domain: 
-
3
 
...
 
3
)
        .chartYScale(domain: 
-
3
 
...
 
3
)
        .chartZScale(domain: 
-
3
 
...
 
3
)
    }
}
```

```swift
import
 SwiftUI


struct
 
DragDropExample
: 
View
 {
    
@State
 
private
 
var
 selectedPhotos: [
Photo
.
ID
] 
=
 []
    
var
 body: 
some
 
View
 {
        
ScrollView
 {
            
LazyVGrid
(columns: gridColumns) {
                
ForEach
(model.photos) { photo 
in

                    view(photo: photo)
                        .draggable(containerItemID: photo.id)
                }
            }
        }
        .dragContainer(for: 
Photo
.
self
, selection: selectedPhotos) { draggedIDs 
in

            photos(ids: draggedIDs)
        }
        .dragConfiguration(
DragConfiguration
(allowMove: 
false
, allowDelete: 
true
))
            .onDragSessionUpdated { session 
in

                
let
 ids 
=
 session.draggedItemIDs(for: 
Photo
.
ID
.
self
)
                    
if
 session.phase 
==
 .ended(.delete) {
                        trash(ids)
                        deletePhotos(ids)
                    }
            }
        .dragPreviewsFormation(.stack)
    }
}
```

```swift
import
 SwiftUI


struct
 
CommentEditor
: 
View
 {
    
@Binding
 
var
 commentText: 
AttributedString


    
var
 body: 
some
 
View
 {
        
TextEditor
(text: 
$commentText
)
    }
}
```


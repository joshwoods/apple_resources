# Wwdc2025 237

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Summary

Transcript

Code

What’s new for the spatial webDiscover the latest spatial features for the web on visionOS 26. We'll cover how to display inline 3D models with the brand new HTML model element. And we'll share powerful features, including model lighting, interactions, and animations. Learn how to embed newly supported immersive media on your web site, such as 360-degree video and Apple Immersive Video. And get a sneak peek at adding a custom environment to your web pages.Chapters0:00 -Introduction0:55 -Embed 3D models21:24 -Present immersive media26:14 -Provide custom environmentResourcesLearn more about Reality ComposerQuickLook example filesHD VideoSD VideoRelated VideosWWDC25Explore video experiences for visionOSLearn about the Apple Projected Media ProfileSupport immersive video playback in visionOS appsWhat’s new in Safari and WebKitWWDC24Create custom environments for your immersive apps in visionOSWWDC23Explore the USD ecosystemMeet Reality Composer Pro

Discover the latest spatial features for the web on visionOS 26. We'll cover how to display inline 3D models with the brand new HTML model element. And we'll share powerful features, including model lighting, interactions, and animations. Learn how to embed newly supported immersive media on your web site, such as 360-degree video and Apple Immersive Video. And get a sneak peek at adding a custom environment to your web pages.

0:00 -Introduction

0:55 -Embed 3D models

21:24 -Present immersive media

26:14 -Provide custom environment

Learn more about Reality Composer

QuickLook example files

HD VideoSD Video

HD Video

SD Video

Explore video experiences for visionOS

Learn about the Apple Projected Media Profile

Support immersive video playback in visionOS apps

What’s new in Safari and WebKit

Create custom environments for your immersive apps in visionOS

Explore the USD ecosystem

Meet Reality Composer Pro

Search this video…Hi, I’m Eddy from the visionOS Safari team.This is a big year for the spatial web, with new exciting featuresthat will take the web experience to the next dimension.We have added support to render 3D models stereoscopicallyin line with other web contentwhile allowing people to interact with the model.We have also added support for playing immersive media,a new class of media that extends beyond the planar screen.We have added some new developer preview features,such as website environments.I’d love to show you how you can adopt these new features.I will show you how to embed 3D models on your webpage,present immersive media, and provide a custom webpage environment.Let's jump right in.For the past few decades, the HTML Image elementallowed web developers to put images onto the web.As we enter the spatial computing era,we are introducing a new way to take your web contentto the next dimension by allowing you to embedand display 3D models on your webpage.This is a new HTML Model element.It has been proposed to the web standards bodies a few years ago,and we are now making it available by defaultin Safari on visionOS this year.With simple markup, your visitors can now see 3D modelsembedded alongside other web content.Unlike any existing model rendering libraries,the Model element is rendered stereoscopically,so people can perceive the depth of the object,and they can move around to see different angles of the model.We are going to dig deep into many aspects of embedding 3D models,from preparing the asset to rendering it nicelywith interactions and animations, etc.The first step to embed a 3D model is to create the model.Now, with Safari on visionOS, the Model element supports the USDZ file format,which is a widely used format in the 3D content industry.With existing tools, you can capture, convert, or create USDZ files.You can capture a real-world object into a 3D model file with an iPhone.Simply download the Reality Composer app from the App Store to get started.The Object Capture API on iOS allows appsto capture and generate model files in a similar way.Some of you may already have some 3D models for your use case,but they may be in some other formats.macOS has built-in support to convert various 3D model formats to USDZusing Preview or command-line tools.For advanced users, there are existing 3D modeling software people have been usingto create beautiful, amazing 3D models,such as Blender, Houdini, Maya, Reality Composer Pro, and many more.Many of them support exporting to USDZ.The USD ecosystem has a wide spectrum of toolsthat you can utilize in your workflow.And you can learn more at the WWDC23 session: “Explore the USD ecosystem.”If you have never created a 3D model before,you may want to check out “Meet Reality Composer Pro”,also from WWDC23.It will be handy for you to have a testing USDZ file readywhen you experiment with the model element.The absolute quickest way to get the USDZ fileis to download from developer.apple.com.Some of them were made with Object Capture,while some others were carefully crafted with 3D modeling software.Just like all web assets,you should try to keep the file size small so that it loads fast.My favorite way is to use Preview on your Mac to exporta copy with compressed textures.There are a lot more ways you can optimize your file,and they’re introduced in-depth in the WWDC24 session:“Optimize your 3D assets for spatial computing”.With an asset file ready, let’s embed it on the webpage.The syntax to embed a model is simple.Just apply a USDZ file in the source attribute of the model element.Don't forget the closing tag.Alternatively, put the source element inside an empty model element,just like how you would do it with the picture element.The model element works just like other visual DOM elements,so you will put it in wherever you want the model to be displayed in.A key thing to know is that the model is always rendered behind the page surface.Think about it as the model elementbeing an opening into a virtual space behind the page,and the model lives within that space.This prevents content from poking out of the page unexpectedly,as the model element is scrolled into view.By default, the browser will scale the modelto fit within the element’s bounds.It does so by fitting and centering the x-y face of the bounding boxof the model within the element.Some older web servers or CDN may not recognize the USDZ file extension,and may return the wrong content type in the HTTP response header.To return the correct content type,you may have to add some configuration to your web server.Here are some examples of specifying the USDZ MIME typefor different web servers.For details, check the documentation for your specific web server software.A vital part to building a great website is to accommodatefor all visitors with different devices.Therefore, it is important for you to provide a backward compatible fallback.To provide a fallback image, you can put it inside the model element.I like to provide a 2D rendering of my modelso that people using other browserscan still get an idea of what the object looks like.Instead of a static image, you can also providea 2D viewing experience using existing third-party librariessuch as Three.js, BabylonJS, model-viewer, and many more.This is an example leveraging the model-viewer library.This library draws a given model onto a 2D canvas using JavaScript.You can use it as a fallback experienceby wrapping the model element around the 2D viewer code.With this setup, people using Safari on visionOSwill see the model rendered stereoscopically with depth,while those using other browsers will see a 2D rendering instead.If you have some really custom fallback behavior in mind,you can use JavaScript to detect whether the model element is supported.You can check for the existence of window.HTMLModelElement object.As a reminder, it is a bad ideato detect whether the user agent is visionOS Safari.It’s fragile and may do the wrong thing in the future,when other browsers start supporting the model element.Remember, detect for the feature, not for the agent.A USDZ file could easily go beyond 10 MB,so it could take several seconds to load on slower networks.You may find yourself wanting to know when the model is fully loaded,so that you can perform updates to the UI.One common example is the loading indicator.The model element has a ready property, which returns a Promise object.When the model is fully loaded, the promise will resolve.You can then hide the loading indicator and show the model element.The ready promise can fail in case of a loading error,so don’t forget to handle the error as appropriate,such as providing a retry button.In my experience, providing visual cues to your visitorsthat something is loading really helps keep them on your pageinstead of navigating away.Now you have the model embedded.It’s time to make it look great on your website.The model element defines a virtual space to render the model within.It’s a good idea to set the color of the spaceto the same color as the surrounding web content,so that the model element blends nicely into the page.When you add a model element to a page,the entire model element is replaced by the virtual space,so people will not see the original background color of that region.To fix that, you should set the color of the virtual spaceusing the CSS background-color attribute.Remember, this needs to be set on the model element itself,not its ancestors.If you specified a background color with alpha,it will be converted to opaque.If you don’t want to repeat yourself for the color definition,you can use a CSS custom property to keep your code dry.Once the model element blends into the page,it’s much easier to do creative things.In this previous example,I extended the model element under the panel on the right.I applied a frosted glass effect to the panel,revealing the camera underneath at a certain angle,giving it a very strong sense of layering.There are a number of ways to achieve the same effect,and I’ll just show you my way of doing it.First, I make sure the model element extendsbehind the panel using position: absolute.The backdrop-filter gives the frosted glass effectby blurring the pixels of the model element.The linear-gradient gives a specular highlight on the edgeto give a sense of thickness,while keeping the panel light in color so that the text is easy to read.All these are good old CSS tricks that have existed for some time,but they really shine when combined with the depth effect of the model element.The page is looking so good now,but we can make the model look even better by adjusting the lighting effect.Here, I’m applying different lighting to the same model file.Notice how different they look depending on the lighting chosen.To control the lighting effect, you use a special kind of imageto define what the environment looks like for the model,so that your model will reflect lights contributed by the environment.This technique is called image-based lighting, or IBL for short.The image is often called an IBL file.The IBL file may look distorted because it’s projectingthe entire 360 degree of the environment onto a planar image.This flattened spherical projection,also known as equirectangular projection, is very common for IBL files.Note that the IBL file is not part of the USDZ file,so it has to be specified during rendering.To specify the IBL for model elements,you should use the environmentmap attribute.If you don’t supply one, the browser will apply a default lighting for your model.Because the IBL is not part of the USDZ file,when the model file is used outside of the webpage,it will not get the same lighting effect.This allows the presenting app to apply the most suitable lightingfor the viewing experience.One tip I have is that you should consider usingOpenEXR and Radiance HDR formats for your IBL file.These two formats will make reflections a lot more realistic,because they represent brightness level across many orders of magnitude.On the other hand, a JPEG IBL will look very dull and flat.With your model looking great, it’s time to let your visitors interact with it.The model element supports a variety of user interactions out of the box.By default, pinch and hold on the model elementwill initiate a drag and drop interaction.People can drop the model to another app or drop it to an empty locationto view the model in their space through Quick Look.This is a fantastic way for people to see the model in their real size,with realistic lighting effects applied to the model to make it look real.People can stick it onto a surface, turn it around, make it bigger or smaller.In addition to drag and drop, you can also enable pinch and dragon the model element to rotate the model when it’s displayed inline.You can tilt the model up and down,and the model will reset the tilt on release.This inline rotation behavior is enabledby specifying stagemode equals orbit on the model element.The rotation happens along the y-axis,with small amount of vertical tilting allowed during gesture.The browser engine will also scale and offset your modelto ensure it remains behind the page surface during rotation.If this stagemode rotation behavior is not sufficient for your use case,you can implement custom interactions manually.If you want to move and orient the model manually in specific ways,you can do so with JavaScript.You can control the exact location and orientationyou want your model to be in within the virtual space.This is achieved by changing the transformation matrixexposed by the model element.The transformation matrix is exposed through the entityTransform property.When the model is loaded, the browser computes the transformation neededfor the default placement and saves it to the entityTransform property.The property will be populated once the ready promise resolves.Let me show you an example of customizing the placement of the model.Here, we want to offer a link that will rotate the model to face right.In the turnRight function, read the browser computed transformation matrixfrom the entityTransform property.Then, apply a 90 degree rotation along the y-axisusing the rotateAxisAngle method,which is an existing API of the DOMMatrix class.0-1-0 means the y-axis, and 90 means rotate for 90 degrees.Once we have our new matrix,set it back to the entityTransform propertyfor it to take effect.The operations supported by an entityTransform matrixinclude uniform scaling, rotation, and translation.You will get an error if you try to assign a matrixcontaining unsupported operations to the entityTransform property.The default entity transform should be sufficient for most use cases.But some of you may want to understand the mathbehind the default computation.To understand that, it helps to go back to the basics and discussthe entity transform behavior for an identity matrix.If you set the entity transform to an identity matrix,it will align the origin of the USDZ file tothe center point of the model element.Remember, the model is only rendered within the space behind the page surface.so any parts extending forward will be clipped.In addition, it renders such that 1 cm in the USDZ fileequals exactly 1 cm in CSS,which is around 38px in CSS.On visionOS, the Safari window grows biggerwhen it's further away from the user.Therefore, when the model is displayed on the webpage,there’s no relationship between the units used in the USDZ fileand the physical units in the real world.If you need to showcase your object in its real physical size,the best way is to let people drag it out of the pageand view it through Quick Look, as we have shown previously.The entityTransform property can be used in really creative ways.In this previous example, it zooms into different parts of the modelas we go through different features of this camera.And to just moving it around,you can even animate the camera screen open and close using model animations.Let me show you how.The USDZ file format supports defining animations within the file itself,and is a well-supported feature in all major authoring tools.Some USDZ files contain multiple tracks of animations too.The model element supports playbackof the first animation track defined in the USDZ file.For simple looping animations,you can use the loop and autoplay attribute.If you want to control the animation manually,you can use the play and pause methods on the model element.You can determine whether the animation is playing using the paused property.These few API may look familiar to you because they’re actuallythe same as those for the video element.For more complex use cases,you can use your 3D modeling software to build a timeline for your model,animating between different states.In my camera model file,I first animate the opening and closing of the camera flashlight,followed by the opening and closing of the camera screen.The animation information is stored inside the USDZ file.When you put an animated model in the model element,you can jump to any point in the timeline using the currentTime property.For example, if I want to open the flash on the camera,I just need to set the currentTime property to 1.Keep in mind the unit for the currentTime property is seconds.Similarly, if I want to open the screen,I just set it to 3.Pay attention to how the model is updated instantly without any implicit animation.This allows you to jump to discontinuous timestamps toachieve any specific effect you need.You can create interesting experiencesby hooking up the currentTime property with some interactions.Here, I have a slider that has a value range between 2 and 3.Meant to cover the portion of the timelinewhere the screen animates open.I add an event listener to watch for the slider value change.And when that happens,I set the current time to the value of the slider.This way, my visitors can use the slider to control the position of the screen.You can extend this idea to other interactions,like scrolling of a page or a custom drag event.You can also combine currentTime and entityTransform in creative ways.In this previous camera page example, the animation is driven by a timer.The individual parts are animated using the currentTime property,while the movement of the whole camerais animated using the entityTransform property.The page is becoming really nice, but you may want to make it even betterby adding a personal touch, like allowing people to engrave on the product.But you cannot possibly know what text to put into the USDZ model ahead of time.That’s where dynamically generated models come into play.If your use case requires displaying a modelthat depends on user input at runtime,you can use JavaScript to programmatically generatea USDZ file in the browser and display it within the model element.Three.js is a powerful JavaScript librarythat allows you to create 3D models programmatically.Three.js is a deep subject on its own,so we are not going to discuss the fine details of it today.At a high level, you have a THREE.Scene objectthat contains the model you created procedurally.So let’s assume you have a nicely crafted scene object already.Three.js comes with a USDZ exporter module that you can import.Once imported, you can use the parseAsync methodto generate the data blob for the full USDZ file of the model scene.You can create an object URL pointing to the data blob you have generatedusing the URL.createObjectURL method.Now you have the object URL,you can set it to the source attribute of the model element,and it will start rendering.With this technique, you’re no longer limitedto using static known USDZ files you prepared offline.You can add customizations to models based on data inputs from your visitors,like adding the name to a product or changing the color of the text.One cool thing about this is that the model can still be dragged outand viewed in people’s space.There are a lot more APIs supported by the model element,and we have only covered some of them today.The rest of them could be useful to you as you adopt models on your webpages.You can learn more about the model element at the MDN documentation pageand the model element proposal at the W3C website.You can find the URLs at the related links for this session.Let me tell you about another category of content,immersive media.Last year, we introduced ways for you to display panoramaand spatial photos from your website.We are extending the support to spatial video, 180-degree, 360-degree,and wide field-of-view video, as well as Apple Immersive Video.And we have some updates to presenting panorama and spatial photos too.With iPhone 15 Pro or newer,you can capture spatial video right from the Camera app,and they can be viewed spatially from the Photos app on Apple Vision Pro.Now, with visionOS, there is new support for three immersive media types:180-degree, 360-degree, and wide field-of-view video.These media types extend beyond a flat surface,wrapping around the user to provide an immersive experience.There is also new support for presenting Apple Immersive Video,with high resolution stereo video perfectly calibratedto each lens in the camera that captured it.You can learn about these new media types at the WWDC session this year,“Explore video experiences for visionOS”.When an immersive media file is embedded on the page,such as this 360-degree video, it will render as a 2D video.To let people view it immersively, present your video in full screen,and the video will wrap around the user with the correct projection.The full screen player also supports stereoscopic content,which is often found in 180-degree and Apple Immersive Video formats.You may already have taken some immersive media before.Now is the best time to showcase them on your website.You can embed all these media types on your websiteusing the existing video element.There’s no new element or attribute involved.You can also use HTTP Live Streaming to serve large video assets as usual.For 180, 360 and wide field-of-view media, the file should conform to APMP,the Apple Projected Media Profile,which contains extra metadata to describe the media’s projection.To learn how to convert your existing media to APMP,check out the WWDC session this year:“Learn about the Apple Projected Media Profile.”To learn more about Apple Immersive Video,check out “Learn about Apple Immersive Video technologies.”Here is an example of wide field-of-view APMP.The metadata captures the camera parameters that was used during recording.visionOS will then present the mediain a shape that will line up each pixels to its intended location,resulting in correct projection during playback.Notice how straight lines will look straight even on the edgeswhen viewed in full screen.This is the power of APNP.The default controls for video element allow people to enter full screen.You can also programmatically enter full screenusing the requestfFullScreen API from JavaScript.In fact, this is the exact same API as you would useto present panorama and spatial photo from your webpage.For panorama, you can now supply different sources for the same picture element,so that you can display a suitable thumbnail before going full screen.Once entered full screen, the widest variant will be used.For spatial photos,the requestFullscreen API works the same way.The spatial photo will render as a flat 2D imagewhen it’s displayed in line,and will render spatially when it’s presented full screen.In my experience, I always have to communicate to my visitorsthat this particular image is actually spatial,and that they should tap on it to see its true beauty.This may become much easier in the future by using the new attribute, controls,which has been added as a developer preview feature since visionOS 2.4.The controls attribute adds a spatial photo badge,indicating that this image is a spatial photo.Coupled with the full screen button,your visitors can easily view the spatial version of the image,all without having you to write a single line of JavaScript.Like all developer preview features,you will have to explicitly turn this feature on to try it out.To do so, go to Settings > Apps > Safari > Advanced > Feature Flags,and enable Spatial Image Controls API.While we are here, let’s also enable the other one,Website environments, as we’re going to talk about it next.Website environment is a new developer preview featurewe’re introducing this yearto allow websites to provide a virtual environment for their visitors.Here's how it works.This example page has specified a USDZ file as the environment,and people can choose to display the environment through the page menu,while still keeping Safari and the website in view.They can use the digital crown to fully immerse themselvesin the environment undistracted.This is a fantastic way to augment your websitebeyond the bounds of the browser window.To provide an environment, use a link element specifying rel equals spatial-backdrop.Then, use the href attribute to point your environment USDZ file.Just like 3D models,you can use the environmentmap attribute to supply a custom IBL for your USDZ file.With a well-crafted environment,your visitors will feel like they are teleported to another locationlike a restaurant, a submarine, or a dungeon.Since this is a developer preview,you will need to enable the feature in Settings before you can try it out.The markup may change in the futureas it goes through the web standards process.Apple is actively leading the development of this feature,and your feedback will help shape its future.To learn more about creating a custom environment, please check out“Create custom environments for immersive apps in visionOS”from WWDC24.We have covered a lot of new spatial web features today.We talked about the new HTML model element,with its support for interactions, custom lighting, and manual placement.Using the existing video element,you can display a range of new immersive media straight from your website.And you got a sneak peek of what website environments would be like in the future.To help you get started,we have added some example usage of model element on webkit.org.There’s no better way to experience itthan actually seeing it through your Apple Vision Pro.Once you feel ready,go ahead and add 3D models to your webpage where appropriate.to give your visitors a stunning new experience.If your website serves video,now is a great time to start including immersive media on your website.We would love for you to experiment with adding custom environmentsand share your feedback with us.Besides the spatial web,there’s a lot more new features for the web,which you can learn more at“What’s new for Safari and WebKit” session this year.You can file bug reports and feature requests for web technologyat bugs.webkit.org, the issue tracker for WebKit.Issues about the interface of Safari or anything about visionOSor other Apple platforms,please file those at feedbackassistant.apple.com.We are eagerly waitingto see all the amazing things you’re going to build with these new technologies.Thank you, and have a great WWDC.

Hi, I’m Eddy from the visionOS Safari team.This is a big year for the spatial web, with new exciting featuresthat will take the web experience to the next dimension.

We have added support to render 3D models stereoscopicallyin line with other web contentwhile allowing people to interact with the model.

We have also added support for playing immersive media,a new class of media that extends beyond the planar screen.

We have added some new developer preview features,such as website environments.

I’d love to show you how you can adopt these new features.I will show you how to embed 3D models on your webpage,present immersive media, and provide a custom webpage environment.

Let's jump right in.

For the past few decades, the HTML Image elementallowed web developers to put images onto the web.As we enter the spatial computing era,we are introducing a new way to take your web contentto the next dimension by allowing you to embedand display 3D models on your webpage.

This is a new HTML Model element.It has been proposed to the web standards bodies a few years ago,and we are now making it available by defaultin Safari on visionOS this year.With simple markup, your visitors can now see 3D modelsembedded alongside other web content.

Unlike any existing model rendering libraries,the Model element is rendered stereoscopically,so people can perceive the depth of the object,and they can move around to see different angles of the model.

We are going to dig deep into many aspects of embedding 3D models,from preparing the asset to rendering it nicelywith interactions and animations, etc.

The first step to embed a 3D model is to create the model.

Now, with Safari on visionOS, the Model element supports the USDZ file format,which is a widely used format in the 3D content industry.With existing tools, you can capture, convert, or create USDZ files.You can capture a real-world object into a 3D model file with an iPhone.Simply download the Reality Composer app from the App Store to get started.The Object Capture API on iOS allows appsto capture and generate model files in a similar way.Some of you may already have some 3D models for your use case,but they may be in some other formats.macOS has built-in support to convert various 3D model formats to USDZusing Preview or command-line tools.

For advanced users, there are existing 3D modeling software people have been usingto create beautiful, amazing 3D models,such as Blender, Houdini, Maya, Reality Composer Pro, and many more.Many of them support exporting to USDZ.The USD ecosystem has a wide spectrum of toolsthat you can utilize in your workflow.And you can learn more at the WWDC23 session: “Explore the USD ecosystem.”If you have never created a 3D model before,you may want to check out “Meet Reality Composer Pro”,also from WWDC23.

It will be handy for you to have a testing USDZ file readywhen you experiment with the model element.The absolute quickest way to get the USDZ fileis to download from developer.apple.com.Some of them were made with Object Capture,while some others were carefully crafted with 3D modeling software.

Just like all web assets,you should try to keep the file size small so that it loads fast.My favorite way is to use Preview on your Mac to exporta copy with compressed textures.There are a lot more ways you can optimize your file,and they’re introduced in-depth in the WWDC24 session:“Optimize your 3D assets for spatial computing”.

With an asset file ready, let’s embed it on the webpage.The syntax to embed a model is simple.Just apply a USDZ file in the source attribute of the model element.Don't forget the closing tag.

Alternatively, put the source element inside an empty model element,just like how you would do it with the picture element.

The model element works just like other visual DOM elements,so you will put it in wherever you want the model to be displayed in.

A key thing to know is that the model is always rendered behind the page surface.

Think about it as the model elementbeing an opening into a virtual space behind the page,and the model lives within that space.This prevents content from poking out of the page unexpectedly,as the model element is scrolled into view.

By default, the browser will scale the modelto fit within the element’s bounds.

It does so by fitting and centering the x-y face of the bounding boxof the model within the element.

Some older web servers or CDN may not recognize the USDZ file extension,and may return the wrong content type in the HTTP response header.To return the correct content type,you may have to add some configuration to your web server.

Here are some examples of specifying the USDZ MIME typefor different web servers.

For details, check the documentation for your specific web server software.A vital part to building a great website is to accommodatefor all visitors with different devices.Therefore, it is important for you to provide a backward compatible fallback.

To provide a fallback image, you can put it inside the model element.

I like to provide a 2D rendering of my modelso that people using other browserscan still get an idea of what the object looks like.

Instead of a static image, you can also providea 2D viewing experience using existing third-party librariessuch as Three.js, BabylonJS, model-viewer, and many more.

This is an example leveraging the model-viewer library.This library draws a given model onto a 2D canvas using JavaScript.

You can use it as a fallback experienceby wrapping the model element around the 2D viewer code.

With this setup, people using Safari on visionOSwill see the model rendered stereoscopically with depth,while those using other browsers will see a 2D rendering instead.

If you have some really custom fallback behavior in mind,you can use JavaScript to detect whether the model element is supported.

You can check for the existence of window.HTMLModelElement object.

As a reminder, it is a bad ideato detect whether the user agent is visionOS Safari.It’s fragile and may do the wrong thing in the future,when other browsers start supporting the model element.

Remember, detect for the feature, not for the agent.

A USDZ file could easily go beyond 10 MB,so it could take several seconds to load on slower networks.

You may find yourself wanting to know when the model is fully loaded,so that you can perform updates to the UI.One common example is the loading indicator.

The model element has a ready property, which returns a Promise object.

When the model is fully loaded, the promise will resolve.

You can then hide the loading indicator and show the model element.

The ready promise can fail in case of a loading error,so don’t forget to handle the error as appropriate,such as providing a retry button.

In my experience, providing visual cues to your visitorsthat something is loading really helps keep them on your pageinstead of navigating away.

Now you have the model embedded.It’s time to make it look great on your website.

The model element defines a virtual space to render the model within.

It’s a good idea to set the color of the spaceto the same color as the surrounding web content,so that the model element blends nicely into the page.

When you add a model element to a page,the entire model element is replaced by the virtual space,so people will not see the original background color of that region.To fix that, you should set the color of the virtual spaceusing the CSS background-color attribute.Remember, this needs to be set on the model element itself,not its ancestors.

If you specified a background color with alpha,it will be converted to opaque.If you don’t want to repeat yourself for the color definition,you can use a CSS custom property to keep your code dry.Once the model element blends into the page,it’s much easier to do creative things.

In this previous example,I extended the model element under the panel on the right.I applied a frosted glass effect to the panel,revealing the camera underneath at a certain angle,giving it a very strong sense of layering.

There are a number of ways to achieve the same effect,and I’ll just show you my way of doing it.First, I make sure the model element extendsbehind the panel using position: absolute.The backdrop-filter gives the frosted glass effectby blurring the pixels of the model element.The linear-gradient gives a specular highlight on the edgeto give a sense of thickness,while keeping the panel light in color so that the text is easy to read.All these are good old CSS tricks that have existed for some time,but they really shine when combined with the depth effect of the model element.The page is looking so good now,but we can make the model look even better by adjusting the lighting effect.Here, I’m applying different lighting to the same model file.Notice how different they look depending on the lighting chosen.To control the lighting effect, you use a special kind of imageto define what the environment looks like for the model,so that your model will reflect lights contributed by the environment.This technique is called image-based lighting, or IBL for short.The image is often called an IBL file.The IBL file may look distorted because it’s projectingthe entire 360 degree of the environment onto a planar image.This flattened spherical projection,also known as equirectangular projection, is very common for IBL files.Note that the IBL file is not part of the USDZ file,so it has to be specified during rendering.

To specify the IBL for model elements,you should use the environmentmap attribute.If you don’t supply one, the browser will apply a default lighting for your model.Because the IBL is not part of the USDZ file,when the model file is used outside of the webpage,it will not get the same lighting effect.This allows the presenting app to apply the most suitable lightingfor the viewing experience.One tip I have is that you should consider usingOpenEXR and Radiance HDR formats for your IBL file.These two formats will make reflections a lot more realistic,because they represent brightness level across many orders of magnitude.On the other hand, a JPEG IBL will look very dull and flat.

With your model looking great, it’s time to let your visitors interact with it.The model element supports a variety of user interactions out of the box.

By default, pinch and hold on the model elementwill initiate a drag and drop interaction.People can drop the model to another app or drop it to an empty locationto view the model in their space through Quick Look.This is a fantastic way for people to see the model in their real size,with realistic lighting effects applied to the model to make it look real.People can stick it onto a surface, turn it around, make it bigger or smaller.In addition to drag and drop, you can also enable pinch and dragon the model element to rotate the model when it’s displayed inline.You can tilt the model up and down,and the model will reset the tilt on release.

This inline rotation behavior is enabledby specifying stagemode equals orbit on the model element.The rotation happens along the y-axis,with small amount of vertical tilting allowed during gesture.

The browser engine will also scale and offset your modelto ensure it remains behind the page surface during rotation.If this stagemode rotation behavior is not sufficient for your use case,you can implement custom interactions manually.

If you want to move and orient the model manually in specific ways,you can do so with JavaScript.

You can control the exact location and orientationyou want your model to be in within the virtual space.This is achieved by changing the transformation matrixexposed by the model element.

The transformation matrix is exposed through the entityTransform property.When the model is loaded, the browser computes the transformation neededfor the default placement and saves it to the entityTransform property.The property will be populated once the ready promise resolves.

Let me show you an example of customizing the placement of the model.Here, we want to offer a link that will rotate the model to face right.

In the turnRight function, read the browser computed transformation matrixfrom the entityTransform property.Then, apply a 90 degree rotation along the y-axisusing the rotateAxisAngle method,which is an existing API of the DOMMatrix class.0-1-0 means the y-axis, and 90 means rotate for 90 degrees.Once we have our new matrix,set it back to the entityTransform propertyfor it to take effect.The operations supported by an entityTransform matrixinclude uniform scaling, rotation, and translation.You will get an error if you try to assign a matrixcontaining unsupported operations to the entityTransform property.The default entity transform should be sufficient for most use cases.But some of you may want to understand the mathbehind the default computation.To understand that, it helps to go back to the basics and discussthe entity transform behavior for an identity matrix.

If you set the entity transform to an identity matrix,it will align the origin of the USDZ file tothe center point of the model element.Remember, the model is only rendered within the space behind the page surface.so any parts extending forward will be clipped.In addition, it renders such that 1 cm in the USDZ fileequals exactly 1 cm in CSS,which is around 38px in CSS.

On visionOS, the Safari window grows biggerwhen it's further away from the user.Therefore, when the model is displayed on the webpage,there’s no relationship between the units used in the USDZ fileand the physical units in the real world.

If you need to showcase your object in its real physical size,the best way is to let people drag it out of the pageand view it through Quick Look, as we have shown previously.

The entityTransform property can be used in really creative ways.In this previous example, it zooms into different parts of the modelas we go through different features of this camera.And to just moving it around,you can even animate the camera screen open and close using model animations.Let me show you how.

The USDZ file format supports defining animations within the file itself,and is a well-supported feature in all major authoring tools.Some USDZ files contain multiple tracks of animations too.

The model element supports playbackof the first animation track defined in the USDZ file.

For simple looping animations,you can use the loop and autoplay attribute.If you want to control the animation manually,you can use the play and pause methods on the model element.You can determine whether the animation is playing using the paused property.

These few API may look familiar to you because they’re actuallythe same as those for the video element.

For more complex use cases,you can use your 3D modeling software to build a timeline for your model,animating between different states.In my camera model file,I first animate the opening and closing of the camera flashlight,followed by the opening and closing of the camera screen.The animation information is stored inside the USDZ file.When you put an animated model in the model element,you can jump to any point in the timeline using the currentTime property.For example, if I want to open the flash on the camera,I just need to set the currentTime property to 1.

Keep in mind the unit for the currentTime property is seconds.Similarly, if I want to open the screen,I just set it to 3.Pay attention to how the model is updated instantly without any implicit animation.This allows you to jump to discontinuous timestamps toachieve any specific effect you need.You can create interesting experiencesby hooking up the currentTime property with some interactions.

Here, I have a slider that has a value range between 2 and 3.Meant to cover the portion of the timelinewhere the screen animates open.I add an event listener to watch for the slider value change.And when that happens,I set the current time to the value of the slider.This way, my visitors can use the slider to control the position of the screen.You can extend this idea to other interactions,like scrolling of a page or a custom drag event.You can also combine currentTime and entityTransform in creative ways.In this previous camera page example, the animation is driven by a timer.The individual parts are animated using the currentTime property,while the movement of the whole camerais animated using the entityTransform property.The page is becoming really nice, but you may want to make it even betterby adding a personal touch, like allowing people to engrave on the product.But you cannot possibly know what text to put into the USDZ model ahead of time.That’s where dynamically generated models come into play.

If your use case requires displaying a modelthat depends on user input at runtime,you can use JavaScript to programmatically generatea USDZ file in the browser and display it within the model element.

Three.js is a powerful JavaScript librarythat allows you to create 3D models programmatically.Three.js is a deep subject on its own,so we are not going to discuss the fine details of it today.At a high level, you have a THREE.Scene objectthat contains the model you created procedurally.So let’s assume you have a nicely crafted scene object already.Three.js comes with a USDZ exporter module that you can import.Once imported, you can use the parseAsync methodto generate the data blob for the full USDZ file of the model scene.You can create an object URL pointing to the data blob you have generatedusing the URL.createObjectURL method.

Now you have the object URL,you can set it to the source attribute of the model element,and it will start rendering.With this technique, you’re no longer limitedto using static known USDZ files you prepared offline.

You can add customizations to models based on data inputs from your visitors,like adding the name to a product or changing the color of the text.

One cool thing about this is that the model can still be dragged outand viewed in people’s space.

There are a lot more APIs supported by the model element,and we have only covered some of them today.The rest of them could be useful to you as you adopt models on your webpages.

You can learn more about the model element at the MDN documentation pageand the model element proposal at the W3C website.You can find the URLs at the related links for this session.

Let me tell you about another category of content,immersive media.Last year, we introduced ways for you to display panoramaand spatial photos from your website.We are extending the support to spatial video, 180-degree, 360-degree,and wide field-of-view video, as well as Apple Immersive Video.And we have some updates to presenting panorama and spatial photos too.With iPhone 15 Pro or newer,you can capture spatial video right from the Camera app,and they can be viewed spatially from the Photos app on Apple Vision Pro.Now, with visionOS, there is new support for three immersive media types:180-degree, 360-degree, and wide field-of-view video.These media types extend beyond a flat surface,wrapping around the user to provide an immersive experience.

There is also new support for presenting Apple Immersive Video,with high resolution stereo video perfectly calibratedto each lens in the camera that captured it.You can learn about these new media types at the WWDC session this year,“Explore video experiences for visionOS”.

When an immersive media file is embedded on the page,such as this 360-degree video, it will render as a 2D video.To let people view it immersively, present your video in full screen,and the video will wrap around the user with the correct projection.The full screen player also supports stereoscopic content,which is often found in 180-degree and Apple Immersive Video formats.You may already have taken some immersive media before.Now is the best time to showcase them on your website.You can embed all these media types on your websiteusing the existing video element.There’s no new element or attribute involved.You can also use HTTP Live Streaming to serve large video assets as usual.For 180, 360 and wide field-of-view media, the file should conform to APMP,the Apple Projected Media Profile,which contains extra metadata to describe the media’s projection.To learn how to convert your existing media to APMP,check out the WWDC session this year:“Learn about the Apple Projected Media Profile.”To learn more about Apple Immersive Video,check out “Learn about Apple Immersive Video technologies.”Here is an example of wide field-of-view APMP.The metadata captures the camera parameters that was used during recording.visionOS will then present the mediain a shape that will line up each pixels to its intended location,resulting in correct projection during playback.Notice how straight lines will look straight even on the edgeswhen viewed in full screen.This is the power of APNP.The default controls for video element allow people to enter full screen.You can also programmatically enter full screenusing the requestfFullScreen API from JavaScript.In fact, this is the exact same API as you would useto present panorama and spatial photo from your webpage.For panorama, you can now supply different sources for the same picture element,so that you can display a suitable thumbnail before going full screen.Once entered full screen, the widest variant will be used.

For spatial photos,the requestFullscreen API works the same way.

The spatial photo will render as a flat 2D imagewhen it’s displayed in line,and will render spatially when it’s presented full screen.

In my experience, I always have to communicate to my visitorsthat this particular image is actually spatial,and that they should tap on it to see its true beauty.

This may become much easier in the future by using the new attribute, controls,which has been added as a developer preview feature since visionOS 2.4.

The controls attribute adds a spatial photo badge,indicating that this image is a spatial photo.Coupled with the full screen button,your visitors can easily view the spatial version of the image,all without having you to write a single line of JavaScript.Like all developer preview features,you will have to explicitly turn this feature on to try it out.To do so, go to Settings > Apps > Safari > Advanced > Feature Flags,and enable Spatial Image Controls API.While we are here, let’s also enable the other one,Website environments, as we’re going to talk about it next.

Website environment is a new developer preview featurewe’re introducing this yearto allow websites to provide a virtual environment for their visitors.

Here's how it works.This example page has specified a USDZ file as the environment,and people can choose to display the environment through the page menu,while still keeping Safari and the website in view.They can use the digital crown to fully immerse themselvesin the environment undistracted.This is a fantastic way to augment your websitebeyond the bounds of the browser window.

To provide an environment, use a link element specifying rel equals spatial-backdrop.Then, use the href attribute to point your environment USDZ file.Just like 3D models,you can use the environmentmap attribute to supply a custom IBL for your USDZ file.With a well-crafted environment,your visitors will feel like they are teleported to another locationlike a restaurant, a submarine, or a dungeon.Since this is a developer preview,you will need to enable the feature in Settings before you can try it out.The markup may change in the futureas it goes through the web standards process.Apple is actively leading the development of this feature,and your feedback will help shape its future.

To learn more about creating a custom environment, please check out“Create custom environments for immersive apps in visionOS”from WWDC24.

We have covered a lot of new spatial web features today.

We talked about the new HTML model element,with its support for interactions, custom lighting, and manual placement.Using the existing video element,you can display a range of new immersive media straight from your website.And you got a sneak peek of what website environments would be like in the future.

To help you get started,we have added some example usage of model element on webkit.org.There’s no better way to experience itthan actually seeing it through your Apple Vision Pro.Once you feel ready,go ahead and add 3D models to your webpage where appropriate.to give your visitors a stunning new experience.If your website serves video,now is a great time to start including immersive media on your website.We would love for you to experiment with adding custom environmentsand share your feedback with us.

Besides the spatial web,there’s a lot more new features for the web,which you can learn more at“What’s new for Safari and WebKit” session this year.

You can file bug reports and feature requests for web technologyat bugs.webkit.org, the issue tracker for WebKit.

Issues about the interface of Safari or anything about visionOSor other Apple platforms,please file those at feedbackassistant.apple.com.We are eagerly waitingto see all the amazing things you’re going to build with these new technologies.Thank you, and have a great WWDC.

1:00 -Embed 3D models - Basic syntax

4:15 -Embed 3D models with source element

5:30 -Example server configurations to add USDZ MIME type support

5:51 -Specify a fall back image forelement

6:17 -Example 2D rendering fallback experience

6:52 -Detect if the model element is supported

7:32 -Implementing a loading indicator using .ready promise

8:23 -CSS example for setting the color of the virtual space

9:21 -CSS example for frosted glass panel on top of a

10:56 -Setting image-based lighting (IBL) with environmentmap

12:41 -Allowing inline rotation with stagemode

13:31 -Customize placement with JavaScript entityTransform

13:49 -Make the model face right with entityTransform

15:03 -Setting the entityTransform to an identity matrix

16:31 -Basic animation control

17:35 -Jump to animation timestamp using .currentTime property

18:11 -Update .currentTime with a slider

19:35 -Generate USDZ with three.js and display with

23:10 -Embed immersive media

24:25 -Going full screen with Javascript forelements

24:35 -Embed panoramas and offer full screen with Javascript

24:57 -Embed spatial photos and offer full screen with Javascript

25:21 -Embed spatial photos with the new "controls" attribute

26:49 -Provide a custom environment

0:00 -IntroductionThe visionOS Safari team introduces new features for the spatial web this year, including stereoscopic 3D model rendering, immersive media playback, and developer preview features like website environments.0:55 -Embed 3D modelsThe evolution of web development introduces the HTML Model element, enabling the seamless embedding of 3D models directly onto webpages. This new feature, now available by default in Safari on visionOS, revolutionizes how people interact with web content by providing stereoscopic rendering, allowing them to perceive depth and explore 3D objects from various angles.21:24 -Present immersive mediaSupport for immersive media on websites is expanded, enabling you to embed various formats such as spatial, 180-degree, 360-degree, and wide-field-of-view videos. With iPhone 15 Pro or later, users can capture spatial video directly from the Camera app and view it on Apple Vision Pro.26:14 -Provide custom environmentThere's also a new developer preview feature for Safari called Website Environment. This feature allows websites to create virtual environments using USDZ files, enabling visitors to experience immersive settings — such as restaurants, submarines, or dungeons — while still keeping Safari and the website in view. 

You can implement this feature by using specific HTML markup, linking to USDZ files, and customizing the environments with IBLs. The feature is currently in development, and feedback is encouraged to shape its future.

0:00 -Introduction

The visionOS Safari team introduces new features for the spatial web this year, including stereoscopic 3D model rendering, immersive media playback, and developer preview features like website environments.

The visionOS Safari team introduces new features for the spatial web this year, including stereoscopic 3D model rendering, immersive media playback, and developer preview features like website environments.

0:55 -Embed 3D models

The evolution of web development introduces the HTML Model element, enabling the seamless embedding of 3D models directly onto webpages. This new feature, now available by default in Safari on visionOS, revolutionizes how people interact with web content by providing stereoscopic rendering, allowing them to perceive depth and explore 3D objects from various angles.

The evolution of web development introduces the HTML Model element, enabling the seamless embedding of 3D models directly onto webpages. This new feature, now available by default in Safari on visionOS, revolutionizes how people interact with web content by providing stereoscopic rendering, allowing them to perceive depth and explore 3D objects from various angles.

21:24 -Present immersive media

Support for immersive media on websites is expanded, enabling you to embed various formats such as spatial, 180-degree, 360-degree, and wide-field-of-view videos. With iPhone 15 Pro or later, users can capture spatial video directly from the Camera app and view it on Apple Vision Pro.

Support for immersive media on websites is expanded, enabling you to embed various formats such as spatial, 180-degree, 360-degree, and wide-field-of-view videos. With iPhone 15 Pro or later, users can capture spatial video directly from the Camera app and view it on Apple Vision Pro.

26:14 -Provide custom environment

There's also a new developer preview feature for Safari called Website Environment. This feature allows websites to create virtual environments using USDZ files, enabling visitors to experience immersive settings — such as restaurants, submarines, or dungeons — while still keeping Safari and the website in view. 

You can implement this feature by using specific HTML markup, linking to USDZ files, and customizing the environments with IBLs. The feature is currently in development, and feedback is encouraged to shape its future.

There's also a new developer preview feature for Safari called Website Environment. This feature allows websites to create virtual environments using USDZ files, enabling visitors to experience immersive settings — such as restaurants, submarines, or dungeons — while still keeping Safari and the website in view. 

You can implement this feature by using specific HTML markup, linking to USDZ files, and customizing the environments with IBLs. The feature is currently in development, and feedback is encouraged to shape its future.

## Code Samples

```swift
<
model
 
src
=
"teapot.usdz"
>
</
model
>
```

```swift
<
model
>

  
<
source
 
src
=
"teapot.usdz"
 
type
=
"model/vnd.usdz+zip"
>


</
model
>
```

```swift
# Apache



```
AddType model/vnd.usdz+zip .usdz
```



# NGINX mime.types



```
types {
  ...
  model/vnd.usdz+zip usdz;
}
```



# Python HTTP server



```
import http.server
Handler = http.server.SimpleHTTPRequestHandle
Handler.extensions_map = { ".usdz": "model/vnd.usdz+zip" }
httpd = http.server.HTTPServer(("", 8000), Handler)
httpd.serve_forever()
```
```

```swift
<
model
 
src
=
"camera.usdz"
>

  
<
img
 
src
=
"camera.png"
>


</
model
>
```

```swift
<!-- <model-viewer> library from https://modelviewer.dev/ -->


<
script
 
type
=
"module"
 
  
src
=
"https://ajax.googleapis.com/ajax/libs/model-viewer/4.0.0/model-viewer.min.js"
>


</
script
>



<
model
 
src
=
"camera.usdz"
>

  
<!-- Fallback experience for backward compatibility -->
  
  
<
model-viewer
 
src
=
"camera.glb"
>
</
model-viewer
>


</
model
>
```

```swift
if
 (
window
.
HTMLModelElement
) {
  
// Supported by this browser

} 
else
 {
  
// Not supported by this browser

}
```

```swift
<
model
 
src
=
"camera.usdz"
 
id
=
"mymodel"
>
</
model
>



<
script
>


const
 mymodel = 
document
.
getElementById
(
"mymodel"
);


if
 (
window
.
HTMLModelElement
) {
  mymodel.
ready
.
then
(
result
 =>
 {
	
// Hide the loading indicator

	
// Show the model

 }).
catch
(
error
 =>
 {
	
// Loading error occurred, show a retry button

 });
}

</
script
>
```

```swift
<
body
>

  
<!-- page content here -->

  
<
model
 
src
=
"camera.usdz"
 
class
=
"my_model"
>
</
model
>


</
body
>



<
style
>


:root
 {
  
--main-bg-color
: 
rgb
(
240
, 
240
, 
240
);
}


body
 {
  
background-color
: 
var
(--main-bg-color);
}


.my_model
 {
  
/* set the virtual space color */

  
background-color
: 
var
(--main-bg-color); 
}

</
style
>
```

```swift
<
div
 
class
=
"container"
>

  
<
model
 
src
=
"camera.usdz"
>
</
model
>

  
<
div
 
class
=
"panel"
>
 ... 
</
div
>


</
div
>



<
style
>


.container
 {
  
position
: relative;
}


.panel
 {
  
position
: absolute;
  
left
: 
60%
;
  backdrop-
filter
: 
blur
(
20px
);
  
background
: 
linear-gradient
(to right,
                              
rgba
(
240
, 
240
, 
240
, 
0.8
),
                              
rgba
(
240
, 
240
, 
240
, 
0.5
) 
4px
);
}

</
style
>
```

```swift
<
model
 
src
=
"camera.usdz"
 
environmentmap
=
"sunset.exr"
>
</
model
>
```

```swift
<
model
 
src
=
"teapot.usdz"
 
stagemode
=
"orbit"
>
</
model
>
```

```swift
<
model
 
src
=
"teapot.usdz"
 
id
=
"mymodel"
>
</
model
>



<
script
>


const
 mymodel = 
document
.
getElementById
(
"mymodel"
);
mymodel.
ready
.
then
(
result
 =>
 {
  
const
 matrix = mymodel.
entityTransform
; 
// DOMMatrixReadOnly

});

</
script
>
```

```swift
<
model
 
src
=
"teapot.usdz"
 
id
=
"mymodel"
>
</
model
>


<
a
 
onclick
=
"turnRight()"
>
Right
</
a
>



<
script
>


const
 mymodel = 
document
.
getElementById
(
"mymodel"
);

function
 
turnRight
(
) {
  
const
 matrix = mymodel.
entityTransform
; 
// DOMMatrixReadOnly

  
const
 newMatrix = matrix.
rotateAxisAngle
(
0
, 
1
, 
0
, 
90
);
  mymodel.
entityTransform
 = newMatrix;
}

</
script
>
```

```swift
model.
entityTransform
 = 
new
 
DOMMatrix
();
```

```swift
<
model
 
src
=
"toy.usdz"
 
id
=
"mymodel"
 
loop
 
autoplay
>
</
model
>


<
button
 
onclick
=
"toggleAnimation()"
>
Play/Pause
</
button
>



<
script
>


const
 mymodel = 
document
.
getElementById
(
"mymodel"
);


function
 
toggleAnimation
(
) {
  
if
 (mymodel.
paused
) {
	mymodel.
play
();
  } 
else
 {
	mymodel.
pause
();
  }
}

</
script
>
```

```swift
<
model
 
src
=
"camera.usdz"
 
id
=
"mymodel"
>
</
model
>



<
script
>


const
 mymodel = 
document
.
getElementById
(
"mymodel"
);


function
 
openFlash
(
) {
  mymodel.
currentTime
 = 
1
; 
// Unit is seconds

}


function
 
openScreen
(
) {
  mymodel.
currentTime
 = 
3
; 
// Unit is seconds

}

</
script
>
```

```swift
<
model
 
src
=
"camera.usdz"
 
id
=
"mymodel"
>
</
model
>


<
input
 
type
=
"range"
 
id
=
"slider"
 
min
=
"2"
 
max
=
"3"
 
step
=
"any"
 
value
=
"2"
>




<
script
>


const
 mymodel = 
document
.
getElementById
(
"mymodel"
);

slider.
addEventListener
(
"input"
, 
(
event
) =>
 {
  mymodel.
currentTime
 = event.
target
.
value
;
});

</
script
>
```

```swift
import
 * 
as
 
THREE
 
from
 
"three"
;

import
 { 
USDZExporter
 } 
from
 
"three/examples/exporters/USDZExporter.js"
;


async
 
function
 
generateModel
(
) {
	
const
 scene = 
new
 
THREE
.
Scene
();
	
// ... create a really nice scene procedurally ...


	
const
 bytes = 
await
 
new
 
USDZExporter
().
parseAsync
(scene);
	
const
 objURL = 
URL
.
createObjectURL
(
new
 
Blob
([bytes]));

	
const
 mymodel = 
document
.
getElementById
(
"mymodel"
);
	mymodel.
setAttribute
(
"src"
, objURL);
}
```

```swift
<
video
 
src
=
"spatial_video.mov"
>
</
video
>
  
<!-- Single file -->


<
video
 
src
=
"360_video.m3u8"
>
</
video
>
  
<!-- HTTP Live Streaming -->
```

```swift
<
video
 
src
=
"360_video.m3u8"
 
id
=
"player"
 
controls
>
</
video
>



<
script
>


const
 player = 
document
.
getElementById
(
"player"
);
player.
requestFullScreen
();

</
script
>
```

```swift
<
picture
>

  
<
source
 
media
=
"(max-width: 799px)"
 
srcset
=
"thumbnail.jpg"
>

  
<
source
 
media
=
"(min-width: 800px)"
 
srcset
=
"panorama.jpg"
>

  
<
img
 
src
=
"panorama.jpg"
 
id
=
"pano"
>


</
picture
>

    

<
script
>


const
 pano = 
document
.
getElementById
(
"pano"
);
pano.
requestFullScreen
();

</
script
>
```

```swift
<
img
 
src
=
"spatial.heic"
 
id
=
"img"
>

  

<
script
>


const
 img = 
document
.
getElementById
(
"img"
);
img.
requestFullScreen
();

</
script
>
```

```swift
<
img
 
src
=
"spatial.heic"
 
id
=
"img"
 
controls
>
```

```swift
<
link
 
rel
=
"spatial-backdrop"
 
href
=
"office.usdz"
 
environmentmap
=
"lighting.hdr"
>
```


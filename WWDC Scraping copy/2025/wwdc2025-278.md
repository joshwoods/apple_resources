# Wwdc2025 278

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Summary

Transcript

Code

What’s new in widgetsWidgetKit elevates your app with updates to widgets, Live Activities, and controls. Learn how to bring your widgets to visionOS, take them on the road with CarPlay, and make them look their best with accented rendering modes. Plus, find out how relevant widgets can be surfaced in the Smart Stack on watchOS, and discover how push notifications can be used to keep your widgets up to date.Chapters0:00 -Introduction1:03 -Widgets in new places15:31 -Relevance widgets18:12 -Push widget updatesResourcesIncreasing the visibility of widgets in Smart StacksOptimizing your widget for accented rendering mode and Liquid GlassRelevanceKitUpdating widgets with WidgetKit push notificationsUpdating your widgets for visionOSHD VideoSD VideoRelated VideosWWDC25Design widgets for visionOSTurbocharge your app for CarPlayWhat’s new in watchOS 26WWDC24Design Live Activities for Apple WatchExtend your app’s controls across the systemWWDC23Bring widgets to new placesMeet Push Notifications ConsoleWWDC20The Push Notifications primer

WidgetKit elevates your app with updates to widgets, Live Activities, and controls. Learn how to bring your widgets to visionOS, take them on the road with CarPlay, and make them look their best with accented rendering modes. Plus, find out how relevant widgets can be surfaced in the Smart Stack on watchOS, and discover how push notifications can be used to keep your widgets up to date.

0:00 -Introduction

1:03 -Widgets in new places

15:31 -Relevance widgets

18:12 -Push widget updates

Increasing the visibility of widgets in Smart Stacks

Optimizing your widget for accented rendering mode and Liquid Glass

RelevanceKit

Updating widgets with WidgetKit push notifications

Updating your widgets for visionOS

HD VideoSD Video

HD Video

SD Video

Design widgets for visionOS

Turbocharge your app for CarPlay

What’s new in watchOS 26

Design Live Activities for Apple Watch

Extend your app’s controls across the system

Bring widgets to new places

Meet Push Notifications Console

The Push Notifications primer

Search this video…Hi, my name is Tanner Oakes,and I’m an engineer on the System Experience team.Widgets are a great way to surface timely information and actions across the system,keeping your app useful even when it’s not front and center.WidgetKit continues to expand, making your widgets more capableand taking your widgets to new places.My friend Luca has a caffeine logging app.I've been helping him update it.Throughout this talk, I’ll show you how it takes advantage ofeverything new in widgets.In this video, I’ll cover widgets, Live Activities,and controls in new places across our platforms.I’ll also cover a new way to show relevant widget contentin the Smart Stack on watchOS.And finally, I’ll show you how to keep your widgets up to dateacross devices with push notifications.Widgets, Live Activities, and controls are in a lot of new places.But first, I’ll cover a new look for widgetsin the places where they first got their start.In iOS 26, the Home Screen can be configuredto present icons and widgets in a clear glass presentation,or further customized by selecting a specific tint color, like blue here.These looks can be configured for widgets on the desktopand Notification Center in macOS Tahoe as well.These new presentations are constructed similarly across iOS and macOS.First, the widgets content is generated using accented rendering mode,tinting all of the content to white.Then the widgets background is removedand replaced with a themed glass or tinted color effect.My caffeine tracker widget looks great in accented mode,without having to do anything.Some widgets might need some tweaking to look their best in accented mode.I’ve added a widget to my app that shows memy most frequently consumed beverage.For me, it's a matcha latte.My widget has a big image representing the beverage,a title at the bottom, and a gradient behind the text,making it more readable when placed on top of the image.When accented rendering is applied,all of the widget’s content is tinted white.For opaque content like my latte cup, it is all a single white color.Partially transparent content like my gradientis tinted white while maintaining its opacity.This is really not the look I'm going for.I can’t make out the image anymore and text is hard to read.I’ll show you how I can update my widget to better handle accented rendering.Here is my widget’s view.I have a ZStack with the beverage image, the gradient, and then the text view.First, I’ll add the widgetRenderingMode environment variable to my widget view.I’ll conditionally display the large image and linear gradientonly if the widget is being rendered in full color.Then I’ll bring my image back above the text by adding in a VStackand conditionally displaying my Image if the widget’s in accented mode.I think my layout is looking pretty good.Now I just need to improve the look of my image.I’ll add the widgetAccentedRenderingMode modifier to my Image,setting it to desaturated.widgetAccentedRenderingMode is a SwiftUI modifierthat can be applied to Images in widgets.The argument I pass in gives me precise controlover how my Image should be shown when in accented mode.There are five different options widgetAccentedRenderingMode accepts.I’ll show you how each of these modes affect the presentation of images,comparing iOS and macOS accented mode to an accented mode on a watch face.For widgetAccentedRenderingMode,passing in nil is the same as not applying the modifier at all.It applies the primary content color to the image.For both my iOS and watchOS widget, this makes my image completely white.Passing in accented tints the image to the accent color.On iOS and macOS, both primary and accent colors are white,making my image white.On watchOS, the accent color matches the color on the watch face,making my watchOS widget's image blue.Passing in desaturated will desaturate the color in the image.This effect looks the same on both iOS and watchOS presentation styles.Passing in accentedDesaturated will apply both the effects,desaturate the colors in the image,and apply the accent color from the selected theme.On iOS, this means the Image is a little whiter,while on watchOS, my desaturated imagenow takes on the theme’s blue accent color.Passing in fullColor shows the Image completely unmodifiedin accented rendering mode.To best blend in with the watch face, this option is ignored on watchOS.For most widgets, use either desaturated or accented desaturatedto help the Image content blend in with the rest of the home screen.Use fullColor for Images that represent media content,such as album artwork or a book cover.Next, I’m excited to show you how to take your widgets into a whole new dimension.With visionOS 26, your visionOS apps can now include widgets.And if you already have a compatible iPhone or iPad app with widgets,those automatically become available in visionOS.All of the system family sizes from iOS and macOS are supported.And widgets in visionOS have interaction and animation capability,just like other platforms.I’ll show you how widgets work on visionOS and new options that WidgetKit provides.In visionOS, widgets can be added into the room and then pinned to a surface.By default, they’ll take on an elevated look,sitting directly on top of the surface.Widgets can also be recessed, making the widget appearlike it’s embedded directly into the surface.If one of these styles isn’t a good fit for your widget,use the supportedMountingStyles modifier on your widget configurationto specify which options should be provided.This modifier is available for both visionOS and iOS widgets.By default, all widgets will be rendered beneath a glass texture.For visionOS apps, an alternative paper texture can be specified,giving the widget a poster style look.Here on the left I have my frequent beverage widget configured with glass,and on the right I’m testing out the same widgetbut with the paper texture applied.Use the widgetTexture modifier on your widget configurationto specify whether your widget should be rendered with a paper textureor behind a pane of glass.To complete the look of poster style widgets,a new systemExtraLargePortrait widget family is available in visionOS.This is a vertically oriented versionof the existing horizontal systemExtraLarge widget family.Add this to your widget configuration using the supportedFamilies modifier.In visionOS, the widget’s color theme can also be customized.By default, the widget will appear in a full color presentation.If I select this green theme, the widget’s content is displayedusing accented rendering mode.The widget frame and content get tinted with my selected color.Then the background is removed and replaced with a solid colorthat complements the selected color theme.This style applies the same rendering approach discussed earlierfor iOS and macOS.Use the same techniques I coveredto make your widget look its best in these color themes.Use the widgetAccentedRenderingMode modifierto customize the presentation of your images.And use the widgetRenderingMode environment variableto conditionally apply more substantial modifications.On visionOS, widgets can be brought into your environmentand placed on multiple surfaces.As you move about your space, widgets stay in their fixed position.Even if a widget is far away on a wall across the room, it remains visible.Just like real physical objects, widgets that are further awayare smaller and harder to see.Unlike physical objects, widgets in visionOS can adaptbased on their distance using a new level of detail API.I’ll show you how I can add levelOfDetail to my caffeine tracking widget.Here I have my existing widget that shows my total caffeine for the day,the last beverage I drank,as well as a handy button to add another drink to the log.When this widget is further away from me,I’d like to make the total caffeine value larger and easier to read.I’d also like to hide the button,since it will be harder to hit further away.Here’s my caffeine tracker widget.I want to update my TotalCaffeineView, changing its size,and conditionally show or hide my LogDrinkView at the bottom.First, I’ll add this environment property, levelOfDetail, to my view.LevelOfDetail can be one of two values.Default is the normal level of detail expected of widgets.On visionOS, widgets are shown in the default level of detailwhen they are at a comfortable distance.If the widget is physically far enough away,the level of detail changes to simplified,providing an opportunity to display a simpler,more easily glanceable representation of the widget.I’ll add this conditional around my LogDrinkViewto only display if the levelOfDetail is default.Now I need to update the caffeine amount.In my total caffeine view, I’m displaying the titleand the formatted total caffeine amount.First, I’ll add the levelOfDetail environment variable to my view.In order to make this bigger,I’ll conditionally change the font of my caffeine amountfrom title to large title based on the level of detail.Now, whenever the widget is far enough away,my widget transitions to show a simpler,more easily glanceable version of my widget.And just like timeline changes within your widget,level of detail changes also animate.To learn more about when to customize your spatial style,recommendations for level of detail,and other considerations for bringing your widgets to this new platform,check out “Design Widgets for visionOS.”Shifting gears, now widgets and Live Activities,are hitting the open road with CarPlay.In CarPlay Ultra,widgets appear in one or more stacks to the left of the dashboard.And starting with iOS 26,this feature now comes to all CarPlay cars.Widgets can be configured in the Settings app under CarPlay.In CarPlay, glanceable information, large typography, and legibilityare all important to help make your widget easy to read on the car’s display.To support this, CarPlay renders widgets in a StandBy style,using the systemSmall family in fullColor with the widget background removed.Widget interactions are supported on touchscreens,and you can use the CarPlay simulatoravailable on the developer site to test your widget.Get more tips on how to adapt your widget for a StandBy presentationin “Bring widgets to new places” from WWDC 23.Live Activities can also be displayed on the home screen in CarPlay.By default, your Live Activity’s Dynamic Islandleading and trailing views will be shown.Here I have my Coffee Order Tracking Live Activitybeing displayed in CarPlay.This is a good start, but with just a little bit of extra code,I can make this even better.Here’s the code for my Live Activity.Currently, my leading and trailing views are shown.To customize this Live Activity presentation for CarPlay,I’ll add the supplementalActivityFamilies modifier,passing in small as an argument to my ActivityConfiguration.Now, rather than using the leading and trailing views,CarPlay will display my ActivityView,the same view that’s used on the iPhone lock screen.For some Live Activities, this may look great,but mine is a little cramped with some of my content cut off.Luckily, I can customize this even further.Here is my ActivityView.I’ll add the activityFamily environment variable to my view.With that added, in my views body, I can conditionally display different contentor adjust the layout to provide a great experience.When the activityFamily is small,I’ll provide a shop order view that is optimized for a smaller layout.Otherwise, I’ll display my default order view.With that little bit of extra code,my Live Activity now looks great in CarPlay.Now I can quickly glance and see how much longer until my order is ready.By adopting supplementalActivityFamily,I’ve also greatly improved how my Live Activity lookswhen presented on a paired Apple Watch.Your iPhone app gets this automatically,without the need for a separate watchOS app.To learn more about how to make your Live Activity look its bestin the Smart Stack on watchOS,check out “Design Live Activities for Apple Watch.”And check out “Turbocharge your app for CarPlay”to learn more about how to really accelerate your widgets in CarPlay.CarPlay isn’t the only new place for Live Activities.Live Activities from a paired iPhone will now appear in macOS Tahoe.Just like in the Dynamic Island on iPhone, my coffee order tracker Live Activitypresents the leading and trailing views together in the menu bar.When the Live Activity is selected,the lock screen presentation from iPhone will appear.Clicking on the lock screen presentation will launch the associated appusing iPhone Mirroring.Live Activities on macOS can be provided by iPhones running iOS 18 and later.There are no code changes required, and just like iPhone widgets on macOS,they support interaction and deep links.Now I’ll cover new places for controls on macOS and watchOS.On macOS, controls can be provided by apps running on the Mac,whether they’re built with the macOS SDK, Catalyst,or from iOS apps running on Apple Silicon Macs.Controls can be added in the Control Center.The same small, medium, and large presentations available on iOScan also be configured on macOS.Controls can also be placed directly on the menu bar.Now that I’ve added a coffee tracker control to my app on macOS,I can easily update my coffee log right from the menu bar.In watchOS 26, controls can appear in three places.They can be configured in the Control Center,accessible from the side button.Controls can also be executed when pressing the Action buttonon Apple Watch Ultra.And they can be configured in the Smart Stack,where they appear alongside other widgetsdisplaying the control’s symbol, title, and current value.Controls can be provided from a watchOS appor from an iPhone app on a paired device.For an extensive guide to building controls,check out“Extend your app’s controls across the system” from WWDC24.Next, I’ll show you relevance widgets in the Smart Stack in watchOS 26.I’ve added a widget to my caffeine tracking app on watchOSthat helps me keep track of when my favorite coffee shopshave half price happy hours.There’s two things I’d like to improve with my widget.First, since I’m tracking the happy hours for several coffee shops,often their happy hours overlap,meaning the content on my widget in the Smart Stack is pretty cramped.Second, the happy hours tend to happen around the same time.So for the rest of the day, my widget isn’t very useful.I’d really like my happy hours widgetto only show up in the Smart Stack if it was relevantand show more detailed information for each active happy hour.With relevance widgets in watchOS 26, I can do just that.I’ll show how I can configure my happy hours as a relevance widget.To define a relevance widget, create a Widget typeand instead of a StaticConfiguration or AppIntentConfiguration,provide a RelevanceConfiguration.Just like other configurations, it takes a kind String, a provider object,and a closure to transform your custom entry into a SwiftUI view.The provider type is a RelevanceEntriesProvider.The placeholder and relevance methods are similar to TimelineEntriesProvider.For placeholder, I can return a simple Entry to be displayedwhile my content is getting prepared.For relevance,  I first fetch a collection of configuration objectsthat I’ve defined.For my happy hours widget, a configuration is relevantbetween the start and end time of that happy hour.I’ll define the relevance attribute with this contextusing the date interval for each happy hour.Then I implement the entry method.Unlike a Timeline widget, a RelevanceEntriesProvideronly provides a single entry for a configuration.I have all the data I need for this entry in my configuration,the shop data and the time range for the happy hour,so I can create that immediately.If I needed any other data or assets,I could fetch them here since this method is marked async.Now with my relevance widget set up,my happy hours widget only displays in the Smart Stack when it’s relevant.Plus, if I have multiple configurations that are relevant at the same time,I can see multiple instances of my widget in the Smart Stack.Relevance widgets are a powerful new feature in watchOS 26,giving you the ability to directly connect widget content with its relevance.These widgets are a great addition on their ownor alongside existing timeline based widgets.To learn more about Relevance widgets,check out “What’s new in watchOS 26” with Anne.Now that there’s so many more places and platforms that widgets can appear,I’d like to keep my widgets always up to date wherever they are.I’ve recently added a serverso I can keep my caffeine log data in sync across my devices.I’ll cover what options are available for refreshing my widget,starting with scheduled widget reloads.In this diagram, on the left I have my app bundle,which contains my app as well as my widget extension.On the right side, I have a box representing WidgetKit.When a widget is configured on a device,such as on the iPhone home screen, or on a watch face,WidgetKit requests a timeline from the widget extension.The extension responds with a widget timeline,which includes a TimelineReloadPolicy.WidgetKit uses this to determine the next appropriate time to reload that widget.Using the TimelineReloadPolicy is a great optionfor widgets that need to update at regular intervals,such as a widget that displays the hours of a cafe,a weather widget, or a stock widget.The scheduled timeline reload is budgeted by the systemto help maintain performance and battery life.The WidgetCenter API is another option available to apps.Inside an app, if a data change occurs that should be reflected in its widget,WidgetCenter’s reloadAllTimelinesor reloadTimelines(ofKind:) method can be called.This tells WidgetKit that the widget’s content is outdatedand needs to be reloaded.WidgetKit then requests a timelinefrom the widget extension to update the widget.This is a great option if widget content primarily changes inside the app,such as updating a caffeine log, changing a note,or checking off a reminder.Since the app is running when this API is called,the system does not budget this request.But what happens if a data change occurs on the server or on another device?This is where widget push updates come in.A server tracking data changes can send a push notification to APNs,which will tell WidgetKit to reload that app’s widgets.And like other updates,WidgetKit will then request an updated timeline from the widget.Widget push updates are a great toolif data can change external to that device.Just like the TimelineReloadPolicy,widget push notification updates are also budgetedto maintain performance and battery life.With this capability, widgets now have a full suite of reload optionsto handle a variety of situations.These are not mutually exclusive.Some widgets may want to use two or even all three of these options.With widget push updates,my widget’s caffeine log can stay up to date across deviceswhether I log an update on my iPad app, my Vision Pro widget,or my macOS menu bar control.I’ll show you how I can add this to my widget.I’ll create a WidgetPushHandler and add it to my widget configuration,add the Push Notification entitlement to my widget extension,and construct a widget update push request.First, I’ll create a struct conforming to the WidgetPushHandler protocol.This type is how we notify you when your push token changesor when the set of configured widgets changes.Use the pushTokenDidChange methodas an opportunity to send your push token and widget info to your server.Next, I need to update my widget configuration.Here I have the configuration for my caffeine tracker widget.I’ll add the pushHandler modifier to my widgetto register its support for push notifications.For this modifier, I pass in the type of the widget pushHandler I implemented.Finally, in Xcode,I’ll go to the Signing and Capabilities tab for my widget extension.Here, I’ll add the push notification entitlementso it can communicate with APNs.Now that my widget is configured for push updates,I’ll show you how to send a widget update push notification.To update your widget via push notification,send an HTTPS POST request to the Apple Push server.Use the widget push token provided in your WidgetPushHandleras the last part of the request path.For your headers, use the widgets APNs push type,and set the APNS topic header using the app’s bundle ID,suffixed with .push-type.widgets.In the body of your request in the aps dictionary,set the value of the content changed key to true.To learn more about push notifications, watch the “Push Notifications Primer”.And check out “Meet Push Notifications Console”to see how you can easily test push notification requests.Push updates for widgets help keep widget content more up to date,but are performed opportunisticallyand aren’t a direct replacement for other notification experiences.If you have an urgent or important update to show,provide a User Notification.If you have updates occurring regularly during a limited period of time,such as a beverage order, updating sports scores, or flight updates,use a Live Activity.Use widget push updates to keep widget content up to date.Widget push updates are available across all platforms that support widgets.When you send a widget push notification,this will update all of the push enabled widgets configured on the device.Remember that these widget reloads are budgeted.Try to keep your update pushes limited,such as by throttling updates on your server.And during development and test,you can use the WidgetKit developer mode in Settingsto ignore push and reload budgets for your app.I've covered a lot today.Take some time to explore these new platforms for widgets.Check out some of the videos listed earlier to help get inspired.Make sure your widgets look great in new appearances on iOS and macOS.And finally,if your widgets data may be updated from external sources or other devices,consider adding push notifications to keep them up to date.I’m so excited about all the new capabilities and places for widgets.I can’t wait to take your widgets with me wherever I go.Thanks for watching.

Hi, my name is Tanner Oakes,and I’m an engineer on the System Experience team.Widgets are a great way to surface timely information and actions across the system,keeping your app useful even when it’s not front and center.WidgetKit continues to expand, making your widgets more capableand taking your widgets to new places.My friend Luca has a caffeine logging app.I've been helping him update it.Throughout this talk, I’ll show you how it takes advantage ofeverything new in widgets.In this video, I’ll cover widgets, Live Activities,and controls in new places across our platforms.

I’ll also cover a new way to show relevant widget contentin the Smart Stack on watchOS.

And finally, I’ll show you how to keep your widgets up to dateacross devices with push notifications.

Widgets, Live Activities, and controls are in a lot of new places.

But first, I’ll cover a new look for widgetsin the places where they first got their start.

In iOS 26, the Home Screen can be configuredto present icons and widgets in a clear glass presentation,or further customized by selecting a specific tint color, like blue here.

These looks can be configured for widgets on the desktopand Notification Center in macOS Tahoe as well.

These new presentations are constructed similarly across iOS and macOS.First, the widgets content is generated using accented rendering mode,tinting all of the content to white.Then the widgets background is removedand replaced with a themed glass or tinted color effect.My caffeine tracker widget looks great in accented mode,without having to do anything.Some widgets might need some tweaking to look their best in accented mode.I’ve added a widget to my app that shows memy most frequently consumed beverage.For me, it's a matcha latte.My widget has a big image representing the beverage,a title at the bottom, and a gradient behind the text,making it more readable when placed on top of the image.When accented rendering is applied,all of the widget’s content is tinted white.For opaque content like my latte cup, it is all a single white color.Partially transparent content like my gradientis tinted white while maintaining its opacity.This is really not the look I'm going for.I can’t make out the image anymore and text is hard to read.

I’ll show you how I can update my widget to better handle accented rendering.Here is my widget’s view.I have a ZStack with the beverage image, the gradient, and then the text view.First, I’ll add the widgetRenderingMode environment variable to my widget view.I’ll conditionally display the large image and linear gradientonly if the widget is being rendered in full color.

Then I’ll bring my image back above the text by adding in a VStackand conditionally displaying my Image if the widget’s in accented mode.I think my layout is looking pretty good.Now I just need to improve the look of my image.

I’ll add the widgetAccentedRenderingMode modifier to my Image,setting it to desaturated.widgetAccentedRenderingMode is a SwiftUI modifierthat can be applied to Images in widgets.The argument I pass in gives me precise controlover how my Image should be shown when in accented mode.There are five different options widgetAccentedRenderingMode accepts.I’ll show you how each of these modes affect the presentation of images,comparing iOS and macOS accented mode to an accented mode on a watch face.

For widgetAccentedRenderingMode,passing in nil is the same as not applying the modifier at all.It applies the primary content color to the image.For both my iOS and watchOS widget, this makes my image completely white.

Passing in accented tints the image to the accent color.On iOS and macOS, both primary and accent colors are white,making my image white.On watchOS, the accent color matches the color on the watch face,making my watchOS widget's image blue.Passing in desaturated will desaturate the color in the image.This effect looks the same on both iOS and watchOS presentation styles.

Passing in accentedDesaturated will apply both the effects,desaturate the colors in the image,and apply the accent color from the selected theme.On iOS, this means the Image is a little whiter,while on watchOS, my desaturated imagenow takes on the theme’s blue accent color.

Passing in fullColor shows the Image completely unmodifiedin accented rendering mode.To best blend in with the watch face, this option is ignored on watchOS.

For most widgets, use either desaturated or accented desaturatedto help the Image content blend in with the rest of the home screen.Use fullColor for Images that represent media content,such as album artwork or a book cover.Next, I’m excited to show you how to take your widgets into a whole new dimension.With visionOS 26, your visionOS apps can now include widgets.And if you already have a compatible iPhone or iPad app with widgets,those automatically become available in visionOS.All of the system family sizes from iOS and macOS are supported.And widgets in visionOS have interaction and animation capability,just like other platforms.I’ll show you how widgets work on visionOS and new options that WidgetKit provides.

In visionOS, widgets can be added into the room and then pinned to a surface.By default, they’ll take on an elevated look,sitting directly on top of the surface.Widgets can also be recessed, making the widget appearlike it’s embedded directly into the surface.

If one of these styles isn’t a good fit for your widget,use the supportedMountingStyles modifier on your widget configurationto specify which options should be provided.This modifier is available for both visionOS and iOS widgets.

By default, all widgets will be rendered beneath a glass texture.For visionOS apps, an alternative paper texture can be specified,giving the widget a poster style look.Here on the left I have my frequent beverage widget configured with glass,and on the right I’m testing out the same widgetbut with the paper texture applied.

Use the widgetTexture modifier on your widget configurationto specify whether your widget should be rendered with a paper textureor behind a pane of glass.To complete the look of poster style widgets,a new systemExtraLargePortrait widget family is available in visionOS.This is a vertically oriented versionof the existing horizontal systemExtraLarge widget family.

Add this to your widget configuration using the supportedFamilies modifier.

In visionOS, the widget’s color theme can also be customized.By default, the widget will appear in a full color presentation.If I select this green theme, the widget’s content is displayedusing accented rendering mode.The widget frame and content get tinted with my selected color.Then the background is removed and replaced with a solid colorthat complements the selected color theme.

This style applies the same rendering approach discussed earlierfor iOS and macOS.Use the same techniques I coveredto make your widget look its best in these color themes.Use the widgetAccentedRenderingMode modifierto customize the presentation of your images.And use the widgetRenderingMode environment variableto conditionally apply more substantial modifications.

On visionOS, widgets can be brought into your environmentand placed on multiple surfaces.As you move about your space, widgets stay in their fixed position.Even if a widget is far away on a wall across the room, it remains visible.Just like real physical objects, widgets that are further awayare smaller and harder to see.Unlike physical objects, widgets in visionOS can adaptbased on their distance using a new level of detail API.I’ll show you how I can add levelOfDetail to my caffeine tracking widget.

Here I have my existing widget that shows my total caffeine for the day,the last beverage I drank,as well as a handy button to add another drink to the log.

When this widget is further away from me,I’d like to make the total caffeine value larger and easier to read.I’d also like to hide the button,since it will be harder to hit further away.Here’s my caffeine tracker widget.I want to update my TotalCaffeineView, changing its size,and conditionally show or hide my LogDrinkView at the bottom.

First, I’ll add this environment property, levelOfDetail, to my view.LevelOfDetail can be one of two values.Default is the normal level of detail expected of widgets.On visionOS, widgets are shown in the default level of detailwhen they are at a comfortable distance.If the widget is physically far enough away,the level of detail changes to simplified,providing an opportunity to display a simpler,more easily glanceable representation of the widget.I’ll add this conditional around my LogDrinkViewto only display if the levelOfDetail is default.Now I need to update the caffeine amount.

In my total caffeine view, I’m displaying the titleand the formatted total caffeine amount.First, I’ll add the levelOfDetail environment variable to my view.

In order to make this bigger,I’ll conditionally change the font of my caffeine amountfrom title to large title based on the level of detail.

Now, whenever the widget is far enough away,my widget transitions to show a simpler,more easily glanceable version of my widget.

And just like timeline changes within your widget,level of detail changes also animate.To learn more about when to customize your spatial style,recommendations for level of detail,and other considerations for bringing your widgets to this new platform,check out “Design Widgets for visionOS.”Shifting gears, now widgets and Live Activities,are hitting the open road with CarPlay.

In CarPlay Ultra,widgets appear in one or more stacks to the left of the dashboard.And starting with iOS 26,this feature now comes to all CarPlay cars.Widgets can be configured in the Settings app under CarPlay.In CarPlay, glanceable information, large typography, and legibilityare all important to help make your widget easy to read on the car’s display.

To support this, CarPlay renders widgets in a StandBy style,using the systemSmall family in fullColor with the widget background removed.Widget interactions are supported on touchscreens,and you can use the CarPlay simulatoravailable on the developer site to test your widget.

Get more tips on how to adapt your widget for a StandBy presentationin “Bring widgets to new places” from WWDC 23.

Live Activities can also be displayed on the home screen in CarPlay.By default, your Live Activity’s Dynamic Islandleading and trailing views will be shown.Here I have my Coffee Order Tracking Live Activitybeing displayed in CarPlay.This is a good start, but with just a little bit of extra code,I can make this even better.

Here’s the code for my Live Activity.Currently, my leading and trailing views are shown.

To customize this Live Activity presentation for CarPlay,I’ll add the supplementalActivityFamilies modifier,passing in small as an argument to my ActivityConfiguration.

Now, rather than using the leading and trailing views,CarPlay will display my ActivityView,the same view that’s used on the iPhone lock screen.For some Live Activities, this may look great,but mine is a little cramped with some of my content cut off.Luckily, I can customize this even further.

Here is my ActivityView.I’ll add the activityFamily environment variable to my view.

With that added, in my views body, I can conditionally display different contentor adjust the layout to provide a great experience.

When the activityFamily is small,I’ll provide a shop order view that is optimized for a smaller layout.Otherwise, I’ll display my default order view.

With that little bit of extra code,my Live Activity now looks great in CarPlay.Now I can quickly glance and see how much longer until my order is ready.

By adopting supplementalActivityFamily,I’ve also greatly improved how my Live Activity lookswhen presented on a paired Apple Watch.Your iPhone app gets this automatically,without the need for a separate watchOS app.

To learn more about how to make your Live Activity look its bestin the Smart Stack on watchOS,check out “Design Live Activities for Apple Watch.”And check out “Turbocharge your app for CarPlay”to learn more about how to really accelerate your widgets in CarPlay.

CarPlay isn’t the only new place for Live Activities.

Live Activities from a paired iPhone will now appear in macOS Tahoe.Just like in the Dynamic Island on iPhone, my coffee order tracker Live Activitypresents the leading and trailing views together in the menu bar.

When the Live Activity is selected,the lock screen presentation from iPhone will appear.Clicking on the lock screen presentation will launch the associated appusing iPhone Mirroring.

Live Activities on macOS can be provided by iPhones running iOS 18 and later.There are no code changes required, and just like iPhone widgets on macOS,they support interaction and deep links.

Now I’ll cover new places for controls on macOS and watchOS.On macOS, controls can be provided by apps running on the Mac,whether they’re built with the macOS SDK, Catalyst,or from iOS apps running on Apple Silicon Macs.

Controls can be added in the Control Center.The same small, medium, and large presentations available on iOScan also be configured on macOS.

Controls can also be placed directly on the menu bar.Now that I’ve added a coffee tracker control to my app on macOS,I can easily update my coffee log right from the menu bar.In watchOS 26, controls can appear in three places.

They can be configured in the Control Center,accessible from the side button.Controls can also be executed when pressing the Action buttonon Apple Watch Ultra.

And they can be configured in the Smart Stack,where they appear alongside other widgetsdisplaying the control’s symbol, title, and current value.Controls can be provided from a watchOS appor from an iPhone app on a paired device.For an extensive guide to building controls,check out“Extend your app’s controls across the system” from WWDC24.Next, I’ll show you relevance widgets in the Smart Stack in watchOS 26.

I’ve added a widget to my caffeine tracking app on watchOSthat helps me keep track of when my favorite coffee shopshave half price happy hours.There’s two things I’d like to improve with my widget.

First, since I’m tracking the happy hours for several coffee shops,often their happy hours overlap,meaning the content on my widget in the Smart Stack is pretty cramped.

Second, the happy hours tend to happen around the same time.So for the rest of the day, my widget isn’t very useful.

I’d really like my happy hours widgetto only show up in the Smart Stack if it was relevantand show more detailed information for each active happy hour.

With relevance widgets in watchOS 26, I can do just that.I’ll show how I can configure my happy hours as a relevance widget.

To define a relevance widget, create a Widget typeand instead of a StaticConfiguration or AppIntentConfiguration,provide a RelevanceConfiguration.Just like other configurations, it takes a kind String, a provider object,and a closure to transform your custom entry into a SwiftUI view.

The provider type is a RelevanceEntriesProvider.The placeholder and relevance methods are similar to TimelineEntriesProvider.For placeholder, I can return a simple Entry to be displayedwhile my content is getting prepared.For relevance,  I first fetch a collection of configuration objectsthat I’ve defined.

For my happy hours widget, a configuration is relevantbetween the start and end time of that happy hour.I’ll define the relevance attribute with this contextusing the date interval for each happy hour.Then I implement the entry method.Unlike a Timeline widget, a RelevanceEntriesProvideronly provides a single entry for a configuration.I have all the data I need for this entry in my configuration,the shop data and the time range for the happy hour,so I can create that immediately.If I needed any other data or assets,I could fetch them here since this method is marked async.

Now with my relevance widget set up,my happy hours widget only displays in the Smart Stack when it’s relevant.

Plus, if I have multiple configurations that are relevant at the same time,I can see multiple instances of my widget in the Smart Stack.Relevance widgets are a powerful new feature in watchOS 26,giving you the ability to directly connect widget content with its relevance.These widgets are a great addition on their ownor alongside existing timeline based widgets.

To learn more about Relevance widgets,check out “What’s new in watchOS 26” with Anne.Now that there’s so many more places and platforms that widgets can appear,I’d like to keep my widgets always up to date wherever they are.I’ve recently added a serverso I can keep my caffeine log data in sync across my devices.I’ll cover what options are available for refreshing my widget,starting with scheduled widget reloads.

In this diagram, on the left I have my app bundle,which contains my app as well as my widget extension.On the right side, I have a box representing WidgetKit.When a widget is configured on a device,such as on the iPhone home screen, or on a watch face,WidgetKit requests a timeline from the widget extension.The extension responds with a widget timeline,which includes a TimelineReloadPolicy.WidgetKit uses this to determine the next appropriate time to reload that widget.

Using the TimelineReloadPolicy is a great optionfor widgets that need to update at regular intervals,such as a widget that displays the hours of a cafe,a weather widget, or a stock widget.The scheduled timeline reload is budgeted by the systemto help maintain performance and battery life.

The WidgetCenter API is another option available to apps.Inside an app, if a data change occurs that should be reflected in its widget,WidgetCenter’s reloadAllTimelinesor reloadTimelines(ofKind:) method can be called.This tells WidgetKit that the widget’s content is outdatedand needs to be reloaded.WidgetKit then requests a timelinefrom the widget extension to update the widget.

This is a great option if widget content primarily changes inside the app,such as updating a caffeine log, changing a note,or checking off a reminder.Since the app is running when this API is called,the system does not budget this request.

But what happens if a data change occurs on the server or on another device?This is where widget push updates come in.A server tracking data changes can send a push notification to APNs,which will tell WidgetKit to reload that app’s widgets.And like other updates,WidgetKit will then request an updated timeline from the widget.

Widget push updates are a great toolif data can change external to that device.Just like the TimelineReloadPolicy,widget push notification updates are also budgetedto maintain performance and battery life.

With this capability, widgets now have a full suite of reload optionsto handle a variety of situations.These are not mutually exclusive.Some widgets may want to use two or even all three of these options.With widget push updates,my widget’s caffeine log can stay up to date across deviceswhether I log an update on my iPad app, my Vision Pro widget,or my macOS menu bar control.

I’ll show you how I can add this to my widget.I’ll create a WidgetPushHandler and add it to my widget configuration,add the Push Notification entitlement to my widget extension,and construct a widget update push request.

First, I’ll create a struct conforming to the WidgetPushHandler protocol.This type is how we notify you when your push token changesor when the set of configured widgets changes.Use the pushTokenDidChange methodas an opportunity to send your push token and widget info to your server.

Next, I need to update my widget configuration.Here I have the configuration for my caffeine tracker widget.

I’ll add the pushHandler modifier to my widgetto register its support for push notifications.

For this modifier, I pass in the type of the widget pushHandler I implemented.

Finally, in Xcode,I’ll go to the Signing and Capabilities tab for my widget extension.

Here, I’ll add the push notification entitlementso it can communicate with APNs.Now that my widget is configured for push updates,I’ll show you how to send a widget update push notification.To update your widget via push notification,send an HTTPS POST request to the Apple Push server.

Use the widget push token provided in your WidgetPushHandleras the last part of the request path.For your headers, use the widgets APNs push type,and set the APNS topic header using the app’s bundle ID,suffixed with .push-type.widgets.

In the body of your request in the aps dictionary,set the value of the content changed key to true.To learn more about push notifications, watch the “Push Notifications Primer”.And check out “Meet Push Notifications Console”to see how you can easily test push notification requests.Push updates for widgets help keep widget content more up to date,but are performed opportunisticallyand aren’t a direct replacement for other notification experiences.

If you have an urgent or important update to show,provide a User Notification.

If you have updates occurring regularly during a limited period of time,such as a beverage order, updating sports scores, or flight updates,use a Live Activity.

Use widget push updates to keep widget content up to date.Widget push updates are available across all platforms that support widgets.When you send a widget push notification,this will update all of the push enabled widgets configured on the device.Remember that these widget reloads are budgeted.Try to keep your update pushes limited,such as by throttling updates on your server.And during development and test,you can use the WidgetKit developer mode in Settingsto ignore push and reload budgets for your app.

I've covered a lot today.Take some time to explore these new platforms for widgets.Check out some of the videos listed earlier to help get inspired.Make sure your widgets look great in new appearances on iOS and macOS.And finally,if your widgets data may be updated from external sources or other devices,consider adding push notifications to keep them up to date.I’m so excited about all the new capabilities and places for widgets.I can’t wait to take your widgets with me wherever I go.Thanks for watching.

2:44 -Observe .widgetRenderingMode

6:08 -visionOS Widget Configuration

8:56 -LevelOfDetail - CaffeineTrackerWidgetView

9:46 -LevelOfDetail - TotalCaffeineView

11:49 -Add .supplementalActivityFamilies

12:27 -Add .activityFamily

16:20 -Define relevance widget with RelevanceConfiguration

16:41 -Implement RelevanceEntriesProvider

21:13 -Handle push token and widget configuration changes

21:30 -Add pushHandler to WidgetConfiguration

22:29 -Push Notification Request Body

0:00 -IntroductionLearn about updates to WidgetKit including new ways to incorporate your app with the system, show relevant content in the Smart Stack, and keep your app up to date.1:03 -Widgets in new placesWidgets have new styling options and are available in new places. Check out tips to make your widgets look great with accented rendering mode. Widgets are available in more places, including visionOS 26 and CarPlay. Widgets on visionOS 26 can be added to rooms and pinned to surfaces. These widgets can be customized to support different mounting styles, textures, and level of detail based on proximity. CarPlay and macOS 26 now support Live Activities. Controls are available on macOS Tahoe and watchOS 26.15:31 -Relevance widgetsRelevant widgets show up in the Smart Stack on watchOS 26 when they’re most relevant based on people’s routines, location, and more. These widgets show up in the Smart Stack only when they’re relevant, and multiple instances can show up at the same time, like for overlapping calendar events or happy hours. Build relevant widgets by specifying when the widget is most relevant, like at a particular time or type of location.18:12 -Push widget updatesWidgets across all WidgetKit platforms can now be updated by push updates through APNS. There are multiple tools to keep widgets up to date, and the best tool for each use case is determined by how the data for your widget is updated. Timelines are good for regularly updating data. Changes driven by interaction in an app should reloadAllTimelines. For synchronization between devices, or external data changes, like from a server, use widget push updates. Push updates for widgets help keep widgets more up to date, but aren’t a direct replacement for other notification experiences. Consider whether a User Notification, Live Activity, or widget is best for each use case.

0:00 -Introduction

Learn about updates to WidgetKit including new ways to incorporate your app with the system, show relevant content in the Smart Stack, and keep your app up to date.

Learn about updates to WidgetKit including new ways to incorporate your app with the system, show relevant content in the Smart Stack, and keep your app up to date.

1:03 -Widgets in new places

Widgets have new styling options and are available in new places. Check out tips to make your widgets look great with accented rendering mode. Widgets are available in more places, including visionOS 26 and CarPlay. Widgets on visionOS 26 can be added to rooms and pinned to surfaces. These widgets can be customized to support different mounting styles, textures, and level of detail based on proximity. CarPlay and macOS 26 now support Live Activities. Controls are available on macOS Tahoe and watchOS 26.

Widgets have new styling options and are available in new places. Check out tips to make your widgets look great with accented rendering mode. Widgets are available in more places, including visionOS 26 and CarPlay. Widgets on visionOS 26 can be added to rooms and pinned to surfaces. These widgets can be customized to support different mounting styles, textures, and level of detail based on proximity. CarPlay and macOS 26 now support Live Activities. Controls are available on macOS Tahoe and watchOS 26.

15:31 -Relevance widgets

Relevant widgets show up in the Smart Stack on watchOS 26 when they’re most relevant based on people’s routines, location, and more. These widgets show up in the Smart Stack only when they’re relevant, and multiple instances can show up at the same time, like for overlapping calendar events or happy hours. Build relevant widgets by specifying when the widget is most relevant, like at a particular time or type of location.

Relevant widgets show up in the Smart Stack on watchOS 26 when they’re most relevant based on people’s routines, location, and more. These widgets show up in the Smart Stack only when they’re relevant, and multiple instances can show up at the same time, like for overlapping calendar events or happy hours. Build relevant widgets by specifying when the widget is most relevant, like at a particular time or type of location.

18:12 -Push widget updates

Widgets across all WidgetKit platforms can now be updated by push updates through APNS. There are multiple tools to keep widgets up to date, and the best tool for each use case is determined by how the data for your widget is updated. Timelines are good for regularly updating data. Changes driven by interaction in an app should reloadAllTimelines. For synchronization between devices, or external data changes, like from a server, use widget push updates. Push updates for widgets help keep widgets more up to date, but aren’t a direct replacement for other notification experiences. Consider whether a User Notification, Live Activity, or widget is best for each use case.

Widgets across all WidgetKit platforms can now be updated by push updates through APNS. There are multiple tools to keep widgets up to date, and the best tool for each use case is determined by how the data for your widget is updated. Timelines are good for regularly updating data. Changes driven by interaction in an app should reloadAllTimelines. For synchronization between devices, or external data changes, like from a server, use widget push updates. Push updates for widgets help keep widgets more up to date, but aren’t a direct replacement for other notification experiences. Consider whether a User Notification, Live Activity, or widget is best for each use case.

## Code Samples

```swift
struct
 
MostFrequentBeverageWidgetView
: 
View
 {
    
@Environment
(\.widgetRenderingMode) 
var
 renderingMode
    
    
var
 entry: 
Entry

    
    
var
 body: 
some
 
View
 {
        
ZStack
 {
            
if
 renderingMode 
==
 .fullColor {
                
Image
(entry.beverageImage)
                    .resizable()
                    .aspectRatio(contentMode: .fill)
            
                
LinearGradient
(gradient: 
Gradient
(colors: [.clear, .clear, .black.opacity(
0.8
)]), startPoint: .top, endPoint: .bottom)
            }
            
            
VStack
 {
                
if
 renderingMode 
==
 .accented {
                    
Image
(entry.beverageImage)
                        .resizable()
                        .widgetAccentedRenderingMode(.desaturated)
                        .aspectRatio(contentMode: .fill)
                }
                
                
BeverageTextView
()
            }
        }
    }
}
```

```swift
struct
 
CaffeineTrackerWidget
: 
Widget
 {
    
var
 body: 
some
 
WidgetConfiguration
 {
        
StaticConfiguration
(
            kind: 
"BaristaWidget"
,
            provider: 
Provider
()
        ) { entry 
in

            
CaffeineTrackerWidgetView
(entry: entry)
        }
        .configurationDisplayName(
"Caffeine Tracker"
)
        .description(
"A widget tracking your caffeine intake during the day."
)
        .supportedMountingStyles([.elevated])
        .widgetTexture(.paper)
        .supportedFamilies([.systemExtraLargePortrait])
    }
}
```

```swift
struct
 
CaffeineTrackerWidgetView
 : 
View
 {
    
@Environment
(\.levelOfDetail) 
var
 levelOfDetail
    
    
var
 entry: 
CaffeineLogEntry


    
var
 body: 
some
 
View
 {
        
VStack
(alignment: .leading) {
            
TotalCaffeineView
(entry: entry)

            
if
 
let
 log 
=
 entry.log {
                
LastDrinkView
(log: log)
            }

            
if
 levelOfDetail 
==
 .default {
                
LogDrinkView
()
            }
        }
    }
}
```

```swift
struct
 
TotalCaffeineView
: 
View
 {
    
@Environment
(\.levelOfDetail) 
var
 levelOfDetail
    
    
let
 entry: 
CaffeineLogEntry


    
var
 body: 
some
 
View
 {
        
VStack
 {
            
Text
(
"Total Caffeine"
)
                .font(.caption)

            
Text
(totalCaffeine.formatted())
                .font(caffeineFont)
        }
    }
    
    
var
 caffeineFont: 
Font
 {
        
if
 levelOfDetail 
==
 .simplified {
            .largeTitle
        } 
else
 {
            .title
        }
    }
    
    
var
 totalCaffeine: 
Measurement
<
UnitMass
> {
        entry.totalCaffeine
    }
}
```

```swift
struct
 
ShopOrderLiveActivity
: 
Widget
 {
    
var
 body: 
some
 
WidgetConfiguration
 {
        
ActivityConfiguration
(for: 
Attributes
.
self
) { context 
in

            
ActivityView
(context: context)
        } dynamicIsland: { context 
in

            
DynamicIsland
 {
                
DynamicIslandExpandedRegion
(.leading) {
                    
ExpandedView
(context: context)
                }
            } compactLeading: {
                
LeadingView
(context: context)
            } compactTrailing: {
                
TrailingView
(context: context)
            } minimal: {
                
MinimalView
(context: context)
            }
        }
        .supplementalActivityFamilies([.small])
    }
}
```

```swift
struct
 
ActivityView
: 
View
 {
    
@Environment
(\.activityFamily) 
var
 activityFamily
    
var
 context: 
ActivityViewContext
<
Attributes
>
    
    
var
 body: 
some
 
View
 {
        
switch
 activityFamily {
        
case
 .small:
            
ShopOrderSmallView
(context: context)
        
default
:
            
ShopOrderView
(context: context)
        }
    }
}
```

```swift
struct
 
HappyHourRelevanceWidget
: 
Widget
 {
    
var
 body: 
some
 
WidgetConfiguration
 {
        
RelevanceConfiguration
(
            kind: 
"HappyHour"
,
            provider: 
Provider
()
        ) { entry 
in

            
WidgetView
(entry: entry)
        }
    }
}
```

```swift
struct
 
Provider
: 
RelevanceEntriesProvider
 {
    
func
 
placeholder
(
context
: 
Context
) -> 
Entry
 {
        
Entry
()
    }
    
    
func
 
relevance
() 
async
 -> 
WidgetRelevance
<
Configuration
> {
        
let
 configs 
=
 
await
 fetchConfigs()
        
var
 attributes: [
WidgetRelevanceAttribute
<
Configuration
>] 
=
 []
        
        
for
 config 
in
 configs {
            attributes.append(
WidgetRelevanceAttribute
(
                configuration: config,
                context: .date(interval: config.interval, kind: .default)))
        }
        
        
return
 
WidgetRelevance
(attributes)
    }
    
    
func
 
entry
(
configuration
: 
Configuration
,
               
context
: 
RelevanceEntriesProviderContext
) 
async
 
throws
 -> 
Entry
 {
        
Entry
(shop: configuration.shop, timeRange: configuration.timeRange)
    }
}
```

```swift
struct
 
CaffeineTrackerPushHandler
: 
WidgetPushHandler
 {
    
func
 
pushTokenDidChange
(
_
 
pushInfo
: 
WidgetPushInfo
, 
widgets
: [
WidgetInfo
]) {
        
// Send push token and subscription info to server

    }
}
```

```swift
struct
 
CaffeineTrackerWidget
: 
Widget
 {
    
var
 body: 
some
 
WidgetConfiguration
 {
        
StaticConfiguration
(
            kind: 
Constants
.widgetKind,
            provider: 
Provider
()
        ) { entry 
in

            
CaffeineTrackerWidgetView
(entry: entry)
        }
        .configurationDisplayName(
"Caffeine Tracker"
)
        .pushHandler(
CaffeineTrackerPushHandler
.
self
)
    }
}
```

```swift
{

    
"aps"
:
 
{

        
"content-changed"
:
 
true

    
}


}
```


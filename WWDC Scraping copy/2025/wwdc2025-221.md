# Wwdc2025 221

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Summary

Transcript

Code

What’s new in AdAttributionKitLearn about new features in AdAttributionKit, including how to measure overlapping reengagement conversions and customize ad attribution rules for your app. Gain insight on a new postback property you can use to measure the success of ad campaigns across countries and regions. We'll also demonstrate new functionality and best practices for testing your AdAttributionKit implementation. To get the most out of this session, we recommend first watching “Meet AdAttributionKit.”Chapters0:00 -Introduction3:23 -Measure overlapping conversion windows7:50 -Customize attribution rules14:46 -Receive geography data in postbacks18:12 -Test AdAttributionKitResourcesAdAttributionKitConfiguring attribution rules for your appCreating postbacks in developer settingsEnabling Developer Mode on a deviceIdentifying conversion values with conversion tagsSupplying an install verification tokenVerifying a postbackHD VideoSD VideoRelated VideosWWDC25Integrate privacy into your development processWWDC24Meet AdAttributionKit

Learn about new features in AdAttributionKit, including how to measure overlapping reengagement conversions and customize ad attribution rules for your app. Gain insight on a new postback property you can use to measure the success of ad campaigns across countries and regions. We'll also demonstrate new functionality and best practices for testing your AdAttributionKit implementation. To get the most out of this session, we recommend first watching “Meet AdAttributionKit.”

0:00 -Introduction

3:23 -Measure overlapping conversion windows

7:50 -Customize attribution rules

14:46 -Receive geography data in postbacks

18:12 -Test AdAttributionKit

AdAttributionKit

Configuring attribution rules for your app

Creating postbacks in developer settings

Enabling Developer Mode on a device

Identifying conversion values with conversion tags

Supplying an install verification token

Verifying a postback

HD VideoSD Video

HD Video

SD Video

Integrate privacy into your development process

Meet AdAttributionKit

Search this video…Hey everyone, I’m Mike,an engineer on the App Store Engineering team.And today I’ll share some new AdAttributionKit featureswe’ve built for developers of advertised apps.Hi, I’m Yuchi,I’m an engineer on the Commerce Engineering team,and today I'll share new featuresfor configuring attribution and receiving new dataif you’re a consumer of postbacks.Here at Apple, we believe privacy is a fundamental human right.That’s why we built AdAttributionKit from the ground upto help advertisers measure the success of their ad campaignswhile preserving the privacy of users.I’ll start with a summary of how AdAttributionKit works.An AdAttributionKit flow consists of three different parties.An ad network is responsible for creating and deliveringan ad payload to a publisher app.The publisher app will handle displaying an advertisementfor the advertised app.And finally, the advertised app measures engagementfrom actions that people take from within their app.These actors each play a role at different pointsin an end-to-end flow of AdAttributionKit.An end-to-end flow begins with an ad networkcreating an ad payload for an app.The ad network then delivers an ad payload to the publisher app,and the publisher app will display an advertisement to someone.Someone can interact with an ad by either viewing itor tapping on it, which leads to either an install or re-engagement conversion.An install conversion occurs when someone installs your appfrom the App Store or an alternativeapp marketplace as a result of interacting with an ad.Re-engagement conversions occur when someoneengages with an ad for an app they alreadyhave installed, taking them into the advertised app directly.Once a conversion has occurred, the advertisermeasures interactions and engagement that people perform inside of their app.After the conversion window has ended, the data representingthe conversion and engagement measurements are transmitted in the form ofa postback back to the ad network.And that completes an end-to-end flow of AdAttributionKit.As a quick recap if you’re not familiar, AdAttributionKit launched with iOS 17.4and included support for install conversions.We added re-engagement support with iOS 18.For a refresher on getting started with AdAttributionKit,check out our WWDC24 session, “Meet AdAttributionKit.”With that review in mind, we’re excited to show younew features we've built that enhance different parts of the end-to-end flow.If you’re a developer of an advertised app,I’ll show you some powerful new features aroundmeasurement and testing flows you can use in your app.If you’re an ad network or a downstream consumer of postback data,Yuchi will share enhancementswe’ve built for your attribution flows and new data in postbacks.We've divided this talk into four parts.First, I’ll cover conversion tags, which enables you to measureoverlapping re-engagement conversions inside of your app.Yuchi will then give a breakdown of how you can customize attribution rulesfor your app and discuss new geography data we’ve added to postbacks.And finally, I’ll wrap up with how to test your AdAttributionKitimplementation with new testability in the iOS Settings app.Let’s dive into how you can measure overlapping conversion windows.Let’s focus on the re-engagement flow inside of our end-to-end diagram.Up until iOS 18.3, your app can only have one activere-engagement conversion at any point in time.As of iOS 18.4, your app can now have multiple activere-engagement conversion windows at the same time.Your app can also receive conversion tags,which is like a bookmark for a conversion.You can use conversion tags to specify, which re-engagement conversion to update.Let’s review a scenario where you would use conversion tags in your app.As a developer, you may run multiple re-engagement campaignsto promote different sales you’re offering to customers in your app.A customer could see an ad promoting a discountedproduct in your app and decide to tap on it.That Interaction will deep link them into your appand create a re-engagement conversion in the system.Then, after a few minutes, they leave your app without purchasing the item.Continuing the scenario, a few hours laterthe same customer sees another ad promoting a second discounted itemin your app and decides to tap the ad.This creates another re-engagement conversion in the system.After some time in the app, they decide to go backand purchase the first discounted item.Using conversion tags, you can update the conversion valuefor the original conversion corresponding to Discount 1.This will be really useful if you run re-engagement campaigns formultiple products in your app at the same time.To begin measuring overlapping conversion windows,set the EligibleForAdAttributionKitOverlappingConversionskey to YES in the Info.plist for your app.Without this, prior conversions will continue to lock whenthey overlap, as they did before.Next, I’ll show you how your app can get conversion tags.Once your app has opted in, conversion tagswill be appended to the re-engagement URL that AdAttributionKit delivers to your appwhen a re-engagement occurs.Re-engagement URLs are Universal Links that are passed into APIswhen either a custom rendered or StoreKit rendered ad is on the screen.The tag is delivered as the value of AdAttributionKit’sre-engagement open parameter.In this example URL, the tag is equal to 1.When your app receives a re-engagement URL,you can extract the conversion tag using a function like this.I'll break down what's happening here.First, the function gets the components of the URLthat were passed in using URLComponents.Next, it gets the list of query items.AdAttributionKit always appends a re-engagement open parameterif the app was open because of a re-engagement.Next, it looks through the list of query parametersthat are attached on the URL.If it finds the reengagement open parameter on the URL,it’ll return the value of that parameter immediately.If it’s not able to find the query parameter,the function will return nil.Now that you have a conversion tag in your app,you can use it to update that conversion directly.We recommend associating conversion tagswith the reengagement conversion that created it,so you can tie back meaningful events that occuras a result of that conversion.You should also store the conversion tag either locallyin your app or in a server-side data store.Once a customer performs an action in your appthat you’d like to measure for that specific conversion,retrieve the tag for that conversion.Now, let me show you how to use a conversion tagto make a directed update to a conversion in code.This function takes a conversion value in conversion tagto update a specific postback.When initializing a PostbackUpdate struct,pass in the conversion tag for the conversion you’d like to update.Then you can call the Postback API to update the conversion value.You can also call the updateConversionValue APIwithout a conversion tag,and the system will update the most recent conversions postbacks.And that’s how you can use conversion tags to update postbackswhen you have overlapping conversion windows.Measuring conversion values for postbacks is only one piece of the puzzlewhen using AdAttributionKit.Interpreting postback data you receive downstreamis another important aspect of the system,and can help inform marketing decisions you might makefor your app's business.Yuchi, do you have updates to share in this space?I sure do.Here are some new features that will help you better consumeand interpret the postback data you receive.To capture the most meaningful signals in your postback data,we added the ability to customize the attribution rulesfor your app, which enables you to adjust your attribution flow.There are two ways in which you could adjust your attribution flow.The first one is configurable attribution window.Revisiting the end-to-end ad attribution flow,AdAttributionKit performs attribution based on ad recency and ad type.The two ad types supported by AdAttributionKitare click-through ad and view-through ad.Different ad types typically target a different time horizon.For example, a click-through ad might target driving conversions within 10 days.And when a conversion happens later than the targeted time frame,let’s say at 20 days after the impression display time,this conversion should no longer be considered driven by this ad.And this ad targeting time frame is what we refer to as the attribution window.The attribution window is defined as the time periodstarting from the ad display timefor the latest time that this ad can still be considered for attribution.If conversion happens within the attribution window of an ad,then this ad would compete for the attribution of this conversion.Otherwise, this ad would not compete for the attribution of this conversion.Previously, all click-through ads that are less than 30 days old,and view-through ads that are less than 1 day oldwould be considered for attribution.We wanted to make this period flexible for you,and therefore, we’re introducing configurable attribution window.As an advertiser, you can specify your desiredattribution window length in the Info.plist file.This example uses a JSON file to illustrate the configurations,but the same keys and structure can be usedwhen editing your app’s Info.plist file.Attribution window can be defined on a per-ad network basisand a per-ad interaction type basisthat are view-through ads and click-through ads.Here's an example.For the ad network com.example.adNetwork,the advertiser specified an attribution windowof two days for click-through ads and one day for view-through ads.If an ad network partner focuses primarily on one type of ad,you might want to completely ignore other ad types from that ad network.You can do this by specifying the ignoreInteractionType key.This key can be set together “view” or “click”,but not both simultaneously.If you work with multiple ad networks,specifying attribution window length for them one by one can be a lot of work.In this case, you can specifya window length for all ad networks you work withby adding the global key, which is applied to all ad networks by default.On top of the global window length, you can alsoconfigure the attribution window length for specific ad networks,which will take precedence over the global configuration.If no ad network or global configuration is found, we will fallback to the defaultattribution window length we use today.In the example, the attribution window for click-through adsfrom ad com.example.adNetwork will be five days,and view-through ads from that ad network will be ignored.For all other ad networks,the attribution window for view-through ads will be three days.Note that the concept of attribution window only applies to install ads,not re-engagement ads.This is because re-engagement ad interactionsand conversions happen right after each other with no time gap in between.The second way in which you can adjust your attribution flowis the configurable cooldown.Revisiting the end-to-end ad attribution flow.Let’s focus on the user engagement measurement followingan ad-driven conversion.After an ad network serves an ad, and the ad-driven conversion happens,the window for advertisers to measure user engagement opens.We refer to this window as the conversion window.Advertisers can measure the value of the conversionbased on activities people take in their app,such as subscription and In-App Purchase,by invoking the updateConversionValue API.In reality, many of these ad attributions might behappening simultaneously for the same advertised appon the same device.And the conversion windows may overlap, in which case,a measurement might not get accorded to the most appropriate conversion.Let’s walk through a more concrete example.If someone clicked on an ad and downloaded the advertised app,and a bit later performed an In-App Purchase,which resulted in a high user value measurement towards the install ad.But imagine immediately after installing the app,the same person tapped on a re-engagement ad and opened the app.Then the In-App Purchase that should have been attributedto the install ad would be attributed to the re-engagement ad.This might not be the desired measurement objective for you.The same scenario may occur for a re-engagement adthat closely follows another re-engagement conversion.What would have been attributed to the first re-engagement ad,will not get attributed to the second re-engagement ad.To prevent this, you might want to set a periodafter each conversion to block other signaland use that period only to measure value of adsthat drove the dedicated conversion.This is what we call the configurable attribution cooldown.The configurable attribution cooldowncan be specified on a per conversion type basis.The cooldown will start from every conversionof that specific type, and all other conversions that happenedbefore the cooldown fully elapsedwill not be attributed towards any conversion.As an advertiser, you can specify your desired attribution cooldownin the Info.plist file.In this example, an advertiser specified a cooldown of six hours for installand one hour for re-engagement.With this configuration,let’s say someone clicked on the installation adand then installed an app at time T.And the configured cooldown for install is six hours.If the same person tap on the re-engagement adand opened the app four hours after the install,then this re-engagement conversion will not be attributed to the ad.If let’s say the re-engagement ad tab and app openhappened seven hours after the install,then the re-engagement will receive an ad attribution.For both configurable attribution window and attribution cooldown,the JWS format will remain unchanged for the impressions and the postbacks.Aside from these configurable features,we’ve also added new geography information to postbacksthat will help you measure the success of your ad campaigns in different countries.Back to the end-to-end ad attribution flow.Now let's focus on postbacks.Postbacks are the outputs of AdAttributionKitwhich transmit information about the conversion,such as attribution, and user engagement measurement.Postbacks are delivered to the ad networksand optionally to the developers of advertised apps.We understand that advertisers and ad networkswould like to access the geo info for conversionsin order to optimize ad delivery.Today, some implementations rely on the source identifier for this information.With the latest AdAttributionKit,the country code is provided as a new field in the postback.Here’s what country code represents in different context.For apps installed from the App Store, country code in the postback is derivedfrom the App Store storefront that the app was downloaded frombased on the location selected in user’s Account Settings.For re-engagement conversion,postbacks use the same location from when the app was initially installed.With iOS 17.4, alternative app marketplacescan supply an install verification tokento communicate an app installation signal with an Apple device.The install verification token is a JWS tokenwith payload including information about the app install,such as the timestamp of the download, and the downloaded app ID.Starting with the new iOS version,alternative app marketplaces provide a new field for country codein the install verification token payload.Sign it, and send to Apple.Then Apple will validate the valueand populate the postback country code field with the code.The country code is an optional field in the install verification token.If the system cannot find a country code in the install verification token,then there will be no country code in the postback.Note that the country code value for conversionvia alternative app marketplaces is limitedto the locations where alternative marketplaces are supported.This is how country code will be added to the postback.Country code will be an unsigned field parallelto the ad-interaction-type, signed JWS token,and coarse-conversion-value.The country code field is subject to the crowd anonymity algorithmthat AdAttributionKit enforces to all postbacks.Crowd anonymity algorithm sits at the centerof our privacy preserving ad attribution,where we ensure each individual’s uniquenessblend into a big crowd before releasing identifiable informationto the advertiser and ad network.The postbacks will only contain country codeif there has been enough volume for similar conversionswithin the same country.The crowd anonymity tier that qualifies for country code presencein the postbackwill be a bonus tier on top of the four crowd anonymity tierswe enforce today.This means that under no circumstance advertisersand ad networks will lose the data they’re currently receiving.That concludes our latest updates to postback data.Mike will now share our new AdAttributionKit testability.Thanks Yuchi for all that great information.Now that we covered all the new features of AdAttributionKit,I’ll show the new ways to test your implementation.Let’s return to our end-to-end diagram and focus on the ad deliveryand conversion flow.This is a typical flow you might use whentesting your app’s AdAttributionKit implementation.First, you need to create and serve an ad payload for your advertised app.Then you display and interact with an ad in a separate publisher app,and then perform an install or re-engagement conversionto create development postbacks for your app.With iOS 18.4, you can now create development postbacksfor your app directly in the iOS Settings app.Postbacks created from developer settings allow you to test in new ways.You can now test updating conversion values if your app was run from Xcodeor other distribution mechanisms, such as ad-hoc distribution.You also now have direct control over the data your postbacks will contain.This can be useful for testing your server implementationfor processing various data tiers of postbacks.Now I’ll show how you can use developer settingsto create postbacks for your app.Before you start, you'll need to make sure Developer Mode is enabled on your device.Next, go into the developer settings inside of the Settings app.Inside of developer settings, scroll down to the Ad Attribution Testing section.We added a new page named Development Postbacksabove AdAttributionKit Developer Mode.Tapping into the Development Postbacks page,you’re presented with options to configure postbacks for your app,transmit any eligible postbacks, or clear all development postbacs from your device.To configure development postbacks,type in your app’s bundle identifier and tap the Configure button.The app must be installed on your device before you can create postbacks for it.The first step is to specify a destination for your postback.This should be the URL of your server.It is best practice to use a development URL when testing,different than the URL where you receive production postbacks.You can also fetch the postback copy URL from your app automatically.You can use this to confirm the well-known URL that the system generatesmatches the URL your server exposes.Next, fill in the properties of your postback.You can configure the postback to representany type of conversion you would like by editing the properties.Now in iOS, you’ll be able to configure country code as a new property.This will help you test country code in postbacks, which Yuchi discussed earlier.After configuring the properties, you can adjust the data granularity ofeach individual postback.This granularity controls how much information will be sent to your server.You can use this to validate your server implementationprocesses different postback data tiers correctly.When you’re done configuring your postbacks,tap the button to create them for your app.Now that your app has development postbacks,you can start updating their conversion values.During testing, call the updateConversionValue(_:) APIto update the development postbacks.You can wait for the development postback to send automatically,or you can tap the Transmit Development Postbacks buttonwhen your postback conversion window ends.Postbacks created in developer settings have some key differencesthan ones created in end-to-end flows.I’ll show the changes you’ll see in your postback’s JSON Web Signature.This is a snippet of the header you would receive in your postback.Postbacks created from developer settings are signed using a new key,indicated with a new kid value.Check out our documentation on verifying postbacks to obtain the new public keyto validate the signature of these postbacks.Switching focus, the payload of the postbackalso has some differences that are worth mentioning.The ad network identifier will always be set to development.adattributionkit.This helps further distinguish postbackscreated in developer settings from production postbacks.The advertised item identifier of the postback may also be zero.For example, if you ran your app from Xcode while testing.And that wraps up the new testability featureswe’ve added to AdAttributionKit.We think this new testability will help streamlineyour workflow when developing and testing your AdAttributionKit implementation.We covered a lot of ground today for our new AdAttributionKit features.From measuring overlapping conversion windows in your appto receiving country code and postbacks,these updates impact various pieces of ad attribution.Some next steps: if you’re ready to configure attribution rules for your app,be sure to start adding the new configurationkeys to your app’s Info.plist.Start using the new testability to test out your AdAttributionKit implementationearlier in your development lifecycle, before releasing to production.And if you’re using SKAdNetwork,now is a great time to migrate over to AdAttributionKitand start building with all of the new features.We want to thank our community of developers that give us feedbackon their experiences using our privacy-first ad frameworks.Your feedback helps drive what we build and how we can deliverexcellent ad experiences for your app that maintain user privacy.Thank you!

Hey everyone, I’m Mike,an engineer on the App Store Engineering team.And today I’ll share some new AdAttributionKit featureswe’ve built for developers of advertised apps.Hi, I’m Yuchi,I’m an engineer on the Commerce Engineering team,and today I'll share new featuresfor configuring attribution and receiving new dataif you’re a consumer of postbacks.

Here at Apple, we believe privacy is a fundamental human right.That’s why we built AdAttributionKit from the ground upto help advertisers measure the success of their ad campaignswhile preserving the privacy of users.I’ll start with a summary of how AdAttributionKit works.

An AdAttributionKit flow consists of three different parties.An ad network is responsible for creating and deliveringan ad payload to a publisher app.

The publisher app will handle displaying an advertisementfor the advertised app.

And finally, the advertised app measures engagementfrom actions that people take from within their app.These actors each play a role at different pointsin an end-to-end flow of AdAttributionKit.

An end-to-end flow begins with an ad networkcreating an ad payload for an app.The ad network then delivers an ad payload to the publisher app,and the publisher app will display an advertisement to someone.

Someone can interact with an ad by either viewing itor tapping on it, which leads to either an install or re-engagement conversion.

An install conversion occurs when someone installs your appfrom the App Store or an alternativeapp marketplace as a result of interacting with an ad.

Re-engagement conversions occur when someoneengages with an ad for an app they alreadyhave installed, taking them into the advertised app directly.

Once a conversion has occurred, the advertisermeasures interactions and engagement that people perform inside of their app.

After the conversion window has ended, the data representingthe conversion and engagement measurements are transmitted in the form ofa postback back to the ad network.And that completes an end-to-end flow of AdAttributionKit.

As a quick recap if you’re not familiar, AdAttributionKit launched with iOS 17.4and included support for install conversions.We added re-engagement support with iOS 18.

For a refresher on getting started with AdAttributionKit,check out our WWDC24 session, “Meet AdAttributionKit.”With that review in mind, we’re excited to show younew features we've built that enhance different parts of the end-to-end flow.

If you’re a developer of an advertised app,I’ll show you some powerful new features aroundmeasurement and testing flows you can use in your app.

If you’re an ad network or a downstream consumer of postback data,Yuchi will share enhancementswe’ve built for your attribution flows and new data in postbacks.

We've divided this talk into four parts.

First, I’ll cover conversion tags, which enables you to measureoverlapping re-engagement conversions inside of your app.

Yuchi will then give a breakdown of how you can customize attribution rulesfor your app and discuss new geography data we’ve added to postbacks.

And finally, I’ll wrap up with how to test your AdAttributionKitimplementation with new testability in the iOS Settings app.

Let’s dive into how you can measure overlapping conversion windows.

Let’s focus on the re-engagement flow inside of our end-to-end diagram.

Up until iOS 18.3, your app can only have one activere-engagement conversion at any point in time.

As of iOS 18.4, your app can now have multiple activere-engagement conversion windows at the same time.

Your app can also receive conversion tags,which is like a bookmark for a conversion.You can use conversion tags to specify, which re-engagement conversion to update.Let’s review a scenario where you would use conversion tags in your app.

As a developer, you may run multiple re-engagement campaignsto promote different sales you’re offering to customers in your app.

A customer could see an ad promoting a discountedproduct in your app and decide to tap on it.That Interaction will deep link them into your appand create a re-engagement conversion in the system.Then, after a few minutes, they leave your app without purchasing the item.

Continuing the scenario, a few hours laterthe same customer sees another ad promoting a second discounted itemin your app and decides to tap the ad.

This creates another re-engagement conversion in the system.After some time in the app, they decide to go backand purchase the first discounted item.Using conversion tags, you can update the conversion valuefor the original conversion corresponding to Discount 1.This will be really useful if you run re-engagement campaigns formultiple products in your app at the same time.To begin measuring overlapping conversion windows,set the EligibleForAdAttributionKitOverlappingConversionskey to YES in the Info.plist for your app.Without this, prior conversions will continue to lock whenthey overlap, as they did before.

Next, I’ll show you how your app can get conversion tags.

Once your app has opted in, conversion tagswill be appended to the re-engagement URL that AdAttributionKit delivers to your appwhen a re-engagement occurs.

Re-engagement URLs are Universal Links that are passed into APIswhen either a custom rendered or StoreKit rendered ad is on the screen.

The tag is delivered as the value of AdAttributionKit’sre-engagement open parameter.In this example URL, the tag is equal to 1.

When your app receives a re-engagement URL,you can extract the conversion tag using a function like this.I'll break down what's happening here.First, the function gets the components of the URLthat were passed in using URLComponents.

Next, it gets the list of query items.AdAttributionKit always appends a re-engagement open parameterif the app was open because of a re-engagement.

Next, it looks through the list of query parametersthat are attached on the URL.

If it finds the reengagement open parameter on the URL,it’ll return the value of that parameter immediately.If it’s not able to find the query parameter,the function will return nil.

Now that you have a conversion tag in your app,you can use it to update that conversion directly.

We recommend associating conversion tagswith the reengagement conversion that created it,so you can tie back meaningful events that occuras a result of that conversion.

You should also store the conversion tag either locallyin your app or in a server-side data store.

Once a customer performs an action in your appthat you’d like to measure for that specific conversion,retrieve the tag for that conversion.

Now, let me show you how to use a conversion tagto make a directed update to a conversion in code.

This function takes a conversion value in conversion tagto update a specific postback.When initializing a PostbackUpdate struct,pass in the conversion tag for the conversion you’d like to update.

Then you can call the Postback API to update the conversion value.

You can also call the updateConversionValue APIwithout a conversion tag,and the system will update the most recent conversions postbacks.

And that’s how you can use conversion tags to update postbackswhen you have overlapping conversion windows.Measuring conversion values for postbacks is only one piece of the puzzlewhen using AdAttributionKit.Interpreting postback data you receive downstreamis another important aspect of the system,and can help inform marketing decisions you might makefor your app's business.Yuchi, do you have updates to share in this space?I sure do.Here are some new features that will help you better consumeand interpret the postback data you receive.To capture the most meaningful signals in your postback data,we added the ability to customize the attribution rulesfor your app, which enables you to adjust your attribution flow.

There are two ways in which you could adjust your attribution flow.

The first one is configurable attribution window.

Revisiting the end-to-end ad attribution flow,AdAttributionKit performs attribution based on ad recency and ad type.

The two ad types supported by AdAttributionKitare click-through ad and view-through ad.

Different ad types typically target a different time horizon.For example, a click-through ad might target driving conversions within 10 days.And when a conversion happens later than the targeted time frame,let’s say at 20 days after the impression display time,this conversion should no longer be considered driven by this ad.And this ad targeting time frame is what we refer to as the attribution window.

The attribution window is defined as the time periodstarting from the ad display timefor the latest time that this ad can still be considered for attribution.

If conversion happens within the attribution window of an ad,then this ad would compete for the attribution of this conversion.Otherwise, this ad would not compete for the attribution of this conversion.Previously, all click-through ads that are less than 30 days old,and view-through ads that are less than 1 day oldwould be considered for attribution.We wanted to make this period flexible for you,and therefore, we’re introducing configurable attribution window.

As an advertiser, you can specify your desiredattribution window length in the Info.plist file.This example uses a JSON file to illustrate the configurations,but the same keys and structure can be usedwhen editing your app’s Info.plist file.Attribution window can be defined on a per-ad network basisand a per-ad interaction type basisthat are view-through ads and click-through ads.

Here's an example.For the ad network com.example.adNetwork,the advertiser specified an attribution windowof two days for click-through ads and one day for view-through ads.If an ad network partner focuses primarily on one type of ad,you might want to completely ignore other ad types from that ad network.You can do this by specifying the ignoreInteractionType key.This key can be set together “view” or “click”,but not both simultaneously.If you work with multiple ad networks,specifying attribution window length for them one by one can be a lot of work.In this case, you can specifya window length for all ad networks you work withby adding the global key, which is applied to all ad networks by default.On top of the global window length, you can alsoconfigure the attribution window length for specific ad networks,which will take precedence over the global configuration.

If no ad network or global configuration is found, we will fallback to the defaultattribution window length we use today.In the example, the attribution window for click-through adsfrom ad com.example.adNetwork will be five days,and view-through ads from that ad network will be ignored.For all other ad networks,the attribution window for view-through ads will be three days.Note that the concept of attribution window only applies to install ads,not re-engagement ads.This is because re-engagement ad interactionsand conversions happen right after each other with no time gap in between.

The second way in which you can adjust your attribution flowis the configurable cooldown.

Revisiting the end-to-end ad attribution flow.Let’s focus on the user engagement measurement followingan ad-driven conversion.After an ad network serves an ad, and the ad-driven conversion happens,the window for advertisers to measure user engagement opens.We refer to this window as the conversion window.Advertisers can measure the value of the conversionbased on activities people take in their app,such as subscription and In-App Purchase,by invoking the updateConversionValue API.

In reality, many of these ad attributions might behappening simultaneously for the same advertised appon the same device.And the conversion windows may overlap, in which case,a measurement might not get accorded to the most appropriate conversion.

Let’s walk through a more concrete example.

If someone clicked on an ad and downloaded the advertised app,and a bit later performed an In-App Purchase,which resulted in a high user value measurement towards the install ad.

But imagine immediately after installing the app,the same person tapped on a re-engagement ad and opened the app.Then the In-App Purchase that should have been attributedto the install ad would be attributed to the re-engagement ad.This might not be the desired measurement objective for you.

The same scenario may occur for a re-engagement adthat closely follows another re-engagement conversion.What would have been attributed to the first re-engagement ad,will not get attributed to the second re-engagement ad.To prevent this, you might want to set a periodafter each conversion to block other signaland use that period only to measure value of adsthat drove the dedicated conversion.This is what we call the configurable attribution cooldown.The configurable attribution cooldowncan be specified on a per conversion type basis.The cooldown will start from every conversionof that specific type, and all other conversions that happenedbefore the cooldown fully elapsedwill not be attributed towards any conversion.As an advertiser, you can specify your desired attribution cooldownin the Info.plist file.In this example, an advertiser specified a cooldown of six hours for installand one hour for re-engagement.With this configuration,let’s say someone clicked on the installation adand then installed an app at time T.And the configured cooldown for install is six hours.If the same person tap on the re-engagement adand opened the app four hours after the install,then this re-engagement conversion will not be attributed to the ad.

If let’s say the re-engagement ad tab and app openhappened seven hours after the install,then the re-engagement will receive an ad attribution.

For both configurable attribution window and attribution cooldown,the JWS format will remain unchanged for the impressions and the postbacks.Aside from these configurable features,we’ve also added new geography information to postbacksthat will help you measure the success of your ad campaigns in different countries.

Back to the end-to-end ad attribution flow.Now let's focus on postbacks.

Postbacks are the outputs of AdAttributionKitwhich transmit information about the conversion,such as attribution, and user engagement measurement.Postbacks are delivered to the ad networksand optionally to the developers of advertised apps.We understand that advertisers and ad networkswould like to access the geo info for conversionsin order to optimize ad delivery.Today, some implementations rely on the source identifier for this information.With the latest AdAttributionKit,the country code is provided as a new field in the postback.Here’s what country code represents in different context.

For apps installed from the App Store, country code in the postback is derivedfrom the App Store storefront that the app was downloaded frombased on the location selected in user’s Account Settings.

For re-engagement conversion,postbacks use the same location from when the app was initially installed.

With iOS 17.4, alternative app marketplacescan supply an install verification tokento communicate an app installation signal with an Apple device.The install verification token is a JWS tokenwith payload including information about the app install,such as the timestamp of the download, and the downloaded app ID.Starting with the new iOS version,alternative app marketplaces provide a new field for country codein the install verification token payload.Sign it, and send to Apple.Then Apple will validate the valueand populate the postback country code field with the code.

The country code is an optional field in the install verification token.If the system cannot find a country code in the install verification token,then there will be no country code in the postback.

Note that the country code value for conversionvia alternative app marketplaces is limitedto the locations where alternative marketplaces are supported.

This is how country code will be added to the postback.Country code will be an unsigned field parallelto the ad-interaction-type, signed JWS token,and coarse-conversion-value.The country code field is subject to the crowd anonymity algorithmthat AdAttributionKit enforces to all postbacks.Crowd anonymity algorithm sits at the centerof our privacy preserving ad attribution,where we ensure each individual’s uniquenessblend into a big crowd before releasing identifiable informationto the advertiser and ad network.

The postbacks will only contain country codeif there has been enough volume for similar conversionswithin the same country.The crowd anonymity tier that qualifies for country code presencein the postbackwill be a bonus tier on top of the four crowd anonymity tierswe enforce today.This means that under no circumstance advertisersand ad networks will lose the data they’re currently receiving.That concludes our latest updates to postback data.Mike will now share our new AdAttributionKit testability.Thanks Yuchi for all that great information.Now that we covered all the new features of AdAttributionKit,I’ll show the new ways to test your implementation.

Let’s return to our end-to-end diagram and focus on the ad deliveryand conversion flow.

This is a typical flow you might use whentesting your app’s AdAttributionKit implementation.

First, you need to create and serve an ad payload for your advertised app.

Then you display and interact with an ad in a separate publisher app,and then perform an install or re-engagement conversionto create development postbacks for your app.

With iOS 18.4, you can now create development postbacksfor your app directly in the iOS Settings app.

Postbacks created from developer settings allow you to test in new ways.You can now test updating conversion values if your app was run from Xcodeor other distribution mechanisms, such as ad-hoc distribution.You also now have direct control over the data your postbacks will contain.This can be useful for testing your server implementationfor processing various data tiers of postbacks.

Now I’ll show how you can use developer settingsto create postbacks for your app.

Before you start, you'll need to make sure Developer Mode is enabled on your device.Next, go into the developer settings inside of the Settings app.

Inside of developer settings, scroll down to the Ad Attribution Testing section.

We added a new page named Development Postbacksabove AdAttributionKit Developer Mode.

Tapping into the Development Postbacks page,you’re presented with options to configure postbacks for your app,transmit any eligible postbacks, or clear all development postbacs from your device.

To configure development postbacks,type in your app’s bundle identifier and tap the Configure button.

The app must be installed on your device before you can create postbacks for it.

The first step is to specify a destination for your postback.This should be the URL of your server.

It is best practice to use a development URL when testing,different than the URL where you receive production postbacks.

You can also fetch the postback copy URL from your app automatically.You can use this to confirm the well-known URL that the system generatesmatches the URL your server exposes.

Next, fill in the properties of your postback.You can configure the postback to representany type of conversion you would like by editing the properties.

Now in iOS, you’ll be able to configure country code as a new property.This will help you test country code in postbacks, which Yuchi discussed earlier.

After configuring the properties, you can adjust the data granularity ofeach individual postback.

This granularity controls how much information will be sent to your server.You can use this to validate your server implementationprocesses different postback data tiers correctly.

When you’re done configuring your postbacks,tap the button to create them for your app.

Now that your app has development postbacks,you can start updating their conversion values.

During testing, call the updateConversionValue(_:) APIto update the development postbacks.

You can wait for the development postback to send automatically,or you can tap the Transmit Development Postbacks buttonwhen your postback conversion window ends.

Postbacks created in developer settings have some key differencesthan ones created in end-to-end flows.I’ll show the changes you’ll see in your postback’s JSON Web Signature.

This is a snippet of the header you would receive in your postback.

Postbacks created from developer settings are signed using a new key,indicated with a new kid value.Check out our documentation on verifying postbacks to obtain the new public keyto validate the signature of these postbacks.

Switching focus, the payload of the postbackalso has some differences that are worth mentioning.

The ad network identifier will always be set to development.adattributionkit.This helps further distinguish postbackscreated in developer settings from production postbacks.

The advertised item identifier of the postback may also be zero.For example, if you ran your app from Xcode while testing.

And that wraps up the new testability featureswe’ve added to AdAttributionKit.We think this new testability will help streamlineyour workflow when developing and testing your AdAttributionKit implementation.We covered a lot of ground today for our new AdAttributionKit features.From measuring overlapping conversion windows in your appto receiving country code and postbacks,these updates impact various pieces of ad attribution.

Some next steps: if you’re ready to configure attribution rules for your app,be sure to start adding the new configurationkeys to your app’s Info.plist.Start using the new testability to test out your AdAttributionKit implementationearlier in your development lifecycle, before releasing to production.And if you’re using SKAdNetwork,now is a great time to migrate over to AdAttributionKitand start building with all of the new features.We want to thank our community of developers that give us feedbackon their experiences using our privacy-first ad frameworks.Your feedback helps drive what we build and how we can deliverexcellent ad experiences for your app that maintain user privacy.Thank you!

5:42 -Function that retrieves a conversion tag from a URL

6:55 -Function that updates conversion value using a conversion tag

9:32 -Example Info.plist for configuring attribution window

9:58 -Example Info.plist for configuring attribution window

10:14 -Example Info.plist for configuring attribution window

10:30 -Example Info.plist for configuring attribution window

11:05 -Example Info.plist for configuring attribution window

13:52 -Example Info.plist for configuring attribution cooldown

16:02 -Example install verification token payload

16:26 -Example install verification token payload

17:05 -Example postback with country code

0:00 -IntroductionAdAttributionKit, designed with user privacy in mind, enables advertisers to measure ad campaign success while preserving user anonymity. The system involves three main actors: ad networks, publisher apps, and advertised apps. 

The process starts with an ad network delivering an ad to a publisher app, which then displays it to users. Interactions with the ad can lead to installs or re-engagements, which are measured by the advertised app. After a specific conversion window, data is transmitted back to the ad network in a postback.

AdAttributionKit, launched in iOS 17.4 and later updated to support re-engagement in iOS 18, now includes new features such as conversion tags for measuring overlapping re-engagement conversions, customizable attribution rules, new geography data in postbacks, and enhanced testability within the iOS Settings app.3:23 -Measure overlapping conversion windowsIn iOS 18.4, you can now have multiple active re-engagement conversion windows simultaneously in your apps. Prior to this, only one conversion is active at a time. 

Conversion tags, which act as bookmarks, now specify which re-engagement conversion to update when a user interacts with multiple ads or campaigns. This is particularly useful when running simultaneous promotions for different products.

To enable this new functionality, you must set the 'EligibleForAdAttributionKitOverlappingConversions' key in your app's Info.plist file. Once opted in, conversion tags are appended to re-engagement URLs, so you can extract and store them for later use. When someone performs an in-app action, the corresponding conversion tag is retrieved and used to update the conversion value directly through the Postback API, ensuring accurate attribution of conversions to the relevant campaigns.7:50 -Customize attribution rulesAdvertisers can now customize their attribution rules for apps. This new feature enables two main ways to adjust the attribution flow:

Configurable Attribution Window. Using this feature, advertisers can specify the time period after an ad is displayed when it can still be considered for attribution. Previously, all click-through ads under 30 days old and view-through ads under one day old were considered. Now, advertisers can set these windows on a per-ad network and per-ad interaction type basis. They can also ignore specific ad types from certain networks by specifying the 'ignoreInteractionType' key, or set a global attribution window length that applies to all networks unless overridden by specific configurations.

Configurable Attribution Cooldown. This feature prevents multiple conversions from overlapping and potentially misattributing user engagement. After a conversion, you can set a cooldown period in the Info.plist, during which time any other conversions are not attributed. This ensures that the value of a conversion is accurately measured for the ad that drove it. Advertisers can specify cooldown periods on a per-conversion type basis, such as install or re-engagement conversions.14:46 -Receive geography data in postbacksAdAttributionKit now has enhanced postbacks with new geography information, specifically country codes, to aid advertisers and ad networks in optimizing ad delivery across different countries. The country code field in postbacks is derived from the App Store storefront for initial installs and re-engagements. 

For apps installed from alternative app marketplaces in iOS 17.4 and later, the country code is included in the install verification token payload, validated by Apple, and then added to the postback. This new field is subject to the Apple crowd anonymity algorithm to ensure user privacy, and is only included in postbacks for conversions with sufficient volume within the same country, providing an additional tier of data without compromising existing information.18:12 -Test AdAttributionKitIn iOS 18.4, you can now directly create development postbacks for your apps within the iOS Settings app. This new feature enables testing of various scenarios, like updating conversion values before your app is released to production and validating server implementation for processing different data tiers of postbacks. 

You can configure postbacks by specifying the app's bundle identifier, destination URL, and various properties, including the new country code property. You can also adjust the data granularity of each postback.

Postbacks created in Developer Settings have distinct characteristics, such as a new signature key and specific values for the ad network identifier ('development.adattributionkit') and advertised item identifier, to distinguish them from production postbacks. This enhancement streamlines the development and testing workflow for AdAttributionKit implementation.

0:00 -Introduction

AdAttributionKit, designed with user privacy in mind, enables advertisers to measure ad campaign success while preserving user anonymity. The system involves three main actors: ad networks, publisher apps, and advertised apps. 

The process starts with an ad network delivering an ad to a publisher app, which then displays it to users. Interactions with the ad can lead to installs or re-engagements, which are measured by the advertised app. After a specific conversion window, data is transmitted back to the ad network in a postback.

AdAttributionKit, launched in iOS 17.4 and later updated to support re-engagement in iOS 18, now includes new features such as conversion tags for measuring overlapping re-engagement conversions, customizable attribution rules, new geography data in postbacks, and enhanced testability within the iOS Settings app.

AdAttributionKit, designed with user privacy in mind, enables advertisers to measure ad campaign success while preserving user anonymity. The system involves three main actors: ad networks, publisher apps, and advertised apps. 

The process starts with an ad network delivering an ad to a publisher app, which then displays it to users. Interactions with the ad can lead to installs or re-engagements, which are measured by the advertised app. After a specific conversion window, data is transmitted back to the ad network in a postback.

AdAttributionKit, launched in iOS 17.4 and later updated to support re-engagement in iOS 18, now includes new features such as conversion tags for measuring overlapping re-engagement conversions, customizable attribution rules, new geography data in postbacks, and enhanced testability within the iOS Settings app.

3:23 -Measure overlapping conversion windows

In iOS 18.4, you can now have multiple active re-engagement conversion windows simultaneously in your apps. Prior to this, only one conversion is active at a time. 

Conversion tags, which act as bookmarks, now specify which re-engagement conversion to update when a user interacts with multiple ads or campaigns. This is particularly useful when running simultaneous promotions for different products.

To enable this new functionality, you must set the 'EligibleForAdAttributionKitOverlappingConversions' key in your app's Info.plist file. Once opted in, conversion tags are appended to re-engagement URLs, so you can extract and store them for later use. When someone performs an in-app action, the corresponding conversion tag is retrieved and used to update the conversion value directly through the Postback API, ensuring accurate attribution of conversions to the relevant campaigns.

In iOS 18.4, you can now have multiple active re-engagement conversion windows simultaneously in your apps. Prior to this, only one conversion is active at a time. 

Conversion tags, which act as bookmarks, now specify which re-engagement conversion to update when a user interacts with multiple ads or campaigns. This is particularly useful when running simultaneous promotions for different products.

To enable this new functionality, you must set the 'EligibleForAdAttributionKitOverlappingConversions' key in your app's Info.plist file. Once opted in, conversion tags are appended to re-engagement URLs, so you can extract and store them for later use. When someone performs an in-app action, the corresponding conversion tag is retrieved and used to update the conversion value directly through the Postback API, ensuring accurate attribution of conversions to the relevant campaigns.

7:50 -Customize attribution rules

Advertisers can now customize their attribution rules for apps. This new feature enables two main ways to adjust the attribution flow:

Configurable Attribution Window. Using this feature, advertisers can specify the time period after an ad is displayed when it can still be considered for attribution. Previously, all click-through ads under 30 days old and view-through ads under one day old were considered. Now, advertisers can set these windows on a per-ad network and per-ad interaction type basis. They can also ignore specific ad types from certain networks by specifying the 'ignoreInteractionType' key, or set a global attribution window length that applies to all networks unless overridden by specific configurations.

Configurable Attribution Cooldown. This feature prevents multiple conversions from overlapping and potentially misattributing user engagement. After a conversion, you can set a cooldown period in the Info.plist, during which time any other conversions are not attributed. This ensures that the value of a conversion is accurately measured for the ad that drove it. Advertisers can specify cooldown periods on a per-conversion type basis, such as install or re-engagement conversions.

Advertisers can now customize their attribution rules for apps. This new feature enables two main ways to adjust the attribution flow:

Configurable Attribution Window. Using this feature, advertisers can specify the time period after an ad is displayed when it can still be considered for attribution. Previously, all click-through ads under 30 days old and view-through ads under one day old were considered. Now, advertisers can set these windows on a per-ad network and per-ad interaction type basis. They can also ignore specific ad types from certain networks by specifying the 'ignoreInteractionType' key, or set a global attribution window length that applies to all networks unless overridden by specific configurations.

Configurable Attribution Cooldown. This feature prevents multiple conversions from overlapping and potentially misattributing user engagement. After a conversion, you can set a cooldown period in the Info.plist, during which time any other conversions are not attributed. This ensures that the value of a conversion is accurately measured for the ad that drove it. Advertisers can specify cooldown periods on a per-conversion type basis, such as install or re-engagement conversions.

14:46 -Receive geography data in postbacks

AdAttributionKit now has enhanced postbacks with new geography information, specifically country codes, to aid advertisers and ad networks in optimizing ad delivery across different countries. The country code field in postbacks is derived from the App Store storefront for initial installs and re-engagements. 

For apps installed from alternative app marketplaces in iOS 17.4 and later, the country code is included in the install verification token payload, validated by Apple, and then added to the postback. This new field is subject to the Apple crowd anonymity algorithm to ensure user privacy, and is only included in postbacks for conversions with sufficient volume within the same country, providing an additional tier of data without compromising existing information.

AdAttributionKit now has enhanced postbacks with new geography information, specifically country codes, to aid advertisers and ad networks in optimizing ad delivery across different countries. The country code field in postbacks is derived from the App Store storefront for initial installs and re-engagements. 

For apps installed from alternative app marketplaces in iOS 17.4 and later, the country code is included in the install verification token payload, validated by Apple, and then added to the postback. This new field is subject to the Apple crowd anonymity algorithm to ensure user privacy, and is only included in postbacks for conversions with sufficient volume within the same country, providing an additional tier of data without compromising existing information.

18:12 -Test AdAttributionKit

In iOS 18.4, you can now directly create development postbacks for your apps within the iOS Settings app. This new feature enables testing of various scenarios, like updating conversion values before your app is released to production and validating server implementation for processing different data tiers of postbacks. 

You can configure postbacks by specifying the app's bundle identifier, destination URL, and various properties, including the new country code property. You can also adjust the data granularity of each postback.

Postbacks created in Developer Settings have distinct characteristics, such as a new signature key and specific values for the ad network identifier ('development.adattributionkit') and advertised item identifier, to distinguish them from production postbacks. This enhancement streamlines the development and testing workflow for AdAttributionKit implementation.

In iOS 18.4, you can now directly create development postbacks for your apps within the iOS Settings app. This new feature enables testing of various scenarios, like updating conversion values before your app is released to production and validating server implementation for processing different data tiers of postbacks. 

You can configure postbacks by specifying the app's bundle identifier, destination URL, and various properties, including the new country code property. You can also adjust the data granularity of each postback.

Postbacks created in Developer Settings have distinct characteristics, such as a new signature key and specific values for the ad network identifier ('development.adattributionkit') and advertised item identifier, to distinguish them from production postbacks. This enhancement streamlines the development and testing workflow for AdAttributionKit implementation.

## Code Samples

```swift
func
 
retrieveConversionTag
(
fromURL
 
url
: 
URL
) -> 
String
? {
    
guard
 
let
 components 
=
 
URLComponents
(url: url, resolvingAgainstBaseURL: 
true
) 
else
 {
        
print
(
"Could not get components for URL."
)
        
return
 
nil

    }

    
guard
 
let
 queryItems 
=
 components.queryItems 
else
 {
        
print
(
"URL does not contain query items."
)
        
return
 
nil

    }

    
for
 item 
in
 queryItems {
        
guard
 item.name 
==
 
Postback
.reengagementOpenURLParameter 
else
 {
            
continue

        }
        
return
 item.value
    }
    
return
 
nil

}
```

```swift
func
 
updateConversionValue
(
_
 
conversionValue
: 
Int
, 
conversionTag
: 
String
) 
async
 {
    
do
 {
        
let
 update 
=
 
PostbackUpdate
(fineConversionValue: conversionValue,
                                    lockPostback: 
false
,
                                    conversionTag: conversionTag)
        
try
 
await
 
Postback
.updateConversionValue(update)
    }
    
catch
 {
        
print
(
"An error occurred while updating the conversion value: 
\(error)
"
)
    }
}
```

```swift
{

  
"AdAttributionKitConfigurations"
:
 
{

    
"AttributionWindows"
:
 
{

      
"com.example.adNetwork"
:
 
{

        
"install"
:
 
{

          
"click"
:
 
2
,

          
"view"
:
 
1

        
}

      
}

    
}

 
}
```

```swift
{

  
"AdAttributionKitConfigurations"
:
 
{

    
"AttributionWindows"
:
 
{

      
"com.example.adNetwork"
:
 
{

        
"install"
:
 
{

          
"click"
:
 
2
,

          
"ignoreInteractionType"
:
 
"view"
                     
        
}

      
}

    
}

 
}
```

```swift
{

  
"AdAttributionKitConfigurations"
:
 
{

    
"AttributionWindows"
:
 
{

      
"global"
:
 
{

        
"install"
:
 
{

          
"view"
:
 
3

        
}

      
}

      
"com.example.adNetwork"
:
 
{

        
"install"
:
 
{

          
"click"
:
 
5
,

          
"ignoreInteractionType"
:
 
"view"

        
}

      
}

    
}

 
}
```

```swift
{

  
"AdAttributionKitConfigurations"
:
 
{

    
"AttributionCooldown"
:
 
{

      
"install-cooldown-hours"
:
 
6
，
      
"reengagement-cooldown-hours"
:
 
1

    
{

  
}


}
```

```swift
{
 
  
"iss"
:
 
13421973
,

  
"iat"
:
 
1745255692
,

  
"iid"
:
 
"34890933"
,

  
"vid"
:
 
"46392455"
,

  
"aud"
:
 
"AppleDownloadVerification-v1"
,

  
"bid"
:
 
"com.example.marketplace"
,

  
"dtype"
:
 
"download"
,

  
"nonce"
:
 
"9BC2C5CC-A1F8-4F93-9D6A-4D524685B67E"


}
```

```swift
{
   
  
"iss"
:
 
13421973
,

  
"iat"
:
 
1745255692
,

  
"iid"
:
 
"34890933"
,

  
"vid"
:
 
"46392455"
,

  
"aud"
:
 
"AppleDownloadVerification-v1"
,

  
"bid"
:
 
"com.example.marketplace"
,

  
"dtype"
:
 
"download"
,

  
"nonce"
:
 
"9BC2C5CC-A1F8-4F93-9D6A-4D524685B67E"
,

  
"ccode"
:
 
"MT"


}
```

```swift
{

   
"ad-interaction-type"
:
 
"click"
,

   
"jws-string"
:
 
"eyJraWQiOiJhcHBsZS1jYXMtaWRlbnRpZmllci8wIiwiYWxnIjoiRVMyNTYifQ.eyJhZHZlcnRpc2VkLWl0ZW0taWRlbnRpZmllciI6Njg0OTM5LCJjb252ZXJzaW9uLXR5cGUiOiJyZS1lbmdhZ2VtZW50IiwibWFya2V0cGxhY2UtaWRlbnRpZmllciI6ImNvbS5hcHBsZS5BcHBTdG9yZSIsImFkLW5ldHdvcmstaWRlbnRpZmllciI6InRlc3QuYWRhdHRyaWJ1dGlvbmtpdCIsImltcHJlc3Npb24tdHlwZSI6ImFwcC1pbXByZXNzaW9uIiwicG9zdGJhY2stc2VxdWVuY2UtaW5kZXgiOjAsInNvdXJjZS1pZGVudGlmaWVyIjoiODM0NCIsImRpZC13aW4iOnRydWUsInBvc3RiYWNrLWlkZW50aWZpZXIiOiIzZjUwZmU1Ny0yOWFlLTQ4NjEtOGMwYi1hYzZhZGRkZmY3MmMiLCJwdWJsaXNoZXItaXRlbS1pZGVudGlmaWVyIjo1ODM4NDkyfQ.AemK1x2ahIPKOnFEEscG4wvipRtR1G6DzpNF4M4joPb8POIH4FJjm4VvcNgLXc9rWBrEDQPvDblduoc7MFcK5w"
,

   
"coarse-conversion-value"
:
 
"medium"
,

   
"country-code"
:
 
"MT"


}
```


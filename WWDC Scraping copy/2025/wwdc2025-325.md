# Wwdc2025 325

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Summary

Transcript

Code

Discover Apple-Hosted Background AssetsBuilding on Background Assets, this session will introduce the new capability to download asset packs of content for games and other applications. Learn how Apple can host these asset packs for you or how to manage self-hosting options. We'll delve into the native API integration and the corresponding App Store implementations, providing you with the tools to enhance your app's content delivery and user experience.Chapters0:00 -Introduction1:01 -New in Background Assets7:32 -Sample app development17:24 -Beta testing and distributionResourcesConfiguring your Background Assets projectDownloading asset packs hosted by AppleMaximum build file sizesOverview of Apple-hosted asset packsTesting your asset packs locallyHD VideoSD VideoRelated VideosWWDC25Automate your development process with the App Store Connect APIWhat’s new in App Store ConnectWWDC23What’s new in Background Assets

Building on Background Assets, this session will introduce the new capability to download asset packs of content for games and other applications. Learn how Apple can host these asset packs for you or how to manage self-hosting options. We'll delve into the native API integration and the corresponding App Store implementations, providing you with the tools to enhance your app's content delivery and user experience.

0:00 -Introduction

1:01 -New in Background Assets

7:32 -Sample app development

17:24 -Beta testing and distribution

Configuring your Background Assets project

Downloading asset packs hosted by Apple

Maximum build file sizes

Overview of Apple-hosted asset packs

Testing your asset packs locally

HD VideoSD Video

HD Video

SD Video

Automate your development process with the App Store Connect API

What’s new in App Store Connect

What’s new in Background Assets

Search this video…Hello, I'm Gabriel.I’m a software engineer on the App Store team.And my name is Jenny.I’m an engineer on the App Processing team.Today, we’re introducing a new way to distribute assets foryour app on the App Store with Background Assets.I’ll cover how your app and assets work together on people’s devices.And I will share how you can use Apple hosting for your assets.In this session,we will first review the current available asset delivery technologies,including Background Assets.Then dive into what’s new this year,including new Swift and Objective-C APIs to manage your Background Assets,as well as Apple hosting.We will show you how to integrate the new features into your app for iOS,iPadOS, macOS, tvOS, and visionOS, and how to do local testing.If you would like that Apple host and deliver your assets,we will walk you through how to prepare for beta testingand App Store distribution.Now, let’s hear from Gabriel for a recap and what’s new in Background Assets.Thanks, Jenny.When people download an app from the App Store,they expect to use it immediately.They may leave or even delete your app if they must wait for other downloadsto finish after opening it.With Background Assets, we’re making it even easierto deliver a great first launch experience.You can configure how the system downloads your assets on devicesand update them without needing to update your main app.For example, you could deliver a tutorial levelonly to people who newly download a game to get them playing quicklywhile the rest of the game is downloaded in the background,offer optional downloadable content, also known as DLC,that you unlock with In-App Purchase,or update on device machine learning modelswith an accelerated submission process to the App Store.Suppose that you’re developing a game with several different levels,including a tutorial.You have four options for delivering the assets for each level:Keeping everything in your main app bundle,URLSession,On-Demand Resources,or Background Assets.There are pros and cons to some of them, so let me go through it.Keeping everything in your main app bundleforces people to wait for all of the assets to download,even if you only need some of them to start the tutorial level.You could also hit the 4GB size limit on most platforms,and updating just one of your assets would require re-uploadingand resubmitting your entire app.On-Demand Resources would let people jump into the tutorial more quickly,because it lets you download some parts of your app bundle separatelyfrom TestFlight or the App Store,but you would still need to update your entire appjust to update a few asset files.On-Demand Resources is a legacy technology,and it will be deprecated.Its successor is Background Assets,with which you host your app’s assets on your own server.You can update those assets at any time without updating your whole app.At the core of Background Assets is the downloader extension,which lets you write code to schedule asset downloadsbefore people open your app.This is great when you need full controlover download behavior and post-processing.For many of you, though,we know that what matters most is that your app’s assets simplybe available and up to date.With the new Managed Background Assets features,the system automatically manages downloads,updates, compression, and more for your asset packs.In fact, we’ve written a system-provided download or extensionthat you can drop into your app with no custom code needed.Plus, with the new Apple-Hosted Background Assets servicefor apps on TestFlight and the App Store,you no longer need to host your assetson your own server with the Apple hosting option.You get 200GB of Apple hosting capacityincluded in your Apple Developer Program membership.If you’re still using On-Demand Resources,then we suggest that you start your migration to Background Assets.With Managed Background Assets, you create multiple asset packsthat each group together some of your asset files,such as the textures, sound effects, and GPU shaders for a tutorial levelin a game.The system automatically downloads an asset pack on people’s devicesbased on its download policy.There are three download policies:Essential, Prefetch, and On-demand.An essential download policy means that the system automaticallydownloads the asset pack and integrates the downloadinto the installation process.The asset pack contributes to the overall download progressthat people see in the App Store, in TestFlight, and on the home screen.And once the installation finishes and a person opens your app,the asset pack is ready to use.A prefetch download policymeans that the system starts downloading the asset packduring the installation of the app,but the download could continue in the backgroundafter the app’s installation finishes.An on-demand download policymeans that the system downloads the asset pack only whenyou explicitly call an API method to request it.You can either host your asset packs yourselfor let Apple host them for you.Now, I’ll hand it over to Jennyto cover how Apple servers deliver asset packs and app builds.Sure thing!Each Apple hosted asset packcan be used on one app, across multiple platforms of your choice.For the device to download the app binary and any asset pack it uses,you will first need to separately upload both to App Store Connect.You can then submit them for reviewfor external testing in TestFlight and App Store distribution.Once uploaded, the asset pack is assigned a version,and it is not tied to any specific app build.How the app and asset pack match upon the device is determined by the state of the asset pack version.Let me explain with some examples.Let’s say you have three different versionsfor the same asset pack.Version 1 is live on the App Store,Version 2 is live for external beta on TestFlight,and Version 3 is live for internal beta on TestFlight.Only one version of the asset pack can be live for each context.At the same time, you have some app buildson devices that are downloaded from the App Store,or through TestFlight external beta or internal beta.The server will select to deliver the live version of your asset packfor all your app builds in that particular context.That means app version 1.0 build 1that is downloaded from the App Store will use asset pack version 1.App version 2.0 build 1 that is availablefor external beta in TestFlight will use asset pack version 2.And app version 2.0 builds 2 and 3 in internal betawill use asset pack version 3.Now, it is important to understand the behavior when you make updatesto the Asset Pack version.For example, if you’re happy with asset pack version 2,you can submit it for App Store distribution.It will replace the old version to be live on the App Store.This means all versions of your app downloadedfrom the App Store will automaticallybe switched over to using asset pack version 2,including older versions that are still installed on people's devices.So, before you update the asset pack, make sure thatit will work on older app builds and versions as well.Now, let’s look at an example for app build update.Let’s say you want to submit app version 2.0 build 3for external beta testing.After approval, if the build is downloaded through external beta,it will use the older asset pack version 2.If you would like it to be paired with the newer asset pack version 3,make sure to submit the asset pack version as well.Now that you’re familiar with the concept of asset packs,Gabriel will walk you through how to create themand use them in your app.Thanks, Jenny.Now, let me show you how to use Managed Background Assets in your app.To get started with Managed Background Assets,you’ll create asset packs, adopt the new APIs,and test your app and asset packs locally.Let me explain how to create an asset pack.You can use the new packaging tool for macOS, Linux, and Windowsthat takes files from your source repositoryand packages them into a compressed archivefor delivery to TestFlight and the App Store.The packaging tool ships with Xcode on macOS and will soon be availableto download from the download section of the Apple developer websitefor Linux and Windows.Let me show you the tool in action.You can start by running the template commandto generate a manifest template.On macOS, install Xcode and run xcrun ba-package template in Terminal.On Linux or Windows, make the tool available in your shell’s search pathand run ba-package template.The packaging tool will generate a manifest template.The manifest is a JSON file that you fill outto tell Apple about your asset pack.You can choose a custom ID.This is what you’ll use to identify the asset pack in your app’s code,a download policy,and the set of platforms that the asset pack supports.Firstly, let's fill in the file selectors.A file selector selects a set of files in your source repositoryto include in your asset pack.There are two types of file selectors:ones that select individual files, and ones that select entire directories.Let’s add a file selector for the game’s introductory cutscene video,using a relative path from the root of the source repository.This asset pack’s ID is Tutorial because  it contains the asset filesfor the game’s Tutorial level.Now, let's configure the download policy.Since the tutorial is the first thing that people experience,let’s make the tutorial asset pack available locallybefore someone can open the game for the first time.So, this is a great situation in which to use an essential download policy.This tutorial level is relevant only for people who newly install the game.People who already play the game and are simply updating to a new versionshouldn’t need to download the tutorial again.So let’s restrict the essential download policyto just the first installation and exclude subsequent updates.This means that only someone who downloads the gameon their device for the first time will get the tutorial’s assets.Now that the manifest is filled out, let’s run the packaging tool againto generate a compressed archive.We’ll set the current directory to the root of the repository and pass in the path tothe manifest and the path at which to save the archive.Now that the asset pack is packaged, let’s see how we can use it in the game.With just a few lines of code, you can use the new APIsin Background Assets to read the files in your asset packs.We’ll start by adding a downloader extension in Xcode.The downloader extension is how your app schedules asset packs to be downloadedwhen the main app isn’t running, such as during the installation process.Let’s add a new target and select the Background Download template.Here you can choose whether you want to use Apple hosting or your own.The template generates Swift code, but you can easily replace itwith Objective-C code if you prefer.Newly this year, the system now provides a fully-featured downloader extensionthat supports automatic downloads, background updates,and more,which you can drop into your app with no custom code.The snippet that Xcode generates with the Background Download templateis already configured to use the system implementation by default.There's no other extension code to write.In fact, you can even remove the stub shouldDownload(_:) method entirelyif you don’t need to customize the download behavior.This means that you can now add a downloader extension to your appwith just a few lines Xcode generated code.If you do want to customize the download behavior,then you can provide a custom implementation for shouldDownload(_:).The system calls your shouldDownload(_:) implementationfor every new asset pack that, based on the asset pack’s download policy,it plans to download in the background, and you can returna Boolean value to decide whether to proceed with the download.This can be useful if some of your asset packshave specific compatibility requirements.Now that you’ve implemented the downloader extension,let’s see how to use files inside downloaded asset packs in your main app.The first step is to call the ensureLocalAvailability(of:)method on the shared AssetPackManager.This method checks whether the asset pack is currently downloaded.If it isn’t, then it starts downloading it and waits for the download to finish.In most cases,the downloader extension will have already downloaded the asset pack,so the method will return quickly.In the rare situation in which the asset pack must be newly downloaded,it’s a good idea to provide visible progress informationto people using your app.In Swift, you can await status updates on the asynchronous sequencethat the statusUpdates(forAssetPackWithID:) method returns.In Objective-C, you can create an object that conformsto the BAManagedAssetPackDownloadDelegate protocoland attach it to the shared asset pack manager’s delegate property.If you need to cancel a download, then you can do so by calling cancel()on any of the progress structures that you receivein the download status updates.Once ensureLocalAvailability(of:) returns without throwing in error,the requested asset pack is ready to use locally.To read a file from it,call the contents(at:searchingInAssetPackWithID:options:)method on the shared asset pack manager.The first parameter is a relative path from the root of your source repository,that is, the directory from which you previouslyran the packaging tool to create the asset pack,to the file that you want to read.The system automatically merges all of your asset packs into a shared namespace,effectively reconstructing your source repositoryas if it were copy-pasted from your development machineinto people’s devices.This means that you don’t need to worry about keeping trackof which asset pack contains a particular filewhen you want to read that file at runtime.By default, contents(at:searchingInAssetPackWithID:options:)returns a memory mapped data instance,which is suitable even for large asset filesthat take up a lot of space in memory.If you need low-level access to the file descriptor,such as for reading a file into memory procedurally,then you can use the descriptor(for:searchingInAssetPackWithID:)method instead,in which case it’s your responsibility to close the descriptorwhen you’re done using it.You can also restrict the search to a particular asset packby providing a non-nil argumentfor the assetPackID parameter of either method.The system tracks which asset packs your apphas downloaded and automaticallykeeps them up to date in the background.It won’t, however, automatically remove your asset packswhile your app remains installed,so it’s a good practice to call the remove(assetPackWithID:) methodon the shared asset pack manager to free up storage spacewhen you don’t expect to use a particular asset pack anymore.For example, you could remove the Tutorial asset packwhen someone finishes playing the tutorial level.You can always call ensureLocalAvailability(of:)to re-download the asset pack again should, for example, someone reset their progressin the game and start playing the tutorial again.Keep in mind that people can see the storage spacethat your downloaded asset packs take up listed for your appin the storage view in the Settings app on their device.The next step is to add both your main appand your downloader extension to the same app group.The system uses the app group to facilitate coordinationbetween your main app and your extension.Then add the BAAppGroupID keyto your main app’s Info.plist with your app group ID as string value.Also, add the BAHasManagedAssetPacks key with true or yes as its Boolean value.If you’re using Apple hosting, then add the BAUsesAppleHosting key with trueor yes as its Boolean value.If you’re not using Apple hosting,then refer to the related documentation in the Resources section for this sessionto learn more about the other required Info.plist keys,including BAManifestURL.Now that the app and the extension are configured,it's time to test.We created a new Background Assets mock server for macOS,Linux, and Windows to test asset packdownloads before you submit your app to TestFlight or the App Store.Like the packaging tool, the mock server shipswith Xcode on macOS and will soon be availableto download from the Downloads section of the Apple Developer websitefor Linux and Windows.Background Assets uses HTTPS for all downloads,so you first need to issue an SSL certificate.To do that, you’ll create a root certificate authority.Then you’ll install that certificate authorityon your test devices.After that, you'll use the certificate authority to issue an SSL certificate,and finally, you’ll start the mock server and point it to that SSL certificate.For more details, refer to the related documentationin the Resources section for this session.Once you’ve issued your SSL certificate, you can run ba-serveto start the mock server,pass in the respective paths to the Asset Pack archives that you want to serve,and set the host to which to bind.The host can be an IP address, a host name, or a domain name.On macOS, the tool will prompt you to choose an identity,that is, a pair of a certificate and a private key from your keychain.On Linux or Windows, you’ll need to pass in the certificateand its private key on the command line.Pass the help flag to learn about additional options,including an option to set a custom port number,and coming soon on macOS, the ability to skip the identity prompt.On iOS, iPadOS and visionOS test devices, and coming soon on tvOS test devices,go to Development Overrides in Developer Settingsto enter your mock server’s base URL, including its host and port.On macOS test devices, run xcrun ba-serve url-overrideto enter the same information.When you build and run your app from Xcode,it’ll download its asset packs from your mock server.Now, I’ll hand it back to Jennyto talk about beta testing and distributing your asset packs.- Jenny? - Thanks Gabriel.Now that you have the new app binary and asset packs ready,let me take you through how to prepare themfor beta testing on TestFlight and distribution on the App Store.If you’re using Apple hosting, you will upload both your app binaryand asset packs to App Store Connect separately,optionally test with TestFlight, and finally distribute on the App Store.Let’s take a deeper look at how this process works for asset packs.There are several ways to upload an asset pack.For a drag and drop UI experience, you can use the Transporter app for macOS.For full control and transparency, you can use the App Store Connect REST APIsto build your own automation.For a simplified command line interface, the cross platform iTMSTransporterprovides useful commands and makes requests for youto the App Store Connect APIs.You can check out the documentation for all of these tools.Here, I will walk you through using Transporter and the App Store Connect API.With the Transporter app, simply drag and drop your Tutorial.aar archiveinto the Transporter window.Add it to the app of your choice, then click Deliver.It will become a new version of the Tutorial asset pack.You will be able to see the state of your asset pack upload rightin the Transporter app.If you would like full visibility of the upload process,you can use the App Store Connect API.You will need to follow three steps:create asset pack record, create version record for the asset pack,then upload the archive to the asset pack version.First, to create the asset pack record,you can make a POST request to the backgroundAssets resource.In the request body, put in the name of the asset packas the assetPackIdentifier and add your app’s Apple IDin the relationships section.The response of this call will return a UUID to your asset pack,which you can use in later API calls.Then you will create a new version for your asset packby making a POST request to the backgroundAssetVersions resource.In the relationships section, use the ID of the asset pack providedto you by the previous API response.This operation automatically increases the version numberbased on existing versions.Here we will have version 1.You will also get an ID in the response to uniquely identify version 1of the Tutorial asset pack.When the asset pack version is successfully created,you can use the backgroundAssetUploadFiles resourceto make an upload reservation for your Tutorial.aar archive file.This step is to other upload operations like App Store screenshots.Here you would need the asset type, file name, file size, and MD5 checksum.Also include the relationship to the background asset version ID.The response of this call includes an ID for your upload file,and details about the upload instructions.When you successfully upload your archive,make a PATCH call to the backgroundAssetUploadFileswith your Upload File ID, and your asset pack will start processing.To view the asset pack’s progress,you can always get the most comprehensive informationabout your available asset packs in App Store Connector using the App Store Connect APIs.On App Store Connect,you can find the asset pack processing status under the TestFlight tab.Once the upload is successfully processed,the status will become Ready for Internal Testing.This means your new version is ready to be used in your app buildsthat are live for internal testing in TestFlight.You will receive an email informing that your new asset pack version is ready.You can also set up a webhook to get this notification.Feel free to check out the WWDC25 session“Automate your development process with the App Store Connect API”to find out more about the webhook features this year.However, during processing, if there is an issue discoveredwith your asset pack archive file,the version state will become Failed and you will be notified as well.You can fix the issue accordingly, and upload the asset pack againas a new version.Using App Store Connect APIs,there are many resources you can make GET requests to,to see a list of all asset packs for your app,versions for each asset pack, and their respective states.You can follow the progress of your upload with the backgroundAssetVersions resource.When your asset pack is processed, an Internal Beta Releases resourcewill be created.It will show you that the asset pack versionis READY_FOR_TESTING.After you successfully upload both your app binary and asset pack,you can start beta testing in TestFlight.On App Store Connect,you can see that currently Tutorial version 1 is ready for internal testing.If you’d like to test your app build and asset pack versionwith a wider audience,you can separately submit them for external testing.To submit an asset pack, click on the specific versionand select Submit for External Testing.When the version is approved, it will see the state changeto Ready for External Testing and you will receive a notification.With App Store Connect APIs, you can also submit the asset pack versionusing the betaBackgroundAssetReviewSubmissions resource.You can follow the state of the review with the external beta releases resource.It will show you when the asset pack version is ready for external testing.After testing, when you’re ready to make your asset pack versionavailable on the App Store,you can submit it to App Review for App Store distribution.You can head to the distribution tab on App Store Connect and view asset packs.Now, you can submit one asset pack versionby itself or alongside other asset packs, an app version,and perhaps other review items together.If you submit an asset pack version and an app version together,the App Review team will use your selected asset pack versionto review your app.To add an asset pack for review, click on Select Asset Pack,choose the version, and add for review.When the submission is approved, you will see that the asset pack versionis Ready for Distribution.Using the App Store Connect API, you can also submit for reviewusing the reviewSubmissions resource.During the review, you can see the review stateson the App Store releases resource.When it reaches ready for distribution, that means the people using your appwill be able to download the new assets from the App Store.Wow, we covered quite a lot of topics today.We talked about asset packs, how to create one and use it in your app,and how to upload and submit for Apple hosting.We hope that you find this session helpful to get startedwith the new Managed Background Assets.Now it's your turn.Try using the packaging tool to create your first asset pack.Then, if your app still uses On-Demand Resources,evaluate how you can migrate to Background Assets.Take a look at the documentation and adopt the new Background Assets APIs in your app.Finally, we want your feedback.Please let us know what works for you and what doesn’tusing Feedback Assistant.You can also check out everything else that’s new this year in App Store Connectby watching the “What’s new in App Store Connect” session.Plus, learn more about existing Background Assets features,including some helpful tips for local testing,with the “What’s new  in Background Assets” session from WWDC23.- Thanks for joining us. - And we look forward to your feedback.

Hello, I'm Gabriel.I’m a software engineer on the App Store team.And my name is Jenny.I’m an engineer on the App Processing team.Today, we’re introducing a new way to distribute assets foryour app on the App Store with Background Assets.I’ll cover how your app and assets work together on people’s devices.And I will share how you can use Apple hosting for your assets.

In this session,we will first review the current available asset delivery technologies,including Background Assets.Then dive into what’s new this year,including new Swift and Objective-C APIs to manage your Background Assets,as well as Apple hosting.

We will show you how to integrate the new features into your app for iOS,iPadOS, macOS, tvOS, and visionOS, and how to do local testing.

If you would like that Apple host and deliver your assets,we will walk you through how to prepare for beta testingand App Store distribution.

Now, let’s hear from Gabriel for a recap and what’s new in Background Assets.

Thanks, Jenny.When people download an app from the App Store,they expect to use it immediately.They may leave or even delete your app if they must wait for other downloadsto finish after opening it.

With Background Assets, we’re making it even easierto deliver a great first launch experience.You can configure how the system downloads your assets on devicesand update them without needing to update your main app.For example, you could deliver a tutorial levelonly to people who newly download a game to get them playing quicklywhile the rest of the game is downloaded in the background,offer optional downloadable content, also known as DLC,that you unlock with In-App Purchase,or update on device machine learning modelswith an accelerated submission process to the App Store.Suppose that you’re developing a game with several different levels,including a tutorial.You have four options for delivering the assets for each level:Keeping everything in your main app bundle,URLSession,On-Demand Resources,or Background Assets.There are pros and cons to some of them, so let me go through it.

Keeping everything in your main app bundleforces people to wait for all of the assets to download,even if you only need some of them to start the tutorial level.You could also hit the 4GB size limit on most platforms,and updating just one of your assets would require re-uploadingand resubmitting your entire app.On-Demand Resources would let people jump into the tutorial more quickly,because it lets you download some parts of your app bundle separatelyfrom TestFlight or the App Store,but you would still need to update your entire appjust to update a few asset files.On-Demand Resources is a legacy technology,and it will be deprecated.

Its successor is Background Assets,with which you host your app’s assets on your own server.You can update those assets at any time without updating your whole app.At the core of Background Assets is the downloader extension,which lets you write code to schedule asset downloadsbefore people open your app.This is great when you need full controlover download behavior and post-processing.For many of you, though,we know that what matters most is that your app’s assets simplybe available and up to date.With the new Managed Background Assets features,the system automatically manages downloads,updates, compression, and more for your asset packs.

In fact, we’ve written a system-provided download or extensionthat you can drop into your app with no custom code needed.

Plus, with the new Apple-Hosted Background Assets servicefor apps on TestFlight and the App Store,you no longer need to host your assetson your own server with the Apple hosting option.You get 200GB of Apple hosting capacityincluded in your Apple Developer Program membership.

If you’re still using On-Demand Resources,then we suggest that you start your migration to Background Assets.

With Managed Background Assets, you create multiple asset packsthat each group together some of your asset files,such as the textures, sound effects, and GPU shaders for a tutorial levelin a game.The system automatically downloads an asset pack on people’s devicesbased on its download policy.There are three download policies:Essential, Prefetch, and On-demand.

An essential download policy means that the system automaticallydownloads the asset pack and integrates the downloadinto the installation process.The asset pack contributes to the overall download progressthat people see in the App Store, in TestFlight, and on the home screen.And once the installation finishes and a person opens your app,the asset pack is ready to use.

A prefetch download policymeans that the system starts downloading the asset packduring the installation of the app,but the download could continue in the backgroundafter the app’s installation finishes.An on-demand download policymeans that the system downloads the asset pack only whenyou explicitly call an API method to request it.

You can either host your asset packs yourselfor let Apple host them for you.Now, I’ll hand it over to Jennyto cover how Apple servers deliver asset packs and app builds.Sure thing!Each Apple hosted asset packcan be used on one app, across multiple platforms of your choice.

For the device to download the app binary and any asset pack it uses,you will first need to separately upload both to App Store Connect.You can then submit them for reviewfor external testing in TestFlight and App Store distribution.

Once uploaded, the asset pack is assigned a version,and it is not tied to any specific app build.How the app and asset pack match upon the device is determined by the state of the asset pack version.Let me explain with some examples.

Let’s say you have three different versionsfor the same asset pack.Version 1 is live on the App Store,Version 2 is live for external beta on TestFlight,and Version 3 is live for internal beta on TestFlight.Only one version of the asset pack can be live for each context.

At the same time, you have some app buildson devices that are downloaded from the App Store,or through TestFlight external beta or internal beta.

The server will select to deliver the live version of your asset packfor all your app builds in that particular context.

That means app version 1.0 build 1that is downloaded from the App Store will use asset pack version 1.

App version 2.0 build 1 that is availablefor external beta in TestFlight will use asset pack version 2.And app version 2.0 builds 2 and 3 in internal betawill use asset pack version 3.

Now, it is important to understand the behavior when you make updatesto the Asset Pack version.

For example, if you’re happy with asset pack version 2,you can submit it for App Store distribution.It will replace the old version to be live on the App Store.

This means all versions of your app downloadedfrom the App Store will automaticallybe switched over to using asset pack version 2,including older versions that are still installed on people's devices.So, before you update the asset pack, make sure thatit will work on older app builds and versions as well.Now, let’s look at an example for app build update.Let’s say you want to submit app version 2.0 build 3for external beta testing.After approval, if the build is downloaded through external beta,it will use the older asset pack version 2.If you would like it to be paired with the newer asset pack version 3,make sure to submit the asset pack version as well.Now that you’re familiar with the concept of asset packs,Gabriel will walk you through how to create themand use them in your app.Thanks, Jenny.Now, let me show you how to use Managed Background Assets in your app.

To get started with Managed Background Assets,you’ll create asset packs, adopt the new APIs,and test your app and asset packs locally.

Let me explain how to create an asset pack.

You can use the new packaging tool for macOS, Linux, and Windowsthat takes files from your source repositoryand packages them into a compressed archivefor delivery to TestFlight and the App Store.The packaging tool ships with Xcode on macOS and will soon be availableto download from the download section of the Apple developer websitefor Linux and Windows.Let me show you the tool in action.

You can start by running the template commandto generate a manifest template.On macOS, install Xcode and run xcrun ba-package template in Terminal.On Linux or Windows, make the tool available in your shell’s search pathand run ba-package template.

The packaging tool will generate a manifest template.The manifest is a JSON file that you fill outto tell Apple about your asset pack.You can choose a custom ID.This is what you’ll use to identify the asset pack in your app’s code,a download policy,and the set of platforms that the asset pack supports.

Firstly, let's fill in the file selectors.A file selector selects a set of files in your source repositoryto include in your asset pack.There are two types of file selectors:ones that select individual files, and ones that select entire directories.

Let’s add a file selector for the game’s introductory cutscene video,using a relative path from the root of the source repository.

This asset pack’s ID is Tutorial because  it contains the asset filesfor the game’s Tutorial level.Now, let's configure the download policy.Since the tutorial is the first thing that people experience,let’s make the tutorial asset pack available locallybefore someone can open the game for the first time.So, this is a great situation in which to use an essential download policy.

This tutorial level is relevant only for people who newly install the game.People who already play the game and are simply updating to a new versionshouldn’t need to download the tutorial again.

So let’s restrict the essential download policyto just the first installation and exclude subsequent updates.This means that only someone who downloads the gameon their device for the first time will get the tutorial’s assets.

Now that the manifest is filled out, let’s run the packaging tool againto generate a compressed archive.We’ll set the current directory to the root of the repository and pass in the path tothe manifest and the path at which to save the archive.Now that the asset pack is packaged, let’s see how we can use it in the game.

With just a few lines of code, you can use the new APIsin Background Assets to read the files in your asset packs.We’ll start by adding a downloader extension in Xcode.The downloader extension is how your app schedules asset packs to be downloadedwhen the main app isn’t running, such as during the installation process.

Let’s add a new target and select the Background Download template.

Here you can choose whether you want to use Apple hosting or your own.

The template generates Swift code, but you can easily replace itwith Objective-C code if you prefer.

Newly this year, the system now provides a fully-featured downloader extensionthat supports automatic downloads, background updates,and more,which you can drop into your app with no custom code.The snippet that Xcode generates with the Background Download templateis already configured to use the system implementation by default.There's no other extension code to write.

In fact, you can even remove the stub shouldDownload(_:) method entirelyif you don’t need to customize the download behavior.This means that you can now add a downloader extension to your appwith just a few lines Xcode generated code.

If you do want to customize the download behavior,then you can provide a custom implementation for shouldDownload(_:).The system calls your shouldDownload(_:) implementationfor every new asset pack that, based on the asset pack’s download policy,it plans to download in the background, and you can returna Boolean value to decide whether to proceed with the download.This can be useful if some of your asset packshave specific compatibility requirements.Now that you’ve implemented the downloader extension,let’s see how to use files inside downloaded asset packs in your main app.

The first step is to call the ensureLocalAvailability(of:)method on the shared AssetPackManager.This method checks whether the asset pack is currently downloaded.If it isn’t, then it starts downloading it and waits for the download to finish.

In most cases,the downloader extension will have already downloaded the asset pack,so the method will return quickly.In the rare situation in which the asset pack must be newly downloaded,it’s a good idea to provide visible progress informationto people using your app.

In Swift, you can await status updates on the asynchronous sequencethat the statusUpdates(forAssetPackWithID:) method returns.

In Objective-C, you can create an object that conformsto the BAManagedAssetPackDownloadDelegate protocoland attach it to the shared asset pack manager’s delegate property.

If you need to cancel a download, then you can do so by calling cancel()on any of the progress structures that you receivein the download status updates.Once ensureLocalAvailability(of:) returns without throwing in error,the requested asset pack is ready to use locally.

To read a file from it,call the contents(at:searchingInAssetPackWithID:options:)method on the shared asset pack manager.The first parameter is a relative path from the root of your source repository,that is, the directory from which you previouslyran the packaging tool to create the asset pack,to the file that you want to read.The system automatically merges all of your asset packs into a shared namespace,effectively reconstructing your source repositoryas if it were copy-pasted from your development machineinto people’s devices.This means that you don’t need to worry about keeping trackof which asset pack contains a particular filewhen you want to read that file at runtime.By default, contents(at:searchingInAssetPackWithID:options:)returns a memory mapped data instance,which is suitable even for large asset filesthat take up a lot of space in memory.

If you need low-level access to the file descriptor,such as for reading a file into memory procedurally,then you can use the descriptor(for:searchingInAssetPackWithID:)method instead,in which case it’s your responsibility to close the descriptorwhen you’re done using it.You can also restrict the search to a particular asset packby providing a non-nil argumentfor the assetPackID parameter of either method.

The system tracks which asset packs your apphas downloaded and automaticallykeeps them up to date in the background.It won’t, however, automatically remove your asset packswhile your app remains installed,so it’s a good practice to call the remove(assetPackWithID:) methodon the shared asset pack manager to free up storage spacewhen you don’t expect to use a particular asset pack anymore.For example, you could remove the Tutorial asset packwhen someone finishes playing the tutorial level.

You can always call ensureLocalAvailability(of:)to re-download the asset pack again should, for example, someone reset their progressin the game and start playing the tutorial again.

Keep in mind that people can see the storage spacethat your downloaded asset packs take up listed for your appin the storage view in the Settings app on their device.

The next step is to add both your main appand your downloader extension to the same app group.The system uses the app group to facilitate coordinationbetween your main app and your extension.

Then add the BAAppGroupID keyto your main app’s Info.plist with your app group ID as string value.

Also, add the BAHasManagedAssetPacks key with true or yes as its Boolean value.

If you’re using Apple hosting, then add the BAUsesAppleHosting key with trueor yes as its Boolean value.If you’re not using Apple hosting,then refer to the related documentation in the Resources section for this sessionto learn more about the other required Info.plist keys,including BAManifestURL.Now that the app and the extension are configured,it's time to test.

We created a new Background Assets mock server for macOS,Linux, and Windows to test asset packdownloads before you submit your app to TestFlight or the App Store.Like the packaging tool, the mock server shipswith Xcode on macOS and will soon be availableto download from the Downloads section of the Apple Developer websitefor Linux and Windows.

Background Assets uses HTTPS for all downloads,so you first need to issue an SSL certificate.To do that, you’ll create a root certificate authority.Then you’ll install that certificate authorityon your test devices.After that, you'll use the certificate authority to issue an SSL certificate,and finally, you’ll start the mock server and point it to that SSL certificate.For more details, refer to the related documentationin the Resources section for this session.Once you’ve issued your SSL certificate, you can run ba-serveto start the mock server,pass in the respective paths to the Asset Pack archives that you want to serve,and set the host to which to bind.

The host can be an IP address, a host name, or a domain name.On macOS, the tool will prompt you to choose an identity,that is, a pair of a certificate and a private key from your keychain.On Linux or Windows, you’ll need to pass in the certificateand its private key on the command line.Pass the help flag to learn about additional options,including an option to set a custom port number,and coming soon on macOS, the ability to skip the identity prompt.On iOS, iPadOS and visionOS test devices, and coming soon on tvOS test devices,go to Development Overrides in Developer Settingsto enter your mock server’s base URL, including its host and port.On macOS test devices, run xcrun ba-serve url-overrideto enter the same information.

When you build and run your app from Xcode,it’ll download its asset packs from your mock server.Now, I’ll hand it back to Jennyto talk about beta testing and distributing your asset packs.- Jenny? - Thanks Gabriel.Now that you have the new app binary and asset packs ready,let me take you through how to prepare themfor beta testing on TestFlight and distribution on the App Store.

If you’re using Apple hosting, you will upload both your app binaryand asset packs to App Store Connect separately,optionally test with TestFlight, and finally distribute on the App Store.

Let’s take a deeper look at how this process works for asset packs.There are several ways to upload an asset pack.

For a drag and drop UI experience, you can use the Transporter app for macOS.

For full control and transparency, you can use the App Store Connect REST APIsto build your own automation.

For a simplified command line interface, the cross platform iTMSTransporterprovides useful commands and makes requests for youto the App Store Connect APIs.You can check out the documentation for all of these tools.Here, I will walk you through using Transporter and the App Store Connect API.With the Transporter app, simply drag and drop your Tutorial.aar archiveinto the Transporter window.

Add it to the app of your choice, then click Deliver.It will become a new version of the Tutorial asset pack.

You will be able to see the state of your asset pack upload rightin the Transporter app.

If you would like full visibility of the upload process,you can use the App Store Connect API.You will need to follow three steps:create asset pack record, create version record for the asset pack,then upload the archive to the asset pack version.

First, to create the asset pack record,you can make a POST request to the backgroundAssets resource.

In the request body, put in the name of the asset packas the assetPackIdentifier and add your app’s Apple IDin the relationships section.The response of this call will return a UUID to your asset pack,which you can use in later API calls.

Then you will create a new version for your asset packby making a POST request to the backgroundAssetVersions resource.

In the relationships section, use the ID of the asset pack providedto you by the previous API response.This operation automatically increases the version numberbased on existing versions.Here we will have version 1.You will also get an ID in the response to uniquely identify version 1of the Tutorial asset pack.

When the asset pack version is successfully created,you can use the backgroundAssetUploadFiles resourceto make an upload reservation for your Tutorial.aar archive file.This step is to other upload operations like App Store screenshots.

Here you would need the asset type, file name, file size, and MD5 checksum.

Also include the relationship to the background asset version ID.The response of this call includes an ID for your upload file,and details about the upload instructions.

When you successfully upload your archive,make a PATCH call to the backgroundAssetUploadFileswith your Upload File ID, and your asset pack will start processing.

To view the asset pack’s progress,you can always get the most comprehensive informationabout your available asset packs in App Store Connector using the App Store Connect APIs.

On App Store Connect,you can find the asset pack processing status under the TestFlight tab.Once the upload is successfully processed,the status will become Ready for Internal Testing.This means your new version is ready to be used in your app buildsthat are live for internal testing in TestFlight.You will receive an email informing that your new asset pack version is ready.You can also set up a webhook to get this notification.

Feel free to check out the WWDC25 session“Automate your development process with the App Store Connect API”to find out more about the webhook features this year.

However, during processing, if there is an issue discoveredwith your asset pack archive file,the version state will become Failed and you will be notified as well.You can fix the issue accordingly, and upload the asset pack againas a new version.

Using App Store Connect APIs,there are many resources you can make GET requests to,to see a list of all asset packs for your app,versions for each asset pack, and their respective states.You can follow the progress of your upload with the backgroundAssetVersions resource.

When your asset pack is processed, an Internal Beta Releases resourcewill be created.It will show you that the asset pack versionis READY_FOR_TESTING.

After you successfully upload both your app binary and asset pack,you can start beta testing in TestFlight.

On App Store Connect,you can see that currently Tutorial version 1 is ready for internal testing.If you’d like to test your app build and asset pack versionwith a wider audience,you can separately submit them for external testing.

To submit an asset pack, click on the specific versionand select Submit for External Testing.When the version is approved, it will see the state changeto Ready for External Testing and you will receive a notification.

With App Store Connect APIs, you can also submit the asset pack versionusing the betaBackgroundAssetReviewSubmissions resource.

You can follow the state of the review with the external beta releases resource.It will show you when the asset pack version is ready for external testing.

After testing, when you’re ready to make your asset pack versionavailable on the App Store,you can submit it to App Review for App Store distribution.

You can head to the distribution tab on App Store Connect and view asset packs.Now, you can submit one asset pack versionby itself or alongside other asset packs, an app version,and perhaps other review items together.If you submit an asset pack version and an app version together,the App Review team will use your selected asset pack versionto review your app.

To add an asset pack for review, click on Select Asset Pack,choose the version, and add for review.

When the submission is approved, you will see that the asset pack versionis Ready for Distribution.

Using the App Store Connect API, you can also submit for reviewusing the reviewSubmissions resource.

During the review, you can see the review stateson the App Store releases resource.When it reaches ready for distribution, that means the people using your appwill be able to download the new assets from the App Store.

Wow, we covered quite a lot of topics today.We talked about asset packs, how to create one and use it in your app,and how to upload and submit for Apple hosting.

We hope that you find this session helpful to get startedwith the new Managed Background Assets.

Now it's your turn.Try using the packaging tool to create your first asset pack.Then, if your app still uses On-Demand Resources,evaluate how you can migrate to Background Assets.Take a look at the documentation and adopt the new Background Assets APIs in your app.Finally, we want your feedback.Please let us know what works for you and what doesn’tusing Feedback Assistant.

You can also check out everything else that’s new this year in App Store Connectby watching the “What’s new in App Store Connect” session.Plus, learn more about existing Background Assets features,including some helpful tips for local testing,with the “What’s new  in Background Assets” session from WWDC23.

- Thanks for joining us. - And we look forward to your feedback.

8:26 -Fill out the manifest

10:44 -Add a downloader extension

11:39 -Download an asset pack

12:22 -Receive download status updates in Objective-C

12:29 -Attach the delegate in Objective-C

12:33 -Cancel an asset-pack download

12:41 -Use an asset pack

13:56 -Remove an asset pack

14:53 -Info.plist

0:00 -IntroductionLearn about Background Assets — a new way to distribute app assets on the App Store. Review current asset-delivery technologies, see new Swift and Objective-C APIs, and learn how to integrate these features across iOS, iPadOS, macOS, tvOS, and visionOS. Apple hosting of assets, including preparation for beta testing and App Store distribution is also discussed.1:01 -New in Background AssetsBackground Assets enhances the app launch experience by allowing you to download and update app assets separately from the main app. This approach enables people to start using the app immediately, with additional content downloading in the background.

There are three main download policies for asset packs: Essential, Prefetch, and On-Demand. You can host your asset packs on your own servers or utilize the new Apple Hosted Background Assets service, which provides 200GB included in your Apple Developer Program membership.

Managed Background Assets replaces the deprecated On-Demand Resources technology. It offers greater control and flexibility, so you can optimize app performance and user engagement. The system automatically manages downloads, updates, and compression, making it easy to implement.7:32 -Sample app developmentTo use Managed Background Assets in an app, you must create asset packs using a new packaging tool available for macOS, Linux, and Windows. This tool generates a JSON manifest file where you specify the asset pack's ID, download policy, supported platforms, and the files to be included by using file selectors.

You can configure the download policy to ensure essential assets are available locally before app launch and restrict downloads to first installations. Once the manifest is filled out, the packaging tool generates a compressed archive.

To integrate the asset pack into the app, add a downloader extension in Xcode, which schedules asset packs to be downloaded in the background. The system provides a fully-featured downloader extension that supports automatic downloads and updates.

Access the downloaded files in the main app using the 'AssetPackManager', ensuring local availability and awaiting status updates if necessary, providing a seamless user experience with optimized asset management. To use the Background Assets framework, the delegate protocol must be attached to the shared asset pack manager's delegate property. 

Download status updates provide progress structures that can be used to cancel downloads if necessary. Once an asset pack is ready for local use, indicated by 'ensureLocalAvailability(of:)' returning without error, files can be read using 'contents(at:searchingInAssetPackWithID:options:)' or 'descriptor(for:searchingInAssetPackWithID:)' methods.

The system automatically manages asset pack updates and storage, but it is recommended to manually remove unused asset packs to free up space.

To enable coordination between the main app and downloader extension, you must add them to the same app group, and configure specific Info.plist keys.

For testing, a mock server is provided, which requires an SSL certificate. You must enter the mock server's base URL in Development Overrides on test devices. Once configured, the app downloads asset packs from the mock server during testing.17:24 -Beta testing and distributionTo prepare an app for beta testing on TestFlight and distribution on the App Store, you must upload the app binary and asset packs to App Store Connect. 

Upload asset packs using various methods, including the Transporter app for macOS, which provides a drag-and-drop interface, or the App Store Connect REST APIs for full control and automation.

Using the APIs involves three main steps: creating an asset pack record, creating a version record, and uploading the archive. Once the asset pack is processed, you can submit for internal or external testing in TestFlight.

After successful testing, you can submit the asset pack version to App Review for distribution on the App Store. Monitor the progress and status of uploads, submissions, and reviews through App Store Connect or the APIs.

0:00 -Introduction

Learn about Background Assets — a new way to distribute app assets on the App Store. Review current asset-delivery technologies, see new Swift and Objective-C APIs, and learn how to integrate these features across iOS, iPadOS, macOS, tvOS, and visionOS. Apple hosting of assets, including preparation for beta testing and App Store distribution is also discussed.

Learn about Background Assets — a new way to distribute app assets on the App Store. Review current asset-delivery technologies, see new Swift and Objective-C APIs, and learn how to integrate these features across iOS, iPadOS, macOS, tvOS, and visionOS. Apple hosting of assets, including preparation for beta testing and App Store distribution is also discussed.

1:01 -New in Background Assets

Background Assets enhances the app launch experience by allowing you to download and update app assets separately from the main app. This approach enables people to start using the app immediately, with additional content downloading in the background.

There are three main download policies for asset packs: Essential, Prefetch, and On-Demand. You can host your asset packs on your own servers or utilize the new Apple Hosted Background Assets service, which provides 200GB included in your Apple Developer Program membership.

Managed Background Assets replaces the deprecated On-Demand Resources technology. It offers greater control and flexibility, so you can optimize app performance and user engagement. The system automatically manages downloads, updates, and compression, making it easy to implement.

Background Assets enhances the app launch experience by allowing you to download and update app assets separately from the main app. This approach enables people to start using the app immediately, with additional content downloading in the background.

There are three main download policies for asset packs: Essential, Prefetch, and On-Demand. You can host your asset packs on your own servers or utilize the new Apple Hosted Background Assets service, which provides 200GB included in your Apple Developer Program membership.

Managed Background Assets replaces the deprecated On-Demand Resources technology. It offers greater control and flexibility, so you can optimize app performance and user engagement. The system automatically manages downloads, updates, and compression, making it easy to implement.

7:32 -Sample app development

To use Managed Background Assets in an app, you must create asset packs using a new packaging tool available for macOS, Linux, and Windows. This tool generates a JSON manifest file where you specify the asset pack's ID, download policy, supported platforms, and the files to be included by using file selectors.

You can configure the download policy to ensure essential assets are available locally before app launch and restrict downloads to first installations. Once the manifest is filled out, the packaging tool generates a compressed archive.

To integrate the asset pack into the app, add a downloader extension in Xcode, which schedules asset packs to be downloaded in the background. The system provides a fully-featured downloader extension that supports automatic downloads and updates.

Access the downloaded files in the main app using the 'AssetPackManager', ensuring local availability and awaiting status updates if necessary, providing a seamless user experience with optimized asset management. To use the Background Assets framework, the delegate protocol must be attached to the shared asset pack manager's delegate property. 

Download status updates provide progress structures that can be used to cancel downloads if necessary. Once an asset pack is ready for local use, indicated by 'ensureLocalAvailability(of:)' returning without error, files can be read using 'contents(at:searchingInAssetPackWithID:options:)' or 'descriptor(for:searchingInAssetPackWithID:)' methods.

The system automatically manages asset pack updates and storage, but it is recommended to manually remove unused asset packs to free up space.

To enable coordination between the main app and downloader extension, you must add them to the same app group, and configure specific Info.plist keys.

For testing, a mock server is provided, which requires an SSL certificate. You must enter the mock server's base URL in Development Overrides on test devices. Once configured, the app downloads asset packs from the mock server during testing.

To use Managed Background Assets in an app, you must create asset packs using a new packaging tool available for macOS, Linux, and Windows. This tool generates a JSON manifest file where you specify the asset pack's ID, download policy, supported platforms, and the files to be included by using file selectors.

You can configure the download policy to ensure essential assets are available locally before app launch and restrict downloads to first installations. Once the manifest is filled out, the packaging tool generates a compressed archive.

To integrate the asset pack into the app, add a downloader extension in Xcode, which schedules asset packs to be downloaded in the background. The system provides a fully-featured downloader extension that supports automatic downloads and updates.

Access the downloaded files in the main app using the 'AssetPackManager', ensuring local availability and awaiting status updates if necessary, providing a seamless user experience with optimized asset management. To use the Background Assets framework, the delegate protocol must be attached to the shared asset pack manager's delegate property. 

Download status updates provide progress structures that can be used to cancel downloads if necessary. Once an asset pack is ready for local use, indicated by 'ensureLocalAvailability(of:)' returning without error, files can be read using 'contents(at:searchingInAssetPackWithID:options:)' or 'descriptor(for:searchingInAssetPackWithID:)' methods.

The system automatically manages asset pack updates and storage, but it is recommended to manually remove unused asset packs to free up space.

To enable coordination between the main app and downloader extension, you must add them to the same app group, and configure specific Info.plist keys.

For testing, a mock server is provided, which requires an SSL certificate. You must enter the mock server's base URL in Development Overrides on test devices. Once configured, the app downloads asset packs from the mock server during testing.

17:24 -Beta testing and distribution

To prepare an app for beta testing on TestFlight and distribution on the App Store, you must upload the app binary and asset packs to App Store Connect. 

Upload asset packs using various methods, including the Transporter app for macOS, which provides a drag-and-drop interface, or the App Store Connect REST APIs for full control and automation.

Using the APIs involves three main steps: creating an asset pack record, creating a version record, and uploading the archive. Once the asset pack is processed, you can submit for internal or external testing in TestFlight.

After successful testing, you can submit the asset pack version to App Review for distribution on the App Store. Monitor the progress and status of uploads, submissions, and reviews through App Store Connect or the APIs.

To prepare an app for beta testing on TestFlight and distribution on the App Store, you must upload the app binary and asset packs to App Store Connect. 

Upload asset packs using various methods, including the Transporter app for macOS, which provides a drag-and-drop interface, or the App Store Connect REST APIs for full control and automation.

Using the APIs involves three main steps: creating an asset pack record, creating a version record, and uploading the archive. Once the asset pack is processed, you can submit for internal or external testing in TestFlight.

After successful testing, you can submit the asset pack version to App Review for distribution on the App Store. Monitor the progress and status of uploads, submissions, and reviews through App Store Connect or the APIs.

## Code Samples

```swift
{

	
"assetPackID"
:
 
"[Asset-Pack ID]"
,

	
"downloadPolicy"
:
 
{

		
"essential"
:
 
{
 
// Possible keys: “essential”, “prefetch”, or “onDemand”

			
// Essential and prefetch download policies require a list of installation event types. For an on-demand download policy, the value for the “onDemand” key must be an empty object.

			
"installationEventTypes"
:
 
[

				
// Remove undesired elements from this array.

				
"firstInstallation"
,

				
"subsequentUpdate"

			
]

		
}

	
}
,

	
"fileSelectors"
:
 
[

		
// You can add as many file and/or directory selectors as you want.

		
{

			
"file"
:
 
"[Path to File]"

		
}
,

		
{

			
"directory"
:
 
"[Path to Directory]"

		
}

	
]
,

	
"platforms"
:
 
[

		
// Remove undesired elements from this array.

		
"iOS"
,

		
"macOS"
,

		
"tvOS"
,

		
"visionOS"

	
]


}
```

```swift
import
 BackgroundAssets

import
 ExtensionFoundation

import
 StoreKit


@main


struct
 
DownloaderExtension
: 
StoreDownloaderExtension
 {
	
	
func
 
shouldDownload
(
_
 
assetPack
: 
AssetPack
) -> 
Bool
 {
		
return
 
true

	}
	
}
```

```swift
let
 assetPack 
=
 
try
 
await
 
AssetPackManager
.shared.assetPack(withID: 
"Tutorial"
)


// Await status updates for progress information


let
 statusUpdates 
=
 
AssetPackManager
.shared.statusUpdates(forAssetPackWithID: 
"Tutorial"
)

Task
 {
	
for
 
await
 statusUpdate 
in
 statusUpdates {
		
// …

  }
}


// Download the asset pack


try
 
await
 
AssetPackManager
.shared.ensureLocalAvailability(of: assetPack)
```

```swift
#import 
<BackgroundAssets/BackgroundAssets.h>



@interface
 
ManagedAssetPackDownloadDelegate
 : 
NSObject
 <
BAManagedAssetPackDownloadDelegate
>



@end



@implementation
 
ManagedAssetPackDownloadDelegate


- (
void
)downloadOfAssetPackBegan:(BAAssetPack *)assetPack { 
/* … */
 }

- (
void
)downloadOfAssetPackPaused:(BAAssetPack *)assetPack { 
/* … */
 }

- (
void
)downloadOfAssetPackFinished:(BAAssetPack *)assetPack { 
/* … */
 }

- (
void
)downloadOfAssetPack:(BAAssetPack *)assetPack hasProgress:(
NSProgress
 *)progress { 
/* … */
 }

- (
void
)downloadOfAssetPack:(BAAssetPack *)assetPack failedWithError:(
NSError
 *)error { 
/* … */
 }


@end
```

```swift
static
 
void
 attachDelegate(ManagedAssetPackDownloadDelegate *delegate) {
	[[BAAssetPackManager sharedManager] setDelegate:delegate];
}
```

```swift
let
 statusUpdates 
=
 
AssetPackManager
.shared.statusUpdates(forAssetPackWithID: 
"Tutorial"
)

for
 
await
 statusUpdate 
in
 statusUpdates {
	
if
 
case
 .downloading(
_
, 
let
 progress) 
=
 statusUpdate {
		progress.cancel()
	}
}
```

```swift
// Read a file into memory


let
 videoData 
=
 
try
 
AssetPackManager
.shared.contents(at: 
"Videos/Introduction.m4v"
)


// Open a file descriptor


let
 videoDescriptor 
=
 
try
 
AssetPackManager
.shared.descriptor(for: 
"Videos/Introduction.m4v"
)

defer
 {
	
do
 {
		
try
 videoDescriptor.close()
	} 
catch
 {
		
// …

	}
}
```

```swift
// Remove the asset pack


try
 
await
 
AssetPackManager
.shared.remove(assetPackWithID: 
"Tutorial"
)


// Redownload the asset pack


let
 assetPack 
=
 
try
 
await
 
AssetPackManager
.shared.assetPack(withID: 
"Tutorial"
)

try
 
await
 
AssetPackManager
.shared.ensureLocalAvailability(of: assetPack)
```

```swift
<
key
>
BAAppGroupID
</
key
>


<
string
>
group.com.naturelab.thecoast
</
string
>


<
key
>
BAHasManagedAssetPacks
</
key
>


<
true
/>


<
key
>
BAUsesAppleHosting
</
key
>


<
true
/>
```


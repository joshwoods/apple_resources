# Wwdc2025 276

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Summary

Transcript

Code

What’s new in BNNS GraphThe BNNS Graph Builder API now enables developers to write graphs of operations using the familiar Swift language to generate pre- and post-processing routines and small machine-learning models. BNNS compiles graphs ahead of execution and supports real-time and latency-sensitive use cases such as audio processing. In this session, we revisit last year's bit-crusher example and simplify the Swift component by removing the reliance on a separate Python file and instead implement the audio effect entirely in Swift. The BNNS Graph Builder API is also suited to pre-processing image data before passing that data to a machine learning model. The session also includes a demonstration of clipping the transparent pixels from an image with an alpha channel.Chapters0:00 -Introduction3:12 -Recapping BNNSGraph6:15 -BNNSGraphBuilder16:58 -Using BNNSGraphBuilderResourcesBNNSSupporting real-time ML inference on the CPUvImage.PixelBufferHD VideoSD VideoRelated VideosWWDC25Discover machine learning & AI frameworks on Apple platformsWWDC24Support real-time ML inference on the CPU

The BNNS Graph Builder API now enables developers to write graphs of operations using the familiar Swift language to generate pre- and post-processing routines and small machine-learning models. BNNS compiles graphs ahead of execution and supports real-time and latency-sensitive use cases such as audio processing. In this session, we revisit last year's bit-crusher example and simplify the Swift component by removing the reliance on a separate Python file and instead implement the audio effect entirely in Swift. The BNNS Graph Builder API is also suited to pre-processing image data before passing that data to a machine learning model. The session also includes a demonstration of clipping the transparent pixels from an image with an alpha channel.

0:00 -Introduction

3:12 -Recapping BNNSGraph

6:15 -BNNSGraphBuilder

16:58 -Using BNNSGraphBuilder

BNNS

Supporting real-time ML inference on the CPU

vImage.PixelBuffer

HD VideoSD Video

HD Video

SD Video

Discover machine learning & AI frameworks on Apple platforms

Support real-time ML inference on the CPU

Search this video…Hi, my name is Simon Gladman,and I work for the Vector and Numerics Group here at Apple.Our group provides a suite of libraries for high-performance,energy-efficient computation on the CPU.These libraries support, among other things,image and signal processing, linear algebra,and what I’ll be talking about today, machine learning.Basic Neural Network Subroutines, or BNNS, is our machine learning library.It allows you to add CPU-based inference to your app,and is perfectly suited to real-time and low-latency use cases,such as audio processing.You might use it to implement functionalities such as:separating audio to isolate or remove vocals,segmenting audio into different regions based on content,or applying timbre transfer to make one instrument sound like another.But BNNS is also perfectly suited to working with other data,such as images.So if your app requires high performance inference, BNNS is for you.Last year we introduced BNNSGraph, an exciting new API that made BNNSfaster, more energy efficient and far far easier to work with.And if you recall we demonstrated BNNSGraphby creating this Bitcrusher audio unitthat shows just how easy it is to add your own effectsto Logic Pro and Garage Band.This year, we’re giving BNNSGraph an even better programming interfacethat allows you to leverage the power of Swift to create small modelsfor inference and graphs of operations for pre- and post-processing.Today, I’ll be talking about our new addition to BNNSGraph,BNNSGraphBuilder.I’ll start today’s session with a quick recap of BNNSGraph.What it is, how it can optimize machine learning and AI modelsand how you can adopt it.Then I’ll introduce BNNSGraphBuilder.I’ll summarize the super easy workflow you need to implement itand as part of this introduction, I’ll demonstrate how to write a simple graph.After introducing BNNSGraphBuilder, I run through three demonstrations.Firstly preprocessing an image using the Graph Builder.Then using the new API to postprocess data generated by an ML model.And finally I’ll update last year’s Bitcrusher demonstrationto build the graph of operations in Swift.And now, without further ado, let’s get started.We recommend BNNSGraph for audio and other latency-sensitive use casesbecause it gives you control over allocating memory and multithreading.Both of these may incur a context switch into kernel codeand lead to defeat of real-time deadlines.Before last year, you would build BNNS based networks usingdiscrete layers such as convolution, matrix multiplication or activation.If you wanted to use BNNS to implement an existing model,you’d have to code each layer as a BNNS primitiveand write the code for all of the intermediate tensors.BNNSGraph takes an entire graph that consists of multiple layersand the data flow between those layers, and consumes it as a single graph object.For you, this means you don’t have to writethe code for each individual layer.Furthermore, you and your users will benefitfrom faster performance and better energy efficiency.Because BNNSGraph is aware of the entire model,it is able to perform a number of optimizationsthat were not possible before.These optimizations reduce execution time, memory usage and energy cost.And even better, they come for free.Let’s use this small section of a model to explore some of these optimizations.One of the optimizations is a mathematical transformation.For example, reordering a slice operation so that BNNS only needsto compute the subset of elements in that slice.Another optimization is layer fusion.For example, fusing a convolution layerand an activation layer into a single operation.And copy elision avoids copying the data in a sliceby referencing that subset of data instead.And by ensuring tensors share memory where possible, BNNSGraph optimizes memory usageand eliminates unnecessary allocations.Finally, BNNSGraph’s weight repacking optimizations canrepack weights to provide better cache locality.You don’t need to write any code to benefit from these optimizations.They happen just like that.To create a graph using the file-based API that we introduced last year,you start off with a CoreML Package.Xcode automatically compiles the package to an mlmodelc fileand then you write the code that builds a graph from the mlmodelc file.The last step is to create a context to wrap the graphand it’s that context that performs inference.This approach is still the best way to integrate existing PyTorch modelsinto your project.However, for small models or graphs of operations,you might benefit from a more immediate workflow.What if you could define the individual elements of your graph in Swift?Well, this year we’re introducing a new API that does just thatBNNSGraphBuilder.The new BNNSGraphBuilder API enables you to write graphsof operations using the familiar Swift language.You can write pre- and post-processing routinesor small machine learning models directly in Swift.You create a context from that Swift code with a single function calland no intermediate steps.Writing your graphs in Swift and inline with your other codebrings some immediate benefits.You use a familiar language and your graph is type-checkedwhen your Swift project is compiled.You can also share values between Swift and your graphthat are known at runtime but before you generate the graph.For example, if you know a tensor’s shape at runtimebefore you initialise the graph,you can pass the shape directly into the graph code,and benefit from the better performance of static sizes over flexible sizes.BNNSGraphBuilder also allows you to query intermediate tensorsfor properties such as shape and data type, and this helps you to debug graphs.And type tensors allows Xcode to autocompleteand reduces the chance of runtime errors.Let’s look at the new syntax, type checking, new methods and operators,and how to query intermediate tensors,all features that were not previously available.This year we’ve added a new type method to the BNNSGraph object,named makeContext.It is this new method that converts your Swift code to a reusable contextthat you use to execute your graph.You only make the context once, typically while your app is starting up.Then your app executes the context when required,and it benefits from the optimizations that treatingthe graph holistically brings.Now for some live coding to see makeContext in action.This method accepts a closure, and it’s that closure that you useto define the series of operations that constitute your graph.Your graph will typically accept one or more arguments.Here, I’ll use the closure’s builder parameter to specify the two arguments,x and y.The parameters are both eight element vectors of float values.In this example the graph performs an element-wise multiplicationon the two input arguments,and writes the result to the output argument that I have named product.My graph also calculates the mean value of the productand writes that value to a second output argument I have named mean,and finally, the code returns those two output arguments.To aid debugging, we can print out details of the intermediateand output tensors that BNNSGraphBuilder generates.In this example,I’ve printed the shape of the mean to ensure it’s got a shape of one,that is, it only contains one element.Once the context is created,you can query it to derive the arguments and their positions.Here, the code queries the context’s argument namesand creates an array of tensorsthat represent the graph’s outputs and inputs.BNNSGraph orders argument namesso that the outputs are first and the inputs follow.The BNNSGraphBuilder API provides a rich set of functionsfor initializing arguments from different data sources,and either copying or referencing data.In this example, the code initializes the inputs from Swift arrays.With the input and output arguments allocated,calling execute function executes the graphand populates the two outputs with the results.And we can print out the results by running the function.We’re not limited to just multiplying and calculating averages though.Let’s take a quick tour around BNNSGraphBuilderand explore some of the other operations that the new API provides.Here’s just a tiny selection of the primitives includedin BNNSGraphBuilder.For example, matrix multiplication and convolution, reduction operations,gather and scatter operations,and operations such as padding, reshape and transpose.Our new API supports many operations as simple, Swift operators.So we have arithmetic operators, multiplication,addition, subtraction and division.We also have element-wise comparison operators including equality,less than, and greater than.And to complete the set, we have element-wise logical operators.OK, that’s a quick introduction to the API itself.Let’s take a deep dive into two features of the GraphBuilder APIthat will be very familiar Swift developers, starting with strong typing.Strong typing helps you catch errors at compile timethat otherwise may happen at runtime.The BNNSGraphBuilder API ensures that the data type for tensorsis correct for a given operation.Let's look at this in action.In this example, the graph returns the element-wise resultsof floating-point base values raised to the power of integer exponents.It’s able to perform this calculation by casting the integer exponents to FP16.Attempting to perform this without the cast would preventthe make context method from compiling.The graph also masks the result by zeroing out elements where the valuesin mask 0 are less than the corresponding values in mask 1.Because the tensor elements that the comparison generates are Boolean,the graph performs another cast in order to multiply the results by the condition.Once again, without the cast operation, the make context method wouldn’t compile.And it’s always best to catch this type of error at compile timeand before your app is in the hands of your users.That's strong typing in action.Let’s now take a look at BNNSGraphBuilder’s approach to slicing,that is selecting parts with tensor.And this too will be very familiar to Swift developers.A slice is effectively a window onto a specific part of a tensor.For example, a slice may be a single column or row of a matrix.The great thing about BNNSGraph is that it treats slicesas references to existing data,without the overhead of copying that data or allocating more memory.Slicing tensors is a common operation.Our new GraphBuilder API allows you to specify slices of a tensoras the source or destination operations.For example, you might want to crop an image to a region of interest beforepassing it to a machine learning model.Let’s look at how easy it is to use the GraphBuilder APIto select a square region from the centre of this photographof a squirrel enjoying its lunch.We’ll define two vImage pixel buffers. Pixel buffers store in images pixel data,dimensions, bit depth and number of channels.The first buffer, source, contains a photograph of the squirrel.The second pixel buffer, Destination, will contain the square crop.Each pixel buffer is three channels, red, green and blue,and each channel is 32-bit floating point format.You can learn more about vImage pixel buffers in our vImage documentation.The horizontal and vertical margins ensure that the 640 by 640 cropis centered on the source image.And here’s a graph that uses the slice operation to perform the crop.First, we’ll define the source as an argumentand specify the height and width as flexible sizes.Passing a negative value, minus 1 in this case, tells BNNSGraphthat those dimensions might be any value.The final value in the shape 3 specifies that the image contains three channels:red, green and blue.The BNNSGraphBuilder API uses Swift subscripts to perform a slice operation.In this example, the code uses the new SliceRange structure.The start indices for both the vertical and horizontal dimensionsare the corresponding margin values.Setting the end indices as the negative margin value indicates that the end indexis the end value of that dimension minus the margin.In this example we don’t want to crop along the channel dimension,and the code specifies fillAll to ensure that we include all three channels.This year we’re also introducing a new method for vImage pixel buffers.The withBNNSTensor method allows you to create a temporary BNNSTensor thatshares memory and properties such as size and channel count with the pixel buffer.As the code here demonstrates, the new method makes passing images toand from your graph super easy.And because memory is shared, there’s no copying or allocating, and that meansyou get great performance when working with images.After the execute function method returns, the destination pixel buffercontains a cropped image.And we can double check our squirrel is safely croppedby creating a core graphics image of the result.In addition to the new GraphBuilder slice range structure,the tensor slicing API supports all the Swift range types.So, whatever your slicing needs, we have you covered.And that is a brief overview of slicing.Now we’ve taken a look at BNNSGraphBuilder and some of its features,let's dive into some use cases.BNNSGraphBuilder is a great API to construct graphs of operationsfor pre- and post-processing data that you pass to or receive from ML models.One pre-processing technique is to threshold an image.That is to convert a continuous tone image to a binary imagethat contains just black or white pixels.Let’s take a look at how we can implement this using the GraphBuilder.Before we start writing the graph, we’ll again define some vImage pixel buffers.The first stores the source image, and the second is the destinationthat receives the thresholded image.Both of these pixel buffers are single channel, 16-bit floating point format.The first step in the graph is to define the source,which represents the input image.The code passes negative values for the image sizeto specify the graph supports any image size,but does however specify the FP16 data typethat matches the pixel buffers.Calculating the average value of the continuous grayscale pixelsis simply a matter of calling the mean method.The element wise is greater than operator populatesthe thresholded tensor with ones for corresponding pixelsof the value greater than the average pixel value, and zeros otherwise.And finally, the graph casts the Boolean ones and zerosto the bit-depth of the destination pixel buffer.We’ll use the withBNNSTensor method again to pass the two image buffersto the context and execute the function to generate the thresholded image.After passing this continuous-toned grayscale image of a pair of pelicansin flight to the graphWe get this thresholded image where all the pixels are either black or white.Another use case for the BNNSGraphBuilder APIis post-processing the results of a machine learning model.For example, let’s say we want to apply a softmax function followedby a topK operation to the results of an ML model.Here, the post-process function creates a small graph on the fly.The graph declares an input argument based on the function’s input tensor.It then applies a softmax operation to the input argument,and then calculates its topK values and indices.Note that the k parameter the code passes to the topK function is actually definedoutside of the make context closure.Lastly, the graph returns the topK results.After defining the graph, the function declares the tensors that storethe results, and passes the output and input tensors to the context.Finally, the makeArray method converts the topK values and indicesto Swift arrays and returns those.There we have some examples of pre- and post-processing datawith the GraphBuilder API.Now, let’s take a look at last year’s Bitcrusher demonstrationand update the Swift piece to use BNNSGraphBuilder.This code demonstrates how BNNSGraph makes adding ML-based audio effects super easy.Last year, we demonstrated BNNSGraph by incorporating itinto an Audio Unit extension app.This app added a real-time Bitcrusher effect to an audio signal,and the demonstration used Swift to apply the same effect to a sine waveto display a visual representation of the effect in the user interface.For example, given this sine wave, the graph is able to reduce the resolutionto add distortion to the sound, and the visual representation showsthe sine wave as a discrete series of steps rather than a continuous wave.We also included saturation gain to add a richness to the sound.Last year’s demonstration used a CoreML packagethat was based on PyTorch code.So, let’s take last year’s code and compare it againstthe same functionality written in Swift using the new GraphBuilder API.Here’s the PyTorch on the left and the new Swift code on the right.One immediate difference is that Swift uses let and varto define intermediate tensors,so you’re free to decide if these are immutable or mutable.You don’t need any extra imports to access the full rangeof available operations.Furthermore, operations such as, in this case tanh,are methods on tensors rather than free functions.Element-wise arithmetic operators are the samewith the two different approaches.Another difference though is that the make context closure can returnmore than one output tensor, so you always return an array.The Swift GraphBuilder allows you to define input arguments insidethe make context closure.If you have an existing PyTorch model, we still recommend usingthat code and the existing file-based API.But, for new projects, our new GraphBuilder API allows youto write graphs using Swift, and as this comparison demonstrates,with a similar structure to the same set of operations written using PyTorch.Furthermore, we can demonstrate BNNSGraph’s 16-bit support, and how,in this example, it is significantly faster than the FP32 operations.Here’s our Swift code again, but this time using a type aliasto specify the precision.Changing the type alias changes the graph to use FP16 rather than FP32.In this example, FP16 is much faster than the FP32 equivalent.To wrap up, BNNSGraphBuilder provides an easy to use Swift API that allows youto write high-performance and energy-efficient modelsand graphs-of-operations.It’s great for real-time and latency-sensitive use cases,but its user-friendly programming interfacemeans it can be used for a wide range of applications.Before I go, please allow me to suggest that you head overto our documentation page where you’ll find plentyof reference material that discusses BNNSGraph and BNNSGraphBuilder.Also, be sure to check out our video from last year, where I talkabout the file-based API and using BNNSGraph in C.Many thanks for your time today and best wishes.

Hi, my name is Simon Gladman,and I work for the Vector and Numerics Group here at Apple.Our group provides a suite of libraries for high-performance,energy-efficient computation on the CPU.These libraries support, among other things,image and signal processing, linear algebra,and what I’ll be talking about today, machine learning.

Basic Neural Network Subroutines, or BNNS, is our machine learning library.It allows you to add CPU-based inference to your app,and is perfectly suited to real-time and low-latency use cases,such as audio processing.You might use it to implement functionalities such as:separating audio to isolate or remove vocals,segmenting audio into different regions based on content,or applying timbre transfer to make one instrument sound like another.

But BNNS is also perfectly suited to working with other data,such as images.So if your app requires high performance inference, BNNS is for you.

Last year we introduced BNNSGraph, an exciting new API that made BNNSfaster, more energy efficient and far far easier to work with.And if you recall we demonstrated BNNSGraphby creating this Bitcrusher audio unitthat shows just how easy it is to add your own effectsto Logic Pro and Garage Band.

This year, we’re giving BNNSGraph an even better programming interfacethat allows you to leverage the power of Swift to create small modelsfor inference and graphs of operations for pre- and post-processing.Today, I’ll be talking about our new addition to BNNSGraph,BNNSGraphBuilder.I’ll start today’s session with a quick recap of BNNSGraph.What it is, how it can optimize machine learning and AI modelsand how you can adopt it.Then I’ll introduce BNNSGraphBuilder.I’ll summarize the super easy workflow you need to implement itand as part of this introduction, I’ll demonstrate how to write a simple graph.After introducing BNNSGraphBuilder, I run through three demonstrations.Firstly preprocessing an image using the Graph Builder.Then using the new API to postprocess data generated by an ML model.And finally I’ll update last year’s Bitcrusher demonstrationto build the graph of operations in Swift.And now, without further ado, let’s get started.We recommend BNNSGraph for audio and other latency-sensitive use casesbecause it gives you control over allocating memory and multithreading.Both of these may incur a context switch into kernel codeand lead to defeat of real-time deadlines.

Before last year, you would build BNNS based networks usingdiscrete layers such as convolution, matrix multiplication or activation.

If you wanted to use BNNS to implement an existing model,you’d have to code each layer as a BNNS primitiveand write the code for all of the intermediate tensors.BNNSGraph takes an entire graph that consists of multiple layersand the data flow between those layers, and consumes it as a single graph object.

For you, this means you don’t have to writethe code for each individual layer.Furthermore, you and your users will benefitfrom faster performance and better energy efficiency.

Because BNNSGraph is aware of the entire model,it is able to perform a number of optimizationsthat were not possible before.These optimizations reduce execution time, memory usage and energy cost.And even better, they come for free.Let’s use this small section of a model to explore some of these optimizations.One of the optimizations is a mathematical transformation.For example, reordering a slice operation so that BNNS only needsto compute the subset of elements in that slice.Another optimization is layer fusion.For example, fusing a convolution layerand an activation layer into a single operation.And copy elision avoids copying the data in a sliceby referencing that subset of data instead.And by ensuring tensors share memory where possible, BNNSGraph optimizes memory usageand eliminates unnecessary allocations.

Finally, BNNSGraph’s weight repacking optimizations canrepack weights to provide better cache locality.You don’t need to write any code to benefit from these optimizations.They happen just like that.To create a graph using the file-based API that we introduced last year,you start off with a CoreML Package.Xcode automatically compiles the package to an mlmodelc fileand then you write the code that builds a graph from the mlmodelc file.The last step is to create a context to wrap the graphand it’s that context that performs inference.This approach is still the best way to integrate existing PyTorch modelsinto your project.However, for small models or graphs of operations,you might benefit from a more immediate workflow.What if you could define the individual elements of your graph in Swift?Well, this year we’re introducing a new API that does just thatBNNSGraphBuilder.

The new BNNSGraphBuilder API enables you to write graphsof operations using the familiar Swift language.You can write pre- and post-processing routinesor small machine learning models directly in Swift.You create a context from that Swift code with a single function calland no intermediate steps.Writing your graphs in Swift and inline with your other codebrings some immediate benefits.You use a familiar language and your graph is type-checkedwhen your Swift project is compiled.You can also share values between Swift and your graphthat are known at runtime but before you generate the graph.For example, if you know a tensor’s shape at runtimebefore you initialise the graph,you can pass the shape directly into the graph code,and benefit from the better performance of static sizes over flexible sizes.

BNNSGraphBuilder also allows you to query intermediate tensorsfor properties such as shape and data type, and this helps you to debug graphs.And type tensors allows Xcode to autocompleteand reduces the chance of runtime errors.Let’s look at the new syntax, type checking, new methods and operators,and how to query intermediate tensors,all features that were not previously available.

This year we’ve added a new type method to the BNNSGraph object,named makeContext.It is this new method that converts your Swift code to a reusable contextthat you use to execute your graph.You only make the context once, typically while your app is starting up.Then your app executes the context when required,and it benefits from the optimizations that treatingthe graph holistically brings.Now for some live coding to see makeContext in action.

This method accepts a closure, and it’s that closure that you useto define the series of operations that constitute your graph.

Your graph will typically accept one or more arguments.Here, I’ll use the closure’s builder parameter to specify the two arguments,x and y.

The parameters are both eight element vectors of float values.In this example the graph performs an element-wise multiplicationon the two input arguments,and writes the result to the output argument that I have named product.My graph also calculates the mean value of the productand writes that value to a second output argument I have named mean,and finally, the code returns those two output arguments.

To aid debugging, we can print out details of the intermediateand output tensors that BNNSGraphBuilder generates.

In this example,I’ve printed the shape of the mean to ensure it’s got a shape of one,that is, it only contains one element.Once the context is created,you can query it to derive the arguments and their positions.Here, the code queries the context’s argument namesand creates an array of tensorsthat represent the graph’s outputs and inputs.BNNSGraph orders argument namesso that the outputs are first and the inputs follow.

The BNNSGraphBuilder API provides a rich set of functionsfor initializing arguments from different data sources,and either copying or referencing data.In this example, the code initializes the inputs from Swift arrays.

With the input and output arguments allocated,calling execute function executes the graphand populates the two outputs with the results.

And we can print out the results by running the function.

We’re not limited to just multiplying and calculating averages though.Let’s take a quick tour around BNNSGraphBuilderand explore some of the other operations that the new API provides.Here’s just a tiny selection of the primitives includedin BNNSGraphBuilder.For example, matrix multiplication and convolution, reduction operations,gather and scatter operations,and operations such as padding, reshape and transpose.Our new API supports many operations as simple, Swift operators.So we have arithmetic operators, multiplication,addition, subtraction and division.We also have element-wise comparison operators including equality,less than, and greater than.And to complete the set, we have element-wise logical operators.OK, that’s a quick introduction to the API itself.Let’s take a deep dive into two features of the GraphBuilder APIthat will be very familiar Swift developers, starting with strong typing.

Strong typing helps you catch errors at compile timethat otherwise may happen at runtime.The BNNSGraphBuilder API ensures that the data type for tensorsis correct for a given operation.Let's look at this in action.In this example, the graph returns the element-wise resultsof floating-point base values raised to the power of integer exponents.

It’s able to perform this calculation by casting the integer exponents to FP16.

Attempting to perform this without the cast would preventthe make context method from compiling.The graph also masks the result by zeroing out elements where the valuesin mask 0 are less than the corresponding values in mask 1.

Because the tensor elements that the comparison generates are Boolean,the graph performs another cast in order to multiply the results by the condition.Once again, without the cast operation, the make context method wouldn’t compile.And it’s always best to catch this type of error at compile timeand before your app is in the hands of your users.That's strong typing in action.Let’s now take a look at BNNSGraphBuilder’s approach to slicing,that is selecting parts with tensor.And this too will be very familiar to Swift developers.

A slice is effectively a window onto a specific part of a tensor.For example, a slice may be a single column or row of a matrix.The great thing about BNNSGraph is that it treats slicesas references to existing data,without the overhead of copying that data or allocating more memory.Slicing tensors is a common operation.Our new GraphBuilder API allows you to specify slices of a tensoras the source or destination operations.

For example, you might want to crop an image to a region of interest beforepassing it to a machine learning model.Let’s look at how easy it is to use the GraphBuilder APIto select a square region from the centre of this photographof a squirrel enjoying its lunch.

We’ll define two vImage pixel buffers. Pixel buffers store in images pixel data,dimensions, bit depth and number of channels.The first buffer, source, contains a photograph of the squirrel.The second pixel buffer, Destination, will contain the square crop.Each pixel buffer is three channels, red, green and blue,and each channel is 32-bit floating point format.You can learn more about vImage pixel buffers in our vImage documentation.

The horizontal and vertical margins ensure that the 640 by 640 cropis centered on the source image.And here’s a graph that uses the slice operation to perform the crop.First, we’ll define the source as an argumentand specify the height and width as flexible sizes.

Passing a negative value, minus 1 in this case, tells BNNSGraphthat those dimensions might be any value.The final value in the shape 3 specifies that the image contains three channels:red, green and blue.

The BNNSGraphBuilder API uses Swift subscripts to perform a slice operation.In this example, the code uses the new SliceRange structure.The start indices for both the vertical and horizontal dimensionsare the corresponding margin values.Setting the end indices as the negative margin value indicates that the end indexis the end value of that dimension minus the margin.

In this example we don’t want to crop along the channel dimension,and the code specifies fillAll to ensure that we include all three channels.

This year we’re also introducing a new method for vImage pixel buffers.The withBNNSTensor method allows you to create a temporary BNNSTensor thatshares memory and properties such as size and channel count with the pixel buffer.As the code here demonstrates, the new method makes passing images toand from your graph super easy.And because memory is shared, there’s no copying or allocating, and that meansyou get great performance when working with images.

After the execute function method returns, the destination pixel buffercontains a cropped image.And we can double check our squirrel is safely croppedby creating a core graphics image of the result.In addition to the new GraphBuilder slice range structure,the tensor slicing API supports all the Swift range types.So, whatever your slicing needs, we have you covered.And that is a brief overview of slicing.

Now we’ve taken a look at BNNSGraphBuilder and some of its features,let's dive into some use cases.

BNNSGraphBuilder is a great API to construct graphs of operationsfor pre- and post-processing data that you pass to or receive from ML models.One pre-processing technique is to threshold an image.That is to convert a continuous tone image to a binary imagethat contains just black or white pixels.Let’s take a look at how we can implement this using the GraphBuilder.

Before we start writing the graph, we’ll again define some vImage pixel buffers.The first stores the source image, and the second is the destinationthat receives the thresholded image.Both of these pixel buffers are single channel, 16-bit floating point format.

The first step in the graph is to define the source,which represents the input image.The code passes negative values for the image sizeto specify the graph supports any image size,but does however specify the FP16 data typethat matches the pixel buffers.Calculating the average value of the continuous grayscale pixelsis simply a matter of calling the mean method.The element wise is greater than operator populatesthe thresholded tensor with ones for corresponding pixelsof the value greater than the average pixel value, and zeros otherwise.

And finally, the graph casts the Boolean ones and zerosto the bit-depth of the destination pixel buffer.We’ll use the withBNNSTensor method again to pass the two image buffersto the context and execute the function to generate the thresholded image.

After passing this continuous-toned grayscale image of a pair of pelicansin flight to the graphWe get this thresholded image where all the pixels are either black or white.

Another use case for the BNNSGraphBuilder APIis post-processing the results of a machine learning model.

For example, let’s say we want to apply a softmax function followedby a topK operation to the results of an ML model.Here, the post-process function creates a small graph on the fly.The graph declares an input argument based on the function’s input tensor.It then applies a softmax operation to the input argument,and then calculates its topK values and indices.Note that the k parameter the code passes to the topK function is actually definedoutside of the make context closure.Lastly, the graph returns the topK results.After defining the graph, the function declares the tensors that storethe results, and passes the output and input tensors to the context.Finally, the makeArray method converts the topK values and indicesto Swift arrays and returns those.

There we have some examples of pre- and post-processing datawith the GraphBuilder API.Now, let’s take a look at last year’s Bitcrusher demonstrationand update the Swift piece to use BNNSGraphBuilder.This code demonstrates how BNNSGraph makes adding ML-based audio effects super easy.

Last year, we demonstrated BNNSGraph by incorporating itinto an Audio Unit extension app.This app added a real-time Bitcrusher effect to an audio signal,and the demonstration used Swift to apply the same effect to a sine waveto display a visual representation of the effect in the user interface.For example, given this sine wave, the graph is able to reduce the resolutionto add distortion to the sound, and the visual representation showsthe sine wave as a discrete series of steps rather than a continuous wave.We also included saturation gain to add a richness to the sound.Last year’s demonstration used a CoreML packagethat was based on PyTorch code.So, let’s take last year’s code and compare it againstthe same functionality written in Swift using the new GraphBuilder API.Here’s the PyTorch on the left and the new Swift code on the right.One immediate difference is that Swift uses let and varto define intermediate tensors,so you’re free to decide if these are immutable or mutable.You don’t need any extra imports to access the full rangeof available operations.Furthermore, operations such as, in this case tanh,are methods on tensors rather than free functions.

Element-wise arithmetic operators are the samewith the two different approaches.

Another difference though is that the make context closure can returnmore than one output tensor, so you always return an array.The Swift GraphBuilder allows you to define input arguments insidethe make context closure.If you have an existing PyTorch model, we still recommend usingthat code and the existing file-based API.But, for new projects, our new GraphBuilder API allows youto write graphs using Swift, and as this comparison demonstrates,with a similar structure to the same set of operations written using PyTorch.Furthermore, we can demonstrate BNNSGraph’s 16-bit support, and how,in this example, it is significantly faster than the FP32 operations.Here’s our Swift code again, but this time using a type aliasto specify the precision.

Changing the type alias changes the graph to use FP16 rather than FP32.In this example, FP16 is much faster than the FP32 equivalent.

To wrap up, BNNSGraphBuilder provides an easy to use Swift API that allows youto write high-performance and energy-efficient modelsand graphs-of-operations.It’s great for real-time and latency-sensitive use cases,but its user-friendly programming interfacemeans it can be used for a wide range of applications.Before I go, please allow me to suggest that you head overto our documentation page where you’ll find plentyof reference material that discusses BNNSGraph and BNNSGraphBuilder.Also, be sure to check out our video from last year, where I talkabout the file-based API and using BNNSGraph in C.

Many thanks for your time today and best wishes.

8:31 -Introduction to BNNSGraphBuilder

12:04 -Strong typing

14:15 -Slicing

17:31 -Preprocessing by thresholding on mean

19:04 -Postprocessing

21:03 -Bitcrusher in PyTorch

21:03 -Bitcrusher in Swift

22:34 -Changing precision

0:00 -IntroductionThe Apple Vector and Numerics Group developed BNNS, a machine-learning library for CPU-based inference in apps, particularly useful for real-time audio and image processing. 

BNNSGraph, introduced last year, enhanced speed, efficiency, and ease of use. Now, BNNSGraphBuilder is added, enabling Swift-based creation of small models and graphs for pre- and post-processing. This is demonstrated with image preprocessing, data post-processing, and updating the Bitcrusher audio unit sample.3:12 -Recapping BNNSGraphBNNSGraph is recommended for audio and low-latency tasks with real-time deadlines because it allows memory and multithreading control, enhancing real-time performance. 

Previously, BNNS required coding each layer manually, but now BNNSGraph takes entire graphs as objects, optimizing performance and energy efficiency through combining mathematical transformations, layer fusion, copy elision, and tensor memory sharing.

BNNSGraph offers two main workflows: using a CoreML Package and Xcode compilation, or defining the graph directly in Swift for smaller models with BNNSGraphBuilder.6:15 -BNNSGraphBuilderA new API called BNNSGraphBuilder lets developers construct graphs of operations directly in Swift. This enables the creation of pre- and post-processing routines and small machine learning models within Swift code.

The benefits include using a familiar language, type-checking during compilation, and the ability to share runtime values between Swift and the graph, leading to improved performance. The API also provides debugging features, such as querying intermediate tensors for properties like shape and data type, and enables Xcode autocomplete.

A new type method, 'makeContext', converts Swift code to a reusable context for graph execution. The context is created once during app startup and can then be executed multiple times, benefiting from wholistic graph optimizations. The API offers a wide range of mathematical and logical operations, as well as support for common neural network primitives like matrix multiplication, convolution, and reduction operations.

The BNNSGraphBuilder API in Swift leverages strong typing to catch errors at compile time, ensuring data type correctness for tensor operations. This is demonstrated through automatic casting of data types, such as integers to FP16, which prevents compilation errors and enhances app reliability.

The API also treats tensor slices as references to existing data, optimizing memory usage. Slicing tensors is performed using Swift subscripts and the new SliceRange structure, making it intuitive for Swift developers. This allows for efficient operations like image cropping, as shown in an example where a square region is cropped from a photograph of a squirrel using vImage pixel buffers and the 'withBNNSTensor' method, which shares memory for improved performance.16:58 -Using BNNSGraphBuilderBNNSGraphBuilder is a powerful API in Swift that helps you construct graphs of operations for efficient data pre- and post-processing in machine learning applications utilizing audio and images.

For pre-processing, use the API to threshold images, converting continuous-tone images to binary images. You can also use it for post-processing tasks such as applying softmax functions and topK operations to the results of ML models.

The API demonstrates its versatility by being applied to audio effects as well. It allows you to create real-time audio effects like bitcrushing, with significant performance improvements when using 16-bit precision compared to 32-bit.

BNNSGraphBuilder offers a user-friendly programming interface, making it accessible for a wide range of applications, from real-time and latency-sensitive use cases to general-purpose ML tasks.

0:00 -Introduction

The Apple Vector and Numerics Group developed BNNS, a machine-learning library for CPU-based inference in apps, particularly useful for real-time audio and image processing. 

BNNSGraph, introduced last year, enhanced speed, efficiency, and ease of use. Now, BNNSGraphBuilder is added, enabling Swift-based creation of small models and graphs for pre- and post-processing. This is demonstrated with image preprocessing, data post-processing, and updating the Bitcrusher audio unit sample.

The Apple Vector and Numerics Group developed BNNS, a machine-learning library for CPU-based inference in apps, particularly useful for real-time audio and image processing. 

BNNSGraph, introduced last year, enhanced speed, efficiency, and ease of use. Now, BNNSGraphBuilder is added, enabling Swift-based creation of small models and graphs for pre- and post-processing. This is demonstrated with image preprocessing, data post-processing, and updating the Bitcrusher audio unit sample.

3:12 -Recapping BNNSGraph

BNNSGraph is recommended for audio and low-latency tasks with real-time deadlines because it allows memory and multithreading control, enhancing real-time performance. 

Previously, BNNS required coding each layer manually, but now BNNSGraph takes entire graphs as objects, optimizing performance and energy efficiency through combining mathematical transformations, layer fusion, copy elision, and tensor memory sharing.

BNNSGraph offers two main workflows: using a CoreML Package and Xcode compilation, or defining the graph directly in Swift for smaller models with BNNSGraphBuilder.

BNNSGraph is recommended for audio and low-latency tasks with real-time deadlines because it allows memory and multithreading control, enhancing real-time performance. 

Previously, BNNS required coding each layer manually, but now BNNSGraph takes entire graphs as objects, optimizing performance and energy efficiency through combining mathematical transformations, layer fusion, copy elision, and tensor memory sharing.

BNNSGraph offers two main workflows: using a CoreML Package and Xcode compilation, or defining the graph directly in Swift for smaller models with BNNSGraphBuilder.

6:15 -BNNSGraphBuilder

A new API called BNNSGraphBuilder lets developers construct graphs of operations directly in Swift. This enables the creation of pre- and post-processing routines and small machine learning models within Swift code.

The benefits include using a familiar language, type-checking during compilation, and the ability to share runtime values between Swift and the graph, leading to improved performance. The API also provides debugging features, such as querying intermediate tensors for properties like shape and data type, and enables Xcode autocomplete.

A new type method, 'makeContext', converts Swift code to a reusable context for graph execution. The context is created once during app startup and can then be executed multiple times, benefiting from wholistic graph optimizations. The API offers a wide range of mathematical and logical operations, as well as support for common neural network primitives like matrix multiplication, convolution, and reduction operations.

The BNNSGraphBuilder API in Swift leverages strong typing to catch errors at compile time, ensuring data type correctness for tensor operations. This is demonstrated through automatic casting of data types, such as integers to FP16, which prevents compilation errors and enhances app reliability.

The API also treats tensor slices as references to existing data, optimizing memory usage. Slicing tensors is performed using Swift subscripts and the new SliceRange structure, making it intuitive for Swift developers. This allows for efficient operations like image cropping, as shown in an example where a square region is cropped from a photograph of a squirrel using vImage pixel buffers and the 'withBNNSTensor' method, which shares memory for improved performance.

A new API called BNNSGraphBuilder lets developers construct graphs of operations directly in Swift. This enables the creation of pre- and post-processing routines and small machine learning models within Swift code.

The benefits include using a familiar language, type-checking during compilation, and the ability to share runtime values between Swift and the graph, leading to improved performance. The API also provides debugging features, such as querying intermediate tensors for properties like shape and data type, and enables Xcode autocomplete.

A new type method, 'makeContext', converts Swift code to a reusable context for graph execution. The context is created once during app startup and can then be executed multiple times, benefiting from wholistic graph optimizations. The API offers a wide range of mathematical and logical operations, as well as support for common neural network primitives like matrix multiplication, convolution, and reduction operations.

The BNNSGraphBuilder API in Swift leverages strong typing to catch errors at compile time, ensuring data type correctness for tensor operations. This is demonstrated through automatic casting of data types, such as integers to FP16, which prevents compilation errors and enhances app reliability.

The API also treats tensor slices as references to existing data, optimizing memory usage. Slicing tensors is performed using Swift subscripts and the new SliceRange structure, making it intuitive for Swift developers. This allows for efficient operations like image cropping, as shown in an example where a square region is cropped from a photograph of a squirrel using vImage pixel buffers and the 'withBNNSTensor' method, which shares memory for improved performance.

16:58 -Using BNNSGraphBuilder

BNNSGraphBuilder is a powerful API in Swift that helps you construct graphs of operations for efficient data pre- and post-processing in machine learning applications utilizing audio and images.

For pre-processing, use the API to threshold images, converting continuous-tone images to binary images. You can also use it for post-processing tasks such as applying softmax functions and topK operations to the results of ML models.

The API demonstrates its versatility by being applied to audio effects as well. It allows you to create real-time audio effects like bitcrushing, with significant performance improvements when using 16-bit precision compared to 32-bit.

BNNSGraphBuilder offers a user-friendly programming interface, making it accessible for a wide range of applications, from real-time and latency-sensitive use cases to general-purpose ML tasks.

BNNSGraphBuilder is a powerful API in Swift that helps you construct graphs of operations for efficient data pre- and post-processing in machine learning applications utilizing audio and images.

For pre-processing, use the API to threshold images, converting continuous-tone images to binary images. You can also use it for post-processing tasks such as applying softmax functions and topK operations to the results of ML models.

The API demonstrates its versatility by being applied to audio effects as well. It allows you to create real-time audio effects like bitcrushing, with significant performance improvements when using 16-bit precision compared to 32-bit.

BNNSGraphBuilder offers a user-friendly programming interface, making it accessible for a wide range of applications, from real-time and latency-sensitive use cases to general-purpose ML tasks.

## Code Samples

```swift
import
 Accelerate




func
 
demo
() 
throws
 {

    
let
 context 
=
 
try
 
BNNSGraph
.makeContext {
        builder 
in

     
        
let
 x 
=
 builder.argument(name: 
"x"
,
                                 dataType: 
Float
.
self
,
                                 shape: [
8
])
        
let
 y 
=
 builder.argument(name: 
"y"
,
                                 dataType: 
Float
.
self
,
                                 shape: [
8
])
        
        
let
 product 
=
 x 
*
 y
        
let
 mean 
=
 product.mean(axes: [
0
], keepDimensions: 
true
)
        
        
// Prints "shape: [1] | stride: [1]".

        
print
(
"mean"
, mean)
        
        
return
 [ product, mean]
    }
    
    
var
 args 
=
 context.argumentNames().map {
        name 
in

        
return
 context.tensor(argument: name,
                              fillKnownDynamicShapes: 
false
)
!

    }
    
    
// Output arguments

    args[
0
].allocate(as: 
Float
.
self
, count: 
8
)
    args[
1
].allocate(as: 
Float
.
self
, count: 
1
)
    
    
// Input arguments

    args[
2
].allocate(
        initializingFrom: [
1
, 
2
, 
3
, 
4
, 
5
, 
6
, 
7
, 
8
] 
as
 [
Float
])
    args[
3
].allocate(
        initializingFrom: [
8
, 
7
, 
6
, 
5
, 
4
, 
3
, 
2
, 
1
] 
as
 [
Float
])

        
try
 context.executeFunction(arguments: 
&
args)
    
    
// [8.0, 14.0, 18.0, 20.0, 20.0, 18.0, 14.0, 8.0]

    
print
(args[
0
].makeArray(of: 
Float
.
self
))
    
    
// [15.0]

    
print
(args[
1
].makeArray(of: 
Float
.
self
))
    
    args.forEach {
        
$0
.deallocate()
    }
}
```

```swift
// Performs `result = mask0 .< mask1 ? bases.pow(exponents) : 0



let
 context 
=
 
try
 
BNNSGraph
.makeContext {
    builder 
in

    
    
let
 mask0 
=
 builder.argument(dataType: 
Float16
.
self
,
                                 shape: [
-
1
])
    
let
 mask1 
=
 builder.argument(dataType: 
Float16
.
self
,
                                 shape: [
-
1
])
    
    
let
 bases 
=
 builder.argument(dataType: 
Float16
.
self
,
                                 shape: [
-
1
])
    
let
 exponents 
=
 builder.argument(dataType: 
Int32
.
self
,
                                     shape: [
-
1
])
    
    
// `mask` contains Boolean values.

    
let
 mask 
=
 mask0 
.<
 mask1
    
    
// Cast integer exponents to FP16.

    
var
 result 
=
 bases.pow(y: exponents.cast(to: 
Float16
.
self
))
    result 
=
 result 
*
 mask.cast(to: 
Float16
.
self
)
    
    
return
 [result]
}
```

```swift
let
 srcImage 
=
 
#imageLiteral
(resourceName: 
"squirrel.jpeg"
).cgImage(
    forProposedRect: 
nil
,
    context: 
nil
,
    hints: 
nil
)
!



var
 cgImageFormat 
=
 vImage_CGImageFormat(
    bitsPerComponent: 
32
,
    bitsPerPixel: 
32
 
*
 
3
,
    colorSpace: 
CGColorSpaceCreateDeviceRGB
(),
    bitmapInfo: 
CGBitmapInfo
(alpha: .none,
                             component: .float,
                             byteOrder: .order32Host))
!



let
 source 
=
 
try
 vImage.
PixelBuffer
(cgImage: srcImage,
                                    cgImageFormat: 
&
cgImageFormat,
                                    pixelFormat: vImage.
InterleavedFx3
.
self
)


let
 cropSize 
=
 
640


let
 horizontalMargin 
=
 (source.width 
-
 cropSize) 
/
 
2


let
 verticalMargin 
=
 (source.height 
-
 cropSize) 
/
 
2



let
 destination 
=
 vImage.
PixelBuffer
(size: .
init
(width: cropSize,
                                                 height: cropSize),
                                     pixelFormat: vImage.
InterleavedFx3
.
self
)


let
 context 
=
 
try
 
BNNSGraph
.makeContext {
    builder 
in

    
    
let
 src 
=
 builder.argument(name: 
"source"
,
                               dataType: 
Float
.
self
,
                               shape: [ 
-
1
, 
-
1
, 
3
])
    
    
let
 result 
=
 src [
        
BNNSGraph
.
Builder
.
SliceRange
(startIndex: verticalMargin,
                                     endIndex: 
-
verticalMargin),
        
BNNSGraph
.
Builder
.
SliceRange
(startIndex: horizontalMargin,
                                     endIndex: 
-
horizontalMargin),
        
BNNSGraph
.
Builder
.
SliceRange
.fillAll
    ]
    
    
return
 [result]
}

source.withBNNSTensor { src 
in

    destination.withBNNSTensor { dst 
in

        
        
var
 args 
=
 [dst, src]
        
        
print
(src)
        
print
(dst)
        
        
try!
 context.executeFunction(arguments: 
&
args)
    }
}


let
 result 
=
 destination.makeCGImage(cgImageFormat: cgImageFormat)
```

```swift
let
 srcImage 
=
 
#imageLiteral
(resourceName: 
"birds.jpeg"
).cgImage(
    forProposedRect: 
nil
,
    context: 
nil
,
    hints: 
nil
)
!



var
 cgImageFormat 
=
 vImage_CGImageFormat(
    bitsPerComponent: 
16
,
    bitsPerPixel: 
16
,
    colorSpace: 
CGColorSpaceCreateDeviceGray
(),
    bitmapInfo: 
CGBitmapInfo
(rawValue: 
CGBitmapInfo
.byteOrder16Little.rawValue 
|

                             
CGBitmapInfo
.floatComponents.rawValue 
|

                             
CGImageAlphaInfo
.none.rawValue))
!



let
 source 
=
 
try!
 vImage.
PixelBuffer
<vImage.
Planar16F
>(cgImage: srcImage,
                                                       cgImageFormat: 
&
cgImageFormat)

let
 destination 
=
 vImage.
PixelBuffer
<vImage.
Planar16F
>(size: source.size)


let
 context 
=
 
try
 
BNNSGraph
.makeContext {
    builder 
in

    
    
let
 src 
=
 builder.argument(name: 
"source"
,
                               dataType: 
Float16
.
self
,
                               shape: [
-
1
, 
-
1
, 
1
])
    
    
let
 mean 
=
 src.mean(axes: [
0
, 
1
], keepDimensions: 
false
)
    
    
let
 thresholded 
=
 src 
.>
 mean
    
    
let
 result 
=
 thresholded.cast(to: 
Float16
.
self
)
    
    
return
 [result]
}

source.withBNNSTensor { src 
in

    destination.withBNNSTensor { dst 
in

        
        
var
 args 
=
 [dst, src]
        
        
try!
 context.executeFunction(arguments: 
&
args)
    }
}


let
 result 
=
 destination.makeCGImage(cgImageFormat: cgImageFormat)
```

```swift
func
 
postProcess
(
result
: 
BNNSTensor
, 
k
: 
Int
) 
throws
 -> ([
Float32
], [
Int32
]) {
    
    
let
 context 
=
 
try
 
BNNSGraph
.makeContext {
        builder 
in

        
        
let
 x 
=
 builder.argument(dataType: 
Float32
.
self
,
                                 shape: [
-
1
])
        
        
let
 softmax 
=
 x.softmax(axis: 
1
)
        
        
let
 topk 
=
 softmax.topK(k, axis: 
1
, findLargest: 
true
)
        
        
return
 [topk.values, topk.indices]
    }
    
    
let
 indices 
=
 context.allocateTensor(argument: context.argumentNames()[
0
],
                                         fillKnownDynamicShapes: 
false
)
!

    
let
 values 
=
 context.allocateTensor(argument: context.argumentNames()[
1
],
                                        fillKnownDynamicShapes: 
false
)
!

    
    
var
 arguments 
=
 [values, indices, result]
    
    
try
 context.executeFunction(arguments: 
&
arguments)
    
    
return
 (values.makeArray(of: 
Float32
.
self
), indices.makeArray(of: 
Int32
.
self
))
}
```

```swift
import
 coremltools 
as
 ct

from
 coremltools.converters.mil 
import
 Builder 
as
 mb

from
 coremltools.converters.mil.mil 
import
 (
    get_new_symbol
)


import
 torch

import
 torch.nn 
as
 nn

import
 torch.nn.functional 
as
 F


class
 
BitcrusherModel
(nn.Module):
    
def
 
__init__
(
self
):
        
super
(BitcrusherModel, self).__init__()

    
def
 
forward
(
self, source, resolution, saturationGain, dryWet
):
        
# saturation

        destination = source * saturationGain
        destination = F.tanh(destination)

        
# quantization

        destination = destination * resolution
        destination = torch.
round
(destination)
        destination = destination / resolution

        
# mix

        destination = destination * dryWet
        destination = 
1.0
 - dryWet
        source = source * dryWet
        
        destination = destination + source
        
        
return
 destination
```

```swift
typealias
 
BITCRUSHER_PRECISION
 
=
 
Float16

    

let
 context 
=
 
try!
 
BNNSGraph
.makeContext {
    builder 
in

    
    
var
 source 
=
 builder.argument(name: 
"source"
,
                                  dataType: 
BITCRUSHER_PRECISION
.
self
,
                                  shape: [sampleCount, 
1
, 
1
])
    
    
let
 resolution 
=
 builder.argument(name: 
"resolution"
,
                                      dataType: 
BITCRUSHER_PRECISION
.
self
,
                                      shape: [
1
, 
1
, 
1
])
    
    
let
 saturationGain 
=
 builder.argument(name: 
"saturationGain"
,
                                          dataType: 
BITCRUSHER_PRECISION
.
self
,
                                          shape: [
1
, 
1
, 
1
])
    
    
var
 dryWet 
=
 builder.argument(name: 
"dryWet"
,
                                  dataType: 
BITCRUSHER_PRECISION
.
self
,
                                  shape: [
1
, 
1
, 
1
])
    
    
// saturation

    
var
 destination 
=
 source 
*
 saturationGain
    destination 
=
 destination.tanh()
    
    
// quantization

    
    destination 
=
 destination 
*
 resolution
    destination 
=
 destination.round()
    destination 
=
 destination 
/
 resolution
    
    
// mix

    destination 
=
 destination 
*
 dryWet
    dryWet 
=
 
BITCRUSHER_PRECISION
(
1
) 
-
 dryWet
    source 
=
 source 
*
 dryWet
    
    destination 
=
 destination 
+
 source
    
    
return
 [destination]
}
```

